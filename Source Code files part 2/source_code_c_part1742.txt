eter            */
    TW_INT16    dataArgType;    /* DSM_Entry dataArgType parameter          */
    TW_INT16    message;        /* DSM_Entry message parameter              */
    TW_INT32    pDataSize;      /* Size of pData (0 if NULL)                */
    //  TW_MEMREF   pData;      /* Based on implementation specifics, a     */
                                /* pData parameter makes no sense in this   */
                                /* structure, but data (if provided) will be*/
                                /* appended in the data block.              */
   } TW_TWUNKDSENTRYPARAMS, FAR * pTW_TWUNKDSENTRYPARAMS;

/* SDH - 03/21/95 - TWUNK */
/* Provides DS_Entry results over thunk link. */
typedef struct
{
    TW_UINT16   returnCode;     /* Thunker DsEntry return code.             */
    TW_UINT16   conditionCode;  /* Thunker DsEntry condition code.          */
    TW_INT32    pDataSize;      /* Size of pData (0 if NULL)                */
    //  TW_MEMREF   pData;      /* Based on implementation specifics, a     */
                                /* pData parameter makes no sense in this   */
                                /* structure, but data (if provided) will be*/
                                /* appended in the data block.              */
} TW_TWUNKDSENTRYRETURN, FAR * pTW_TWUNKDSENTRYRETURN;

/* WJD - 950818 */
/* Added for 1.6 Specification */
/* TWAIN 1.6 CAP_SUPPORTEDCAPSEXT structure */
typedef struct
{
    TW_UINT16 Cap;   /* Which CAP/ICAP info is relevant to */
    TW_UINT16 Properties;  /* Messages this CAP/ICAP supports */
} TW_CAPEXT, FAR * pTW_CAPEXT;

/* ----------------------------------------------------------------------- *\

  Version 1.7:      Added Following data structure for Document Imaging
  July 1997         Enhancement.
  KHL               TW_CUSTOMDSDATA --  For Saving and Restoring Source's
                                        state.
                    TW_INFO         --  Each attribute for extended image
                                        information.
                    TW_EXTIMAGEINFO --  Extended image information structure.

\* ----------------------------------------------------------------------- */

typedef struct {
    TW_UINT32  InfoLength;     /* Length of Information in bytes.  */
    TW_HANDLE  hData;          /* Place holder for data, DS Allocates */
}TW_CUSTOMDSDATA, FAR *pTW_CUSTOMDSDATA;

typedef struct {
    TW_UINT16   InfoID;
    TW_UINT16   ItemType;
    TW_UINT16   NumItems;
    TW_UINT16   CondCode;
    TW_UINT32   Item;
}TW_INFO, FAR* pTW_INFO;

typedef struct {
    TW_UINT32   NumInfos;
    TW_INFO     Info[1];
}TW_EXTIMAGEINFO, FAR* pTW_EXTIMAGEINFO;

/****************************************************************************
 * Generic Constants                                                        *
 ****************************************************************************/

#define TWON_ARRAY           3 /* indicates TW_ARRAY container       */
#define TWON_ENUMERATION     4 /* indicates TW_ENUMERATION container */
#define TWON_ONEVALUE        5 /* indicates TW_ONEVALUE container    */
#define TWON_RANGE           6 /* indicates TW_RANGE container       */

#define TWON_ICONID          962 /* res Id of icon used in USERSELECT lbox */
#define TWON_DSMID           461 /* res Id of the DSM version num resource */
#define TWON_DSMCODEID       63  /* res Id of the Mac SM Code resource     */

#define TWON_DONTCARE8       0xff
#define TWON_DONTCARE16      0xffff
#define TWON_DONTCARE32      0xffffffff

/* Flags used in TW_MEMORY structure. */
#define TWMF_APPOWNS     0x1
#define TWMF_DSMOWNS     0x2
#define TWMF_DSOWNS      0x4
#define TWMF_POINTER     0x8
#define TWMF_HANDLE      0x10

/* Palette types for TW_PALETTE8 */
#define TWPA_RGB         0
#define TWPA_GRAY        1
#define TWPA_CMY         2

/* There are four containers used for capabilities negotiation:
 *    TWON_ONEVALUE, TWON_RANGE, TWON_ENUMERATION, TWON_ARRAY
 * In each container structure ItemType can be TWTY_INT8, TWTY_INT16, etc.
 * The kind of data stored in the container can be determined by doing
 * DCItemSize[ItemType] where the following is defined in TWAIN glue code:
 *          DCItemSize[]= { sizeof(TW_INT8),
 *                          sizeof(TW_INT16),
 *                          etc.
 *                          sizeof(TW_UINT32) };
 *
 */

#define TWTY_INT8        0x0000    /* Means Item is a TW_INT8   */
#define TWTY_INT16       0x0001    /* Means Item is a TW_INT16  */
#define TWTY_INT32       0x0002    /* Means Item is a TW_INT32  */

#define TWTY_UINT8       0x0003    /* Means Item is a TW_UINT8  */
#define TWTY_UINT16      0x0004    /* Means Item is a TW_UINT16 */
#define TWTY_UINT32      0x0005    /* Means Item is a TW_UINT32 */

#define TWTY_BOOL        0x0006    /* Means Item is a TW_BOOL   */

#define TWTY_FIX32       0x0007    /* Means Item is a TW_FIX32  */

#define TWTY_FRAME       0x0008    /* Means Item is a TW_FRAME  */

#define TWTY_STR32       0x0009    /* Means Item is a TW_STR32  */
#define TWTY_STR64       0x000a    /* Means Item is a TW_STR64  */
#define TWTY_STR128      0x000b    /* Means Item is a TW_STR128 */
#define TWTY_STR255      0x000c    /* Means Item is a TW_STR255 */

/****************************************************************************
 * Capability Constants                                                     *
 ****************************************************************************/

/* ICAP_BITORDER values (BO_ means Bit Order) */
#define TWBO_LSBFIRST    0
#define TWBO_MSBFIRST    1

/* ICAP_COMPRESSION values (CP_ means ComPression ) */
#define TWCP_NONE        0
#define TWCP_PACKBITS    1
#define TWCP_GROUP31D    2 /* Follows CCITT spec (no End Of Line)          */
#define TWCP_GROUP31DEOL 3 /* Follows CCITT spec (has End Of Line)         */
#define TWCP_GROUP32D    4 /* Follows CCITT spec (use cap for K Factor)    */
#define TWCP_GROUP4      5 /* Follows CCITT spec                           */
#define TWCP_JPEG        6 /* Use capability for more info                 */
#define TWCP_LZW         7 /* Must license from Unisys and IBM to use      */
#define TWCP_JBIG        8 /* For Bitonal images  -- Added 1.7 KHL         */

/* ICAP_IMAGEFILEFORMAT values (FF_means File Format)   */
#define TWFF_TIFF        0    /* Tagged Image File Format     */
#define TWFF_PICT        1    /* Macintosh PICT               */
#define TWFF_BMP         2    /* Windows Bitmap               */
#define TWFF_XBM         3    /* X-Windows Bitmap             */
#define TWFF_JFIF        4    /* JPEG File Interchange Format */

/* ICAP_FILTER values (FT_ means Filter Type) */
#define TWFT_RED         0
#define TWFT_GREEN       1
#define TWFT_BLUE        2
#define TWFT_NONE        3
#define TWFT_WHITE       4
#define TWFT_CYAN        5
#define TWFT_MAGENTA     6
#define TWFT_YELLOW      7
#define TWFT_BLACK       8

/* ICAP_LIGHTPATH values (LP_ means Light Path) */
#define TWLP_REFLECTIVE   0
#define TWLP_TRANSMISSIVE 1

/* ICAP_LIGHTSOURCE values (LS_ means Light Source) */
#define TWLS_RED         0
#define TWLS_GREEN       1
#define TWLS_BLUE        2
#define TWLS_NONE        3
#define TWLS_WHITE       4
#define TWLS_UV          5
#define TWLS_IR          6

/* ICAP_ORIENTATION values (OR_ means ORientation) */
#define TWOR_ROT0        0
#define TWOR_ROT90       1
#define TWOR_ROT180      2
#define TWOR_ROT270      3
#define TWOR_PORTRAIT    TWOR_ROT0
#define TWOR_LANDSCAPE   TWOR_ROT270

/* ICAP_PLANARCHUNKY values (PC_ means Planar/Chunky ) */
#define TWPC_CHUNKY      0
#define TWPC_PLANAR      1

/* ICAP_PIXELFLAVOR values (PF_ means Pixel Flavor) */
#define TWPF_CHOCOLATE   0  /* zero pixel represents darkest shade  */
#define TWPF_VANILLA     1  /* zero pixel represents lightest shade */

/* ICAP_PIXELTYPE values (PT_ means Pixel Type) */
#define TWPT_BW          0 /* Black and White */
#define TWPT_GRAY        1
#define TWPT_RGB         2
#define TWPT_PALETTE     3
#define TWPT_CMY         4
#define TWPT_CMYK        5
#define TWPT_YUV         6
#define TWPT_YUVK        7
#define TWPT_CIEXYZ      8

/* ICAP_SUPPORTEDSIZES values (SS_ means Supported Sizes) */
#define TWSS_NONE        0
#define TWSS_A4LETTER    1
#define TWSS_B5LETTER    2
#define TWSS_USLETTER    3
#define TWSS_USLEGAL     4
/* Added 1.5 */
#define TWSS_A5          5
#define TWSS_B4          6
#define TWSS_B6          7
//#define TWSS_B          8
/* Added 1.7 */
#define TWSS_USLEDGER    9
#define TWSS_USEXECUTIVE 10
#define TWSS_A3          11
#define TWSS_B3          12
#define TWSS_A6          13
#define TWSS_C4          14
#define TWSS_C5          15
#define TWSS_C6          16

/* ICAP_XFERMECH values (SX_ means Setup XFer) */
#define TWSX_NATIVE      0
#define TWSX_FILE        1
#define TWSX_MEMORY      2

/* ICAP_UNITS values (UN_ means UNits) */
#define TWUN_INCHES      0
#define TWUN_CENTIMETERS 1
#define TWUN_PICAS       2
#define TWUN_POINTS      3
#define TWUN_TWIPS       4
#define TWUN_PIXELS      5

/* Added 1.5 */
/* ICAP_BITDEPTHREDUCTION values (BR_ means Bitdepth Reduction) */
#define TWBR_THRESHOLD     0
#define TWBR_HALFTONE      1
#define TWBR_CUSTHALFTONE  2
#define TWBR_DIFFUSION     3

/* Added 1.7 */
/* ICAP_DUPLEX values */
#define TWDX_NONE         0
#define TWDX_1PASSDUPLEX  1
#define TWDX_2PASSDUPLEX  2

/* Added 1.7 */
/* TWEI_BARCODETYPE values */
#define TWBT_3OF9                 0
#define TWBT_2OF5INTERLEAVED      1
#define TWBT_2OF5NONINTERLEAVED   2
#define TWBT_CODE93               3
#define TWBT_CODE128              4
#define TWBT_UCC128               5
#define TWBT_CODABAR              6
#define TWBT_UPCA                 7
#define TWBT_UPCE                 8
#define TWBT_EAN8                 9
#define TWBT_EAN13                10
#define TWBT_POSTNET              11
#define TWBT_PDF417               12

/* Added 1.7 */
/* TWEI_DESKEWSTATUS values */
#define TWDSK_SUCCESS     0
#define TWDSK_REPORTONLY  1
#define TWDSK_FAIL        2
#define TWDSK_DISABLED    3

/* Added 1.7 */
/* TWEI_PATCHCODE values */
#define TWPCH_PATCH1      0
#define TWPCH_PATCH2      1
#define TWPCH_PATCH3      2
#define TWPCH_PATCH4      3
#define TWPCH_PATCH6      4
#define TWPCH_PATCHT      5

/* Added 1.7 */
/* CAP_JOBCONTROL values */
#define TWJC_NONE   0
#define TWJC_JSIC   1
#define TWJC_JSIS   2
#define TWJC_JSXC   3
#define TWJC_JSXS   4

/****************************************************************************
 * Country Constants                                                        *
 ****************************************************************************/

#define TWCY_AFGHANISTAN   1001
#define TWCY_ALGERIA        213
#define TWCY_AMERICANSAMOA  684
#define TWCY_ANDORRA        033
#define TWCY_ANGOLA        1002
#define TWCY_ANGUILLA      8090
#define TWCY_ANTIGUA       8091
#define TWCY_ARGENTINA       54
#define TWCY_ARUBA          297
#define TWCY_ASCENSIONI     247
#define TWCY_AUSTRALIA       61
#define TWCY_AUSTRIA         43
#define TWCY_BAHAMAS       8092
#define TWCY_BAHRAIN        973
#define TWCY_BANGLADESH     880
#define TWCY_BARBADOS      8093
#define TWCY_BELGIUM         32
#define TWCY_BELIZE         501
#define TWCY_BENIN          229
#define TWCY_BERMUDA       8094
#define TWCY_BHUTAN        1003
#define TWCY_BOLIVIA        591
#define TWCY_BOTSWANA       267
#define TWCY_BRITAIN          6
#define TWCY_BRITVIRGINIS  8095
#define TWCY_BRAZIL          55
#define TWCY_BRUNEI         673
#define TWCY_BULGARIA       359
#define TWCY_BURKINAFASO   1004
#define TWCY_BURMA         1005
#define TWCY_BURUNDI       1006
#define TWCY_CAMAROON       237
#define TWCY_CANADA           2
#define TWCY_CAPEVERDEIS    238
#define TWCY_CAYMANIS      8096
#define TWCY_CENTRALAFREP  1007
#define TWCY_CHAD          1008
#define TWCY_CHILE           56
#define TWCY_CHINA           86
#define TWCY_CHRISTMASIS   1009
#define TWCY_COCOSIS       1009
#define TWCY_COLOMBIA        57
#define TWCY_COMOROS       1010
#define TWCY_CONGO         1011
#define TWCY_COOKIS        1012
#define TWCY_COSTARICA     506
#define TWCY_CUBA           005
#define TWCY_CYPRUS         357
#define TWCY_CZECHOSLOVAKIA  42
#define TWCY_DENMARK         45
#define TWCY_DJIBOUTI      1013
#define TWCY_DOMINICA      8097
#define TWCY_DOMINCANREP   8098
#define TWCY_EASTERIS      1014
#define TWCY_ECUADOR        593
#define TWCY_EGYPT           20
#define TWCY_ELSALVADOR     503
#define TWCY_EQGUINEA      1015
#define TWCY_ETHIOPIA       251
#define TWCY_FALKLANDIS    1016
#define TWCY_FAEROEIS       298
#define TWCY_FIJIISLANDS    679
#define TWCY_FINLAND        358
#define TWCY_FRANCE          33
#define TWCY_FRANTILLES     596
#define TWCY_FRGUIANA       594
#define TWCY_FRPOLYNEISA    689
#define TWCY_FUTANAIS      1043
#define TWCY_GABON          241
#define TWCY_GAMBIA         220
#define TWCY_GERMANY         49
#define TWCY_GHANA          233
#define TWCY_GIBRALTER      350
#define TWCY_GREECE          30
#define TWCY_GREENLAND      299
#define TWCY_GRENADA       8099
#define TWCY_GRENEDINES    8015
#define TWCY_GUADELOUPE     590
#define TWCY_GUAM           671
#define TWCY_GUANTANAMOBAY 5399
#define TWCY_GUATEMALA      502
#define TWCY_GUINEA         224
#define TWCY_GUINEABISSAU  1017
#define TWCY_GUYANA         592
#define TWCY_HAITI          509
#define TWCY_HONDURAS       504
#define TWCY_HONGKONG      852
#define TWCY_HUNGARY         36
#define TWCY_ICELAND        354
#define TWCY_INDIA           91
#define TWCY_INDONESIA       62
#define TWCY_IRAN            98
#define TWCY_IRAQ           964
#define TWCY_IRELAND        353
#define TWCY_ISRAEL         972
#define TWCY_ITALY           39
#define TWCY_IVORYCOAST    225
#define TWCY_JAMAICA       8010
#define TWCY_JAPAN           81
#define TWCY_JORDAN         962
#define TWCY_KENYA          254
#define TWCY_KIRIBATI      1018
#define TWCY_KOREA           82
#define TWCY_KUWAIT         965
#define TWCY_LAOS          1019
#define TWCY_LEBANON       1020
#define TWCY_LIBERIA        231
#define TWCY_LIBYA          218
#define TWCY_LIECHTENSTEIN   41
#define TWCY_LUXENBOURG     352
#define TWCY_MACAO          853
#define TWCY_MADAGASCAR    1021
#define TWCY_MALAWI         265
#define TWCY_MALAYSIA        60
#define TWCY_MALDIVES       960
#define TWCY_MALI          1022
#define TWCY_MALTA          356
#define TWCY_MARSHALLIS     692
#define TWCY_MAURITANIA    1023
#define TWCY_MAURITIUS      230
#define TWCY_MEXICO           3
#define TWCY_MICRONESIA     691
#define TWCY_MIQUELON       508
#define TWCY_MONACO          33
#define TWCY_MONGOLIA      1024
#define TWCY_MONTSERRAT    8011
#define TWCY_MOROCCO        212
#define TWCY_MOZAMBIQUE    1025
#define TWCY_NAMIBIA        264
#define TWCY_NAURU         1026
#define TWCY_NEPAL          977
#define TWCY_NETHERLANDS     31
#define TWCY_NETHANTILLES   599
#define TWCY_NEVIS         8012
#define TWCY_NEWCALEDONIA   687
#define TWCY_NEWZEALAND      64
#define TWCY_NICARAGUA      505
#define TWCY_NIGER          227
#define TWCY_NIGERIA        234
#define TWCY_NIUE          1027
#define TWCY_NORFOLKI      1028
#define TWCY_NORWAY          47
#define TWCY_OMAN           968
#define TWCY_PAKISTAN        92
#define TWCY_PALAU         1029
#define TWCY_PANAMA         507
#define TWCY_PARAGUAY       595
#define TWCY_PERU            51
#define TWCY_PHILLIPPINES    63
#define TWCY_PITCAIRNIS    1030
#define TWCY_PNEWGUINEA     675
#define TWCY_POLAND          48
#define TWCY_PORTUGAL       351
#define TWCY_QATAR          974
#define TWCY_REUNIONI      1031
#define TWCY_ROMANIA         40
#define TWCY_RWANDA         250
#define TWCY_SAIPAN         670
#define TWCY_SANMARINO       39
#define TWCY_SAOTOME       1033
#define TWCY_SAUDIARABIA    966
#define TWCY_SENEGAL        221
#define TWCY_SEYCHELLESIS  1034
#define TWCY_SIERRALEONE   1035
#define TWCY_SINGAPORE       65
#define TWCY_SOLOMONIS     1036
#define TWCY_SOMALI        1037
#define TWCY_SOUTHAFRICA    27
#define TWCY_SPAIN           34
#define TWCY_SRILANKA        94
#define TWCY_STHELENA      1032
#define TWCY_STKITTS       8013
#define TWCY_STLUCIA       8014
#define TWCY_STPIERRE       508
#define TWCY_STVINCENT     8015
#define TWCY_SUDAN         1038
#define TWCY_SURINAME       597
#define TWCY_SWAZILAND      268
#define TWCY_SWEDEN          46
#define TWCY_SWITZERLAND     41
#define TWCY_SYRIA         1039
#define TWCY_TAIWAN         886
#define TWCY_TANZANIA       255
#define TWCY_THAILAND        66
#define TWCY_TOBAGO        8016
#define TWCY_TOGO           228
#define TWCY_TONGAIS        676
#define TWCY_TRINIDAD      8016
#define TWCY_TUNISIA        216
#define TWCY_TURKEY          90
#define TWCY_TURKSCAICOS   8017
#define TWCY_TUVALU        1040
#define TWCY_UGANDA         256
#define TWCY_USSR             7
#define TWCY_UAEMIRATES     971
#define TWCY_UNITEDKINGDOM   44
#define TWCY_USA              1
#define TWCY_URUGUAY        598
#define TWCY_VANUATU       1041
#define TWCY_VATICANCITY     39
#define TWCY_VENEZUELA       58
#define TWCY_WAKE          1042
#define TWCY_WALLISIS      1043
#define TWCY_WESTERNSAHARA 1044
#define TWCY_WESTERNSAMOA  1045
#define TWCY_YEMEN         1046
#define TWCY_YUGOSLAVIA      38
#define TWCY_ZAIRE          243
#define TWCY_ZAMBIA         260
#define TWCY_ZIMBABWE       263

/****************************************************************************
 * Language Constants                                                       *
 ****************************************************************************/

#define TWLG_DAN              0 /* Danish                 */
#define TWLG_DUT              1 /* Dutch                  */
#define TWLG_ENG              2 /* International English  */
#define TWLG_FCF              3 /* French Canadian        */
#define TWLG_FIN              4 /* Finnish                */
#define TWLG_FRN              5 /* French                 */
#define TWLG_GER              6 /* German                 */
#define TWLG_ICE              7 /* Icelandic              */
#define TWLG_ITN              8 /* Italian                */
#define TWLG_NOR              9 /* Norwegian              */
#define TWLG_POR             10 /* Portuguese             */
#define TWLG_SPA             11 /* Spanish                */
#define TWLG_SWE             12 /* Swedish                */
#define TWLG_USA             13 /* U.S. English           */

/****************************************************************************
 * Data Groups                                                              *
 ****************************************************************************/

/* More Data Groups may be added in the future.
 * Possible candidates include text, vector graphics, sound, etc.
 * NOTE: Data Group constants must be powers of 2 as they are used
 *       as bitflags when App asks DSM to present a list of DSs.
 */

#define DG_CONTROL          0x0001L /* data pertaining to control       */
#define DG_IMAGE            0x0002L /* data pertaining to raster images */

/****************************************************************************
 * Data Argument Types                                                      *
 ****************************************************************************/

/*  SDH - 03/23/95 - WATCH                                                  */
/*  The thunker requires knowledge about size of data being passed in the   */
/*  lpData parameter to DS_Entry (which is not readily available due to     */
/*  type LPVOID.  Thus, we key off the DAT_ argument to determine the size. */
/*  This has a couple implications:                                         */
/*  1) Any additional DAT_ features require modifications to the thunk code */
/*     for thunker support.                                                 */
/*  2) Any applications which use the custom capabailites are not supported */
/*     under thunking since we have no way of knowing what size data (if    */
/*     any) is being passed.                                                */

#define DAT_NULL            0x0000 /* No data or structure. */
#define DAT_CUSTOMBASE      0x8000 /* Base of custom DATs.  */

/* Data Argument Types for the DG_CONTROL Data Group. */
#define DAT_CAPABILITY      0x0001 /* TW_CAPABILITY                        */
#define DAT_EVENT           0x0002 /* TW_EVENT                             */
#define DAT_IDENTITY        0x0003 /* TW_IDENTITY                          */
#define DAT_PARENT          0x0004 /* TW_HANDLE, app win handle in Windows */
#define DAT_PENDINGXFERS    0x0005 /* TW_PENDINGXFERS                      */
#define DAT_SETUPMEMXFER    0x0006 /* TW_SETUPMEMXFER                      */
#define DAT_SETUPFILEXFER   0x0007 /* TW_SETUPFILEXFER                     */
#define DAT_STATUS          0x0008 /* TW_STATUS                            */
#define DAT_USERINTERFACE   0x0009 /* TW_USERINTERFACE                     */
#define DAT_XFERGROUP       0x000a /* TW_UINT32                            */
/*  SDH - 03/21/95 - TWUNK                                         */
/*  Additional message required for thunker to request the special */
/*  identity information.                                          */
#define DAT_TWUNKIDENTITY   0x000b /* TW_TWUNKIDENTITY                     */
#define DAT_CUSTOMDSDATA    0x000c /* TW_CUSTOMDSDATA.                     */

/* Data Argument Types for the DG_IMAGE Data Group. */
#define DAT_IMAGEINFO       0x0101 /* TW_IMAGEINFO                         */
#define DAT_IMAGELAYOUT     0x0102 /* TW_IMAGELAYOUT                       */
#define DAT_IMAGEMEMXFER    0x0103 /* TW_IMAGEMEMXFER                      */
#define DAT_IMAGENATIVEXFER 0x0104 /* TW_UINT32 loword is hDIB, PICHandle  */
#define DAT_IMAGEFILEXFER   0x0105 /* Null data                            */
#define DAT_CIECOLOR        0x0106 /* TW_CIECOLOR                          */
#define DAT_GRAYRESPONSE    0x0107 /* TW_GRAYRESPONSE                      */
#define DAT_RGBRESPONSE     0x0108 /* TW_RGBRESPONSE                       */
#define DAT_JPEGCOMPRESSION 0x0109 /* TW_JPEGCOMPRESSION                   */
#define DAT_PALETTE8        0x010a /* TW_PALETTE8                          */
#define DAT_EXTIMAGEINFO    0x010b /* TW_EXTIMAGEINFO -- for 1.7 Spec.     */


/****************************************************************************
 * Messages                                                                 *
 ****************************************************************************/

/* All message constants are unique.
 * Messages are grouped according to which DATs they are used with.*/

#define MSG_NULL         0x0000 /* Used in TW_EVENT structure               */
#define MSG_CUSTOMBASE   0x8000 /* Base of custom messages                  */

/* Generic messages may be used with any of several DATs.                   */
#define MSG_GET          0x0001 /* Get one or more values                   */
#define MSG_GETCURRENT   0x0002 /* Get current value                        */
#define MSG_GETDEFAULT   0x0003 /* Get default (e.g. power up) value        */
#define MSG_GETFIRST     0x0004 /* Get first of a series of items, e.g. DSs */
#define MSG_GETNEXT      0x0005 /* Iterate through a series of items.       */
#define MSG_SET          0x0006 /* Set one or more values                   */
#define MSG_RESET        0x0007 /* Set current value to default value       */
#define MSG_QUERYSUPPORT 0x0008 /* Get supported operations on the cap.     */

/* Messages used with DAT_NULL                                              */
#define MSG_XFERREADY    0x0101 /* The data source has data ready           */
#define MSG_CLOSEDSREQ   0x0102 /* Request for App. to close DS             */
#define MSG_CLOSEDSOK    0x0103 /* Tell the App. to save the state.         */

/* Messages used with a pointer to a DAT_STATUS structure                   */
#define MSG_CHECKSTATUS  0x0201 /* Get status information                   */

/* Messages used with a pointer to DAT_PARENT data                          */
#define MSG_OPENDSM      0x0301 /* Open the DSM                             */
#define MSG_CLOSEDSM     0x0302 /* Close the DSM                            */

/* Messages used with a pointer to a DAT_IDENTITY structure                 */
#define MSG_OPENDS       0x0401 /* Open a data source                       */
#define MSG_CLOSEDS      0x0402 /* Close a data source                      */
#define MSG_USERSELECT   0x0403 /* Put up a dialog of all DS                */

/* Messages used with a pointer to a DAT_USERINTERFACE structure            */
#define MSG_DISABLEDS    0x0501 /* Disable data transfer in the DS          */
#define MSG_ENABLEDS     0x0502 /* Enable data transfer in the DS           */
#define MSG_ENABLEDSUIONLY  0x0503  /* Enable for saving DS state only.     */

/* Messages used with a pointer to a DAT_EVENT structure                    */
#define MSG_PROCESSEVENT 0x0601

/* Messages used with a pointer to a DAT_PENDINGXFERS structure             */
#define MSG_ENDXFER      0x0701


/****************************************************************************
 * Capabilities                                                             *
 ****************************************************************************/

#define CAP_CUSTOMBASE          0x8000 /* Base of custom capabilities */

/* all data sources are REQUIRED to support these caps */
#define CAP_XFERCOUNT           0x0001

/* image data sources are REQUIRED to support these caps */
#define ICAP_COMPRESSION        0x0100
#define ICAP_PIXELTYPE          0x0101
#define ICAP_UNITS              0x0102 /* default is TWUN_INCHES */
#define ICAP_XFERMECH           0x0103

/* all data sources MAY support these caps */
#define CAP_AUTHOR              0x1000
#define CAP_CAPTION             0x1001
#define CAP_FEEDERENABLED       0x1002
#define CAP_FEEDERLOADED        0x1003
#define CAP_TIMEDATE            0x1004
#define CAP_SUPPORTEDCAPS       0x1005
#define CAP_EXTENDEDCAPS        0x1006
#define CAP_AUTOFEED            0x1007
#define CAP_CLEARPAGE           0x1008
#define CAP_FEEDPAGE            0x1009
#define CAP_REWINDPAGE          0x100a
#define CAP_INDICATORS          0x100b   /* Added 1.1 */
#define CAP_SUPPORTEDCAPSEXT    0x100c   /* Added 1.6 */
#define CAP_PAPERDETECTABLE     0x100d   /* Added 1.6 */
#define CAP_UICONTROLLABLE      0x100e   /* Added 1.6 */
#define CAP_DEVICEONLINE        0x100f   /* Added 1.6 */
#define CAP_AUTOSCAN            0x1010   /* Added 1.6 */
#define CAP_THUMBNAILSENABLED   0x1011   /* Added 1.7 */
#define CAP_DUPLEX              0x1012   /* Added 1.7 */
#define CAP_DUPLEXENABLED       0x1013   /* Added 1.7 */
#define CAP_ENABLEDSUIONLY      0x1014   /* Added 1.7 */
#define CAP_CUSTOMDSDATA        0x1015   /* Added 1.7 */
#define CAP_ENDORSER            0x1016   /* Added 1.7 */
#define CAP_JOBCONTROL          0x1017   /* Added 1.7 */

/* image data sources MAY support these caps */
#define ICAP_AUTOBRIGHT         0x1100
#define ICAP_BRIGHTNESS         0x1101
#define ICAP_CONTRAST           0x1103
#define ICAP_CUSTHALFTONE       0x1104
#define ICAP_EXPOSURETIME       0x1105
#define ICAP_FILTER             0x1106
#define ICAP_FLASHUSED          0x1107
#define ICAP_GAMMA              0x1108
#define ICAP_HALFTONES          0x1109
#define ICAP_HIGHLIGHT          0x110a
#define ICAP_IMAGEFILEFORMAT    0x110c
#define ICAP_LAMPSTATE          0x110d
#define ICAP_LIGHTSOURCE        0x110e
#define ICAP_ORIENTATION        0x1110
#define ICAP_PHYSICALWIDTH      0x1111
#define ICAP_PHYSICALHEIGHT     0x1112
#define ICAP_SHADOW             0x1113
#define ICAP_FRAMES             0x1114
#define ICAP_XNATIVERESOLUTION  0x1116
#define ICAP_YNATIVERESOLUTION  0x1117
#define ICAP_XRESOLUTION        0x1118
#define ICAP_YRESOLUTION        0x1119
#define ICAP_MAXFRAMES          0x111a
#define ICAP_TILES              0x111b
#define ICAP_BITORDER           0x111c
#define ICAP_CCITTKFACTOR       0x111d
#define ICAP_LIGHTPATH          0x111e
#define ICAP_PIXELFLAVOR        0x111f
#define ICAP_PLANARCHUNKY       0x1120
#define ICAP_ROTATION           0x1121
#define ICAP_SUPPORTEDSIZES     0x1122
#define ICAP_THRESHOLD          0x1123
#define ICAP_XSCALING           0x1124
#define ICAP_YSCALING           0x1125
#define ICAP_BITORDERCODES      0x1126
#define ICAP_PIXELFLAVORCODES   0x1127
#define ICAP_JPEGPIXELTYPE      0x1128
#define ICAP_TIMEFILL           0x112a
#define ICAP_BITDEPTH           0x112b
#define ICAP_BITDEPTHREDUCTION  0x112c   /* Added 1.5 */
#define ICAP_UNDEFINEDIMAGESIZE 0X112d  /* Added 1.6 */
#define ICAP_IMAGEDATASET       0x112e  /* Added 1.7 */
#define ICAP_EXTIMAGEINFO       0x112f  /* Added 1.7 */
#define ICAP_MINIMUMHEIGHT      0x1130  /* Added 1.7 */
#define ICAP_MINIMUMWIDTH       0x1131  /* Added 1.7 */

/* ----------------------------------------------------------------------- *\

  Version 1.7:      Following is Extended Image Info Attributes.
  July 1997
  KHL

\* ----------------------------------------------------------------------- */

#define TWEI_BARCODEX               0x1200
#define TWEI_BARCODEY               0x1201
#define TWEI_BARCODETEXT            0x1202
#define TWEI_BARCODETYPE            0x1203
#define TWEI_DESHADETOP             0x1204
#define TWEI_DESHADELEFT            0x1205
#define TWEI_DESHADEHEIGHT          0x1206
#define TWEI_DESHADEWIDTH           0x1207
#define TWEI_DESHADESIZE            0x1208
#define TWEI_SPECKLESREMOVED        0x1209
#define TWEI_HORZLINEXCOORD         0x120A
#define TWEI_HORZLINEYCOORD         0x120B
#define TWEI_HORZLINELENGTH         0x120C
#define TWEI_HORZLINETHICKNESS      0x120D
#define TWEI_VERTLINEXCOORD         0x120E
#define TWEI_VERTLINEYCOORD         0x120F
#define TWEI_VERTLINELENGTH         0x1210
#define TWEI_VERTLINETHICKNESS      0x1211
#define TWEI_PATCHCODE              0x1212
#define TWEI_ENDORSEDTEXT           0x1213
#define TWEI_FORMCONFIDENCE         0x1214
#define TWEI_FORMTEMPLATEMATCH      0x1215
#define TWEI_FORMTEMPLATEPAGEMATCH  0x1216
#define TWEI_FORMHORZDOCOFFSET      0x1217
#define TWEI_FORMVERTDOCOFFSET      0x1218
#define TWEI_BARCODECOUNT           0x1219
#define TWEI_BARCODECONFIDENCE      0x121A
#define TWEI_BARCODEROTATION        0x121B
#define TWEI_BARCODETEXTLENGTH      0x121C
#define TWEI_DESHADECOUNT           0x121D
#define TWEI_DESHADEBLACKCOUNTOLD   0x121E
#define TWEI_DESHADEBLACKCOUNTNEW   0x121F
#define TWEI_DESHADEBLACKRLMIN      0x1220
#define TWEI_DESHADEBLACKRLMAX      0x1221
#define TWEI_DESHADEWHITECOUNTOLD   0x1222
#define TWEI_DESHADEWHITECOUNTNEW   0x1223
#define TWEI_DESHADEWHITERLMIN      0x1224
#define TWEI_DESHADEWHITERLAVE      0x1225
#define TWEI_DESHADEWHITERLMAX      0x1226
#define TWEI_BLACKSPECKLESREMOVED   0x1227
#define TWEI_WHITESPECKLESREMOVED   0x1228
#define TWEI_HORZLINECOUNT          0x1229
#define TWEI_VERTLINECOUNT          0x122A
#define TWEI_DESKEWSTATUS           0x122B
#define TWEI_SKEWORIGINALANGLE      0x122C
#define TWEI_SKEWFINALANGLE         0x122D
#define TWEI_SKEWCONFIDENCE         0x122E
#define TWEI_SKEWWINDOWX1           0x122F
#define TWEI_SKEWWINDOWY1           0x1230
#define TWEI_SKEWWINDOWX2           0x1231
#define TWEI_SKEWWINDOWY2           0x1232
#define TWEI_SKEWWINDOWX3           0x1233
#define TWEI_SKEWWINDOWY3           0x1234
#define TWEI_SKEWWINDOWX4           0x1235
#define TWEI_SKEWWINDOWY4           0x1236

#define TWEJ_NONE                   0x0000
#define TWEJ_MIDSEPARATOR           0x0001
#define TWEJ_PATCH1                 0x0002
#define TWEJ_PATCH2                 0x0003
#define TWEJ_PATCH3                 0x0004
#define TWEJ_PATCH4                 0x0005
#define TWEJ_PATCH6                 0x0006
#define TWEJ_PATCHT                 0x0007


/***************************************************************************
 *            Return Codes and Condition Codes section                     *
 ***************************************************************************/

/* Return Codes: DSM_Entry and DS_Entry may return any one of these values. */
#define TWRC_CUSTOMBASE     0x8000

#define TWRC_SUCCESS          0
#define TWRC_FAILURE          1 /* App may get TW_STATUS for info on failure */
#define TWRC_CHECKSTATUS      2 /* "tried hard"; get status                  */
#define TWRC_CANCEL           3
#define TWRC_DSEVENT          4
#define TWRC_NOTDSEVENT       5
#define TWRC_XFERDONE         6
#define TWRC_ENDOFLIST        7 /* After MSG_GETNEXT if nothing left         */
#define TWRC_INFONOTSUPPORTED 8
#define TWRC_DATANOTAVAILABLE 9

/* Condition Codes: App gets these by doing DG_CONTROL DAT_STATUS MSG_GET.  */
#define TWCC_CUSTOMBASE     0x8000

#define TWCC_SUCCESS         0 /* It worked!                                */
#define TWCC_BUMMER          1 /* Failure due to unknown causes             */
#define TWCC_LOWMEMORY       2 /* Not enough memory to perform operation    */
#define TWCC_NODS            3 /* No Data Source                            */
#define TWCC_MAXCONNECTIONS  4 /* DS is connected to max possible apps      */
#define TWCC_OPERATIONERROR  5 /* DS or DSM reported error, app shouldn't   */
#define TWCC_BADCAP          6 /* Unknown capability                        */
#define TWCC_BADPROTOCOL     9 /* Unrecognized MSG DG DAT combination       */
#define TWCC_BADVALUE        10 /* Data parameter out of range              */
#define TWCC_SEQERROR        11 /* DG DAT MSG out of expected sequence      */
#define TWCC_BADDEST         12 /* Unknown destination App/Src in DSM_Entry */
#define TWCC_CAPUNSUPPORTED  13 /* Capability not supported by source            */
#define TWCC_CAPBADOPERATION 14 /* Operation not supported by capability         */
#define TWCC_CAPSEQERROR     15 /* Capability has dependancy on other capability */

/* bit patterns: for query the operation that are supported by the data source on a capability */
/* App gets these through DG_CONTROL/DAT_CAPABILITY/MSG_QUERYSUPPORT */
/* Added 1.6 */
#define TWQC_GET           0x0001
#define TWQC_SET           0x0002
#define TWQC_GETDEFAULT    0x0004
#define TWQC_GETCURRENT    0x0008
#define TWQC_RESET         0x0010


/****************************************************************************
 * Entry Points                                                             *
 ****************************************************************************/

/**********************************************************************
 * Function: DSM_Entry, the only entry point into the Data Source Manager.
 *
 * Parameters:
 *  pOrigin Identifies the source module of the message. This could
 *          identify an Application, a Source, or the Source Manager.
 *
 *  pDest   Identifies the destination module for the message.
 *          This could identify an application or a data source.
 *          If this is NULL, the message goes to the Source Manager.
 *
 *  DG      The Data Group.
 *          Example: DG_IMAGE.
 *
 *  DAT     The Data Attribute Type.
 *          Example: DAT_IMAGEMEMXFER.
 *
 *  MSG     The message.  Messages are interpreted by the destination module
 *          with respect to the Data Group and the Data Attribute Type.
 *          Example: MSG_GET.
 *
 *  pData   A pointer to the data structure or variable identified
 *          by the Data Attribute Type.
 *          Example: (TW_MEMREF)&ImageMemXfer
 *                   where ImageMemXfer is a TW_IMAGEMEMXFER structure.
 *
 * Returns:
 *  ReturnCode
 *         Example: TWRC_SUCCESS.
 *
 ********************************************************************/

/* Don't mangle the name "DSM_Entry" if we're compiling in C++! */
#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef  _MSWIN_

#ifdef _WIN32
    TW_UINT16 FAR PASCAL DSM_Entry( pTW_IDENTITY pOrigin,
                                pTW_IDENTITY pDest,
                                TW_UINT32    DG,
                                TW_UINT16    DAT,
                                TW_UINT16    MSG,
                                TW_MEMREF    pData);

    typedef TW_UINT16 (FAR PASCAL *DSMENTRYPROC)(pTW_IDENTITY, pTW_IDENTITY,
                                                 TW_UINT32,    TW_UINT16,
                                                 TW_UINT16,    TW_MEMREF);
#else

    TW_UINT16 FAR PASCAL _export DSM_Entry( pTW_IDENTITY pOrigin,
                                pTW_IDENTITY pDest,
                                TW_UINT32    DG,
                                TW_UINT16    DAT,
                                TW_UINT16    MSG,
                                TW_MEMREF    pData);

    typedef TW_UINT16 (FAR PASCAL *DSMENTRYPROC)(pTW_IDENTITY, pTW_IDENTITY,
                                             TW_UINT32,    TW_UINT16,
                                             TW_UINT16,    TW_MEMREF);
#endif /* _WIN32 */

#else   /* _MSWIN_ */

FAR PASCAL TW_UINT16 _export DSM_Entry( pTW_IDENTITY pOrigin,
                                pTW_IDENTITY pDest,
                                TW_UINT32    DG,
                                TW_UINT16    DAT,
                                TW_UINT16    MSG,
                                TW_MEMREF    pData);

typedef TW_UINT16 (*DSMENTRYPROC)(pTW_IDENTITY, pTW_IDENTITY,
                                  TW_UINT32,    TW_UINT16,
                                  TW_UINT16,    TW_MEMREF);
#endif  /* _MSWIN_ */

#ifdef  __cplusplus
}
#endif  /* cplusplus */


/**********************************************************************
 * Function: DS_Entry, the entry point provided by a Data Source.
 *
 * Parameters:
 *  pOrigin Identifies the source module of the message. This could
 *          identify an application or the Data Source Manager.
 *
 *  DG      The Data Group.
 *          Example: DG_IMAGE.
 *
 *  DAT     The Data Attribute Type.
 *          Example: DAT_IMAGEMEMXFER.
 *
 *  MSG     The message.  Messages are interpreted by the data source
 *          with respect to the Data Group and the Data Attribute Type.
 *          Example: MSG_GET.
 *
 *  pData   A pointer to the data structure or variable identified
 *          by the Data Attribute Type.
 *          Example: (TW_MEMREF)&ImageMemXfer
 *                   where ImageMemXfer is a TW_IMAGEMEMXFER structure.
 *
 * Returns:
 *  ReturnCode
 *          Example: TWRC_SUCCESS.
 *
 * Note:
 *  The DSPROC type is only used by an application when it calls
 *  a Data Source directly, bypassing the Data Source Manager.
 *
 ********************************************************************/
/* Don't mangle the name "DS_Entry" if we're compiling in C++! */
#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef  _MSWIN_
  #ifdef _WIN32
    #if defined(_TWAIN_NO_EXPORT_) && !defined(_X86_)
    #define _TWAIN_DLL_EXPORT_
    #else
    #define _TWAIN_DLL_EXPORT_ __declspec(dllexport)
    #endif

     _TWAIN_DLL_EXPORT_ TW_UINT16 FAR PASCAL DS_Entry (pTW_IDENTITY pOrigin,
                                                       TW_UINT32    DG,
                                                       TW_UINT16    DAT,
                                                       TW_UINT16    MSG,
                                                       TW_MEMREF    pData);
  #else   /* _WIN32 */
     TW_UINT16 FAR PASCAL DS_Entry (pTW_IDENTITY pOrigin,
                                    TW_UINT32    DG,
                                    TW_UINT16    DAT,
                                    TW_UINT16    MSG,
                                    TW_MEMREF    pData);
  #endif  /* _WIN32 */

  typedef TW_UINT16 (FAR PASCAL *DSENTRYPROC) (pTW_IDENTITY pOrigin,
                                               TW_UINT32    DG,
                                               TW_UINT16    DAT,
                                               TW_UINT16    MSG,
                                               TW_MEMREF    pData);
#else   /* _MSWIN_ */
FAR PASCAL TW_UINT16 DS_Entry( pTW_IDENTITY pOrigin,
                               TW_UINT32    DG,
                               TW_UINT16    DAT,
                               TW_UINT16    MSG,
                               TW_MEMREF    pData);

typedef TW_UINT16 (*DSENTRYPROC)(pTW_IDENTITY,
                                  TW_UINT32,    TW_UINT16,
                                  TW_UINT16,    TW_MEMREF);
#endif  /* _MSWIN_ */

#ifdef  __cplusplus
}
#endif  /* cplusplus */

/*  SDH - 02/08/95 - TWUNK */
/*  Force 32-bit twain to use same packing of twain structures as existing */
/*  16-bit twain.  This allows 16/32-bit thunking. */
#ifdef  WIN32
    #ifdef __BORLANDC__ //(Mentor June 13, 1996) if we're using a Borland compiler
        #pragma option -a.  //(Mentor October 30, 1996) switch back to original alignment
    #else   //(Mentor June 13, 1996) if we're NOT using a Borland compiler
        #pragma pack (pop, before_twain)
    #endif  //(Mentor June 13, 1996)
#else   /* WIN32 */
#endif  /* WIN32 */

#endif  /* TWAIN */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vddsvc.h ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    VDDSVC.H

Abstract:

    Include file contains VDM services provided for installable VDDs.


--*/


/**
 * This file contains VDM services prototype defintions only; their
 * related structures and macros are defined in NT_VDD.H.
 * If we have not included the file yet, include it and set a signal
 * to tell anybody the fact.
**/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _NT_VDD
#include "nt_vdd.h"
#define _NT_VDD
#endif


/** Memory Accessing services **/

#define GetVDMAddress(usSeg, usOff) (((ULONG)usSeg << 4) + (ULONG)usOff)

#define GetVDMPointer(Address, Size, Mode) Sim32GetVDMPointer(\
						Address, Size, Mode)

#define FlushVDMPointer(Address, Size, Buffer, Mode) Sim32FlushVDMPointer(\
					   Address, Size, Buffer, Mode)

#define FreeVDMPointer(Address, Size, Buffer, Mode) Sim32FreeVDMPointer(\
					   Address, Size, Buffer, Mode)

/** interrupt simualtion services **/

#define ICA_MASTER 0
#define ICA_SLAVE  1
#define VDDSimulateInterrupt(ms, line, count) (call_ica_hw_interrupt)(\
						   ms, line, 1)


/** Register manipulation services **/

#ifndef i386

#define	getEAX()	(ULONG)c_getAX()
#define	getAX() 	c_getAX()
#define	getAL() 	c_getAL()
#define getAH()         c_getAH()
#define	getEBX()	(ULONG)c_getBX()
#define	getBX() 	c_getBX()
#define	getBL() 	c_getBL()
#define	getBH() 	c_getBH()
#define	getECX()	(ULONG)c_getCX()
#define	getCX() 	c_getCX()
#define	getCL() 	c_getCL()
#define	getCH() 	c_getCH()
#define	getEDX()	(ULONG)c_getDX()
#define	getDX() 	c_getDX()
#define	getDL() 	c_getDL()
#define	getDH() 	c_getDH()
#define	getESP()	(ULONG)c_getSP()
#define	getSP() 	c_getSP()
#define	getEBP()	(ULONG)c_getBP()
#define	getBP() 	c_getBP()
#define	getESI()	(ULONG)c_getSI()
#define	getSI() 	c_getSI()
#define	getEDI()	(ULONG)c_getDI()
#define	getDI() 	c_getDI()
#define	getEIP()	(ULONG)c_getIP()
#define	getIP() 	c_getIP()
#define	getCS() 	c_getCS()
#define	getSS() 	c_getSS()
#define	getDS() 	c_getDS()
#define	getES() 	c_getES()
#define	getCF() 	c_getCF()
#define	getPF() 	c_getPF()
#define	getAF() 	c_getAF()
#define	getZF() 	c_getZF()
#define	getSF() 	c_getSF()
#define	getIF() 	c_getIF()
#define	getDF() 	c_getDF()
#define	getOF() 	c_getOF()
#define	getMSW()	c_getMSW()

#define	setEAX(value)	c_setAX((WORD)value)
#define	setAX(value)	c_setAX(value)
#define	setAH(value)	c_setAH(value)
#define	setAL(value)	c_setAL(value)
#define	setEBX(value)	c_setBX((WORD)value)
#define	setBX(value)	c_setBX(value)
#define	setBH(value)	c_setBH(value)
#define	setBL(value)	c_setBL(value)
#define	setECX(value)	c_setCX((WORD)value)
#define	setCX(value)	c_setCX(value)
#define	setCH(value)	c_setCH(value)
#define	setCL(value)	c_setCL(value)
#define	setEDX(value)	c_setDX((WORD)value)
#define	setDX(value)	c_setDX(value)
#define	setDH(value)	c_setDH(value)
#define	setDL(value)	c_setDL(value)
#define	setESP(value)	c_setSP((WORD)value)
#define	setSP(value)	c_setSP(value)
#define	setEBP(value)	c_setBP((WORD)value)
#define	setBP(value)	c_setBP(value)
#define	setESI(value)	c_setSI((WORD)value)
#define	setSI(value)	c_setSI(value)
#define	setEDI(value)	c_setDI((WORD)value)
#define	setDI(value)	c_setDI(value)
#define	setEIP(value)	c_setIP((WORD)value)
#define	setIP(value)	c_setIP(value)
#define	setCS(value)	c_setCS(value)
#define	setSS(value)	c_setSS(value)
#define	setDS(value)	c_setDS(value)
#define	setES(value)	c_setES(value)
#define	setCF(value)	c_setCF(value)
#define	setPF(value)	c_setPF(value)
#define	setAF(value)	c_setAF(value)
#define	setZF(value)	c_setZF(value)
#define	setSF(value)	c_setSF(value)
#define	setIF(value)	c_setIF(value)
#define	setDF(value)	c_setDF(value)
#define	setOF(value)	c_setOF(value)
#define	setMSW(value)	c_setMSW(value)

#endif


/** Real function prototype declarations **/


/** interrupt simulation functions **/

VOID
call_ica_hw_interrupt (
 int ms,
 BYTE line,
 int count
 );

#define Sim32FreeVDMPointer(address, size, buffer, mode) TRUE

/** memory address manipulation functions **/

#ifdef i386

#define Sim32GetVDMPointer(address, size, mode) MGetVdmPointer(address,\
                                                               size, mode)
#define Sim32FlushVDMPointer(addess, size, buffer, mode) TRUE

PBYTE
MGetVdmPointer(
 ULONG	 Address,
 ULONG	 Size,
 UCHAR   ProtectedMode
);

#else

PBYTE
Sim32GetVDMPointer(
 ULONG	 Address,
 ULONG   Size,
 UCHAR   ProtectedMode
);

BOOLEAN
Sim32FlushVDMPointer(
 ULONG	 Address,
 USHORT	 Size,
 PBYTE	 Buffer,
 BOOLEAN ProtectedMode
);

#endif


/** Register manipulation functions **/

#ifdef i386
ULONG   getEAX(VOID);
USHORT  getAX(VOID);
UCHAR   getAL(VOID);
UCHAR   getAH(VOID);
ULONG   getEBX(VOID);
USHORT  getBX(VOID);
UCHAR   getBL(VOID);
UCHAR   getBH(VOID);
ULONG   getECX(VOID);
USHORT  getCX(VOID);
UCHAR   getCL(VOID);
UCHAR   getCH(VOID);
ULONG   getEDX(VOID);
USHORT  getDX(VOID);
UCHAR   getDL(VOID);
UCHAR   getDH(VOID);
ULONG   getESP(VOID);
USHORT  getSP(VOID);
ULONG   getEBP(VOID);
USHORT  getBP(VOID);
ULONG   getESI(VOID);
USHORT  getSI(VOID);
ULONG   getEDI(VOID);
USHORT  getDI(VOID);
ULONG   getEIP(VOID);
USHORT  getIP(VOID);
USHORT  getCS(VOID);
USHORT  getSS(VOID);
USHORT  getDS(VOID);
USHORT  getES(VOID);
USHORT  getFS(VOID);
USHORT  getGS(VOID);
ULONG   getCF(VOID);
ULONG   getPF(VOID);
ULONG   getAF(VOID);
ULONG   getZF(VOID);
ULONG   getSF(VOID);
ULONG   getIF(VOID);
ULONG   getDF(VOID);
ULONG   getOF(VOID);
USHORT	getMSW(VOID);

VOID    setEAX(ULONG);
VOID    setAX(USHORT);
VOID    setAH(UCHAR);
VOID    setAL(UCHAR);
VOID    setEBX(ULONG);
VOID    setBX(USHORT);
VOID    setBH(UCHAR);
VOID    setBL(UCHAR);
VOID    setECX(ULONG);
VOID    setCX(USHORT);
VOID    setCH(UCHAR);
VOID    setCL(UCHAR);
VOID    setEDX(ULONG);
VOID    setDX(USHORT);
VOID    setDH(UCHAR);
VOID    setDL(UCHAR);
VOID    setESP(ULONG);
VOID    setSP(USHORT);
VOID    setEBP(ULONG);
VOID    setBP(USHORT);
VOID    setESI(ULONG);
VOID    setSI(USHORT);
VOID    setEDI(ULONG);
VOID    setDI(USHORT);
VOID    setEIP(ULONG);
VOID    setIP(USHORT);
VOID    setCS(USHORT);
VOID    setSS(USHORT);
VOID    setDS(USHORT);
VOID    setES(USHORT);
VOID    setFS(USHORT);
VOID    setGS(USHORT);
VOID    setCF(ULONG);
VOID    setPF(ULONG);
VOID    setAF(ULONG);
VOID    setZF(ULONG);
VOID    setSF(ULONG);
VOID    setIF(ULONG);
VOID    setDF(ULONG);
VOID    setOF(ULONG);
VOID    setMSW(USHORT);


#else

UCHAR c_getAL(VOID);
UCHAR c_getCL(VOID);
UCHAR c_getDL(VOID);
UCHAR c_getBL(VOID);
UCHAR c_getAH(VOID);
UCHAR c_getCH(VOID);
UCHAR c_getDH(VOID);
UCHAR c_getBH(VOID);

USHORT c_getAX(VOID);
USHORT c_getCX(VOID);
USHORT c_getDX(VOID);
USHORT c_getBX(VOID);
USHORT c_getSP(VOID);
USHORT c_getBP(VOID);
USHORT c_getSI(VOID);
USHORT c_getDI(VOID);
USHORT c_getIP(VOID);
USHORT c_getES(VOID);
USHORT c_getCS(VOID);
USHORT c_getSS(VOID);
USHORT c_getDS(VOID);

USHORT c_getMSW(VOID);

ULONG c_getAF(VOID);
ULONG c_getCF(VOID);
ULONG c_getDF(VOID);
ULONG c_getIF(VOID);
ULONG c_getOF(VOID);
ULONG c_getPF(VOID);
ULONG c_getSF(VOID);
ULONG c_getZF(VOID);

VOID c_setAL(UCHAR val);
VOID c_setCL(UCHAR val);
VOID c_setDL(UCHAR val);
VOID c_setBL(UCHAR val);
VOID c_setAH(UCHAR val);
VOID c_setCH(UCHAR val);
VOID c_setDH(UCHAR val);
VOID c_setBH(UCHAR val);

VOID c_setAX(USHORT val);
VOID c_setCX(USHORT val);
VOID c_setDX(USHORT val);
VOID c_setBX(USHORT val);
VOID c_setSP(USHORT val);
VOID c_setBP(USHORT val);
VOID c_setSI(USHORT val);
VOID c_setDI(USHORT val);
VOID c_setIP(USHORT val);

VOID c_setES(USHORT val);
VOID c_setCS(USHORT val);
VOID c_setSS(USHORT val);
VOID c_setDS(USHORT val);

VOID c_setMSW(USHORT val);

VOID c_setAF(ULONG val);
VOID c_setCF(ULONG val);
VOID c_setDF(ULONG val);
VOID c_setIF(ULONG val);
VOID c_setOF(ULONG val);
VOID c_setPF(ULONG val);
VOID c_setSF(ULONG val);
VOID c_setZF(ULONG val);

#endif


/* end of VDDSVC.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winresrc.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    winresrc.h

Abstract:

    This module defines the 32-Bit Windows resource codes.

Revision History:

--*/

#ifndef _WINRESRC_
#define _WINRESRC_

#ifndef WINVER
#define WINVER 0x0500
#endif

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#endif

#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0410
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <winuser.rh>
#include <commctrl.rh>
#include <dde.rh>
#include <winnt.rh>
#include <dlgs.h>
#include <winver.h>

#endif /* _WINRESRC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vfw.h ===
/****************************************************************************
 *
 *      VfW.H - Video for windows include file for WIN32
 *
 *      Copyright (c) 1991-1995, Microsoft Corp.  All rights reserved.
 *
 *      This include files defines interfaces to the following
 *      video components
 *
 *          COMPMAN         - Installable Compression Manager.
 *          DRAWDIB         - Routines for drawing to the display.
 *          VIDEO           - Video Capture Driver Interface
 *
 *          AVIFMT          - AVI File Format structure definitions.
 *          MMREG           - FOURCC and other things
 *
 *          AVIFile         - Interface for reading AVI Files and AVI Streams
 *          MCIWND          - MCI/AVI window class
 *          AVICAP          - AVI Capture Window class
 *
 *          MSACM           - Audio compression manager.
 *
 *      The following symbols control inclusion of various parts of this file:
 *
 *          NOCOMPMAN       - dont include COMPMAN
 *          NODRAWDIB       - dont include DRAWDIB
 *          NOVIDEO         - dont include video capture interface
 *
 *          NOAVIFMT        - dont include AVI file format structs
 *          NOMMREG         - dont include MMREG
 *
 *          NOAVIFILE       - dont include AVIFile interface
 *          NOMCIWND        - dont include AVIWnd class.
 *          NOAVICAP        - dont include AVICap class.
 *
 *          NOMSACM         - dont include ACM stuff.
 *
 ****************************************************************************/

#ifndef _INC_VFW
#define _INC_VFW

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  types
 *
 ***************************************************************************/

#define VFWAPI  WINAPI
#define VFWAPIV WINAPIV

/****************************************************************************
 *
 *  VideoForWindowsVersion() - returns version of VfW
 *
 ***************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************
 *
 *  call these to start stop using VfW from your app.
 *
 ***************************************************************************/

LONG VFWAPI InitVFW(void);
LONG VFWAPI TermVFW(void);

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */


/****************************************************************************
 *
 *  do we need MMSYSTEM?
 *
 ****************************************************************************/

#if !defined(_INC_MMSYSTEM) && (!defined(NOVIDEO) || !defined(NOAVICAP))
    #include <mmsystem.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************/
/*                                                                          */
/*        Macros                                                            */
/*                                                                          */
/*  should we define this??                                                 */
/*                                                                          */
/****************************************************************************/

#ifndef MKFOURCC
#define MKFOURCC( ch0, ch1, ch2, ch3 )                                    \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#if !defined(_INC_MMSYSTEM)
    #define mmioFOURCC MKFOURCC
#endif

/****************************************************************************
 *
 *  COMPMAN - Installable Compression Manager.
 *
 ****************************************************************************/

#ifndef NOCOMPMAN

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif
#ifndef _WIN32					// ;Internal
#define ICMODE_INTERNALF_FUNCTION32	0x8000	// ;Internal
#define ICMODE_INTERNALF_MASK		0x8000	// ;Internal
#endif						// ;Internal

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD ;Internal
#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format ;Internal
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats ;Internal

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame ;Internal
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS               (ICM_USER+20)   // decompress a frame to screen ;Internal
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time ;Internal

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames ;Internal
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;


/************************************************************************

    ICM function declarations
	
************************************************************************/

BOOL
VFWAPI
ICInfo(
    IN DWORD fccType,
    IN DWORD fccHandler,
    OUT ICINFO FAR * lpicinfo
    );

BOOL
VFWAPI
ICInstall(
    IN DWORD fccType,
    IN DWORD fccHandler,
    IN LPARAM lParam,
    IN LPSTR szDesc,
    IN UINT wFlags
    );

BOOL
VFWAPI
ICRemove(
    IN DWORD fccType,
    IN DWORD fccHandler,
    IN UINT wFlags
    );

LRESULT
VFWAPI
ICGetInfo(
    IN HIC hic,
    OUT ICINFO FAR *picinfo,
    IN DWORD cb
    );

HIC
VFWAPI
ICOpen(
    IN DWORD fccType,
    IN DWORD fccHandler,
    IN UINT wMode
    );

HIC
VFWAPI
ICOpenFunction(
    IN DWORD fccType,
    IN DWORD fccHandler,
    IN UINT wMode,
    IN FARPROC lpfnHandler
    );

LRESULT
VFWAPI
ICClose(
    IN HIC hic
    );

LRESULT
VFWAPI
ICSendMessage(
    IN HIC hic,
    IN UINT msg,
    IN DWORD_PTR dw1,
    IN DWORD_PTR dw2
    );
#ifndef _WIN32
//this function is unsupported on Win32 as it is non-portable.
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...);
#endif


/* Values for wFlags of ICInstall() */
#define ICINSTALL_UNICODE       0x8000

#define ICINSTALL_FUNCTION      0x0001  // lParam is a DriverProc (function ptr)
#define ICINSTALL_DRIVER        0x0002  // lParam is a driver name (string)
#define ICINSTALL_HDRV          0x0004  // lParam is a HDRVR (driver handle)

#define ICINSTALL_DRIVERW       0x8002  // lParam is a unicode driver name

/************************************************************************

    query macros

************************************************************************/
#define ICMF_CONFIGURE_QUERY     0x00000001
#define ICMF_ABOUT_QUERY         0x00000001

#define ICQueryAbout(hic) \
    (ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR) -1, ICMF_ABOUT_QUERY) == ICERR_OK)

#define ICAbout(hic, hwnd) \
    ICSendMessage(hic, ICM_ABOUT, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

#define ICQueryConfigure(hic) \
    (ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR) -1, ICMF_CONFIGURE_QUERY) == ICERR_OK)

#define ICConfigure(hic, hwnd) \
    ICSendMessage(hic, ICM_CONFIGURE, (DWORD_PTR)(UINT_PTR)(hwnd), 0)

/************************************************************************

    get/set state macros
	
************************************************************************/

#define ICGetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_GETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICSetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_SETSTATE, (DWORD_PTR)(LPVOID)(pv), (DWORD_PTR)(cb))

#define ICGetStateSize(hic) \
    (DWORD) ICGetState(hic, NULL, 0)

/************************************************************************

    get value macros

************************************************************************/
static DWORD dwICValue;

#define ICGetDefaultQuality(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTQUALITY, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

#define ICGetDefaultKeyFrameRate(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTKEYFRAMERATE, (DWORD_PTR)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

/************************************************************************

    draw window macro
	
************************************************************************/
#define ICDrawWindow(hic, prc) \
    ICSendMessage(hic, ICM_DRAW_WINDOW, (DWORD_PTR)(LPVOID)(prc), sizeof(RECT))

/************************************************************************

    compression functions

************************************************************************/
/*
 *  ICCompress()
 *
 *  compress a single frame
 *
 */
DWORD
VFWAPIV
ICCompress(
    IN     HIC                 hic,
    IN     DWORD               dwFlags,        // flags
    IN     LPBITMAPINFOHEADER  lpbiOutput,     // output format
    OUT    LPVOID              lpData,         // output data
    IN     LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    IN     LPVOID              lpBits,         // frame data to compress
    OUT    LPDWORD             lpckid,         // ckid for data in AVI file
    OUT    LPDWORD             lpdwFlags,      // flags in the AVI index.
    IN     LONG                lFrameNum,      // frame number of seq.
    IN     DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    IN     DWORD               dwQuality,      // quality within one frame
    IN     LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    IN     LPVOID              lpPrev          // previous frame
    );

/*
 *  ICCompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICCompressGetFormat()
 *
 *  get the output format, (format of compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICCompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressGetFormatSize(hic, lpbi) \
    (DWORD) ICCompressGetFormat(hic, lpbi, NULL)

/*
 *  ICCompressSize()
 *
 *  return the maximal size of a compressed frame
 *
 */
#define ICCompressGetSize(hic, lpbiInput, lpbiOutput) \
    (DWORD) ICSendMessage(hic, ICM_COMPRESS_GET_SIZE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICCompressEnd(hic) \
    ICSendMessage(hic, ICM_COMPRESS_END, 0, 0)

/************************************************************************

    decompression functions

************************************************************************/

/*
 *  ICDecompress()
 *
 *  decompress a single frame
 *
 */
#define ICDECOMPRESS_HURRYUP    0x80000000L     // don't draw just buffer (hurry up!)

DWORD
VFWAPIV
ICDecompress(
    IN  HIC                 hic,
    IN  DWORD               dwFlags,    // flags (from AVI index...)
    IN  LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
                                        // biSizeImage has the chunk size
    IN  LPVOID              lpData,     // data
    IN  LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    OUT LPVOID              lpBits
    );

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_BEGIN, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressGetFormat()
 *
 *  get the output format, (format of un-compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICDecompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ((LONG) ICSendMessage(hic, ICM_DECOMPRESS_GET_FORMAT, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput)))

#define ICDecompressGetFormatSize(hic, lpbi) \
    ICDecompressGetFormat(hic, lpbi, NULL)

/*
 *  ICDecompressGetPalette()
 *
 *  get the output palette
 *
 */
#define ICDecompressGetPalette(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_GET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), (DWORD_PTR)(LPVOID)(lpbiOutput))

#define ICDecompressSetPalette(hic, lpbiPalette) \
    ICSendMessage(hic, ICM_DECOMPRESS_SET_PALETTE, (DWORD_PTR)(LPVOID)(lpbiPalette), 0)

#define ICDecompressEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESS_END, 0, 0)

/************************************************************************

    decompression (ex) functions

************************************************************************/


//
// on Win16 these functions are macros that call ICMessage. ICMessage will
// not work on NT. rather than add new entrypoints we have given
// them as static inline functions
//

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
static __inline LRESULT VFWAPI
ICDecompressEx(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD_PTR)&ic, sizeof(ic));
}


/*
 *  ICDecompressExBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExBegin(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD_PTR)&ic, sizeof(ic));
}

/*
 *  ICDecompressExQuery()
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExQuery(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD_PTR)&ic, sizeof(ic));
}


#define ICDecompressExEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESSEX_END, 0, 0)

/************************************************************************

    drawing functions

************************************************************************/

/*
 *  ICDrawBegin()
 *
 *  start decompressing data with format (lpbiInput) directly to the screen
 *
 *  return zero if the decompressor supports drawing.
 *
 */

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND

DWORD
VFWAPIV
ICDrawBegin(
    IN HIC                 hic,
    IN DWORD               dwFlags,        // flags
    IN HPALETTE            hpal,           // palette to draw with
    IN HWND                hwnd,           // window to draw to
    IN HDC                 hdc,            // HDC to draw to
    IN int                 xDst,           // destination rectangle
    IN int                 yDst,
    IN int                 dxDst,
    IN int                 dyDst,
    IN LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
    IN int                 xSrc,           // source rectangle
    IN int                 ySrc,
    IN int                 dxSrc,
    IN int                 dySrc,
    IN DWORD               dwRate,         // frames/second = (dwRate/dwScale)
    IN DWORD               dwScale
    );

/*
 *  ICDraw()
 *
 *  decompress data directly to the screen
 *
 */

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen

DWORD
VFWAPIV
ICDraw(
    IN HIC                 hic,
    IN DWORD               dwFlags,        // flags
    IN LPVOID              lpFormat,       // format of frame to decompress
    IN LPVOID              lpData,         // frame data to decompress
    IN DWORD               cbData,         // size of data
    IN LONG                lTime           // time to draw this frame
    );


// ICMessage is not supported on Win32, so provide a static inline function
// to do the same job
static __inline LRESULT VFWAPI
ICDrawSuggestFormat(
            HIC hic,
            LPBITMAPINFOHEADER lpbiIn,
            LPBITMAPINFOHEADER lpbiOut,
            int dxSrc,
            int dySrc,
            int dxDst,
            int dyDst,
            HIC hicDecomp)
{
    ICDRAWSUGGEST ic;

    ic.lpbiIn = lpbiIn;
    ic.lpbiSuggest = lpbiOut;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    ic.hicDecompressor = hicDecomp;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DRAW_SUGGESTFORMAT, (DWORD_PTR)&ic, sizeof(ic));
}


/*
 *  ICDrawQuery()
 *
 *  determines if the compressor is willing to render the specified format.
 *
 */
#define ICDrawQuery(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_QUERY, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICDrawChangePalette(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_CHANGEPALETTE, (DWORD_PTR)(LPVOID)(lpbiInput), 0L)

#define ICGetBuffersWanted(hic, lpdwBuffers) \
    ICSendMessage(hic, ICM_GETBUFFERSWANTED, (DWORD_PTR)(LPVOID)(lpdwBuffers), 0)

#define ICDrawEnd(hic) \
    ICSendMessage(hic, ICM_DRAW_END, 0, 0)

#define ICDrawStart(hic) \
    ICSendMessage(hic, ICM_DRAW_START, 0, 0)

#define ICDrawStartPlay(hic, lFrom, lTo) \
    ICSendMessage(hic, ICM_DRAW_START_PLAY, (DWORD_PTR)(lFrom), (DWORD_PTR)(lTo))

#define ICDrawStop(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP, 0, 0)

#define ICDrawStopPlay(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP_PLAY, 0, 0)

#define ICDrawGetTime(hic, lplTime) \
    ICSendMessage(hic, ICM_DRAW_GETTIME, (DWORD_PTR)(LPVOID)(lplTime), 0)

#define ICDrawSetTime(hic, lTime) \
    ICSendMessage(hic, ICM_DRAW_SETTIME, (DWORD_PTR)lTime, 0)

#define ICDrawRealize(hic, hdc, fBackground) \
    ICSendMessage(hic, ICM_DRAW_REALIZE, (DWORD_PTR)(UINT_PTR)(HDC)(hdc), (DWORD_PTR)(BOOL)(fBackground))

#define ICDrawFlush(hic) \
    ICSendMessage(hic, ICM_DRAW_FLUSH, 0, 0)

#define ICDrawRenderBuffer(hic) \
    ICSendMessage(hic, ICM_DRAW_RENDERBUFFER, 0, 0)

/************************************************************************

    Status callback functions

************************************************************************/

/*
 *  ICSetStatusProc()
 *
 *  Set the status callback function
 *
 */


// ICMessage is not supported on NT
static __inline LRESULT VFWAPI
ICSetStatusProc(
            HIC hic,
            DWORD dwFlags,
            LRESULT lParam,
            LONG (CALLBACK *fpfnStatus)(LPARAM, UINT, LONG) )
{
    ICSETSTATUSPROC ic;

    ic.dwFlags = dwFlags;
    ic.lParam = lParam;
    ic.Status = fpfnStatus;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_SET_STATUS_PROC, (DWORD_PTR)&ic, sizeof(ic));
}


/************************************************************************

helper routines for DrawDib and MCIAVI...

************************************************************************/

#define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \
    ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS)

#define ICDrawOpen(fccType, fccHandler, lpbiIn) \
    ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW)

HIC
VFWAPI
ICLocate(
    IN DWORD fccType,
    IN DWORD fccHandler,
    IN LPBITMAPINFOHEADER lpbiIn,
    IN LPBITMAPINFOHEADER lpbiOut,
    IN WORD wFlags
    );

HIC
VFWAPI
ICGetDisplayFormat(
    IN HIC hic,
    IN LPBITMAPINFOHEADER lpbiIn,
    OUT LPBITMAPINFOHEADER lpbiOut,
    IN int BitDepth,
    IN int dx,
    IN int dy
    );

/************************************************************************
Higher level functions
************************************************************************/

HANDLE
VFWAPI
ICImageCompress(
    IN HIC                 hic,        // compressor to use
    IN UINT                uiFlags,    // flags (none yet)
    IN LPBITMAPINFO        lpbiIn,     // format to compress from
    IN LPVOID              lpBits,     // data to compress
    IN LPBITMAPINFO        lpbiOut,    // compress to this (NULL ==> default)
    IN LONG                lQuality,   // quality to use
    IN OUT LONG FAR *      plSize      // compress to this size (0=whatever)
    );

HANDLE
VFWAPI
ICImageDecompress(
    IN HIC                 hic,        // compressor to use
    IN UINT                uiFlags,    // flags (none yet)
    IN LPBITMAPINFO        lpbiIn,     // format to decompress from
    IN LPVOID              lpBits,     // data to decompress
    IN LPBITMAPINFO        lpbiOut     // decompress to this (NULL ==> default)
    );

//
// Structure used by ICSeqCompressFrame and ICCompressorChoose routines
// Make sure this matches the autodoc in icm.c!
//
typedef struct {
    LONG		cbSize;		// set to sizeof(COMPVARS) before
					// calling ICCompressorChoose
    DWORD		dwFlags;	// see below...
    HIC			hic;		// HIC of chosen compressor
    DWORD               fccType;	// basically ICTYPE_VIDEO
    DWORD               fccHandler;	// handler of chosen compressor or
					// "" or "DIB "
    LPBITMAPINFO	lpbiIn;		// input format
    LPBITMAPINFO	lpbiOut;	// output format - will compress to this
    LPVOID		lpBitsOut;
    LPVOID		lpBitsPrev;
    LONG		lFrame;
    LONG		lKey;		// key frames how often?
    LONG		lDataRate;	// desired data rate KB/Sec
    LONG		lQ;		// desired quality
    LONG		lKeyCount;
    LPVOID		lpState;	// state of compressor
    LONG		cbState;	// size of the state
} COMPVARS, FAR *PCOMPVARS;

// FLAGS for dwFlags element of COMPVARS structure:
// set this flag if you initialize COMPVARS before calling ICCompressorChoose
#define ICMF_COMPVARS_VALID	0x00000001	// COMPVARS contains valid data

//
//  allows user to choose compressor, quality etc...
//
BOOL
VFWAPI
ICCompressorChoose(
    IN     HWND        hwnd,               // parent window for dialog
    IN     UINT        uiFlags,            // flags
    IN     LPVOID      pvIn,               // input format (optional)
    IN     LPVOID      lpData,             // input data (optional)
    IN OUT PCOMPVARS   pc,                 // data about the compressor/dlg
    IN     LPSTR       lpszTitle           // dialog title (optional)
    );

// defines for uiFlags
#define ICMF_CHOOSE_KEYFRAME	0x0001	// show KeyFrame Every box
#define ICMF_CHOOSE_DATARATE	0x0002	// show DataRate box
#define ICMF_CHOOSE_PREVIEW	0x0004	// allow expanded preview dialog
#define ICMF_CHOOSE_ALLCOMPRESSORS	0x0008	// don't only show those that
						// can handle the input format
						// or input data

BOOL
VFWAPI
ICSeqCompressFrameStart(
    IN PCOMPVARS pc,
    IN LPBITMAPINFO lpbiIn
    );

void
VFWAPI
ICSeqCompressFrameEnd(
    IN PCOMPVARS pc
    );

LPVOID
VFWAPI
ICSeqCompressFrame(
    IN  PCOMPVARS               pc,         // set by ICCompressorChoose
    IN  UINT                    uiFlags,    // flags
    IN  LPVOID                  lpBits,     // input DIB bits
    OUT BOOL FAR                *pfKey,     // did it end up being a key frame?
    IN OUT LONG FAR             *plSize     // size to compress to/of returned image
    );

void
VFWAPI
ICCompressorFree(
    IN PCOMPVARS pc
    );

#endif  /* NOCOMPMAN */

/**************************************************************************
 *
 *  DRAWDIB - Routines for drawing to the display.
 *
 *************************************************************************/

#ifndef NODRAWDIB

typedef HANDLE HDRAWDIB; /* hdd */

/*********************************************************************

  DrawDib Flags

**********************************************************************/
#define DDF_0001            0x0001          /* ;Internal */
#define DDF_UPDATE          0x0002          /* re-draw the last DIB */
#define DDF_SAME_HDC        0x0004          /* HDC same as last call (all setup) */
#define DDF_SAME_DRAW       0x0008          /* draw params are the same */
#define DDF_DONTDRAW        0x0010          /* dont draw frame, just decompress */
#define DDF_ANIMATE         0x0020          /* allow palette animation */
#define DDF_BUFFER          0x0040          /* always buffer image */
#define DDF_JUSTDRAWIT      0x0080          /* just draw it with GDI */
#define DDF_FULLSCREEN      0x0100          /* use DisplayDib */
#define DDF_BACKGROUNDPAL   0x0200	    /* Realize palette in background */
#define DDF_NOTKEYFRAME     0x0400          /* this is a partial frame update, hint */
#define DDF_HURRYUP         0x0800          /* hurry up please! */
#define DDF_HALFTONE        0x1000          /* always halftone */
#define DDF_2000            0x2000          /* ;Internal */

#define DDF_PREROLL         DDF_DONTDRAW    /* Builing up a non-keyframe */
#define DDF_SAME_DIB        DDF_SAME_DRAW
#define DDF_SAME_SIZE       DDF_SAME_DRAW

/*********************************************************************

    DrawDib functions
	
*********************************************************************/
/*							// ;Internal
**  DrawDibInit()					// ;Internal
**							// ;Internal
*/							// ;Internal
extern BOOL VFWAPI DrawDibInit(void);			// ;Internal
							// ;Internal
/*
**  DrawDibOpen()
**
*/
extern HDRAWDIB VFWAPI DrawDibOpen(void);

/*
**  DrawDibClose()
**
*/
extern
BOOL
VFWAPI
DrawDibClose(
    IN HDRAWDIB hdd
    );

/*
** DrawDibGetBuffer()
**
*/
extern
LPVOID
VFWAPI
DrawDibGetBuffer(
    IN HDRAWDIB hdd,
    OUT LPBITMAPINFOHEADER lpbi,
    IN DWORD dwSize,
    IN DWORD dwFlags
    );

/*							// ;Internal
**  DrawDibError()					// ;Internal
*/							// ;Internal
extern UINT VFWAPI DrawDibError(HDRAWDIB hdd);		// ;Internal
							// ;Internal
/*
**  DrawDibGetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern
HPALETTE
VFWAPI
DrawDibGetPalette(
    IN HDRAWDIB hdd
    );


/*
**  DrawDibSetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern
BOOL
VFWAPI
DrawDibSetPalette(
    IN HDRAWDIB hdd,
    IN HPALETTE hpal
    );

/*
**  DrawDibChangePalette()
*/
extern
BOOL
VFWAPI
DrawDibChangePalette(
    IN HDRAWDIB hdd,
    IN int iStart,
    IN int iLen,
    IN LPPALETTEENTRY lppe
    );

/*
**  DrawDibRealize()
**
**  realize the palette in a HDD
**
*/
extern
UINT
VFWAPI
DrawDibRealize(
    IN HDRAWDIB hdd,
    IN HDC hdc,
    IN BOOL fBackground
    );

/*
**  DrawDibStart()
**
**  start of streaming playback
**
*/
extern
BOOL
VFWAPI
DrawDibStart(
    IN HDRAWDIB hdd,
    IN DWORD rate
    );

/*
**  DrawDibStop()
**
**  start of streaming playback
**
*/
extern
BOOL
VFWAPI
DrawDibStop(
    IN HDRAWDIB hdd
    );

/*
**  DrawDibBegin()
**
**  prepare to draw
**
*/
extern
BOOL
VFWAPI
DrawDibBegin(
    IN HDRAWDIB hdd,
    IN HDC      hdc,
    IN int      dxDst,
    IN int      dyDst,
    IN LPBITMAPINFOHEADER lpbi,
    IN int      dxSrc,
    IN int      dySrc,
    IN UINT     wFlags
    );

/*
**  DrawDibDraw()
**
**  actualy draw a DIB to the screen.
**
*/
extern
BOOL
VFWAPI
DrawDibDraw(
    IN HDRAWDIB hdd,
    IN HDC      hdc,
    IN int      xDst,
    IN int      yDst,
    IN int      dxDst,
    IN int      dyDst,
    IN LPBITMAPINFOHEADER lpbi,
    IN LPVOID   lpBits,
    IN int      xSrc,
    IN int      ySrc,
    IN int      dxSrc,
    IN int      dySrc,
    IN UINT     wFlags
    );

/*
**  DrawDibUpdate()
**
**  redraw the last image (may only be valid with DDF_BUFFER)
*/
#define DrawDibUpdate(hdd, hdc, x, y) \
        DrawDibDraw(hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, 0, 0, DDF_UPDATE)

/*
**  DrawDibEnd()
*/
extern
BOOL
VFWAPI
DrawDibEnd(
    IN HDRAWDIB hdd
    );

/*
**  DrawDibTime()  [for debugging purposes only]
*/
typedef struct {
    LONG    timeCount;
    LONG    timeDraw;
    LONG    timeDecompress;
    LONG    timeDither;
    LONG    timeStretch;
    LONG    timeBlt;
    LONG    timeSetDIBits;
}   DRAWDIBTIME, FAR *LPDRAWDIBTIME;

BOOL
VFWAPI
DrawDibTime(
    IN HDRAWDIB hdd,
    OUT LPDRAWDIBTIME lpddtime
    );

/* display profiling */
#define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
#define PD_CAN_STRETCHDIB       0x0002      /* basicly RC_STRETCHDIB */
#define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
#define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
#define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */

LRESULT
VFWAPI
DrawDibProfileDisplay(
    IN LPBITMAPINFOHEADER lpbi
    );

#endif  /* NODRAWDIB */

/****************************************************************************
 *
 *  AVIFMT - AVI file format definitions
 *
 ****************************************************************************/

#ifndef NOAVIFMT
    #ifndef _INC_MMSYSTEM
        typedef DWORD FOURCC;
    #endif
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

/* The following is a short description of the AVI file format.  Please
 * see the accompanying documentation for a full explanation.
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI'
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	
 *      	  { LIST('rec'
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *	The main file header specifies how many streams are present.  For
 *	each one, there must be a stream header chunk and a stream format
 *	chunk, enlosed in a 'strl' LIST chunk.  The 'strf' chunk contains
 *	type-specific format information; for a video stream, this should
 *	be a BITMAPINFO structure, including palette.  For an audio stream,
 *	this should be a WAVEFORMAT (or PCMWAVEFORMAT) structure.
 *
 *	The actual data is contained in subchunks within the 'movi' LIST
 *	chunk.  The first two characters of each data chunk are the
 *	stream number with which that data is associated.
 *
 *	Some defined chunk types:
 *           Video Streams:
 *                  ##db:	RGB DIB bits
 *                  ##dc:	RLE8 compressed DIB bits
 *                  ##pc:	Palette Change
 *
 *           Audio Streams:
 *                  ##wb:	waveform audio bytes
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is used for files specifically intended to be played from
 *   CD-ROM.
 *
 * The index chunk at the end of the file should contain one entry for
 *   each data chunk in the file.
 *
 * Limitations for the current software:
 *	Only one video stream and one audio stream are allowed.
 *	The streams must start at the beginning of the file.
 *
 *
 * To register codec types please obtain a copy of the Multimedia
 * Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 */


#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')
#define ckidSTREAMNAME		mmioFOURCC('s', 't', 'r', 'n')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/* Basic chunk types */
#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')

/* Chunk id to use for extra chunks for padding. */
#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')


/*
** Useful macros
**
** Warning: These are nasty macro, and MS C 6.0 compiles some of them
** incorrectly if optimizations are on.  Ack.
*/

/* Macro to get stream number out of a FOURCC ckid */
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | \
			    (ToHex(((stream) & 0xf0) >> 4)), tcc)


/*
** Main AVI File Header
*/	
		
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

typedef struct
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwReserved[4];
} MainAVIHeader;


/*
** Stream header
*/

#define AVISF_DISABLED			0x00000001

#define AVISF_VIDEO_PALCHANGES		0x00010000

typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;
} AVIStreamHeader;

/* Flags for index */
#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)

#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time
#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

#endif /* NOAVIFMT */

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  MMREG.H (standard include file for MM defines, like FOURCC and things)
 *
 ***************************************************************************/

#ifndef RC_INVOKED
#include "pshpack8.h"
#endif
#ifndef NOMMREG
    #include <mmreg.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  AVIFile - routines for reading/writing standard AVI files
 *
 ***************************************************************************/

#ifndef NOAVIFILE

/*
 * Ansi - Unicode thunking.
 *
 * Unicode or Ansi-only apps can call the avifile APIs.
 * any Win32 app who wants to use
 * any of the AVI COM interfaces must be UNICODE - the AVISTREAMINFO and
 * AVIFILEINFO structures used in the Info methods of these interfaces are
 * the unicode variants, and no thunking to or from ansi takes place
 * except in the AVIFILE api entrypoints.
 *
 * For Ansi/Unicode thunking: for each entrypoint or structure that
 * uses chars or strings, two versions are declared in the Win32 version,
 * ApiNameW and ApiNameA. The default name ApiName is #defined to one or
 * other of these depending on whether UNICODE is defined (during
 * compilation of the app that is including this header). The source will
 * contain ApiName and ApiNameA (with ApiName being the Win16 implementation,
 * and also #defined to ApiNameW, and ApiNameA being the thunk entrypoint).
 *
 */

#ifndef mmioFOURCC
    #define mmioFOURCC( ch0, ch1, ch2, ch3 ) \
	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef streamtypeVIDEO
#define streamtypeVIDEO		mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO		mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT		mmioFOURCC('t', 'x', 't', 's')
#endif

#ifndef AVIIF_KEYFRAME
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#endif

// For GetFrame::SetFormat - use the best format for the display
#define AVIGETFRAMEF_BESTDISPLAYFMT	1

//
// Structures used by AVIStreamInfo & AVIFileInfo.
//
// These are related to, but not identical to, the header chunks
// in an AVI file.
//

/*
 *
 * --- AVISTREAMINFO ------------------------------------------------
 *
 * for Unicode/Ansi thunking we need to declare three versions of this!
 */
typedef struct _AVISTREAMINFOW {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    WCHAR		szName[64];
} AVISTREAMINFOW, FAR * LPAVISTREAMINFOW;

typedef struct _AVISTREAMINFOA {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFOA, FAR * LPAVISTREAMINFOA;

#ifdef UNICODE
#define AVISTREAMINFO	AVISTREAMINFOW
#define LPAVISTREAMINFO	LPAVISTREAMINFOW
#else
#define AVISTREAMINFO	AVISTREAMINFOA
#define LPAVISTREAMINFO	LPAVISTREAMINFOA
#endif


#define AVISTREAMINFO_DISABLED			0x00000001
#define AVISTREAMINFO_FORMATCHANGES		0x00010000

/*
 * --- AVIFILEINFO ----------------------------------------------------
 *
 */


typedef struct _AVIFILEINFOW {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    WCHAR		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOW, FAR * LPAVIFILEINFOW;

typedef struct _AVIFILEINFOA {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOA, FAR * LPAVIFILEINFOA;

#ifdef UNICODE
#define AVIFILEINFO	AVIFILEINFOW
#define LPAVIFILEINFO	LPAVIFILEINFOW
#else
#define AVIFILEINFO	AVIFILEINFOA
#define LPAVIFILEINFO	LPAVIFILEINFOA
#endif


// Flags for dwFlags
#define AVIFILEINFO_HASINDEX		0x00000010
#define AVIFILEINFO_MUSTUSEINDEX	0x00000020
#define AVIFILEINFO_ISINTERLEAVED	0x00000100
#define AVIFILEINFO_WASCAPTUREFILE	0x00010000
#define AVIFILEINFO_COPYRIGHTED		0x00020000

// Flags for dwCaps
#define AVIFILECAPS_CANREAD		0x00000001
#define AVIFILECAPS_CANWRITE		0x00000002
#define AVIFILECAPS_ALLKEYFRAMES	0x00000010
#define AVIFILECAPS_NOCOMPRESSION	0x00000020

typedef BOOL (FAR PASCAL * AVISAVECALLBACK)(int);

/************************************************************************/
/* Declaration for the AVICOMPRESSOPTIONS structure.  Make sure it 	*/
/* matches the AutoDoc in avisave.c !!!                            	*/
/************************************************************************/

typedef struct {
    DWORD	fccType;		    /* stream type, for consistency */
    DWORD       fccHandler;                 /* compressor */
    DWORD       dwKeyFrameEvery;            /* keyframe rate */
    DWORD       dwQuality;                  /* compress quality 0-10,000 */
    DWORD       dwBytesPerSecond;           /* bytes per second */
    DWORD       dwFlags;                    /* flags... see below */
    LPVOID      lpFormat;                   /* save format */
    DWORD       cbFormat;
    LPVOID      lpParms;                    /* compressor options */
    DWORD       cbParms;
    DWORD       dwInterleaveEvery;          /* for non-video streams only */
} AVICOMPRESSOPTIONS, FAR *LPAVICOMPRESSOPTIONS;

//
// Defines for the dwFlags field of the AVICOMPRESSOPTIONS struct
// Each of these flags determines if the appropriate field in the structure
// (dwInterleaveEvery, dwBytesPerSecond, and dwKeyFrameEvery) is payed
// attention to.  See the autodoc in avisave.c for details.
//
#define AVICOMPRESSF_INTERLEAVE		0x00000001    // interleave
#define AVICOMPRESSF_DATARATE		0x00000002    // use a data rate
#define AVICOMPRESSF_KEYFRAMES		0x00000004    // use keyframes
#define AVICOMPRESSF_VALID		0x00000008    // has valid data?

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

#include <ole2.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*	-	-	-	-	-	-	-	-	*/


/****** AVI Stream Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIStream

DECLARE_INTERFACE_(IAVIStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStream methods ***
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2) PURE ;
    STDMETHOD(Info)        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize) PURE ;
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags) PURE ;
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat) PURE ;
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat) PURE ;
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples) PURE ;
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten) PURE ;
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples) PURE;
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb) PURE ;
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb) PURE ;
#ifdef _WIN32
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW FAR * lpInfo,
			    LONG cbInfo) PURE;
#else
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
#endif
};

typedef       IAVIStream FAR* PAVISTREAM;


#undef  INTERFACE
#define INTERFACE   IAVIStreaming

DECLARE_INTERFACE_(IAVIStreaming, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStreaming methods ***
    STDMETHOD(Begin) (THIS_
		      LONG  lStart,		    // start of what we expect
						    // to play
		      LONG  lEnd,		    // expected end, or -1
		      LONG  lRate) PURE;	    // Should this be a float?
    STDMETHOD(End)   (THIS) PURE;
};

typedef       IAVIStreaming FAR* PAVISTREAMING;


#undef  INTERFACE
#define INTERFACE   IAVIEditStream

DECLARE_INTERFACE_(IAVIEditStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIEditStream methods ***
    STDMETHOD(Cut) (THIS_ LONG FAR *plStart,
			  LONG FAR *plLength,
			  PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Copy) (THIS_ LONG FAR *plStart,
			   LONG FAR *plLength,
			   PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Paste) (THIS_ LONG FAR *plPos,
			    LONG FAR *plLength,
			    PAVISTREAM pstream,
			    LONG lStart,
			    LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ PAVISTREAM FAR *ppResult) PURE;
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW FAR * lpInfo,
			    LONG cbInfo) PURE;
};

typedef       IAVIEditStream FAR* PAVIEDITSTREAM;


/****** AVI File Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IAVIFile
#define PAVIFILE IAVIFile FAR*

DECLARE_INTERFACE_(IAVIFile, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIFile methods ***
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFOW FAR * pfi,
                                     LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFOW FAR * psi) PURE;
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData) PURE;
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData) PURE;
    STDMETHOD(EndRecord)            (THIS) PURE;
    STDMETHOD(DeleteStream)         (THIS_
				     DWORD fccType,
                                     LONG lParam) PURE;
};

#undef PAVIFILE
typedef       IAVIFile FAR* PAVIFILE;

/****** GetFrame Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IGetFrame
#define PGETFRAME   IGetFrame FAR*

DECLARE_INTERFACE_(IGetFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGetFrame methods ***

    STDMETHOD_(LPVOID,GetFrame) (THIS_ LONG lPos) PURE;
//  STDMETHOD_(LPVOID,GetFrameData) (THIS_ LONG lPos) PURE;

    STDMETHOD(Begin) (THIS_ LONG lStart, LONG lEnd, LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;

    STDMETHOD(SetFormat) (THIS_ LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy) PURE;

//  STDMETHOD(DrawFrameStart) (THIS) PURE;
//  STDMETHOD(DrawFrame) (THIS_ LONG lPos, HDC hdc, int x, int y, int dx, int dy) PURE;
//  STDMETHOD(DrawFrameEnd) (THIS) PURE;
};

#undef PGETFRAME
typedef IGetFrame FAR* PGETFRAME;

/****** GUIDs *******************************************/

#define DEFINE_AVIGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
DEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);
DEFINE_AVIGUID(IID_IGetFrame,           0x00020023, 0, 0);
DEFINE_AVIGUID(IID_IAVIEditStream,      0x00020024, 0, 0);
#ifndef UNICODE
DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,        0x00020009, 0, 0);
#endif

DEFINE_AVIGUID(CLSID_AVIFile,           0x00020000, 0, 0);

#define	AVIFILEHANDLER_CANREAD		0x0001
#define	AVIFILEHANDLER_CANWRITE		0x0002
#define	AVIFILEHANDLER_CANACCEPTNONRGB	0x0004

//
// functions
//

STDAPI_(void) AVIFileInit(void);   // Call this first!
STDAPI_(void) AVIFileExit(void);

STDAPI_(ULONG) AVIFileAddRef       (PAVIFILE pfile);
STDAPI_(ULONG) AVIFileRelease      (PAVIFILE pfile);

#ifdef _WIN32
STDAPI AVIFileOpenA       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
STDAPI AVIFileOpenW       (PAVIFILE FAR * ppfile, LPCWSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#ifdef UNICODE
#define AVIFileOpen	  AVIFileOpenW	
#else
#define AVIFileOpen	  AVIFileOpenA	
#endif
#else // win16
STDAPI AVIFileOpen       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#define AVIFileOpenW	AVIFileOpen	    /* ;Internal */
#endif

#ifdef _WIN32
STDAPI AVIFileInfoW (PAVIFILE pfile, LPAVIFILEINFOW pfi, LONG lSize);
STDAPI AVIFileInfoA (PAVIFILE pfile, LPAVIFILEINFOA pfi, LONG lSize);
#ifdef UNICODE
#define AVIFileInfo	AVIFileInfoW
#else
#define AVIFileInfo	AVIFileInfoA
#endif
#else //win16 version
STDAPI AVIFileInfo (PAVIFILE pfile, LPAVIFILEINFO pfi, LONG lSize);
#define AVIFileInfoW AVIFileInfo	    /* ;Internal */
#endif


STDAPI AVIFileGetStream     (PAVIFILE pfile, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam);


#ifdef _WIN32
STDAPI AVIFileCreateStreamW (PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFOW FAR * psi);
STDAPI AVIFileCreateStreamA (PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFOA FAR * psi);
#ifdef UNICODE
#define AVIFileCreateStream	AVIFileCreateStreamW
#else
#define AVIFileCreateStream	AVIFileCreateStreamA
#endif
#else //win16 version
STDAPI AVIFileCreateStream(PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFO FAR * psi);
#define AVIFileCreateStreamW AVIFileCreateStream	    /* ;Internal */
#endif

STDAPI AVIFileWriteData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData);
STDAPI AVIFileReadData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR *lpcbData);
STDAPI AVIFileEndRecord	(PAVIFILE pfile);

STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi);
STDAPI_(ULONG) AVIStreamRelease      (PAVISTREAM pavi);

STDAPI AVIStreamInfoW (PAVISTREAM pavi, LPAVISTREAMINFOW psi, LONG lSize);
STDAPI AVIStreamInfoA (PAVISTREAM pavi, LPAVISTREAMINFOA psi, LONG lSize);
#ifdef UNICODE
#define AVIStreamInfo	AVIStreamInfoW
#else
#define AVIStreamInfo	AVIStreamInfoA
#endif

STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags);
STDAPI AVIStreamReadFormat   (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG FAR *lpcbFormat);
STDAPI AVIStreamSetFormat    (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG cbFormat);
STDAPI AVIStreamReadData     (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG FAR *lpcb);
STDAPI AVIStreamWriteData    (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG cb);

STDAPI AVIStreamRead         (PAVISTREAM pavi,
			      LONG lStart,
			      LONG lSamples,
			      LPVOID lpBuffer,
			      LONG cbBuffer,
			      LONG FAR * plBytes,
			      LONG FAR * plSamples);
#define AVISTREAMREAD_CONVENIENT	(-1L)

STDAPI AVIStreamWrite        (PAVISTREAM pavi,
			      LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);

// Right now, these just use AVIStreamInfo() to get information, then
// return some of it.  Can they be more efficient?
STDAPI_(LONG) AVIStreamStart        (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamLength       (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime);
STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample);


STDAPI AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
STDAPI AVIStreamEndStreaming(PAVISTREAM pavi);

//
// helper functions for using IGetFrame
//
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi,
					 LPBITMAPINFOHEADER lpbiWanted);
STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pg, LONG lPos);
STDAPI AVIStreamGetFrameClose(PGETFRAME pg);


// !!! We need some way to place an advise on a stream....
// STDAPI AVIStreamHasChanged   (PAVISTREAM pavi);



// Shortcut function
STDAPI AVIStreamOpenFromFileA(PAVISTREAM FAR *ppavi, LPCSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
STDAPI AVIStreamOpenFromFileW(PAVISTREAM FAR *ppavi, LPCWSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
#ifdef UNICODE
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileW
#else
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileA
#endif

// Use to create disembodied streams
STDAPI AVIStreamCreate(PAVISTREAM FAR *ppavi, LONG lParam1, LONG lParam2,
		       CLSID FAR *pclsidHandler);



// PHANDLER    AVIAPI AVIGetHandler         (PAVISTREAM pavi, PAVISTREAMHANDLER psh);
// PAVISTREAM  AVIAPI AVIGetStream          (PHANDLER p);

//
// flags for AVIStreamFindSample
//
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward
#define FIND_FROM_START 0x00000008L     // start at the logical beginning

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change

#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return physical index position


//
//  stuff to support backward compat.
//
#define AVIStreamFindKeyFrame AVIStreamFindSample
#define FindKeyFrame	FindSample

#define AVIStreamClose AVIStreamRelease
#define AVIFileClose   AVIFileRelease
#define AVIStreamInit  AVIFileInit
#define AVIStreamExit  AVIFileExit

#define SEARCH_NEAREST  FIND_PREV
#define SEARCH_BACKWARD FIND_PREV
#define SEARCH_FORWARD  FIND_NEXT
#define SEARCH_KEY      FIND_KEY
#define SEARCH_ANY      FIND_ANY

//
//  helper macros.
//
#define     AVIStreamSampleToSample(pavi1, pavi2, l) \
            AVIStreamTimeToSample(pavi1,AVIStreamSampleToTime(pavi2, l))

#define     AVIStreamNextSample(pavi, l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_ANY)

#define     AVIStreamPrevSample(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_ANY)

#define     AVIStreamNearestSample(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_ANY)

#define     AVIStreamNextKeyFrame(pavi,l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_KEY)

#define     AVIStreamPrevKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_KEY)

#define     AVIStreamNearestKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_KEY)

#define     AVIStreamIsKeyFrame(pavi, l) \
            (AVIStreamNearestKeyFrame(pavi,l) == l)

#define     AVIStreamPrevSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNearestSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamPrevKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamNearestKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamStartTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamStart(pavi))

#define     AVIStreamLengthTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamLength(pavi))

#define     AVIStreamEnd(pavi) \
            (AVIStreamStart(pavi) + AVIStreamLength(pavi))

#define     AVIStreamEndTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamEnd(pavi))

#define     AVIStreamSampleSize(pavi, lPos, plSize) \
	    AVIStreamRead(pavi,lPos,1,NULL,0,plSize,NULL)

#define     AVIStreamFormatSize(pavi, lPos, plSize) \
            AVIStreamReadFormat(pavi,lPos,NULL,plSize)

#define     AVIStreamDataSize(pavi, fcc, plSize) \
            AVIStreamReadData(pavi,fcc,NULL,plSize)

/****************************************************************************
 *
 *  AVISave routines and structures
 *
 ***************************************************************************/

#ifndef comptypeDIB
#define comptypeDIB         mmioFOURCC('D', 'I', 'B', ' ')
#endif

STDAPI AVIMakeCompressedStream(
		PAVISTREAM FAR *	    ppsCompressed,
		PAVISTREAM		    ppsSource,
		AVICOMPRESSOPTIONS FAR *    lpOptions,
		CLSID FAR *pclsidHandler);

EXTERN_C HRESULT CDECL AVISaveA (LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVA(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
EXTERN_C HRESULT CDECL AVISaveW (LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVW(LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
#ifdef UNICODE
#define AVISave		AVISaveW
#define AVISaveV	AVISaveVW
#else
#define AVISave		AVISaveA
#define AVISaveV	AVISaveVA
#endif



STDAPI_(INT_PTR) AVISaveOptions(HWND hwnd,
			     UINT	uiFlags,
			     int	nStreams,
			     PAVISTREAM FAR *ppavi,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

STDAPI AVISaveOptionsFree(int nStreams,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

// FLAGS FOR uiFlags:
//
// Same as the flags for ICCompressorChoose (see compman.h)
// These determine what the compression options dialog for video streams
// will look like.

STDAPI AVIBuildFilterW(LPWSTR lpszFilter, LONG cbFilter, BOOL fSaving);
STDAPI AVIBuildFilterA(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving);
#ifdef UNICODE
#define AVIBuildFilter	AVIBuildFilterW
#else
#define AVIBuildFilter	AVIBuildFilterA
#endif
STDAPI AVIMakeFileFromStreams(PAVIFILE FAR *	ppfile,
			       int		nStreams,
			       PAVISTREAM FAR *	papStreams);

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, HANDLE hGlobal, PAVISTREAM FAR *ppstream);

/****************************************************************************
 *
 *  Clipboard routines
 *
 ***************************************************************************/

STDAPI AVIPutFileOnClipboard(PAVIFILE pf);

STDAPI AVIGetFromClipboard(PAVIFILE FAR * lppf);

STDAPI AVIClearClipboard(void);

/****************************************************************************
 *
 *  Editing routines
 *
 ***************************************************************************/
STDAPI CreateEditableStream(
		PAVISTREAM FAR *	    ppsEditable,
		PAVISTREAM		    psSource);

STDAPI EditStreamCut(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamCopy(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamPaste(PAVISTREAM pavi, LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lEnd);

STDAPI EditStreamClone(PAVISTREAM pavi, PAVISTREAM FAR *ppResult);


STDAPI EditStreamSetNameA(PAVISTREAM pavi, LPCSTR lpszName);
STDAPI EditStreamSetNameW(PAVISTREAM pavi, LPCWSTR lpszName);
STDAPI EditStreamSetInfoW(PAVISTREAM pavi, LPAVISTREAMINFOW lpInfo, LONG cbInfo);
STDAPI EditStreamSetInfoA(PAVISTREAM pavi, LPAVISTREAMINFOA lpInfo, LONG cbInfo);
#ifdef UNICODE
#define EditStreamSetInfo	EditStreamSetInfoW
#define EditStreamSetName	EditStreamSetNameW
#else
#define EditStreamSetInfo	EditStreamSetInfoA
#define EditStreamSetName	EditStreamSetNameA
#endif

/*	-	-	-	-	-	-	-	-	*/

#ifndef AVIERR_OK
#define AVIERR_OK               0L

#define MAKE_AVIERR(error)	MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x4000 + error)

// !!! Questions to be answered:
// How can you get a string form of these errors?
// Which of these errors should be replaced by errors in SCODE.H?
#define AVIERR_UNSUPPORTED      MAKE_AVIERR(101)
#define AVIERR_BADFORMAT        MAKE_AVIERR(102)
#define AVIERR_MEMORY           MAKE_AVIERR(103)
#define AVIERR_INTERNAL         MAKE_AVIERR(104)
#define AVIERR_BADFLAGS         MAKE_AVIERR(105)
#define AVIERR_BADPARAM         MAKE_AVIERR(106)
#define AVIERR_BADSIZE          MAKE_AVIERR(107)
#define AVIERR_BADHANDLE        MAKE_AVIERR(108)
#define AVIERR_FILEREAD         MAKE_AVIERR(109)
#define AVIERR_FILEWRITE        MAKE_AVIERR(110)
#define AVIERR_FILEOPEN         MAKE_AVIERR(111)
#define AVIERR_COMPRESSOR       MAKE_AVIERR(112)
#define AVIERR_NOCOMPRESSOR     MAKE_AVIERR(113)
#define AVIERR_READONLY		MAKE_AVIERR(114)
#define AVIERR_NODATA		MAKE_AVIERR(115)
#define AVIERR_BUFFERTOOSMALL	MAKE_AVIERR(116)
#define AVIERR_CANTCOMPRESS	MAKE_AVIERR(117)
#define AVIERR_USERABORT        MAKE_AVIERR(198)
#define AVIERR_ERROR            MAKE_AVIERR(199)
#endif
#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  MCIWnd - Window class for MCI objects
 *
 ***************************************************************************/

#ifndef NOMCIWND
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class header file.
 *
 *    the MCIWnd window class is a window class for controling MCI devices
 *    MCI devices include, wave files, midi files, AVI Video, cd audio,
 *    vcr, video disc, and others..
 *
 *    to learn more about MCI and mci command sets see the
 *    "Microsoft Multimedia Programmers's guide" in the Win31 SDK
 *
 *    the easiest use of the MCIWnd class is like so:
 *
 *          hwnd = MCIWndCreate(hwndParent, hInstance, 0, "chimes.wav");
 *          ...
 *          MCIWndPlay(hwnd);
 *          MCIWndStop(hwnd);
 *          MCIWndPause(hwnd);
 *          ....
 *          MCIWndDestroy(hwnd);
 *
 *    this will create a window with a play/pause, stop and a playbar
 *    and start the wave file playing.
 *
 *    mciwnd.h defines macros for all the most common MCI commands, but
 *    any string command can be used if needed.
 *
 *    Note: unlike the mciSendString() API, no alias or file name needs
 *    to be specifed, since the device to use is implied by the window handle.
 *
 *          MCIWndSendString(hwnd, "setaudio stream to 2");
 *
 *    (C) Copyright Microsoft Corp. 1991-1995.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files.
 *
 *    If you did not get this from Microsoft Sources, then it may not be the
 *    most current version.  This sample code in particular will be updated
 *    and include more documentation.
 *
 *    Sources are:
 *       CompuServe: WINSDK forum, MDK section.
 *       Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
 *
 * WIN32:
 *
 *    MCIWnd supports both ansi and unicode interfaces. For any message that
 *    takes or returns a text string, two versions of the message are defined,
 *    appended with A or W for Ansi or Wide Char. The message or api itself
 *    is defined to be one or other of these depending on whether you have
 *    UNICODE defined in your application.
 *    Thus for the api MCIWndCreate, there are in fact two apis,
 *    MCIWndCreateA and MCIWndCreateW. If you call MCIWndCreate, this will be
 *    re-routed to MCIWndCreateA unless UNICODE is defined when building your
 *    application. In any one application, you can mix calls to the
 *    Ansi and Unicode entrypoints.
 *
 *    If you use SendMessage instead of the macros below such as MCIWndOpen(),
 *    you will see that the messages have changed for WIN32, to support Ansi
 *    and Unicode entrypoints. In particular, MCI_OPEN has been replaced by
 *    MCWNDM_OPENA, or MCIWNDM_OPENW (MCIWNDM_OPEN is defined to be one or
 *    other of these).
 *
 *    Also, note that the WIN32 implementation of MCIWnd uses UNICODE
 *    so all apis and messages supporting ANSI strings do so by mapping them
 *    UNICODE strings and then calling the corresponding UNICODE entrypoint.
 *
 *----------------------------------------------------------------------------*/

#ifdef __cplusplus
// MFC Redefines SendMessage, so make sure we get the global one....
#define MCIWndSM ::SendMessage  /* SendMessage in C++*/
#else
#define MCIWndSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */
#define MCIWND_WINDOW_CLASS TEXT("MCIWndClass")
HWND
VFWAPIV
MCIWndCreateA(
    IN HWND hwndParent,
    IN HINSTANCE hInstance,
    IN DWORD dwStyle,
    IN LPCSTR szFile
    );

HWND
VFWAPIV
MCIWndCreateW(
    IN HWND hwndParent,
    IN HINSTANCE hInstance,
    IN DWORD dwStyle,
    IN LPCWSTR szFile
    );

#ifdef UNICODE
#define MCIWndCreate    MCIWndCreateW
#else
#define MCIWndCreate    MCIWndCreateA
#endif
BOOL VFWAPIV MCIWndRegisterClass(void);

// Flags for the MCIWndOpen command
#define MCIWNDOPENF_NEW	            0x0001  // open a new file

// window styles
#define MCIWNDF_NOAUTOSIZEWINDOW    0x0001  // when movie size changes
#define MCIWNDF_NOPLAYBAR           0x0002  // no toolbar
#define MCIWNDF_NOAUTOSIZEMOVIE     0x0004  // when window size changes
#define MCIWNDF_NOMENU              0x0008  // no popup menu from RBUTTONDOWN
#define MCIWNDF_SHOWNAME            0x0010  // show name in caption
#define MCIWNDF_SHOWPOS             0x0020  // show position in caption
#define MCIWNDF_SHOWMODE            0x0040  // show mode in caption
#define MCIWNDF_SHOWALL             0x0070  // show all

#define MCIWNDF_NOTIFYMODE         0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOS          0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZE         0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYERROR        0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALL          0x1F00  // tell all

#define MCIWNDF_NOTIFYANSI	   0x0080


// The MEDIA notification includes a text string.
// To receive notifications in ANSI instead of unicode set the
// MCIWNDF_NOTIFYANSI style bit. The macro below includes this bit
// by default unless you define UNICODE in your application.

#define MCIWNDF_NOTIFYMEDIAA       0x0880  // tell parent of media change
#define MCIWNDF_NOTIFYMEDIAW       0x0800  // tell parent of media change

#ifdef UNICODE
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAW
#else
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAA
#endif



#define MCIWNDF_RECORD              0x2000  // Give a record button
#define MCIWNDF_NOERRORDLG          0x4000  // Show Error Dlgs for MCI cmds?
#define MCIWNDF_NOOPEN		    0x8000  // Don't allow user to open things




// can macros

#define MCIWndCanPlay(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,0,0)
#define MCIWndCanRecord(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,0,0)
#define MCIWndCanSave(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,0,0)
#define MCIWndCanWindow(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,0,0)
#define MCIWndCanEject(hwnd)        (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,0,0)
#define MCIWndCanConfig(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,0,0)
#define MCIWndPaletteKick(hwnd)     (BOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,0,0)

#define MCIWndSave(hwnd, szFile)    (LONG)MCIWndSM(hwnd, MCI_SAVE, 0, (LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd)      MCIWndSave(hwnd, -1)

// if you dont give a device it will use the current device....
#define MCIWndNew(hwnd, lp)         (LONG)MCIWndSM(hwnd, MCIWNDM_NEW, 0, (LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RECORD, 0, 0)
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#define MCIWndOpenDialog(hwnd)      MCIWndOpen(hwnd, -1, 0)
#define MCIWndClose(hwnd)           (LONG)MCIWndSM(hwnd, MCI_CLOSE, 0, 0)
#define MCIWndPlay(hwnd)            (LONG)MCIWndSM(hwnd, MCI_PLAY, 0, 0)
#define MCIWndStop(hwnd)            (LONG)MCIWndSM(hwnd, MCI_STOP, 0, 0)
#define MCIWndPause(hwnd)           (LONG)MCIWndSM(hwnd, MCI_PAUSE, 0, 0)
#define MCIWndResume(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RESUME, 0, 0)
#define MCIWndSeek(hwnd, lPos)      (LONG)MCIWndSM(hwnd, MCI_SEEK, 0, (LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd)           (LONG)MCIWndSM(hwnd, MCIWNDM_EJECT, 0, 0)

#define MCIWndHome(hwnd)            MCIWndSeek(hwnd, MCIWND_START)
#define MCIWndEnd(hwnd)             MCIWndSeek(hwnd, MCIWND_END)

#define MCIWndGetSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_GET_SOURCE, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_SOURCE, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_GET_DEST, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_DEST, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYREVERSE, 0, 0)
#define MCIWndPlayFrom(hwnd, lPos)  (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYFROM, 0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd, lPos)    (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYTO,   0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd, lStart, lEnd) (MCIWndSeek(hwnd, lStart), MCIWndPlayTo(hwnd, lEnd))

#define MCIWndGetDeviceID(hwnd)     (UINT)MCIWndSM(hwnd, MCIWNDM_GETDEVICEID, 0, 0)
#define MCIWndGetAlias(hwnd)        (UINT)MCIWndSM(hwnd, MCIWNDM_GETALIAS, 0, 0)
#define MCIWndGetMode(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETMODE, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetPosition(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, 0, 0)
#define MCIWndGetPositionString(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetStart(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSTART, 0, 0)
#define MCIWndGetLength(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETLENGTH, 0, 0)
#define MCIWndGetEnd(hwnd)          (LONG)MCIWndSM(hwnd, MCIWNDM_GETEND, 0, 0)

#define MCIWndStep(hwnd, n)         (LONG)MCIWndSM(hwnd, MCI_STEP, 0,(LPARAM)(long)(n))

#define MCIWndDestroy(hwnd)         (VOID)MCIWndSM(hwnd, WM_CLOSE, 0, 0)
#define MCIWndSetZoom(hwnd,iZoom)   (VOID)MCIWndSM(hwnd, MCIWNDM_SETZOOM, 0, (LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd)         (UINT)MCIWndSM(hwnd, MCIWNDM_GETZOOM, 0, 0)
#define MCIWndSetVolume(hwnd,iVol)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETVOLUME, 0, (LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETVOLUME, 0, 0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd, MCIWNDM_SETSPEED, 0, (LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSPEED, 0, 0)
#define MCIWndSetTimeFormat(hwnd, lp) (LONG)MCIWndSM(hwnd, MCIWNDM_SETTIMEFORMAT, 0, (LPARAM)(LPTSTR)(lp))
#define MCIWndGetTimeFormat(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETTIMEFORMAT, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndValidateMedia(hwnd)   (VOID)MCIWndSM(hwnd, MCIWNDM_VALIDATEMEDIA, 0, 0)

#define MCIWndSetRepeat(hwnd,f)     (void)MCIWndSM(hwnd, MCIWNDM_SETREPEAT, 0, (LPARAM)(BOOL)(f))
#define MCIWndGetRepeat(hwnd)       (BOOL)MCIWndSM(hwnd, MCIWNDM_GETREPEAT, 0, 0)

#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, TEXT("frames"))
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, TEXT("ms"))

#define MCIWndSetActiveTimer(hwnd, active)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETACTIVETIMER,			\
	(WPARAM)(UINT)(active), 0L)
#define MCIWndSetInactiveTimer(hwnd, inactive)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETINACTIVETIMER,		\
	(WPARAM)(UINT)(inactive), 0L)
#define MCIWndSetTimers(hwnd, active, inactive)				      \
	    (VOID)MCIWndSM(hwnd, MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active), \
	    (LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETACTIVETIMER,	0, 0L);
#define MCIWndGetInactiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETINACTIVETIMER, 0, 0L);

#define MCIWndRealize(hwnd, fBkgnd) (LONG)MCIWndSM(hwnd, MCIWNDM_REALIZE,(WPARAM)(BOOL)(fBkgnd),0)

#define MCIWndSendString(hwnd, sz)  (LONG)MCIWndSM(hwnd, MCIWNDM_SENDSTRING, 0, (LPARAM)(LPTSTR)(sz))
#define MCIWndReturnString(hwnd, lp, len)  (LONG)MCIWndSM(hwnd, MCIWNDM_RETURNSTRING, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETERROR, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

//#define MCIWndActivate(hwnd, f)     (void)MCIWndSM(hwnd, WM_ACTIVATE, (WPARAM)(BOOL)(f), 0)

#define MCIWndGetPalette(hwnd)      (HPALETTE)MCIWndSM(hwnd, MCIWNDM_GETPALETTE, 0, 0)
#define MCIWndSetPalette(hwnd, hpal) (LONG)MCIWndSM(hwnd, MCIWNDM_SETPALETTE, (WPARAM)(HPALETTE)(hpal), 0)

#define MCIWndGetFileName(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd, lp, len)   (LONG)MCIWndSM(hwnd, MCIWNDM_GETDEVICE, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd, MCIWNDM_GETSTYLES, 0, 0L)
#define MCIWndChangeStyles(hwnd, mask, value) (LONG)MCIWndSM(hwnd, MCIWNDM_CHANGESTYLES, (WPARAM)(UINT)(mask), (LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd, pUnk)  (LONG)MCIWndSM(hwnd, MCIWNDM_OPENINTERFACE, 0, (LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd, hwndP)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETOWNER, (WPARAM)(hwndP), 0)


// Messages an app will send to MCIWND

// all the text-related messages are defined out of order above (they need
// to be defined before the MCIWndOpen() macros

#define MCIWNDM_GETDEVICEID	(WM_USER + 100)
#define MCIWNDM_GETSTART	(WM_USER + 103)
#define MCIWNDM_GETLENGTH	(WM_USER + 104)
#define MCIWNDM_GETEND		(WM_USER + 105)
#define MCIWNDM_EJECT		(WM_USER + 107)
#define MCIWNDM_SETZOOM		(WM_USER + 108)
#define MCIWNDM_GETZOOM         (WM_USER + 109)
#define MCIWNDM_SETVOLUME	(WM_USER + 110)
#define MCIWNDM_GETVOLUME	(WM_USER + 111)
#define MCIWNDM_SETSPEED	(WM_USER + 112)
#define MCIWNDM_GETSPEED	(WM_USER + 113)
#define MCIWNDM_SETREPEAT	(WM_USER + 114)
#define MCIWNDM_GETREPEAT	(WM_USER + 115)
#define MCIWNDM_REALIZE         (WM_USER + 118)
#define MCIWNDM_VALIDATEMEDIA   (WM_USER + 121)
#define MCIWNDM_PLAYFROM	(WM_USER + 122)
#define MCIWNDM_PLAYTO          (WM_USER + 123)
#define MCIWNDM_GETPALETTE      (WM_USER + 126)
#define MCIWNDM_SETPALETTE      (WM_USER + 127)
#define MCIWNDM_SETTIMERS	(WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER	(WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER	(WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_CHANGESTYLES	(WM_USER + 135)
#define MCIWNDM_GETSTYLES	(WM_USER + 136)
#define MCIWNDM_GETALIAS	(WM_USER + 137)
#define MCIWNDM_PLAYREVERSE	(WM_USER + 139)
#define MCIWNDM_GET_SOURCE      (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE      (WM_USER + 141)
#define MCIWNDM_GET_DEST        (WM_USER + 142)
#define MCIWNDM_PUT_DEST        (WM_USER + 143)
#define MCIWNDM_CAN_PLAY        (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW      (WM_USER + 145)
#define MCIWNDM_CAN_RECORD      (WM_USER + 146)
#define MCIWNDM_CAN_SAVE        (WM_USER + 147)
#define MCIWNDM_CAN_EJECT       (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG      (WM_USER + 149)
#define MCIWNDM_PALETTEKICK     (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE	(WM_USER + 151)
#define MCIWNDM_SETOWNER	(WM_USER + 152)



//define both A and W messages
#define MCIWNDM_SENDSTRINGA	(WM_USER + 101)
#define MCIWNDM_GETPOSITIONA	(WM_USER + 102)
#define MCIWNDM_GETMODEA	(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMATA  (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMATA  (WM_USER + 120)
#define MCIWNDM_GETFILENAMEA    (WM_USER + 124)
#define MCIWNDM_GETDEVICEA      (WM_USER + 125)
#define MCIWNDM_GETERRORA       (WM_USER + 128)
#define MCIWNDM_NEWA		(WM_USER + 134)
#define MCIWNDM_RETURNSTRINGA	(WM_USER + 138)
#define MCIWNDM_OPENA		(WM_USER + 153)

#define MCIWNDM_SENDSTRINGW	(WM_USER + 201)
#define MCIWNDM_GETPOSITIONW	(WM_USER + 202)
#define MCIWNDM_GETMODEW	(WM_USER + 206)
#define MCIWNDM_SETTIMEFORMATW  (WM_USER + 219)
#define MCIWNDM_GETTIMEFORMATW  (WM_USER + 220)
#define MCIWNDM_GETFILENAMEW    (WM_USER + 224)
#define MCIWNDM_GETDEVICEW      (WM_USER + 225)
#define MCIWNDM_GETERRORW       (WM_USER + 228)
#define MCIWNDM_NEWW		(WM_USER + 234)
#define MCIWNDM_RETURNSTRINGW	(WM_USER + 238)
#define MCIWNDM_OPENW		(WM_USER + 252)

// map defaults to A or W depending on app's UNICODE setting
#ifdef UNICODE
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGW
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONW
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEW
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATW
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATW
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEW
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEW
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORW
#define MCIWNDM_NEW             MCIWNDM_NEWW
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGW
#define MCIWNDM_OPEN		MCIWNDM_OPENW
#else
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGA
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONA
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEA
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATA
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATA
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEA
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEA
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORA
#define MCIWNDM_NEW             MCIWNDM_NEWA
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGA
#define MCIWNDM_OPEN		MCIWNDM_OPENA
#endif

// note that the source text for MCIWND will thus contain
// support for eg MCIWNDM_SENDSTRING (both the 16-bit entrypoint and
// in win32 mapped to MCIWNDM_SENDSTRINGW), and MCIWNDM_SENDSTRINGA (the
// win32 ansi thunk).







// Messages MCIWND will send to an app
// !!! Use less messages and use a code instead to indicate the type of notify? /* ;Internal */
#define MCIWNDM_NOTIFYMODE      (WM_USER + 200)  // wp = hwnd, lp = mode
#define MCIWNDM_NOTIFYPOS	(WM_USER + 201)  // wp = hwnd, lp = pos
#define MCIWNDM_NOTIFYSIZE	(WM_USER + 202)  // wp = hwnd
#define MCIWNDM_NOTIFYMEDIA     (WM_USER + 203)  // wp = hwnd, lp = fn
#define MCIWNDM_NOTIFYERROR     (WM_USER + 205)  // wp = hwnd, lp = error

// special seek values for START and END
#define MCIWND_START                -1
#define MCIWND_END                  -2

#ifndef MCI_PLAY
    /* MCI command message identifiers */
#ifndef _WIN32
    // win32 apps send MCIWNDM_OPEN
    #define MCI_OPEN                        0x0803
#endif
    #define MCI_CLOSE                       0x0804
    #define MCI_PLAY                        0x0806
    #define MCI_SEEK                        0x0807
    #define MCI_STOP                        0x0808
    #define MCI_PAUSE                       0x0809
    #define MCI_STEP                        0x080E
    #define MCI_RECORD                      0x080F
    #define MCI_SAVE                        0x0813
    #define MCI_CUT                         0x0851
    #define MCI_COPY                        0x0852
    #define MCI_PASTE                       0x0853
    #define MCI_RESUME                      0x0855
    #define MCI_DELETE                      0x0856
#endif

#ifndef MCI_MODE_NOT_READY
    /* return values for 'status mode' command */
    #define MCI_MODE_NOT_READY      (524)
    #define MCI_MODE_STOP           (525)
    #define MCI_MODE_PLAY           (526)
    #define MCI_MODE_RECORD         (527)
    #define MCI_MODE_SEEK           (528)
    #define MCI_MODE_PAUSE          (529)
    #define MCI_MODE_OPEN           (530)
#endif

#endif  /* NOAVIFILE */

/****************************************************************************
 *
 *  VIDEO - Video Capture Driver Interface
 *
 ****************************************************************************/

#if !defined(NOAVICAP) || !defined(NOVIDEO)

#ifndef _RCINVOKED


/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

//#define DV_IDS_PROFILING        (DV_ERR_BASE + 900)
//#define DV_IDS_LISTBOX          (DV_ERR_BASE + 901)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD_PTR   dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD_PTR   dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */


/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#endif  /* NOVIDEO */

/****************************************************************************
 *
 *  AVICAP - Window class for AVI capture
 *
 ***************************************************************************/

#ifndef NOAVICAP
#ifdef __cplusplus
/* SendMessage in C++*/
#define AVICapSM(hwnd,m,w,l) ( (::IsWindow(hwnd)) ? ::SendMessage(hwnd,m,w,l) : 0)
#else
/* SendMessage in C */
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ?   SendMessage(hwnd,m,w,l) : 0)
#endif  /* __cplusplus */

#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------



// UNICODE
//
// The Win32 version of AVICAP on NT supports UNICODE applications:
// for each API or message that takes a char or string parameter, there are
// two versions, ApiNameA and ApiNameW. The default name ApiName is #defined
// to one or other depending on whether UNICODE is defined. Apps can call
// the A and W apis directly, and mix them.
//
// The 32-bit AVICAP on NT uses unicode exclusively internally.
// ApiNameA() will be implemented as a call to ApiNameW() together with
// translation of strings.




// Defines start of the message range
#define WM_CAP_START                    WM_USER

// start of unicode messages
#define WM_CAP_UNICODE_START            WM_USER+100

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

#define WM_CAP_SET_CALLBACK_ERRORW     (WM_CAP_UNICODE_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSW    (WM_CAP_UNICODE_START+  3)
#define WM_CAP_SET_CALLBACK_ERRORA     (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSA    (WM_CAP_START+  3)
#ifdef UNICODE
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORW
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSW
#else
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORA
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSA
#endif


#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA		(WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA		(WM_CAP_START+  9)

#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)

#define WM_CAP_DRIVER_GET_NAMEA        (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONA     (WM_CAP_START+  13)
#define WM_CAP_DRIVER_GET_NAMEW        (WM_CAP_UNICODE_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONW     (WM_CAP_UNICODE_START+  13)
#ifdef UNICODE
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEW
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONW
#else
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEA
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONA
#endif

#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14)

#define WM_CAP_FILE_SET_CAPTURE_FILEA  (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEA  (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEASA            (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIBA           (WM_CAP_START+  25)
#define WM_CAP_FILE_SET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  21)
#define WM_CAP_FILE_SAVEASW            (WM_CAP_UNICODE_START+  23)
#define WM_CAP_FILE_SAVEDIBW           (WM_CAP_UNICODE_START+  25)
#ifdef UNICODE
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEW
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEW
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASW
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBW
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEA
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEA
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASA
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBA
#endif

// out of order to save on ifdefs
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35)
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)

#define WM_CAP_SET_MCI_DEVICEA         (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICEA         (WM_CAP_START+  67)
#define WM_CAP_SET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  66)
#define WM_CAP_GET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  67)
#ifdef UNICODE
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEW
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEW
#else
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEA
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEA
#endif



#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70)
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71)
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72)

#define WM_CAP_PAL_OPENA               (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVEA               (WM_CAP_START+  81)
#define WM_CAP_PAL_OPENW               (WM_CAP_UNICODE_START+  80)
#define WM_CAP_PAL_SAVEW               (WM_CAP_UNICODE_START+  81)
#ifdef UNICODE
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENW
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEW
#else
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENA
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEA
#endif

#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)


// Defines end of the message range
#define WM_CAP_UNICODE_END              WM_CAP_PAL_SAVEW
#define WM_CAP_END                      WM_CAP_UNICODE_END

// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

// message wrapper macros are defined for the default messages only. Apps
// that wish to mix Ansi and UNICODE message sending will have to
// reference the _A and _W messages directly

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)               (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM)0L))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)            ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, 0L))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    UINT        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?

// following always NULL on Win32.
    HANDLE      hVideoIn;                   // Driver In channel
    HANDLE      hVideoOut;                  // Driver Out channel
    HANDLE      hVideoExtIn;                // Driver Ext In channel
    HANDLE      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    UINT        wNumVideoAllocated;         // Actual number of video buffers
    UINT        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    UINT        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    UINT        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    UINT        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    UINT        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
    UINT        AVStreamMaster;             // Which stream controls length?
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

// ------------------------------------------------------------------
//  AVStreamMaster
//  Since Audio and Video streams generally use non-synchronized capture
//  clocks, this flag determines whether the audio stream is to be considered
//  the master or controlling clock when writing the AVI file:
//
//  AVSTREAMMASTER_AUDIO  - Audio is master, video frame duration is forced
//                          to match audio duration (VFW 1.0, 1.1 default)
//  AVSTREAMMASTER_NONE   - No master, audio and video streams may be of
//                          different lengths
// ------------------------------------------------------------------
#define AVSTREAMMASTER_AUDIO            0 /* Audio master (VFW 1.0, 1.1) */
#define AVSTREAMMASTER_NONE             1 /* No master */

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKW) (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKW)  (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKA) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKA)  (HWND hWnd, int nID, LPCSTR lpsz);
#ifdef UNICODE
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKW
#define CAPERRORCALLBACK   CAPERRORCALLBACKW
#else
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKA
#define CAPERRORCALLBACK   CAPERRORCALLBACKA
#endif
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

HWND VFWAPI capCreateCaptureWindowA (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionA (UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

HWND VFWAPI capCreateCaptureWindowW (
        LPCWSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionW (UINT wDriverIndex,
        LPWSTR lpszName, int cbName,
        LPWSTR lpszVer, int cbVer);
#ifdef UNICODE
#define capCreateCaptureWindow  capCreateCaptureWindowW
#define capGetDriverDescription capGetDriverDescriptionW
#else
#define capCreateCaptureWindow  capCreateCaptureWindowA
#define capGetDriverDescription capGetDriverDescriptionA
#endif

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */

#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */

#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */

#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */

#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
#define IDS_CAP_AUDIO_DROP_COMPERROR 442  /* "Error: Audio data was lost during capture.  Try capturing without compressing." */

/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
#endif  /* NOAVIFILE */

#ifdef __cplusplus
} // extern "C"
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  ACM (Audio compression manager)
 *
 ***************************************************************************/

#ifndef NOMSACM
    #include <msacm.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
 *
 *  FilePreview dialog.
 *
 ***************************************************************************/
#ifdef OFN_READONLY

    BOOL
    VFWAPI
    GetOpenFileNamePreviewA(
        IN OUT LPOPENFILENAMEA lpofn
        );

    BOOL
    VFWAPI
    GetSaveFileNamePreviewA(
        IN OUT LPOPENFILENAMEA lpofn
        );

    BOOL
    VFWAPI
    GetOpenFileNamePreviewW(
        IN OUT LPOPENFILENAMEW lpofn
        );

    BOOL
    VFWAPI
    GetSaveFileNamePreviewW(
        IN OUT LPOPENFILENAMEW lpofn
        );

    #ifdef UNICODE
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewW
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewW
    #else
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewA
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewA
    #endif

#endif // OFN_READONLY

#ifndef RC_INVOKED
#include "poppack.h"
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_VFW */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winber.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    winber.h   Basic Encoding Rules (BER) API header file

Abstract:

   This module is the header file for the 32 bit BER library on
   Windows NT and Windows 95.

Updates :

Environments :

    Win32 user mode

--*/

//
// Only pull in this header file once.
//

#ifndef _WINBER_DEFINED_
#define _WINBER_DEFINED_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WINBER_)
#define WINBERAPI DECLSPEC_IMPORT
#else
//#define WINBERAPI __declspec(dllexport)
#define WINBERAPI
#endif

#ifndef BERAPI
#define BERAPI __cdecl
#endif

#define LBER_ERROR   0xffffffffL
#define LBER_DEFAULT 0xffffffffL

typedef unsigned int ber_tag_t;   /* for BER tags */
typedef int ber_int_t;            /* for BER ints, enums, and Booleans */
typedef unsigned int ber_uint_t;  /* unsigned equivalent of ber_int_t */
typedef int ber_slen_t;           /* signed equivalent of ber_len_t */

//
// This constructs a new BerElement structure containing a copy of the
// data in the supplied berval structure.
//

WINBERAPI BerElement * BERAPI ber_init( BERVAL *pBerVal );

//
// This frees a BerElement which is returned from ber_alloc_t()
// or ber_init(). The second argument - fbuf should always be set
// to 1.
//
//

WINBERAPI VOID BERAPI ber_free( BerElement *pBerElement, INT fbuf );

//
// Frees a BERVAL structure. Applications should not call
// this API to free BERVAL structures which they themselves
// have allocated
//

WINBERAPI VOID BERAPI ber_bvfree( BERVAL *pBerVal );


//
// Frees an array of BERVAL structures.
//

WINBERAPI VOID BERAPI ber_bvecfree( PBERVAL *pBerVal );

//
// Returns a copy of a the supplied berval structure
//

WINBERAPI BERVAL * BERAPI ber_bvdup( BERVAL *pBerVal );


//
// Constructs and returns a BerElement structure. The options field
// contains a bitwise-or of options which are to be used when generating
// the encoding of the BerElement
//
// The LBER_USE_DER options should always be specified.
//

WINBERAPI BerElement * BERAPI ber_alloc_t( INT options );


//
// This skips over the current tag and returns the tag of the next
// element in the supplied BerElement. The lenght of this element is
// stored in the pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
// The difference between ber_skip_tag() and ber_peek_tag() is that the
// state pointer is advanced past the first tag+lenght and is pointed to
// the value part of the next element
//

WINBERAPI ULONG BERAPI ber_skip_tag( BerElement *pBerElement, ULONG *pLen );

//
// This returns the tag of the next element to be parsed in the
// supplied BerElement. The length of this element is stored in the
// pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//

WINBERAPI ULONG BERAPI ber_peek_tag( BerElement *pBerElement, ULONG *pLen);

//
// This returns the tag and length of the first element in a SET, SET OF
// or SEQUENCE OF data value.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned. It also returns an opaque cookie which has to be passed to
// subsequent invocations of ber_next_element().
//

WINBERAPI ULONG BERAPI ber_first_element( BerElement *pBerElement, ULONG *pLen, CHAR **ppOpaque );

//
// This positions the state at the start of the next element in the
// constructed type.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned.
//

WINBERAPI ULONG BERAPI ber_next_element( BerElement *pBerElement, ULONG *pLen, CHAR *opaque );

//
// This allocates a BerVal structure whose contents are taken from the
// supplied BerElement structure.
//
// The return values are 0 on success and -1 on error.
//

WINBERAPI INT BERAPI ber_flatten( BerElement *pBerElement, PBERVAL *pBerVal );


/*
The ber_printf() routine is used to encode a BER element in much the
same way that sprintf() works.  One important difference, though, is
that state information is kept in the ber argument so that multiple
calls can be made to ber_printf() to append to the end of the BER ele-
ment. ber MUST be a pointer to a BerElement returned by ber_alloc_t().
ber_printf() interprets and formats its arguments according to the for-
mat string fmt.  ber_printf() returns -1 if there is an error during
encoding and a non-negative number if successful.  As with sprintf(),
each character in fmt refers to an argument to ber_printf().
 
The format string can contain the following format characters:

't'     Tag.  The next argument is a ber_tag_t specifying the tag to
        override the next element to be written to the ber.  This works
        across calls.  The integer tag value SHOULD contain the tag
        class, constructed bit, and tag value.  For example, a tag of
        "[3]" for a constructed type is 0xA3U.  All implementations MUST
        support tags that fit in a single octet (i.e., where the tag
        value is less than 32) and they MAY support larger tags.

'b'     Boolean.  The next argument is an ber_int_t, containing either 0
        for FALSE or 0xff for TRUE.  A boolean element is output.  If
        this format character is not preceded by the 't' format modif-
        ier, the tag 0x01U is used for the element.

'e'     Enumerated.  The next argument is a ber_int_t, containing the
        enumerated value in the host's byte order.  An enumerated ele-
        ment is output.  If this format character is not preceded by the
        't' format modifier, the tag 0x0AU is used for the element.

'i'     Integer.  The next argument is a ber_int_t, containing the
        integer in the host's byte order.  An integer element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x02U is used for the element.

'n'     Null.  No argument is needed.  An ASN.1 NULL element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x05U is used for the element.
        
'o'     Octet string.  The next two arguments are a char *, followed by
        a ber_len_t with the length of the string.  The string MAY con-
        tain null bytes and are do not have to be zero-terminated.   An
        octet string element is output, in primitive form.  If this for-
        mat character is not preceded by the 't' format modifier, the
        tag 0x04U is used for the element.

's'     Octet string.  The next argument is a char * pointing to a
        zero-terminated string.  An octet string element in primitive
        form is output, which does not include the trailing '\0' (null)
        byte. If this format character is not preceded by the 't' format
        modifier, the tag 0x04U is used for the element.

'v'     Several octet strings.  The next argument is a char **, an array
        of char * pointers to zero-terminated strings.  The last element
        in the array MUST be a NULL pointer. The octet strings do not
        include the trailing '\0' (null) byte.  Note that a construct
        like '{v}' is used to get an actual SEQUENCE OF octet strings.
        The 't' format modifier cannot be used with this format charac-
        ter.

'V'     Several octet strings.  A NULL-terminated array of struct berval
        *'s is supplied.  Note that a construct like '{V}' is used to
        get an actual SEQUENCE OF octet strings. The 't' format modifier
        cannot be used with this format character.

'{'     Begin sequence.  No argument is needed.  If this format charac-
        ter is not preceded by the 't' format modifier, the tag 0x30U is
        used.

'}'     End sequence.  No argument is needed.  The 't' format modifier
        cannot be used with this format character.

'['     Begin set.  No argument is needed.  If this format character is
        not preceded by the 't' format modifier, the tag 0x31U is used.

']'     End set.  No argument is needed.  The 't' format modifier cannot
        be used with this format character.
*/

WINBERAPI INT BERAPI ber_printf( BerElement *pBerElement, PCHAR fmt, ... );

/*
The ber_scanf() routine is used to decode a BER element in much the same
way that sscanf() works.  One important difference, though, is that some
state information is kept with the ber argument so that multiple calls
can be made to ber_scanf() to sequentially read from the BER element.
The ber argument SHOULD be a pointer to a BerElement returned by
ber_init().  ber_scanf interprets the bytes according to the format
string fmt, and stores the results in its additional arguments.
ber_scanf() returns LBER_ERROR on error, and a different value on suc-
cess.

The format string contains conversion specifications which are used to
direct the interpretation of the BER element.  The format string can
contain the following characters:

'a'     Octet string.  A char ** argument MUST be supplied.  Memory is
        allocated, filled with the contents of the octet string, zero-
        terminated, and the pointer to the string is stored in the argu-
        ment.  The returned value SHOULD be freed using ldap_memfree.
        The tag of the element MUST indicate the primitive form
        (constructed strings are not supported) but is otherwise ignored
        and discarded during the decoding.  This format cannot be used
        with octet strings which could contain null bytes.        
        
'O'     Octet string.  A struct berval ** argument MUST be supplied,
        which upon return points to an allocated struct berval contain-
        ing the octet string and its length.  ber_bvfree() SHOULD be
        called to free the allocated memory.  The tag of the element
        MUST indicate the primitive form (constructed strings are not
        supported) but is otherwise ignored during the decoding.

'b'     Boolean.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be 0 for FALSE or nonzero for TRUE.
        The tag of the element MUST indicate the primitive form but is
        otherwise ignored during the decoding.

'e'     Enumerated.  A pointer to a ber_int_t MUST be supplied. The
        enumerated value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the value of the enumerated value cannot be stored in a
        ber_int_t.

'i'     Integer.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the integer cannot be stored in a ber_int_t.

'B'     Bitstring.  A char ** argument MUST be supplied which will point
        to the allocated bits, followed by a ber_len_t * argument, which
        will point to the length (in bits) of the bitstring returned.
        ldap_memfree SHOULD be called to free the bitstring.  The tag of
        the element MUST indicate the primitive form (constructed bit-
        strings are not supported) but is otherwise ignored during the
        decoding.

'n'     Null.  No argument is needed.  The element is verified to have a
        zero-length value and is skipped.  The tag is ignored.

'v'     Several octet strings.  A char *** argument MUST be supplied,
        which upon return points to an allocated NULL-terminated array
        of char *'s containing the octet strings.  NULL is stored if the
        sequence is empty.  ldap_memfree SHOULD be called to free each
        element of the array and the array itself.  The tag of the
        sequence and of the octet strings are ignored.

'V'     Several octet strings (which could contain null bytes).  A
        struct berval *** MUST be supplied, which upon return points to
        a allocated NULL-terminated array of struct berval *'s contain-
        ing the octet strings and their lengths.  NULL is stored if the
        sequence is empty. ber_bvecfree() can be called to free the
        allocated memory.  The tag of the sequence and of the octet
        strings are ignored.

'x'     Skip element.  The next element is skipped.  No argument is
        needed.

'{'     Begin sequence.  No argument is needed.  The initial sequence
        tag and length are skipped.

'}'     End sequence.  No argument is needed.

'['     Begin set.  No argument is needed.  The initial set tag and
        length are skipped.

']'     End set.  No argument is needed.

*/

WINBERAPI ULONG BERAPI ber_scanf( BerElement *pBerElement, PCHAR fmt, ... );


#ifdef __cplusplus
}
#endif


#endif  // _WINBER_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winmm.h ===
/*++ BUILD Version: 0002    Increment this if a change has global effects

Copyright (c) 1990-1999, Microsoft Corporation

Module Name:

    winmm.h

Abstract:

    This include file defines all the support for Multimedia applications.

--*/
#if _MSC_VER > 1000
#pragma once
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       winefs.h
//
//  Contents:   EFS Data and prototypes.
//
//----------------------------------------------------------------------------

#ifndef __WINEFS_H__
#define __WINEFS_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

//+---------------------------------------------------------------------------------/
//                                                                                  /
//                                                                                  /
//                          Data Structures                                         /
//                                                                                  /
//                                                                                  /
//----------------------------------------------------------------------------------/


#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif

//
//  Encoded Certificate
//


typedef struct _CERTIFICATE_BLOB {

    DWORD   dwCertEncodingType;

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;


//
//  Certificate Hash
//

typedef struct _EFS_HASH_BLOB {

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_HASH_BLOB, *PEFS_HASH_BLOB;


//
//  RPC blob
//

typedef struct _EFS_RPC_BLOB {

    DWORD   cbData;

#ifdef MIDL_PASS
    [size_is(cbData)]
#endif // MIDL_PASS
    PBYTE    pbData;

} EFS_RPC_BLOB, *PEFS_RPC_BLOB;

typedef struct _EFS_KEY_INFO {

    DWORD   dwVersion;
    ULONG   Entropy;
    ALG_ID  Algorithm;
    ULONG   KeyLength;
    
} EFS_KEY_INFO, *PEFS_KEY_INFO;


//
// Input to add a user to an encrypted file
//


typedef struct _ENCRYPTION_CERTIFICATE {
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_CERTIFICATE_BLOB pCertBlob;
} ENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

#define MAX_SID_SIZE 256


typedef struct _ENCRYPTION_CERTIFICATE_HASH {
    DWORD cbTotalLength;
    SID * pUserSid;
    PEFS_HASH_BLOB  pHash;

#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR lpDisplayInformation;

} ENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;







typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
    DWORD nCert_Hash;
#ifdef MIDL_PASS
    [size_is(nCert_Hash)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE_HASH * pUsers;
} ENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;



typedef struct _ENCRYPTION_CERTIFICATE_LIST {
    DWORD nUsers;
#ifdef MIDL_PASS
    [size_is(nUsers)]
#endif // MIDL_PASS
     PENCRYPTION_CERTIFICATE * pUsers;
} ENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;




//+---------------------------------------------------------------------------------/
//                                                                                  /
//                                                                                  /
//                               Prototypes                                         /
//                                                                                  /
//                                                                                  /
//----------------------------------------------------------------------------------/


WINADVAPI
DWORD
WINAPI
QueryUsersOnEncryptedFile(
     IN LPCWSTR lpFileName,
     OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );


WINADVAPI
DWORD
WINAPI
QueryRecoveryAgentsOnEncryptedFile(
     IN LPCWSTR lpFileName,
     OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );


WINADVAPI
DWORD
WINAPI
RemoveUsersFromEncryptedFile(
     IN LPCWSTR lpFileName,
     IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

WINADVAPI
DWORD
WINAPI
AddUsersToEncryptedFile(
     IN LPCWSTR lpFileName,
     IN PENCRYPTION_CERTIFICATE_LIST pUsers
    );

WINADVAPI
DWORD
WINAPI
SetUserFileEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );


WINADVAPI
VOID
WINAPI
FreeEncryptionCertificateHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

WINADVAPI
BOOL
WINAPI
EncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
    );


WINADVAPI
DWORD
WINAPI
DuplicateEncryptionInfoFile(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName, 
     IN DWORD dwCreationDistribution, 
     IN DWORD dwAttributes, 
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __WINEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winfax.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/



#ifndef _FAXAPI_
#define _FAXAPI_

#ifndef MIDL_PASS
#include <tapi.h>
#endif

#if !defined(_WINFAX_)
#define WINFAXAPI DECLSPEC_IMPORT
#else
#define WINFAXAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif


#pragma pack (push,EnterWinFax)
#pragma pack (1)





typedef enum
{
    FAXLOG_LEVEL_NONE            = 0,
    FAXLOG_LEVEL_MIN,
    FAXLOG_LEVEL_MED,
    FAXLOG_LEVEL_MAX
} FAX_ENUM_LOG_LEVELS;

typedef enum
{
    FAXLOG_CATEGORY_INIT        = 1,        // Initialization / shutdown
    FAXLOG_CATEGORY_OUTBOUND,               // Outbound messages
    FAXLOG_CATEGORY_INBOUND,                // Inbound messages
    FAXLOG_CATEGORY_UNKNOWN                 // Unknown category (all others)
} FAX_ENUM_LOG_CATEGORIES;

typedef struct _FAX_LOG_CATEGORYA
{
    LPCSTR              Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYA, *PFAX_LOG_CATEGORYA;
typedef struct _FAX_LOG_CATEGORYW
{
    LPCWSTR             Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYW, *PFAX_LOG_CATEGORYW;
#ifdef UNICODE
typedef FAX_LOG_CATEGORYW FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYW PFAX_LOG_CATEGORY;
#else
typedef FAX_LOG_CATEGORYA FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYA PFAX_LOG_CATEGORY;
#endif // UNICODE

typedef struct _FAX_TIME
{
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;

typedef struct _FAX_CONFIGURATIONA
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCSTR              ArchiveDirectory;               // archive directory for outgoing faxes
    LPCSTR              InboundProfile;                 // profile used for inbound routing (email)
} FAX_CONFIGURATIONA, *PFAX_CONFIGURATIONA;
typedef struct _FAX_CONFIGURATIONW
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCWSTR             ArchiveDirectory;               // archive directory for outgoing faxes
    LPCWSTR             InboundProfile;                 // profile used for inbound routing (email)
} FAX_CONFIGURATIONW, *PFAX_CONFIGURATIONW;
#ifdef UNICODE
typedef FAX_CONFIGURATIONW FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONW PFAX_CONFIGURATION;
#else
typedef FAX_CONFIGURATIONA FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONA PFAX_CONFIGURATION;
#endif // UNICODE


//
// FaxSetJob() command codes
//

typedef enum
{
    JC_UNKNOWN      = 0,
    JC_DELETE,
    JC_PAUSE,
    JC_RESUME
} FAX_ENUM_JOB_COMMANDS;

#define JC_RESTART                  JC_RESUME


//
// job type defines
//

typedef enum
{
    JT_UNKNOWN                  = 0x0001,       // Fax type is not determined yet
    JT_SEND                     = 0x0002,       // Outgoing fax message
    JT_RECEIVE                  = 0x0004,       // Incoming fax message
    JT_ROUTING                  = 0x0008,       // Incoming message - being routed
    JT_FAIL_RECEIVE             = 0x0010        // Fail receive job
} FAX_ENUM_JOB_TYPES;


//
// job status defines
//

#define JS_PENDING                  0x00000001
#define JS_INPROGRESS               0x00000002
#define JS_DELETING                 0x00000004
#define JS_FAILED                   0x00000008  
#define JS_PAUSED                   0x00000010  
#define JS_NOLINE                   0x00000020  
#define JS_RETRYING                 0x00000040
#define JS_RETRIES_EXCEEDED         0x00000080



typedef struct _FAX_DEVICE_STATUSA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              CallerId;                   // caller id string
    LPCSTR              Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCSTR              DeviceName;                 // device name
    LPCSTR              DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCSTR              PhoneNumber;                // sending phone number
    LPCSTR              RoutingString;              // routing information
    LPCSTR              SenderName;                 // sender name
    LPCSTR              RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCSTR              StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCSTR              Tsid;                       // transmitting station identifier
    LPCSTR              UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSA, *PFAX_DEVICE_STATUSA;
typedef struct _FAX_DEVICE_STATUSW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             CallerId;                   // caller id string
    LPCWSTR             Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCWSTR             PhoneNumber;                // sending phone number
    LPCWSTR             RoutingString;              // routing information
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCWSTR             StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCWSTR             Tsid;                       // transmitting station identifier
    LPCWSTR             UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSW, *PFAX_DEVICE_STATUSW;
#ifdef UNICODE
typedef FAX_DEVICE_STATUSW FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSW PFAX_DEVICE_STATUS;
#else
typedef FAX_DEVICE_STATUSA FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSA PFAX_DEVICE_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRYA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCSTR              UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr)
    LPCSTR              DocumentName;               // document name
} FAX_JOB_ENTRYA, *PFAX_JOB_ENTRYA;
typedef struct _FAX_JOB_ENTRYW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCWSTR             UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr)
    LPCWSTR             DocumentName;               // document name
} FAX_JOB_ENTRYW, *PFAX_JOB_ENTRYW;
#ifdef UNICODE
typedef FAX_JOB_ENTRYW FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYW PFAX_JOB_ENTRY;
#else
typedef FAX_JOB_ENTRYA FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYA PFAX_JOB_ENTRY;
#endif // UNICODE

//
// fax port state masks
//
// if you change these defines the be sure to
// change the resources in the fax service.
//

#define FPS_DIALING              0x20000001
#define FPS_SENDING              0x20000002
#define FPS_RECEIVING            0x20000004
#define FPS_COMPLETED            0x20000008
#define FPS_HANDLED              0x20000010
#define FPS_UNAVAILABLE          0x20000020
#define FPS_BUSY                 0x20000040
#define FPS_NO_ANSWER            0x20000080
#define FPS_BAD_ADDRESS          0x20000100
#define FPS_NO_DIAL_TONE         0x20000200
#define FPS_DISCONNECTED         0x20000400
#define FPS_FATAL_ERROR          0x20000800
#define FPS_NOT_FAX_CALL         0x20001000
#define FPS_CALL_DELAYED         0x20002000
#define FPS_CALL_BLACKLISTED     0x20004000
#define FPS_INITIALIZING         0x20008000
#define FPS_OFFLINE              0x20010000
#define FPS_RINGING              0x20020000

#define FPS_AVAILABLE            0x20100000
#define FPS_ABORTING             0x20200000
#define FPS_ROUTING              0x20400000
#define FPS_ANSWERED             0x20800000

//
// fax port capability mask
//

#define FPF_RECEIVE       0x00000001
#define FPF_SEND          0x00000002
#define FPF_VIRTUAL       0x00000004
#define FPF_AUTO_ANSWER   0x00000040
typedef struct _FAX_PORT_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCSTR              DeviceName;                 // Device name
    LPCSTR              Tsid;                       // Device Tsid
    LPCSTR              Csid;                       // Device Csid
} FAX_PORT_INFOA, *PFAX_PORT_INFOA;
typedef struct _FAX_PORT_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCWSTR             DeviceName;                 // Device name
    LPCWSTR             Tsid;                       // Device Tsid
    LPCWSTR             Csid;                       // Device Csid
} FAX_PORT_INFOW, *PFAX_PORT_INFOW;
#ifdef UNICODE
typedef FAX_PORT_INFOW FAX_PORT_INFO;
typedef PFAX_PORT_INFOW PFAX_PORT_INFO;
#else
typedef FAX_PORT_INFOA FAX_PORT_INFO;
typedef PFAX_PORT_INFOA PFAX_PORT_INFO;
#endif // UNICODE


typedef struct _FAX_ROUTING_METHODA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCSTR              DeviceName;                 // device name
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODA, *PFAX_ROUTING_METHODA;
typedef struct _FAX_ROUTING_METHODW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODW, *PFAX_ROUTING_METHODW;
#ifdef UNICODE
typedef FAX_ROUTING_METHODW FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODW PFAX_ROUTING_METHOD;
#else
typedef FAX_ROUTING_METHODA FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODA PFAX_ROUTING_METHOD;
#endif // UNICODE


typedef struct _FAX_GLOBAL_ROUTING_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOA, *PFAX_GLOBAL_ROUTING_INFOA;
typedef struct _FAX_GLOBAL_ROUTING_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOW, *PFAX_GLOBAL_ROUTING_INFOW;
#ifdef UNICODE
typedef FAX_GLOBAL_ROUTING_INFOW FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOW PFAX_GLOBAL_ROUTING_INFO;
#else
typedef FAX_GLOBAL_ROUTING_INFOA FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOA PFAX_GLOBAL_ROUTING_INFO;
#endif // UNICODE


typedef struct _FAX_COVERPAGE_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCSTR              CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCSTR              RecName;                    //
    LPCSTR              RecFaxNumber;               //
    LPCSTR              RecCompany;                 //
    LPCSTR              RecStreetAddress;           //
    LPCSTR              RecCity;                    //
    LPCSTR              RecState;                   //
    LPCSTR              RecZip;                     //
    LPCSTR              RecCountry;                 //
    LPCSTR              RecTitle;                   //
    LPCSTR              RecDepartment;              //
    LPCSTR              RecOfficeLocation;          //
    LPCSTR              RecHomePhone;               //
    LPCSTR              RecOfficePhone;             //
    //
    // Sender information
    //
    LPCSTR              SdrName;                    //
    LPCSTR              SdrFaxNumber;               //
    LPCSTR              SdrCompany;                 //
    LPCSTR              SdrAddress;                 //
    LPCSTR              SdrTitle;                   //
    LPCSTR              SdrDepartment;              //
    LPCSTR              SdrOfficeLocation;          //
    LPCSTR              SdrHomePhone;               //
    LPCSTR              SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCSTR              Note;                       //
    LPCSTR              Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOA, *PFAX_COVERPAGE_INFOA;
typedef struct _FAX_COVERPAGE_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW, *PFAX_COVERPAGE_INFOW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFOW FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOW PFAX_COVERPAGE_INFO;
#else
typedef FAX_COVERPAGE_INFOA FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOA PFAX_COVERPAGE_INFO;
#endif // UNICODE

typedef enum
{
    JSA_NOW                  = 0,   // Send now
    JSA_SPECIFIC_TIME,              // Send at specific time
    JSA_DISCOUNT_PERIOD             // Send at server configured discount period
} FAX_ENUM_JOB_SEND_ATTRIBUTES;

typedef enum
{
    DRT_NONE                = 0x0000,       // Do not send receipt
    DRT_EMAIL               = 0x0001,       // Send receipt by email
    DRT_MSGBOX              = 0x0002,       // Send receipt by a message box
} FAX_ENUM_DELIVERY_REPORT_TYPES;

typedef struct _FAX_JOB_PARAMA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr)
    LPCSTR              DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMA, *PFAX_JOB_PARAMA;
typedef struct _FAX_JOB_PARAMW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr)
    LPCWSTR             DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMW, *PFAX_JOB_PARAMW;
#ifdef UNICODE
typedef FAX_JOB_PARAMW FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMW PFAX_JOB_PARAM;
#else
typedef FAX_JOB_PARAMA FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMA PFAX_JOB_PARAM;
#endif // UNICODE

//
// Event Ids
//
// FEI_NEVENTS is the number of events
//

#define FEI_DIALING                 0x00000001
#define FEI_SENDING                 0x00000002
#define FEI_RECEIVING               0x00000003
#define FEI_COMPLETED               0x00000004
#define FEI_BUSY                    0x00000005
#define FEI_NO_ANSWER               0x00000006
#define FEI_BAD_ADDRESS             0x00000007
#define FEI_NO_DIAL_TONE            0x00000008
#define FEI_DISCONNECTED            0x00000009
#define FEI_FATAL_ERROR             0x0000000a
#define FEI_NOT_FAX_CALL            0x0000000b
#define FEI_CALL_DELAYED            0x0000000c
#define FEI_CALL_BLACKLISTED        0x0000000d
#define FEI_RINGING                 0x0000000e
#define FEI_ABORTING                0x0000000f
#define FEI_ROUTING                 0x00000010
#define FEI_MODEM_POWERED_ON        0x00000011
#define FEI_MODEM_POWERED_OFF       0x00000012
#define FEI_IDLE                    0x00000013
#define FEI_FAXSVC_ENDED            0x00000014
#define FEI_ANSWERED                0x00000015
#define FEI_JOB_QUEUED              0x00000016
#define FEI_DELETED                 0x00000017
#define FEI_INITIALIZING            0x00000018
#define FEI_LINE_UNAVAILABLE        0x00000019
#define FEI_HANDLED                 0x0000001a
#define FEI_FAXSVC_STARTED          0x0000001b

#define FEI_NEVENTS                 FEI_FAXSVC_STARTED

typedef struct _FAX_EVENTA
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTA, *PFAX_EVENTA;
typedef struct _FAX_EVENTW
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTW, *PFAX_EVENTW;
#ifdef UNICODE
typedef FAX_EVENTW FAX_EVENT;
typedef PFAX_EVENTW PFAX_EVENT;
#else
typedef FAX_EVENTA FAX_EVENT;
typedef PFAX_EVENTA PFAX_EVENT;
#endif // UNICODE


typedef struct _FAX_PRINT_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCSTR              DocName;                    // Document name that appears in the spooler
    LPCSTR              RecipientName;              // Recipient name
    LPCSTR              RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCSTR              SenderName;                 // Sender name
    LPCSTR              SenderCompany;              // Sender company (optional)
    LPCSTR              SenderDept;                 // Sender department
    LPCSTR              SenderBillingCode;          // Billing code
    LPCSTR              DrProfileName;              // Profile name for delivery report    <--| mutually exclusive
    LPCSTR              DrEmailAddress;             // E.Mail address for delivery report  <--|
    LPCSTR              OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOA, *PFAX_PRINT_INFOA;
typedef struct _FAX_PRINT_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCWSTR             DocName;                    // Document name that appears in the spooler
    LPCWSTR             RecipientName;              // Recipient name
    LPCWSTR             RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCWSTR             SenderName;                 // Sender name
    LPCWSTR             SenderCompany;              // Sender company (optional)
    LPCWSTR             SenderDept;                 // Sender department
    LPCWSTR             SenderBillingCode;          // Billing code
    LPCWSTR             DrProfileName;              // Profile name for delivery report    <--| mutually exclusive
    LPCWSTR             DrEmailAddress;             // E.Mail address for delivery report  <--|
    LPCWSTR             OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOW, *PFAX_PRINT_INFOW;
#ifdef UNICODE
typedef FAX_PRINT_INFOW FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOW PFAX_PRINT_INFO;
#else
typedef FAX_PRINT_INFOA FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOA PFAX_PRINT_INFO;
#endif // UNICODE


typedef struct _FAX_CONTEXT_INFOA
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    CHAR                ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOA, *PFAX_CONTEXT_INFOA;
typedef struct _FAX_CONTEXT_INFOW
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    WCHAR               ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOW, *PFAX_CONTEXT_INFOW;
#ifdef UNICODE
typedef FAX_CONTEXT_INFOW FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOW PFAX_CONTEXT_INFO;
#else
typedef FAX_CONTEXT_INFOA FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOA PFAX_CONTEXT_INFO;
#endif // UNICODE


//
// prototypes
//

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define FaxConnectFaxServer  FaxConnectFaxServerW
#else
#define FaxConnectFaxServer  FaxConnectFaxServerA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERA)(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERW)(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERW
#else
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXCLOSE)(
    IN HANDLE FaxHandle
    );

typedef enum
{
    PORT_OPEN_QUERY     = 1,
    PORT_OPEN_MODIFY
} FAX_ENUM_PORT_OPEN_TYPE;

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

typedef BOOL
(WINAPI *PFAXOPENPORT)(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define FaxCompleteJobParams  FaxCompleteJobParamsW
#else
#define FaxCompleteJobParams  FaxCompleteJobParamsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSA)(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSW)(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSW
#else
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSA
#endif // !UNICODE



WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define FaxSendDocument  FaxSendDocumentW
#else
#define FaxSendDocument  FaxSendDocumentA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTA)(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTW)(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTW
#else
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTA
#endif // !UNICODE

typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKA)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMA JobParams,
    IN OUT PFAX_COVERPAGE_INFOA CoverpageInfo OPTIONAL
    );
typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMW JobParams,
    IN OUT PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
    );
#ifdef UNICODE
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKW
#else
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKA
#endif // !UNICODE
    
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    );
#ifdef UNICODE
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastW
#else
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumJobsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumJobsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define FaxEnumJobs  FaxEnumJobsW
#else
#define FaxEnumJobs  FaxEnumJobsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMJOBSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMJOBSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define PFAXENUMJOBS  PFAXENUMJOBSW
#else
#define PFAXENUMJOBS  PFAXENUMJOBSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetJobA(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxGetJobW(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxGetJob  FaxGetJobW
#else
#define FaxGetJob  FaxGetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETJOBA)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXGETJOBW)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXGETJOB  PFAXGETJOBW
#else
#define PFAXGETJOB  PFAXGETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxSetJob  FaxSetJobW
#else
#define FaxSetJob  FaxSetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETJOBA)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXSETJOBW)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXSETJOB  PFAXSETJOBW
#else
#define PFAXSETJOB  PFAXSETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

typedef BOOL
(WINAPI *PFAXGETPAGEDATA)(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define FaxGetDeviceStatus  FaxGetDeviceStatusW
#else
#define FaxGetDeviceStatus  FaxGetDeviceStatusA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSW
#else
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

typedef BOOL
(WINAPI *PFAXABORT)(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxGetConfiguration  FaxGetConfigurationW
#else
#define FaxGetConfiguration  FaxGetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONW
#else
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxSetConfiguration  FaxSetConfigurationW
#else
#define FaxSetConfiguration  FaxSetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONW
#else
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesW
#else
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESW
#else
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesW
#else
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESW
#else
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define FaxEnumPorts  FaxEnumPortsW
#else
#define FaxEnumPorts  FaxEnumPortsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMPORTSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMPORTSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define PFAXENUMPORTS  PFAXENUMPORTSW
#else
#define PFAXENUMPORTS  PFAXENUMPORTSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxGetPort  FaxGetPortW
#else
#define FaxGetPort  FaxGetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETPORTA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXGETPORTW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXGETPORT  PFAXGETPORTW
#else
#define PFAXGETPORT  PFAXGETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxSetPort  FaxSetPortW
#else
#define FaxSetPort  FaxSetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETPORTA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXSETPORTW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXSETPORT  PFAXSETPORTW
#else
#define PFAXSETPORT  PFAXSETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsW
#else
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSW
#else
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodW
#else
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODW
#else
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoW
#else
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOW
#else
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoW
#else
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOW
#else
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxGetRoutingInfo  FaxGetRoutingInfoW
#else
#define FaxGetRoutingInfo  FaxGetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXGETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOW
#else
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxSetRoutingInfo  FaxSetRoutingInfoW
#else
#define FaxSetRoutingInfo  FaxSetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXSETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOW
#else
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

typedef BOOL
(WINAPI *PFAXINITIALIZEEVENTQUEUE)(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    );

typedef VOID
(WINAPI *PFAXFREEBUFFER)(
    LPVOID Buffer
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define FaxStartPrintJob  FaxStartPrintJobW
#else
#define FaxStartPrintJob  FaxStartPrintJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBA)(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBW)(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBW
#else
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define FaxPrintCoverPage  FaxPrintCoverPageW
#else
#define FaxPrintCoverPage  FaxPrintCoverPageA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEA)(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEW)(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEW
#else
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define FaxRegisterServiceProvider  FaxRegisterServiceProviderW

typedef BOOL
(WINAPI *PFAXREGISTERSERVICEPROVIDERW)(    
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );
    
#define PFAXREGISTERSERVICEPROVIDER PFAXREGISTERSERVICEPROVIDERW

typedef BOOL
(CALLBACK *PFAX_ROUTING_INSTALLATION_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );

#define PFAX_ROUTING_INSTALLATION_CALLBACK PFAX_ROUTING_INSTALLATION_CALLBACKW


WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define FaxRegisterRoutingExtension FaxRegisterRoutingExtensionW


typedef BOOL
(WINAPI *PFAXREGISTERROUTINGEXTENSIONW)(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define PFAXREGISTERROUTINGEXTENSION PFAXREGISTERROUTINGEXTENSIONW




WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

typedef BOOL
(WINAPI *PFAXACCESSCHECK)(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

//
// Win2K Fax compatibility - Specific Fax Access Rights
//
#define FAX_JOB_SUBMIT                  0x0003
#define FAX_JOB_QUERY                   0x0008
#define FAX_CONFIG_QUERY                0x0020
#define FAX_CONFIG_SET                  0x0060
#define FAX_PORT_QUERY                  0x0020
#define FAX_PORT_SET                    0x0060
#define FAX_JOB_MANAGE                  0x0018


//
// Win2K Fax compatibility - Generic Fax Access Rights
//
#define FAX_READ                (FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_PORT_QUERY)

#define FAX_WRITE               (FAX_JOB_SUBMIT)

#define FAX_ALL_ACCESS          (FAX_JOB_SUBMIT              |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_CONFIG_SET              |\
                                 FAX_PORT_QUERY              |\
                                 FAX_PORT_SET                |\
                                 FAX_JOB_MANAGE)



#pragma pack (pop,EnterWinFax)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version Win32 / Windows NT                                    *
*                                                                             *
*               Copyright (c) 1992-1999, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#if (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else   /* __cplusplus */
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif  /* __cplusplus */
#endif  /* SNDMSG */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) (HMODULE)(hInstance)

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)GlobalHandle(lp))

#define     GlobalLockPtr(lp)                \
                ((BOOL)GlobalLock(GlobalPtrHandle(lp)))
#define     GlobalUnlockPtr(lp)      \
                GlobalUnlock(GlobalPtrHandle(lp))

#ifndef _MAC
#define     GlobalAllocPtr(flags, cb)        \
                (GlobalLock(GlobalAlloc((flags), (cb))))
#else
#define     GlobalAllocPtr(flags, cb)        \
                (GlobalLock(GlobalAlloc((flags) | GMEM_PMODELOCKSTRATEGY, (cb))))
#endif
#define     GlobalReAllocPtr(lp, cbNew, flags)       \
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)                \
                (GlobalUnlockPtr(lp), (BOOL)(ULONG_PTR)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)      DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)       ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)     DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)     ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)      DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#ifndef _MAC
#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#else
#define     AfxCopyRgn(hrgnDst, hrgnSrc)            CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#endif
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#ifndef _MAC
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)
#else
#define     AfxUnionRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     AfxXorRgn(hrgnResult, hrgnA, hrgnB)     CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)
#endif

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)            DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)      ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#ifndef _MAC
#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))
#else
#define     AfxInsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))
#endif

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HMODULE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)            GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SNDMSG(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)       \
              ((WNDPROC)SetWindowLongPtr((hwnd), GWLP_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)        IsIconic(hwnd)
#define     IsMaximized(hwnd)        IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SNDMSG)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SNDMSG)
#if (WINVER >= 0x030a)

#ifdef UNIX
#define     MapWindowRect MwMapWindowRect
LONG MwMapWindowRect(HWND, HWND, RECT *);
#else

#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)
#endif /* !UNIX */
#endif
#define     IsLButtonDown()  (GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()  (GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()  (GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
             ((DLGPROC)SetWindowLongPtr(hwndDlg, DWLP_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result) (( \
        (msg) == WM_CTLCOLORMSGBOX      || \
        (msg) == WM_CTLCOLOREDIT        || \
        (msg) == WM_CTLCOLORLISTBOX     || \
        (msg) == WM_CTLCOLORBTN         || \
        (msg) == WM_CTLCOLORDLG         || \
        (msg) == WM_CTLCOLORSCROLLBAR   || \
        (msg) == WM_CTLCOLORSTATIC      || \
        (msg) == WM_COMPAREITEM         || \
        (msg) == WM_VKEYTOITEM          || \
        (msg) == WM_CHARTOITEM          || \
        (msg) == WM_QUERYDRAGICON       || \
        (msg) == WM_INITDIALOG             \
    ) ? (BOOL)(result) : (SetWindowLongPtr((hwnd), DWLP_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio) */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName) */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0L, (LPARAM)(LPCTSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd) */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0L, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd) */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0L)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0L, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange) */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange) */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd) */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0L, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue) */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)(short)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCTSTR lpszDeviceName) */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0L, (LPARAM)(LPCTSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd) */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0L, 0L)

/* void Cls_OnPower(HWND hwnd, int code) */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(int)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd) */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0L)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0L, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding) */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode) */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* This message is in Windows 3.1 only */
/* void Cls_OnSystemError(HWND hwnd, int errCode) */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) 0L
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) 0L

/* BOOL Cls_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCREATESTRUCT)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0L, (LPARAM)(LPCREATESTRUCT)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (LPCREATESTRUCT)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0L, (LPARAM)(LPCREATESTRUCT)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd) */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0L, 0L)

/* void Cls_OnNCDestroy(HWND hwnd) */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0L, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status) */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (UINT)(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), (LPARAM)(UINT)(status))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw) */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable) */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCTSTR lpszText) */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0L, (LPARAM)(LPCTSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPTSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPTSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPTSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd) */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0L, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, LPWINDOWPOS lpwpos) */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (LPWINDOWPOS)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0L, (LPARAM)(LPWINDOWPOS)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const LPWINDOWPOS lpwpos) */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const LPWINDOWPOS)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0L, (LPARAM)(const LPWINDOWPOS)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y) */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0L, MAKELPARAM((x), (y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy) */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((cx), (cy)))

/* void Cls_OnClose(HWND hwnd) */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0L, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd) */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0L)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0L, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpMinMaxInfo) */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPMINMAXINFO)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0L, (LPARAM)(LPMINMAXINFO)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd) */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0L, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc) */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc) */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn) */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS * lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS *)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS *)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y) */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0L, MAKELPARAM((x), (y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd) */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0L, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop) */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(HDROP)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized) */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)LOWORD(wParam), (HWND)(lParam), (BOOL)HIWORD(wParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, MAKEWPARAM((state), (fMinimized)), (LPARAM)(HWND)(hwndActDeact))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, DWORD dwThreadId) */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (DWORD)(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, dwThreadId, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), (LPARAM)(dwThreadId))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized) */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), 0L, 0L)
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), 0L)

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus) */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((cRepeat), (flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((cRepeat), (flags)))

/* void Cls_OnChar(HWND hwnd, TCHAR ch, int cRepeat) */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(TCHAR)(ch), MAKELPARAM((cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, TCHAR ch, int cRepeat) */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(TCHAR)(ch), MAKELPARAM((cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((cRepeat), (flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)(short)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((cRepeat), (flags)))

/* void Cls_OnSysChar(HWND hwnd, TCHAR ch, int cRepeat) */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(TCHAR)(ch), MAKELPARAM((cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, TCHAR ch, int cRepeat) */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (TCHAR)(wParam), (int)(short)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(TCHAR)(ch), MAKELPARAM((cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags) */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags) */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags) */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags) */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMouseWheel(HWND hwnd, int xPos, int yPos, int zDelta, UINT fwKeys) */
#define HANDLE_WM_MOUSEWHEEL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (int)(short)HIWORD(wParam), (UINT)(short)LOWORD(wParam)))
#define FORWARD_WM_MOUSEWHEEL(hwnd, xPos, yPos, zDelta, fwKeys, fn) \
    (void)(fn)((hwnd), WM_MOUSEWHEEL, MAKEWPARAM((fwKeys),(zDelta)), MAKELPARAM((x),(y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest) */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg) */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd) */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0L, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id) */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu) */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu) */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags) */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn)                  \
    ((fn)((hwnd), (HMENU)(lParam),  \
    (HIWORD(wParam) & MF_POPUP) ? 0L : (int)(LOWORD(wParam)),           \
    (HIWORD(wParam) & MF_POPUP) ? GetSubMenu((HMENU)lParam, LOWORD(wParam)) : 0L, \
    (UINT)(((short)HIWORD(wParam) == -1) ? 0xFFFFFFFF : HIWORD(wParam))), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, MAKEWPARAM((item), (flags)), (LPARAM)(HMENU)((hmenu) ? (hmenu) : (hmenuPopup)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu) */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(LOWORD(wParam)), (UINT)HIWORD(wParam), (HMENU)(lParam))
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, MAKEWPARAM(flags, (WORD)(ch)), (LPARAM)(HMENU)(hmenu))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos) */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(lParam), (UINT)(LOWORD(wParam)), (int)(short)HIWORD(wParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, MAKEWPARAM((UINT)(int)(code),(UINT)(int)(pos)), (LPARAM)(HWND)(hwndCtl))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos) */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(lParam), (UINT)(LOWORD(wParam)),  (int)(short)HIWORD(wParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, MAKEWPARAM((UINT)(int)(code), (UINT)(int)(pos)), (LPARAM)(HWND)(hwndCtl))

/* void Cls_OnCut(HWND hwnd) */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0L, 0L)

/* void Cls_OnCopy(HWND hwnd) */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0L, 0L)

/* void Cls_OnPaste(HWND hwnd) */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0L, 0L)

/* void Cls_OnClear(HWND hwnd) */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0L, 0L)

/* void Cls_OnUndo(HWND hwnd) */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0L, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt) */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT_PTR)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd) */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0L, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd) */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0L, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd) */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0L, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const LPPAINTSTRUCT lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const LPPAINTSTRUCT)GlobalLock((HGLOBAL)(lParam))), GlobalUnlock((HGLOBAL)(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPPAINTSTRUCT)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const LPRECT lprc) */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const LPRECT)GlobalLock((HGLOBAL)(lParam))), GlobalUnlock((HGLOBAL)(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPRECT)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos) */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos) */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPTSTR rgchName) */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPTSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext) */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), (LPARAM)(HWND)(hwndNext))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg) */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y) */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const LPMDICREATESTRUCT lpmcs) */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (LPMDICREATESTRUCT)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0L, (LPARAM)(LPMDICREATESTRUCT)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy) */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate) */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(lParam == (LPARAM)hwnd), (HWND)(lParam), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(hwndDeactivate), (LPARAM)(hwndActivate))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore) */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev) */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)lParam)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT_PTR)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), (LPARAM)(fPrev))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize) */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd) */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd) */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd) */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0L, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd) */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT_PTR)(fn)((hwnd), WM_MDIGETACTIVE, 0L, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow) */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(fn)((hwnd), (BOOL)(wParam), (HMENU)(wParam), (HMENU)(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT_PTR)(fn)((hwnd), WM_MDISETMENU, (WPARAM)((fRefresh) ? (hmenuFrame) : 0), (LPARAM)(hmenuWindow))

/* void Cls_OnChildActivate(HWND hwnd) */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0L, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam)
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT_PTR)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), (LPARAM)(fNext))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild) */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)LOWORD(wParam), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, MAKEWPARAM(msg, idChild), (LPARAM)(hwndChild))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource) */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), (LPARAM)(HWND)(hwndSource))

/* UINT Cls_OnGetDlgCode(HWND hwnd, LPMSG lpmsg) */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (LPMSG)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (lpmsg ? lpmsg->wParam : 0), (LPARAM)(LPMSG)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type) */
#define HANDLE_WM_CTLCOLORMSGBOX(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_MSGBOX)
#define FORWARD_WM_CTLCOLORMSGBOX(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORMSGBOX, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLOREDIT(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_EDIT)
#define FORWARD_WM_CTLCOLOREDIT(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLOREDIT, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLORLISTBOX(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_LISTBOX)
#define FORWARD_WM_CTLCOLORLISTBOX(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORLISTBOX, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLORBTN(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_BTN)
#define FORWARD_WM_CTLCOLORBTN(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORBTN, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLORDLG(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_DLG)
#define FORWARD_WM_CTLCOLORDLG(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORDLG, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLORSCROLLBAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_SCROLLBAR)
#define FORWARD_WM_CTLCOLORSCROLLBAR(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORSCROLLBAR, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

#define HANDLE_WM_CTLCOLORSTATIC(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_STATIC)
#define FORWARD_WM_CTLCOLORSTATIC(hwnd, hdc, hwndChild, fn) \
    (HBRUSH)(UINT_PTR)(fn)((hwnd), WM_CTLCOLORSTATIC, (WPARAM)(HDC)(hdc), (LPARAM)(HWND)(hwndChild))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw) */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), (LPARAM)(BOOL)(fRedraw))

/* HFONT Cls_OnGetFont(HWND hwnd) */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(UINT_PTR)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT_PTR)(fn)((hwnd), WM_GETFONT, 0L, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem) */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT *)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, (WPARAM)(((const DRAWITEMSTRUCT *)lpDrawItem)->CtlID), (LPARAM)(const DRAWITEMSTRUCT *)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem) */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT *)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, (WPARAM)(((MEASUREITEMSTRUCT *)lpMeasureItem)->CtlID), (LPARAM)(MEASUREITEMSTRUCT *)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT *)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, (WPARAM)(((const DELETEITEMSTRUCT *)(lpDeleteItem))->CtlID), (LPARAM)(const DELETEITEMSTRUCT *)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT * lpCompareItem) */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT *)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, (WPARAM)(((const COMPAREITEMSTRUCT *)(lpCompareItem))->CtlID), (LPARAM)(const COMPAREITEMSTRUCT *)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret) */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)LOWORD(wParam), (HWND)(lParam), (int)(short)HIWORD(wParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, MAKEWPARAM((vk), (iCaret)), (LPARAM)(hwndListBox))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret) */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)LOWORD(wParam), (HWND)(lParam), (int)(short)HIWORD(wParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, MAKEWPARAM((UINT)(ch), (UINT)(iCaret)), (LPARAM)(hwndListBox))

/* void Cls_OnQueueSync(HWND hwnd) */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0L, 0L)
#if (WINVER >= 0x030a)
/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags) */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (UINT)LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))
#endif

/* void Cls_OnDisplayChange(HWND hwnd, UINT bitsPerPixel, UINT cxScreen, UINT cyScreen) */
#define HANDLE_WM_DISPLAYCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(wParam)), 0L)
#define FORWARD_WM_DISPLAYCHANGE(hwnd, bitsPerPixel, cxScreen, cyScreen, fn) \
    (void)(fn)((hwnd), WM_DISPLAYCHANGE, (WPARAM)(UINT)(bitsPerPixel), (LPARAM)MAKELPARAM((UINT)(cxScreen), (UINT)(cyScreen)))

/* BOOL Cls_OnDeviceChange(HWND hwnd, UINT uEvent, DWORD dwEventData) */
#define HANDLE_WM_DEVICECHANGE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (UINT)(wParam), (DWORD)(wParam))
#define FORWARD_WM_DEVICECHANGE(hwnd, uEvent, dwEventData, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_DEVICECHANGE, (WPARAM)(UINT)(uEvent), (LPARAM)(DWORD)(dwEventData))

/* void Cls_OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_CONTEXTMENU(hwnd, hwndContext, xPos, yPos, fn) \
    (void)(fn)((hwnd), WM_CONTEXTMENU, (WPARAM)(HWND)(hwndContext), MAKELPARAM((UINT)(xPos), (UINT)(yPos)))

#define HANDLE_WM_COPYDATA(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (PCOPYDATASTRUCT)lParam), 0L)
#define FORWARD_WM_COPYDATA(hwnd, hwndFrom, pcds, fn) \
    (BOOL)(UINT)(DWORD)(fn)((hwnd), WM_COPYDATA, (WPARAM)(hwndFrom), (LPARAM)(pcds))

/* void Cls_OnHotKey(HWND hwnd, int idHotKey, UINT fuModifiers, UINT vk) */
#define HANDLE_WM_HOTKEY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_HOTKEY(hwnd, idHotKey, fuModifiers, vk, fn) \
    (void)(fn)((hwnd), WM_HOTKEY, (WPARAM)(idHotKey), MAKELPARAM((fuModifiers), (vk)))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT_PTR)SNDMSG((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT_PTR)SNDMSG((hwndCtl), STM_GETICON, 0L, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SNDMSG((hwndCtl), BM_GETCHECK, 0L, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SNDMSG((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SNDMSG((hwndCtl), BM_GETSTATE, 0L, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SNDMSG((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SNDMSG((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SNDMSG((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SNDMSG((hwndCtl), EM_GETLINECOUNT, 0L, 0L))
#ifndef _MAC
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int *)(lpch)) = (cchMax)), ((int)(DWORD)SNDMSG((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPTSTR)(lpch))))
#else
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((WORD *)(lpch)) = (cchMax)), ((int)(DWORD)SNDMSG((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPTSTR)(lpch))))
#endif

#define Edit_GetRect(hwndCtl, lprc)             ((void)SNDMSG((hwndCtl), EM_GETRECT, 0L, (LPARAM)(RECT *)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SNDMSG((hwndCtl), EM_SETRECT, 0L, (LPARAM)(const RECT *)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SNDMSG((hwndCtl), EM_SETRECTNP, 0L, (LPARAM)(const RECT *)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SNDMSG((hwndCtl), EM_GETSEL, 0L, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SNDMSG((hwndCtl), EM_SETSEL, (ichStart), (ichEnd)))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SNDMSG((hwndCtl), EM_REPLACESEL, 0L, (LPARAM)(LPCTSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_GETMODIFY, 0L, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SNDMSG((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_ScrollCaret(hwndCtl)               ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_SCROLLCARET, 0, 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SNDMSG((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SNDMSG((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SNDMSG((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SNDMSG((hwndCtl), EM_LINESCROLL, (WPARAM)(dh), (LPARAM)(dv)))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_CANUNDO, 0L, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_UNDO, 0L, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SNDMSG((hwndCtl), EM_EMPTYUNDOBUFFER, 0L, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SNDMSG((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SNDMSG((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int *)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT_PTR)SNDMSG((hwndCtl), EM_GETHANDLE, 0L, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SNDMSG((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT_PTR)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SNDMSG((hwndCtl), EM_GETFIRSTVISIBLELINE, 0L, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SNDMSG((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((TCHAR)(DWORD)SNDMSG((hwndCtl), EM_GETPASSWORDCHAR, 0L, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SNDMSG((hwndCtl), EM_SETWORDBREAKPROC, 0L, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SNDMSG((hwndCtl), EM_GETWORDBREAKPROC, 0L, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0L, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SNDMSG((hwndCtl), LB_RESETCONTENT, 0L, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SNDMSG((hwndCtl), LB_ADDSTRING, 0L, (LPARAM)(LPCTSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SNDMSG((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SNDMSG((hwndCtl), LB_ADDSTRING, 0L, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SNDMSG((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SNDMSG((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(ULONG_PTR)SNDMSG((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SNDMSG((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#if (WINVER >= 0x030a)
#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SNDMSG((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SNDMSG((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SNDMSG((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), (LPARAM)(index)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SNDMSG((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCURSEL, 0L, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SNDMSG((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SNDMSG((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SNDMSG((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SNDMSG((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SNDMSG((hwndCtl), LB_GETSELCOUNT, 0L, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTOPINDEX, 0L, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int *)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SNDMSG((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SNDMSG((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SNDMSG((hwndCtl), LB_GETHORIZONTALEXTENT, 0L, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SNDMSG((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SNDMSG((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int *)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SNDMSG((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT *)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SNDMSG((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCARETINDEX, 0L, 0L))

#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SNDMSG((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SNDMSG((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SNDMSG((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SNDMSG((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCTSTR)(lpszFileSpec)))

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SNDMSG((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SNDMSG((hwndCtl), CB_GETEDITSEL, 0L, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETEDITSEL, 0L, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCOUNT, 0L, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SNDMSG((hwndCtl), CB_RESETCONTENT, 0L, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SNDMSG((hwndCtl), CB_ADDSTRING, 0L, (LPARAM)(LPCTSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SNDMSG((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SNDMSG((hwndCtl), CB_ADDSTRING, 0L, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SNDMSG((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SNDMSG((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SNDMSG((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SNDMSG((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(ULONG_PTR)SNDMSG((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SNDMSG((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SNDMSG((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SNDMSG((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCURSEL, 0L, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SNDMSG((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SNDMSG((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SNDMSG((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SNDMSG((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCTSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SNDMSG((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SNDMSG((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SNDMSG((hwndCtl), CB_GETDROPPEDSTATE, 0L, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SNDMSG((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0L, (LPARAM)(RECT *)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SNDMSG((hwndCtl), CB_GETITEMHEIGHT, 0L, 0L))
#define ComboBox_SetItemHeight(hwndCtl, index, cyItem) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), (LPARAM)(int)cyItem))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SNDMSG((hwndCtl), CB_GETEXTENDEDUI, 0L, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SNDMSG((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

/****** Alternate porting layer macros ****************************************/

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#define GET_WM_ACTIVATE_STATE(wp, lp)           LOWORD(wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(wp)
#define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)MAKELONG((s), (fmin)), (LPARAM)(hwnd)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          (TCHAR)LOWORD(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(wp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)MAKELONG((pos), (ch)), (LPARAM)(hwnd)

#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)MAKELONG(id, cmd), (LPARAM)(hwnd)

#define WM_CTLCOLOR                             0x0019

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       (WORD)(msg - WM_CTLCOLORMSGBOX)
#define GET_WM_CTLCOLOR_MSG(type)               (WORD)(WM_CTLCOLORMSGBOX+(type))
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)(hwnd)


#define GET_WM_MENUSELECT_CMD(wp, lp)               LOWORD(wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)(int)(short)HIWORD(wp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)MAKELONG(cmd, f), (LPARAM)(hmenu)

/* Note: the following are for interpreting MDIclient to MDI child messages. */
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (lp == (LPARAM)hwnd)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)(wp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)(lp)
/* Note: the following is for sending to the MDI client window. */
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) (WPARAM)hmenuF, (LPARAM)hmenuW

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (TCHAR)LOWORD(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(wp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)MAKELONG(ch, f), (LPARAM)(hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             LOWORD(wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(wp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (int)(short)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (int)(short)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)MAKELONG(id, msg), (LPARAM)(hwnd)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)MAKELONG(0, msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (int)(short)LOWORD(wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(wp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)MAKELONG(item, code), (LPARAM)(hwnd)

#define GET_EM_SETSEL_START(wp, lp)                 (INT)(wp)
#define GET_EM_SETSEL_END(wp, lp)                   (lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)(iStart), (LPARAM)(iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)horz, (LPARAM)vert

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LPARAM)(hwnd)

/****** C runtime porting macros ****************************************/

#define _ncalloc    calloc
#define _nexpand    _expand
#define _ffree      free
#define _fmalloc    malloc
#define _fmemccpy   _memccpy
#define _fmemchr    memchr
#define _fmemcmp    memcmp
#define _fmemcpy    memcpy
#define _fmemicmp   _memicmp
#define _fmemmove   memmove
#define _fmemset    memset
#define _fmsize     _msize
#define _frealloc   realloc
#define _fstrcat    strcat
#define _fstrchr    strchr
#define _fstrcmp    strcmp
#define _fstrcpy    strcpy
#define _fstrcspn   strcspn
#define _fstrdup    _strdup
#define _fstricmp   _stricmp
#define _fstrlen    strlen
#define _fstrlwr    _strlwr
#define _fstrncat   strncat
#define _fstrncmp   strncmp
#define _fstrncpy   strncpy
#define _fstrnicmp  _strnicmp
#define _fstrnset   _strnset
#define _fstrpbrk   strpbrk
#define _fstrrchr   strrchr
#define _fstrrev    _strrev
#define _fstrset    _strset
#define _fstrspn    strspn
#define _fstrstr    strstr
#define _fstrtok    strtok
#define _fstrupr    _strupr
#define _nfree      free
#define _nmalloc    malloc
#define _nmsize     _msize
#define _nrealloc   realloc
#define _nstrdup    _strdup
#define hmemcpy     MoveMemory

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32    DECLARE_HANDLE
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif       /* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wnapidec.inc ===
' ------------------------------------------------------------------------
'     WNAPIDEC.INC -- Windows 3.0 API Declarations for 32-bit FastTest
'
'              Copyright (C) 1991-1992 Microsoft Corporation
'
'  The following are provided for sample purposes only.  You should only
'  copy the ones you use into your code in order to save code space and
'  parse time.
'
'  You have a royalty-free right to use, modify, reproduce and distribute
'  this file (and/or any modified version) in any way you find useful,
'  provided that you agree Microsoft has no warranty, obligation or
'  liability for its contents.  Refer to the Microsoft Windows Programmer's
'  Reference for further information.
'
' ------------------------------------------------------------------------
'$define _WNAPIDEC          ' Define this so other includes don't redefine
                            ' stuff defined in this include file

'$ifndef _WINUSER

' Definitions stolen from WINUSER.INC
'-----------------------------------------------------------------------------
Type RECT
    wleft As Integer
    top As Integer
    wright As Integer
    bottom As Integer
End Type

Type POINT
    x As Integer
    y As Integer
End Type

Declare Function FindWindow          Lib "User32" ALIAS "FindWindowA" (lpClassName As Any, lpWindowName As Any) As Integer
Declare Function GetActiveWindow     Lib "User32" ALIAS "GetActiveWindow" () As Integer
Declare Sub      GetClientRect       Lib "User32" ALIAS "GetClientRect" (hWnd%, lpRect As RECT)
Declare Function GetDesktopWindow    Lib "User32" ALIAS "GetDesktopWindow" () As Integer
Declare Function GetFocus            Lib "User32" ALIAS "GetFocus" () As Integer
Declare Function GetForegroundWindow Lib "User32" ALIAS "GetForegroundWindow" () As Integer
Declare Function GetSystemMetrics    Lib "User32" ALIAS "GetSystemMetrics" (nIndex%) As Integer
Declare Function GetWindowLong       Lib "User32" ALIAS "GetWindowLongA" (hWnd%,  nIndex%) As Long
Declare Sub      GetWindowRect       Lib "User32" ALIAS "GetWindowRect" (hWnd%, lpRect As RECT)
Declare Function GetWindowText       Lib "User32" ALIAS "GetWindowTextA" (hWnd%,  lpString$,  nMaxCount%) As Integer
Declare Function IsZoomed            Lib "User32" ALIAS "IsZoomed" (hWnd%) As Integer
Declare Function MessageBox          Lib "User32" ALIAS "MessageBoxA" (hWndParent%,  lpText$,  lpCaption$,  wType%) As Integer
Declare Function SendMessage         Lib "User32" ALIAS "SendMessageA" (hWnd%,  wMsg%,  wParam%, lParam As Any) As Long
Declare Function SetActiveWindow     Lib "User32" ALIAS "SetActiveWindow" (hWnd%) As Integer
Declare Function SetFocus            Lib "User32" ALIAS "SetFocus" (hWnd%) As Integer
Declare Function SetForegroundWindow Lib "User32" ALIAS "SetForegroundWindow" (hWnd%) As Integer
Declare Function SetWindowPos        Lib "User32" ALIAS "SetWindowPos" (h%, ha%, x%, y%, cx%, cy%, f%) As Integer
Declare Function ShowWindow          Lib "User32" ALIAS "ShowWindow" (hWnd%,  nCmdShow%) As Integer


'  ShowWindow() Commands
Const SW_HIDE = 0
Const SW_SHOWNORMAL = 1
Const SW_NORMAL = 1
Const SW_SHOWMINIMIZED = 2
Const SW_SHOWMAXIMIZED = 3
Const SW_MAXIMIZE = 3
Const SW_SHOWNOACTIVATE = 4
Const SW_SHOW = 5
Const SW_MINIMIZE = 6
Const SW_SHOWMINNOACTIVE = 7
Const SW_SHOWNA = 8
Const SW_RESTORE = 9

'  Window Styles
Const WS_MINIMIZE = &H20000000
Const WS_MAXIMIZE = &H1000000


'  Window field offsets for GetWindowLong()
Const GWL_WNDPROC = (-4)
Const GWL_STYLE = (-16)
Const GWL_EXSTYLE = (-20)

'$endif

'$ifndef _WINKERN

' Definitions stolen from WINKERN.INC
'-----------------------------------------------------------------------------
Declare Function WinExec           Lib "Kernel32" ALIAS "WinExec" (lpCmdLine$, nCmdShow%) As Integer

'$endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wownt16.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt16.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 16-bit thunking code.

--*/

#ifndef _WOWNT16_
#define _WOWNT16_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// GetVDMPointer32W will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer. The upper 16 bits
// of the address are treated according to the value passed in
// fMode: if fMode = 1, then the hiword of vp is used as a
// protected mode selector. Otherwise it is used as a real mode
// segment value.
// The lower 16 bits are treated as the offset.
//
// The return value is 0 if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause 0 to be returned when the
// limit is exceeded by the supplied offset.
//

DWORD FAR PASCAL GetVDMPointer32W(LPVOID vp, UINT fMode);


//
// Win32 module management.
//
// The following routines accept parameters that correspond directly
// to the respective Win32 API function calls that they invoke. Refer
// to the Win32 reference documentation for more detail.

DWORD FAR PASCAL LoadLibraryEx32W(LPCSTR lpszLibFile, DWORD hFile, DWORD dwFlags);
DWORD FAR PASCAL GetProcAddress32W(DWORD hModule, LPCSTR lpszProc);
DWORD FAR PASCAL FreeLibrary32W(DWORD hLibModule);

//
// Generic Thunk Routine:
//
//   CallProc32W
//
// Transitions to 32 bits and calls specified routine
//
// This routine can pass a variable number of arguments, up to 32, to the
// target 32-bit routine. These arguments are given to CallProc32W following
// the 3 required parameters.
//
//   DWORD cParams          - Number of optional DWORD parameters (0-32)
//
//   LPVOID fAddressConvert - Bit Field, for 16:16 address Convertion. The
//                            optional parameters can be automatically converted
//                            from a 16:16 address format to flat by specifying
//                            a 1 bit in the corresponding position in this mask.
//                            eg (bit 1 means convert parameter 1 from 16:16
//                              to flat address before calling routine)
//
//   DWORD lpProcAddress   -  32 bit native address to call (use LoadLibraryEx32W
//                            and GetProcAddress32W to get this address).
//
// Returns:
//   What ever the API returned on 32 bit side in AX:DX
//
// Error Returns:
//   AX = 0, more than 32 parameters.
//
//
// The function prototype must be declared by the application source code
// in the following format:
//
// DWORD FAR PASCAL CallProc32W( DWORD p1, ... , DWORD lpProcAddress,
//                                        DWORD fAddressConvert, DWORD cParams);
//
// where the value in cParams must match the actual number of optional
// parameters (p1-pn) given AND the "DWORD p1, ..." must be replaced by
// the correct number of parameters being passed.  For example, passing 3
// parameter would simply require the removal of the ... and it insertion of
// "DWORD p2, DWORD p3" instead.  The fAddressConvert parameter uses bit 1
// for the last parameter (p3 in our example), with bit 2 for the next to last,
// etc.
//
// Generic Thunk Routine:
//
//   CallProcEx32W
//
// Transitions to 32 bits and calls specified routine
//
// Similar to the CallProc32W function, the CallProcEx32W is an equivalent
// function that is C calling convention and allows easier and more flexible
// prototyping.  See the prototype below.  The fAddressConvert parameter uses
// bit 1 for the 1st parameter, bit 2 for the 2nd parameter, etc.
//
// Both CallProc32W and CallProcEx32W accept a flag OR'd with the parameter
// count to indicate the calling convention of the function in 32 bits.
// For example, to call a cdecl function in 32-bits with 1 parameter, it would
// look like this:
//
// dwResult = CallProcEx32W( CPEX_DEST_CDECL | 1, 0, dwfn32, p1 );
//

DWORD FAR CDECL CallProcEx32W( DWORD, DWORD, DWORD, ... );

#define CPEX_DEST_STDCALL   0x00000000L
#define CPEX_DEST_CDECL     0x80000000L

#ifdef __cplusplus
}
#endif

#endif /* !_WOWNT16_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wshisotp.h ===
/* File: .streams.include.src/mod  wshisotp.h            Version: Initial */
/*
 *   wshisotp.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for ISO TP4.  This file contains all
 *   standardized ISO TP4 information.  Include this header file after
 *   winsock.h.
 *
 *   The information contained in this header file was originally
 *   created by Alcatel TITN Inc.
 */

#ifndef _WSHISOTP_
#define _WSHISOTP_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Protocol values for ISO transport protocols.
 */

#define ISOPROTO_TP0       25      /* connection orientated transport protocol */
#define ISOPROTO_TP1       26      /* not implemented */
#define ISOPROTO_TP2       27      /* not implemented */
#define ISOPROTO_TP3       28      /* not implemented */
#define ISOPROTO_TP4       29      /* connection orientated transport protocol */
#define ISOPROTO_TP        ISOPROTO_TP4
#define ISOPROTO_CLTP      30      /* connectionless transport */
#define ISOPROTO_CLNP      31      /* connectionless internetworking protocol */
#define ISOPROTO_X25       32      /* cons */
#define ISOPROTO_INACT_NL  33      /* inactive network layer */
#define ISOPROTO_ESIS      34      /* ES-IS protocol */
#define ISOPROTO_INTRAISIS 35      /* IS-IS protocol */

#define IPPROTO_RAW        255     /* raw clnp */
#define IPPROTO_MAX        256

/*
 *   The maximum size of the tranport address (tp_addr field of a
 *   sockaddr_tp structure) is 64.
 */

#define ISO_MAX_ADDR_LENGTH 64

/*
 *   There are two types of ISO addresses, hierarchical and
 *   non-hierarchical.  For hierarchical addresses, the tp_addr
 *   field contains both the transport selector and the network
 *   address.  For non-hierarchical addresses, tp_addr contains only
 *   the transport address, which must be translated by the ISO TP4
 *   transport provider into the transport selector and network address.
 */

#define ISO_HIERARCHICAL            0
#define ISO_NON_HIERARCHICAL        1

/*
 *   The format of the address structure (sockaddr) to pass to Windows
 *   Sockets APIs.
 *
 */

typedef struct sockaddr_tp {
   u_short tp_family;          /* Always AF_ISO */
   u_short tp_addr_type;       /* ISO_HIERARCHICAL or ISO_NON_HIERARCHICAL
*/
   u_short tp_taddr_len;       /* Length of transport address, <= 52 */
   u_short tp_tsel_len;        /* Length of transport selector, <= 32 */
                               /* 0 if ISO_NON_HIERARCHICAL */
   u_char tp_addr[ISO_MAX_ADDR_LENGTH];
} SOCKADDR_TP, *PSOCKADDR_TP, *LPSOCKADDR_TP;

#define ISO_SET_TP_ADDR(sa_tp, port, portlen, node, nodelen)              \
            (sa_tp)->tp_family = AF_ISO;                         \
            (sa_tp)->tp_addr_type = ISO_HIERARCHICAL;            \
            (sa_tp)->tp_tsel_len = (portlen);              \
            (sa_tp)->tp_taddr_len = (portlen) + (nodelen); \
            memcpy(&(sa_tp)->tp_addr, (port), (portlen)); \
            memcpy(&(sa_tp)->tp_addr[portlen], (node), (nodelen));


/*
 *   Expedited Data Usage Negotiation option.
 *   Default when the option is not present is be EXP_DATA_USE
 *   as per ISO 8073
 */

#define ISO_EXP_DATA_USE  00    /* Use of Expedited Data */
#define ISO_EXP_DATA_NUSE 01    /* Non-use of Expedited Data */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winperf.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
#ifdef _WIN64
    DWORD           ObjectNameTitle;
#else
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
#ifdef _WIN64
    DWORD           ObjectHelpTitle;
#else
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000
#define PERF_SIZE_LARGE         0x00000100
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
#define PERF_COUNTER_PRECISION  0x00070000  // divide ctr / private clock
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)


// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_LARGE_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using 100 Ns timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_100NS_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using Object specific timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in object specific units. Display delta divided by
// delta time as returned in the object type header structure.  Display suffix: "%"
#define PERF_OBJ_TIME_TIMER	\
            (PERF_SIZE_LARGE   | PERF_TYPE_COUNTER  | PERF_COUNTER_RATE |\
             PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)


// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

#define PERF_LARGE_RAW_FRACTION           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

#define PERF_LARGE_RAW_BASE               \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW )

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram
//
//  This counter is used to display the difference from one sample
//  to the next. The counter value is a constantly increasing number
//  and the value displayed is the difference between the current
//  value and the previous value. Negative numbers are not allowed
//  which shouldn't be a problem as long as the counter value is
//  increasing or unchanged.
//
#define PERF_COUNTER_DELTA      \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

#define PERF_COUNTER_LARGE_DELTA      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)
//
//  The precision counters are timers that consist of two counter values:
//      1) the count of elapsed time of the event being monitored
//      2) the "clock" time in the same units
//
//  the precition timers are used where the standard system timers are not
//  precise enough for accurate readings. It's assumed that the service
//  providing the data is also providing a timestamp at the same time which
//  will eliminate any error that may occur since some small and variable
//  time elapses between the time the system timestamp is captured and when
//  the data is collected from the performance DLL. Only in extreme cases
//  has this been observed to be problematic.
//
//  when using this type of timer, the definition of the
//      PERF_PRECISION_TIMESTAMP counter must immediately follow the
//      definition of the PERF_PRECISION_*_TIMER in the Object header
//
// The timer used has the same frequency as the System Performance Timer
#define PERF_PRECISION_SYSTEM_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_TICK    | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used has the same frequency as the 100 NanoSecond Timer
#define PERF_PRECISION_100NS_TIMER  \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_100NS   | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used is of the frequency specified in the Object header's
//  PerfFreq field (PerfTime is ignored)
#define PERF_PRECISION_OBJECT_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_OBJECT_TIMER  | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// This is the timestamp to use in the computation of the timer specified
// in the previous description block
#define PERF_PRECISION_TIMESTAMP    PERF_LARGE_RAW_BASE
//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//
//
#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer
//
//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//
//
typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterNameTitle;
#else
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterHelpTitle;
#else
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;
//
//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none
                                        // this length includes the characters
                                        // in the string plus the size of the
                                        // terminating NULL char. It does not
                                        // include any additional pad bytes to
                                        // correct structure alignment
} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
// Support for New Extensible API starting with NT 5.0
//
#define     PERF_QUERY_OBJECTS      ((LONG)0x80000000)
#define     PERF_QUERY_GLOBAL       ((LONG)0x80000001)
#define     PERF_QUERY_COSTLY       ((LONG)0x80000002)

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);
typedef DWORD (APIENTRY PM_QUERY_PROC) (LPDWORD, LPVOID *, LPDWORD, LPDWORD);

#define     MAX_PERF_OBJECTS_IN_QUERY_FUNCTION      (64L)

#include <poppack.h>

#endif // _WINPERF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wsipx.h ===
/*
 *   wsipx.h
 *
 *   Microsoft Windows
 *   Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for IPX/SPX.  This file contains all
 *   standardized IPX/SPX information.  Include this header file after
 *   winsock.h.
 *
 *   To open an IPX socket, call socket() with an address family of
 *   AF_IPX, a socket type of SOCK_DGRAM, and protocol NSPROTO_IPX.
 *   Note that the protocol value must be specified, it cannot be 0.
 *   All IPX packets are sent with the packet type field of the IPX
 *   header set to 0.
 *
 *   To open an SPX or SPXII socket, call socket() with an address
 *   family of AF_IPX, socket type of SOCK_SEQPACKET or SOCK_STREAM,
 *   and protocol of NSPROTO_SPX or NSPROTO_SPXII.  If SOCK_SEQPACKET
 *   is specified, then the end of message bit is respected, and
 *   recv() calls are not completed until a packet is received with
 *   the end of message bit set.  If SOCK_STREAM is specified, then
 *   the end of message bit is not respected, and recv() completes
 *   as soon as any data is received, regardless of the setting of the
 *   end of message bit.  Send coalescing is never performed, and sends
 *   smaller than a single packet are always sent with the end of
 *   message bit set.  Sends larger than a single packet are packetized
 *   with the end of message bit set on only the last packet of the
 *   send.
 *
 */

#ifndef _WSIPX_
#define _WSIPX_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for IPX and SPX.
 *
 */

typedef struct sockaddr_ipx {
    short sa_family;
    char  sa_netnum[4];
    char  sa_nodenum[6];
    unsigned short sa_socket;
} SOCKADDR_IPX, *PSOCKADDR_IPX,FAR *LPSOCKADDR_IPX;

/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 *
 */

#define NSPROTO_IPX      1000
#define NSPROTO_SPX      1256
#define NSPROTO_SPXII    1257

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wsnetbs.h ===
/*
 *   wsnetbs.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for NETBIOS.  This file contains all
 *   standardized NETBIOS information.  Include this header file after
 *   winsock.h.
 *
 */

#ifndef _WSNETBS_
#define _WSNETBS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for NETBIOS.
 *
 */

#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb {
    short   snb_family;
    u_short snb_type;
    char    snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB, *PSOCKADDR_NB,FAR *LPSOCKADDR_NB;

/*
 * Bit values for the snb_type field of SOCKADDR_NB.
 *
 */

#define NETBIOS_UNIQUE_NAME         (0x0000)
#define NETBIOS_GROUP_NAME          (0x0001)
#define NETBIOS_TYPE_QUICK_UNIQUE   (0x0002)
#define NETBIOS_TYPE_QUICK_GROUP    (0x0003)

/*
 * A macro convenient for setting up NETBIOS SOCKADDRs.
 *
 */

#define SET_NETBIOS_SOCKADDR(_snb,_type,_name,_port)                          \
    {                                                                         \
        int _i;                                                               \
        (_snb)->snb_family = AF_NETBIOS;                                      \
        (_snb)->snb_type = (_type);                                           \
        for (_i=0; _i<NETBIOS_NAME_LENGTH-1; _i++) {                          \
            (_snb)->snb_name[_i] = ' ';                                       \
        }                                                                     \
        for (_i=0; *((_name)+_i) != '\0' && _i<NETBIOS_NAME_LENGTH-1; _i++) { \
            (_snb)->snb_name[_i] = *((_name)+_i);                             \
        }                                                                     \
        (_snb)->snb_name[NETBIOS_NAME_LENGTH-1] = (_port);                    \
    }

/*
 *   To open a NetBIOS socket, call the socket() function as follows:
 *
 *       s = socket( AF_NETBIOS, {SOCK_SEQPACKET|SOCK_DGRAM}, -Lana );
 *
 *   where Lana is the NetBIOS Lana number of interest.  For example, to
 *   open a socket for Lana 2, specify -2 as the "protocol" parameter
 *   to the socket() function.
 *
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wsvns.h ===
/*******************************************************************************
 *
 *   wsvns.h
 *
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for VINES IP.  This file contains all
 *   standardized VINES IP information.  Include this header file after
 *   winsock.h.
 *
 *   To open an VINES IP socket, call socket() with an address family of
 *   AF_BAN, a socket type of SOCK_DGRAM, SOCK_STREAM, or SOCK_SEQPACKET,
 *   and protocol of 0.
 *
 ******************************************************************************/

#ifndef _WSVNS_
#define _WSVNS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Socket address, VINES IP style.  Address fields and port field are defined
 * as a sequence of bytes.  This is done because they are byte ordered
 * BIG ENDIAN, ala most significant byte first.
 */
typedef struct sockaddr_vns {
    u_short sin_family;			// = AF_BAN
    u_char  net_address[4];		// network address
    u_char  subnet_addr[2];		// subnet address
    u_char  port[2];			// msb=port[0], lsb=port[1]
    u_char  hops;			// # hops for broadcasts
    u_char  filler[5];			// filler, zeros
} SOCKADDR_VNS, *PSOCKADDR_VNS, FAR *LPSOCKADDR_VNS;

#define VNSPROTO_IPC		1
#define VNSPROTO_RELIABLE_IPC	2
#define VNSPROTO_SPP		3


#endif _WSVNS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wmium.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmium.h

Abstract:

    Public headers for WMI data consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMIUM_
#define _WMIUM_

#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif
#endif

#include <guiddef.h>

#include <basetsd.h>
#include <wmistr.h>

typedef PVOID WMIHANDLE, *PWMIHANDLE, MOFHANDLE, *PMOFHANDLE;


//
// When set the guid can be opened and accessed
#define MOFCI_RESERVED0  0x00000001

#define MOFCI_RESERVED1  0x00000002
#define MOFCI_RESERVED2  0x00000004

typedef struct
{
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ImagePath;        // Path to image containing MOF resource
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
#ifdef MIDL_PASS
    [size_is(0)] PDFBYTE
#else
    PUCHAR
#endif
             ResourceBuffer;    // Reserved
} MOFRESOURCEINFOW, *PMOFRESOURCEINFOW;


typedef struct
{
    LPSTR
             ImagePath;        // Path to image containing MOF resource
    LPSTR
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
    UCHAR
             *ResourceBuffer;   // Reserved
} MOFRESOURCEINFOA, *PMOFRESOURCEINFOA;

#ifdef UNICODE
typedef MOFRESOURCEINFOW MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOW PMOFRESOURCEINFO;
#else
typedef MOFRESOURCEINFOA MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOA PMOFRESOURCEINFO;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data consumer apis
ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
);

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
);

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define WmiQueryAllData WmiQueryAllDataW
#else
#define WmiQueryAllData WmiQueryAllDataA
#endif


ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);
#ifdef UNICODE
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleW
#else
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );
#ifdef UNICODE
#define WmiQuerySingleInstance WmiQuerySingleInstanceW
#else
#define WmiQuerySingleInstance WmiQuerySingleInstanceA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN LPCWSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN LPCSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

#ifdef UNICODE
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleW
#else
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleA
#endif

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleInstance WmiSetSingleInstanceW
#else
#define WmiSetSingleInstance WmiSetSingleInstanceA
#endif

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleItem WmiSetSingleItemW
#else
#define WmiSetSingleItem WmiSetSingleItemA
#endif

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

#ifdef UNICODE
#define WmiExecuteMethod WmiExecuteMethodW
#else
#define WmiExecuteMethod WmiExecuteMethodA
#endif

// Set this Flag when calling NotficationRegistration to enable or
// disable a trace logging guid
#define NOTIFICATION_TRACE_FLAG       0x00010000

// Set this flag when enabling a notification that should be delivered via
// a direct callback. Any notifications received will be given their own
// thread and the callback function called immediately.
#define NOTIFICATION_CALLBACK_DIRECT  0x00000004

//
// Set this flag (and only this flag) when you want to only check if the 
// caller has permission to receive events for the guid
//
#define NOTIFICATION_CHECK_ACCESS 0x00000008

//
// Event notification callback function prototype
typedef void (
#ifndef MIDL_PASS
WINAPI
#endif
*NOTIFICATIONCALLBACK)(
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext
    );

#ifndef MIDL_PASS
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_REGISTRATION_CHANGE_NOTIFICATION,
0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);
#endif

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );
#ifdef UNICODE
#define WmiNotificationRegistration WmiNotificationRegistrationW
#else
#define WmiNotificationRegistration WmiNotificationRegistrationA
#endif

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    );


ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    );
#ifdef UNICODE
#define WmiMofEnumerateResources WmiMofEnumerateResourcesW
#else
#define WmiMofEnumerateResources WmiMofEnumerateResourcesA
#endif

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT CHAR *InstanceNames
    );

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT WCHAR *InstanceNames
    );
#ifdef UNICODE
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameW
#else
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameA
#endif

#define WmiInsertTimestamp(WnodeHeader) \
    GetSystemTimeAsFileTime((FILETIME *)&((PWNODE_HEADER)WnodeHeader)->TimeStamp)

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT CHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN CHAR *DevInst,
    IN ULONG InstanceIndex
    );

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT WCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN WCHAR *DevInst,
    IN ULONG InstanceIndex
    );
#ifdef UNICODE
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameW
#else
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameA
#endif

typedef struct _WMIGUIDINFORMATION
{
    ULONG Size;
    BOOLEAN IsExpensive;
    BOOLEAN IsEventOnly;
} WMIGUIDINFORMATION, *PWMIGUIDINFORMATION;


ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE GuidHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    );


ULONG
WMIAPI
WmiReceiveNotificationsW(
    IN ULONG HandleCount,
	IN HANDLE *HandleList,
	IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

ULONG
WMIAPI
WmiReceiveNotificationsA(
    IN ULONG HandleCount,
	IN HANDLE *HandleList,
	IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

#ifdef UNICODE
#define WmiReceiveNotifications WmiReceiveNotificationsW
#else
#define WmiReceiveNotifications WmiReceiveNotificationsA
#endif


//
// Internal Flags for different processing modes.
// Applies to the TRACE_LOGFILE_HEADER ReservedFlags field.
//

#define EVENT_TRACE_USE_RAWTIMESTAMP 2    // Used with OpenTrace(), prevents
                                          // conversion of TimeStamps to UTC

//
// Low level trace consumer routines
//

typedef enum tagWMI_HEADER_TYPE {
    WMIHT_NONE,
    WMIHT_UNKNOWN,
    WMIHT_SYSTEM32,
    WMIHT_SYSTEM64,
    WMIHT_EVENT_TRACE,
    WMIHT_EVENT_INSTANCE,
    WMIHT_TIMED,
    WMIHT_ULONG32,
    WMIHT_WNODE,
    WMIHT_MESSAGE,
    WMIHT_PERFINFO32,
    WMIHT_PERFINFO64
} WMI_HEADER_TYPE;

typedef enum tagWMI_BUFFER_SOURCE {
    WMIBS_FLUSH_LIST,
    WMIBS_FREE_LIST,
    WMIBS_TRANSITION_LIST,
    WMIBS_CURRENT_LIST,
    WMIBS_LOG_FILE
} WMI_BUFFER_SOURCE;

typedef struct {
    WMI_BUFFER_SOURCE BufferSource;
    ULONG BufferSize;   // Size of the Buffer
    ULONG ProcessorNumber;      
    ULONG Alignment;    // Alignment
    PVOID Buffer;       // Pointer to the raw buffer
} WMIBUFFERINFO, *PWMIBUFFERINFO;

//
// Get buffer offset to first event only. Returns Size. 
// Fix up the Buffer for proper termination and alignment. 
//

ULONG
WMIAPI
WmiGetFirstTraceOffset(
    IN PWMIBUFFERINFO BufferInfo
    );

//
// Get the next event, size and type. Caller must advance offset with Size
// 

WMI_HEADER_TYPE
WMIAPI
WmiGetTraceHeader(
    IN  PVOID  Buffer,
    IN  ULONG  Offset,
    OUT ULONG  *Size
    );

//
// Returns a EVENT_TRACE / (new Structure Ian will define) 
// in the Buffer provided

ULONG 
WMIAPI
WmiParseTraceEvent(
    IN PVOID Buffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    );


#ifdef __cplusplus
}
#endif

#endif  // _WMIUM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wmiguid.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

--*/

#include <guiddef.h>

//
// This is WMI guid used to return disk performance information from
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

//
// This guid will return additional information about a data provider
// {5494DFDC-A98A-11d1-BF43-00A0C9062910}
#define DATA_PROVIDER_INFO_GUID \
   {0x5494dfdc, 0xa98a, 0x11d1, 0xbf, 0x43, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}


//
// This wmi guid is used to return the entire SMBIOS data table
// {8F680850-A584-11d1-BF38-00A0C9062910}
#define SMBIOS_DATA_GUID \
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

//
// This wmi guid is used to return thermal information
// {A1BC18C0-A7C8-11d1-BF3C-00A0C9062910}
DEFINE_GUID(THERMAL_ZONE_GUID,  \
   0xa1bc18c0, 0xa7c8, 0x11d1, 0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This wmi guid is used to return additional information about the provider
// of an instance name. Note that only QuerySingleInstance is supported.
// {C7BF35D0-AADB-11d1-BF4A-00A0C9062910}
#define INSTANCE_INFO_GUID \
    {0xc7bf35d0, 0xaadb, 0x11d1, 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

#define BINARY_MOF_GUID \
    {0x05901221, 0xD566, 0x11d1, 0xB2, 0xF0, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}

#define ENUMERATE_GUIDS_GUID \
    {0xe3dff7bd, 0x3915, 0x11d2, 0x91, 0x03, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}

//
// Global WMI Logger GUID
//

DEFINE_GUID ( /* e8908abc-aa84-11d2-9a93-00805f85d7c6 */
    GlobalLoggerGuid,
    0xe8908abc,
    0xaa84,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

DEFINE_GUID ( /* 44608a51-1851-4456-98b2-b300e931ee41 */
    WmiEventLoggerGuid,
    0x44608a51,
    0x1851,
    0x4456,
    0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41
  );
DEFINE_GUID ( /* 8d40301f-ab4a-11d2-9a93-00805f85d7c6 */
    GenericMessageGuid,
    0x8d40301f,
    0xab4a,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

//
// Event Trace GUIDs
//

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
DEFINE_GUID ( /* 9a280ac0-c8e0-11d1-84e2-00c04fb998a2 */
    TcpIpGuid,
    0x9a280ac0,
    0xc8e0,
    0x11d1,
    0x84, 0xe2, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
  );
DEFINE_GUID ( /* bf3a50c5-a9c9-4988-a005-2df0b7c80f80 */
    UdpIpGuid,
    0xbf3a50c5,
    0xa9c9,
    0x4988,
    0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80
  );

DEFINE_GUID ( /* 2cb15d1d-5fc1-11d2-abe1-00a0c911f518 */
    ImageLoadGuid,
    0x2cb15d1d,
    0x5fc1,
    0x11d2,
    0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18
  );

DEFINE_GUID ( /* AE53722E-C863-11d2-8659-00C04FA321A1 */
    RegistryGuid, 
    0xae53722e,
    0xc863,
    0x11d2,
    0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1
);

DEFINE_GUID( /* 13976D09-A327-438c-950B-7F03192815C7  */
    DbgPrintGuid,
    0x13976d09,
    0xa327,
    0x438c,
    0x95, 0xb, 0x7f, 0x3, 0x19, 0x28, 0x15, 0xc7
    );


//
// Special WMI events
//
DEFINE_GUID ( /* 398191dc-2da7-11d3-8b98-00805f85d7c6 */
    TraceErrorGuid,
    0x398191dc,
    0x2da7,
    0x11d3,
    0x8b, 0x98, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wmistr.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmistr.h

Abstract:

    WMI structure definitions

--*/

#ifndef _WMISTR_
#define _WMISTR_

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;    // Provider Id of driver returning this buffer
    union
    {
        ULONG64 HistoricalContext;  // Logger use
    	struct
	    {
            ULONG Version;           // Reserved
            ULONG Linkage;           // Linkage field reserved for WMI
    	};
    };

    union
    {
        ULONG CountLost;         // Reserved
        HANDLE KernelHandle;     // Kernel handle for data block
        LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                                 // since 1/1/1601
    };
    GUID Guid;                  // Guid for data block returned with results
    ULONG ClientContext;
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is
                                              // identical for all instances
                                              // (used with  WNODE_ALL_DATA
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a
                                 // WNODE_ALL_DATA in which the number of
                                 // instances and their names returned
                                 // are identical to those returned from the
                                 // previous WNODE_ALL_DATA query. Only data
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in
                                 // WNODE_ALL_DATA; values specified at
                                 // registration are used instead. Always
                                 // set for guids registered with static
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200
#define WNODE_FLAG_PERSIST_EVENT 0x00000400

#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// The second byte, except the first bit is used exclusively for tracing
#define WNODE_FLAG_TRACED_GUID   0x00020000 // denotes a trace

#define WNODE_FLAG_LOG_WNODE     0x00040000 // request to log Wnode

#define WNODE_FLAG_USE_GUID_PTR  0x00080000 // Guid is actually a pointer

#define WNODE_FLAG_USE_MOF_PTR   0x00100000 // MOF data are dereferenced

#define WNODE_FLAG_INTERNAL2     0x00200000  // Used internally by WMI

// Set for events that are WNODE_EVENT_REFERENCE
// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

//
// This structure is used within the WNODE_ALL_DATA when the data blocks
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block

    ULONG InstanceCount;  // Count of instances whose data follows.

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the
    // offsets and lengths of the data blocks for each instance.
    union
    {
        ULONG FixedInstanceSize;
    	OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };

    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data
                            // On Return: offset from WNODE to input and
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    union
    {
                     // If WMIREG_FLAG_INSTANCE_LIST then this has the offset
                     // to a list of InstanceCount counted UNICODE
                     // strings placed end to end.
        ULONG InstanceNameList;
			
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this has the
                     // offset to a single counted UNICODE string that
                     // has the basename for the instance names.
			
        ULONG BaseNameOffset;
			
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will
                     // become the instance name
        ULONG_PTR Pdo;
			
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to
                     // a WMIREGINSTANCEREF structure.
			
        ULONG_PTR InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
    };

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020

// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_RESERVED1         0x00020000 // Reserved by WMI
#define WMIREG_FLAG_RESERVED2         0x00040000 // Reserved by WMI

// Set if guid is one that is written to trace log.
// This guid cannot be queried directly via WMI, but must be read using
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000

//
// Only those Trace Guids that have this bit set can receive
// Enable/Disable Notifications.
//
#define WMIREG_FLAG_TRACE_CONTROL_GUID 0x00001000

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG 	
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data
						// providers
							
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER
// TRACELOG_CREATE_INPROC
// TRACELOG_ACCESS_REALTIME

//
// GuidTypes 
//
//#ifndef _WMIKM_
#define WMI_GUIDTYPE_TRACECONTROL 0
#define WMI_GUIDTYPE_TRACE        1
#define WMI_GUIDTYPE_DATA         2
#define WMI_GUIDTYPE_EVENT        3
//#endif

//
// Specific rights for WMI guid objects. These are available from 0x0001 to
// 0xffff (ie up to 16 rights)
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_READ |     \
                            SYNCHRONIZE | \
                            WMIGUID_QUERY |                \
                            WMIGUID_SET |                  \
                            WMIGUID_NOTIFICATION |         \
                            WMIGUID_READ_DESCRIPTION |     \
                            WMIGUID_EXECUTE |              \
                            TRACELOG_CREATE_REALTIME |     \
                            TRACELOG_CREATE_ONDISK |       \
                            TRACELOG_GUID_ENABLE |         \
                            TRACELOG_ACCESS_KERNEL_LOGGER |\
                            TRACELOG_CREATE_INPROC | \
                            TRACELOG_ACCESS_REALTIME | \
                            TRACELOG_REGISTER_GUIDS  )

#define WMI_GLOBAL_LOGGER_ID          0x0001
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\zmouse.h ===
/****************************************************************************
*                                                                           *
* ZMOUSE.H -- Include file for IntelliMouse(tm) 1.0                         *
*                                                                           *
* NOTE:  Zmouse.h contains #defines required when providing IntelliMouse    *
*        wheel support for Windows95 and NT3.51.  Wheel is supported        *
*        natively in WinNT4.0, please refer to the NT4.0 SDK for more info  *
*        on providing support for IntelliMouse in NT4.0.                    *
*                                                                           *
* Copyright (c) 1983-1999, Microsoft Corp. All rights reserved.             *
*                                                                           *
\***************************************************************************/


#if _MSC_VER > 1000
#pragma once
#endif

/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#ifdef UNICODE
#define MSH_MOUSEWHEEL L"MSWHEEL_ROLLMSG"
#else
#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
#endif
   // wParam = wheel rotation expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one notch


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	   *  determining if wheel support active
	   *  determining # of Scroll Lines
***************************************************************************/

// Class name for MSWHEEL.EXE's invisible window
// use FindWindow to get hwnd to MSWHEEL
#ifdef UNICODE
#define MOUSEZ_CLASSNAME  L"MouseZ"           // wheel window class
#define MOUSEZ_TITLE      L"Magellan MSWHEEL" // wheel window title
#else
#define MOUSEZ_CLASSNAME  "MouseZ"            // wheel window class
#define MOUSEZ_TITLE      "Magellan MSWHEEL"  // wheel window title
#endif

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines
// below to get the message numbers for:
// 1) the message that can be sent to the MSWHEEL window to
//    query if wheel support is active (MSH_WHEELSUPPORT)>
// 2) the message to query for the number of scroll lines
//    (MSH_SCROLL_LINES)
//
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is not currently available.

#ifdef UNICODE
#define MSH_WHEELSUPPORT L"MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                 // to query for wheel support
#else
#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG"  // name of msg to send
                                                 // to query for wheel support
#endif

// MSH_WHEELSUPPORT
//    wParam - not used
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise


#ifdef UNICODE
#define MSH_SCROLL_LINES L"MSH_SCROLL_LINES_MSG"
#else
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"
#endif

// MSH_SCROLL_LINES
//    wParam - not used
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL  (UINT_MAX)   // signifies to scroll a page, also
                                       // defined in winuser.h in the
                                       // NT4.0 SDK
#endif

#ifndef SPI_SETWHEELSCROLLLINES
#define SPI_SETWHEELSCROLLLINES   105  // Also defined in winuser.h in the
                                       // NT4.0 SDK, please see the NT4.0 SDK
                                       // documentation for NT4.0 implementation
                                       // specifics.
                                       // For Win95 and WinNT3.51,
                                       // Mswheel broadcasts the message
                                       // WM_SETTINGCHANGE (equivalent to
                                       // WM_WININICHANGE) when the scroll
                                       // lines has changed.  Applications
                                       // will recieve the WM_SETTINGCHANGE
                                       // message with the wParam set to
                                       // SPI_SETWHEELSCROLLLINES.  When
                                       // this message is recieved the application
                                       // should query Mswheel for the new
                                       // setting.
#endif


/*********************************************************************
* INLINE FUNCTION: HwndMsWheel
* Purpose : Get a reference to MSWheel Window, the registered messages,
*           wheel support active setting, and number of scrollLines
* Params  : PUINT puiMsh_MsgMouseWheel - address of UINT to contain returned registered wheel message
*           PUINT puiMsh_Msg3DSupport - address of UINT to contain wheel support registered message
*           PUINT puiMsh_MsgScrollLines - address of UINT to contain Scroll lines registered message
*           PBOOL pf3DSupport - address of BOOL to contain returned flag for wheel support active
*           PINT  piScrollLines - address of int to contain returned scroll lines
* Returns : HWND handle to the MsWheel window
* Note    : The return value for pf3DSupport and piScrollLines is dependant
*           on the POINT32 module.  If POINT32 module is not running then
*           the values returned for these parameters will be
*           FALSE and 3, respectively.
*********************************************************************/
__inline HWND HwndMSWheel(
      PUINT puiMsh_MsgMouseWheel,
      PUINT puiMsh_Msg3DSupport,
      PUINT puiMsh_MsgScrollLines,
      PBOOL pf3DSupport,
      PINT  piScrollLines
)
{
   HWND hdlMsWheel;

   hdlMsWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);

   *puiMsh_MsgMouseWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
   *puiMsh_Msg3DSupport = RegisterWindowMessage(MSH_WHEELSUPPORT);
   *puiMsh_MsgScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);

   if (*puiMsh_Msg3DSupport)
      *pf3DSupport = (BOOL)SendMessage(hdlMsWheel, *puiMsh_Msg3DSupport, 0, 0);
   else
      *pf3DSupport = FALSE;  // default to FALSE

   if (*puiMsh_MsgScrollLines)
      *piScrollLines = (int)SendMessage(hdlMsWheel, *puiMsh_MsgScrollLines, 0, 0);
   else
      *piScrollLines = 3;  // default

   return(hdlMsWheel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao350\daogetrw.h ===
/************************************************************************
**  D A O G E T R W . H                                                 *
**                                                                      *
**  GetRows interface                                                   *
**                                                                      *
**  Warning: The interface defined in this file is for internal use by	*
**    the Microsoft Foundation Classes and the dbdao C++ classes.		*
**    Future releases of DAO may not be completely compatible with this	*
**    implementation.  However, if you write to the MFC or dbdao 		*
**    classes that use this interface, those classes will continue to 	*
**    be compatible even if this underlying interface changes.			*
**                                                                      *
*************************************************************************
** Copyright (C) 1995 by Microsoft Corporation                          *
**         All Rights Reserved                                          *
************************************************************************/

#if !defined (_DAOGETRW_H_)
#define _DAOGETRW_H_


/*
	Enumerations
*/
typedef enum
	{
	DAOCOLKIND_IND = 0,
	DAOCOLKIND_STR,
	DAOCOLKIND_WSTR
	} DAOCOLKIND;

typedef enum
	{
	DAO_I2 = 0,
	DAO_I4,
	DAO_R4,
	DAO_R8,
	DAO_CURRENCY,
	DAO_DATE,
	DAO_BOOL,
	DAO_BSTR,
	DAO_LPSTR,
	DAO_LPWSTR,
	DAO_BLOB,
	DAO_BYTES,
	DAO_CHAR,
	DAO_WCHAR,
	DAO_ANYVARIANT,
	DAO_BOOKMARK,
	DAO_BYTE,
	DAO_GUID,
	DAO_DATATYPEMAX
	} DAODATATYPE;

/*
	Macros
*/
#define DAO_NOINDICATOR 0xffffffff
#define DAO_NULL        0xffffffff
#define DAO_CANTCOERCE  0xfffffffc
#define DAO_NOMAXLENGTH 0x00000000

#define DAOROWFETCH_CALLEEALLOCATES     0x00000001
#define DAOROWFETCH_DONTADVANCE         0x00000002
#define DAOROWFETCH_FORCEREFRESH        0x00000004
#define DAOROWFETCH_BINDABSOLUTE        0x00000008

#define DAOBINDING_DIRECT               0x00000001
#define DAOBINDING_VARIANT              0x00000002
#define DAOBINDING_CALLBACK             0x00000004

/*
	Structures
*/
typedef struct
	{
	DWORD           dwKind;
	union
		{
		LONG        ind;
		LPCSTR      lpstr;
		LPCWSTR		lpwstr;
		};
	} DAOCOLUMNID;
typedef DAOCOLUMNID *LPDAOCOLUMNID;

// Callback for binding
EXTERN_C typedef HRESULT (STDAPICALLTYPE *LPDAOBINDFUNC)(ULONG cb, DWORD dwUser, LPVOID *ppData);
#define DAOBINDINGFUNC(f)   STDAPI f (ULONG cb, DWORD dwUser, LPVOID *ppData)

typedef struct
	{
	DAOCOLUMNID     columnID;
	ULONG           cbDataOffset;
	ULONG           cbMaxLen;
	ULONG           cbInfoOffset;
	DWORD           dwBinding;
	DWORD           dwDataType;
	DWORD           dwUser;
	} DAOCOLUMNBINDING;
typedef DAOCOLUMNBINDING *LPDAOCOLUMNBINDING;

typedef struct
	{
	ULONG           cRowsRequested;
	DWORD           dwFlags;
	LPVOID          pData;
	LPVOID          pVarData;
	ULONG           cbVarData;
	ULONG           cRowsReturned;
	} DAOFETCHROWS;
typedef DAOFETCHROWS *LPDAOFETCHROWS;

/*
	New Errors

	**NOTE: OLE standard ids to be determined.
*/

#define GETROWSUCCESS(x) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, x)
#define GETROWERR(x) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, x)

#define S_BUFFERTOOSMALL    GETROWSUCCESS(0x1000)
#define S_ENDOFCURSOR       GETROWSUCCESS(0x1001)
#define S_SILENTCANCEL      GETROWSUCCESS(0x1002)
#define S_RECORDDELETED     GETROWSUCCESS(0x1003)

#define E_ROWTOOSHORT       GETROWERR(0x1000)
#define E_BADBINDINFO       GETROWERR(0x1001)
#define E_COLUMNUNAVAILABLE GETROWERR(0x1002)


/*
	Interfaces
*/
#undef INTERFACE
#define INTERFACE ICDAORecordset
DECLARE_INTERFACE_(ICDAORecordset, IDispatch)
	{
	STDMETHOD(GetRows)          (THIS_ LONG cRowsToSkip, LONG cCol, LPDAOCOLUMNBINDING prgBndCol, ULONG cbRowLen, LPDAOFETCHROWS pFetchRows) PURE;
	};

#endif // _DAOGETRW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao350\dbdaoid.h ===
/************************************************************************
**	D B D A O I D . H													*
**																		*
**	OLE DAO component class id definitions								*
**																		*
*************************************************************************
** Copyright (C) 1992-5 by Microsoft Corporation		 				*
**		   All Rights Reserved					 						*
************************************************************************/

/*
	All UNICODE IID_... names are the same as the ANSI IID_... name
		with a "W" appended to the end.

*/

// Type library
DEFINE_OLEGUID(LIBID_CDAO,				0x00025e01, 0, 0);

// StdObject
DEFINE_OLEGUID(IID_IDAOStdObject,		0x00025e02, 0, 0);

// StdCollection
DEFINE_OLEGUID(IID_IDAOStdCollection,	0x00025e03, 0, 0);

// DBEngine
DEFINE_OLEGUID(CLSID_CDAODBEngine,		0x00025e15, 0, 0);
DEFINE_OLEGUID(IID_IDAODBEngine,		0x00025e16, 0, 0);
DEFINE_OLEGUID(IID_IDAODBEngineW,		0x00025e17, 0, 0);
DEFINE_OLEGUID(CLSID_CDAOPrivDBEngine,	0x00025e19, 0, 0);

// Error
DEFINE_OLEGUID(IID_IDAOError,			0x00025e1d, 0, 0);
DEFINE_OLEGUID(IID_IDAOErrorW,			0x00025e1e, 0, 0);
DEFINE_OLEGUID(IID_IDAOErrors,			0x00025e1f, 0, 0);
DEFINE_OLEGUID(IID_IDAOErrorsW,			0x00025e20, 0, 0);

// Property
DEFINE_OLEGUID(IID_IDAOProperty,		0x00025e25, 0, 0);
DEFINE_OLEGUID(IID_IDAOPropertyW,		0x00025e26, 0, 0);
DEFINE_OLEGUID(IID_IDAOProperties,		0x00025e27, 0, 0);
DEFINE_OLEGUID(IID_IDAOPropertiesW,		0x00025e28, 0, 0);

// Recordset
DEFINE_OLEGUID(IID_IDAORecordset,		0x00025e2d, 0, 0);
DEFINE_OLEGUID(IID_IDAORecordsetW,		0x00025e2e, 0, 0);
DEFINE_OLEGUID(IID_IDAORecordsets,		0x00025e2f, 0, 0);
DEFINE_OLEGUID(IID_IDAORecordsetsW,		0x00025e30, 0, 0);
DEFINE_OLEGUID(IID_ICDAORecordset,		0x00025e31, 0, 0);

// Workspace
DEFINE_OLEGUID(IID_IDAOWorkspace,		0x00025e3a, 0, 0);
DEFINE_OLEGUID(IID_IDAOWorkspaceW,		0x00025e3b, 0, 0);
DEFINE_OLEGUID(IID_IDAOWorkspaces,		0x00025e3c, 0, 0);
DEFINE_OLEGUID(IID_IDAOWorkspacesW,		0x00025e3d, 0, 0);

// TableDef
DEFINE_OLEGUID(CLSID_CDAOTableDef,		0x00025e43, 0, 0);
DEFINE_OLEGUID(IID_IDAOTableDef,		0x00025e44, 0, 0);
DEFINE_OLEGUID(IID_IDAOTableDefW,		0x00025e45, 0, 0);
DEFINE_OLEGUID(IID_IDAOTableDefs,		0x00025e46, 0, 0);
DEFINE_OLEGUID(IID_IDAOTableDefsW,		0x00025e47, 0, 0);

// Field
DEFINE_OLEGUID(CLSID_CDAOField, 		0x00025e4c, 0, 0);
DEFINE_OLEGUID(IID_IDAOField,			0x00025e4d, 0, 0);
DEFINE_OLEGUID(IID_IDAOFieldW,			0x00025e4e, 0, 0);
DEFINE_OLEGUID(IID_IDAOFields,			0x00025e4f, 0, 0);
DEFINE_OLEGUID(IID_IDAOFieldsW,			0x00025e50, 0, 0);

// Index
DEFINE_OLEGUID(CLSID_CDAOIndex, 		0x00025e55, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndex,			0x00025e56, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndexW,			0x00025ed7, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndexes,			0x00025e58, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndexesW,		0x00025e59, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndexFields,		0x00025e5a, 0, 0);
DEFINE_OLEGUID(IID_IDAOIndexFieldsW,	0x00025e5b, 0, 0);

// Group
DEFINE_OLEGUID(CLSID_CDAOGroup, 		0x00025e5f, 0, 0);
DEFINE_OLEGUID(IID_IDAOGroup,			0x00025e60, 0, 0);
DEFINE_OLEGUID(IID_IDAOGroupW,			0x00025e61, 0, 0);
DEFINE_OLEGUID(IID_IDAOGroups,			0x00025e62, 0, 0);
DEFINE_OLEGUID(IID_IDAOGroupsW,			0x00025e63, 0, 0);

// User
DEFINE_OLEGUID(CLSID_CDAOUser,			0x00025e68, 0, 0);
DEFINE_OLEGUID(IID_IDAOUser,			0x00025e69, 0, 0);
DEFINE_OLEGUID(IID_IDAOUserW,			0x00025e6a, 0, 0);
DEFINE_OLEGUID(IID_IDAOUsers,			0x00025e6b, 0, 0);
DEFINE_OLEGUID(IID_IDAOUsersW,			0x00025e6c, 0, 0);

// Database
DEFINE_OLEGUID(IID_IDAODatabase,		0x00025e71, 0, 0);
DEFINE_OLEGUID(IID_IDAODatabaseW,		0x00025e72, 0, 0);
DEFINE_OLEGUID(IID_IDAODatabases,		0x00025e73, 0, 0);
DEFINE_OLEGUID(IID_IDAODatabasesW,		0x00025e74, 0, 0);

// QueryDef
DEFINE_OLEGUID(CLSID_CDAOQueryDef,		0x00025e7a, 0, 0);
DEFINE_OLEGUID(IID_IDAOQueryDef,		0x00025e7b, 0, 0);
DEFINE_OLEGUID(IID_IDAOQueryDefW,		0x00025e7c, 0, 0);
DEFINE_OLEGUID(IID_IDAOQueryDefs,		0x00025e7d, 0, 0);
DEFINE_OLEGUID(IID_IDAOQueryDefsW,		0x00025e7e, 0, 0);

// Parameter
DEFINE_OLEGUID(IID_IDAOParameter,		0x00025e83, 0, 0);
DEFINE_OLEGUID(IID_IDAOParameterW,		0x00025e84, 0, 0);
DEFINE_OLEGUID(IID_IDAOParameters,		0x00025e85, 0, 0);
DEFINE_OLEGUID(IID_IDAOParametersW,		0x00025e86, 0, 0);

// Relation
DEFINE_OLEGUID(CLSID_CDAORelation,		0x00025e8b, 0, 0);
DEFINE_OLEGUID(IID_IDAORelation,		0x00025e8c, 0, 0);
DEFINE_OLEGUID(IID_IDAORelationW,		0x00025e8d, 0, 0);
DEFINE_OLEGUID(IID_IDAORelations,		0x00025e8e, 0, 0);
DEFINE_OLEGUID(IID_IDAORelationsW,		0x00025e8f, 0, 0);

// Container
DEFINE_OLEGUID(IID_IDAOContainer,		0x00025e94, 0, 0);
DEFINE_OLEGUID(IID_IDAOContainerW,		0x00025e95, 0, 0);
DEFINE_OLEGUID(IID_IDAOContainers,		0x00025e96, 0, 0);
DEFINE_OLEGUID(IID_IDAOContainersW,		0x00025e97, 0, 0);

// Document
DEFINE_OLEGUID(IID_IDAODocument,		0x00025e9c, 0, 0);
DEFINE_OLEGUID(IID_IDAODocumentW,		0x00025e9d, 0, 0);
DEFINE_OLEGUID(IID_IDAODocuments,		0x00025e9e, 0, 0);
DEFINE_OLEGUID(IID_IDAODocumentsW,		0x00025e9f, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\winsnmp.h ===
/* WinSNMP.h */
/* Copyright (C) 1993-1999 Microsoft Corporation */
/* v1.0 - Sep 13, 1993 */
/* v1.1 - Jun 12, 1994 */
/* v2.0 - Nov  1, 1997 */
/*      - Nov 17, 1997: inc limits.h, tests for ULONG/UINT_MAX */
/*      - Mar 23, 1998: fixed typo in "lpClientData" */

/* Questions/comments to Bob Natale, bnatale@acecomm.com */

#ifndef _INC_WINSNMP     /* Include WinSNMP declarations */
#define  _INC_WINSNMP    /* Just once! */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WINDOWS     /* Include Windows declarations, if not already done */
#include <windows.h>
#define _INC_WINDOWS     /* Just once! */
#endif                   /* _INC_WINDOWS */

#include <limits.h>

#ifdef __cplusplus
extern "C" {
#endif

/* WinSNMP API Type Definitions  */
typedef  HANDLE        HSNMP_SESSION,      FAR *LPHSNMP_SESSION;
typedef  HANDLE        HSNMP_ENTITY,       FAR *LPHSNMP_ENTITY;
typedef  HANDLE        HSNMP_CONTEXT,      FAR *LPHSNMP_CONTEXT;
typedef  HANDLE        HSNMP_PDU,          FAR *LPHSNMP_PDU;
typedef  HANDLE        HSNMP_VBL,          FAR *LPHSNMP_VBL;
typedef unsigned char    smiBYTE,          FAR *smiLPBYTE;
/* SNMP-related types */
#if ULONG_MAX == 4294967295U
typedef signed long      smiINT,           FAR *smiLPINT;
typedef smiINT           smiINT32,         FAR *smiLPINT32;
typedef unsigned long    smiUINT32,        FAR *smiLPUINT32;
#elif UINT_MAX == 4294967295U
typedef int              smiINT,           FAR *smiLPINT;
typedef smiINT           smiINT32,         FAR *smiLPINT32;
typedef unsigned int     smiUINT32,        FAR *smiLPUINT32;
#else
#error can not define smiINT and smiUINT
#endif
typedef struct {
     smiUINT32 len;
     smiLPBYTE ptr;}     smiOCTETS,        FAR *smiLPOCTETS;
typedef const smiOCTETS                    FAR *smiLPCOCTETS;
typedef smiOCTETS        smiBITS,          FAR *smiLPBITS;
typedef struct {
     smiUINT32   len;
     smiLPUINT32 ptr;}   smiOID,           FAR *smiLPOID;
typedef const smiOID                       FAR *smiLPCOID;
typedef smiOCTETS        smiIPADDR,        FAR *smiLPIPADDR;
typedef smiUINT32        smiCNTR32,        FAR *smiLPCNTR32;
typedef smiUINT32        smiGAUGE32,       FAR *smiLPGAUGE32;
typedef smiUINT32        smiTIMETICKS,     FAR *smiLPTIMETICKS;
typedef smiOCTETS        smiOPAQUE,        FAR *smiLPOPAQUE;
typedef smiOCTETS        smiNSAPADDR,      FAR *smiLPNSAPADDR;
typedef struct {
     smiUINT32 hipart;
     smiUINT32 lopart;}  smiCNTR64,        FAR *smiLPCNTR64;
/* ASN/BER Base Types */
/* (used in forming SYNTAXes and certain SNMP types/values) */
#define ASN_UNIVERSAL         (0x00)
#define ASN_APPLICATION       (0x40)
#define ASN_CONTEXT           (0x80)
#define ASN_PRIVATE           (0xC0)
#define ASN_PRIMITIVE         (0x00)
#define ASN_CONSTRUCTOR       (0x20)

/* SNMP ObjectSyntax Values */
#define SNMP_SYNTAX_SEQUENCE  (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10)
/* These values are used in the "syntax" member of the smiVALUE structure which follows */
#define SNMP_SYNTAX_INT       (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02)
#define SNMP_SYNTAX_BITS      (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03)
#define SNMP_SYNTAX_OCTETS    (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04)
#define SNMP_SYNTAX_NULL      (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05)
#define SNMP_SYNTAX_OID       (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06)
#define SNMP_SYNTAX_INT32     SNMP_SYNTAX_INT
#define SNMP_SYNTAX_IPADDR    (ASN_APPLICATION | ASN_PRIMITIVE | 0x00)
#define SNMP_SYNTAX_CNTR32    (ASN_APPLICATION | ASN_PRIMITIVE | 0x01)
#define SNMP_SYNTAX_GAUGE32   (ASN_APPLICATION | ASN_PRIMITIVE | 0x02)
#define SNMP_SYNTAX_TIMETICKS (ASN_APPLICATION | ASN_PRIMITIVE | 0x03)
#define SNMP_SYNTAX_OPAQUE    (ASN_APPLICATION | ASN_PRIMITIVE | 0x04)
#define SNMP_SYNTAX_NSAPADDR  (ASN_APPLICATION | ASN_PRIMITIVE | 0x05)
#define SNMP_SYNTAX_CNTR64    (ASN_APPLICATION | ASN_PRIMITIVE | 0x06)
#define SNMP_SYNTAX_UINT32    (ASN_APPLICATION | ASN_PRIMITIVE | 0x07)
/* Exception conditions in response PDUs for SNMPv2 */
#define SNMP_SYNTAX_NOSUCHOBJECT   (ASN_CONTEXT | ASN_PRIMITIVE | 0x00)
#define SNMP_SYNTAX_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x01)
#define SNMP_SYNTAX_ENDOFMIBVIEW   (ASN_CONTEXT | ASN_PRIMITIVE | 0x02)

typedef struct {              /* smiVALUE portion of VarBind */
     smiUINT32 syntax;        /* Insert SNMP_SYNTAX_<type> */
     union {
     smiINT    sNumber;       /* SNMP_SYNTAX_INT
                                 SNMP_SYNTAX_INT32 */
     smiUINT32 uNumber;       /* SNMP_SYNTAX_UINT32
                                 SNMP_SYNTAX_CNTR32
                                 SNMP_SYNTAX_GAUGE32
                                 SNMP_SYNTAX_TIMETICKS */
     smiCNTR64 hNumber;       /* SNMP_SYNTAX_CNTR64 */
     smiOCTETS string;        /* SNMP_SYNTAX_OCTETS
                                 SNMP_SYNTAX_BITS
                                 SNMP_SYNTAX_OPAQUE
                                 SNMP_SYNTAX_IPADDR
                                 SNMP_SYNTAX_NSAPADDR */
     smiOID    oid;           /* SNMP_SYNTAX_OID */
     smiBYTE   empty;         /* SNMP_SYNTAX_NULL
                                 SNMP_SYNTAX_NOSUCHOBJECT
                                 SNMP_SYNTAX_NOSUCHINSTANCE
                                 SNMP_SYNTAX_ENDOFMIBVIEW */
         }     value;         /* union */
     }         smiVALUE,      FAR *smiLPVALUE;
typedef const  smiVALUE       FAR *smiLPCVALUE;

/* SNMP Limits   */
#define MAXOBJIDSIZE     128  /* Max number of components in an OID */
#define MAXOBJIDSTRSIZE  1408 /* Max len of decoded MAXOBJIDSIZE OID */

/* PDU Type Values */
#define SNMP_PDU_GET          (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
#define SNMP_PDU_GETNEXT      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
#define SNMP_PDU_RESPONSE     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
#define SNMP_PDU_SET          (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
/* SNMP_PDU_V1TRAP is obsolete in SNMPv2 */
#define SNMP_PDU_V1TRAP       (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
#define SNMP_PDU_GETBULK      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
#define SNMP_PDU_INFORM       (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
#define SNMP_PDU_TRAP         (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)

/* SNMPv1 Trap Values */
/* (These values might be superfluous wrt WinSNMP applications) */
#define SNMP_TRAP_COLDSTART             0
#define SNMP_TRAP_WARMSTART             1
#define SNMP_TRAP_LINKDOWN              2
#define SNMP_TRAP_LINKUP                3
#define SNMP_TRAP_AUTHFAIL              4
#define SNMP_TRAP_EGPNEIGHBORLOSS       5
#define SNMP_TRAP_ENTERPRISESPECIFIC    6

/* SNMP Error Codes Returned in Error_status Field of PDU */
/* (these are NOT WinSNMP API Error Codes */
/* Error Codes Common to SNMPv1 and SNMPv2 */
#define SNMP_ERROR_NOERROR              0
#define SNMP_ERROR_TOOBIG               1
#define SNMP_ERROR_NOSUCHNAME           2
#define SNMP_ERROR_BADVALUE             3
#define SNMP_ERROR_READONLY             4
#define SNMP_ERROR_GENERR               5
/* Error Codes Added for SNMPv2 */
#define SNMP_ERROR_NOACCESS             6
#define SNMP_ERROR_WRONGTYPE            7
#define SNMP_ERROR_WRONGLENGTH          8
#define SNMP_ERROR_WRONGENCODING        9
#define SNMP_ERROR_WRONGVALUE           10
#define SNMP_ERROR_NOCREATION           11
#define SNMP_ERROR_INCONSISTENTVALUE    12
#define SNMP_ERROR_RESOURCEUNAVAILABLE  13
#define SNMP_ERROR_COMMITFAILED         14
#define SNMP_ERROR_UNDOFAILED           15
#define SNMP_ERROR_AUTHORIZATIONERROR   16
#define SNMP_ERROR_NOTWRITABLE          17
#define SNMP_ERROR_INCONSISTENTNAME     18

/* WinSNMP API Values */
/* Values used to indicate entity/context translation modes */
#define SNMPAPI_TRANSLATED         0
#define SNMPAPI_UNTRANSLATED_V1    1
#define SNMPAPI_UNTRANSLATED_V2    2

/* Values used to indicate "SNMP level" supported by the implementation */
#define SNMPAPI_NO_SUPPORT         0
#define SNMPAPI_V1_SUPPORT         1
#define SNMPAPI_V2_SUPPORT         2
#define SNMPAPI_M2M_SUPPORT        3

/* Values used to indicate retransmit mode in the implementation */
#define SNMPAPI_OFF                0    /* Refuse support */
#define SNMPAPI_ON                 1    /* Request support */

/* WinSNMP API Function Return Codes */
typedef smiUINT32    SNMPAPI_STATUS;    /* Used for function ret values */
#define SNMPAPI_FAILURE            0    /* Generic error code */
#define SNMPAPI_SUCCESS            1    /* Generic success code */
/* WinSNMP API Error Codes (for SnmpGetLastError) */
/* (NOT SNMP Response-PDU error_status codes) */
#define SNMPAPI_ALLOC_ERROR        2    /* Error allocating memory */
#define SNMPAPI_CONTEXT_INVALID    3    /* Invalid context parameter */
#define SNMPAPI_CONTEXT_UNKNOWN    4    /* Unknown context parameter */
#define SNMPAPI_ENTITY_INVALID     5    /* Invalid entity parameter */
#define SNMPAPI_ENTITY_UNKNOWN     6    /* Unknown entity parameter */
#define SNMPAPI_INDEX_INVALID      7    /* Invalid VBL index parameter */
#define SNMPAPI_NOOP               8    /* No operation performed */
#define SNMPAPI_OID_INVALID        9    /* Invalid OID parameter */
#define SNMPAPI_OPERATION_INVALID  10   /* Invalid/unsupported operation */
#define SNMPAPI_OUTPUT_TRUNCATED   11   /* Insufficient output buf len */
#define SNMPAPI_PDU_INVALID        12   /* Invalid PDU parameter */
#define SNMPAPI_SESSION_INVALID    13   /* Invalid session parameter */
#define SNMPAPI_SYNTAX_INVALID     14   /* Invalid syntax in smiVALUE */
#define SNMPAPI_VBL_INVALID        15   /* Invalid VBL parameter */
#define SNMPAPI_MODE_INVALID       16   /* Invalid mode parameter */
#define SNMPAPI_SIZE_INVALID       17   /* Invalid size/length parameter */
#define SNMPAPI_NOT_INITIALIZED    18   /* SnmpStartup failed/not called */
#define SNMPAPI_MESSAGE_INVALID    19   /* Invalid SNMP message format */
#define SNMPAPI_HWND_INVALID       20   /* Invalid Window handle */
#define SNMPAPI_OTHER_ERROR        99   /* For internal/undefined errors */
/* Generic Transport Layer (TL) Errors */
#define SNMPAPI_TL_NOT_INITIALIZED 100  /* TL not initialized */
#define SNMPAPI_TL_NOT_SUPPORTED   101  /* TL does not support protocol */
#define SNMPAPI_TL_NOT_AVAILABLE   102  /* Network subsystem has failed */
#define SNMPAPI_TL_RESOURCE_ERROR  103  /* TL resource error */
#define SNMPAPI_TL_UNDELIVERABLE   104  /* Destination unreachable */
#define SNMPAPI_TL_SRC_INVALID     105  /* Source endpoint invalid */
#define SNMPAPI_TL_INVALID_PARAM   106  /* Input parameter invalid */
#define SNMPAPI_TL_IN_USE          107  /* Source endpoint in use */
#define SNMPAPI_TL_TIMEOUT         108  /* No response before timeout */
#define SNMPAPI_TL_PDU_TOO_BIG     109  /* PDU too big for send/receive */
#define SNMPAPI_TL_OTHER           199  /* Undefined TL error */

/* WinSNMP API Function Prototypes */

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#define SNMPAPI_CALL     WINAPI         /* FAR PASCAL calling conventions */

/* v2.0: Structure for SnmpGetVendorInfo() output */
#define MAXVENDORINFO 32
typedef struct
	{
	char vendorName[MAXVENDORINFO*2];
	char vendorContact[MAXVENDORINFO*2];
	char vendorVersionId[MAXVENDORINFO];
	char vendorVersionDate[MAXVENDORINFO];
	smiUINT32 vendorEnterprise;
	} smiVENDORINFO, FAR *smiLPVENDORINFO;

/* v2.0: Callback format for SnmpCreateSession() fCallback parameter */
typedef SNMPAPI_STATUS (CALLBACK *SNMPAPI_CALLBACK)
                        (IN HSNMP_SESSION hSession,
                         IN HWND hWnd,
                         IN UINT wMsg,
                         IN WPARAM wParam,
                         IN LPARAM lParam,
                         IN LPVOID lpClientData);

/* Local Database Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetTranslateMode
                              (OUT smiLPUINT32 nTranslateMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetTranslateMode
                              (IN smiUINT32 nTranslateMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetRetransmitMode
                              (OUT smiLPUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetRetransmitMode
                              (IN smiUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetTimeout
                              (IN HSNMP_ENTITY hEntity,
                              OUT smiLPTIMETICKS nPolicyTimeout,
                              OUT smiLPTIMETICKS nActualTimeout);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetTimeout
                              (IN HSNMP_ENTITY hEntity,
                              IN smiTIMETICKS nPolicyTimeout);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetRetry
                              (IN HSNMP_ENTITY hEntity,
                              OUT smiLPUINT32 nPolicyRetry,
                              OUT smiLPUINT32 nActualRetry);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetRetry
                              (IN HSNMP_ENTITY hEntity,
                              IN smiUINT32 nPolicyRetry);

/* Following Local Database Functions added in v2.0 */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetVendorInfo
                              (OUT smiLPVENDORINFO vendorInfo);

/* Communications Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpStartup
                              (OUT smiLPUINT32 nMajorVersion,
                              OUT smiLPUINT32 nMinorVersion,
                              OUT smiLPUINT32 nLevel,
                              OUT smiLPUINT32 nTranslateMode,
                              OUT smiLPUINT32 nRetransmitMode);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCleanup
                              (void);

HSNMP_SESSION  SNMPAPI_CALL   SnmpOpen
                              (IN HWND hWnd,
                              IN UINT wMsg);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpClose
                              (IN HSNMP_SESSION session);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSendMsg
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN HSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpRecvMsg
                              (IN HSNMP_SESSION session,
                              OUT LPHSNMP_ENTITY srcEntity,
                              OUT LPHSNMP_ENTITY dstEntity,
                              OUT LPHSNMP_CONTEXT  context,
                              OUT LPHSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpRegister
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN smiLPCOID notification,
                              IN smiUINT32 state);

/* Following Communications Functions added in v2.0 */
HSNMP_SESSION  SNMPAPI_CALL   SnmpCreateSession
                              (IN HWND hWnd,
                              IN UINT wMsg,
                              IN SNMPAPI_CALLBACK fCallBack,
                              IN LPVOID lpClientData);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpListen
                              (IN HSNMP_ENTITY hEntity,
                              IN SNMPAPI_STATUS lStatus);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCancelMsg
                              (IN HSNMP_SESSION session,
                              IN smiINT32 reqId);

/* Entity/Context Functions */
HSNMP_ENTITY   SNMPAPI_CALL   SnmpStrToEntity
                              (IN HSNMP_SESSION session,
                              IN LPCSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpEntityToStr
                              (IN HSNMP_ENTITY entity,
                              IN smiUINT32 size,
                              OUT LPSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeEntity
                              (IN HSNMP_ENTITY entity);

HSNMP_CONTEXT  SNMPAPI_CALL   SnmpStrToContext
                              (IN HSNMP_SESSION session,
                              IN smiLPCOCTETS string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpContextToStr
                              (IN HSNMP_CONTEXT context,
                              OUT smiLPOCTETS string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeContext
                              (IN HSNMP_CONTEXT context);

/* Following Entity/Context Functions added in v2.0 */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetPort
                              (IN HSNMP_ENTITY hEntity,
                              IN UINT nPort);

/* PDU Functions */
HSNMP_PDU      SNMPAPI_CALL   SnmpCreatePdu
                              (IN HSNMP_SESSION session,
                              IN smiINT PDU_type,
                              IN smiINT32 request_id,
                              IN smiINT error_status,
                              IN smiINT error_index,
                              IN HSNMP_VBL varbindlist);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetPduData
                              (IN HSNMP_PDU PDU,
                              OUT smiLPINT PDU_type,
                              OUT smiLPINT32 request_id,
                              OUT smiLPINT error_status,
                              OUT smiLPINT error_index,
                              OUT LPHSNMP_VBL varbindlist);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetPduData
                              (IN HSNMP_PDU PDU,
                              IN const smiINT FAR *PDU_type,
                              IN const smiINT32 FAR *request_id,
                              IN const smiINT FAR *non_repeaters,
                              IN const smiINT FAR *max_repetitions,
                              IN const HSNMP_VBL FAR *varbindlist);

HSNMP_PDU      SNMPAPI_CALL   SnmpDuplicatePdu
                              (IN HSNMP_SESSION session,
                              IN HSNMP_PDU PDU);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreePdu
                              (IN HSNMP_PDU PDU);

/* Variable-Binding Functions */
HSNMP_VBL      SNMPAPI_CALL   SnmpCreateVbl
                              (IN HSNMP_SESSION session,
                              IN smiLPCOID name,
                              IN smiLPCVALUE value);

HSNMP_VBL      SNMPAPI_CALL   SnmpDuplicateVbl
                              (IN HSNMP_SESSION session,
                              IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeVbl
                              (IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpCountVbl
                              (IN HSNMP_VBL vbl);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index,
                              OUT smiLPOID name,
                              OUT smiLPVALUE value);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpSetVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index,
                              IN smiLPCOID name,
                              IN smiLPCVALUE value);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpDeleteVb
                              (IN HSNMP_VBL vbl,
                              IN smiUINT32 index);

/* Utility Functions */
SNMPAPI_STATUS SNMPAPI_CALL   SnmpGetLastError
                              (IN HSNMP_SESSION session);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpStrToOid
                              (IN LPCSTR string,
                              OUT smiLPOID dstOID);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidToStr
                              (IN smiLPCOID srcOID,
                              IN smiUINT32 size,
                              OUT LPSTR string);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidCopy
                              (IN smiLPCOID srcOID,
                              OUT smiLPOID dstOID);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpOidCompare
                              (IN smiLPCOID xOID,
                              IN smiLPCOID yOID,
                              IN smiUINT32 maxlen,
                              OUT smiLPINT result);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpEncodeMsg
                              (IN HSNMP_SESSION session,
                              IN HSNMP_ENTITY srcEntity,
                              IN HSNMP_ENTITY dstEntity,
                              IN HSNMP_CONTEXT context,
                              IN HSNMP_PDU pdu,
                              OUT smiLPOCTETS msgBufDesc);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpDecodeMsg
                              (IN HSNMP_SESSION session,
                              OUT LPHSNMP_ENTITY srcEntity,
                              OUT LPHSNMP_ENTITY dstEntity,
                              OUT LPHSNMP_CONTEXT context,
                              OUT LPHSNMP_PDU pdu,
                              IN smiLPCOCTETS msgBufDesc);

SNMPAPI_STATUS SNMPAPI_CALL   SnmpFreeDescriptor
                              (IN smiUINT32 syntax,
                              IN smiLPOPAQUE descriptor);

#ifdef __cplusplus
}
#endif

#endif         /* _INC_WINSNMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\daogetrw.h ===
/************************************************************************
**  D A O G E T R W . H                                                 *
**                                                                      *
**  GetRows interface                                                   *
**                                                                      *
**  Warning: This file is copied from cdaost.h. Changes must be made    *
**           in both files                                              *
**                                                                      *
**                                                                      *
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                          *
**         All Rights Reserved                                          *
************************************************************************/

#if !defined (_DAOGETRW_H_)
#define _DAOGETRW_H_

/*
	Enumerations
*/
typedef enum
	{
	DAOCOLKIND_IND = 0,
	DAOCOLKIND_STR,
	DAOCOLKIND_WSTR
	} DAOCOLKIND;

typedef enum
	{
	DAO_I2 = 0,
	DAO_I4,
	DAO_R4,
	DAO_R8,
	DAO_CURRENCY,
	DAO_DATE,
	DAO_BOOL,
	DAO_BSTR,
	DAO_LPSTR,
	DAO_LPWSTR,
	DAO_BLOB,
	DAO_BYTES,
	DAO_CHAR,
	DAO_WCHAR,
	DAO_ANYVARIANT,
	DAO_BOOKMARK,
	DAO_BYTE,
	DAO_GUID,
	DAO_DATATYPEMAX
	} DAODATATYPE;

/*
	Macros
*/
#define DAO_NOINDICATOR 0xffffffff
#define DAO_NULL        0xffffffff
#define DAO_CANTCOERCE  0xfffffffc
#define DAO_NOMAXLENGTH 0x00000000

#define DAOROWFETCH_CALLEEALLOCATES     0x00000001
#define DAOROWFETCH_DONTADVANCE         0x00000002
#define DAOROWFETCH_FORCEREFRESH        0x00000004
#define DAOROWFETCH_BINDABSOLUTE        0x00000008
#define DAOROWFETCH_ODBCNEXT			0x00000010

#define DAOBINDING_DIRECT               0x00000001
#define DAOBINDING_VARIANT              0x00000002
#define DAOBINDING_CALLBACK             0x00000004

/*
	Structures
*/
typedef struct
	{
	DWORD           dwKind;
	union
		{
		LONG        ind;
		LPCSTR      lpstr;
		LPCWSTR		lpwstr;
		};
	} DAOCOLUMNID;
typedef DAOCOLUMNID *LPDAOCOLUMNID;

// Callback for binding
EXTERN_C typedef HRESULT (STDAPICALLTYPE *LPDAOBINDFUNC)(ULONG cb, DWORD dwUser, LPVOID *ppData);
#define DAOBINDINGFUNC(f)   STDAPI f (ULONG cb, DWORD dwUser, LPVOID *ppData)

typedef struct
	{
	DAOCOLUMNID     columnID;
	ULONG           cbDataOffset;
	ULONG           cbMaxLen;
	ULONG           cbInfoOffset;
	DWORD           dwBinding;
	DWORD           dwDataType;
	DWORD           dwUser;
	} DAOCOLUMNBINDING;
typedef DAOCOLUMNBINDING *LPDAOCOLUMNBINDING;

typedef struct
	{
	ULONG           cRowsRequested;
	DWORD           dwFlags;
	LPVOID          pData;
	LPVOID          pVarData;
	ULONG           cbVarData;
	ULONG           cRowsReturned;
	} DAOFETCHROWS;
typedef DAOFETCHROWS *LPDAOFETCHROWS;

/*
	New Errors

	**NOTE: OLE standard ids to be determined.
*/
#define S_BUFFERTOOSMALL    MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1000)
#define S_ENDOFCURSOR       MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1001)
#define S_SILENTCANCEL      MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1002)
#define S_RECORDDELETED     MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1003)

#define E_ROWTOOSHORT       MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1000)
#define E_BADBINDINFO       MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1001)
#define E_COLUMNUNAVAILABLE MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1002)


/*
	Interfaces
*/
#undef INTERFACE
#define INTERFACE ICDAORecordset
DECLARE_INTERFACE_(ICDAORecordset, IDispatch)
	{
	STDMETHOD(GetRows)          (THIS_ LONG cRowsToSkip, LONG cCol, LPDAOCOLUMNBINDING prgBndCol, ULONG cbRowLen, LPDAOFETCHROWS pFetchRows) PURE;
	STDMETHOD(SetNotify)		(THIS_ REFIID riid, BOOL fNotify);
	STDMETHOD(GetNotify)		(THIS_ REFIID riid, BOOL *fNotify);
	STDMETHOD(OnBeforeNotify)	(THIS_ REFIID riid, DWORD cat, DWORD rsn, VARIANT v1, VARIANT v2);
	STDMETHOD(OnAfterNotify)	(THIS_ REFIID riid, DWORD cat, DWORD rsn, VARIANT v1, VARIANT v2, HRESULT hr);
	STDMETHOD(PutLock)			(THIS_ BOOL f);
	STDMETHOD(GetLock)			(THIS_ BOOL *f);
	STDMETHOD(AddGetRowsErr)    (THIS_ HRESULT hr) PURE;
	};

//Get rows errors
#define errVtoFetchBuffTooSmall	-30028	//3640	The fetch buffer was too small for the amount of data you requested.
#define errVtoEOFDuringFetch	-30029	//3641	There are fewer records remaining in the recordset than you requested.
#define errVtoSilentCancel		-30030	//3642	A cancel was performed on the operation.
#define errVtoRecordDeleted		-30031	//3643	One of the records in the recordset was deleted by another process.
#define errVtoRowLenTooSmall	-30032	//3646	The specified row length is shorter than the sum of the column lengths.
#define errVtoBadBindInfo		-30033	//3645	One of the binding parameters is incorrect.
#define errVtoColumnMissing		-30034	//3647	A column requested is not being returned to the recordset.

#endif // _DAOGETRW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\ws2atm.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

	ws2atm.h

Abstract:

	Winsock 2 ATM Annex definitions.

Revision History:

Notes:

--*/

#ifndef _WS2ATM_H_
#define _WS2ATM_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#define ATMPROTO_AALUSER           0x00   /* User-defined AAL */
#define ATMPROTO_AAL1              0x01   /* AAL 1 */
#define ATMPROTO_AAL2              0x02   /* AAL 2 */
#define ATMPROTO_AAL34             0x03   /* AAL 3/4 */
#define ATMPROTO_AAL5              0x05   /* AAL 5 */

#define SAP_FIELD_ABSENT           0xFFFFFFFE
#define SAP_FIELD_ANY              0xFFFFFFFF
#define SAP_FIELD_ANY_AESA_SEL     0xFFFFFFFA
#define SAP_FIELD_ANY_AESA_REST    0xFFFFFFFB

/*
 *  values used for AddressType in struct ATM_ADDRESS
 */
#define ATM_E164               0x01   /* E.164 addressing scheme */
#define ATM_NSAP               0x02   /* NSAP-style ATM Endsystem Address scheme */
#define ATM_AESA               0x02   /* NSAP-style ATM Endsystem Address scheme */

#define ATM_ADDR_SIZE          20
typedef struct {
    DWORD AddressType;                /* E.164 or NSAP-style ATM Endsystem Address */
    DWORD NumofDigits;                /* number of digits; */
    UCHAR Addr[ATM_ADDR_SIZE];        /* IA5 digits for E164, BCD encoding for NSAP */
                                      /* format as defined in the ATM Forum UNI 3.1 */
} ATM_ADDRESS;

/*
 *  values used for Layer2Protocol in B-LLI
 */
#define BLLI_L2_ISO_1745           0x01   /* Basic mode ISO 1745                      */
#define BLLI_L2_Q921               0x02   /* CCITT Rec. Q.921                         */
#define BLLI_L2_X25L               0x06   /* CCITT Rec. X.25, link layer              */
#define BLLI_L2_X25M               0x07   /* CCITT Rec. X.25, multilink               */
#define BLLI_L2_ELAPB              0x08   /* Extended LAPB; for half duplex operation */
#define BLLI_L2_HDLC_ARM           0x09   /* HDLC ARM (ISO 4335)                      */
#define BLLI_L2_HDLC_NRM           0x0A   /* HDLC NRM (ISO 4335)                      */
#define BLLI_L2_HDLC_ABM           0x0B   /* HDLC ABM (ISO 4335)                      */
#define BLLI_L2_LLC                0x0C   /* LAN logical link control (ISO 8802/2)    */
#define BLLI_L2_X75                0x0D   /* CCITT Rec. X.75, single link procedure   */
#define BLLI_L2_Q922               0x0E   /* CCITT Rec. Q.922                         */
#define BLLI_L2_USER_SPECIFIED     0x10   /* User Specified                           */
#define BLLI_L2_ISO_7776           0x11   /* ISO 7776 DTE-DTE operation               */

/*
 *  values used for Layer3Protocol in B-LLI
 */
#define BLLI_L3_X25                0x06   /* CCITT Rec. X.25, packet layer            */
#define BLLI_L3_ISO_8208           0x07   /* ISO/IEC 8208 (X.25 packet layer for DTE  */
#define BLLI_L3_X223               0x08   /* X.223/ISO 8878                           */
#define BLLI_L3_SIO_8473           0x09   /* ISO/IEC 8473 (OSI connectionless)        */
#define BLLI_L3_T70                0x0A   /* CCITT Rec. T.70 min. network layer       */
#define BLLI_L3_ISO_TR9577         0x0B   /* ISO/IEC TR 9577 Network Layer Protocol ID*/
#define BLLI_L3_USER_SPECIFIED     0x10   /* User Specified                           */

/*
 *  values used for Layer3IPI in B-LLI
 */
#define BLLI_L3_IPI_SNAP           0x80   /* IEEE 802.1 SNAP identifier               */
#define BLLI_L3_IPI_IP             0xCC   /* Internet Protocol (IP) identifier        */

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI;

/*
 *  values used for the HighLayerInfoType field in ATM_BHLI
 */
#define BHLI_ISO                   0x00   /* ISO                                 */
#define BHLI_UserSpecific          0x01   /* User Specific                       */
#define BHLI_HighLayerProfile      0x02   /* High layer profile (only in UNI3.0) */
#define BHLI_VendorSpecificAppId   0x03   /* Vendor-Specific Application ID      */

typedef struct {
    DWORD HighLayerInfoType;          /* High Layer Information Type      */
    DWORD HighLayerInfoLength;        /* number of bytes in HighLayerInfo */
    UCHAR HighLayerInfo[8];           /* the value dependent on the       */
                                      /*   HighLayerInfoType field        */
} ATM_BHLI;

typedef struct sockaddr_atm {
    u_short satm_family;              /* address family should be AF_ATM  */
    ATM_ADDRESS satm_number;          /* ATM address                      */
    ATM_BLLI satm_blli;               /* B-LLI                            */
    ATM_BHLI satm_bhli;               /* B-HLI                            */
} sockaddr_atm, SOCKADDR_ATM, *PSOCKADDR_ATM, *LPSOCKADDR_ATM;

typedef enum {
    IE_AALParameters,
    IE_TrafficDescriptor,
    IE_BroadbandBearerCapability,
    IE_BHLI,
    IE_BLLI,
    IE_CalledPartyNumber,
    IE_CalledPartySubaddress,
    IE_CallingPartyNumber,
    IE_CallingPartySubaddress,
    IE_Cause,
    IE_QOSClass,
    IE_TransitNetworkSelection,
} Q2931_IE_TYPE;

typedef struct {
    Q2931_IE_TYPE IEType;
    ULONG         IELength;
    UCHAR         IE[1];
} Q2931_IE;

/*
 *  manifest constants for the AALType field in struct AAL_PARAMETERS_IE
 */
typedef enum {
    AALTYPE_5     = 5,   /* AAL 5 */
    AALTYPE_USER  = 16,  /* user-defined AAL */
} AAL_TYPE;

/*
 *  values used for the Mode field in struct AAL5_PARAMETERS
 */
#define AAL5_MODE_MESSAGE           0x01
#define AAL5_MODE_STREAMING         0x02

/*
 *  values used for the SSCSType field in struct AAL5_PARAMETERS
 */
#define AAL5_SSCS_NULL              0x00
#define AAL5_SSCS_SSCOP_ASSURED     0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED 0x02
#define AAL5_SSCS_FRAME_RELAY       0x04

typedef struct {
    ULONG ForwardMaxCPCSSDUSize;
    ULONG BackwardMaxCPCSSDUSize;
    UCHAR Mode;                        /* only available in UNI 3.0 */
    UCHAR SSCSType;
} AAL5_PARAMETERS;

typedef struct {
    ULONG UserDefined;
} AALUSER_PARAMETERS;

typedef struct {
    AAL_TYPE AALType;
    union {
        AAL5_PARAMETERS     AAL5Parameters;
        AALUSER_PARAMETERS  AALUserParameters;
    } AALSpecificParameters;
} AAL_PARAMETERS_IE;

typedef struct {
    ULONG PeakCellRate_CLP0;
    ULONG PeakCellRate_CLP01;
    ULONG SustainableCellRate_CLP0;
    ULONG SustainableCellRate_CLP01;
    ULONG MaxBurstSize_CLP0;
    ULONG MaxBurstSize_CLP01;
    BOOL  Tagging;
} ATM_TD;

typedef struct {
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL   BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE;

/*
 *  values used for the BearerClass field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define BCOB_A                   0x01   /* Bearer class A                      */
#define BCOB_C                   0x03   /* Bearer class C                      */
#define BCOB_X                   0x10   /* Bearer class X                      */

/*
 *  values used for the TrafficType field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TT_NOIND                 0x00   /* No indication of traffic type       */
#define TT_CBR                   0x04   /* Constant bit rate                   */
#define TT_VBR                   0x08   /* Variable bit rate                   */

/*
 *  values used for the TimingRequirements field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TR_NOIND                 0x00   /* No timing requirement indication    */
#define TR_END_TO_END            0x01   /* End-to-end timing required          */
#define TR_NO_END_TO_END         0x02   /* End-to-end timing not required      */

/*
 *  values used for the ClippingSusceptability field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define CLIP_NOT                 0x00   /* Not susceptible to clipping         */
#define CLIP_SUS                 0x20   /* Susceptible to clipping             */

/*
 *  values used for the UserPlaneConnectionConfig field in
 *  struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define UP_P2P                   0x00   /* Point-to-point connection           */
#define UP_P2MP                  0x01   /* Point-to-multipoint connection      */

typedef struct {
    UCHAR BearerClass;
    UCHAR TrafficType;
    UCHAR TimingRequirements;
    UCHAR ClippingSusceptability;
    UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef ATM_BHLI ATM_BHLI_IE;

/*
 *  values used for the Layer2Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L2_MODE_NORMAL         0x40
#define BLLI_L2_MODE_EXT            0x80

/*
 *  values used for the Layer3Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L3_MODE_NORMAL         0x40
#define BLLI_L3_MODE_EXT            0x80

/*
 *  values used for the Layer3DefaultPacketSize field in struct ATM_BLLI_IE
 */
#define BLLI_L3_PACKET_16           0x04
#define BLLI_L3_PACKET_32           0x05
#define BLLI_L3_PACKET_64           0x06
#define BLLI_L3_PACKET_128          0x07
#define BLLI_L3_PACKET_256          0x08
#define BLLI_L3_PACKET_512          0x09
#define BLLI_L3_PACKET_1024         0x0A
#define BLLI_L3_PACKET_2048         0x0B
#define BLLI_L3_PACKET_4096         0x0C

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    UCHAR Layer2Mode;
    UCHAR Layer2WindowSize;
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    UCHAR Layer3Mode;
    UCHAR Layer3DefaultPacketSize;
    UCHAR Layer3PacketWindowSize;
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Presentation_Indication field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define PI_ALLOWED                  0x00
#define PI_RESTRICTED               0x40
#define PI_NUMBER_NOT_AVAILABLE     0x80

/*
 *  values used for the Screening_Indicator field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define SI_USER_NOT_SCREENED        0x00
#define SI_USER_PASSED              0x01
#define SI_USER_FAILED              0x02
#define SI_NETWORK                  0x03

typedef struct {
    ATM_ADDRESS ATM_Number;
    UCHAR       Presentation_Indication;
    UCHAR       Screening_Indicator;
} ATM_CALLING_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Location field in struct ATM_CAUSE_IE
 */
#define CAUSE_LOC_USER                      0x00
#define CAUSE_LOC_PRIVATE_LOCAL             0x01
#define CAUSE_LOC_PUBLIC_LOCAL              0x02
#define CAUSE_LOC_TRANSIT_NETWORK           0x03
#define CAUSE_LOC_PUBLIC_REMOTE             0x04
#define CAUSE_LOC_PRIVATE_REMOTE            0x05
#define CAUSE_LOC_INTERNATIONAL_NETWORK     0x07
#define CAUSE_LOC_BEYOND_INTERWORKING       0x0A

/*
 *  values used for the Cause field in struct ATM_CAUSE_IE
 */
#define CAUSE_UNALLOCATED_NUMBER                0x01
#define CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK       0x02
#define CAUSE_NO_ROUTE_TO_DESTINATION           0x03
#define CAUSE_VPI_VCI_UNACCEPTABLE              0x0A
#define CAUSE_NORMAL_CALL_CLEARING              0x10
#define CAUSE_USER_BUSY                         0x11
#define CAUSE_NO_USER_RESPONDING                0x12
#define CAUSE_CALL_REJECTED                     0x15
#define CAUSE_NUMBER_CHANGED                    0x16
#define CAUSE_USER_REJECTS_CLIR                 0x17
#define CAUSE_DESTINATION_OUT_OF_ORDER          0x1B
#define CAUSE_INVALID_NUMBER_FORMAT             0x1C
#define CAUSE_STATUS_ENQUIRY_RESPONSE           0x1E
#define CAUSE_NORMAL_UNSPECIFIED                0x1F
#define CAUSE_VPI_VCI_UNAVAILABLE               0x23
#define CAUSE_NETWORK_OUT_OF_ORDER              0x26
#define CAUSE_TEMPORARY_FAILURE                 0x29
#define CAUSE_ACCESS_INFORMAION_DISCARDED       0x2B
#define CAUSE_NO_VPI_VCI_AVAILABLE              0x2D
#define CAUSE_RESOURCE_UNAVAILABLE              0x2F
#define CAUSE_QOS_UNAVAILABLE                   0x31
#define CAUSE_USER_CELL_RATE_UNAVAILABLE        0x33
#define CAUSE_BEARER_CAPABILITY_UNAUTHORIZED    0x39
#define CAUSE_BEARER_CAPABILITY_UNAVAILABLE     0x3A
#define CAUSE_OPTION_UNAVAILABLE                0x3F
#define CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED   0x41
#define CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS    0x49
#define CAUSE_INVALID_CALL_REFERENCE            0x51
#define CAUSE_CHANNEL_NONEXISTENT               0x52
#define CAUSE_INCOMPATIBLE_DESTINATION          0x58
#define CAUSE_INVALID_ENDPOINT_REFERENCE        0x59
#define CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define CAUSE_TOO_MANY_PENDING_ADD_PARTY        0x5C
#define CAUSE_AAL_PARAMETERS_UNSUPPORTED        0x5D
#define CAUSE_MANDATORY_IE_MISSING              0x60
#define CAUSE_UNIMPLEMENTED_MESSAGE_TYPE        0x61
#define CAUSE_UNIMPLEMENTED_IE                  0x63
#define CAUSE_INVALID_IE_CONTENTS               0x64
#define CAUSE_INVALID_STATE_FOR_MESSAGE         0x65
#define CAUSE_RECOVERY_ON_TIMEOUT               0x66
#define CAUSE_INCORRECT_MESSAGE_LENGTH          0x68
#define CAUSE_PROTOCOL_ERROR                    0x6F

/*
 *  values used for the Condition portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_COND_UNKNOWN                  0x00
#define CAUSE_COND_PERMANENT                0x01
#define CAUSE_COND_TRANSIENT                0x02

/*
 *  values used for the Rejection Reason portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_REASON_USER                   0x00
#define CAUSE_REASON_IE_MISSING             0x04
#define CAUSE_REASON_IE_INSUFFICIENT        0x08

/*
 *  values used for the P-U flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_PU_PROVIDER                   0x00
#define CAUSE_PU_USER                       0x08

/*
 *  values used for the N-A flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_NA_NORMAL                     0x00
#define CAUSE_NA_ABNORMAL                   0x04

typedef struct {
    UCHAR Location;
    UCHAR Cause;
    UCHAR DiagnosticsLength;
    UCHAR Diagnostics[4];
} ATM_CAUSE_IE;

/*
 *  values used for the QOSClassForward and QOSClassBackward
 *  field in struct ATM_QOS_CLASS_IE
 */
#define QOS_CLASS0                  0x00
#define QOS_CLASS1                  0x01
#define QOS_CLASS2                  0x02
#define QOS_CLASS3                  0x03
#define QOS_CLASS4                  0x04

typedef struct {
    UCHAR QOSClassForward;
    UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE;

/*
 *  values used for the TypeOfNetworkId field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_TYPE_NATIONAL           0x40

/*
 *  values used for the NetworkIdPlan field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_PLAN_CARRIER_ID_CODE    0x01

typedef struct {
    UCHAR TypeOfNetworkId;
    UCHAR NetworkIdPlan;
    UCHAR NetworkIdLength;
    UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE;

/*
 *  ATM specific Ioctl codes
 */
#define SIO_GET_NUMBER_OF_ATM_DEVICES   0x50160001
#define SIO_GET_ATM_ADDRESS             0xd0160002
#define SIO_ASSOCIATE_PVC               0x90160003
#define SIO_GET_ATM_CONNECTION_ID       0x50160004

/* ATM Connection Identifier */

typedef struct {
    DWORD  DeviceNumber;
    DWORD  VPI;
    DWORD  VCI;
} ATM_CONNECTION_ID;

/*
 * Input buffer format for SIO_ASSOCIATE_PVC
 */

typedef struct {
   ATM_CONNECTION_ID   PvcConnectionId;
   QOS                 PvcQos;
} ATM_PVC_PARAMS;

#include <poppack.h>

#endif   /* _WS2ATM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wownt32.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt32.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 32-bit thunking code.

--*/

#ifndef _WOWNT32_
#define _WOWNT32_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// WOWGetVDMPointer will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer.  If fProtectedMode
// is TRUE, the function treats the upper 16 bits as a selector
// in the local descriptor table.  If fProtectedMode is FALSE,
// the upper 16 bits are treated as a real-mode segment value.
// In either case the lower 16 bits are treated as the offset.
//
// The return value is NULL if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause NULL to be returned when the
// limit is exceeded by the supplied offset.
//

LPVOID WINAPI WOWGetVDMPointer(DWORD vp, DWORD dwBytes,
                               BOOL fProtectedMode);

//
// The following two functions are here for compatibility with
// Windows 95.  On Win95, the global heap can be rearranged,
// invalidating flat pointers returned by WOWGetVDMPointer, while
// a thunk is executing.  On Windows NT, the 16-bit VDM is completely
// halted while a thunk executes, so the only way the heap will
// be rearranged is if a callback is made to Win16 code.
//
// The Win95 versions of these functions call GlobalFix to
// lock down a segment's flat address, and GlobalUnfix to
// release the segment.
//
// The Windows NT implementations of these functions do *not*
// call GlobalFix/GlobalUnfix on the segment, because there
// will not be any heap motion unless a callback occurs.
// If your thunk does callback to the 16-bit side, be sure
// to discard flat pointers and call WOWGetVDMPointer again
// to be sure the flat address is correct.
//

LPVOID WINAPI WOWGetVDMPointerFix(DWORD vp, DWORD dwBytes,
                                  BOOL fProtectedMode);
VOID WINAPI WOWGetVDMPointerUnfix(DWORD vp);


//
// Win16 memory management.
//
// These functions can be used to manage memory in the Win16
// heap.  The following four functions are identical to their
// Win16 counterparts, except that they are called from Win32
// code.
//

WORD  WINAPI WOWGlobalAlloc16(WORD wFlags, DWORD cb);
WORD  WINAPI WOWGlobalFree16(WORD hMem);
DWORD WINAPI WOWGlobalLock16(WORD hMem);
BOOL  WINAPI WOWGlobalUnlock16(WORD hMem);

//
// The following three functions combine two common operations in
// one switch to 16-bit mode.
//

DWORD WINAPI WOWGlobalAllocLock16(WORD wFlags, DWORD cb, WORD *phMem);
WORD  WINAPI WOWGlobalUnlockFree16(DWORD vpMem);
DWORD WINAPI WOWGlobalLockSize16(WORD hMem, PDWORD pcb);

//
// Yielding the Win16 nonpreemptive scheduler
//
// The following two functions are provided for Win32 code called
// via Generic Thunks which needs to yield the Win16 scheduler so
// that tasks in that VDM can execute while the thunk waits for
// something to complete.  These two functions are functionally
// identical to calling back to 16-bit code which calls Yield or
// DirectedYield.
//

VOID WINAPI WOWYield16(VOID);
VOID WINAPI WOWDirectedYield16(WORD htask16);


//
// 16 <--> 32 Handle mapping functions.
//
// NOTE:  While some of these functions perform trivial
// conversions, these functions must be used to maintain
// compatibility with future versions of Windows NT which
// may require different handle mapping.
//

typedef enum _WOW_HANDLE_TYPE { /* WOW */
    WOW_TYPE_HWND,
    WOW_TYPE_HMENU,
    WOW_TYPE_HDWP,
    WOW_TYPE_HDROP,
    WOW_TYPE_HDC,
    WOW_TYPE_HFONT,
    WOW_TYPE_HMETAFILE,
    WOW_TYPE_HRGN,
    WOW_TYPE_HBITMAP,
    WOW_TYPE_HBRUSH,
    WOW_TYPE_HPALETTE,
    WOW_TYPE_HPEN,
    WOW_TYPE_HACCEL,
    WOW_TYPE_HTASK,
    WOW_TYPE_FULLHWND
} WOW_HANDLE_TYPE;

HANDLE WINAPI WOWHandle32 (WORD, WOW_HANDLE_TYPE);
WORD WINAPI WOWHandle16 (HANDLE, WOW_HANDLE_TYPE);

#define HWND_32(h16)      ((HWND)      (WOWHandle32(h16, WOW_TYPE_HWND)))
#define HMENU_32(h16)     ((HMENU)     (WOWHandle32(h16, WOW_TYPE_HMENU)))
#define HDWP_32(h16)      ((HDWP)      (WOWHandle32(h16, WOW_TYPE_HDWP)))
#define HDROP_32(h16)     ((HDROP)     (WOWHandle32(h16, WOW_TYPE_HDROP)))
#define HDC_32(h16)       ((HDC)       (WOWHandle32(h16, WOW_TYPE_HDC)))
#define HFONT_32(h16)     ((HFONT)     (WOWHandle32(h16, WOW_TYPE_HFONT)))
#define HMETAFILE_32(h16) ((HMETAFILE) (WOWHandle32(h16, WOW_TYPE_HMETAFILE)))
#define HRGN_32(h16)      ((HRGN)      (WOWHandle32(h16, WOW_TYPE_HRGN)))
#define HBITMAP_32(h16)   ((HBITMAP)   (WOWHandle32(h16, WOW_TYPE_HBITMAP)))
#define HBRUSH_32(h16)    ((HBRUSH)    (WOWHandle32(h16, WOW_TYPE_HBRUSH)))
#define HPALETTE_32(h16)  ((HPALETTE)  (WOWHandle32(h16, WOW_TYPE_HPALETTE)))
#define HPEN_32(h16)      ((HPEN)      (WOWHandle32(h16, WOW_TYPE_HPEN)))
#define HACCEL_32(h16)	  ((HACCEL)    (WOWHandle32(h16, WOW_TYPE_HACCEL)))
#define HTASK_32(h16)	  ((DWORD)     (WOWHandle32(h16, WOW_TYPE_HTASK)))
#define FULLHWND_32(h16)  ((HWND)      (WOWHandle32(h16, WOW_TYPE_FULLHWND)))

#define HWND_16(h32)      (WOWHandle16(h32, WOW_TYPE_HWND))
#define HMENU_16(h32)     (WOWHandle16(h32, WOW_TYPE_HMENU))
#define HDWP_16(h32)      (WOWHandle16(h32, WOW_TYPE_HDWP))
#define HDROP_16(h32)     (WOWHandle16(h32, WOW_TYPE_HDROP))
#define HDC_16(h32)       (WOWHandle16(h32, WOW_TYPE_HDC))
#define HFONT_16(h32)     (WOWHandle16(h32, WOW_TYPE_HFONT))
#define HMETAFILE_16(h32) (WOWHandle16(h32, WOW_TYPE_HMETAFILE))
#define HRGN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HRGN))
#define HBITMAP_16(h32)   (WOWHandle16(h32, WOW_TYPE_HBITMAP))
#define HBRUSH_16(h32)    (WOWHandle16(h32, WOW_TYPE_HBRUSH))
#define HPALETTE_16(h32)  (WOWHandle16(h32, WOW_TYPE_HPALETTE))
#define HPEN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HPEN))
#define HACCEL_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HACCEL))
#define HTASK_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HTASK))

//
// Generic Callbacks.
//
// WOWCallback16 can be used in Win32 code called
// from 16-bit (such as by using Generic Thunks) to call back to
// the 16-bit side.  The function called must be declared similarly
// to the following:
//
// LONG FAR PASCAL CallbackRoutine(DWORD dwParam);
//
// If you are passing a pointer, declare the parameter as such:
//
// LONG FAR PASCAL CallbackRoutine(VOID FAR *vp);
//
// NOTE: If you are passing a pointer, you'll need to get the
// pointer using WOWGlobalAlloc16 or WOWGlobalAllocLock16
//
// If the function called returns a WORD instead of a DWORD, the
// upper 16 bits of the return value is undefined.  Similarly, if
// the function called has no return value, the entire return value
// is undefined.
//
// WOWCallback16Ex allows any combination of arguments up to
// WCB16_MAX_CBARGS bytes total to be passed to the 16-bit routine.
// cbArgs is used to properly clean up the 16-bit stack after calling
// the routine.  Regardless of the value of cbArgs, WCB16_MAX_CBARGS
// bytes will always be copied from pArgs to the 16-bit stack.  If
// pArgs is less than WCB16_MAX_CBARGS bytes from the end of a page,
// and the next page is inaccessible, WOWCallback16Ex will incur an
// access violation.
//
// If cbArgs is larger than the WCB16_MAX_ARGS which the running
// system supports, the function returns FALSE and GetLastError
// returns ERROR_INVALID_PARAMETER.  Otherwise the function
// returns TRUE and the DWORD pointed to by pdwRetCode contains
// the return code from the callback routine.  If the callback
// routine returns a WORD, the HIWORD of the return code is
// undefined and should be ignored using LOWORD(dwRetCode).
//
// WOWCallback16Ex can call routines using the PASCAL and CDECL
// calling conventions.  The default is to use the PASCAL
// calling convention.  To use CDECL, pass WCB16_CDECL in the
// dwFlags parameter.
//
// The arguments pointed to by pArgs must be in the correct
// order for the callback routine's calling convention.
// To call the PASCAL routine SetWindowText,
//
// LONG FAR PASCAL SetWindowText(HWND hwnd, LPCSTR lpsz);
//
// pArgs would point to an array of words:
//
// WORD SetWindowTextArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz), hwnd};
//
// In other words, the arguments are placed in the array in reverse
// order with the least significant word first for DWORDs and offset
// first for FAR pointers.
//
// To call the CDECL routine wsprintf, for example
//
// LPSTR lpszFormat = "%d %s";
// int _cdecl wsprintf(lpsz, lpszFormat, nValue. lpszString);
//
// pArgs would point to the array:
//
// WORD wsprintfArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz),
//                        OFFSETOF(lpszFormat), SELECTOROF(lpszFormat),
//                        nValue,
//                        OFFSETOF(lpszString), SELECTOROF(lpszString)};
//
// In other words, the arguments are placed in the array in the order
// listed in the function prototype with the least significant word
// first for DWORDs and offset first for FAR pointers.
//

DWORD WINAPI WOWCallback16(DWORD vpfn16, DWORD dwParam);

#define WCB16_MAX_CBARGS (16)

#define WCB16_PASCAL     (0x0)
#define WCB16_CDECL      (0x1)

BOOL WINAPI WOWCallback16Ex(
                DWORD  vpfn16,
                DWORD  dwFlags,
                DWORD  cbArgs,
                PVOID  pArgs,
                PDWORD pdwRetCode
                );

#endif /* !_WOWNT32_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wsnwlink.h ===
/*
 *   wsnwlink.h
 *
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *   Microsoft-specific extensions to the Windows NT IPX/SPX Windows
 *   Sockets interface.  These extensions are provided for use as
 *   necessary for compatibility with existing applications.  They are
 *   otherwise not recommended for use, as they are only guaranteed to
 *   work *   over the Microsoft IPX/SPX stack.  An application which
 *   uses these *   extensions may not work over other IPX/SPX
 *   implementations.  Include this header file after winsock.h and
 *   wsipx.h.
 *
 *   To open an IPX socket where a particular packet type is sent in
 *   the IPX header, specify NSPROTO_IPX + n as the protocol parameter
 *   of the socket() API.  For example, to open an IPX socket that
 *   sets the packet type to 34, use the following socket() call:
 *
 *       s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX + 34);
 *
 *   Below are socket option that may be set or retrieved by specifying
 *   the appropriate manifest in the "optname" parameter of getsockopt()
 *   or setsockopt().  Use NSPROTO_IPX as the "level" argument for the
 *   call.
 *
 */

#ifndef _WSNWLINK_
#define _WSNWLINK_

#if _MSC_VER > 1000
#pragma once
#endif


/*
 *   Set/get the IPX packet type.  The value specified in the
 *   optval argument will be set as the packet type on every IPX
 *   packet sent from this socket.  The optval parameter of
 *   getsockopt()/setsockopt() points to an int.
 *
 */

#define IPX_PTYPE               0x4000


/*
 *   Set/get the receive filter packet type.  Only IPX packets with
 *   a packet type equal to the value specified in the optval
 *   argument will be returned; packets with a packet type that
 *   does not match are discarded.  optval points to an int.
 *
 */

#define IPX_FILTERPTYPE         0x4001


/*
 *   Stop filtering on packet type set with IPX_FILTERPTYPE.
 *
 */

#define IPX_STOPFILTERPTYPE     0x4003


/*
 *   Set/get the value of the datastream field in the SPX header on
 *   every packet sent.  optval points to an int.
 *
 */

#define IPX_DSTYPE              0x4002


/*
 *   Enable extended addressing.  On sends, adds the element
 *   "unsigned char sa_ptype" to the SOCKADDR_IPX structure,
 *   making the total length 15 bytes.  On receives, add both
 *   the sa_ptype and "unsigned char sa_flags" to the SOCKADDR_IPX
 *   structure, making the total length 16 bytes.  The current
 *   bits defined in sa_flags are:
 *
 *   0x01 - the received frame was sent as a broadcast
 *   0x02 - the received frame was sent from this machine
 *
 *   optval points to a BOOL.
 *
 */

#define IPX_EXTENDED_ADDRESS    0x4004


/*
 *   Send protocol header up on all receive packets.  optval points
 *   to a BOOL.
 *
 */

#define IPX_RECVHDR             0x4005


/*
 *   Get the maximum data size that can be sent.  Not valid with
 *   setsockopt().  optval points to an int where the value is
 *   returned.
 *
 */

#define IPX_MAXSIZE             0x4006


/*
 *   Query information about a specific adapter that IPX is bound
 *   to.  In a system with n adapters they are numbered 0 through n-1.
 *   Callers can issue the IPX_MAX_ADAPTER_NUM getsockopt() to find
 *   out the number of adapters present, or call IPX_ADDRESS with
 *   increasing values of adapternum until it fails.  Not valid
 *   with setsockopt().  optval points to an instance of the
 *   IPX_ADDRESS_DATA structure with the adapternum filled in.
 *
 */

#define IPX_ADDRESS             0x4007

typedef struct _IPX_ADDRESS_DATA {
    INT   adapternum;  /* input: 0-based adapter number */
    UCHAR netnum[4];   /* output: IPX network number */
    UCHAR nodenum[6];  /* output: IPX node address */
    BOOLEAN wan;       /* output: TRUE = adapter is on a wan link */
    BOOLEAN status;    /* output: TRUE = wan link is up (or adapter is not wan) */
    INT   maxpkt;      /* output: max packet size, not including IPX header */
    ULONG linkspeed;   /* output: link speed in 100 bytes/sec (i.e. 96 == 9600 bps) */
} IPX_ADDRESS_DATA, *PIPX_ADDRESS_DATA;


/*
 *   Query information about a specific IPX network number.  If the
 *   network is in IPX's cache it will return the information directly,
 *   otherwise it will issue RIP requests to find it.  Not valid with
 *   setsockopt().  optval points to an instance of the IPX_NETNUM_DATA
 *   structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO          0x4008

typedef struct _IPX_NETNUM_DATA {
    UCHAR  netnum[4];  /* input: IPX network number */
    USHORT hopcount;   /* output: hop count to this network, in machine order */
    USHORT netdelay;   /* output: tick count to this network, in machine order */
    INT    cardnum;    /* output: 0-based adapter number used to route to this net;
                       /*         can be used as adapternum input to IPX_ADDRESS */
    UCHAR  router[6];  /* output: MAC address of the next hop router, zeroed if
                       /*         the network is directly attached */
} IPX_NETNUM_DATA, *PIPX_NETNUM_DATA;


/*
 *   Like IPX_GETNETINFO except it *does not* issue RIP requests. If the
 *   network is in IPX's cache it will return the information, otherwise
 *   it will fail (see also IPX_RERIPNETNUMBER which *always* forces a
 *   re-RIP). Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO_NORIP    0x4009


/*
 *   Get information on a connected SPX socket.  optval points
 *   to an instance of the IPX_SPXCONNSTATUS_DATA structure.
 *
 *   All numbers are in Novell (high-low) order.
 *
 */

#define IPX_SPXGETCONNECTIONSTATUS 0x400B

typedef struct _IPX_SPXCONNSTATUS_DATA {
    UCHAR  ConnectionState;
    UCHAR  WatchDogActive;
    USHORT LocalConnectionId;
    USHORT RemoteConnectionId;
    USHORT LocalSequenceNumber;
    USHORT LocalAckNumber;
    USHORT LocalAllocNumber;
    USHORT RemoteAckNumber;
    USHORT RemoteAllocNumber;
    USHORT LocalSocket;
    UCHAR  ImmediateAddress[6];
    UCHAR  RemoteNetwork[4];
    UCHAR  RemoteNode[6];
    USHORT RemoteSocket;
    USHORT RetransmissionCount;
    USHORT EstimatedRoundTripDelay; /* In milliseconds */
    USHORT RetransmittedPackets;
    USHORT SuppressedPacket;
} IPX_SPXCONNSTATUS_DATA, *PIPX_SPXCONNSTATUS_DATA;


/*
 *   Get notification when the status of an adapter that IPX is
 *   bound to changes.  Typically this will happen when a wan line
 *   goes up or down.  Not valid with setsockopt().  optval points
 *   to a buffer which contains an IPX_ADDRESS_DATA structure
 *   followed immediately by a HANDLE to an unsignaled event.
 *
 *   When the getsockopt() query is submitted, it will complete
 *   successfully.  However, the IPX_ADDRESS_DATA pointed to by
 *   optval will not be updated at that point.  Instead the
 *   request is queued internally inside the transport.
 *
 *   When the status of an adapter changes, IPX will locate a
 *   queued getsockopt() query and fill in all the fields in the
 *   IPX_ADDRESS_DATA structure.  It will then signal the event
 *   pointed to by the HANDLE in the optval buffer.  This handle
 *   should be obtained before calling getsockopt() by calling
 *   CreateEvent().  If multiple getsockopts() are submitted at
 *   once, different events must be used.
 *
 *   The event is used because the call needs to be asynchronous
 *   but currently getsockopt() does not support this.
 *
 *   WARNING: In the current implementation, the transport will
 *   only signal one queued query for each status change.  Therefore
 *   only one service which uses this query should be running at
 *   once.
 *
 */

#define IPX_ADDRESS_NOTIFY      0x400C


/*
 *   Get the maximum number of adapters present.  If this call returns
 *   n then the adapters are numbered 0 through n-1.  Not valid
 *   with setsockopt().  optval points to an int where the value
 *   is returned.
 *
 */

#define IPX_MAX_ADAPTER_NUM     0x400D


/*
 *   Like IPX_GETNETINFO except it forces IPX to re-RIP even if the
 *   network is in its cache (but not if it is directly attached to).
 *   Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_RERIPNETNUMBER      0x400E


/*
 *   A hint that broadcast packets may be received.  The default is
 *   TRUE.  Applications that do not need to receive broadcast packets
 *   should set this sockopt to FALSE which may cause better system
 *   performance (note that it does not necessarily cause broadcasts
 *   to be filtered for the application).  Not valid with getsockopt().
 *   optval points to a BOOL.
 *
 */

#define IPX_RECEIVE_BROADCAST   0x400F


/*
 *   On SPX connections, don't delay before sending ack.  Applications
 *   that do not tend to have back-and-forth traffic over SPX should
 *   set this; it will increase the number of acks sent but will remove
 *   delays in sending acks.  optval points to a BOOL.
 *
 */

#define IPX_IMMEDIATESPXACK     0x4010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wx86ofl.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wx86ofl.h

Abstract:

    Wx86 On-The-Fly declarations/definitions.

Revision History:

    06-Jun-1998 CBiks   Created

--*/

#ifndef WX86OFL_INCLUDED
#define WX86OFL_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef WX86

#include <unknwn.h>

#ifdef __cplusplus
extern "C" {
#endif

// Each successful call to Wx86Load must be matched with a call to
// Wx86Unload()

BOOL Wx86Load();
void Wx86Unload();

// The following functions require wx86.dll to have been loaded

UINT Wx86Callback(PROC pfnCallBack, HWND hwnd, UINT uMsg, LPARAM lParam);

PVOID Wx86ThunkProc(PVOID pvAddress, PVOID pvCBDispatch, BOOL  fNativeToX86 );

PVOID Wx86DualThunkProc(PVOID pvAddress, PVOID pvCBDispatch, BOOL  fNativeToX86 );

ULONG Wx86EmulateX86(PVOID pvAddress, ULONG  nParameters, PULONG Parameters);

ULONGLONG Wx86EmulateX86GetQWord(PVOID pvAddress, ULONG  nParameters,
                                 PULONG Parameters);

IUnknown* Wx86ThunkInterface(IUnknown *punk, IID *piid,
                             BOOLEAN fOutParameter, BOOLEAN fNativeToX86);

void Wx86CheckFreeTempProxy(IUnknown *punk);

IUnknown* Wx86ResolveProxy(IUnknown *punk, BOOLEAN fNativeToX86);

HRESULT Wx86DllGetClassObjectThunk(IID *piid, LPVOID *ppv, HRESULT hr,
                                   BOOLEAN fNativetoX86);

ULONG Wx86ProxyAddRef(IUnknown* punk);

ULONG Wx86ProxyRelease(IUnknown* punk);


// Wx86LoadX86Dll is retained for backward compatibility

HMODULE Wx86LoadX86Dll(LPCWSTR lpLibFileName, DWORD dwFlags);

BOOL Wx86FreeX86Dll(HMODULE hMod);

// Wx86LoadX86Library is ifdef'd for UNICODE and non-UNICODE. This has been
// added for compatibility with other Win32 functions as well as the functions
// below. We cannot reuse the name Wx86LoadX86Dll because it is already defined
// in wx86dll.h and will require cleaning up the code of all apps that use that
// function
//
// At some point, this should be cleaned up and wx86dll.h should be eliminated.
// A clean build will be required then.

HMODULE Wx86LoadX86LibraryA(LPCSTR lpLibFileName, DWORD dwFlags);
#define Wx86LoadX86LibraryW Wx86LoadX86Dll

#ifdef UNICODE
#define Wx86LoadX86Library  Wx86LoadX86LibraryW
#else
#define Wx86LoadX86Library  Wx86LoadX86LibraryA
#endif // !UNICODE


#define Wx86FreeX86Library Wx86FreeX86Dll

//
// The following functions do not require wx86.dll to be loaded
//

//
// GetModuleHandle returns 0 if a native apps calls it with an x86 dll name.
// This function will return the x86 dll's module handle.

HMODULE Wx86GetX86ModuleHandleA(LPCSTR szDll);
HMODULE Wx86GetX86ModuleHandleW(LPCWSTR szDll);

#ifdef UNICODE
#define Wx86GetX86ModuleHandle  Wx86GetX86ModuleHandleW
#else
#define Wx86GetX86ModuleHandle  Wx86GetX86ModuleHandleA
#endif // !UNICODE

UINT Wx86GetX86SystemDirectoryA(LPSTR lpBuffer, UINT nSize);
UINT Wx86GetX86SystemDirectoryW(LPWSTR lpBuffer, UINT nSize);

#ifdef UNICODE
#define Wx86GetX86SystemDirectory  Wx86GetX86SystemDirectoryW
#else
#define Wx86GetX86SystemDirectory  Wx86GetX86SystemDirectoryA
#endif // !UNICODE

BOOL Wx86SuppressHardErrors(BOOL bSuppressHardErrors);

BOOL Wx86IsCallThunked(VOID);


BOOL Wx86UseKnownWx86Dll(BOOL bUseKnownWx86Dll);

//
// Helper functions for Wx86 plugin providers
//

typedef
BOOLEAN
(*WX86ENUMEXPORTCALLBACK)(
    PVOID DllBase,      // same as DllBase above
    PVOID Context,      // same as Context above
    PCHAR ExportName,   // Name of Export (NULL if noname)
    ULONG Ordinal       // Ordinal of Export
    );

BOOL
Wx86EnumExports(
    IN PVOID DllBase,
    IN PVOID Context,
    IN WX86ENUMEXPORTCALLBACK CallBackRtn
    );

//
// Registry thunking APIs
//

LONG
Wx86RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG
Wx86RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG
Wx86RegDeleteKeyA(
    HKEY hKey,
    LPCSTR lpKeyName
    );

LONG
Wx86RegDeleteKeyW(
    HKEY hKey,
    LPCWSTR lpKeyName
    );

LONG
Wx86RegEnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );

LONG
Wx86RegEnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

LONG
Wx86RegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
Wx86RegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
Wx86RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
Wx86RegQueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );

LONG
Wx86RegQueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    );

LONG
Wx86RegQueryValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegQueryValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegSetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
Wx86RegDeleteValueA(
    HKEY hKey,
    LPCSTR lpValueName
    );

LONG
Wx86RegDeleteValueW(
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG
Wx86RegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegQueryMultipleValuesA(
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

LONG
Wx86RegQueryMultipleValuesW(
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

LONG
Wx86RegCloseKey(
    HKEY hKey
    );

#if defined(UNICODE)

#define Wx86RegCreateKey            Wx86RegCreateKeyA
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExA
#define Wx86RegDeleteKey            Wx86RegDeleteKeyA
#define Wx86RegEnumKey              Wx86RegEnumKeyA
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExA
#define Wx86RegOpenKey              Wx86RegOpenKeyA
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExA
#define Wx86RegQueryValue           Wx86RegQueryValueA
#define Wx86RegQueryValueEx         Wx86RegQueryValueExA
#define Wx86RegSetValue             Wx86RegSetValueA
#define Wx86RegSetValueEx           Wx86RegSetValueExA
#define Wx86RegDeleteValue          Wx86RegDeleteValueA
#define Wx86RegEnumValue            Wx86RegEnumValueA
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesA

#else

#define Wx86RegCreateKey            Wx86RegCreateKeyW
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExW
#define Wx86RegDeleteKey            Wx86RegDeleteKeyW
#define Wx86RegEnumKey              Wx86RegEnumKeyW
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExW
#define Wx86RegOpenKey              Wx86RegOpenKeyW
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExW
#define Wx86RegQueryValue           Wx86RegQueryValueW
#define Wx86RegQueryValueEx         Wx86RegQueryValueExW
#define Wx86RegSetValue             Wx86RegSetValueW
#define Wx86RegSetValueEx           Wx86RegSetValueExW
#define Wx86RegDeleteValue          Wx86RegDeleteValueW
#define Wx86RegEnumValue            Wx86RegEnumValueW
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesW

#endif


#ifdef __cplusplus
};
#endif

#endif // WX86

#endif // WX86OFL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\wx86dll.h ===
/************************************************************************
*                                                                       *
*   wx86dll.h -- This module defines Wx86 APIs for x86 emulation        *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _WX86DLL_
#define _WX86DLL_

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_WX86DLLAPI_)
#define WX86DLLAPI DECLSPEC_IMPORT
#else
#define WX86DLLAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _BopInstr {
    BYTE    Instr1;         // 0xc4c4 - the x86 BOP instruction
    BYTE    Instr2;
    BYTE    BopNum;
    BYTE    Flags;
    USHORT  ApiNum;
    BYTE    RetSize;
    BYTE    ArgSize;
} BOPINSTR;
typedef UNALIGNED BOPINSTR * PBOPINSTR;


typedef
BOOL
(*WX86OFLYINITIALIZE_ROUTINE)(
    VOID
    );

WX86DLLAPI
BOOL
Wx86OFlyInitialize(
    VOID
    );

WX86DLLAPI
HMODULE
Wx86LoadX86Dll(
    LPCWSTR lpLibFileName,
    DWORD   dwFlags
    );

typedef
HMODULE
(*WX86LOADX86DLL_ROUTINE)(
  LPCWSTR lpLibFileName,
  DWORD   dwFlags
  );

WX86DLLAPI
HMODULE
Wx86GetX86DllHandle(
    LPCWSTR lpLibFileName
    );

typedef
HMODULE
(*WX86GETX86DLLHANDLE_ROUTINE)(
  LPCWSTR lpLibFileName
  );

WX86DLLAPI
BOOL
Wx86FreeX86Dll(
    HMODULE hMod
    );

typedef
BOOL
(*WX86FREEX86Dll_ROUTINE)(
    HMODULE hMod
    );

WX86DLLAPI
BOOL
Wx86Compact(
    VOID
    );

typedef
BOOL
(*WX86COMPACT_ROUTINE)(
    VOID
    );

WX86DLLAPI
PVOID
Wx86ThunkProc(
    PVOID pvAddress,
    PVOID pvCBDispatch,
    BOOL  fNativeToX86
    );

WX86DLLAPI
PVOID
Wx86DualThunkProc(
    PVOID pvAddress,
    PVOID pvCBDispatch,
    BOOL  fNativeToX86
    );

typedef
PVOID
(*WX86THUNKPROC_ROUTINE)(
  PVOID pvAddress,
  PVOID pvCBDispatch,
  BOOL  fNativeToX86
  );

typedef
ULONG
(*X86TONATIVETHUNKPROC)(
    PVOID  pvNativeAddress,
    PULONG pBaseArgs,
    PULONG pArgCount
    );

WX86DLLAPI
ULONG
Wx86ThunkEmulateX86(
    ULONG  nParameters,
    PULONG Parameters
    );

typedef
ULONG
(*WX86THUNKEMULATEX86)(
    ULONG  nParameters,
    PULONG Parameters
    );

WX86DLLAPI
ULONG
Wx86EmulateX86(
    PVOID  StartAddress,
    ULONG  nParameters,
    PULONG Parameters
    );

typedef
ULONG
(*WX86EMULATEX86)(
    PVOID  StartAddress,
    ULONG  nParameters,
    PULONG Parameters
    );

WX86DLLAPI
IUnknown *
Wx86ThunkInterface(
    IUnknown *punk,
    IID *piid,
    BOOLEAN fOutParameter,
    BOOLEAN fNativeToX86
    );

typedef
IUnknown *
(*WX86THUNKINTERFACE)(
    IUnknown *punk,
    IID *piid,
    BOOL  fOutParameter,
    BOOL  fNativeToX86
    );

WX86DLLAPI
void
Wx86CheckFreeTempProxy(
    IUnknown *punk
    );

typedef
void
(*WX86CHECKFREETEMPPROXY)(
    IUnknown *punk
    );

WX86DLLAPI
IUnknown *
Wx86ResolveProxy(
    IUnknown *punk,
    BOOLEAN fNativeToX86);

typedef
IUnknown *
(*WX86RESOLVEPROXY)(
    IUnknown *punk,
    BOOLEAN fNativeToX86);

WX86DLLAPI
ULONG
Wx86ProxyAddRef(IUnknown* punk);

typedef
ULONG
(*WX86PROXYADDREF)(
    IUnknown *punk);


WX86DLLAPI
ULONG
Wx86ProxyRelease(IUnknown* punk);

typedef
ULONG
(*WX86PROXYRELEASE)(
    IUnknown *punk);

WX86DLLAPI
HRESULT
Wx86DllGetClassObjectThunk(
    IID *piid,
    LPVOID *ppv,
    HRESULT hr,
    BOOLEAN fNativetoX86);

typedef
HRESULT
(*WX86DLLGETCLASSOBJECTTHUNK)(
    IID *piid,
    LPVOID *ppv,
    HRESULT hr,
    BOOLEAN fNativetoX86);

WX86DLLAPI
PVOID *
Wx86InitializeOle(
    VOID
    );

typedef
PVOID *
(*W86INITIALIZEOLE)(
    VOID
    );

WX86DLLAPI
void
Wx86DeinitializeOle(
    VOID
    );

VOID
WX86DEINITIALIZEOLE(
    VOID
    );


WX86DLLAPI
LONG
Wx86RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

WX86DLLAPI
LONG
Wx86RegDeleteKeyA(
    HKEY hKey,
    LPCSTR lpKeyName
    );

WX86DLLAPI
LONG
Wx86RegDeleteKeyW(
    HKEY hKey,
    LPCWSTR lpKeyName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegQueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegDeleteValueA(
    HKEY hKey,
    LPCSTR lpValueName
    );

WX86DLLAPI
LONG
Wx86RegDeleteValueW(
    HKEY hKey,
    LPCWSTR lpValueName
    );

WX86DLLAPI
LONG
Wx86RegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryMultipleValuesA(
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

WX86DLLAPI
LONG
Wx86RegQueryMultipleValuesW(
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

WX86DLLAPI
LONG
Wx86RegCloseKey(
    HKEY hKey
    );

#ifdef UNICODE

#define Wx86RegCreateKey            Wx86RegCreateKeyA
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExA
#define Wx86RegDeleteKey            Wx86RegDeleteKeyA
#define Wx86RegEnumKey              Wx86RegEnumKeyA
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExA
#define Wx86RegOpenKey              Wx86RegOpenKeyA
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExA
#define Wx86RegQueryValue           Wx86RegQueryValueA
#define Wx86RegQueryValueEx         Wx86RegQueryValueExA
#define Wx86RegSetValue             Wx86RegSetValueA
#define Wx86RegSetValueEx           Wx86RegSetValueExA
#define Wx86RegDeleteValue          Wx86RegDeleteValueA
#define Wx86RegEnumValue            Wx86RegEnumValueA
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesA

#else

#define Wx86RegCreateKey            Wx86RegCreateKeyW
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExW
#define Wx86RegDeleteKey            Wx86RegDeleteKeyW
#define Wx86RegEnumKey              Wx86RegEnumKeyW
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExW
#define Wx86RegOpenKey              Wx86RegOpenKeyW
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExW
#define Wx86RegQueryValue           Wx86RegQueryValueW
#define Wx86RegQueryValueEx         Wx86RegQueryValueExW
#define Wx86RegSetValue             Wx86RegSetValueW
#define Wx86RegSetValueEx           Wx86RegSetValueExW
#define Wx86RegDeleteValue          Wx86RegDeleteValueW
#define Wx86RegEnumValue            Wx86RegEnumValueW
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesW

#endif

#ifdef __cplusplus
}
#endif


#endif // _WX86DLL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao350\dbdaoerr.h ===
/************************************************************************
**	D B D A O E R R . H													*														*
**																		*
**		History 														*
**		------- 														*
**	5-17-95 Added to DAO SDK				 							*
**	7-17-95 Added DBDAOERR macro, removed internal only codes																	*
**																		*
**	The following #defines map the integer to a descriptive name
**	i.e.  3270 -> E_DAO_VtoPropNotFound									*
**																		*
**																		*
*************************************************************************
** Copyright (C) 1995 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

#ifndef _DBDAOERR_H_
#define _DBDAOERR_H_

#define DBDAOERR(x) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)

#define E_DAO_InternalError					DBDAOERR(3000) //Reserved error (|); there is no message for this error.
#define E_DAO_InvalidParameter				DBDAOERR(3001) //Invalid argument.
#define E_DAO_CantBegin						DBDAOERR(3002) //Couldn't start session.
#define E_DAO_TransTooDeep					DBDAOERR(3003) //Couldn't start transaction; too many transactions already nested.
#define E_DAO_DatabaseNotFound				DBDAOERR(3004) //Couldn't find database '|'.
#define E_DAO_DatabaseInvalidName			DBDAOERR(3005) //'|' isn't a valid database name.
#define E_DAO_DatabaseLocked				DBDAOERR(3006) //Database '|' is exclusively locked.
#define E_DAO_DatabaseOpenError				DBDAOERR(3007) //Can't open library database '|'.
#define E_DAO_TableLocked					DBDAOERR(3008) //Table '|' is exclusively locked.
#define E_DAO_TableInUse					DBDAOERR(3009) //Couldn't lock table '|'; currently in use.
#define E_DAO_TableDuplicate				DBDAOERR(3010) //Table '|' already exists.
#define E_DAO_ObjectNotFound				DBDAOERR(3011) //Couldn't find object '|'.
#define E_DAO_ObjectDuplicate				DBDAOERR(3012) //Object '|' already exists.
#define E_DAO_CannotRename					DBDAOERR(3013) //Couldn't rename installable ISAM file.
#define E_DAO_TooManyOpenTables				DBDAOERR(3014) //Can't open any more tables.
#define E_DAO_IndexNotFound					DBDAOERR(3015) //'|' isn't an index in this table.
#define E_DAO_ColumnDoesNotFit 				DBDAOERR(3016) //Field won't fit in record.
#define E_DAO_ColumnTooBig					DBDAOERR(3017) //The size of a field is too long.
#define E_DAO_ColumnNotFound				DBDAOERR(3018) //Couldn't find field '|'.
#define E_DAO_NoCurrentIndex				DBDAOERR(3019) //Operation invalid without a current index.
#define E_DAO_RecordNoCopy					DBDAOERR(3020) //Update or CancelUpdate without AddNew or Edit.
#define E_DAO_NoCurrentRecord				DBDAOERR(3021) //No current record.
#define E_DAO_KeyDuplicate					DBDAOERR(3022) //Duplicate value in index, primary key, or relationship.  Changes were unsuccessful.
#define E_DAO_AlreadyPrepared				DBDAOERR(3023) //AddNew or Edit already used.
#define E_DAO_FileNotFound					DBDAOERR(3024) //Couldn't find file '|'.
#define E_DAO_TooManyOpenFiles				DBDAOERR(3025) //Can't open any more files.
#define E_DAO_DiskFull						DBDAOERR(3026) //Not enough space on disk.
#define E_DAO_PermissionDenied				DBDAOERR(3027) //Can't update.  Database or object is read-only.
#define E_DAO_CannotOpenSystemDb			DBDAOERR(3028) //Can't start your application. The system database is missing or opened exclusively by another user.
#define E_DAO_InvalidLogon					DBDAOERR(3029) //Not a valid account name or password.
#define E_DAO_InvalidAccountName			DBDAOERR(3030) //'|' isn't a valid account name.
#define E_DAO_InvalidPassword				DBDAOERR(3031) //Not a valid password.
#define E_DAO_InvalidOperation				DBDAOERR(3032) //Can't perform this operation.
#define E_DAO_AccessDenied					DBDAOERR(3033) //No permission for '|'.
#define E_DAO_NotInTransaction				DBDAOERR(3034) //Commit or Rollback without BeginTrans.
#define E_DAO_OutOfMemory					DBDAOERR(3035) //*
#define E_DAO_CantAllocatePage				DBDAOERR(3036) //Database has reached maximum size.
#define E_DAO_NoMoreCursors					DBDAOERR(3037) //Can't open any more tables or queries.
#define E_DAO_OutOfBuffers					DBDAOERR(3038) //*
#define E_DAO_TooManyIndexes				DBDAOERR(3039) //Couldn't create index; too many indexes already defined.
#define E_DAO_ReadVerifyFailure				DBDAOERR(3040) //Disk I/O error during read.
#define E_DAO_FilesysVersion				DBDAOERR(3041) //Can't open a database created with a previous version of your application.
#define E_DAO_NoMoreFiles					DBDAOERR(3042) //Out of MS-DOS file handles.
#define E_DAO_DiskError						DBDAOERR(3043) //Disk or network error.
#define E_DAO_InvalidPath					DBDAOERR(3044) //'|' isn't a valid path.
#define E_DAO_FileShareViolation			DBDAOERR(3045) //Couldn't use '|'; file already in use.
#define E_DAO_FileLockViolation				DBDAOERR(3046) //Couldn't save; currently locked by another user.
#define E_DAO_RecordTooBig					DBDAOERR(3047) //Record is too large.
#define E_DAO_TooManyOpenDatabases			DBDAOERR(3048) //Can't open any more databases.
#define E_DAO_InvalidDatabase				DBDAOERR(3049) //Can't open database '|'.  It may not be a database that your application recognizes, or the file may be corrupt.
#define E_DAO_FileLockingUnavailable		DBDAOERR(3050) //Couldn't lock file.
#define E_DAO_FileAccessDenied				DBDAOERR(3051) //Couldn't open file '|'.
#define E_DAO_SharingBufferExceeded			DBDAOERR(3052) //MS-DOS file sharing lock count exceeded.  You need to increase the number of locks installed with SHARE.EXE.
#define E_DAO_TaskLimitExceeded				DBDAOERR(3053) //Too many client tasks.
#define E_DAO_TooManyLongColumns			DBDAOERR(3054) //Too many Memo or OLE object fields.
#define E_DAO_InvalidFilename				DBDAOERR(3055) //Not a valid file name.
#define E_DAO_AbortSalvage					DBDAOERR(3056) //Couldn't repair this database.
#define E_DAO_LinkNotSupported				DBDAOERR(3057) //Operation not supported on attached, or linked, tables.
#define E_DAO_NullKeyDisallowed				DBDAOERR(3058) //Index or primary key can't contain a null value.
#define E_DAO_OperationCanceled				DBDAOERR(3059) //Operation canceled by user.
#define E_DAO_QueryParmTypeMismatch			DBDAOERR(3060) //Wrong data type for parameter '|'.
#define E_DAO_QueryMissingParmsM			DBDAOERR(3061) //Too few parameters. Expected |.
#define E_DAO_QueryDuplicateAliasM			DBDAOERR(3062) //Duplicate output alias '|'.
#define E_DAO_QueryDuplicateOutputM			DBDAOERR(3063) //Duplicate output destination '|'.
#define E_DAO_QueryIsBulkOp					DBDAOERR(3064) //Can't open action query '|'.
#define E_DAO_QueryIsNotBulkOp				DBDAOERR(3065) //Can't execute a non-action query.
#define E_DAO_QueryNoOutputsM				DBDAOERR(3066) //Query or table must contain at least one output field.
#define E_DAO_QueryNoInputTablesM			DBDAOERR(3067) //Query input must contain at least one table or query.
#define E_DAO_QueryInvalidAlias				DBDAOERR(3068) //Not a valid alias name.
#define E_DAO_QueryInvalidBulkInputM		DBDAOERR(3069) //The action query '|' cannot be used as a row source.
#define E_DAO_QueryUnboundRef				DBDAOERR(3070) //Can't bind name '|'.
#define E_DAO_QueryExprEvaluation			DBDAOERR(3071) //Can't evaluate expression.
#define E_DAO_EvalEBESErr					DBDAOERR(3072) //|
#define E_DAO_QueryNotUpdatable				DBDAOERR(3073) //Operation must use an updatable query.
#define E_DAO_TableRepeatInFromList			DBDAOERR(3074) //Can't repeat table name '|' in FROM clause.
#define E_DAO_QueryExprSyntax				DBDAOERR(3075) //|1 in query expression '|2'.
#define E_DAO_QbeExprSyntax					DBDAOERR(3076) //| in criteria expression.
#define E_DAO_FindExprSyntax				DBDAOERR(3077) //| in expression.
#define E_DAO_InputTableNotFound			DBDAOERR(3078) //Couldn't find input table or query '|'.
#define E_DAO_QueryAmbigRefM				DBDAOERR(3079) //Ambiguous field reference '|'.
#define E_DAO_JoinTableNotInput				DBDAOERR(3080) //Joined table '|' not listed in FROM clause.
#define E_DAO_UnaliasedSelfJoin				DBDAOERR(3081) //Can't join more than one table with the same name (|).
#define E_DAO_ColumnNotInJoinTable			DBDAOERR(3082) //JOIN operation '|' refers to a non-joined table.
#define E_DAO_QueryIsMGB					DBDAOERR(3083) //Can't use internal report query.
#define E_DAO_QueryInsIntoBulkMGB			DBDAOERR(3084) //Can't insert data with action query.
#define E_DAO_ExprUnknownFunctionM			DBDAOERR(3085) //Undefined function '|' in expression.
#define E_DAO_QueryCannotDelete				DBDAOERR(3086) //Couldn't delete from specified tables.
#define E_DAO_QueryTooManyGroupExprs		DBDAOERR(3087) //Too many expressions in GROUP BY clause.
#define E_DAO_QueryTooManyOrderExprs		DBDAOERR(3088) //Too many expressions in ORDER BY clause.
#define E_DAO_QueryTooManyDistExprs			DBDAOERR(3089) //Too many expressions in DISTINCT output.
#define E_DAO_Column2ndSysMaint				DBDAOERR(3090) //Resultant table not allowed to have more than one Counter or Autonumber field.
#define E_DAO_HavingWOGrouping				DBDAOERR(3091) //HAVING clause (|) without grouping or aggregation.
#define E_DAO_HavingOnTransform				DBDAOERR(3092) //Can't use HAVING clause in TRANSFORM statement.
#define E_DAO_OrderVsDistinct				DBDAOERR(3093) //ORDER BY clause (|) conflicts with DISTINCT.
#define E_DAO_OrderVsGroup					DBDAOERR(3094) //ORDER BY clause (|) conflicts with GROUP BY clause.
#define E_DAO_AggregateInArgument			DBDAOERR(3095) //Can't have aggregate function in expression (|).
#define E_DAO_AggregateInWhere				DBDAOERR(3096) //Can't have aggregate function in WHERE clause (|).
#define E_DAO_AggregateInOrderBy			DBDAOERR(3097) //Can't have aggregate function in ORDER BY clause (|).
#define E_DAO_AggregateInGroupBy			DBDAOERR(3098) //Can't have aggregate function in GROUP BY clause (|).
#define E_DAO_AggregateInJoin				DBDAOERR(3099) //Can't have aggregate function in JOIN operation (|).
#define E_DAO_NullInJoinKey					DBDAOERR(3100) //Can't set field '|' in join key to Null.
#define E_DAO_ValueBreaksJoin				DBDAOERR(3101) //There is no record in table '|2' with key matching field(s) '|1'.
#define E_DAO_QueryTreeCycle				DBDAOERR(3102) //Circular reference caused by '|'.
#define E_DAO_OutputAliasCycle				DBDAOERR(3103) //Circular reference caused by alias '|' in query definition's SELECT list.
#define E_DAO_QryDuplicatedFixedSetM		DBDAOERR(3104) //Can't specify Fixed Column Heading '|' in a crosstab query more than once.
#define E_DAO_NoSelectIntoColumnName		DBDAOERR(3105) //Missing destination field name in SELECT INTO statement (|).
#define E_DAO_NoUpdateColumnName			DBDAOERR(3106) //Missing destination field name in UPDATE statement (|).
#define E_DAO_QueryNoInsertPerm				DBDAOERR(3107) //Record(s) can't be added; no Insert Data permission on '|'.
#define E_DAO_QueryNoReplacePerm			DBDAOERR(3108) //Record(s) can't be edited; no Update Data permission on '|'.
#define E_DAO_QueryNoDeletePerm				DBDAOERR(3109) //Record(s) can't be deleted; no Delete Data permission on '|'.
#define E_DAO_QueryNoReadDefPerm			DBDAOERR(3110) //Couldn't read definitions; no Read Design permission for table or query '|'.
#define E_DAO_QueryNoTblCrtPerm				DBDAOERR(3111) //Couldn't create; no Create permission for table or query '|'.
#define E_DAO_QueryNoReadPerm				DBDAOERR(3112) //Record(s) can't be read; no Read Data permission on '|'.
#define E_DAO_QueryColNotUpd				DBDAOERR(3113) //Can't update '|'; field not updatable.
#define E_DAO_QueryLVInDistinct				DBDAOERR(3114) //Can't include Memo or OLE object when you select unique values (|).
#define E_DAO_QueryLVInAggregate			DBDAOERR(3115) //Can't have Memo or OLE object in aggregate argument (|).
#define E_DAO_QueryLVInHaving				DBDAOERR(3116) //Can't have Memo or OLE object in criteria (|) for aggregate function.
#define E_DAO_QueryLVInOrderBy				DBDAOERR(3117) //Can't sort on Memo or OLE object (|).
#define E_DAO_QueryLVInJoin					DBDAOERR(3118) //Can't join on Memo or OLE object (|).
#define E_DAO_QueryLVInGroupBy				DBDAOERR(3119) //Can't group on Memo or OLE object (|).
#define E_DAO_DotStarWithGrouping			DBDAOERR(3120) //Can't group on fields selected with '*' (|).
#define E_DAO_StarWithGrouping				DBDAOERR(3121) //Can't group on fields selected with '*'.
#define E_DAO_IllegalDetailRef				DBDAOERR(3122) //'|' not part of aggregate function or grouping.
#define E_DAO_StarNotAtLevel0				DBDAOERR(3123) //Can't use '*' in crosstab query.
#define E_DAO_QueryInvalidMGBInput			DBDAOERR(3124) //Can't input from internal report query (|).
#define E_DAO_InvalidName					DBDAOERR(3125) //'|' isn't a valid name.
#define E_DAO_QueryBadBracketing			DBDAOERR(3126) //Invalid bracketing of name '|'.
#define E_DAO_InsertIntoUnknownCol			DBDAOERR(3127) //INSERT INTO statement contains unknown field name '|'.
#define E_DAO_QueryNoDeleteTables			DBDAOERR(3128) //Must specify tables to delete from.
#define E_DAO_SQLSyntax						DBDAOERR(3129) //Invalid SQL statement; expected 'DELETE', 'INSERT', 'PROCEDURE', 'SELECT', or 'UPDATE'.
#define E_DAO_SQLDeleteSyntax				DBDAOERR(3130) //Syntax error in DELETE statement.
#define E_DAO_SQLFromSyntax					DBDAOERR(3131) //Syntax error in FROM clause.
#define E_DAO_SQLGroupBySyntax				DBDAOERR(3132) //Syntax error in GROUP BY clause.
#define E_DAO_SQLHavingSyntax				DBDAOERR(3133) //Syntax error in HAVING clause.
#define E_DAO_SQLInsertSyntax				DBDAOERR(3134) //Syntax error in INSERT statement.
#define E_DAO_SQLJoinSyntax					DBDAOERR(3135) //Syntax error in JOIN operation.
#define E_DAO_SQLLevelSyntax				DBDAOERR(3136) //Syntax error in LEVEL clause.
#define E_DAO_SQLMissingSemicolon			DBDAOERR(3137) //Missing semicolon (;) at end of SQL statement.
#define E_DAO_SQLOrderBySyntax				DBDAOERR(3138) //Syntax error in ORDER BY clause.
#define E_DAO_SQLParameterSyntax			DBDAOERR(3139) //Syntax error in PARAMETER clause.
#define E_DAO_SQLProcedureSyntax			DBDAOERR(3140) //Syntax error in PROCEDURE clause.
#define E_DAO_SQLSelectSyntax				DBDAOERR(3141) //Syntax error in SELECT statement.
#define E_DAO_SQLTooManyTokens				DBDAOERR(3142) //Characters found after end of SQL statement.
#define E_DAO_SQLTransformSyntax			DBDAOERR(3143) //Syntax error in TRANSFORM statement.
#define E_DAO_SQLUpdateSyntax				DBDAOERR(3144) //Syntax error in UPDATE statement.
#define E_DAO_SQLWhereSyntax				DBDAOERR(3145) //Syntax error in WHERE clause.
#define E_DAO_RmtSQLCError					DBDAOERR(3146) //ODBC--call failed.
#define E_DAO_RmtDataOverflow				DBDAOERR(3147) //*
#define E_DAO_RmtConnectFailed				DBDAOERR(3148) //*
#define E_DAO_RmtIncorrectSqlcDll			DBDAOERR(3149) //*
#define E_DAO_RmtMissingSqlcDll				DBDAOERR(3150) //*
#define E_DAO_RmtConnectFailedM				DBDAOERR(3151) //ODBC--connection to '|' failed.
#define E_DAO_RmtDrvrVer					DBDAOERR(3152) //*
#define E_DAO_RmtSrvrVer					DBDAOERR(3153) //*
#define E_DAO_RmtMissingOdbcDll				DBDAOERR(3154) //ODBC--couldn't find DLL '|'.
#define E_DAO_RmtInsertFailedM				DBDAOERR(3155) //ODBC--insert failed on attached (linked) table '|'.
#define E_DAO_RmtDeleteFailedM				DBDAOERR(3156) //ODBC--delete failed on attached (linked) table '|'.
#define E_DAO_RmtUpdateFailedM				DBDAOERR(3157) //ODBC--update failed on attached (linked) table '|'.
#define E_DAO_RecordLocked					DBDAOERR(3158) //Couldn't save record; currently locked by another user.
#define E_DAO_InvalidBookmark				DBDAOERR(3159) //Not a valid bookmark.
#define E_DAO_TableNotOpen					DBDAOERR(3160) //Table isn't open.
#define E_DAO_DecryptFail					DBDAOERR(3161) //Couldn't decrypt file.
#define E_DAO_NullInvalid					DBDAOERR(3162) //Null is invalid.
#define E_DAO_InvalidBufferSize				DBDAOERR(3163) //Couldn't perform operation; data too long for field.
#define E_DAO_ColumnNotUpdatable			DBDAOERR(3164) //Field can't be updated.
#define E_DAO_CantMakeINFFile				DBDAOERR(3165) //Couldn't open .INF file.
#define E_DAO_MissingMemoFile				DBDAOERR(3166) //Missing memo file.
#define E_DAO_RecordDeleted					DBDAOERR(3167) //Record is deleted.
#define E_DAO_INFFileError					DBDAOERR(3168) //Invalid .INF file.
#define E_DAO_ExprIllegalType				DBDAOERR(3169) //Illegal type in expression.
#define E_DAO_InstalIsamNotFound			DBDAOERR(3170) //Couldn't find installable ISAM.
#define E_DAO_NoConfigParameters			DBDAOERR(3171) //Couldn't find net path or user name.
#define E_DAO_CantAccessPdoxNetDir			DBDAOERR(3172) //Couldn't open PARADOX.NET.
#define E_DAO_NoMSysAccounts				DBDAOERR(3173) //Couldn't open table 'MSysAccounts' in the system database file.
#define E_DAO_NoMSysGroups					DBDAOERR(3174) //Couldn't open table 'MSysGroups' in the system database file.
#define E_DAO_DateOutOfRange				DBDAOERR(3175) //Date is out of range or is in an invalid format.
#define E_DAO_ImexCantOpenFile				DBDAOERR(3176) //Couldn't open file '|'.
#define E_DAO_ImexBadTableName				DBDAOERR(3177) //Not a valid table name.
#define E_DAO_ImexOutOfMemory				DBDAOERR(3178) //*
#define E_DAO_ImexEndofFile					DBDAOERR(3179) //Encountered unexpected end of file.
#define E_DAO_ImexCantWriteToFile			DBDAOERR(3180) //Couldn't write to file '|'.
#define E_DAO_ImexBadRange					DBDAOERR(3181) //Invalid range.
#define E_DAO_ImexBogusFile					DBDAOERR(3182) //Invalid file format.
#define E_DAO_TempDiskFull					DBDAOERR(3183) //Not enough space on temporary disk.
#define E_DAO_RmtLinkNotFound				DBDAOERR(3184) //Couldn't execute query; couldn't find attached, or linked, table.
#define E_DAO_RmtTooManyColumns				DBDAOERR(3185) //SELECT INTO remote database tried to produce too many fields.
#define E_DAO_ReadConflictM					DBDAOERR(3186) //Couldn't save; currently locked by user '|2' on machine '|1'.
#define E_DAO_CommitConflictM				DBDAOERR(3187) //Couldn't read; currently locked by user '|2' on machine '|1'.
#define E_DAO_SessionWriteConflict			DBDAOERR(3188) //Couldn't update; currently locked by another session on this machine.
#define E_DAO_JetSpecialTableLocked			DBDAOERR(3189) //Table '|1' is exclusively locked by user '|3' on machine '|2'.
#define E_DAO_TooManyColumns				DBDAOERR(3190) //Too many fields defined.
#define E_DAO_ColumnDuplicate				DBDAOERR(3191) //Can't define field more than once.
#define E_DAO_OutputTableNotFound			DBDAOERR(3192) //Couldn't find output table '|'.
#define E_DAO_JetNoUserName					DBDAOERR(3193) //(unknown)
#define E_DAO_JetNoMachineName				DBDAOERR(3194) //(unknown)
#define E_DAO_JetNoColumnName				DBDAOERR(3195) //(expression)
#define E_DAO_DatabaseInUse					DBDAOERR(3196) //Couldn't use '|'; database already in use.
#define E_DAO_DataHasChanged				DBDAOERR(3197) //Data has changed; operation stopped.
#define E_DAO_TooManySessions				DBDAOERR(3198) //Couldn't start session.  Too many sessions already active.
#define E_DAO_ReferenceNotFound				DBDAOERR(3199) //Couldn't find reference.
#define E_DAO_IntegrityViolMasterM			DBDAOERR(3200) //Can't delete or change record.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_IntegrityViolSlaveM			DBDAOERR(3201) //Can't add or change record.  Referential integrity rules require a related record in table '|'.
#define E_DAO_ReadConflict					DBDAOERR(3202) //Couldn't save; currently locked by another user.
#define E_DAO_AggregatingHigherLevel		DBDAOERR(3203) //Can't specify subquery in expression (|).
#define E_DAO_DatabaseDuplicate				DBDAOERR(3204) //Database already exists.
#define E_DAO_QueryTooManyXvtColumn			DBDAOERR(3205) //Too many crosstab column headers (|).
#define E_DAO_SelfReference					DBDAOERR(3206) //Can't create a relationship between a field and itself.
#define E_DAO_CantUseUnkeyedTable			DBDAOERR(3207) //Operation not supported on Paradox table with no primary key.
#define E_DAO_IllegalDeletedOption			DBDAOERR(3208) //Invalid Deleted entry in the Xbase section of initialization setting.
#define E_DAO_IllegalStatsOption			DBDAOERR(3209) //Invalid Stats entry in the Xbase section of initialization setting.
#define E_DAO_ConnStrTooLong				DBDAOERR(3210) //Connection string too long.
#define E_DAO_TableInUseQM					DBDAOERR(3211) //Couldn't lock table '|'; currently in use.
#define E_DAO_JetSpecialTableInUse			DBDAOERR(3212) //Couldn't lock table '|1'; currently in use by user '|3' on machine '|2'.
#define E_DAO_IllegalDateOption				DBDAOERR(3213) //Invalid Date entry in the Xbase section of initialization setting.
#define E_DAO_IllegalMarkOption				DBDAOERR(3214) //Invalid Mark entry in the Xbase section of initialization setting.
#define E_DAO_BtrieveTooManyTasks			DBDAOERR(3215) //Too many Btrieve tasks.
#define E_DAO_QueryParmNotTableid			DBDAOERR(3216) //Parameter '|' specified where a table name is required.
#define E_DAO_QueryParmNotDatabase			DBDAOERR(3217) //Parameter '|' specified where a database name is required.
#define E_DAO_WriteConflict					DBDAOERR(3218) //Couldn't update; currently locked.
#define E_DAO_IllegalOperation				DBDAOERR(3219) //Invalid operation.
#define E_DAO_WrongCollatingSequence		DBDAOERR(3220) //Incorrect collating sequence.
#define E_DAO_BadConfigParameters			DBDAOERR(3221) //Invalid entries in the Btrieve section of initialization setting.
#define E_DAO_QueryContainsDbParm			DBDAOERR(3222) //Query can't contain a Database parameter.
#define E_DAO_QueryInvalidParmM				DBDAOERR(3223) //'|' isn't a valid parameter name.
#define E_DAO_BtrieveDDCorrupted			DBDAOERR(3224) //Can't read Btrieve data dictionary.
#define E_DAO_BtrieveDeadlock				DBDAOERR(3225) //Encountered record locking deadlock while performing Btrieve operation.
#define E_DAO_BtrieveFailure				DBDAOERR(3226) //Errors encountered while using the Btrieve DLL.
#define E_DAO_IllegalCenturyOption			DBDAOERR(3227) //Invalid Century entry in the Xbase section of initialization setting.
#define E_DAO_IllegalCollatingSeq			DBDAOERR(3228) //Invalid Collating Sequence.
#define E_DAO_NonModifiableKey				DBDAOERR(3229) //Btrieve--can't change field.
#define E_DAO_ObsoleteLockFile				DBDAOERR(3230) //Out-of-date Paradox lock file.
#define E_DAO_RmtColDataTruncated			DBDAOERR(3231) //ODBC--field would be too long; data truncated.
#define E_DAO_RmtCreateTableFailed			DBDAOERR(3232) //ODBC--couldn't create table.
#define E_DAO_RmtOdbcVer					DBDAOERR(3233) //*
#define E_DAO_RmtQueryTimeout				DBDAOERR(3234) //ODBC--remote query timeout expired.
#define E_DAO_RmtTypeIncompat				DBDAOERR(3235) //ODBC--data type not supported on server.
#define E_DAO_RmtUnexpectedNull				DBDAOERR(3236) //*
#define E_DAO_RmtUnexpectedType				DBDAOERR(3237) //*
#define E_DAO_RmtValueOutOfRange			DBDAOERR(3238) //ODBC--data out of range.
#define E_DAO_TooManyActiveUsers			DBDAOERR(3239) //Too many active users.
#define E_DAO_CantStartBtrieve				DBDAOERR(3240) //Btrieve--missing Btrieve engine.
#define E_DAO_OutOfBVResources				DBDAOERR(3241) //Btrieve--out of resources.
#define E_DAO_QueryBadUpwardRefedM			DBDAOERR(3242) //Invalid reference in SELECT statement.
#define E_DAO_ImexNoMatchingColumns			DBDAOERR(3243) //None of the import field names match fields in the appended table.
#define E_DAO_ImexPasswordProtected			DBDAOERR(3244) //Can't import password-protected spreadsheet.
#define E_DAO_ImexUnparsableRecord			DBDAOERR(3245) //Couldn't parse field names from first row of import table.
#define E_DAO_InTransaction					DBDAOERR(3246) //Operation not supported in transactions.
#define E_DAO_RmtLinkOutOfSync				DBDAOERR(3247) //ODBC--linked table definition has changed.
#define E_DAO_IllegalNetworkOption			DBDAOERR(3248) //Invalid NetworkAccess entry in initialization setting.
#define E_DAO_IllegalTimeoutOption			DBDAOERR(3249) //Invalid PageTimeout entry in initialization setting.
#define E_DAO_CantBuildKey					DBDAOERR(3250) //Couldn't build key.
#define E_DAO_FeatureNotAvailable			DBDAOERR(3251) //Operation is not supported for this type of object.
#define E_DAO_IllegalReentrancy				DBDAOERR(3252) //Can't open form whose underlying query contains a user-defined function that attempts to set or get the form's RecordsetClone property.
#define E_DAO_UNUSED						DBDAOERR(3253) //*
#define E_DAO_RmtDenyWriteIsInvalid			DBDAOERR(3254) //ODBC--Can't lock all records.
#define E_DAO_ODBCParmsChanged				DBDAOERR(3255) //*
#define E_DAO_INFIndexNotFound 				DBDAOERR(3256) //Index file not found.
#define E_DAO_SQLOwnerAccessSyntax			DBDAOERR(3257) //Syntax error in WITH OWNERACCESS OPTION declaration.
#define E_DAO_QueryAmbiguousJoins			DBDAOERR(3258) //Query contains ambiguous outer joins.
#define E_DAO_InvalidColumnType				DBDAOERR(3259) //Invalid field data type.
#define E_DAO_WriteConflictM				DBDAOERR(3260) //Couldn't update; currently locked by user '|2' on machine '|1'.
#define E_DAO_TableLockedM					DBDAOERR(3261) //|
#define E_DAO_TableInUseMUQM				DBDAOERR(3262) //|
#define E_DAO_InvalidTableId				DBDAOERR(3263) //Invalid database object.
#define E_DAO_VtoNoFields					DBDAOERR(3264) //No fields defined - cannot append Tabledef or Index.
#define E_DAO_VtoNameNotFound				DBDAOERR(3265) //Item not found in this collection.
#define E_DAO_VtoFieldInCollection			DBDAOERR(3266) //Can't append.  Field is part of a TableDefs collection.
#define E_DAO_VtoNotARecordset				DBDAOERR(3267) //Property can be set only when the field is part of a Recordset object's Fields collection.
#define E_DAO_VtoNoSetObjInDb				DBDAOERR(3268) //Can't set this property once the object is part of a collection.
#define E_DAO_VtoIndexInCollection			DBDAOERR(3269) //Can't append.  Index is part of a TableDefs collection.
#define E_DAO_VtoPropNotFound				DBDAOERR(3270) //Property not found.
#define E_DAO_VtoIllegalValue				DBDAOERR(3271) //Invalid property value.
#define E_DAO_VtoNotArray					DBDAOERR(3272) //Object isn't a collection.
#define E_DAO_VtoNoSuchMethod				DBDAOERR(3273) //Method not applicable for this object.
#define E_DAO_NotExternalFormat				DBDAOERR(3274) //External table isn't in the expected format.
#define E_DAO_UnexpectedEngineReturn		DBDAOERR(3275) //Unexpected error from external database driver (|).
#define E_DAO_InvalidDatabaseId				DBDAOERR(3276) //Invalid database ID.
#define E_DAO_TooManyKeys					DBDAOERR(3277) //Can't have more than 10 fields in an index.
#define E_DAO_NotInitialized				DBDAOERR(3278) //Database engine hasn't been initialized.
#define E_DAO_AlreadyInitialized			DBDAOERR(3279) //Database engine has already been initialized.
#define E_DAO_ColumnInUse					DBDAOERR(3280) //Can't delete a field that is part of an index or is needed by the system.
#define E_DAO_IndexInUse					DBDAOERR(3281) //Can't delete this index.  It is either the current index or is used in a relationship.
#define E_DAO_TableNotEmpty					DBDAOERR(3282) //Can't create field or index in a table that is already defined.
#define E_DAO_IndexHasPrimary				DBDAOERR(3283) //Primary key already exists.
#define E_DAO_IndexDuplicate				DBDAOERR(3284) //Index already exists.
#define E_DAO_IndexInvalidDef				DBDAOERR(3285) //Invalid index definition.
#define E_DAO_WrongMemoFileType				DBDAOERR(3286) //Format of memo file doesn't match specified external database format.
#define E_DAO_ColumnCannotIndex				DBDAOERR(3287) //Can't create index on the given field.
#define E_DAO_IndexHasNoPrimary				DBDAOERR(3288) //Paradox index is not primary.
#define E_DAO_DDLConstraintSyntax			DBDAOERR(3289) //Syntax error in CONSTRAINT clause.
#define E_DAO_DDLCreateTableSyntax			DBDAOERR(3290) //Syntax error in CREATE TABLE statement.
#define E_DAO_DDLCreateIndexSyntax			DBDAOERR(3291) //Syntax error in CREATE INDEX statement.
#define E_DAO_DDLColumnDefSyntax			DBDAOERR(3292) //Syntax error in field definition.
#define E_DAO_DDLAlterTableSyntax			DBDAOERR(3293) //Syntax error in ALTER TABLE statement.
#define E_DAO_DDLDropIndexSyntax			DBDAOERR(3294) //Syntax error in DROP INDEX statement.
#define E_DAO_DDLDropSyntax					DBDAOERR(3295) //Syntax error in DROP TABLE or DROP INDEX.
#define E_DAO_V11NotSupported				DBDAOERR(3296) //Join expression not supported.
#define E_DAO_ImexNothingToImport			DBDAOERR(3297) //Couldn't import table or query.  No records found, or all records contain errors.
#define E_DAO_RmtTableAmbiguous				DBDAOERR(3298) //There are several tables with that name.  Please specify owner in the format 'owner.table'.
#define E_DAO_JetODBCConformanceError		DBDAOERR(3299) //ODBC Specification Conformance Error (|).  This error should be reported to the ODBC driver vendor.
#define E_DAO_IllegalRelationship			DBDAOERR(3300) //Can't create a relationship.
#define E_DAO_DBVerFeatureNotAvailable		DBDAOERR(3301) //Can't perform this operation; features in this version are not available in databases with older formats.
#define E_DAO_RulesLoaded					DBDAOERR(3302) //Can't change a rule while the rules for this table are in use.
#define E_DAO_ColumnInRelationship			DBDAOERR(3303) //Can't delete this field.  It's part of one or more relationships.
#define E_DAO_InvalidPin					DBDAOERR(3304) //You must enter a personal identifier (PID) consisting of at least four and no more than 20 characters and digits.
#define E_DAO_RmtBogusConnStr				DBDAOERR(3305) //Invalid connection string in pass-through query.
#define E_DAO_SingleColumnExpected			DBDAOERR(3306) //At most one field can be returned from a subquery that doesn't use the EXISTS keyword.
#define E_DAO_ColumnCountMismatch			DBDAOERR(3307) //The number of columns in the two selected tables or queries of a union query don't match.
#define E_DAO_InvalidTopArgumentM			DBDAOERR(3308) //Invalid TOP argument in select query.
#define E_DAO_PropertyTooLarge				DBDAOERR(3309) //Property setting can't be larger than 2 KB.
#define E_DAO_JPMInvalidForV1x				DBDAOERR(3310) //This property isn't supported for external data sources or for databases created in a previous version.
#define E_DAO_PropertyExists				DBDAOERR(3311) //Property specified already exists.
#define E_DAO_TLVNativeUserTablesOnly		DBDAOERR(3312) //Validation rules and default values can't be placed on system or attached (linked) tables.
#define E_DAO_TLVInvalidColumn				DBDAOERR(3313) //Can't place this validation expression on this field.
#define E_DAO_TLVNoNullM					DBDAOERR(3314) //Field '|' can't contain a null value.
#define E_DAO_TLVNoBlankM					DBDAOERR(3315) //Field '|' can't be a zero-length string.
#define E_DAO_TLVRuleViolationM				DBDAOERR(3316) //|
#define E_DAO_TLVRuleVioNoMessage			DBDAOERR(3317) //One or more values entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_QueryTopNotAllowedM			DBDAOERR(3318) //Top not allowed in delete queries.
#define E_DAO_SQLUnionSyntax				DBDAOERR(3319) //Syntax error in union query.
#define E_DAO_TLVExprSyntaxM				DBDAOERR(3320) //| in table-level validation expression.
#define E_DAO_NoDbInConnStr					DBDAOERR(3321) //No database specified in connection string or IN clause.
#define E_DAO_QueryBadValueListM			DBDAOERR(3322) //Crosstab query contains one or more invalid fixed column headings.
#define E_DAO_QueryIsNotRowReturning		DBDAOERR(3323) //The query can not be used as a row source.
#define E_DAO_QueryIsDDL					DBDAOERR(3324) //This query is a DDL query and cannot be used as a row source.
#define E_DAO_SPTReturnedNoRecords			DBDAOERR(3325) //Pass-through query with ReturnsRecords property set to True did not return any records.
#define E_DAO_QueryIsSnapshot				DBDAOERR(3326) //This Recordset is not updatable.
#define E_DAO_QueryExprOutput				DBDAOERR(3327) //Field '|' is based on an expression and can't be edited.
#define E_DAO_QueryTableRO					DBDAOERR(3328) //Table '|2' is read-only.
#define E_DAO_QueryRowDeleted				DBDAOERR(3329) //Record in table '|' was deleted by another user.
#define E_DAO_QueryRowLocked				DBDAOERR(3330) //Record in table '|' is locked by another user.
#define E_DAO_QueryFixupChanged				DBDAOERR(3331) //To make changes to this field, first save the record.
#define E_DAO_QueryCantFillIn				DBDAOERR(3332) //Can't enter value into blank field on 'one' side of outer join.
#define E_DAO_QueryWouldOrphan				DBDAOERR(3333) //Records in table '|' would have no record on the 'one' side.
#define E_DAO_V10Format						DBDAOERR(3334) //Can be present only in version 1.0 format.
#define E_DAO_InvalidDelete					DBDAOERR(3335) //DeleteOnly called with non-zero cbData.
#define E_DAO_IllegalIndexDDFOption			DBDAOERR(3336) //Btrieve: Invalid IndexDDF option in initialization setting.
#define E_DAO_IllegalDataCodePage			DBDAOERR(3337) //Invalid DataCodePage option in initialization setting.
#define E_DAO_XtrieveEnvironmentError		DBDAOERR(3338) //Btrieve: Xtrieve options aren't correct in initialization setting.
#define E_DAO_IllegalIndexNumberOption		DBDAOERR(3339) //Btrieve: Invalid IndexDeleteRenumber option in initialization setting.
#define E_DAO_QueryIsCorruptM				DBDAOERR(3340) //Query '|' is corrupt.
#define E_DAO_IncorrectJoinKeyM				DBDAOERR(3341) //Current field must match join key '|' on 'one' side of outer join because it has been updated.
#define E_DAO_QueryLVInSubqueryM			DBDAOERR(3342) //Invalid Memo or OLE object in subquery '|'.
#define E_DAO_InvalidDatabaseM				DBDAOERR(3343) //Unrecognized database format '|'.
#define E_DAO_TLVCouldNotBindRef			DBDAOERR(3344) //Unknown or invalid reference '|1' in validation expression or default value in table '|2'.
#define E_DAO_CouldNotBindRef				DBDAOERR(3345) //Unknown or invalid field reference '|'.
#define E_DAO_QueryWrongNumDestCol			DBDAOERR(3346) //Number of query values and destination fields aren't the same.
#define E_DAO_QueryPKeyNotOutput			DBDAOERR(3347) //Can't add record(s); primary key for table '|' not in recordset.
#define E_DAO_QueryJKeyNotOutput			DBDAOERR(3348) //Can't add record(s); join key of table '|' not in recordset.
#define E_DAO_NumericFieldOverflow			DBDAOERR(3349) //Numeric field overflow.
#define E_DAO_InvalidObject					DBDAOERR(3350) //Object is invalid for operation.
#define E_DAO_OrderVsUnion					DBDAOERR(3351) //ORDER BY expression (|) uses non-output fields.
#define E_DAO_NoInsertColumnNameM			DBDAOERR(3352) //No destination field name in INSERT INTO statement (|).
#define E_DAO_MissingDDFFile				DBDAOERR(3353) //Btrieve: Can't find file FIELD.DDF.
#define E_DAO_SingleRecordExpected			DBDAOERR(3354) //At most one record can be returned by this subquery.
#define E_DAO_DefaultExprSyntax				DBDAOERR(3355) //Syntax error in default value.
#define E_DAO_ExclusiveDBConflict			DBDAOERR(3356) //The database is opened by user '|2' on machine '|1'.
#define E_DAO_QueryIsNotDDL					DBDAOERR(3357) //This query is not a properly formed data-definition query.
#define E_DAO_SysDatabaseOpenError			DBDAOERR(3358) //Can't open Microsoft Jet engine system database.
#define E_DAO_SQLInvalidSPT					DBDAOERR(3359) //Pass-through query must contain at least one character.
#define E_DAO_QueryTooComplex				DBDAOERR(3360) //Query is too complex.
#define E_DAO_SetOpInvalidInSubquery		DBDAOERR(3361) //Unions not allowed in a subquery.
#define E_DAO_RmtMultiRowUpdate				DBDAOERR(3362) //Single-row update/delete affected more than one row of an attached (linked) table.  Unique index contains duplicate values.
#define E_DAO_QueryNoJoinedRecord			DBDAOERR(3363) //Record(s) can't be added; no corresponding record on the 'one' side.
#define E_DAO_QueryLVInSetOp				DBDAOERR(3364) //Can't use Memo or OLE object field '|' in SELECT clause of a union query.
#define E_DAO_VtoInvalidOnRemote			DBDAOERR(3365) //Property value not valid for REMOTE objects.
#define E_DAO_VtoNoFieldsRel				DBDAOERR(3366) //Can't append a relation with no fields defined.
#define E_DAO_VtoObjectInCollection			DBDAOERR(3367) //Can't append.  Object already in collection.
#define E_DAO_DDLDiffNumRelCols				DBDAOERR(3368) //Relationship must be on the same number of fields with the same data types.
#define E_DAO_DDLIndexColNotFound			DBDAOERR(3369) //Can't find field in index definition.
#define E_DAO_DDLPermissionDenied			DBDAOERR(3370) //Can't modify the design of table '|'.  It's in a read-only database.
#define E_DAO_DDLObjectNotFound				DBDAOERR(3371) //Can't find table or constraint.
#define E_DAO_DDLIndexNotFound				DBDAOERR(3372) //No such index '|2' on table '|1'.
#define E_DAO_DDLNoPkeyOnRefdTable			DBDAOERR(3373) //Can't create relationship.  Referenced table '|' doesn't have a primary key.
#define E_DAO_DDLColumnsNotUnique			DBDAOERR(3374) //The specified fields are not uniquely indexed in table '|'.
#define E_DAO_DDLIndexDuplicate				DBDAOERR(3375) //Table '|1' already has an index named '|2'
#define E_DAO_DDLTableNotFound				DBDAOERR(3376) //Table '|' doesn't exist.
#define E_DAO_DDLRelNotFound				DBDAOERR(3377) //No such relationship '|2' on table '|1'.
#define E_DAO_DDLRelDuplicate				DBDAOERR(3378) //There is already a relationship named '|' in the current database.
#define E_DAO_DDLIntegrityViolation			DBDAOERR(3379) //Can't create relationships to enforce referential integrity.  Existing data in table '|2' violates referential integrity rules with related table '|1'.
#define E_DAO_DDLColumnDuplicate			DBDAOERR(3380) //Field '|2' already exists in table '|1'.
#define E_DAO_DDLColumnNotFound				DBDAOERR(3381) //There is no field named '|2' in table '|1'.
#define E_DAO_DDLColumnTooBig				DBDAOERR(3382) //The size of field '|' is too long.
#define E_DAO_DDLColumnInRel				DBDAOERR(3383) //Can't delete field '|'.  It's part of one or more relationships.
#define E_DAO_VtoCantDeleteBuiltIn			DBDAOERR(3384) //Can't delete a built-in property.
#define E_DAO_VtoUDPsDontSupportNull		DBDAOERR(3385) //User-defined properties don't support a Null value.
#define E_DAO_VtoMissingRequiredParm		DBDAOERR(3386) //Property '|' must be set before using this method.
#define E_DAO_JetJetInitInvalidPath			DBDAOERR(3387) //Can't find TEMP directory.
#define E_DAO_TLVExprUnknownFunctionM		DBDAOERR(3388) //Unknown function '|2' in validation expression or default value on '|1'.
#define E_DAO_QueryNotSupported				DBDAOERR(3389) //Query support unavailable.
#define E_DAO_AccountDuplicate				DBDAOERR(3390) //Account name already exists.
#define E_DAO_JetwrnPropCouldNotSave		DBDAOERR(3391) //An error has occurred.  Properties were not saved.
#define E_DAO_RelNoPrimaryIndexM			DBDAOERR(3392) //There is no primary key in table '|'.
#define E_DAO_QueryKeyTooBig				DBDAOERR(3393) //Can't perform join, group, sort, or indexed restriction. A value being searched or sorted on is too long.
#define E_DAO_PropMustBeDDL					DBDAOERR(3394) //Can't save property; property is a schema property.
#define E_DAO_IllegalRIConstraint			DBDAOERR(3395) //Invalid referential integrity constraint.
#define E_DAO_RIViolationMasterCM			DBDAOERR(3396) //Can't perform cascading operation.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_RIViolationSlaveCM			DBDAOERR(3397) //Can't perform cascading operation.  There must be a related record in table '|'.
#define E_DAO_RIKeyNullDisallowedCM			DBDAOERR(3398) //Can't perform cascading operation.  It would result in a null key in table '|'.
#define E_DAO_RIKeyDuplicateCM				DBDAOERR(3399) //Can't perform cascading operation.  It would result in a duplicate key in table '|'.
#define E_DAO_RIUpdateTwiceCM				DBDAOERR(3400) //Can't perform cascading operation.  It would result in two updates on field '|2' in table '|1'.
#define E_DAO_RITLVNoNullCM					DBDAOERR(3401) //Can't perform cascading operation.  It would cause field '|' to become null, which is not allowed.
#define E_DAO_RITLVNoBlankCM				DBDAOERR(3402) //Can't perform cascading operation.  It would cause field '|' to become a zero-length string, which is not allowed.
#define E_DAO_RITLVRuleViolationCM			DBDAOERR(3403) //Can't perform cascading operation:  '|'
#define E_DAO_RITLVRuleVioCNoMessage		DBDAOERR(3404) //Can't perform cascading operation.  The value entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_TLVRuleEvalEBESErr			DBDAOERR(3405) //Error '|' in validation rule.
#define E_DAO_TLVDefaultEvalEBESErr			DBDAOERR(3406) //Error '|' in default value.
#define E_DAO_BadMSysConf					DBDAOERR(3407) //The server's MSysConf table exists, but is in an incorrect format.  Contact your system administrator.
#define E_DAO_TooManyFindSessions			DBDAOERR(3408) //Too many FastFind Sessions were invoked.
#define E_DAO_InvalidColumnM				DBDAOERR(3409) //Invalid field name '|' in definition of index or relationship.
#define E_DAO_REPReadOnly					DBDAOERR(3410) //*
#define E_DAO_RIInvalidBufferSizeCM			DBDAOERR(3411) //Invalid entry.  Can't perform cascading operation specified in table '|1' because value entered is too big for field '|2'.
#define E_DAO_RIWriteConflictCM				DBDAOERR(3412) //|
#define E_DAO_JetSpecialRIWriteConflictCM	DBDAOERR(3413) //Can't perform cascading update on table '|1' because it is currently in use by user '|3' on machine '|2'.
#define E_DAO_RISessWriteConflictCM			DBDAOERR(3414) //Can't perform cascading update on table '|' because it is currently in use.
#define E_DAO_NoBlank						DBDAOERR(3415) //Zero-length string is valid only in a text or Memo field.
#define E_DAO_FutureError					DBDAOERR(3416) //|
#define E_DAO_QueryInvalidBulkInput			DBDAOERR(3417) //An action query cannot be used as a row source.
#define E_DAO_NetCtrlMismatch				DBDAOERR(3418) //Can't open '|'.  Another user has the table open using a different network control file or locking style.
#define E_DAO_4xTableWith3xLocking			DBDAOERR(3419) //Can't open this Paradox 4.x or Paradox 5.x table because ParadoxNetStyle is set to 3.x in the initialization setting.
#define E_DAO_VtoObjectNotSet				DBDAOERR(3420) //Object is invalid or not set.
#define E_DAO_VtoDataConvError				DBDAOERR(3421) //Data type conversion error.

#endif // def _DBDAOERR.H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\dbdao.h ===
/************************************************************************
**      D B D A O . H                                                   *
**                                                                      *
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation			                *
**                 All Rights Reserved                                  *
************************************************************************/
/*
	DBDAO.H

	Class definitions for ddao SDK.  

This is a part of the Microsoft Data Access Objects SDK library.
See the  DAO SDK help information for detailed information regarding the
Microsoft Data Access Objects SDK product.

*/

#ifndef _DBDAO_H_
#define _DBDAO_H_

// Ignore warning "non dll-interface class 'X' used as base for dll-interface class 'Y'
#pragma warning( disable : 4275 )

//DAO must be built with an MFC version >= 4.2 (or you'll get memory problems with CStrings)

#if _MFC_VER < 0x0420
#error The DAOSDK 3.5 libraries will not operate correctly if built with MFC older than 4.2
#endif

#ifndef DAO35
#define DAO35
#endif

#include <dbdaoint.h>
#include <daogetrw.h>
#include <dbdaoid.h>

// Decorations
#define CONSTRUCTOR
#define DESTRUCTOR

//Disable export
#ifndef DLLEXPORT
#define DLLEXPORT __declspec( dllexport )
#endif

//Macro to convert HRESULT to IDA 
#define DBERR(x) SCODE_CODE(GetScode(x))

// Include internal DAO definitions
#include <_dbdao.h>

//      DAO Recordset::GetRowsEx() binding definitions

#define dbBindIndexINT  1
#define dbBindIndexSTR  2

#define dbBindI2                DAO_I2                  // long
#define dbBindI4                DAO_I4                  // short
#define dbBindR4                DAO_R4                  // float
#define dbBindR8                DAO_R8                  // double
#define dbBindCY                DAO_CURRENCY			// Currency
#define dbBindDATE              DAO_DATE                // DATE
#define dbBindBOOL              DAO_BOOL                // VARIANT_BOOL
#define dbBindUI1               DAO_CHAR                // unsigned char
#define dbBindVARIANT			DAO_ANYVARIANT			// VARIANT
#define dbBindWCHAR             DAO_WCHAR               // wchar_t[] (inline)

#define dbBindBookmark			DAO_BOOKMARK			// bookmark psuedo field
#define dbBindLPSTR				DAO_LPSTR				// \0 string in pvVarBuffer
#define dbBindLPWSTR			DAO_LPWSTR				// wide string in pvVarBuffer
#define dbBindBlob				DAO_BLOB				// 

#ifdef _UNICODE
#define dbBindSTRING    dbBindWCHAR     
#define dbBindLPSTRING	dbBindLPWSTR
#else
#define dbBindSTRING    dbBindUI1
#define dbBindLPSTRING	dbBindLPSTR
#endif

//      Binding structure (Used with GetRowsEX)

typedef struct
	{
	DWORD   dwBindIndexType;
	union
		{
		LONG    i;
		LPCTSTR pstr;
		};

	DWORD   dwType;
	DWORD   dwOffset;
	DWORD   cb;

	} DAORSETBINDING, *LPDAORSETBINDING;



/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;


/*****************************************************************************
* CdbException
*/
class DLLEXPORT CdbException 
	{
public:
	CONSTRUCTOR                     CdbException            (HRESULT hr);

	HRESULT                         m_hr;
	};


/*****************************************************************************
* CdbBookmark
*/
class DLLEXPORT CdbBookmark : public COleVariant
	{
	public:

	CONSTRUCTOR                     CdbBookmark                     (LPSAFEARRAY psa);
	CONSTRUCTOR                     CdbBookmark                     ();
	CONSTRUCTOR                     CdbBookmark                     (const CdbBookmark &);
	CdbBookmark &                   operator =                      (const CdbBookmark &);
	operator                        LPSAFEARRAY                     (VOID);
	};


/*****************************************************************************
* CdbIndexFields (special case for index fields)
*/
class DLLEXPORT CdbIndexFields : public CdbFields
	{
	public:
	CdbField                                Item                            (LPCTSTR pstr);
	CdbField                                Item                            (LONG i);
	CdbObject                               ObItem                          (LPCTSTR pstr);
	CdbObject                               ObItem                          (LONG i);
	};


/*****************************************************************************
* CdbLastOLEError
*/
class DLLEXPORT CdbLastOLEError : public CdbOleObject
	{
	public:

	CONSTRUCTOR                             CdbLastOLEError         (VOID);

	CString                                 GetSource                       (VOID);
	CString                                 GetDescription          (VOID);
	CString                                 GetHelpFile                     (VOID);
	DWORD                                   GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbDBEngine
*/
class DLLEXPORT CdbDBEngine : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDBEngine             (DAODBEngine *peng, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDBEngine             (BOOL bPrivate=FALSE, BOOL bStart=TRUE, LPCTSTR pstrIniPath=NULL, LPCTSTR pstrDefUser=NULL, LPCTSTR pstrDefPW=NULL, LONG lType=dbUseJet);
	CONSTRUCTOR                     CdbDBEngine             (const CdbDBEngine &);
	CdbDBEngine &           operator =                      (const CdbDBEngine &);
	inline CdbWorkspace     operator []                     (LONG lIndex);
	inline CdbWorkspace     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	VOID                            SetDefaultPassword      (LPCTSTR pstr);
	VOID                            SetDefaultUser          (LPCTSTR pstr);
	VOID                            SetIniPath              (LPCTSTR pstr);
	CString                         GetIniPath              (VOID);
	VOID							SetDefaultType			(LONG l);
	LONG							GetDefaultType			(VOID);
	VOID                            SetLoginTimeout         (SHORT s);
	SHORT                           GetLoginTimeout         (VOID);
	CString                         GetVersion              (VOID);
	CString                         GetSystemDB             (VOID);
	VOID                            SetSystemDB             (LPCTSTR pstr);

	// Methods
	CdbWorkspace					CreateWorkspace         (LPCTSTR pstrName, LPCTSTR pstrUser, LPCTSTR pstrPassword, LONG lType=-1);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	VOID                            CompactDatabase			(LPCTSTR pstrOldDatabase, LPCTSTR pstrNewDatabase, LPCTSTR pstrDstConnect = NULL, LONG lOptions=-1, LPCTSTR pstrSrcConnect = NULL);
	VOID                            RepairDatabase          (LPCTSTR pstrDatabase);
	VOID                            RegisterDatabase        (LPCTSTR pstrDatabase, LPCTSTR pstrDriver, BOOL bSilent, LPCTSTR pstrAttributes);
	VOID                            Idle                    (LONG lOptions=-1);
	VOID                            Start                   (VOID);
	VOID							SetOption				(long lOption, LPVARIANT pvValue);
	

	// Collections
	CdbWorkspaces					Workspaces;
	CdbErrors                       Errors;

	private:
	BOOL                            m_bStarted;
	};

/*****************************************************************************
* CdbWorkspace
*/
class DLLEXPORT CdbWorkspace : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbWorkspace            (VOID);
	CONSTRUCTOR                     CdbWorkspace            (DAOWorkspace *pwrk, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbWorkspace            (const CdbWorkspace &);
	CdbWorkspace &          operator =                      (const CdbWorkspace &);
	inline CdbDatabase      operator []                     (LONG lIndex);
	inline CdbDatabase      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	BOOL                            GetIsolateODBCTrans				(VOID);
	VOID                            SetIsolateODBCTrans				(BOOL b);
	LONG							GetType							(VOID);
	LONG							GetDefaultCursorDriver			(VOID);
	VOID							SetDefaultCursorDriver			(LONG l);
	LONG							GetLoginTimeout					(VOID);
	VOID							SetLoginTimeout					(LONG l);

	// Methods
	VOID                            BeginTrans                      (VOID);
	VOID                            CommitTrans                     (LONG lOptions=-1);
	VOID                            Close                           (VOID);
	VOID                            Rollback                        (VOID);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     CreateDatabase          (LPCTSTR pstrName, LPCTSTR pstrConnect, LONG lOption=-1);
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbDatabases					Databases;
	CdbConnections					Connections;
	CdbUsers                        Users;
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbDatabase
*/
class DLLEXPORT CdbDatabase : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDatabase                     (VOID);
	CONSTRUCTOR                     CdbDatabase                     (DAODatabase *pdb, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDatabase                     (const CdbDatabase &);
	CdbDatabase &           operator =                      (const CdbDatabase &);
	inline CdbTableDef      operator []                     (LONG lIndex);
	inline CdbTableDef      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                    GetCollatingOrder       (VOID);
	CString                 GetConnect              (VOID);
	VOID					SetConnect				(LPCTSTR pstrConnect);
	CString                 GetName                 (VOID);
	SHORT                   GetQueryTimeout         (VOID);
	VOID                    SetQueryTimeout         (SHORT s);
	BOOL                    GetTransactions         (VOID);
	BOOL                    GetUpdatable            (VOID);
	CString                 GetVersion              (VOID);
	LONG                    GetRecordsAffected      (VOID);
	CdbConnection			GetConnection			(VOID);
	//Replication properties
	CString					GetReplicaID			(VOID);
	CString					GetDesignMasterID		(VOID);
	VOID					SetDesignMasterID		(LPCTSTR pstrMasterID);


	// Methods
	VOID                    Close                   (VOID);
	VOID                    Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset            OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);
	CdbProperty             CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	CdbRelation             CreateRelation          (LPCTSTR pstrName=NULL, LPCTSTR pstrTable=NULL, LPCTSTR pstrForiegn=NULL, LONG lAttributes=-1);
	CdbTableDef             CreateTableDef          (LPCTSTR pstrName=NULL, LONG lAttributes=-1, LPCTSTR pstrSource=NULL, LPCTSTR pstrConnect=NULL);
	CdbQueryDef             CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID					NewPassword				(LPCTSTR pstrOld, LPCTSTR pstrNew);
	//Replication methods
	VOID                    Synchronize				(LPCTSTR pstrReplica, LONG lType=-1);
	VOID                    MakeReplica				(LPCTSTR pstrPath, LPCTSTR pstrDescription, LONG lOptions=-1);
	VOID					PopulatePartial			(LPCTSTR pstrDbPathName);

	// Collections
	CdbTableDefs            TableDefs;
	CdbQueryDefs            QueryDefs;
	CdbRelations            Relations;
	CdbContainers           Containers;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbConnection
*/
class DLLEXPORT CdbConnection : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbConnection           (VOID);
	CONSTRUCTOR                     CdbConnection           (DAOConnection *pconn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbConnection           (const CdbConnection &);
	CdbConnection &					operator =              (const CdbConnection &);
	inline CdbQueryDef				operator []             (LONG lIndex);
	inline CdbQueryDef				operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetConnect              (VOID);
	CString                         GetName                 (VOID);
	CdbDatabase						GetDatabase				(VOID);
	SHORT                           GetQueryTimeout         (VOID);
	VOID                            SetQueryTimeout         (SHORT s);
	LONG							GetRecordsAffected		(VOID);
	BOOL							GetStillExecuting		(VOID);
	BOOL							GetTransactions         (VOID);
	BOOL                            GetUpdatable            (VOID);

	// Methods
	VOID                            Cancel					(VOID);
	VOID                            Close                   (VOID);
	CdbQueryDef						CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID                            Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset					OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);

	// Collections
	CdbQueryDefs            QueryDefs;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbRecordset
*/
class DLLEXPORT CdbRecordset : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRecordset            (VOID);
	CONSTRUCTOR                     CdbRecordset            (DAORecordset *prs, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRecordset            (const CdbRecordset &);
	CdbRecordset &          operator =                      (const CdbRecordset &);
	inline CdbField     operator []                     (LONG lIndex);
	inline CdbField     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);
	VOID                            SetGetRowsExInt			(VOID);

	// Properties
	BOOL                            GetBOF                          (VOID);
	CdbBookmark                     GetBookmark                     (VOID);
	VOID                            SetBookmark                     (class CdbBookmark);
	BOOL                            GetBookmarkable         (VOID);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	BOOL                            GetEOF                          (VOID);
	CString                         GetFilter                       (VOID);
	VOID                            SetFilter                       (LPCTSTR pstr);
	CString                         GetIndex                        (VOID);
	VOID                            SetIndex                        (LPCTSTR pstr);
	CdbBookmark                     GetLastModified         (VOID);
	BOOL                            GetLockEdits            (VOID);
	VOID                            SetLockEdits            (BOOL b);
	CString                         GetName                         (VOID);
	BOOL                            GetNoMatch                      (VOID);
	CString                         GetSort                         (VOID);
	VOID                            SetSort                         (LPCTSTR pstr);
	BOOL                            GetTransactions         (VOID);
	SHORT                           GetType                         (VOID);
	LONG                            GetRecordCount          (VOID);
	BOOL                            GetUpdatable            (VOID);
	BOOL                            GetRestartable          (VOID);
	CString                         GetValidationText       (VOID);
	CString                         GetValidationRule       (VOID);
	CdbBookmark                     GetCacheStart           (VOID);
	VOID                            SetCacheStart           (CdbBookmark &pbm);
	LONG                            GetCacheSize            (VOID);
	VOID                            SetCacheSize            (LONG l);
	FLOAT                           GetPercentPosition      (VOID);
	VOID                            SetPercentPosition      (FLOAT f);
	LONG                            GetAbsolutePosition     (VOID);
	VOID                            SetAbsolutePosition     (LONG l);
	SHORT                           GetEditMode				(VOID);
	LONG                            GetUpdateOptions		(VOID);
	VOID                            SetUpdateOptions		(LONG l);
	SHORT                           GetRecordStatus			(VOID);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetBatchSize			(VOID);
	VOID                            SetBatchSize			(LONG l);
	LONG                            GetBatchCollisionCount	(VOID);
	COleVariant						GetBatchCollisions		(VOID);
	CdbConnection					GetConnection			(VOID);

	// Methods
	VOID                            CancelUpdate            (short sType = dbUpdateRegular);
	VOID                            AddNew                          (VOID);
	VOID                            Close                           (VOID);
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            Delete                          (VOID);
	VOID                            Edit                            (VOID);
	VOID                            FindFirst                       (LPCTSTR pstrCriteria);
	VOID                            FindLast                        (LPCTSTR pstrCriteria);
	VOID                            FindNext                        (LPCTSTR pstrCriteria);
	VOID                            FindPrevious            (LPCTSTR pstrCriteria);
	VOID                            MoveFirst                       (VOID);
	VOID                            MoveLast                        (LONG lOptions=-1);
	VOID                            MoveNext                        (VOID);
	VOID                            MovePrevious            (VOID);
	VOID                            Seek                            (LPCTSTR pstrComparison, LONG lNumFields, COleVariant cKey, ...);
	VOID                            Update                          (short sType = dbUpdateRegular, VARIANT_BOOL bForce = FALSE);
	CdbRecordset					Clone                           (VOID);
	VOID                            Requery                         (CdbQueryDef *pq = NULL);
	VOID                            Move                            (LONG lRows, CdbBookmark *bm=NULL);
	VOID                            FillCache                       (LONG lRows=-1, CdbBookmark *pbm=NULL);
	CdbQueryDef                     CopyQueryDef					(VOID);
	COleVariant                     GetRows                         (LONG lRows=-1);
	LONG                            GetRowsEx                       (LPVOID pvBuffer, LONG cbRow, LPDAORSETBINDING prb, LONG cBinding, LPVOID pvVarBuffer = NULL, LONG cbVarBuffer = 0, LONG lRows = -1);
	VOID                            Cancel							(VOID);
	BOOL							NextRecordset					(VOID);

	inline VOID						GetFieldV                       (COleVariant &vIndex, COleVariant &vValue);
	inline VOID                     SetFieldV                       (COleVariant &vIndex, LPVARIANT pv);


	COleVariant                     GetField                        (LPCTSTR pstrIndex);
	COleVariant                     GetField                        (LONG lIndex);
	COleVariant						GetField                        (COleVariant &vIndex);
	COleVariant						GetField                        (CString &str){return GetField((LPCTSTR)str);}

	VOID                            SetField                        (LPCTSTR pstrIndex, LPVARIANT pv);
	VOID                            SetField                        (LONG lIndex, LPVARIANT pv);
	VOID							SetField                        (COleVariant &vIndex, LPVARIANT pv);
	VOID							SetField                        (CString &str, LPVARIANT pv){SetField((LPCTSTR)str, pv);}

	// Collections
	CdbFields                       Fields;
protected:
	// GetRowsEx interface
	CdbGetRowsEx            m_GetRowsInt;
	};


/*****************************************************************************
* CdbField
*/
class DLLEXPORT CdbField : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbField                        (VOID);
	CONSTRUCTOR                     CdbField                        (DAOField *pfld, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbField                        (const CdbField &);
	CdbField &                      operator =                      (const CdbField &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetCollatingOrder       (VOID);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT s);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	LONG                            GetSize                         (VOID);
	VOID                            SetSize                         (LONG l);
	CString                         GetSourceField          (VOID);
	CString                         GetSourceTable          (VOID);
	COleVariant                     GetValue                 (VOID);

	VOID                            SetValue                (LPVARIANT pv);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	SHORT                           GetOrdinalPosition      (VOID);
	VOID                            SetOrdinalPosition      (SHORT s);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	BOOL                            GetValidateOnSet        (VOID);
	VOID                            SetValidateOnSet        (BOOL b);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	CString		                    GetDefaultValue         (VOID);
	VOID                            SetDefaultValue         (LPCTSTR pstr);
	VOID                            SetDefaultValue         (LPVARIANT pv);
	BOOL                            GetRequired             (VOID);
	VOID                            SetRequired             (BOOL b);
	BOOL                            GetAllowZeroLength      (VOID);
	VOID                            SetAllowZeroLength      (BOOL b);
	BOOL                            GetDataUpdatable		(VOID);
	CString                         GetForeignName          (VOID);
	VOID                            SetForeignName          (LPCTSTR pstr);
	COleVariant                     GetOriginalValue		(VOID);
	COleVariant                     GetVisibleValue			(VOID);

	// Methods
	VOID                            AppendChunk                     (LPVARIANT pv);
	COleVariant                     GetChunk                        (LONG lOffset, LONG lBytes);
	LONG                            FieldSize                       (VOID);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbQueryDef
*/
class DLLEXPORT CdbQueryDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbQueryDef             (VOID);
	CONSTRUCTOR                     CdbQueryDef             (DAOQueryDef *pqd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbQueryDef             (const CdbQueryDef &);
	CdbQueryDef &           operator =                      (const CdbQueryDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                 (VOID);
	VOID                            SetName                 (LPCTSTR pstr);
	SHORT                           GetODBCTimeout          (VOID);
	VOID                            SetODBCTimeout          (SHORT s);
	SHORT                           GetType                 (VOID);
	CString                         GetSQL                  (VOID);
	VOID                            SetSQL                  (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetConnect              (VOID);
	VOID                            SetConnect              (LPCTSTR pstr);
	BOOL                            GetReturnsRecords       (VOID);
	VOID                            SetReturnsRecords       (BOOL b);
	LONG                            GetRecordsAffected      (VOID);
	LONG                            GetMaxRecords			(VOID);
	VOID                            SetMaxRecords			(LONG l);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetCacheSize			(VOID);
	VOID                            SetCacheSize			(LONG l);
	COleVariant						GetPrepare				(VOID);
	VOID                            SetPrepare				(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1, LONG lLockEdit=-1);
	VOID                            Execute                 (LONG lOption=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	VOID							Close					(VOID);
	VOID							Cancel					(VOID);

	// Collections
	CdbFields                       Fields;
	CdbParameters					Parameters;
	};

/*****************************************************************************
* CdbTableDef
*/
class DLLEXPORT CdbTableDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbTableDef                     (VOID);
	CONSTRUCTOR                     CdbTableDef                     (DAOTableDef *ptd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbTableDef                     (const CdbTableDef &);
	CdbTableDef &           operator =                      (const CdbTableDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	CString                         GetConnect                      (VOID);
	VOID                            SetConnect                      (LPCTSTR pstr);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetSourceTableName      (VOID);
	VOID                            SetSourceTableName      (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	LONG                            GetRecordCount          (VOID);
	CString							GetConflictTable		(VOID);
	COleVariant						GetReplicaFilter		(VOID);
	VOID							SetReplicaFilter		(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            RefreshLink                     (VOID);
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbIndex                        CreateIndex                     (LPCTSTR pstrName=NULL);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbFields                       Fields;
	CdbIndexes                      Indexes;
	};

/*****************************************************************************
* CdbIndex
*/
class DLLEXPORT CdbIndex : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbIndex                        (VOID);
	CONSTRUCTOR                     CdbIndex                        (DAOIndex *pidx, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbIndex                        (const CdbIndex &);
	CdbIndex &                      operator =                      (const CdbIndex &);
	inline CdbField         operator []             (LONG lIndex);
	inline CdbField         operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	BOOL                            GetForeign                      (VOID);
	BOOL                            GetUnique                       (VOID);
	VOID                            SetUnique                       (BOOL b);
	BOOL                            GetClustered            (VOID);
	VOID                            SetClustered            (BOOL b);
	BOOL                            GetRequired                     (VOID);
	VOID                            SetRequired                     (BOOL b);
	BOOL                            GetIgnoreNulls          (VOID);
	VOID                            SetIgnoreNulls          (BOOL b);
	BOOL                            GetPrimary                      (VOID);
	VOID                            SetPrimary                      (BOOL b);
	LONG                            GetDistinctCount        (VOID);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbIndexFields          Fields;
	};

/*****************************************************************************
* CdbParameter
*/
class DLLEXPORT CdbParameter : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbParameter            (VOID);
	CONSTRUCTOR                     CdbParameter            (DAOParameter *pprm, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbParameter            (const CdbParameter &);
	CdbParameter &          operator =                      (const CdbParameter &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName					(VOID);
	COleVariant                     GetValue				(VOID);
	VOID                            SetValue				(LPVARIANT pv);
	SHORT                           GetType					(VOID);
	VOID							SetType					(SHORT i);
	SHORT							GetDirection			(VOID);
	VOID							SetDirection			(SHORT i);
	};

/*****************************************************************************
* CdbRelation
*/
class DLLEXPORT CdbRelation : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRelation                     (VOID);
	CONSTRUCTOR                     CdbRelation                     (DAORelation *prl, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRelation                     (const CdbRelation &);
	CdbRelation &           operator =                      (const CdbRelation &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetTable                        (VOID);
	VOID                            SetTable                        (LPCTSTR pstr);
	CString                         GetForeignTable         (VOID);
	VOID                            SetForeignTable         (LPCTSTR pstr);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG);
	BOOL							GetPartialReplica		(VOID);
	VOID							SetPartialReplica		(BOOL b);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);

	// Collections
	CdbFields                       Fields;
	};

/*****************************************************************************
* CdbUser
*/
class DLLEXPORT CdbUser : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbUser                         (VOID);
	CONSTRUCTOR                     CdbUser                         (DAOUser *pusr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbUser                         (const CdbUser &);
	CdbUser &                       operator =                      (const CdbUser &);
	inline CdbGroup         operator []                     (LONG lIndex);
	inline CdbGroup         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);
	VOID                            SetPassword                     (LPCTSTR pstr);

	// Methods
	VOID                            NewPassword                     (LPCTSTR pstrOld, LPCTSTR pstrNew);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbGroup
*/
class DLLEXPORT CdbGroup : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGroup                        (VOID);
	CONSTRUCTOR                     CdbGroup                        (DAOGroup *pgrp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGroup                        (const CdbGroup &);
	CdbGroup &                      operator =                      (const CdbGroup &);
	inline CdbUser          operator []                     (LONG lIndex);
	inline CdbUser          operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);

	// Methods
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);

	// Collections
	CdbUsers                        Users;
	};

/*****************************************************************************
* CdbDocument
*/
class DLLEXPORT CdbDocument : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDocument                     (VOID);
	CONSTRUCTOR                     CdbDocument                     (DAODocument *pdoc, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDocument                     (const CdbDocument &);
	CdbDocument &           operator =                      (const CdbDocument &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetContainer            (VOID);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	LONG							GetAllPermissions		(VOID);
	//Methods
	CdbProperty						CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbContainer
*/
class DLLEXPORT CdbContainer : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbContainer            (VOID);
	CONSTRUCTOR                     CdbContainer            (DAOContainer *pctn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbContainer            (const CdbContainer &);
	CdbContainer &          operator =                      (const CdbContainer &);
	inline CdbDocument      operator []                     (LONG lIndex);
	inline CdbDocument      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	BOOL                            GetInherit                      (VOID);
	VOID                            SetInherit                      (BOOL b);
	LONG							GetAllPermissions		(VOID);

	// Collections
	CdbDocuments            Documents;
	};

/*****************************************************************************
* CdbError
*/
class DLLEXPORT CdbError : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbError                        (VOID);
	CONSTRUCTOR                     CdbError                        (DAOError *perr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbError                        (const CdbError &);
	CdbError &                      operator =                      (const CdbError &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetNumber                       (VOID);
	CString                         GetSource                       (VOID);
	CString                         GetDescription          (VOID);
	CString                         GetHelpFile                     (VOID);
	LONG                            GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbProperty
*/
class DLLEXPORT CdbProperty : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbProperty                     (VOID);
	CONSTRUCTOR                     CdbProperty                     (DAOProperty *pprp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbProperty                     (const CdbProperty &);
	CdbProperty &           operator =                      (const CdbProperty &);

	// Properties
	COleVariant                     GetValue                        (VOID);
	VOID                            SetValue                        (LPVARIANT pv);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstrName);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT sType);
	BOOL                            GetInherited            (VOID);
	};


/*****************************************************************************
*  Inline functions
*/
inline BOOL	CdbOleObject::Exists(void)
	{ 
	return (m_punkInterface ? TRUE : FALSE);
	}

/*****************************************************************************
*  Recordset GetField functions
*/


inline VOID				CdbRecordset::GetFieldV(
	COleVariant &vIndex,
	COleVariant &vValue)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		{
		DAOVINIT(vValue);
		return;
		}

	DAOMFC_CALL(prs->get_Collect(vIndex, &vValue));

	return;
}

inline VOID				CdbRecordset::SetFieldV(
	COleVariant &vIndex, 
	LPVARIANT pv)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		return;

	DAOMFC_CALL(prs->put_Collect(vIndex, *pv));
}


/*****************************************************************************
* Default collection operators
*/
inline CdbWorkspace CdbDBEngine::operator []
	(LONG lIndex)
{
return Workspaces[lIndex];
}

inline CdbWorkspace CdbDBEngine::operator []
	(LPCTSTR pstrIndex)
{
return Workspaces[pstrIndex];
}


inline CdbDatabase CdbWorkspace::operator []
	(LONG lIndex)
{
return Databases[lIndex];
}

inline CdbDatabase CdbWorkspace::operator []
	(LPCTSTR pstrIndex)
{
return Databases[pstrIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LONG lIndex)
{
return TableDefs[lIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LPCTSTR pstrIndex)
{
return TableDefs[pstrIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LONG lIndex)
{
return QueryDefs[lIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LPCTSTR pstrIndex)
{
return QueryDefs[pstrIndex];
}

inline CdbField      CdbRecordset::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField      CdbRecordset::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}



inline CdbField CdbTableDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbTableDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbIndex::operator []   
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbIndex::operator []   
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbRelation::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbRelation::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbGroup CdbUser::operator []
	(LONG lIndex)
{
return Groups[lIndex];
}

inline CdbGroup CdbUser::operator []
	(LPCTSTR pstrIndex)
{
return Groups[pstrIndex];
}

inline CdbUser CdbGroup::operator []
	(LONG lIndex)
{
return Users[lIndex];
}

inline CdbUser CdbGroup::operator []
	(LPCTSTR pstrIndex)
{
return Users[pstrIndex];
}

inline CdbDocument CdbContainer::operator []
	(LONG lIndex)
{
return Documents[lIndex];
}

inline CdbDocument CdbContainer::operator []
	(LPCTSTR pstrIndex)
{
return Documents[pstrIndex];
}

/*****************************************************************************
*  Use different DAO interface for wide (UNICODE) versions
*/

#ifdef _UNICODE

#define dbIID_IDAODBEngine IID_IDAODBEngineW
#define dbIID_IDAOError IID_IDAOErrorW
#define dbIID_IDAOErrors IID_IDAOErrorsW
#define dbIID_IDAOProperty IID_IDAOPropertyW
#define dbIID_IDAOProperties IID_IDAOPropertiesW
#define dbIID_IDAORecordset IID_IDAORecordsetW
#define dbIID_IDAORecordsets IID_IDAORecordsetsW
#define dbIID_IDAOWorkspace IID_IDAOWorkspaceW
#define dbIID_IDAOWorkspaces IID_IDAOWorkspacesW
#define dbIID_IDAOConnection IID_IDAOConnectionW
#define dbIID_IDAOConnections IID_IDAOConnectionsW
#define dbIID_IDAOTableDef IID_IDAOTableDefW
#define dbIID_IDAOTableDefs IID_IDAOTableDefsW
#define dbIID_IDAOField IID_IDAOFieldW
#define dbIID_IDAOFields IID_IDAOFieldsW
#define dbIID_IDAOIndex IID_IDAOIndexW
#define dbIID_IDAOIndexes IID_IDAOIndexesW
#define dbIID_IDAOIndexFields IID_IDAOIndexFieldsW
#define dbIID_IDAOGroup IID_IDAOGroupW
#define dbIID_IDAOGroups IID_IDAOGroupsW
#define dbIID_IDAOUser IID_IDAOUserW
#define dbIID_IDAOUsers IID_IDAOUsersW
#define dbIID_IDAODatabase IID_IDAODatabaseW
#define dbIID_IDAODatabases IID_IDAODatabasesW
#define dbIID_IDAOQueryDef IID_IDAOQueryDefW
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefsW
#define dbIID_IDAOParameter IID_IDAOParameterW
#define dbIID_IDAOParameters IID_IDAOParametersW
#define dbIID_IDAORelation IID_IDAORelationW
#define dbIID_IDAORelations IID_IDAORelationsW
#define dbIID_IDAOContainer IID_IDAOContainerW
#define dbIID_IDAOContainers IID_IDAOContainersW
#define dbIID_IDAODocument IID_IDAODocumentW
#define dbIID_IDAODocuments IID_IDAODocumentsW

#else

#define dbIID_IDAODBEngine IID_IDAODBEngine
#define dbIID_IDAOError IID_IDAOError
#define dbIID_IDAOErrors IID_IDAOErrors
#define dbIID_IDAOProperty IID_IDAOProperty
#define dbIID_IDAOProperties IID_IDAOProperties
#define dbIID_IDAORecordset IID_IDAORecordset
#define dbIID_IDAORecordsets IID_IDAORecordsets
#define dbIID_IDAOWorkspace IID_IDAOWorkspace
#define dbIID_IDAOWorkspaces IID_IDAOWorkspaces
#define dbIID_IDAOConnection IID_IDAOConnection
#define dbIID_IDAOConnections IID_IDAOConnections
#define dbIID_IDAOTableDef IID_IDAOTableDef
#define dbIID_IDAOTableDefs IID_IDAOTableDefs
#define dbIID_IDAOField IID_IDAOField
#define dbIID_IDAOFields IID_IDAOFields
#define dbIID_IDAOIndex IID_IDAOIndex
#define dbIID_IDAOIndexes IID_IDAOIndexes
#define dbIID_IDAOIndexFields IID_IDAOIndexFields
#define dbIID_IDAOGroup IID_IDAOGroup
#define dbIID_IDAOGroups IID_IDAOGroups
#define dbIID_IDAOUser IID_IDAOUser
#define dbIID_IDAOUsers IID_IDAOUsers
#define dbIID_IDAODatabase IID_IDAODatabase
#define dbIID_IDAODatabases IID_IDAODatabases
#define dbIID_IDAOQueryDef IID_IDAOQueryDef
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefs
#define dbIID_IDAOParameter IID_IDAOParameter
#define dbIID_IDAOParameters IID_IDAOParameters
#define dbIID_IDAORelation IID_IDAORelation
#define dbIID_IDAORelations IID_IDAORelations
#define dbIID_IDAOContainer IID_IDAOContainer
#define dbIID_IDAOContainers IID_IDAOContainers
#define dbIID_IDAODocument IID_IDAODocument
#define dbIID_IDAODocuments IID_IDAODocuments

#endif



#endif // _DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao350\dbdaoint.h ===
/*************************************************************************
**	D B D A O I N T . H													*
**																		*
**	OLE DAO Interface 													*
**																		*
**	History 															*
**	------- 															*
**       File converted from cdaotype.h for use by CDAO clients.	        *
**      																	*
**																		*
**************************************************************************
** Copyright (C) 1995 by Microsoft Corporation		 					*
**		   All Rights Reserved											*
**************************************************************************/
#ifndef _DBDAOINT_H_
#define _DBDAOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

// Forwards
#define DAODBEngine _DAODBEngine
interface _DAODBEngine;
interface DAOError;
interface DAOErrors;
interface DAOProperty;
interface DAOProperties;
interface DAOWorkspace;
interface DAOWorkspaces;
interface DAODatabase;
interface DAODatabases;
#define DAOTableDef _DAOTableDef
interface _DAOTableDef;
interface DAOTableDefs;
#define DAOQueryDef _DAOQueryDef
interface _DAOQueryDef;
interface DAOQueryDefs;
interface DAORecordset;
interface DAORecordsets;
#define DAOField _DAOField
interface _DAOField;
interface DAOFields;
#define DAOIndex _DAOIndex
interface _DAOIndex;
interface DAOIndexes;
interface DAOParameter;
interface DAOParameters;
#define DAOUser _DAOUser
interface _DAOUser;
interface DAOUsers;
#define DAOGroup _DAOGroup
interface _DAOGroup;
interface DAOGroups;
#define DAORelation _DAORelation
interface _DAORelation;
interface DAORelations;
interface DAOContainer;
interface DAOContainers;
interface DAODocument;
interface DAODocuments;


// Constants
    const short dbOpenTable = 1;
    const short dbOpenDynaset = 2;
    const short dbOpenSnapshot = 4;
    const short dbEditNone = 0;
    const short dbEditInProgress = 1;
    const short dbEditAdd = 2;
    const short dbDenyWrite = 1;
    const short dbDenyRead = 2;
    const short dbReadOnly = 4;
    const short dbAppendOnly = 8;
    const short dbInconsistent = 16;
    const short dbConsistent = 32;
    const short dbSQLPassThrough = 64;
    const short dbFailOnError = 128;
    const short dbForwardOnly = 256;
    const short dbSeeChanges = 512;
    const short dbFixedField = 1;
    const short dbVariableField = 2;
    const short dbAutoIncrField = 16;
    const short dbUpdatableField = 32;
    const long dbSystemField = 8192;
    const short dbDescending = 1;
    const short dbBoolean = 1;
    const short dbByte = 2;
    const short dbInteger = 3;
    const short dbLong = 4;
    const short dbCurrency = 5;
    const short dbSingle = 6;
    const short dbDouble = 7;
    const short dbDate = 8;
    const short dbText = 10;
    const short dbLongBinary = 11;
    const short dbMemo = 12;
    const short dbGUID = 15;
    const long dbRelationUnique = 1;
    const long dbRelationDontEnforce = 2;
    const long dbRelationInherited = 4;
    const long dbRelationUpdateCascade = 256;
    const long dbRelationDeleteCascade = 4096;
    const long dbRelationLeft = 16777216;
    const long dbRelationRight = 33554432;
    const long dbAttachExclusive = 65536;
    const long dbAttachSavePWD = 131072;
    const long dbSystemObject = -2147483646;
    const long dbAttachedTable = 1073741824;
    const long dbAttachedODBC = 536870912;
    const long dbHiddenObject = 1;
    const short dbQSelect = 0;
    const short dbQAction = 240;
    const short dbQCrosstab = 16;
    const short dbQDelete = 32;
    const short dbQUpdate = 48;
    const short dbQAppend = 64;
    const short dbQMakeTable = 80;
    const short dbQDDL = 96;
    const short dbQSQLPassThrough = 112;
    const short dbQSetOperation = 128;
    const short dbQSPTBulk = 144;
	const TCHAR dbLangArabic[] = _T(";LANGID=0x0401;CP=1256;COUNTRY=0";);
	const TCHAR dbLangCzech[] = _T(";LANGID=0x0405;CP=1250;COUNTRY=0";);
	const TCHAR dbLangDutch[] = _T(";LANGID=0x0413;CP=1252;COUNTRY=0";);
	const TCHAR dbLangGeneral[] = _T(";LANGID=0x0409;CP=1252;COUNTRY=0";);
	const TCHAR dbLangGreek[] = _T(";LANGID=0x0408;CP=1253;COUNTRY=0";);
	const TCHAR dbLangHebrew[] = _T(";LANGID=0x040D;CP=1255;COUNTRY=0";);
	const TCHAR dbLangHungarian[] = _T(";LANGID=0x040E;CP=1250;COUNTRY=0";);
	const TCHAR dbLangIcelandic[] = _T(";LANGID=0x040F;CP=1252;COUNTRY=0";);
	const TCHAR dbLangNordic[] = _T(";LANGID=0x041D;CP=1252;COUNTRY=0";);
	const TCHAR dbLangNorwDan[] = _T(";LANGID=0x0414;CP=1252;COUNTRY=0";);
	const TCHAR dbLangPolish[] = _T(";LANGID=0x0415;CP=1250;COUNTRY=0";);
	const TCHAR dbLangCyrillic[] = _T(";LANGID=0x0419;CP=1251;COUNTRY=0";);
	const TCHAR dbLangSpanish[] = _T(";LANGID=0x040A;CP=1252;COUNTRY=0";);
	const TCHAR dbLangSwedFin[] = _T(";LANGID=0x040B;CP=1252;COUNTRY=0";);
	const TCHAR dbLangTurkish[] = _T(";LANGID=0x041F;CP=1254;COUNTRY=0";);
	const TCHAR dbLangJapanese[] = _T(";LANGID=0x0411;CP=932;COUNTRY=0";);
	const TCHAR dbLangChineseSimplified[] = _T(";LANGID=0x0804;CP=936;COUNTRY=0";);
	const TCHAR dbLangChineseTraditional[] = _T(";LANGID=0x0404;CP=950;COUNTRY=0";);
	const TCHAR dbLangKorean[] = _T(";LANGID=0x040C;CP=494;COUNTRY=0";);
	const TCHAR dbLangThai[] = _T(";LANGID=0x101E;CP=874;COUNTRY=0";);
    const short dbVersion10 = 1;
    const short dbEncrypt = 2;
    const short dbDecrypt = 4;
    const short dbVersion11 = 8;
    const short dbVersion20 = 16;
    const short dbVersion30 = 32;
    const short dbSortNeutral = 1024;
    const short dbSortArabic = 1025;
    const short dbSortCyrillic = 1049;
    const short dbSortCzech = 1029;
    const short dbSortDutch = 1043;
    const short dbSortGeneral = 1033;
    const short dbSortGreek = 1032;
    const short dbSortHebrew = 1037;
    const short dbSortHungarian = 1038;
    const short dbSortIcelandic = 1039;
    const short dbSortNorwdan = 1030;
    const short dbSortPDXIntl = 1033;
    const short dbSortPDXNor = 1030;
    const short dbSortPDXSwe = 1053;
    const short dbSortPolish = 1045;
    const short dbSortSpanish = 1034;
    const short dbSortSwedFin = 1053;
    const short dbSortTurkish = 1055;
    const short dbSortJapanese = 1041;
    const short dbSortChineseSimplified = 2052;
    const short dbSortChineseTraditional = 1028;
    const short dbSortKorean = 1036;
    const short dbSortThai = 4126;
    const short dbSortUndefined = -1;
    const short dbFreeLocks = 1;
    const long dbSecNoAccess = 0;
    const long dbSecFullAccess = 1048575;
    const long dbSecDelete = 65536;
    const long dbSecReadSec = 131072;
    const long dbSecWriteSec = 262144;
    const long dbSecWriteOwner = 524288;
    const long dbSecDBCreate = 1;
    const long dbSecDBOpen = 2;
    const long dbSecDBExclusive = 4;
    const long dbSecDBAdmin = 8;
    const long dbSecCreate = 1;
    const long dbSecReadDef = 4;
    const long dbSecWriteDef = 65548;
    const long dbSecRetrieveData = 20;
    const long dbSecInsertData = 32;
    const long dbSecReplaceData = 64;
    const long dbSecDeleteData = 128;
    const long dbRepExportChanges = 1;
    const long dbRepImportChanges = 2;
    const long dbRepImpExpChanges = 4;
    const long dbRepMakeReadOnly = 2;
// Interface: _DAOCollection
#undef INTERFACE
#define INTERFACE _DAOCollection
DECLARE_INTERFACE_(_DAOCollection, IDispatch)
	{
	STDMETHOD(get_Count)						 (THIS_ short FAR* c) PURE;
	STDMETHOD(_NewEnum)							 (THIS_ IUnknown * FAR* ppunk) PURE;
	STDMETHOD(Refresh)							 (THIS) PURE;
	};

// Interface: _DAODynaCollection
#undef INTERFACE
#define INTERFACE _DAODynaCollection
DECLARE_INTERFACE_(_DAODynaCollection, _DAOCollection)
	{
	STDMETHOD(Append)							 (THIS_ IDispatch * Object) PURE;
	STDMETHOD(Delete)							 (THIS_ BSTR Name) PURE;
	};

// Interface: _DAO
#undef INTERFACE
#define INTERFACE _DAO
DECLARE_INTERFACE_(_DAO, IDispatch)
	{
	STDMETHOD(get_Properties)					 (THIS_ DAOProperties FAR* FAR* ppprops) PURE;
	};

// Interface: _DAODBEngine
#undef INTERFACE
#define INTERFACE _DAODBEngine
DECLARE_INTERFACE_(_DAODBEngine, _DAO)
	{
	STDMETHOD(get_Version)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_IniPath)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_IniPath)						 (THIS_ BSTR path) PURE;
	STDMETHOD(put_DefaultUser)					 (THIS_ BSTR user) PURE;
	STDMETHOD(put_DefaultPassword)				 (THIS_ BSTR pw) PURE;
	STDMETHOD(get_LoginTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_LoginTimeout)					 (THIS_ short Timeout) PURE;
	STDMETHOD(get_Workspaces)					 (THIS_ DAOWorkspaces FAR* FAR* ppworks) PURE;
	STDMETHOD(get_Errors)						 (THIS_ DAOErrors FAR* FAR* pperrs) PURE;
	STDMETHOD(Idle)								 (THIS_ VARIANT Action) PURE;
	STDMETHOD(CompactDatabase)					 (THIS_ BSTR SrcName, BSTR DstName, VARIANT DstConnect, VARIANT Options, VARIANT SrcConnect) PURE;
	STDMETHOD(RepairDatabase)					 (THIS_ BSTR Name) PURE;
	STDMETHOD(RegisterDatabase)					 (THIS_ BSTR Dsn, BSTR Driver, VARIANT_BOOL Silent, BSTR Attributes) PURE;
	STDMETHOD(CreateWorkspace)					 (THIS_ BSTR Name, BSTR UserName, BSTR Password, DAOWorkspace FAR* FAR* ppwrk) PURE;
	STDMETHOD(OpenDatabase)						 (THIS_ BSTR Name, VARIANT Exclusive, VARIANT ReadOnly, VARIANT Connect, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateDatabase)					 (THIS_ BSTR Name, BSTR Connect, VARIANT Option, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(FreeLocks)						 (THIS) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(SetDefaultWorkspace)				 (THIS_ BSTR Name, BSTR Password) PURE;
	STDMETHOD(SetDataAccessOption)				 (THIS_ short Option, VARIANT Value) PURE;
	STDMETHOD(ISAMStats)						 (THIS_ long StatNum, VARIANT Reset, long FAR* pl) PURE;
	STDMETHOD(get_SystemDB)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SystemDB)						 (THIS_ BSTR SystemDBPath) PURE;
	};

// Interface: DAOError
#undef INTERFACE
#define INTERFACE DAOError
DECLARE_INTERFACE_(DAOError, IDispatch)
	{
	STDMETHOD(get_Number)						 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Source)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Description)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_HelpFile)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_HelpContext)					 (THIS_ long FAR* pl) PURE;
	};

// Interface: DAOErrors
#undef INTERFACE
#define INTERFACE DAOErrors
DECLARE_INTERFACE_(DAOErrors, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOError FAR* FAR* pperr) PURE;
	};

// Interface: DAOWorkspace
#undef INTERFACE
#define INTERFACE DAOWorkspace
DECLARE_INTERFACE_(DAOWorkspace, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_UserName)						 (THIS_ BSTR UserName) PURE;
	STDMETHOD(put_Password)						 (THIS_ BSTR Password) PURE;
	STDMETHOD(get_IsolateODBCTrans)				 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_IsolateODBCTrans)				 (THIS_ short s) PURE;
	STDMETHOD(get_Databases)					 (THIS_ DAODatabases FAR* FAR* ppdbs) PURE;
	STDMETHOD(get_Users)						 (THIS_ DAOUsers FAR* FAR* ppusrs) PURE;
	STDMETHOD(get_Groups)						 (THIS_ DAOGroups FAR* FAR* ppgrps) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(OpenDatabase)						 (THIS_ BSTR Name, VARIANT Exclusive, VARIANT ReadOnly, VARIANT Connect, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateDatabase)					 (THIS_ BSTR Name, BSTR Connect, VARIANT Option, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateUser)						 (THIS_ VARIANT Name, VARIANT PID, VARIANT Password, DAOUser FAR* FAR* ppusr) PURE;
	STDMETHOD(CreateGroup)						 (THIS_ VARIANT Name, VARIANT PID, DAOGroup FAR* FAR* ppgrp) PURE;
	};

// Interface: DAOWorkspaces
#undef INTERFACE
#define INTERFACE DAOWorkspaces
DECLARE_INTERFACE_(DAOWorkspaces, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOWorkspace FAR* FAR* ppwrk) PURE;
	};

// Interface: _DAOTableDef
#undef INTERFACE
#define INTERFACE _DAOTableDef
DECLARE_INTERFACE_(_DAOTableDef, _DAO)
	{
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long Attributes) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR Connection) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_SourceTableName)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SourceTableName)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationText)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationRule)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_RecordCount)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Indexes)						 (THIS_ DAOIndexes FAR* FAR* ppidxs) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(RefreshLink)						 (THIS) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	STDMETHOD(CreateIndex)						 (THIS_ VARIANT Name, DAOIndex FAR* FAR* ppidx) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(get_ConflictTable)				 (THIS_ BSTR FAR* pbstr) PURE;
	};

// Interface: DAOTableDefs
#undef INTERFACE
#define INTERFACE DAOTableDefs
DECLARE_INTERFACE_(DAOTableDefs, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOTableDef FAR* FAR* pptdf) PURE;
	};

// Interface: DAODatabase
#undef INTERFACE
#define INTERFACE DAODatabase
DECLARE_INTERFACE_(DAODatabase, _DAO)
	{
	STDMETHOD(get_CollatingOrder)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_QueryTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_QueryTimeout)					 (THIS_ short Timeout) PURE;
	STDMETHOD(get_Transactions)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Version)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_RecordsAffected)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_TableDefs)					 (THIS_ DAOTableDefs FAR* FAR* pptdfs) PURE;
	STDMETHOD(get_QueryDefs)					 (THIS_ DAOQueryDefs FAR* FAR* ppqdfs) PURE;
	STDMETHOD(get_Relations)					 (THIS_ DAORelations FAR* FAR* pprls) PURE;
	STDMETHOD(get_Containers)					 (THIS_ DAOContainers FAR* FAR* ppctns) PURE;
	STDMETHOD(get_Recordsets)					 (THIS_ DAORecordsets FAR* FAR* pprsts) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(Execute)							 (THIS_ BSTR Query, VARIANT Options) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ BSTR Name, VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(CreateRelation)					 (THIS_ VARIANT Name, VARIANT Table, VARIANT ForeignTable, VARIANT Attributes, DAORelation FAR* FAR* pprel) PURE;
	STDMETHOD(CreateTableDef)					 (THIS_ VARIANT Name, VARIANT Attributes, VARIANT SourceTablename, VARIANT Connect, DAOTableDef FAR* FAR* pptdf) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ BSTR Name, VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateQueryDef)					 (THIS_ VARIANT Name, VARIANT SQLText, DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ BSTR Source, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(DeleteQueryDef)					 (THIS_ BSTR Name) PURE;
	STDMETHOD(ExecuteSQL)						 (THIS_ BSTR SQL, long FAR* pl) PURE;
	STDMETHOD(ListFields)						 (THIS_ BSTR Name, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListTables)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(OpenQueryDef)						 (THIS_ BSTR Name, DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(OpenTable)						 (THIS_ BSTR Name, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(get_ReplicaID)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_DesignMasterID)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_DesignMasterID)				 (THIS_ BSTR MasterID) PURE;
	STDMETHOD(Synchronize)						 (THIS_ BSTR DbPathName, VARIANT ExchangeType) PURE;
	STDMETHOD(MakeReplica)						 (THIS_ BSTR PathName, BSTR Description, VARIANT Options) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR ODBCConnnect) PURE;
	STDMETHOD(NewPassword)						 (THIS_ BSTR bstrOld, BSTR bstrNew) PURE;
	};

// Interface: DAODatabases
#undef INTERFACE
#define INTERFACE DAODatabases
DECLARE_INTERFACE_(DAODatabases, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAODatabase FAR* FAR* ppdb) PURE;
	};

// Interface: _DAOQueryDef
#undef INTERFACE
#define INTERFACE _DAOQueryDef
DECLARE_INTERFACE_(_DAOQueryDef, _DAO)
	{
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ODBCTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_ODBCTimeout)					 (THIS_ short timeout) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* pi) PURE;
	STDMETHOD(get_SQL)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SQL)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ReturnsRecords)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_ReturnsRecords)				 (THIS_ VARIANT_BOOL f) PURE;
	STDMETHOD(get_RecordsAffected)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Parameters)					 (THIS_ DAOParameters FAR* FAR* ppprms) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(_OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(_Copy)							 (THIS_ DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(Execute)							 (THIS_ VARIANT Options) PURE;
	STDMETHOD(Compare)							 (THIS_ DAOQueryDef FAR* pQdef, short FAR* lps) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListParameters)					 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	};

// Interface: DAOQueryDefs
#undef INTERFACE
#define INTERFACE DAOQueryDefs
DECLARE_INTERFACE_(DAOQueryDefs, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOQueryDef FAR* FAR* ppqdef) PURE;
	};

// Interface: DAORecordset
#undef INTERFACE
#define INTERFACE DAORecordset
DECLARE_INTERFACE_(DAORecordset, _DAO)
	{
	STDMETHOD(get_BOF)							 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Bookmark)						 (THIS_ SAFEARRAY FAR* FAR* ppsach) PURE;
	STDMETHOD(put_Bookmark)						 (THIS_ SAFEARRAY FAR* FAR* psach) PURE;
	STDMETHOD(get_Bookmarkable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_EOF)							 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Filter)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Filter)						 (THIS_ BSTR Filter) PURE;
	STDMETHOD(get_Index)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Index)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_LastModified)					 (THIS_ SAFEARRAY FAR* FAR* ppsa) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LockEdits)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_LockEdits)					 (THIS_ VARIANT_BOOL Lock) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_NoMatch)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Sort)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Sort)							 (THIS_ BSTR Sort) PURE;
	STDMETHOD(get_Transactions)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	STDMETHOD(get_RecordCount)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Restartable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_CacheStart)					 (THIS_ SAFEARRAY FAR* FAR* ppsa) PURE;
	STDMETHOD(put_CacheStart)					 (THIS_ SAFEARRAY FAR* FAR* psa) PURE;
	STDMETHOD(get_CacheSize)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_CacheSize)					 (THIS_ long CacheSize) PURE;
	STDMETHOD(get_PercentPosition)				 (THIS_ float FAR* pd) PURE;
	STDMETHOD(put_PercentPosition)				 (THIS_ float Position) PURE;
	STDMETHOD(get_AbsolutePosition)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_AbsolutePosition)				 (THIS_ long Position) PURE;
	STDMETHOD(get_EditMode)						 (THIS_ short FAR* pi) PURE;
	STDMETHOD(get_ODBCFetchCount)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_ODBCFetchDelay)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Parent)						 (THIS_ DAODatabase FAR* FAR* pdb) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Indexes)						 (THIS_ DAOIndexes FAR* FAR* ppidxs) PURE;
	STDMETHOD(CancelUpdate)						 (THIS) PURE;
	STDMETHOD(AddNew)							 (THIS) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(Delete)							 (THIS) PURE;
	STDMETHOD(Edit)								 (THIS) PURE;
	STDMETHOD(FindFirst)						 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindLast)							 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindNext)							 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindPrevious)						 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(MoveFirst)						 (THIS) PURE;
	STDMETHOD(MoveLast)							 (THIS) PURE;
	STDMETHOD(MoveNext)							 (THIS) PURE;
	STDMETHOD(MovePrevious)						 (THIS) PURE;
	STDMETHOD(Seek)								 (THIS_ BSTR Comparison, VARIANT Key1, VARIANT Key2, VARIANT Key3, VARIANT Key4, VARIANT Key5, VARIANT Key6, VARIANT Key7, VARIANT Key8, VARIANT Key9, VARIANT Key10, VARIANT Key11, VARIANT Key12, VARIANT Key13) PURE;
	STDMETHOD(Update)							 (THIS) PURE;
	STDMETHOD(Clone)							 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(Requery)							 (THIS_ VARIANT NewQueryDef) PURE;
	STDMETHOD(Move)								 (THIS_ long Rows, VARIANT StartBookmark) PURE;
	STDMETHOD(FillCache)						 (THIS_ VARIANT Rows, VARIANT StartBookmark) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CopyQueryDef)						 (THIS_ DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(ListFields)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListIndexes)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(GetRows)							 (THIS_ VARIANT cRows, VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Collect)						 (THIS_ VARIANT index, VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Collect)						 (THIS_ VARIANT index, VARIANT value) PURE;
	};

// Interface: DAORecordsets
#undef INTERFACE
#define INTERFACE DAORecordsets
DECLARE_INTERFACE_(DAORecordsets, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAORecordset FAR* FAR* pprst) PURE;
	};

// Interface: _DAOField
#undef INTERFACE
#define INTERFACE _DAOField
DECLARE_INTERFACE_(_DAOField, _DAO)
	{
	STDMETHOD(get_CollatingOrder)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_Type)							 (THIS_ short Type) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_Size)							 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Size)							 (THIS_ long Size) PURE;
	STDMETHOD(get_SourceField)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_SourceTable)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT Val) PURE;
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long Attr) PURE;
	STDMETHOD(get_OrdinalPosition)				 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_OrdinalPosition)				 (THIS_ short Pos) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationText)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ValidateOnSet)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_ValidateOnSet)				 (THIS_ VARIANT_BOOL Validate) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationRule)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_DefaultValue)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_DefaultValue)					 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Required)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Required)						 (THIS_ VARIANT_BOOL fReq) PURE;
	STDMETHOD(get_AllowZeroLength)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_AllowZeroLength)				 (THIS_ VARIANT_BOOL fAllow) PURE;
	STDMETHOD(get_DataUpdatable)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ForeignName)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ForeignName)					 (THIS_ BSTR bstr) PURE;
	STDMETHOD(AppendChunk)						 (THIS_ VARIANT Val) PURE;
	STDMETHOD(GetChunk)							 (THIS_ long Offset, long Bytes, VARIANT FAR* pvar) PURE;
	STDMETHOD(FieldSize)						 (THIS_ long FAR* pl) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(get_CollectionIndex)				 (THIS_ short FAR* i) PURE;
	};

// Interface: DAOFields
#undef INTERFACE
#define INTERFACE DAOFields
DECLARE_INTERFACE_(DAOFields, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOField FAR* FAR* ppfld) PURE;
	};

// Interface: _DAOIndex
#undef INTERFACE
#define INTERFACE _DAOIndex
DECLARE_INTERFACE_(_DAOIndex, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Foreign)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Unique)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Unique)						 (THIS_ VARIANT_BOOL fUnique) PURE;
	STDMETHOD(get_Clustered)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Clustered)					 (THIS_ VARIANT_BOOL fClustered) PURE;
	STDMETHOD(get_Required)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Required)						 (THIS_ VARIANT_BOOL fRequired) PURE;
	STDMETHOD(get_IgnoreNulls)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_IgnoreNulls)					 (THIS_ VARIANT_BOOL fIgnoreNulls) PURE;
	STDMETHOD(get_Primary)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Primary)						 (THIS_ VARIANT_BOOL fPrimary) PURE;
	STDMETHOD(get_DistinctCount)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ VARIANT FAR* pv) PURE;
	STDMETHOD(put_Fields)						 (THIS_ VARIANT v) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	};

// Interface: DAOIndexes
#undef INTERFACE
#define INTERFACE DAOIndexes
DECLARE_INTERFACE_(DAOIndexes, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOIndex FAR* FAR* ppidx) PURE;
	};

// Interface: DAOIndexFields
#undef INTERFACE
#define INTERFACE DAOIndexFields
DECLARE_INTERFACE_(DAOIndexFields, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, VARIANT FAR* pvar) PURE;
	};

// Interface: DAOParameter
#undef INTERFACE
#define INTERFACE DAOParameter
DECLARE_INTERFACE_(DAOParameter, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT val) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	};

// Interface: DAOParameters
#undef INTERFACE
#define INTERFACE DAOParameters
DECLARE_INTERFACE_(DAOParameters, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOParameter FAR* FAR* ppprm) PURE;
	};

// Interface: _DAOUser
#undef INTERFACE
#define INTERFACE _DAOUser
DECLARE_INTERFACE_(_DAOUser, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_PID)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_Password)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Groups)						 (THIS_ DAOGroups FAR* FAR* ppgrps) PURE;
	STDMETHOD(NewPassword)						 (THIS_ BSTR bstrOld, BSTR bstrNew) PURE;
	STDMETHOD(CreateGroup)						 (THIS_ VARIANT Name, VARIANT PID, DAOGroup FAR* FAR* ppgrp) PURE;
	};

// Interface: DAOUsers
#undef INTERFACE
#define INTERFACE DAOUsers
DECLARE_INTERFACE_(DAOUsers, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOUser FAR* FAR* ppusr) PURE;
	};

// Interface: _DAOGroup
#undef INTERFACE
#define INTERFACE _DAOGroup
DECLARE_INTERFACE_(_DAOGroup, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_PID)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Users)						 (THIS_ DAOUsers FAR* FAR* ppusrs) PURE;
	STDMETHOD(CreateUser)						 (THIS_ VARIANT Name, VARIANT PID, VARIANT Password, DAOUser FAR* FAR* ppusr) PURE;
	};

// Interface: DAOGroups
#undef INTERFACE
#define INTERFACE DAOGroups
DECLARE_INTERFACE_(DAOGroups, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOGroup FAR* FAR* ppgrp) PURE;
	};

// Interface: _DAORelation
#undef INTERFACE
#define INTERFACE _DAORelation
DECLARE_INTERFACE_(_DAORelation, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Table)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Table)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ForeignTable)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ForeignTable)					 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long attr) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	};

// Interface: DAORelations
#undef INTERFACE
#define INTERFACE DAORelations
DECLARE_INTERFACE_(DAORelations, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAORelation FAR* FAR* pprel) PURE;
	};

// Interface: DAOProperty
#undef INTERFACE
#define INTERFACE DAOProperty
DECLARE_INTERFACE_(DAOProperty, _DAO)
	{
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pval) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT val) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ptype) PURE;
	STDMETHOD(put_Type)							 (THIS_ short type) PURE;
	STDMETHOD(get_Inherited)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	};

// Interface: DAOProperties
#undef INTERFACE
#define INTERFACE DAOProperties
DECLARE_INTERFACE_(DAOProperties, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOProperty FAR* FAR* ppprop) PURE;
	};

// Interface: DAOContainer
#undef INTERFACE
#define INTERFACE DAOContainer
DECLARE_INTERFACE_(DAOContainer, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Owner)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Owner)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_UserName)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Permissions)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Permissions)					 (THIS_ long permissions) PURE;
	STDMETHOD(get_Inherit)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Inherit)						 (THIS_ VARIANT_BOOL fInherit) PURE;
	STDMETHOD(get_Documents)					 (THIS_ DAODocuments FAR* FAR* ppdocs) PURE;
	STDMETHOD(get_AllPermissions)				 (THIS_ long FAR* pl) PURE;
	};

// Interface: DAOContainers
#undef INTERFACE
#define INTERFACE DAOContainers
DECLARE_INTERFACE_(DAOContainers, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOContainer FAR* FAR* ppctn) PURE;
	};

// Interface: DAODocument
#undef INTERFACE
#define INTERFACE DAODocument
DECLARE_INTERFACE_(DAODocument, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Owner)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Owner)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Container)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_UserName)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Permissions)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Permissions)					 (THIS_ long permissions) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_AllPermissions)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	};

// Interface: DAODocuments
#undef INTERFACE
#define INTERFACE DAODocuments
DECLARE_INTERFACE_(DAODocuments, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAODocument FAR* FAR* ppdoc) PURE;
	};

#endif // _DBDAOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\dbdaoerr.h ===
/************************************************************************
**	D B D A O E R R . H													*														*
**																		*
**		History 														*
**		------- 														*
**	5-17-95 Added to DAO SDK				 							*
**	7-17-95 Added DBDAOERR macro, removed internal only codes																	*
**	8-30-96 Added replication and ODBC direct errors																	*
**																		*
**	The following #defines map the integer to a descriptive name
**	i.e.  3270 -> E_DAO_VtoPropNotFound									*
**																		*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

#ifndef _DDAOERR_H_
#define _DDAOERR_H_

#define DBDAOERR(x) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)

#define E_DAO_InternalError					DBDAOERR(3000) //Reserved error (|); there is no message for this error.
#define E_DAO_InvalidParameter				DBDAOERR(3001) //Invalid argument.
#define E_DAO_CantBegin						DBDAOERR(3002) //Couldn't start session.
#define E_DAO_TransTooDeep					DBDAOERR(3003) //Couldn't start transaction; too many transactions already nested.
#define E_DAO_DatabaseNotFound				DBDAOERR(3004) //Couldn't find database '|'.
#define E_DAO_DatabaseInvalidName			DBDAOERR(3005) //'|' isn't a valid database name.
#define E_DAO_DatabaseLocked				DBDAOERR(3006) //Database '|' is exclusively locked.
#define E_DAO_DatabaseOpenError				DBDAOERR(3007) //Can't open library database '|'.
#define E_DAO_TableLocked					DBDAOERR(3008) //Table '|' is exclusively locked.
#define E_DAO_TableInUse					DBDAOERR(3009) //Couldn't lock table '|'; currently in use.
#define E_DAO_TableDuplicate				DBDAOERR(3010) //Table '|' already exists.
#define E_DAO_ObjectNotFound				DBDAOERR(3011) //Couldn't find object '|'.
#define E_DAO_ObjectDuplicate				DBDAOERR(3012) //Object '|' already exists.
#define E_DAO_CannotRename					DBDAOERR(3013) //Couldn't rename installable ISAM file.
#define E_DAO_TooManyOpenTables				DBDAOERR(3014) //Can't open any more tables.
#define E_DAO_IndexNotFound					DBDAOERR(3015) //'|' isn't an index in this table.
#define E_DAO_ColumnDoesNotFit 				DBDAOERR(3016) //Field won't fit in record.
#define E_DAO_ColumnTooBig					DBDAOERR(3017) //The size of a field is too long.
#define E_DAO_ColumnNotFound				DBDAOERR(3018) //Couldn't find field '|'.
#define E_DAO_NoCurrentIndex				DBDAOERR(3019) //Operation invalid without a current index.
#define E_DAO_RecordNoCopy					DBDAOERR(3020) //Update or CancelUpdate without AddNew or Edit.
#define E_DAO_NoCurrentRecord				DBDAOERR(3021) //No current record.
#define E_DAO_KeyDuplicate					DBDAOERR(3022) //Duplicate value in index, primary key, or relationship.  Changes were unsuccessful.
#define E_DAO_AlreadyPrepared				DBDAOERR(3023) //AddNew or Edit already used.
#define E_DAO_FileNotFound					DBDAOERR(3024) //Couldn't find file '|'.
#define E_DAO_TooManyOpenFiles				DBDAOERR(3025) //Can't open any more files.
#define E_DAO_DiskFull						DBDAOERR(3026) //Not enough space on disk.
#define E_DAO_PermissionDenied				DBDAOERR(3027) //Can't update.  Database or object is read-only.
#define E_DAO_CannotOpenSystemDb			DBDAOERR(3028) //Can't start your application. The system database is missing or opened exclusively by another user.
#define E_DAO_InvalidLogon					DBDAOERR(3029) //Not a valid account name or password.
#define E_DAO_InvalidAccountName			DBDAOERR(3030) //'|' isn't a valid account name.
#define E_DAO_InvalidPassword				DBDAOERR(3031) //Not a valid password.
#define E_DAO_InvalidOperation				DBDAOERR(3032) //Can't perform this operation.
#define E_DAO_AccessDenied					DBDAOERR(3033) //No permission for '|'.
#define E_DAO_NotInTransaction				DBDAOERR(3034) //Commit or Rollback without BeginTrans.
#define E_DAO_OutOfMemory					DBDAOERR(3035) //*
#define E_DAO_CantAllocatePage				DBDAOERR(3036) //Database has reached maximum size.
#define E_DAO_NoMoreCursors					DBDAOERR(3037) //Can't open any more tables or queries.
#define E_DAO_OutOfBuffers					DBDAOERR(3038) //*
#define E_DAO_TooManyIndexes				DBDAOERR(3039) //Couldn't create index; too many indexes already defined.
#define E_DAO_ReadVerifyFailure				DBDAOERR(3040) //Disk I/O error during read.
#define E_DAO_FilesysVersion				DBDAOERR(3041) //Can't open a database created with a previous version of your application.
#define E_DAO_NoMoreFiles					DBDAOERR(3042) //Out of MS-DOS file handles.
#define E_DAO_DiskError						DBDAOERR(3043) //Disk or network error.
#define E_DAO_InvalidPath					DBDAOERR(3044) //'|' isn't a valid path.
#define E_DAO_FileShareViolation			DBDAOERR(3045) //Couldn't use '|'; file already in use.
#define E_DAO_FileLockViolation				DBDAOERR(3046) //Couldn't save; currently locked by another user.
#define E_DAO_RecordTooBig					DBDAOERR(3047) //Record is too large.
#define E_DAO_TooManyOpenDatabases			DBDAOERR(3048) //Can't open any more databases.
#define E_DAO_InvalidDatabase				DBDAOERR(3049) //Can't open database '|'.  It may not be a database that your application recognizes, or the file may be corrupt.
#define E_DAO_FileLockingUnavailable		DBDAOERR(3050) //Couldn't lock file.
#define E_DAO_FileAccessDenied				DBDAOERR(3051) //Couldn't open file '|'.
#define E_DAO_SharingBufferExceeded			DBDAOERR(3052) //MS-DOS file sharing lock count exceeded.  You need to increase the number of locks installed with SHARE.EXE.
#define E_DAO_TaskLimitExceeded				DBDAOERR(3053) //Too many client tasks.
#define E_DAO_TooManyLongColumns			DBDAOERR(3054) //Too many Memo or OLE object fields.
#define E_DAO_InvalidFilename				DBDAOERR(3055) //Not a valid file name.
#define E_DAO_AbortSalvage					DBDAOERR(3056) //Couldn't repair this database.
#define E_DAO_LinkNotSupported				DBDAOERR(3057) //Operation not supported on attached, or linked, tables.
#define E_DAO_NullKeyDisallowed				DBDAOERR(3058) //Index or primary key can't contain a null value.
#define E_DAO_OperationCanceled				DBDAOERR(3059) //Operation canceled by user.
#define E_DAO_QueryParmTypeMismatch			DBDAOERR(3060) //Wrong data type for parameter '|'.
#define E_DAO_QueryMissingParmsM			DBDAOERR(3061) //Too few parameters. Expected |.
#define E_DAO_QueryDuplicateAliasM			DBDAOERR(3062) //Duplicate output alias '|'.
#define E_DAO_QueryDuplicateOutputM			DBDAOERR(3063) //Duplicate output destination '|'.
#define E_DAO_QueryIsBulkOp					DBDAOERR(3064) //Can't open action query '|'.
#define E_DAO_QueryIsNotBulkOp				DBDAOERR(3065) //Can't execute a non-action query.
#define E_DAO_QueryNoOutputsM				DBDAOERR(3066) //Query or table must contain at least one output field.
#define E_DAO_QueryNoInputTablesM			DBDAOERR(3067) //Query input must contain at least one table or query.
#define E_DAO_QueryInvalidAlias				DBDAOERR(3068) //Not a valid alias name.
#define E_DAO_QueryInvalidBulkInputM		DBDAOERR(3069) //The action query '|' cannot be used as a row source.
#define E_DAO_QueryUnboundRef				DBDAOERR(3070) //Can't bind name '|'.
#define E_DAO_QueryExprEvaluation			DBDAOERR(3071) //Can't evaluate expression.
#define E_DAO_EvalEBESErr					DBDAOERR(3072) //|
#define E_DAO_QueryNotUpdatable				DBDAOERR(3073) //Operation must use an updatable query.
#define E_DAO_TableRepeatInFromList			DBDAOERR(3074) //Can't repeat table name '|' in FROM clause.
#define E_DAO_QueryExprSyntax				DBDAOERR(3075) //|1 in query expression '|2'.
#define E_DAO_QbeExprSyntax					DBDAOERR(3076) //| in criteria expression.
#define E_DAO_FindExprSyntax				DBDAOERR(3077) //| in expression.
#define E_DAO_InputTableNotFound			DBDAOERR(3078) //Couldn't find input table or query '|'.
#define E_DAO_QueryAmbigRefM				DBDAOERR(3079) //Ambiguous field reference '|'.
#define E_DAO_JoinTableNotInput				DBDAOERR(3080) //Joined table '|' not listed in FROM clause.
#define E_DAO_UnaliasedSelfJoin				DBDAOERR(3081) //Can't join more than one table with the same name (|).
#define E_DAO_ColumnNotInJoinTable			DBDAOERR(3082) //JOIN operation '|' refers to a non-joined table.
#define E_DAO_QueryIsMGB					DBDAOERR(3083) //Can't use internal report query.
#define E_DAO_QueryInsIntoBulkMGB			DBDAOERR(3084) //Can't insert data with action query.
#define E_DAO_ExprUnknownFunctionM			DBDAOERR(3085) //Undefined function '|' in expression.
#define E_DAO_QueryCannotDelete				DBDAOERR(3086) //Couldn't delete from specified tables.
#define E_DAO_QueryTooManyGroupExprs		DBDAOERR(3087) //Too many expressions in GROUP BY clause.
#define E_DAO_QueryTooManyOrderExprs		DBDAOERR(3088) //Too many expressions in ORDER BY clause.
#define E_DAO_QueryTooManyDistExprs			DBDAOERR(3089) //Too many expressions in DISTINCT output.
#define E_DAO_Column2ndSysMaint				DBDAOERR(3090) //Resultant table not allowed to have more than one Counter or Autonumber field.
#define E_DAO_HavingWOGrouping				DBDAOERR(3091) //HAVING clause (|) without grouping or aggregation.
#define E_DAO_HavingOnTransform				DBDAOERR(3092) //Can't use HAVING clause in TRANSFORM statement.
#define E_DAO_OrderVsDistinct				DBDAOERR(3093) //ORDER BY clause (|) conflicts with DISTINCT.
#define E_DAO_OrderVsGroup					DBDAOERR(3094) //ORDER BY clause (|) conflicts with GROUP BY clause.
#define E_DAO_AggregateInArgument			DBDAOERR(3095) //Can't have aggregate function in expression (|).
#define E_DAO_AggregateInWhere				DBDAOERR(3096) //Can't have aggregate function in WHERE clause (|).
#define E_DAO_AggregateInOrderBy			DBDAOERR(3097) //Can't have aggregate function in ORDER BY clause (|).
#define E_DAO_AggregateInGroupBy			DBDAOERR(3098) //Can't have aggregate function in GROUP BY clause (|).
#define E_DAO_AggregateInJoin				DBDAOERR(3099) //Can't have aggregate function in JOIN operation (|).
#define E_DAO_NullInJoinKey					DBDAOERR(3100) //Can't set field '|' in join key to Null.
#define E_DAO_ValueBreaksJoin				DBDAOERR(3101) //There is no record in table '|2' with key matching field(s) '|1'.
#define E_DAO_QueryTreeCycle				DBDAOERR(3102) //Circular reference caused by '|'.
#define E_DAO_OutputAliasCycle				DBDAOERR(3103) //Circular reference caused by alias '|' in query definition's SELECT list.
#define E_DAO_QryDuplicatedFixedSetM		DBDAOERR(3104) //Can't specify Fixed Column Heading '|' in a crosstab query more than once.
#define E_DAO_NoSelectIntoColumnName		DBDAOERR(3105) //Missing destination field name in SELECT INTO statement (|).
#define E_DAO_NoUpdateColumnName			DBDAOERR(3106) //Missing destination field name in UPDATE statement (|).
#define E_DAO_QueryNoInsertPerm				DBDAOERR(3107) //Record(s) can't be added; no Insert Data permission on '|'.
#define E_DAO_QueryNoReplacePerm			DBDAOERR(3108) //Record(s) can't be edited; no Update Data permission on '|'.
#define E_DAO_QueryNoDeletePerm				DBDAOERR(3109) //Record(s) can't be deleted; no Delete Data permission on '|'.
#define E_DAO_QueryNoReadDefPerm			DBDAOERR(3110) //Couldn't read definitions; no Read Design permission for table or query '|'.
#define E_DAO_QueryNoTblCrtPerm				DBDAOERR(3111) //Couldn't create; no Create permission for table or query '|'.
#define E_DAO_QueryNoReadPerm				DBDAOERR(3112) //Record(s) can't be read; no Read Data permission on '|'.
#define E_DAO_QueryColNotUpd				DBDAOERR(3113) //Can't update '|'; field not updatable.
#define E_DAO_QueryLVInDistinct				DBDAOERR(3114) //Can't include Memo or OLE object when you select unique values (|).
#define E_DAO_QueryLVInAggregate			DBDAOERR(3115) //Can't have Memo or OLE object in aggregate argument (|).
#define E_DAO_QueryLVInHaving				DBDAOERR(3116) //Can't have Memo or OLE object in criteria (|) for aggregate function.
#define E_DAO_QueryLVInOrderBy				DBDAOERR(3117) //Can't sort on Memo or OLE object (|).
#define E_DAO_QueryLVInJoin					DBDAOERR(3118) //Can't join on Memo or OLE object (|).
#define E_DAO_QueryLVInGroupBy				DBDAOERR(3119) //Can't group on Memo or OLE object (|).
#define E_DAO_DotStarWithGrouping			DBDAOERR(3120) //Can't group on fields selected with '*' (|).
#define E_DAO_StarWithGrouping				DBDAOERR(3121) //Can't group on fields selected with '*'.
#define E_DAO_IllegalDetailRef				DBDAOERR(3122) //'|' not part of aggregate function or grouping.
#define E_DAO_StarNotAtLevel0				DBDAOERR(3123) //Can't use '*' in crosstab query.
#define E_DAO_QueryInvalidMGBInput			DBDAOERR(3124) //Can't input from internal report query (|).
#define E_DAO_InvalidName					DBDAOERR(3125) //'|' isn't a valid name.
#define E_DAO_QueryBadBracketing			DBDAOERR(3126) //Invalid bracketing of name '|'.
#define E_DAO_InsertIntoUnknownCol			DBDAOERR(3127) //INSERT INTO statement contains unknown field name '|'.
#define E_DAO_QueryNoDeleteTables			DBDAOERR(3128) //Must specify tables to delete from.
#define E_DAO_SQLSyntax						DBDAOERR(3129) //Invalid SQL statement; expected 'DELETE', 'INSERT', 'PROCEDURE', 'SELECT', or 'UPDATE'.
#define E_DAO_SQLDeleteSyntax				DBDAOERR(3130) //Syntax error in DELETE statement.
#define E_DAO_SQLFromSyntax					DBDAOERR(3131) //Syntax error in FROM clause.
#define E_DAO_SQLGroupBySyntax				DBDAOERR(3132) //Syntax error in GROUP BY clause.
#define E_DAO_SQLHavingSyntax				DBDAOERR(3133) //Syntax error in HAVING clause.
#define E_DAO_SQLInsertSyntax				DBDAOERR(3134) //Syntax error in INSERT statement.
#define E_DAO_SQLJoinSyntax					DBDAOERR(3135) //Syntax error in JOIN operation.
#define E_DAO_SQLLevelSyntax				DBDAOERR(3136) //Syntax error in LEVEL clause.
#define E_DAO_SQLMissingSemicolon			DBDAOERR(3137) //Missing semicolon (;) at end of SQL statement.
#define E_DAO_SQLOrderBySyntax				DBDAOERR(3138) //Syntax error in ORDER BY clause.
#define E_DAO_SQLParameterSyntax			DBDAOERR(3139) //Syntax error in PARAMETER clause.
#define E_DAO_SQLProcedureSyntax			DBDAOERR(3140) //Syntax error in PROCEDURE clause.
#define E_DAO_SQLSelectSyntax				DBDAOERR(3141) //Syntax error in SELECT statement.
#define E_DAO_SQLTooManyTokens				DBDAOERR(3142) //Characters found after end of SQL statement.
#define E_DAO_SQLTransformSyntax			DBDAOERR(3143) //Syntax error in TRANSFORM statement.
#define E_DAO_SQLUpdateSyntax				DBDAOERR(3144) //Syntax error in UPDATE statement.
#define E_DAO_SQLWhereSyntax				DBDAOERR(3145) //Syntax error in WHERE clause.
#define E_DAO_RmtSQLCError					DBDAOERR(3146) //ODBC--call failed.
#define E_DAO_RmtDataOverflow				DBDAOERR(3147) //*
#define E_DAO_RmtConnectFailed				DBDAOERR(3148) //*
#define E_DAO_RmtIncorrectSqlcDll			DBDAOERR(3149) //*
#define E_DAO_RmtMissingSqlcDll				DBDAOERR(3150) //*
#define E_DAO_RmtConnectFailedM				DBDAOERR(3151) //ODBC--connection to '|' failed.
#define E_DAO_RmtDrvrVer					DBDAOERR(3152) //*
#define E_DAO_RmtSrvrVer					DBDAOERR(3153) //*
#define E_DAO_RmtMissingOdbcDll				DBDAOERR(3154) //ODBC--couldn't find DLL '|'.
#define E_DAO_RmtInsertFailedM				DBDAOERR(3155) //ODBC--insert failed on attached (linked) table '|'.
#define E_DAO_RmtDeleteFailedM				DBDAOERR(3156) //ODBC--delete failed on attached (linked) table '|'.
#define E_DAO_RmtUpdateFailedM				DBDAOERR(3157) //ODBC--update failed on attached (linked) table '|'.
#define E_DAO_RecordLocked					DBDAOERR(3158) //Couldn't save record; currently locked by another user.
#define E_DAO_InvalidBookmark				DBDAOERR(3159) //Not a valid bookmark.
#define E_DAO_TableNotOpen					DBDAOERR(3160) //Table isn't open.
#define E_DAO_DecryptFail					DBDAOERR(3161) //Couldn't decrypt file.
#define E_DAO_NullInvalid					DBDAOERR(3162) //Null is invalid.
#define E_DAO_InvalidBufferSize				DBDAOERR(3163) //Couldn't perform operation; data too long for field.
#define E_DAO_ColumnNotUpdatable			DBDAOERR(3164) //Field can't be updated.
#define E_DAO_CantMakeINFFile				DBDAOERR(3165) //Couldn't open .INF file.
#define E_DAO_MissingMemoFile				DBDAOERR(3166) //Missing memo file.
#define E_DAO_RecordDeleted					DBDAOERR(3167) //Record is deleted.
#define E_DAO_INFFileError					DBDAOERR(3168) //Invalid .INF file.
#define E_DAO_ExprIllegalType				DBDAOERR(3169) //Illegal type in expression.
#define E_DAO_InstalIsamNotFound			DBDAOERR(3170) //Couldn't find installable ISAM.
#define E_DAO_NoConfigParameters			DBDAOERR(3171) //Couldn't find net path or user name.
#define E_DAO_CantAccessPdoxNetDir			DBDAOERR(3172) //Couldn't open PARADOX.NET.
#define E_DAO_NoMSysAccounts				DBDAOERR(3173) //Couldn't open table 'MSysAccounts' in the system database file.
#define E_DAO_NoMSysGroups					DBDAOERR(3174) //Couldn't open table 'MSysGroups' in the system database file.
#define E_DAO_DateOutOfRange				DBDAOERR(3175) //Date is out of range or is in an invalid format.
#define E_DAO_ImexCantOpenFile				DBDAOERR(3176) //Couldn't open file '|'.
#define E_DAO_ImexBadTableName				DBDAOERR(3177) //Not a valid table name.
#define E_DAO_ImexOutOfMemory				DBDAOERR(3178) //*
#define E_DAO_ImexEndofFile					DBDAOERR(3179) //Encountered unexpected end of file.
#define E_DAO_ImexCantWriteToFile			DBDAOERR(3180) //Couldn't write to file '|'.
#define E_DAO_ImexBadRange					DBDAOERR(3181) //Invalid range.
#define E_DAO_ImexBogusFile					DBDAOERR(3182) //Invalid file format.
#define E_DAO_TempDiskFull					DBDAOERR(3183) //Not enough space on temporary disk.
#define E_DAO_RmtLinkNotFound				DBDAOERR(3184) //Couldn't execute query; couldn't find attached, or linked, table.
#define E_DAO_RmtTooManyColumns				DBDAOERR(3185) //SELECT INTO remote database tried to produce too many fields.
#define E_DAO_ReadConflictM					DBDAOERR(3186) //Couldn't save; currently locked by user '|2' on machine '|1'.
#define E_DAO_CommitConflictM				DBDAOERR(3187) //Couldn't read; currently locked by user '|2' on machine '|1'.
#define E_DAO_SessionWriteConflict			DBDAOERR(3188) //Couldn't update; currently locked by another session on this machine.
#define E_DAO_JetSpecialTableLocked			DBDAOERR(3189) //Table '|1' is exclusively locked by user '|3' on machine '|2'.
#define E_DAO_TooManyColumns				DBDAOERR(3190) //Too many fields defined.
#define E_DAO_ColumnDuplicate				DBDAOERR(3191) //Can't define field more than once.
#define E_DAO_OutputTableNotFound			DBDAOERR(3192) //Couldn't find output table '|'.
#define E_DAO_JetNoUserName					DBDAOERR(3193) //(unknown)
#define E_DAO_JetNoMachineName				DBDAOERR(3194) //(unknown)
#define E_DAO_JetNoColumnName				DBDAOERR(3195) //(expression)
#define E_DAO_DatabaseInUse					DBDAOERR(3196) //Couldn't use '|'; database already in use.
#define E_DAO_DataHasChanged				DBDAOERR(3197) //Data has changed; operation stopped.
#define E_DAO_TooManySessions				DBDAOERR(3198) //Couldn't start session.  Too many sessions already active.
#define E_DAO_ReferenceNotFound				DBDAOERR(3199) //Couldn't find reference.
#define E_DAO_IntegrityViolMasterM			DBDAOERR(3200) //Can't delete or change record.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_IntegrityViolSlaveM			DBDAOERR(3201) //Can't add or change record.  Referential integrity rules require a related record in table '|'.
#define E_DAO_ReadConflict					DBDAOERR(3202) //Couldn't save; currently locked by another user.
#define E_DAO_AggregatingHigherLevel		DBDAOERR(3203) //Can't specify subquery in expression (|).
#define E_DAO_DatabaseDuplicate				DBDAOERR(3204) //Database already exists.
#define E_DAO_QueryTooManyXvtColumn			DBDAOERR(3205) //Too many crosstab column headers (|).
#define E_DAO_SelfReference					DBDAOERR(3206) //Can't create a relationship between a field and itself.
#define E_DAO_CantUseUnkeyedTable			DBDAOERR(3207) //Operation not supported on Paradox table with no primary key.
#define E_DAO_IllegalDeletedOption			DBDAOERR(3208) //Invalid Deleted entry in the Xbase section of initialization setting.
#define E_DAO_IllegalStatsOption			DBDAOERR(3209) //Invalid Stats entry in the Xbase section of initialization setting.
#define E_DAO_ConnStrTooLong				DBDAOERR(3210) //Connection string too long.
#define E_DAO_TableInUseQM					DBDAOERR(3211) //Couldn't lock table '|'; currently in use.
#define E_DAO_JetSpecialTableInUse			DBDAOERR(3212) //Couldn't lock table '|1'; currently in use by user '|3' on machine '|2'.
#define E_DAO_IllegalDateOption				DBDAOERR(3213) //Invalid Date entry in the Xbase section of initialization setting.
#define E_DAO_IllegalMarkOption				DBDAOERR(3214) //Invalid Mark entry in the Xbase section of initialization setting.
#define E_DAO_BtrieveTooManyTasks			DBDAOERR(3215) //Too many Btrieve tasks.
#define E_DAO_QueryParmNotTableid			DBDAOERR(3216) //Parameter '|' specified where a table name is required.
#define E_DAO_QueryParmNotDatabase			DBDAOERR(3217) //Parameter '|' specified where a database name is required.
#define E_DAO_WriteConflict					DBDAOERR(3218) //Couldn't update; currently locked.
#define E_DAO_IllegalOperation				DBDAOERR(3219) //Invalid operation.
#define E_DAO_WrongCollatingSequence		DBDAOERR(3220) //Incorrect collating sequence.
#define E_DAO_BadConfigParameters			DBDAOERR(3221) //Invalid entries in the Btrieve section of initialization setting.
#define E_DAO_QueryContainsDbParm			DBDAOERR(3222) //Query can't contain a Database parameter.
#define E_DAO_QueryInvalidParmM				DBDAOERR(3223) //'|' isn't a valid parameter name.
#define E_DAO_BtrieveDDCorrupted			DBDAOERR(3224) //Can't read Btrieve data dictionary.
#define E_DAO_BtrieveDeadlock				DBDAOERR(3225) //Encountered record locking deadlock while performing Btrieve operation.
#define E_DAO_BtrieveFailure				DBDAOERR(3226) //Errors encountered while using the Btrieve DLL.
#define E_DAO_IllegalCenturyOption			DBDAOERR(3227) //Invalid Century entry in the Xbase section of initialization setting.
#define E_DAO_IllegalCollatingSeq			DBDAOERR(3228) //Invalid Collating Sequence.
#define E_DAO_NonModifiableKey				DBDAOERR(3229) //Btrieve--can't change field.
#define E_DAO_ObsoleteLockFile				DBDAOERR(3230) //Out-of-date Paradox lock file.
#define E_DAO_RmtColDataTruncated			DBDAOERR(3231) //ODBC--field would be too long; data truncated.
#define E_DAO_RmtCreateTableFailed			DBDAOERR(3232) //ODBC--couldn't create table.
#define E_DAO_RmtOdbcVer					DBDAOERR(3233) //*
#define E_DAO_RmtQueryTimeout				DBDAOERR(3234) //ODBC--remote query timeout expired.
#define E_DAO_RmtTypeIncompat				DBDAOERR(3235) //ODBC--data type not supported on server.
#define E_DAO_RmtUnexpectedNull				DBDAOERR(3236) //*
#define E_DAO_RmtUnexpectedType				DBDAOERR(3237) //*
#define E_DAO_RmtValueOutOfRange			DBDAOERR(3238) //ODBC--data out of range.
#define E_DAO_TooManyActiveUsers			DBDAOERR(3239) //Too many active users.
#define E_DAO_CantStartBtrieve				DBDAOERR(3240) //Btrieve--missing Btrieve engine.
#define E_DAO_OutOfBVResources				DBDAOERR(3241) //Btrieve--out of resources.
#define E_DAO_QueryBadUpwardRefedM			DBDAOERR(3242) //Invalid reference in SELECT statement.
#define E_DAO_ImexNoMatchingColumns			DBDAOERR(3243) //None of the import field names match fields in the appended table.
#define E_DAO_ImexPasswordProtected			DBDAOERR(3244) //Can't import password-protected spreadsheet.
#define E_DAO_ImexUnparsableRecord			DBDAOERR(3245) //Couldn't parse field names from first row of import table.
#define E_DAO_InTransaction					DBDAOERR(3246) //Operation not supported in transactions.
#define E_DAO_RmtLinkOutOfSync				DBDAOERR(3247) //ODBC--linked table definition has changed.
#define E_DAO_IllegalNetworkOption			DBDAOERR(3248) //Invalid NetworkAccess entry in initialization setting.
#define E_DAO_IllegalTimeoutOption			DBDAOERR(3249) //Invalid PageTimeout entry in initialization setting.
#define E_DAO_CantBuildKey					DBDAOERR(3250) //Couldn't build key.
#define E_DAO_FeatureNotAvailable			DBDAOERR(3251) //Operation is not supported for this type of object.
#define E_DAO_IllegalReentrancy				DBDAOERR(3252) //Can't open form whose underlying query contains a user-defined function that attempts to set or get the form's RecordsetClone property.
#define E_DAO_UNUSED						DBDAOERR(3253) //*
#define E_DAO_RmtDenyWriteIsInvalid			DBDAOERR(3254) //ODBC--Can't lock all records.
#define E_DAO_ODBCParmsChanged				DBDAOERR(3255) //*
#define E_DAO_INFIndexNotFound 				DBDAOERR(3256) //Index file not found.
#define E_DAO_SQLOwnerAccessSyntax			DBDAOERR(3257) //Syntax error in WITH OWNERACCESS OPTION declaration.
#define E_DAO_QueryAmbiguousJoins			DBDAOERR(3258) //Query contains ambiguous outer joins.
#define E_DAO_InvalidColumnType				DBDAOERR(3259) //Invalid field data type.
#define E_DAO_WriteConflictM				DBDAOERR(3260) //Couldn't update; currently locked by user '|2' on machine '|1'.
#define E_DAO_TableLockedM					DBDAOERR(3261) //|
#define E_DAO_TableInUseMUQM				DBDAOERR(3262) //|
#define E_DAO_InvalidTableId				DBDAOERR(3263) //Invalid database object.
#define E_DAO_VtoNoFields					DBDAOERR(3264) //No fields defined - cannot append Tabledef or Index.
#define E_DAO_VtoNameNotFound				DBDAOERR(3265) //Item not found in this collection.
#define E_DAO_VtoFieldInCollection			DBDAOERR(3266) //Can't append.  Field is part of a TableDefs collection.
#define E_DAO_VtoNotARecordset				DBDAOERR(3267) //Property can be set only when the field is part of a Recordset object's Fields collection.
#define E_DAO_VtoNoSetObjInDb				DBDAOERR(3268) //Can't set this property once the object is part of a collection.
#define E_DAO_VtoIndexInCollection			DBDAOERR(3269) //Can't append.  Index is part of a TableDefs collection.
#define E_DAO_VtoPropNotFound				DBDAOERR(3270) //Property not found.
#define E_DAO_VtoIllegalValue				DBDAOERR(3271) //Invalid property value.
#define E_DAO_VtoNotArray					DBDAOERR(3272) //Object isn't a collection.
#define E_DAO_VtoNoSuchMethod				DBDAOERR(3273) //Method not applicable for this object.
#define E_DAO_NotExternalFormat				DBDAOERR(3274) //External table isn't in the expected format.
#define E_DAO_UnexpectedEngineReturn		DBDAOERR(3275) //Unexpected error from external database driver (|).
#define E_DAO_InvalidDatabaseId				DBDAOERR(3276) //Invalid database ID.
#define E_DAO_TooManyKeys					DBDAOERR(3277) //Can't have more than 10 fields in an index.
#define E_DAO_NotInitialized				DBDAOERR(3278) //Database engine hasn't been initialized.
#define E_DAO_AlreadyInitialized			DBDAOERR(3279) //Database engine has already been initialized.
#define E_DAO_ColumnInUse					DBDAOERR(3280) //Can't delete a field that is part of an index or is needed by the system.
#define E_DAO_IndexInUse					DBDAOERR(3281) //Can't delete this index.  It is either the current index or is used in a relationship.
#define E_DAO_TableNotEmpty					DBDAOERR(3282) //Can't create field or index in a table that is already defined.
#define E_DAO_IndexHasPrimary				DBDAOERR(3283) //Primary key already exists.
#define E_DAO_IndexDuplicate				DBDAOERR(3284) //Index already exists.
#define E_DAO_IndexInvalidDef				DBDAOERR(3285) //Invalid index definition.
#define E_DAO_WrongMemoFileType				DBDAOERR(3286) //Format of memo file doesn't match specified external database format.
#define E_DAO_ColumnCannotIndex				DBDAOERR(3287) //Can't create index on the given field.
#define E_DAO_IndexHasNoPrimary				DBDAOERR(3288) //Paradox index is not primary.
#define E_DAO_DDLConstraintSyntax			DBDAOERR(3289) //Syntax error in CONSTRAINT clause.
#define E_DAO_DDLCreateTableSyntax			DBDAOERR(3290) //Syntax error in CREATE TABLE statement.
#define E_DAO_DDLCreateIndexSyntax			DBDAOERR(3291) //Syntax error in CREATE INDEX statement.
#define E_DAO_DDLColumnDefSyntax			DBDAOERR(3292) //Syntax error in field definition.
#define E_DAO_DDLAlterTableSyntax			DBDAOERR(3293) //Syntax error in ALTER TABLE statement.
#define E_DAO_DDLDropIndexSyntax			DBDAOERR(3294) //Syntax error in DROP INDEX statement.
#define E_DAO_DDLDropSyntax					DBDAOERR(3295) //Syntax error in DROP TABLE or DROP INDEX.
#define E_DAO_V11NotSupported				DBDAOERR(3296) //Join expression not supported.
#define E_DAO_ImexNothingToImport			DBDAOERR(3297) //Couldn't import table or query.  No records found, or all records contain errors.
#define E_DAO_RmtTableAmbiguous				DBDAOERR(3298) //There are several tables with that name.  Please specify owner in the format 'owner.table'.
#define E_DAO_JetODBCConformanceError		DBDAOERR(3299) //ODBC Specification Conformance Error (|).  This error should be reported to the ODBC driver vendor.
#define E_DAO_IllegalRelationship			DBDAOERR(3300) //Can't create a relationship.
#define E_DAO_DBVerFeatureNotAvailable		DBDAOERR(3301) //Can't perform this operation; features in this version are not available in databases with older formats.
#define E_DAO_RulesLoaded					DBDAOERR(3302) //Can't change a rule while the rules for this table are in use.
#define E_DAO_ColumnInRelationship			DBDAOERR(3303) //Can't delete this field.  It's part of one or more relationships.
#define E_DAO_InvalidPin					DBDAOERR(3304) //You must enter a personal identifier (PID) consisting of at least four and no more than 20 characters and digits.
#define E_DAO_RmtBogusConnStr				DBDAOERR(3305) //Invalid connection string in pass-through query.
#define E_DAO_SingleColumnExpected			DBDAOERR(3306) //At most one field can be returned from a subquery that doesn't use the EXISTS keyword.
#define E_DAO_ColumnCountMismatch			DBDAOERR(3307) //The number of columns in the two selected tables or queries of a union query don't match.
#define E_DAO_InvalidTopArgumentM			DBDAOERR(3308) //Invalid TOP argument in select query.
#define E_DAO_PropertyTooLarge				DBDAOERR(3309) //Property setting can't be larger than 2 KB.
#define E_DAO_JPMInvalidForV1x				DBDAOERR(3310) //This property isn't supported for external data sources or for databases created in a previous version.
#define E_DAO_PropertyExists				DBDAOERR(3311) //Property specified already exists.
#define E_DAO_TLVNativeUserTablesOnly		DBDAOERR(3312) //Validation rules and default values can't be placed on system or attached (linked) tables.
#define E_DAO_TLVInvalidColumn				DBDAOERR(3313) //Can't place this validation expression on this field.
#define E_DAO_TLVNoNullM					DBDAOERR(3314) //Field '|' can't contain a null value.
#define E_DAO_TLVNoBlankM					DBDAOERR(3315) //Field '|' can't be a zero-length string.
#define E_DAO_TLVRuleViolationM				DBDAOERR(3316) //|
#define E_DAO_TLVRuleVioNoMessage			DBDAOERR(3317) //One or more values entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_QueryTopNotAllowedM			DBDAOERR(3318) //Top not allowed in delete queries.
#define E_DAO_SQLUnionSyntax				DBDAOERR(3319) //Syntax error in union query.
#define E_DAO_TLVExprSyntaxM				DBDAOERR(3320) //| in table-level validation expression.
#define E_DAO_NoDbInConnStr					DBDAOERR(3321) //No database specified in connection string or IN clause.
#define E_DAO_QueryBadValueListM			DBDAOERR(3322) //Crosstab query contains one or more invalid fixed column headings.
#define E_DAO_QueryIsNotRowReturning		DBDAOERR(3323) //The query can not be used as a row source.
#define E_DAO_QueryIsDDL					DBDAOERR(3324) //This query is a DDL query and cannot be used as a row source.
#define E_DAO_SPTReturnedNoRecords			DBDAOERR(3325) //Pass-through query with ReturnsRecords property set to True did not return any records.
#define E_DAO_QueryIsSnapshot				DBDAOERR(3326) //This Recordset is not updatable.
#define E_DAO_QueryExprOutput				DBDAOERR(3327) //Field '|' is based on an expression and can't be edited.
#define E_DAO_QueryTableRO					DBDAOERR(3328) //Table '|2' is read-only.
#define E_DAO_QueryRowDeleted				DBDAOERR(3329) //Record in table '|' was deleted by another user.
#define E_DAO_QueryRowLocked				DBDAOERR(3330) //Record in table '|' is locked by another user.
#define E_DAO_QueryFixupChanged				DBDAOERR(3331) //To make changes to this field, first save the record.
#define E_DAO_QueryCantFillIn				DBDAOERR(3332) //Can't enter value into blank field on 'one' side of outer join.
#define E_DAO_QueryWouldOrphan				DBDAOERR(3333) //Records in table '|' would have no record on the 'one' side.
#define E_DAO_V10Format						DBDAOERR(3334) //Can be present only in version 1.0 format.
#define E_DAO_InvalidDelete					DBDAOERR(3335) //DeleteOnly called with non-zero cbData.
#define E_DAO_IllegalIndexDDFOption			DBDAOERR(3336) //Btrieve: Invalid IndexDDF option in initialization setting.
#define E_DAO_IllegalDataCodePage			DBDAOERR(3337) //Invalid DataCodePage option in initialization setting.
#define E_DAO_XtrieveEnvironmentError		DBDAOERR(3338) //Btrieve: Xtrieve options aren't correct in initialization setting.
#define E_DAO_IllegalIndexNumberOption		DBDAOERR(3339) //Btrieve: Invalid IndexDeleteRenumber option in initialization setting.
#define E_DAO_QueryIsCorruptM				DBDAOERR(3340) //Query '|' is corrupt.
#define E_DAO_IncorrectJoinKeyM				DBDAOERR(3341) //Current field must match join key '|' on 'one' side of outer join because it has been updated.
#define E_DAO_QueryLVInSubqueryM			DBDAOERR(3342) //Invalid Memo or OLE object in subquery '|'.
#define E_DAO_InvalidDatabaseM				DBDAOERR(3343) //Unrecognized database format '|'.
#define E_DAO_TLVCouldNotBindRef			DBDAOERR(3344) //Unknown or invalid reference '|1' in validation expression or default value in table '|2'.
#define E_DAO_CouldNotBindRef				DBDAOERR(3345) //Unknown or invalid field reference '|'.
#define E_DAO_QueryWrongNumDestCol			DBDAOERR(3346) //Number of query values and destination fields aren't the same.
#define E_DAO_QueryPKeyNotOutput			DBDAOERR(3347) //Can't add record(s); primary key for table '|' not in recordset.
#define E_DAO_QueryJKeyNotOutput			DBDAOERR(3348) //Can't add record(s); join key of table '|' not in recordset.
#define E_DAO_NumericFieldOverflow			DBDAOERR(3349) //Numeric field overflow.
#define E_DAO_InvalidObject					DBDAOERR(3350) //Object is invalid for operation.
#define E_DAO_OrderVsUnion					DBDAOERR(3351) //ORDER BY expression (|) uses non-output fields.
#define E_DAO_NoInsertColumnNameM			DBDAOERR(3352) //No destination field name in INSERT INTO statement (|).
#define E_DAO_MissingDDFFile				DBDAOERR(3353) //Btrieve: Can't find file FIELD.DDF.
#define E_DAO_SingleRecordExpected			DBDAOERR(3354) //At most one record can be returned by this subquery.
#define E_DAO_DefaultExprSyntax				DBDAOERR(3355) //Syntax error in default value.
#define E_DAO_ExclusiveDBConflict			DBDAOERR(3356) //The database is opened by user '|2' on machine '|1'.
#define E_DAO_QueryIsNotDDL					DBDAOERR(3357) //This query is not a properly formed data-definition query.
#define E_DAO_SysDatabaseOpenError			DBDAOERR(3358) //Can't open Microsoft Jet engine system database.
#define E_DAO_SQLInvalidSPT					DBDAOERR(3359) //Pass-through query must contain at least one character.
#define E_DAO_QueryTooComplex				DBDAOERR(3360) //Query is too complex.
#define E_DAO_SetOpInvalidInSubquery		DBDAOERR(3361) //Unions not allowed in a subquery.
#define E_DAO_RmtMultiRowUpdate				DBDAOERR(3362) //Single-row update/delete affected more than one row of an attached (linked) table.  Unique index contains duplicate values.
#define E_DAO_QueryNoJoinedRecord			DBDAOERR(3363) //Record(s) can't be added; no corresponding record on the 'one' side.
#define E_DAO_QueryLVInSetOp				DBDAOERR(3364) //Can't use Memo or OLE object field '|' in SELECT clause of a union query.
#define E_DAO_VtoInvalidOnRemote			DBDAOERR(3365) //Property value not valid for REMOTE objects.
#define E_DAO_VtoNoFieldsRel				DBDAOERR(3366) //Can't append a relation with no fields defined.
#define E_DAO_VtoObjectInCollection			DBDAOERR(3367) //Can't append.  Object already in collection.
#define E_DAO_DDLDiffNumRelCols				DBDAOERR(3368) //Relationship must be on the same number of fields with the same data types.
#define E_DAO_DDLIndexColNotFound			DBDAOERR(3369) //Can't find field in index definition.
#define E_DAO_DDLPermissionDenied			DBDAOERR(3370) //Can't modify the design of table '|'.  It's in a read-only database.
#define E_DAO_DDLObjectNotFound				DBDAOERR(3371) //Can't find table or constraint.
#define E_DAO_DDLIndexNotFound				DBDAOERR(3372) //No such index '|2' on table '|1'.
#define E_DAO_DDLNoPkeyOnRefdTable			DBDAOERR(3373) //Can't create relationship.  Referenced table '|' doesn't have a primary key.
#define E_DAO_DDLColumnsNotUnique			DBDAOERR(3374) //The specified fields are not uniquely indexed in table '|'.
#define E_DAO_DDLIndexDuplicate				DBDAOERR(3375) //Table '|1' already has an index named '|2'
#define E_DAO_DDLTableNotFound				DBDAOERR(3376) //Table '|' doesn't exist.
#define E_DAO_DDLRelNotFound				DBDAOERR(3377) //No such relationship '|2' on table '|1'.
#define E_DAO_DDLRelDuplicate				DBDAOERR(3378) //There is already a relationship named '|' in the current database.
#define E_DAO_DDLIntegrityViolation			DBDAOERR(3379) //Can't create relationships to enforce referential integrity.  Existing data in table '|2' violates referential integrity rules with related table '|1'.
#define E_DAO_DDLColumnDuplicate			DBDAOERR(3380) //Field '|2' already exists in table '|1'.
#define E_DAO_DDLColumnNotFound				DBDAOERR(3381) //There is no field named '|2' in table '|1'.
#define E_DAO_DDLColumnTooBig				DBDAOERR(3382) //The size of field '|' is too long.
#define E_DAO_DDLColumnInRel				DBDAOERR(3383) //Can't delete field '|'.  It's part of one or more relationships.
#define E_DAO_VtoCantDeleteBuiltIn			DBDAOERR(3384) //Can't delete a built-in property.
#define E_DAO_VtoUDPsDontSupportNull		DBDAOERR(3385) //User-defined properties don't support a Null value.
#define E_DAO_VtoMissingRequiredParm		DBDAOERR(3386) //Property '|' must be set before using this method.
#define E_DAO_JetJetInitInvalidPath			DBDAOERR(3387) //Can't find TEMP directory.
#define E_DAO_TLVExprUnknownFunctionM		DBDAOERR(3388) //Unknown function '|2' in validation expression or default value on '|1'.
#define E_DAO_QueryNotSupported				DBDAOERR(3389) //Query support unavailable.
#define E_DAO_AccountDuplicate				DBDAOERR(3390) //Account name already exists.
#define E_DAO_JetwrnPropCouldNotSave		DBDAOERR(3391) //An error has occurred.  Properties were not saved.
#define E_DAO_RelNoPrimaryIndexM			DBDAOERR(3392) //There is no primary key in table '|'.
#define E_DAO_QueryKeyTooBig				DBDAOERR(3393) //Can't perform join, group, sort, or indexed restriction. A value being searched or sorted on is too long.
#define E_DAO_PropMustBeDDL					DBDAOERR(3394) //Can't save property; property is a schema property.
#define E_DAO_IllegalRIConstraint			DBDAOERR(3395) //Invalid referential integrity constraint.
#define E_DAO_RIViolationMasterCM			DBDAOERR(3396) //Can't perform cascading operation.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_RIViolationSlaveCM			DBDAOERR(3397) //Can't perform cascading operation.  There must be a related record in table '|'.
#define E_DAO_RIKeyNullDisallowedCM			DBDAOERR(3398) //Can't perform cascading operation.  It would result in a null key in table '|'.
#define E_DAO_RIKeyDuplicateCM				DBDAOERR(3399) //Can't perform cascading operation.  It would result in a duplicate key in table '|'.
#define E_DAO_RIUpdateTwiceCM				DBDAOERR(3400) //Can't perform cascading operation.  It would result in two updates on field '|2' in table '|1'.
#define E_DAO_RITLVNoNullCM					DBDAOERR(3401) //Can't perform cascading operation.  It would cause field '|' to become null, which is not allowed.
#define E_DAO_RITLVNoBlankCM				DBDAOERR(3402) //Can't perform cascading operation.  It would cause field '|' to become a zero-length string, which is not allowed.
#define E_DAO_RITLVRuleViolationCM			DBDAOERR(3403) //Can't perform cascading operation:  '|'
#define E_DAO_RITLVRuleVioCNoMessage		DBDAOERR(3404) //Can't perform cascading operation.  The value entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_TLVRuleEvalEBESErr			DBDAOERR(3405) //Error '|' in validation rule.
#define E_DAO_TLVDefaultEvalEBESErr			DBDAOERR(3406) //Error '|' in default value.
#define E_DAO_BadMSysConf					DBDAOERR(3407) //The server's MSysConf table exists, but is in an incorrect format.  Contact your system administrator.
#define E_DAO_TooManyFindSessions			DBDAOERR(3408) //Too many FastFind Sessions were invoked.
#define E_DAO_InvalidColumnM				DBDAOERR(3409) //Invalid field name '|' in definition of index or relationship.
#define E_DAO_REPReadOnly					DBDAOERR(3410) //*
#define E_DAO_RIInvalidBufferSizeCM			DBDAOERR(3411) //Invalid entry.  Can't perform cascading operation specified in table '|1' because value entered is too big for field '|2'.
#define E_DAO_RIWriteConflictCM				DBDAOERR(3412) //|
#define E_DAO_JetSpecialRIWriteConflictCM	DBDAOERR(3413) //Can't perform cascading update on table '|1' because it is currently in use by user '|3' on machine '|2'.
#define E_DAO_RISessWriteConflictCM			DBDAOERR(3414) //Can't perform cascading update on table '|' because it is currently in use.
#define E_DAO_NoBlank						DBDAOERR(3415) //Zero-length string is valid only in a text or Memo field.
#define E_DAO_FutureError					DBDAOERR(3416) //|
#define E_DAO_QueryInvalidBulkInput			DBDAOERR(3417) //An action query cannot be used as a row source.
#define E_DAO_NetCtrlMismatch				DBDAOERR(3418) //Can't open '|'.  Another user has the table open using a different network control file or locking style.
#define E_DAO_4xTableWith3xLocking			DBDAOERR(3419) //Can't open this Paradox 4.x or Paradox 5.x table because ParadoxNetStyle is set to 3.x in the initialization setting.
#define E_DAO_VtoObjectNotSet				DBDAOERR(3420) //Object is invalid or not set.
#define E_DAO_VtoDataConvError				DBDAOERR(3421) //Data type conversion error.
#define E_DAO_TableNotLocked				DBDAOERR(3422) //Can't modify table structure.  Another user has the table open
#define E_DAO_RmtDriverNotSupported			DBDAOERR(3423) //You cannot use ODBC to attach an external Microsoft Access or ISAM database table to your database
#define E_DAO_InvalidLanguageId				DBDAOERR(3424) //Can't create database; Invalid locale
#define E_DAO_VtoInvalidOpDuringCallback	DBDAOERR(3425) //This method or property is not currently available on this Recordset
#define E_DAO_VtoActionCancelled			DBDAOERR(3426) //The action was cancelled by an associated object
#define E_DAO_VtoOleAutoFailed				DBDAOERR(3427) //Error in DAO automation
#define E_DAO_DatabaseCorrupted_Cmpct		DBDAOERR(3428) //The Jet database engine has encountered a problem in your database.  To correct the problem, you must repair and compact the database
#define E_DAO_IncompatibleIIsam				DBDAOERR(3429) //Incompatible installable ISAM version
#define E_DAO_OLEInitializeFailure			DBDAOERR(3430) //While loading the Excel installable ISAM, OLE was unable to initialize
#define E_DAO_OLENotCompoundFile			DBDAOERR(3431) //This is not an Excel 5 file
#define E_DAO_OLEFailure					DBDAOERR(3432) //Error opening an Excel 5 file
#define E_DAO_IllegalIisamIniOption			DBDAOERR(3433) //Invalid parameter in [Excel ISAM] section of the initialization file
#define E_DAO_TableFull						DBDAOERR(3434) //Can't expand named range
#define E_DAO_TableCantClear				DBDAOERR(3435) //Cannot delete Excel cells
#define E_DAO_CreateFailed					DBDAOERR(3436) //Failure creating file
#define E_DAO_DatabaseFull					DBDAOERR(3437) //Excel spreadsheet is full
#define E_DAO_SpecAndColumnMismatch			DBDAOERR(3438) //File specification and data do not match
#define E_DAO_CantOpenWordMergeFiles		DBDAOERR(3439) //Can't attach or import Word mail merge file
#define E_DAO_FileHasNoColumns				DBDAOERR(3440) //Text file has no columns
#define E_DAO_AmbiguousDelimiters			DBDAOERR(3441) //Text file specification field separator matches decimal seperator or text delimiter
#define E_DAO_FileSpecErrorM				DBDAOERR(3442) //Error in entry |2 of section [|1] in schema.ini
#define E_DAO_NoSpecForFixedFormatM			DBDAOERR(3443) //Can't create fixed width text file without column specification in section [|2] of schema.ini
#define E_DAO_WidthMissInFixedSpecM			DBDAOERR(3444) //Column width required for column |2 in section [|1] of schema.ini
#define E_DAO_VtoWrongDllVersion			DBDAOERR(3445) //Incorrect version of JET DLL found
#define E_DAO_VtoMissingVBA					DBDAOERR(3446) //Could not locate a VBA related file
#define E_DAO_VtoVBAFailed					DBDAOERR(3447) //Failed to initialize VBA
#define E_DAO_VtoOLEFailed					DBDAOERR(3448) //An OLE system function failed
#define E_DAO_InvalidCountry				DBDAOERR(3449) //Missing country code
#define E_DAO_QueryIncompleteRowM			DBDAOERR(3450) //Syntax error in query.  Incomplete query clause
#define E_DAO_QueryParmTypeNotAllowed		DBDAOERR(3451) //Illegal reference in query
#define E_DAO_REPDBNotMaster				DBDAOERR(3452) //You can't make changes to the design of the database at this replica.
#define E_DAO_REPCantRelate					DBDAOERR(3453) //You can't establish or maintain an enforced relationship between a replicated table and a local table.
#define E_DAO_REPNotOwner					DBDAOERR(3454) //*
#define E_DAO_CantMakeReplicable			DBDAOERR(3455) //Can't make the database replicable.
#define E_DAO_CantMakeObjectReplicable		DBDAOERR(3456) //Can't make the |2 object in |1 container replicable.
#define E_DAO_REPCantKeepLocal				DBDAOERR(3457) //You can't set the KeepLocal property for an object that is already replicated.
#define E_DAO_REPCantKeepDBLocal			DBDAOERR(3458) //The KeepLocal property cannot be set on a database; it can be set only on the objects in a database.
#define E_DAO_CantUnreplDatabase			DBDAOERR(3459) //After a database has been replicated, you cannot remove the replication features from the database.
#define E_DAO_ReplConflict					DBDAOERR(3460) //The operation you attempted conflicts with an existing operation involving this member of the replica set.
#define E_DAO_REPSetRepid					DBDAOERR(3461) //The replication property you are attempting to set or delete is read-only and can't be changed.
#define E_DAO_TransportLoadFailure			DBDAOERR(3462) //Failure to load a DLL.
#define E_DAO_TransportLoadFailureM			DBDAOERR(3463) //Can't find the .dll '|2'.
#define E_DAO_TypeMismatchM					DBDAOERR(3464) //Data type mismatch in criteria expression.
#define E_DAO_DiskIOM						DBDAOERR(3465) //The disk drive you are attempting to access is unreadable.
#define E_DAO_FileAccessDeniedM				DBDAOERR(3466) //*
#define E_DAO_InvalidPathM					DBDAOERR(3467) //*
#define E_DAO_TranspAccessDeniedM			DBDAOERR(3468) //Access was denied while accessing dropbox folder '|2'.
#define E_DAO_TransportDiskFullM			DBDAOERR(3469) //The disk for dropbox folder '|2' is full.
#define E_DAO_TransportDiskIOM				DBDAOERR(3470) //Disk failure accessing dropbox folder '|2'.
#define E_DAO_LogWriteFail					DBDAOERR(3471) //Failure to write to the Synchronizer log file.
#define E_DAO_LogDiskFullM					DBDAOERR(3472) //Disk full for path '|1'.
#define E_DAO_LogDiskIOM					DBDAOERR(3473) //Disk failure while accessing log file '|1'.
#define E_DAO_LogFileAccessDeniedM			DBDAOERR(3474) //Can't open the log file '|1' for writing.
#define E_DAO_LogFileShareViolationM		DBDAOERR(3475) //Sharing violation while attempting to open log file '|1' in Deny Write mode.
#define E_DAO_TransportInvalidPathM			DBDAOERR(3476) //Invalid dropbox path '|2'.
#define E_DAO_TranspInvalidAddressM			DBDAOERR(3477) //Dropbox address '|2' is syntactically invalid.
#define E_DAO_RepNotPartial					DBDAOERR(3478) //The replica is not a partial replica.
#define E_DAO_RepPartial					DBDAOERR(3479) //Can't designate a partial replica as the Design Master for the replica set.
#define E_DAO_PARTInvalidRelNameM			DBDAOERR(3480) //The relationship '|' in the partial filter expression is invalid.
#define E_DAO_PARTInvalidTableNameM			DBDAOERR(3481) //The table name '|' in the partial filter expression is invalid.
#define E_DAO_REPInvalidFilter				DBDAOERR(3482) //The filter expression for the partial replica is invalid.
#define E_DAO_TranspInvalidPasswordM		DBDAOERR(3483) //The password supplied for the dropbox folder '|2' is invalid.
#define E_DAO_TransDestInvalidPassword		DBDAOERR(3484) //The password used by the Synchronizer to write to a destination dropbox folder is invalid.
#define E_DAO_REPDBNotRep					DBDAOERR(3485) //The object can't be replicated because the database is not replicated.
#define E_DAO_REPSecondGuid					DBDAOERR(3486) //You can't add a second Replication ID AutoNumber field to a table.
#define E_DAO_REPOnlyBuiltin				DBDAOERR(3487) //The database you are attempting to replicate can't be converted.
#define E_DAO_REPNoSuchRepid				DBDAOERR(3488) //The value specified is not a ReplicaID for any member in the replica set.
#define E_DAO_REPObjectNotRep				DBDAOERR(3489) //The object specified can't be replicated because it is missing a  necessary resource.
#define E_DAO_CantCreateReplica				DBDAOERR(3490) //Can't create a new replica because the '|2' object in '|1' container could not be replicated.
#define E_DAO_MustOpenDbExclusive			DBDAOERR(3491) //The database must be opened in exclusive mode before it can be replicated.
#define E_DAO_CantDoSchemaChange			DBDAOERR(3492) //The synchronization failed because a design change could not be applied to one of the replicas.
#define E_DAO_UnableToSetParam				DBDAOERR(3493) //Can't set the specified Registry parameter for the Synchronizer.
#define E_DAO_UnableToGetParam				DBDAOERR(3494) //Unable to retrieve the specified Registry parameter for the Synchronizer.
#define E_DAO_REPNoSuchSchedule				DBDAOERR(3495) //There are no scheduled synchronizations between the two Synchronizers.
#define E_DAO_REPNoSuchExchange				DBDAOERR(3496) //Replication Manager cannot find the ExchangeID in the MSysExchangeLog table.
#define E_DAO_REPCantSetSchedule			DBDAOERR(3497) //Unable to set a schedule for the Synchronizer.
#define E_DAO_REPCantGetSchedule			DBDAOERR(3498) //*
#define E_DAO_REPCantGetDBPath				DBDAOERR(3499) //Can't retrieve the full path information for a member of the replica set.
#define E_DAO_REPCantSetExchange			DBDAOERR(3500) //You cannot specify two different Synchronizers to manage the same replica.
#define E_DAO_REPNotUpdated					DBDAOERR(3501) //*
#define E_DAO_REPNotManaged					DBDAOERR(3502) //The Design Master or replica is not being managed by a Synchronizer.
#define E_DAO_ValueNotSet					DBDAOERR(3503) //The Synchronizer's Registry has no value set for the key you queried.
#define E_DAO_REPInvalidTID					DBDAOERR(3504) //The Synchronizer ID does not match an existing ID in the MSysTranspAddress table.
#define E_DAO_REPFilterNotFound				DBDAOERR(3505) //You attempted to delete or get information about a partial filter that does not exist in MSysFilters.
#define E_DAO_OpenLog						DBDAOERR(3506) //The Synchronizer is unable to open the Synchronizer log.
#define E_DAO_WriteLog						DBDAOERR(3507) //Failure writing to the Synchronizer log.
#define E_DAO_NoTransport					DBDAOERR(3508) //There is no active transport for the Synchronizer.
#define E_DAO_TransportNotFound				DBDAOERR(3509) //Could not find a valid transport for this Synchronizer.
#define E_DAO_ReplicaAlreadyLocked			DBDAOERR(3510) //The member of the replica set you are attempting to synchronize is currently being used in another synchronization.
#define E_DAO_DBAccess						DBDAOERR(3511) //*
#define E_DAO_TransportReadFailure			DBDAOERR(3512) //Failed to read the dropbox folder.
#define E_DAO_TransportWriteFailure			DBDAOERR(3513) //Failed to write to the dropbox folder.
#define E_DAO_NoExchange					DBDAOERR(3514) //Synchronizer could not find any scheduled or on-demand synchronizations to process.
#define E_DAO_SysClock						DBDAOERR(3515) //The Microsoft Jet database engine could not read the system clock on your computer.
#define E_DAO_NoTransportAddress			DBDAOERR(3516) //Destination synchronizer is not configured to support indirect synchronronization, and the destination replica is unavailable for direct synchronization
#define E_DAO_NoMessage						DBDAOERR(3517) //Synchronizer could not find any messages to process.
#define E_DAO_TransporterNotFound			DBDAOERR(3518) //Could not find Synchronizer in the MSysTranspAddress table.
#define E_DAO_TransportSendFailure			DBDAOERR(3519) //Failed to send a message.
#define E_DAO_ReplicaNotFound				DBDAOERR(3520) //The replica name or ID does not match a currently managed member of the replica set.
#define E_DAO_OutOfSynch					DBDAOERR(3521) //Two members of the replica set cannot be synchronized because there is no common point to start the synchronization.
#define E_DAO_ExchangeNotFound				DBDAOERR(3522) //Synchronizer cannot find the record of a specific synchronization in the MSysExchangeLog table.
#define E_DAO_SchemaNotFound				DBDAOERR(3523) //Synchronizer cannot find a specific version number in the MSysSchChange table.
#define E_DAO_SchemaHistMismatch			DBDAOERR(3524) //The history of design changes in the replica does not match the history in the Design Master.
#define E_DAO_MessageDBAccess				DBDAOERR(3525) //Synchronizer could not access the message database.
#define E_DAO_ObjectAlreadyExists			DBDAOERR(3526) //The name selected for the system object is already in use.
#define E_DAO_ObjectDoesntExist				DBDAOERR(3527) //The Synchronizer or Replication Manager could not find the system object.
#define E_DAO_NoNewData						DBDAOERR(3528) //There is no new data in shared memory for the Synchronizer or Replication Manager to read.
#define E_DAO_PrevDataNotRead				DBDAOERR(3529) //The Synchronizer or Replication Manager found unread data in the shared memory. The existing data will be overwritten.
#define E_DAO_ClientAlreadyExists			DBDAOERR(3530) //The Synchronizer is already serving a client.
#define E_DAO_WaitTimeout					DBDAOERR(3531) //The wait period for an event has timed out.
#define E_DAO_ServerInitialization			DBDAOERR(3532) //Synchronizer could not be initialized.
#define E_DAO_ObjectAbandoned				DBDAOERR(3533) //The system object used by a process still exists after the process has stopped.
#define E_DAO_NoEvent						DBDAOERR(3534) //Synchronizer looked for a system event but did not find one to report to the client.
#define E_DAO_ClientSentTerm				DBDAOERR(3535) //Client has asked the Synchronizer to terminate operation.
#define E_DAO_InvalidMessage				DBDAOERR(3536) //Synchronizer received an invalid message for a member of the replica set that it manages.
#define E_DAO_NoClient						DBDAOERR(3537) //The Synchronizer's client is no longer present and cannot be notified.
#define E_DAO_TooManyTasks					DBDAOERR(3538) //Cannot initialize Synchronizer because there are too many applications running.
#define E_DAO_SysDiskIO						DBDAOERR(3539) //A system error has occurred or your swap file has reached its limit.
#define E_DAO_PageFile						DBDAOERR(3540) //Your swap file has reached its limit or is corrupted.
#define E_DAO_ProcessStillActive			DBDAOERR(3541) //Synchronizer could not be shut down properly and is still active.
#define E_DAO_ProcessAborted				DBDAOERR(3542) //Process stopped when attempting to terminate Synchronizer client.
#define E_DAO_TransporterNotSetup			DBDAOERR(3543) //Synchronizer has not been set up.
#define E_DAO_ServerAlreadyRunning			DBDAOERR(3544) //Synchronizer is already running.
#define E_DAO_DiffReplicaSet				DBDAOERR(3545) //The two replicas you are attempting to synchronize are from different replica sets.
#define E_DAO_BadExchangeType				DBDAOERR(3546) //The type of synchronization you are attempting is not valid.
#define E_DAO_NoReplica						DBDAOERR(3547) //Synchronizer could not find a replica from the correct set to complete the synchronization.
#define E_DAO_GuidMismatch					DBDAOERR(3548) //GUIDs do not match or the requested GUID could not be found.
#define E_DAO_FilenameTooLong				DBDAOERR(3549) //The file name you provided is too long.
#define E_DAO_NoGuidIndex					DBDAOERR(3550) //There is no index on the GUID column.
#define E_DAO_UnableToDeleteParam			DBDAOERR(3551) //Unable to delete the specified Registry parameter for the Synchronizer.
#define E_DAO_ValueTooBig					DBDAOERR(3552) //The size of the Registry parameter exceeds the maximum allowed.
#define E_DAO_REPGuidCreateFailure			DBDAOERR(3553) //The GUID could not be created.
#define E_DAO_REPDBMovedCopied				DBDAOERR(3554) //*
#define E_DAO_REPNoValidNick				DBDAOERR(3555) //All valid nicknames for replicas are already in use.
#define E_DAO_TransportDestInvalidPath		DBDAOERR(3556) //Invalid path for destination dropbox folder.
#define E_DAO_TransDestInvalidAddress		DBDAOERR(3557) //Invalid address for destination dropbox folder.
#define E_DAO_TransportDestDiskIO			DBDAOERR(3558) //Disk I/O error at destination dropbox folder.
#define E_DAO_TransportDestDiskFull			DBDAOERR(3559) //Failure to write because destination disk is full.
#define E_DAO_REPSameReplicaID				DBDAOERR(3560) //The two members of the replica set you are attempting to synchronize have the same ReplicaID.
#define E_DAO_REPBothMasters				DBDAOERR(3561) //The two members of the replica set you are attempting to synchronize are both Design Masters.
#define E_DAO_TransDestAccessDenied			DBDAOERR(3562) //Access denied at destination dropbox folder.
#define E_DAO_TransportSrcAccess			DBDAOERR(3563) //Fatal error accessing a local dropbox folder.
#define E_DAO_TransportSrcFileNotFound		DBDAOERR(3564) //Synchronizer can't find the source file for messages.
#define E_DAO_TransSrcSharingViolation		DBDAOERR(3565) //There is a sharing violation in the source dropbox folder because the message database is open in another application.
#define E_DAO_NetworkIO						DBDAOERR(3566) //Network I/O error.
#define E_DAO_TransportWrongMessage			DBDAOERR(3567) //Message in dropbox folder belongs to the wrong Synchronizer.
#define E_DAO_TransportDeleteFailure		DBDAOERR(3568) //Synchronizer could not delete a file.
#define E_DAO_RepRemoved					DBDAOERR(3569) //This member of the replica set has been logically removed from the set and is no longer available.
#define E_DAO_FiltersChanged				DBDAOERR(3570) //The filters defining a partial replica are out of synch with each other.
#define E_DAO_LimitedUpdate					DBDAOERR(3571) //The attempt  to set a column in a partial replica violated a rule governing partial replicas.
#define E_DAO_TempDiskIO					DBDAOERR(3572) //A disk I/O error occurred while reading or writing to the TEMP directory.
#define E_DAO_DirNotManaged					DBDAOERR(3573) //The directory you queried for a list of replicas is not a managed directory.
#define E_DAO_RepidChanged					DBDAOERR(3574) //The ReplicaID for this member of the replica set was reassigned during a move or copy procedure.
#define E_DAO_DiskFullM						DBDAOERR(3575) //The disk drive you are attempting to write to is full.
#define E_DAO_ShareViolationM				DBDAOERR(3576) //The database you are attempting to open is already in use by another application.
#define E_DAO_UpdateReplCol					DBDAOERR(3577) //Can't update replication system column.
#define E_DAO_GetDbinfoM					DBDAOERR(3578) //Failure to replicate database; can't determine whether the database is open in exclusive mode.
#define E_DAO_MakeRepTablesM				DBDAOERR(3579) //Could not create replication system tables needed to make the database replicable.
#define E_DAO_AddReplicaInfoM				DBDAOERR(3580) //Could not add rows needed to make the database replicable.
#define E_DAO_OpenRepTablesM				DBDAOERR(3581) //Can't open replication system table '|' because the table is already in use.
#define E_DAO_CreateReplicaObjectM			DBDAOERR(3582) //Cannot make a new replica because the |2 object in |1 container could not be made replicable.
#define E_DAO_MakeObjectReplM				DBDAOERR(3583) //Cannot make the |2 object in |1 container replicable.
#define E_DAO_OutOfMemoryM					DBDAOERR(3584) //Insufficient memory to complete operation.
#define E_DAO_RepTooManyColumnsM			DBDAOERR(3585) //Can't replicate the table; the number of columns exceeds the maximum allowed.
#define E_DAO_PARTFilterExprSyntaxM			DBDAOERR(3586) //Syntax error in partial filter expression on table |1.
#define E_DAO_PARTUnknownTokenM				DBDAOERR(3587) //Invalid expression in the ReplicaFilter property.
#define E_DAO_PARTExprEvaluationM			DBDAOERR(3588) //Error when evaluating the partial filter expression.
#define E_DAO_PARTExprUnknownFuncM			DBDAOERR(3589) //The partial filter expression contains an unknown function.
#define E_DAO_LimitedUpdateM				DBDAOERR(3590) //Violates the rules for partial replicas.
#define E_DAO_LogInvalidPathM				DBDAOERR(3591) //Log file path '|1' is invalid.
#define E_DAO_REPPasswdNotAllowed			DBDAOERR(3592) //You can't replicate a password-protected database or set password protection on a replicated database.
#define E_DAO_BadSingleMasterAttrib			DBDAOERR(3593) //You can't change the data master attribute for the replica set.
#define E_DAO_BadMultiMasterAttrib			DBDAOERR(3594) //You can't change the data master attribute for the replica set.  It allows data changes only at the Design Master.
#define E_DAO_REPCantRepair					DBDAOERR(3595) //The system tables in your replica are no longer reliable and the replica should not be used.
#define E_DAO_NoDataIncluded				DBDAOERR(3596) //*
#define E_DAO_SenderNotFound				DBDAOERR(3597) //*
#define E_DAO_CouldnotFindService			DBDAOERR(3598) //*
#define E_DAO_UnableToStartService			DBDAOERR(3599) //*
#define E_DAO_ExprAggIllegalOnGuid			DBDAOERR(3600) //Aggregation expressions cannot use GUIDs.
#define E_DAO_RefreshReplicaList			DBDAOERR(3601) //*
#define E_DAO_MoreWorkNeeded				DBDAOERR(3602) //*
#define E_DAO_SenderTooOld					DBDAOERR(3603) //*
#define E_DAO_RepAccess						DBDAOERR(3604) //*
#define E_DAO_REPDbNotReplicableM			DBDAOERR(3605) //Synchronizing with a non-replicated database is not allowed. The '|' database is not a Design Master or replica.
#define E_DAO_DaemonDied					DBDAOERR(3606) //*
#define E_DAO_REPCantDelete					DBDAOERR(3607) //The replication property you are attempting to delete is read-only and cannot be removed.
#define E_DAO_IndexCantBuild				DBDAOERR(3608) //Record length is too long for an indexed Paradox table.
#define E_DAO_RelNoPrimaryIndex				DBDAOERR(3609) //No unique index found for the referenced field of the primary table.
#define E_DAO_QuerySameSrcDestTableM		DBDAOERR(3610) //Same table '|' referenced as both the source and destination in make-table query.
#define E_DAO_InvalidDDLObject				DBDAOERR(3611) //Can't execute data definition statements on linked data sources.
#define E_DAO_QueryMGBWithSubquery			DBDAOERR(3612) //Multi-level GROUP BY clause is not allowed in a subquery.
#define E_DAO_SQLLinkNotSupported			DBDAOERR(3613) //Can't create a relationship on linked ODBC tables.
#define E_DAO_InvalidFindOnGUID				DBDAOERR(3614) //GUID not allowed in Find method criteria expression.
#define E_DAO_QueryJoinExprInComp			DBDAOERR(3615) //Type mismatch in JOIN expression.
#define E_DAO_UpdateNotAvailable			DBDAOERR(3616) //Updating data in a linked table is not supported by this ISAM.
#define E_DAO_DeleteNotAvailable			DBDAOERR(3617) //Deleting data in a linked table is not supported by this ISAM.
#define E_DAO_ExceptTableCreateFail			DBDAOERR(3618) //Exceptions table could not be created on import/export.
#define E_DAO_ExceptTableWriteFail			DBDAOERR(3619) //Records could not be added to exceptions table.
#define E_DAO_ExcelOLEConnectLost			DBDAOERR(3620) //The connection for viewing your linked Microsoft Excel worksheet was lost.
#define E_DAO_CantChangeDbPwdOnShared		DBDAOERR(3621) //Can't change password on a shared open database.
#define E_DAO_RmtMustCheckTimeStamp			DBDAOERR(3622) //You must use the dbSeeChanges option with OpenRecordset when accessing a SQL Server table that has an IDENTITY column.
#define E_DAO_NotWithBoundFileM				DBDAOERR(3623) //Cannot access the FoxPro 3.0 bound DBF file '|'.
#define E_DAO_CommitConflict				DBDAOERR(3624) //Couldn't read the record; currently locked by another user.
#define E_DAO_NoSuchSpecM					DBDAOERR(3625) //The text file specification '|' does not exist.  You can't import, export, or link using the specification.
#define E_DAO_TooManyIndexesM				DBDAOERR(3626) //The operation failed.  There are too many indexes on table '|'.  Delete some of the indexes on the table and try the operation again.
#define E_DAO_TransExeNotFound				DBDAOERR(3627) //Cannot find the executable file for the Synchronizer (mstran35.exe).
#define E_DAO_RemRepNotManaged				DBDAOERR(3628) //Partner replica is not managed by a Synchronizer.
#define E_DAO_FSDropboxShared				DBDAOERR(3629) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_FSDropboxSharedM				DBDAOERR(3630) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_RepInvalidTableInFilter		DBDAOERR(3631) //Invalid Table Name In Filter
#define E_DAO_InetNotEnabled				DBDAOERR(3632) //Internet Transport not enabled on the remote Synchronizer.
#define E_DAO_VtoDllLoadFailed				DBDAOERR(3633) //Can't load DLL:  '|'
#define E_DAO_REPDBIsPartial				DBDAOERR(3634) //Cannot create a replica using a partial replica.
#define E_DAO_CantCreatePartialSys			DBDAOERR(3635) //Cannot create partial replica of a system database.
#define E_DAO_CantPopulateWithErrors		DBDAOERR(3636) //Cannot populate the replica or change the replica's filter because the replica has conflicts or data errors.
#define E_DAO_QueryEmbeddedVarTab			DBDAOERR(3637) //Cannot use the crosstab of a non-fixed column as a subquery.
#define E_DAO_SrcCntrlDB					DBDAOERR(3638) //A Source Controlled database cannot be made replicable.
#define E_DAO_CantCreateSysReplica			DBDAOERR(3639) //Cannot create a replica of a System database.
#define E_DAO_VtoFetchBuffTooSmall			DBDAOERR(3640) //The fetch buffer was too small for the amount of data you requested.
#define E_DAO_VtoEOFDuringFetch				DBDAOERR(3641) //There are fewer records remaining in the recordset than you requested.
#define E_DAO_VtoSilentCancel				DBDAOERR(3642) //A cancel was performed on the operation.
#define E_DAO_VtoRecordDeleted				DBDAOERR(3643) //One of the records in the recordset was deleted by another process.
#define E_DAO_3644							DBDAOERR(3644) //*
#define E_DAO_VtoBadBindInfo				DBDAOERR(3645) //One of the binding parameters is incorrect.
#define E_DAO_VtoRowLenTooSmall				DBDAOERR(3646) //The specified row length is shorter than the sum of the column lengths.
#define E_DAO_VtoColumnMissing				DBDAOERR(3647) //A column requested is not being returned to the recordset.
#define E_DAO_BothPartials					DBDAOERR(3648) //Cannot synchronize a partial replica with another partial replica.
#define E_DAO_InvalidCodePage				DBDAOERR(3649) //The language-specific code page was not specified or could not be found.
#define E_DAO_InetTooSlow					DBDAOERR(3650) //Either the Internet is very slow OR there is some problem in the replication manager setup on the internet server machine.
#define E_DAO_InetInvalidAddress			DBDAOERR(3651) //Invalid internet address.
#define E_DAO_InetLoginFailure				DBDAOERR(3652) //Internet login failure.
#define E_DAO_InetNotSetup					DBDAOERR(3653) //Internet not set up.
#define E_DAO_InetInternalFailure			DBDAOERR(3654) //Internal internet failure.
#define E_DAO_InetServicesUnavailable		DBDAOERR(3655) //The wininet.dll can't be loaded or initialized.
#define E_DAO_PARTExprEvaluation			DBDAOERR(3656) //Error in evaluating a partial expression
#define E_DAO_PARTFilterEvalM				DBDAOERR(3657) //Error in evaluating the boolean filter expression for table '|1'.
#define E_DAO_PARTBinaryNotAllowedM			DBDAOERR(3658) //Binary column '|' cannot be used in a boolean filter.
#define E_DAO_PARTUnenforcedRelM			DBDAOERR(3659) //Relationship '|1' is unenforced. Relationship in a partial filter expression must be enforced.
#define E_DAO_ExchangeFailed				DBDAOERR(3660) //Requested exchange failed because '|1'
#define E_DAO_ExchangeFailedM				DBDAOERR(3661) //Requested exchange failed because '|1'
#define E_DAO_VtoRSNeedsBatchCursorLib		DBDAOERR(3662) //*
#define E_DAO_VtoNeedDiffCursorLibrary		DBDAOERR(3663) //This operation requires a different cursor library.
#define E_DAO_VtoStillConnecting			DBDAOERR(3664) //An asynchronous OpenConnection call is not yet complete, and you cannot yet reference the returned Connection object until it is complete.
#define E_DAO_AccessDeniedRepl				DBDAOERR(3665) //You cannot modify the replication system object '1'
#define E_DAO_AccessDeniedReplM				DBDAOERR(3666) //You cannot modify the replication system object '1'
#define E_DAO_VtoOtherOperBlocking			DBDAOERR(3667) //A different operation is preventing this operation from being executed.
#define E_DAO_VtoNoActiveConnection			DBDAOERR(3668) //Can not perform this operation because there is no active connection.
#define E_DAO_VtoExecCancelled				DBDAOERR(3669) //Execution cancelled.
#define E_DAO_VtoCursorNotValid				DBDAOERR(3670) //Cursor is not valid.
#define E_DAO_VtoCanNotFindTable			DBDAOERR(3671) //Can not find table to update.
#define E_DAO_VtoCanNotFindCursLib			DBDAOERR(3672) //Failed to load RDOCURS.DLL.

#endif // def _DBDAOERR.H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\customaw.h ===
#ifndef __CUSTOMAW_H__
#define __CUSTOMAW_H__

#include <afxdisp.h>
#include <ObjModel\appauto.h>
#include <ObjModel\bldauto.h>

/////////////////////////////////////////////////////////////////////////////
// customaw.h -- Header file to be included by all custom AppWizards.

// Link to the AppWizard import library
#pragma comment(lib, "mfcapwz.lib")

/////////////////////////////////////////////////////////////////////////////
// Class CAppWizStepDlg-- all custom AppWizard steps must derive from
//  this class

class CAppWizStepDlg : public CDialog
{
public:
	CAppWizStepDlg(UINT nIDTemplate);
	~CAppWizStepDlg();
	virtual BOOL OnDismiss();

	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to handle tabbing from
	//  the dialog controls in CAppWizStepDlg to the outer AppWizard dialog's
	//  controls.
    virtual BOOL PreTranslateMessage(MSG* pMsg);


	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to dynamically change
	//  the dialog template's font to match the rest of the IDE.
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	UINT m_nIDTemplate;
};


/////////////////////////////////////////////////////////////////////////////
// class OutputStream-- this abstract class is used to funnel output while
//  parsing templates.

class OutputStream
{
public:
    virtual void WriteLine(LPCTSTR lpsz) = 0;
    virtual void WriteBlock(LPCTSTR pBlock, DWORD dwSize) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Class CCustomAppWiz-- all custom AppWizards must have a class derived from
//  this.  MFCAPWZ.DLL talks to the custom AppWizard by calling these virtual
//  functions.

class CCustomAppWiz : public CObject
{
public:
	CMapStringToString m_Dictionary;

	virtual void GetPlatforms(CStringList& rPlatforms) {}

	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg) { return NULL; }
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg) { return NULL; }

	virtual void InitCustomAppWiz() { m_Dictionary.RemoveAll(); }
	virtual void ExitCustomAppWiz() {}

	virtual LPCTSTR LoadTemplate(LPCTSTR lpszTemplateName,
		DWORD& rdwSize, HINSTANCE hInstance = NULL);

	virtual void CopyTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void ProcessTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void PostProcessTemplate(LPCTSTR szTemplate) {}

	virtual void CustomizeProject(IBuildProject* pProject) {}
};


/////////////////////////////////////////////////////////////////////////////
// C API's exported by AppWizard.  The custom AppWizard talks to MFCAPWZ.DLL
//  by calling these functions.

// Values to be passed to GetDialog()
enum AppWizDlgID
{
	APWZDLG_APPTYPE = 1,
	APWZDLG_DATABASE,
	APWZDLG_OLE,
	APWZDLG_DOCAPPOPTIONS,
	APWZDLG_PROJOPTIONS,
	APWZDLG_CLASSES,
	APWZDLG_DLGAPPOPTIONS,
	APWZDLG_DLLPROJOPTIONS,
};

void SetCustomAppWizClass(CCustomAppWiz* pAW);
CAppWizStepDlg* GetDialog(AppWizDlgID nID);
void SetNumberOfSteps(int nSteps);
BOOL ScanForAvailableLanguages(CStringList& rLanguages);
void SetSupportedLanguages(LPCTSTR szSupportedLangs);


#endif //__CUSTOMAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\addauto.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// addauto.h

// This file declares the IDSAddIn interface.  Unlike the other
//  files in this directory, this file describes an interface that
//  is not implemented by Visual Studio.  This interface must be
//  implemented by a Developer Studio Add-in so that Visual
//  Studio can call into it.  The code to do this is automatically
//  generated by the Developer Studio Add-in Wizard.

#ifndef __ADDAUTO_H__
#define __ADDAUTO_H__

#include "appauto.h"

DECLARE_INTERFACE_(IDSAddIn, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IDSAddIn methods
	STDMETHOD(OnConnection)(THIS_ IApplication* pApp, VARIANT_BOOL bFirstTime, long dwCookie, VARIANT_BOOL* OnConnection) PURE;
	STDMETHOD(OnDisconnection)(THIS_ VARIANT_BOOL bLastTime) PURE;
};



#endif //__ADDAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\dbdaoint.h ===
/************************************************************************ 
**	D B D A O I N T. H													*
**																		*
************************************************************************* 
** Copyright (C) 1995-1997 by Microsoft Corporation						*
**		   All Rights Reserved					 						*
************************************************************************/ 
/*
 DBDAOINT.H
 OLE DAO Interface.  
This is a part of the Microsoft Data Access Objects SDK library.
See the dao*.hlp files for detailed information regarding the
Microsoft Data Access Objects SDK product.
 
*/
#ifndef _DBDAOINT_H_
#define _DBDAOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

// Forwards
interface _DAODBEngine;
#define DAODBEngine _DAODBEngine
interface DAOError;
interface _DAOCollection;
#define DAOCollection _DAOCollection
interface DAOErrors;
interface DAOProperty;
interface _DAODynaCollection;
#define DAODynaCollection _DAODynaCollection
interface DAOProperties;
interface DAOWorkspace;
interface DAOWorkspaces;
interface DAOConnection;
interface DAOConnections;
interface DAODatabase;
interface DAODatabases;
interface _DAOTableDef;
#define DAOTableDef _DAOTableDef
interface DAOTableDefs;
interface _DAOQueryDef;
#define DAOQueryDef _DAOQueryDef
interface DAOQueryDefs;
interface DAORecordset;
interface DAORecordsets;
interface _DAOField;
#define DAOField _DAOField
interface DAOFields;
interface _DAOIndex;
#define DAOIndex _DAOIndex
interface DAOIndexes;
interface DAOParameter;
interface DAOParameters;
interface _DAOUser;
#define DAOUser _DAOUser
interface DAOUsers;
interface _DAOGroup;
#define DAOGroup _DAOGroup
interface DAOGroups;
interface _DAORelation;
#define DAORelation _DAORelation
interface DAORelations;
interface DAOContainer;
interface DAOContainers;
interface DAODocument;
interface DAODocuments;
interface DAOIndexFields;



typedef enum RecordsetTypeEnum
    {	dbOpenTable	= 1,
	dbOpenDynaset	= 2,
	dbOpenSnapshot	= 4,
	dbOpenForwardOnly	= 8,
	dbOpenDynamic	= 16
    }	RecordsetTypeEnum;


typedef enum EditModeEnum
    {	dbEditNone	= 0,
	dbEditInProgress	= 1,
	dbEditAdd	= 2,
	dbEditChanged	= 4,
	dbEditDeleted	= 8,
	dbEditNew	= 16
    }	EditModeEnum;


typedef enum RecordsetOptionEnum
    {	dbDenyWrite	= 0x1,
	dbDenyRead	= 0x2,
	dbReadOnly	= 0x4,
	dbAppendOnly	= 0x8,
	dbInconsistent	= 0x10,
	dbConsistent	= 0x20,
	dbSQLPassThrough	= 0x40,
	dbFailOnError	= 0x80,
	dbForwardOnly	= 0x100,
	dbSeeChanges	= 0x200,
	dbRunAsync	= 0x400,
	dbExecDirect	= 0x800
    }	RecordsetOptionEnum;


typedef enum LockTypeEnum
    {	dbPessimistic	= 0x2,
	dbOptimistic	= 0x3,
	dbOptimisticValue	= 0x1,
	dbOptimisticBatch	= 0x5
    }	LockTypeEnum;


typedef enum UpdateCriteriaEnum
    {	dbCriteriaKey	= 0x1,
	dbCriteriaModValues	= 0x2,
	dbCriteriaAllCols	= 0x4,
	dbCriteriaTimestamp	= 0x8,
	dbCriteriaDeleteInsert	= 0x10,
	dbCriteriaUpdate	= 0x20
    }	UpdateCriteriaEnum;


typedef enum FieldAttributeEnum
    {	dbFixedField	= 0x1,
	dbVariableField	= 0x2,
	dbAutoIncrField	= 0x10,
	dbUpdatableField	= 0x20,
	dbSystemField	= 0x2000,
	dbHyperlinkField	= 0x8000,
	dbDescending	= 0x1
    }	FieldAttributeEnum;


typedef enum DataTypeEnum
    {	dbBoolean	= 1,
	dbByte	= 2,
	dbInteger	= 3,
	dbLong	= 4,
	dbCurrency	= 5,
	dbSingle	= 6,
	dbDouble	= 7,
	dbDate	= 8,
	dbBinary	= 9,
	dbText	= 10,
	dbLongBinary	= 11,
	dbMemo	= 12,
	dbGUID	= 15,
	dbBigInt	= 16,
	dbVarBinary	= 17,
	dbChar	= 18,
	dbNumeric	= 19,
	dbDecimal	= 20,
	dbFloat	= 21,
	dbTime	= 22,
	dbTimeStamp	= 23
    }	DataTypeEnum;


typedef enum RelationAttributeEnum
    {	dbRelationUnique	= 0x1,
	dbRelationDontEnforce	= 0x2,
	dbRelationInherited	= 0x4,
	dbRelationUpdateCascade	= 0x100,
	dbRelationDeleteCascade	= 0x1000,
	dbRelationLeft	= 0x1000000,
	dbRelationRight	= 0x2000000
    }	RelationAttributeEnum;


typedef enum TableDefAttributeEnum
    {	dbAttachExclusive	= 0x10000,
	dbAttachSavePWD	= 0x20000,
	dbSystemObject	= 0x80000002,
	dbAttachedTable	= 0x40000000,
	dbAttachedODBC	= 0x20000000,
	dbHiddenObject	= 0x1
    }	TableDefAttributeEnum;


typedef enum QueryDefTypeEnum
    {	dbQSelect	= 0,
	dbQProcedure	= 0xe0,
	dbQAction	= 0xf0,
	dbQCrosstab	= 0x10,
	dbQDelete	= 0x20,
	dbQUpdate	= 0x30,
	dbQAppend	= 0x40,
	dbQMakeTable	= 0x50,
	dbQDDL	= 0x60,
	dbQSQLPassThrough	= 0x70,
	dbQSetOperation	= 0x80,
	dbQSPTBulk	= 0x90,
	dbQCompound	= 0xa0
    }	QueryDefTypeEnum;


typedef enum QueryDefStateEnum
    {	dbQPrepare	= 1,
	dbQUnprepare	= 2
    }	QueryDefStateEnum;


typedef enum DatabaseTypeEnum
    {	dbVersion10	= 1,
	dbEncrypt	= 2,
	dbDecrypt	= 4,
	dbVersion11	= 8,
	dbVersion20	= 16,
	dbVersion30	= 32,
	dbVersion40	= 64
    }	DatabaseTypeEnum;


typedef enum CollatingOrderEnum
    {	dbSortNeutral	= 0x400,
	dbSortArabic	= 0x401,
	dbSortCyrillic	= 0x419,
	dbSortCzech	= 0x405,
	dbSortDutch	= 0x413,
	dbSortGeneral	= 0x409,
	dbSortGreek	= 0x408,
	dbSortHebrew	= 0x40d,
	dbSortHungarian	= 0x40e,
	dbSortIcelandic	= 0x40f,
	dbSortNorwdan	= 0x406,
	dbSortPDXIntl	= 0x409,
	dbSortPDXNor	= 0x406,
	dbSortPDXSwe	= 0x41d,
	dbSortPolish	= 0x415,
	dbSortSpanish	= 0x40a,
	dbSortSwedFin	= 0x41d,
	dbSortTurkish	= 0x41f,
	dbSortJapanese	= 0x411,
	dbSortChineseSimplified	= 0x804,
	dbSortChineseTraditional	= 0x404,
	dbSortKorean	= 0x412,
	dbSortThai	= 0x41e,
	dbSortSlovenian	= 0x424,
	dbSortUndefined	= -1
    }	CollatingOrderEnum;


typedef enum IdleEnum
    {	dbFreeLocks	= 1,
	dbRefreshCache	= 8
    }	IdleEnum;


typedef enum PermissionEnum
    {	dbSecNoAccess	= 0,
	dbSecFullAccess	= 0xfffff,
	dbSecDelete	= 0x10000,
	dbSecReadSec	= 0x20000,
	dbSecWriteSec	= 0x40000,
	dbSecWriteOwner	= 0x80000,
	dbSecDBCreate	= 0x1,
	dbSecDBOpen	= 0x2,
	dbSecDBExclusive	= 0x4,
	dbSecDBAdmin	= 0x8,
	dbSecCreate	= 0x1,
	dbSecReadDef	= 0x4,
	dbSecWriteDef	= 0x1000c,
	dbSecRetrieveData	= 0x14,
	dbSecInsertData	= 0x20,
	dbSecReplaceData	= 0x40,
	dbSecDeleteData	= 0x80
    }	PermissionEnum;


typedef enum SynchronizeTypeEnum
    {	dbRepExportChanges	= 0x1,
	dbRepImportChanges	= 0x2,
	dbRepImpExpChanges	= 0x4,
	dbRepSyncInternet	= 0x10
    }	SynchronizeTypeEnum;


typedef enum ReplicaTypeEnum
    {	dbRepMakeReadOnly	= 0x2,
	dbRepMakePartial	= 0x1
    }	ReplicaTypeEnum;


typedef enum WorkspaceTypeEnum
    {	dbUseODBC	= 1,
	dbUseJet	= 2
    }	WorkspaceTypeEnum;


typedef enum CursorDriverEnum
    {	dbUseDefaultCursor	= -1,
	dbUseODBCCursor	= 1,
	dbUseServerCursor	= 2,
	dbUseClientBatchCursor	= 3,
	dbUseNoCursor	= 4
    }	CursorDriverEnum;


typedef enum DriverPromptEnum
    {	dbDriverPrompt	= 2,
	dbDriverNoPrompt	= 1,
	dbDriverComplete	= 0,
	dbDriverCompleteRequired	= 3
    }	DriverPromptEnum;


typedef enum SetOptionEnum
    {	dbPageTimeout	= 6,
	dbLockRetry	= 57,
	dbMaxBufferSize	= 8,
	dbUserCommitSync	= 58,
	dbImplicitCommitSync	= 59,
	dbExclusiveAsyncDelay	= 60,
	dbSharedAsyncDelay	= 61,
	dbMaxLocksPerFile	= 62,
	dbLockDelay	= 63,
	dbRecycleLVs	= 65,
	dbFlushTransactionTimeout	= 66
    }	SetOptionEnum;


typedef enum ParameterDirectionEnum
    {	dbParamInput	= 1,
	dbParamOutput	= 2,
	dbParamInputOutput	= 3,
	dbParamReturnValue	= 4
    }	ParameterDirectionEnum;


typedef enum UpdateTypeEnum
    {	dbUpdateBatch	= 4,
	dbUpdateRegular	= 1,
	dbUpdateCurrentRecord	= 2
    }	UpdateTypeEnum;


typedef enum RecordStatusEnum
    {	dbRecordUnmodified	= 0,
	dbRecordModified	= 1,
	dbRecordNew	= 2,
	dbRecordDeleted	= 3,
	dbRecordDBDeleted	= 4
    }	RecordStatusEnum;


typedef enum CommitTransOptionsEnum
    {	dbForceOSFlush	= 1
    }	CommitTransOptionsEnum;


typedef enum _DAOSuppHelp
    {	LogMessages	= 0,
	KeepLocal	= 0,
	Replicable	= 0,
	ReplicableBool	= 0,
	V1xNullBehavior	= 0
    }	_DAOSuppHelp;

#define dbLangArabic _T(";LANGID=0x0401;CP=1256;COUNTRY=0")
#define dbLangCzech _T(";LANGID=0x0405;CP=1250;COUNTRY=0")
#define dbLangDutch _T(";LANGID=0x0413;CP=1252;COUNTRY=0")
#define dbLangGeneral _T(";LANGID=0x0409;CP=1252;COUNTRY=0")
#define dbLangGreek _T(";LANGID=0x0408;CP=1253;COUNTRY=0")
#define dbLangHebrew _T(";LANGID=0x040D;CP=1255;COUNTRY=0")
#define dbLangHungarian _T(";LANGID=0x040E;CP=1250;COUNTRY=0")
#define dbLangIcelandic _T(";LANGID=0x040F;CP=1252;COUNTRY=0")
#define dbLangNordic _T(";LANGID=0x041D;CP=1252;COUNTRY=0")
#define dbLangNorwDan _T(";LANGID=0x0414;CP=1252;COUNTRY=0")
#define dbLangPolish _T(";LANGID=0x0415;CP=1250;COUNTRY=0")
#define dbLangCyrillic _T(";LANGID=0x0419;CP=1251;COUNTRY=0")
#define dbLangSpanish _T(";LANGID=0x040A;CP=1252;COUNTRY=0")
#define dbLangSwedFin _T(";LANGID=0x040B;CP=1252;COUNTRY=0")
#define dbLangTurkish _T(";LANGID=0x041F;CP=1254;COUNTRY=0")
#define dbLangJapanese _T(";LANGID=0x0411;CP=932;COUNTRY=0")
#define dbLangChineseSimplified _T(";LANGID=0x0804;CP=936;COUNTRY=0")
#define dbLangChineseTraditional _T(";LANGID=0x0404;CP=950;COUNTRY=0")
#define dbLangKorean _T(";LANGID=0x0412;CP=949;COUNTRY=0")
#define dbLangThai _T(";LANGID=0x041E;CP=874;COUNTRY=0")
#define dbLangSlovenian _T(";LANGID=0x0424;CP=1250;COUNTRY=0")
// Interface: _DAOCollection
#undef INTERFACE
#define INTERFACE _DAOCollection
DECLARE_INTERFACE_(_DAOCollection, IDispatch)
	{
	STDMETHOD(get_Count)						 (THIS_ short FAR* c) PURE;
	STDMETHOD(_NewEnum)							 (THIS_ IUnknown * FAR* ppunk) PURE;
	STDMETHOD(Refresh)							 (THIS) PURE;
	};
 
// Interface: _DAODynaCollection
#undef INTERFACE
#define INTERFACE _DAODynaCollection
DECLARE_INTERFACE_(_DAODynaCollection, _DAOCollection)
	{
	STDMETHOD(Append)							 (THIS_ IDispatch * Object) PURE;
	STDMETHOD(Delete)							 (THIS_ BSTR Name) PURE;
	};
 
// Interface: _DAO
#undef INTERFACE
#define INTERFACE _DAO
DECLARE_INTERFACE_(_DAO, IDispatch)
	{
	STDMETHOD(get_Properties)					 (THIS_ DAOProperties FAR* FAR* ppprops) PURE;
	};
// Interface: _DAODBEngine
#undef INTERFACE
#define INTERFACE _DAODBEngine
DECLARE_INTERFACE_(_DAODBEngine, _DAO)
{
	STDMETHOD( get_Properties )						(
			/* [retval][out] */ DAOProperties __RPC_FAR *__RPC_FAR *ppprops );
	STDMETHOD( get_Version )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_IniPath )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_IniPath )					 ( 
    
 /* [in] */ BSTR path ) PURE;
	STDMETHOD( put_DefaultUser )				 ( 
    
 /* [in] */ BSTR user ) PURE;
	STDMETHOD( put_DefaultPassword )			 ( 
    
 /* [in] */ BSTR pw ) PURE;
	STDMETHOD( get_LoginTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_LoginTimeout )				 ( 
    
 /* [in] */ short Timeout ) PURE;
	STDMETHOD( get_Workspaces )					 ( 
    
 /* [retval][out] */ DAOWorkspaces __RPC_FAR *__RPC_FAR *ppworks ) PURE;
	STDMETHOD( get_Errors )						 ( 
    
 /* [retval][out] */ DAOErrors __RPC_FAR *__RPC_FAR *pperrs ) PURE;
	STDMETHOD( Idle )							 ( 
    
 /* [optional][in] */ VARIANT Action ) PURE;
	STDMETHOD( CompactDatabase )				 ( 
    
 /* [in] */ BSTR SrcName,
 /* [in] */ BSTR DstName,
 /* [optional][in] */ VARIANT DstLocale,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT SrcLocale ) PURE;
	STDMETHOD( RepairDatabase )					 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( RegisterDatabase )				 ( 
    
 /* [in] */ BSTR Dsn,
 /* [in] */ BSTR Driver,
 /* [in] */ VARIANT_BOOL Silent,
 /* [in] */ BSTR Attributes ) PURE;
	STDMETHOD( _30_CreateWorkspace )			 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR UserName,
 /* [in] */ BSTR Password,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	STDMETHOD( OpenDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Locale,
 /* [optional][in] */ VARIANT Option,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( FreeLocks )						 ( 
   			VOID ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Option ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( SetDefaultWorkspace )			 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Password ) PURE;
	STDMETHOD( SetDataAccessOption )			 ( 
    
 /* [in] */ short Option,
 /* [in] */ VARIANT Value ) PURE;
	STDMETHOD( ISAMStats )						 ( 
    
 /* [in] */ long StatNum,
 /* [optional][in] */ VARIANT Reset,
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_SystemDB )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SystemDB )					 ( 
    
 /* [in] */ BSTR SystemDBPath ) PURE;
	STDMETHOD( CreateWorkspace )				 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR UserName,
 /* [in] */ BSTR Password,
 /* [optional][in] */ VARIANT UseType,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	STDMETHOD( OpenConnection )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	STDMETHOD( get_DefaultType )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *Option ) PURE;
	STDMETHOD( put_DefaultType )				 ( 
    
 /* [in] */ long Option ) PURE;
	STDMETHOD( SetOption )						 ( 
    
 /* [in] */ LONG Option,
 /* [in] */ VARIANT Value ) PURE;
	STDMETHOD( DumpObjects )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( DebugPrint )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	};// end interface;

// Interface: DAOError
#undef INTERFACE
#define INTERFACE DAOError
DECLARE_INTERFACE_(DAOError, IDispatch)
{
	STDMETHOD( get_Number )						 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Source )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Description )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_HelpFile )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_HelpContext )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOErrors
#undef INTERFACE
#define INTERFACE DAOErrors
DECLARE_INTERFACE_(DAOErrors, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOError __RPC_FAR *__RPC_FAR *pperr ) PURE;
	};// end interface;

// Interface: DAOProperty
#undef INTERFACE
#define INTERFACE DAOProperty
DECLARE_INTERFACE_(DAOProperty, _DAO)
{
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pval ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT val ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ptype ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short type ) PURE;
	STDMETHOD( get_Inherited )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	};// end interface;

// Interface: DAOProperties
#undef INTERFACE
#define INTERFACE DAOProperties
DECLARE_INTERFACE_(DAOProperties, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *ppprop ) PURE;
	};// end interface;

// Interface: DAOWorkspace
#undef INTERFACE
#define INTERFACE DAOWorkspace
DECLARE_INTERFACE_(DAOWorkspace, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put__30_UserName )				 ( 
    
 /* [in] */ BSTR UserName ) PURE;
	STDMETHOD( put__30_Password )				 ( 
    
 /* [in] */ BSTR Password ) PURE;
	STDMETHOD( get_IsolateODBCTrans )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_IsolateODBCTrans )			 ( 
    
 /* [in] */ short s ) PURE;
	STDMETHOD( get_Databases )					 ( 
    
 /* [retval][out] */ DAODatabases __RPC_FAR *__RPC_FAR *ppdbs ) PURE;
	STDMETHOD( get_Users )						 ( 
    
 /* [retval][out] */ DAOUsers __RPC_FAR *__RPC_FAR *ppusrs ) PURE;
	STDMETHOD( get_Groups )						 ( 
    
 /* [retval][out] */ DAOGroups __RPC_FAR *__RPC_FAR *ppgrps ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( OpenDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateDatabase )					 ( 
    
 /* [in] */ BSTR Name,
 /* [in] */ BSTR Connect,
 /* [optional][in] */ VARIANT Option,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	STDMETHOD( CreateUser )						 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [optional][in] */ VARIANT Password,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	STDMETHOD( CreateGroup )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	STDMETHOD( OpenConnection )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT ReadOnly,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	STDMETHOD( get_LoginTimeout )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pTimeout ) PURE;
	STDMETHOD( put_LoginTimeout )				 ( 
    
 /* [in] */ long Timeout ) PURE;
	STDMETHOD( get_DefaultCursorDriver )		 ( 
    
 /* [retval][out] */ long __RPC_FAR *pCursorType ) PURE;
	STDMETHOD( put_DefaultCursorDriver )		 ( 
    
 /* [in] */ long CursorType ) PURE;
	STDMETHOD( get_hEnv )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phEnv ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *ptype ) PURE;
	STDMETHOD( get_Connections )				 ( 
    
 /* [retval][out] */ DAOConnections __RPC_FAR *__RPC_FAR *ppcns ) PURE;
	};// end interface;

// Interface: DAOWorkspaces
#undef INTERFACE
#define INTERFACE DAOWorkspaces
DECLARE_INTERFACE_(DAOWorkspaces, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOWorkspace __RPC_FAR *__RPC_FAR *ppwrk ) PURE;
	};// end interface;

// Interface: DAOConnection
#undef INTERFACE
#define INTERFACE DAOConnection
DECLARE_INTERFACE_(DAOConnection, IDispatch)
{
	STDMETHOD( QueryInterface )					 ( REFIID riid, LPVOID FAR* ppvObj );
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Database )					 ( 
    
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppDb ) PURE;
	STDMETHOD( get_hDbc )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phDbc ) PURE;
	STDMETHOD( get_QueryTimeout )				 ( 
    
 /* [retval][out] */ SHORT __RPC_FAR *pSeconds ) PURE;
	STDMETHOD( put_QueryTimeout )				 ( 
    
 /* [in] */ SHORT Seconds ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pRecords ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_QueryDefs )					 ( 
    
 /* [retval][out] */ DAOQueryDefs __RPC_FAR *__RPC_FAR *ppqdfs ) PURE;
	STDMETHOD( get_Recordsets )					 ( 
    
 /* [retval][out] */ DAORecordsets __RPC_FAR *__RPC_FAR *pprsts ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( CreateQueryDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT SQLText,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [in] */ BSTR Query,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	};// end interface;

// Interface: DAOConnections
#undef INTERFACE
#define INTERFACE DAOConnections
DECLARE_INTERFACE_(DAOConnections, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppconn ) PURE;
	};// end interface;

// Interface: DAODatabase
#undef INTERFACE
#define INTERFACE DAODatabase
DECLARE_INTERFACE_(DAODatabase, _DAO)
{
	STDMETHOD( get_CollatingOrder )				 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_QueryTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_QueryTimeout )				 ( 
    
 /* [in] */ short Timeout ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Version )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_TableDefs )					 ( 
    
 /* [retval][out] */ DAOTableDefs __RPC_FAR *__RPC_FAR *pptdfs ) PURE;
	STDMETHOD( get_QueryDefs )					 ( 
    
 /* [retval][out] */ DAOQueryDefs __RPC_FAR *__RPC_FAR *ppqdfs ) PURE;
	STDMETHOD( get_Relations )					 ( 
    
 /* [retval][out] */ DAORelations __RPC_FAR *__RPC_FAR *pprls ) PURE;
	STDMETHOD( get_Containers )					 ( 
    
 /* [retval][out] */ DAOContainers __RPC_FAR *__RPC_FAR *ppctns ) PURE;
	STDMETHOD( get_Recordsets )					 ( 
    
 /* [retval][out] */ DAORecordsets __RPC_FAR *__RPC_FAR *pprsts ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [in] */ BSTR Query,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( _30_OpenRecordset )				 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( CreateRelation )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Table,
 /* [optional][in] */ VARIANT ForeignTable,
 /* [optional][in] */ VARIANT Attributes,
 /* [retval][out] */ DAORelation __RPC_FAR *__RPC_FAR *pprel ) PURE;
	STDMETHOD( CreateTableDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Attributes,
 /* [optional][in] */ VARIANT SourceTablename,
 /* [optional][in] */ VARIANT Connect,
 /* [retval][out] */ DAOTableDef __RPC_FAR *__RPC_FAR *pptdf ) PURE;
	STDMETHOD( BeginTrans )						 ( 
   			VOID ) PURE;
	STDMETHOD( CommitTrans )					 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	STDMETHOD( Rollback )						 ( 
   			VOID ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateQueryDef )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT SQLText,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [in] */ BSTR Source,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( DeleteQueryDef )					 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( ExecuteSQL )						 ( 
    
 /* [in] */ BSTR SQL,
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( ListFields )						 ( 
    
 /* [in] */ BSTR Name,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListTables )						 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( OpenQueryDef )					 ( 
    
 /* [in] */ BSTR Name,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( OpenTable )						 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( get_ReplicaID )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_DesignMasterID )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_DesignMasterID )				 ( 
    
 /* [in] */ BSTR MasterID ) PURE;
	STDMETHOD( Synchronize )					 ( 
    
 /* [in] */ BSTR DbPathName,
 /* [optional][in] */ VARIANT ExchangeType ) PURE;
	STDMETHOD( MakeReplica )					 ( 
    
 /* [in] */ BSTR PathName,
 /* [in] */ BSTR Description,
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR ODBCConnnect ) PURE;
	STDMETHOD( NewPassword )					 ( 
    
 /* [in] */ BSTR bstrOld,
 /* [in] */ BSTR bstrNew ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [in] */ BSTR Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( get_Connection )					 ( 
    
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppCn ) PURE;
	STDMETHOD( PopulatePartial )				 ( 
    
 /* [in] */ BSTR DbPathName ) PURE;
	};// end interface;

// Interface: DAODatabases
#undef INTERFACE
#define INTERFACE DAODatabases
DECLARE_INTERFACE_(DAODatabases, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *ppdb ) PURE;
	};// end interface;

// Interface: _DAOTableDef
#undef INTERFACE
#define INTERFACE _DAOTableDef
DECLARE_INTERFACE_(_DAOTableDef, _DAO)
{
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long Attributes ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR Connection ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_SourceTableName )			 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SourceTableName )			 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationText )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationRule )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_RecordCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Indexes )					 ( 
    
 /* [retval][out] */ DAOIndexes __RPC_FAR *__RPC_FAR *ppidxs ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( RefreshLink )					 ( 
   			VOID ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( CreateIndex )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [retval][out] */ DAOIndex __RPC_FAR *__RPC_FAR *ppidx ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( get_ConflictTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_ReplicaFilter )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pFilter ) PURE;
	STDMETHOD( put_ReplicaFilter )				 ( 
    
 /* [in] */ VARIANT Filter ) PURE;
	};// end interface;

// Interface: DAOTableDefs
#undef INTERFACE
#define INTERFACE DAOTableDefs
DECLARE_INTERFACE_(DAOTableDefs, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOTableDef __RPC_FAR *__RPC_FAR *pptdf ) PURE;
	};// end interface;

// Interface: _DAOQueryDef
#undef INTERFACE
#define INTERFACE _DAOQueryDef
DECLARE_INTERFACE_(_DAOQueryDef, _DAO)
{
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ODBCTimeout )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_ODBCTimeout )				 ( 
    
 /* [in] */ short timeout ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_SQL )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_SQL )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Connect )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Connect )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ReturnsRecords )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_ReturnsRecords )				 ( 
    
 /* [in] */ VARIANT_BOOL f ) PURE;
	STDMETHOD( get_RecordsAffected )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Parameters )					 ( 
    
 /* [retval][out] */ DAOParameters __RPC_FAR *__RPC_FAR *ppprms ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( _30_OpenRecordset )				 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _30__OpenRecordset )				 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _Copy )							 ( 
    
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( Execute )						 ( 
    
 /* [optional][in] */ VARIANT Options ) PURE;
	STDMETHOD( Compare )						 ( 
    
 /* [in] */ DAOQueryDef __RPC_FAR *pQdef,
 /* [in] */ SHORT __RPC_FAR *lps ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListParameters )					 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( _OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT LockEdit,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( get_hStmt )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phStmt ) PURE;
	STDMETHOD( get_MaxRecords )					 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *pMxRecs ) PURE;
	STDMETHOD( put_MaxRecords )					 ( 
    
 /* [in] */ LONG MxRecs ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_CacheSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *lCacheSize ) PURE;
	STDMETHOD( put_CacheSize )					 ( 
    
 /* [in] */ long lCacheSize ) PURE;
	STDMETHOD( get_Prepare )					 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Prepare )					 ( 
    
 /* [in] */ VARIANT f ) PURE;
	};// end interface;

// Interface: DAOQueryDefs
#undef INTERFACE
#define INTERFACE DAOQueryDefs
DECLARE_INTERFACE_(DAOQueryDefs, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdef ) PURE;
	};// end interface;

// Interface: DAORecordset
#undef INTERFACE
#define INTERFACE DAORecordset
DECLARE_INTERFACE_(DAORecordset, _DAO)
{
	STDMETHOD( GetIDsOfNames )					 (      REFIID riid,      OLECHAR FAR* FAR* rgszNames,      UINT cNames,      LCID lcid,      DISPID FAR* rgdispid );
	STDMETHOD( Invoke )							 (      DISPID dispidMember,      REFIID riid,      LCID lcid,      WORD wFlags,      DISPPARAMS FAR* pdispparams,      VARIANT FAR* pvarResult,      EXCEPINFO FAR* pexcepinfo,      UINT FAR* puArgErr );
	STDMETHOD( get_BOF )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Bookmark )					 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsach ) PURE;
	STDMETHOD( put_Bookmark )					 ( 
    
 /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psach ) PURE;
	STDMETHOD( get_Bookmarkable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_EOF )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Filter )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Filter )						 ( 
    
 /* [in] */ BSTR Filter ) PURE;
	STDMETHOD( get_Index )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Index )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_LastModified )				 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LockEdits )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_LockEdits )					 ( 
    
 /* [in] */ VARIANT_BOOL Lock ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_NoMatch )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Sort )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Sort )						 ( 
    
 /* [in] */ BSTR Sort ) PURE;
	STDMETHOD( get_Transactions )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( get_RecordCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Updatable )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Restartable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_CacheStart )					 ( 
    
 /* [retval][out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa ) PURE;
	STDMETHOD( put_CacheStart )					 ( 
    
 /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psa ) PURE;
	STDMETHOD( get_CacheSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_CacheSize )					 ( 
    
 /* [in] */ long CacheSize ) PURE;
	STDMETHOD( get_PercentPosition )			 ( 
    
 /* [retval][out] */ float __RPC_FAR *pd ) PURE;
	STDMETHOD( put_PercentPosition )			 ( 
    
 /* [in] */ float Position ) PURE;
	STDMETHOD( get_AbsolutePosition )			 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_AbsolutePosition )			 ( 
    
 /* [in] */ long Position ) PURE;
	STDMETHOD( get_EditMode )					 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_ODBCFetchCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_ODBCFetchDelay )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Parent )						 ( 
    
 /* [retval][out] */ DAODatabase __RPC_FAR *__RPC_FAR *pdb ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( get_Indexes )					 ( 
    
 /* [retval][out] */ DAOIndexes __RPC_FAR *__RPC_FAR *ppidxs ) PURE;
	STDMETHOD( _30_CancelUpdate )				 ( 
   			VOID ) PURE;
	STDMETHOD( AddNew )							 ( 
   			VOID ) PURE;
	STDMETHOD( Close )							 ( 
   			VOID ) PURE;
	STDMETHOD( OpenRecordset )					 ( 
    
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Delete )							 ( 
   			VOID ) PURE;
	STDMETHOD( Edit )							 ( 
   			VOID ) PURE;
	STDMETHOD( FindFirst )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindLast )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindNext )						 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( FindPrevious )					 ( 
    
 /* [in] */ BSTR Criteria ) PURE;
	STDMETHOD( MoveFirst )						 ( 
   			VOID ) PURE;
	STDMETHOD( _30_MoveLast )					 ( 
   			VOID ) PURE;
	STDMETHOD( MoveNext )						 ( 
   			VOID ) PURE;
	STDMETHOD( MovePrevious )					 ( 
   			VOID ) PURE;
	STDMETHOD( Seek )							 ( 
    
 /* [in] */ BSTR Comparison,
 /* [in] */ VARIANT Key1,
 /* [optional][in] */ VARIANT Key2,
 /* [optional][in] */ VARIANT Key3,
 /* [optional][in] */ VARIANT Key4,
 /* [optional][in] */ VARIANT Key5,
 /* [optional][in] */ VARIANT Key6,
 /* [optional][in] */ VARIANT Key7,
 /* [optional][in] */ VARIANT Key8,
 /* [optional][in] */ VARIANT Key9,
 /* [optional][in] */ VARIANT Key10,
 /* [optional][in] */ VARIANT Key11,
 /* [optional][in] */ VARIANT Key12,
 /* [optional][in] */ VARIANT Key13 ) PURE;
	STDMETHOD( _30_Update )						 ( 
   			VOID ) PURE;
	STDMETHOD( Clone )							 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( Requery )						 ( 
    
 /* [optional][in] */ VARIANT NewQueryDef ) PURE;
	STDMETHOD( Move )							 ( 
    
 /* [in] */ long Rows,
 /* [optional][in] */ VARIANT StartBookmark ) PURE;
	STDMETHOD( FillCache )						 ( 
    
 /* [optional][in] */ VARIANT Rows,
 /* [optional][in] */ VARIANT StartBookmark ) PURE;
	STDMETHOD( CreateDynaset )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [optional][in] */ VARIANT Inconsistent,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CreateSnapshot )					 ( 
    
 /* [optional][in] */ VARIANT Options,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( CopyQueryDef )					 ( 
    
 /* [retval][out] */ DAOQueryDef __RPC_FAR *__RPC_FAR *ppqdf ) PURE;
	STDMETHOD( ListFields )						 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( ListIndexes )					 ( 
    
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	STDMETHOD( GetRows )						 ( 
    
 /* [optional][in] */ VARIANT NumRows,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Collect )					 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Collect )					 ( 
    
 /* [in] */ VARIANT Item,
 /* [in] */ VARIANT value ) PURE;
	STDMETHOD( Cancel )							 ( 
   			VOID ) PURE;
	STDMETHOD( NextRecordset )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_hStmt )						 ( 
    
 /* [retval][out] */ LONG __RPC_FAR *phStmt ) PURE;
	STDMETHOD( get_StillExecuting )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStillExec ) PURE;
	STDMETHOD( get_BatchSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_BatchSize )					 ( 
    
 /* [in] */ long BatchSize ) PURE;
	STDMETHOD( get_BatchCollisionCount )		 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_BatchCollisions )			 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_Connection )					 ( 
    
 /* [retval][out] */ DAOConnection __RPC_FAR *__RPC_FAR *ppCn ) PURE;
	STDMETHOD( putref_Connection )				 ( 
    
 /* [in] */ DAOConnection __RPC_FAR *pNewCn ) PURE;
	STDMETHOD( get_RecordStatus )				 ( 
    
 /* [retval][out] */ short __RPC_FAR *pi ) PURE;
	STDMETHOD( get_UpdateOptions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_UpdateOptions )				 ( 
    
 /* [in] */ long l ) PURE;
	STDMETHOD( CancelUpdate )					 ( 
    
 /* [defaultvalue][in] */ long UpdateType ) PURE;
	STDMETHOD( Update )							 ( 
    
 /* [defaultvalue][in] */ long UpdateType,
 /* [defaultvalue][in] */ VARIANT_BOOL Force ) PURE;
	STDMETHOD( MoveLast )						 ( 
    
 /* [defaultvalue][in] */ long Options ) PURE;
	};// end interface;

// Interface: DAORecordsets
#undef INTERFACE
#define INTERFACE DAORecordsets
DECLARE_INTERFACE_(DAORecordsets, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAORecordset __RPC_FAR *__RPC_FAR *pprst ) PURE;
	};// end interface;

// Interface: _DAOField
#undef INTERFACE
#define INTERFACE _DAOField
DECLARE_INTERFACE_(_DAOField, _DAO)
{
	STDMETHOD( get_CollatingOrder )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short Type ) PURE;
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR Name ) PURE;
	STDMETHOD( get_Size )						 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Size )						 ( 
    
 /* [in] */ long Size ) PURE;
	STDMETHOD( get_SourceField )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_SourceTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT Val ) PURE;
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long Attr ) PURE;
	STDMETHOD( get_OrdinalPosition )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_OrdinalPosition )			 ( 
    
 /* [in] */ short Pos ) PURE;
	STDMETHOD( get_ValidationText )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationText )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ValidateOnSet )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_ValidateOnSet )				 ( 
    
 /* [in] */ VARIANT_BOOL Validate ) PURE;
	STDMETHOD( get_ValidationRule )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ValidationRule )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_DefaultValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_DefaultValue )				 ( 
    
 /* [in] */ VARIANT var ) PURE;
	STDMETHOD( get_Required )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Required )					 ( 
    
 /* [in] */ VARIANT_BOOL fReq ) PURE;
	STDMETHOD( get_AllowZeroLength )			 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_AllowZeroLength )			 ( 
    
 /* [in] */ VARIANT_BOOL fAllow ) PURE;
	STDMETHOD( get_DataUpdatable )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_ForeignName )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ForeignName )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( AppendChunk )					 ( 
    
 /* [in] */ VARIANT Val ) PURE;
	STDMETHOD( GetChunk )						 ( 
    
 /* [in] */ long Offset,
 /* [in] */ long Bytes,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( _30_FieldSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	STDMETHOD( get_CollectionIndex )			 ( 
    
 /* [retval][out] */ short __RPC_FAR *i ) PURE;
	STDMETHOD( get_OriginalValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_VisibleValue )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_FieldSize )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOFields
#undef INTERFACE
#define INTERFACE DAOFields
DECLARE_INTERFACE_(DAOFields, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	};// end interface;

// Interface: _DAOIndex
#undef INTERFACE
#define INTERFACE _DAOIndex
DECLARE_INTERFACE_(_DAOIndex, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Foreign )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( get_Unique )						 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Unique )						 ( 
    
 /* [in] */ VARIANT_BOOL fUnique ) PURE;
	STDMETHOD( get_Clustered )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Clustered )					 ( 
    
 /* [in] */ VARIANT_BOOL fClustered ) PURE;
	STDMETHOD( get_Required )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Required )					 ( 
    
 /* [in] */ VARIANT_BOOL fRequired ) PURE;
	STDMETHOD( get_IgnoreNulls )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_IgnoreNulls )				 ( 
    
 /* [in] */ VARIANT_BOOL fIgnoreNulls ) PURE;
	STDMETHOD( get_Primary )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Primary )					 ( 
    
 /* [in] */ VARIANT_BOOL fPrimary ) PURE;
	STDMETHOD( get_DistinctCount )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pv ) PURE;
	STDMETHOD( put_Fields )						 ( 
    
 /* [in] */ VARIANT v ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	};// end interface;

// Interface: DAOIndexes
#undef INTERFACE
#define INTERFACE DAOIndexes
DECLARE_INTERFACE_(DAOIndexes, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOIndex __RPC_FAR *__RPC_FAR *ppidx ) PURE;
	};// end interface;

// Interface: DAOParameter
#undef INTERFACE
#define INTERFACE DAOParameter
DECLARE_INTERFACE_(DAOParameter, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Value )						 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( put_Value )						 ( 
    
 /* [in] */ VARIANT val ) PURE;
	STDMETHOD( get_Type )						 ( 
    
 /* [retval][out] */ short __RPC_FAR *ps ) PURE;
	STDMETHOD( put_Type )						 ( 
    
 /* [in] */ short s ) PURE;
	STDMETHOD( get_Direction )					 ( 
    
 /* [retval][out] */ short __RPC_FAR *pOption ) PURE;
	STDMETHOD( put_Direction )					 ( 
    
 /* [in] */ short Option ) PURE;
	};// end interface;

// Interface: DAOParameters
#undef INTERFACE
#define INTERFACE DAOParameters
DECLARE_INTERFACE_(DAOParameters, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOParameter __RPC_FAR *__RPC_FAR *ppprm ) PURE;
	};// end interface;

// Interface: _DAOUser
#undef INTERFACE
#define INTERFACE _DAOUser
DECLARE_INTERFACE_(_DAOUser, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_PID )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_Password )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Groups )						 ( 
    
 /* [retval][out] */ DAOGroups __RPC_FAR *__RPC_FAR *ppgrps ) PURE;
	STDMETHOD( NewPassword )					 ( 
    
 /* [in] */ BSTR bstrOld,
 /* [in] */ BSTR bstrNew ) PURE;
	STDMETHOD( CreateGroup )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	};// end interface;

// Interface: DAOUsers
#undef INTERFACE
#define INTERFACE DAOUsers
DECLARE_INTERFACE_(DAOUsers, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	};// end interface;

// Interface: _DAOGroup
#undef INTERFACE
#define INTERFACE _DAOGroup
DECLARE_INTERFACE_(_DAOGroup, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( put_PID )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Users )						 ( 
    
 /* [retval][out] */ DAOUsers __RPC_FAR *__RPC_FAR *ppusrs ) PURE;
	STDMETHOD( CreateUser )						 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT PID,
 /* [optional][in] */ VARIANT Password,
 /* [retval][out] */ DAOUser __RPC_FAR *__RPC_FAR *ppusr ) PURE;
	};// end interface;

// Interface: DAOGroups
#undef INTERFACE
#define INTERFACE DAOGroups
DECLARE_INTERFACE_(DAOGroups, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOGroup __RPC_FAR *__RPC_FAR *ppgrp ) PURE;
	};// end interface;

// Interface: _DAORelation
#undef INTERFACE
#define INTERFACE _DAORelation
DECLARE_INTERFACE_(_DAORelation, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Name )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Table )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Table )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_ForeignTable )				 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_ForeignTable )				 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Attributes )					 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Attributes )					 ( 
    
 /* [in] */ long attr ) PURE;
	STDMETHOD( get_Fields )						 ( 
    
 /* [retval][out] */ DAOFields __RPC_FAR *__RPC_FAR *ppflds ) PURE;
	STDMETHOD( CreateField )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Size,
 /* [retval][out] */ DAOField __RPC_FAR *__RPC_FAR *ppfld ) PURE;
	STDMETHOD( get_PartialReplica )				 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPartialReplica ) PURE;
	STDMETHOD( put_PartialReplica )				 ( 
    
 /* [in] */ VARIANT_BOOL fPartialReplica ) PURE;
	};// end interface;

// Interface: DAORelations
#undef INTERFACE
#define INTERFACE DAORelations
DECLARE_INTERFACE_(DAORelations, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAORelation __RPC_FAR *__RPC_FAR *pprel ) PURE;
	};// end interface;

// Interface: DAOContainer
#undef INTERFACE
#define INTERFACE DAOContainer
DECLARE_INTERFACE_(DAOContainer, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Owner )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Owner )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_UserName )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Permissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Permissions )				 ( 
    
 /* [in] */ long permissions ) PURE;
	STDMETHOD( get_Inherit )					 ( 
    
 /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb ) PURE;
	STDMETHOD( put_Inherit )					 ( 
    
 /* [in] */ VARIANT_BOOL fInherit ) PURE;
	STDMETHOD( get_Documents )					 ( 
    
 /* [retval][out] */ DAODocuments __RPC_FAR *__RPC_FAR *ppdocs ) PURE;
	STDMETHOD( get_AllPermissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	};// end interface;

// Interface: DAOContainers
#undef INTERFACE
#define INTERFACE DAOContainers
DECLARE_INTERFACE_(DAOContainers, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAOContainer __RPC_FAR *__RPC_FAR *ppctn ) PURE;
	};// end interface;

// Interface: DAODocument
#undef INTERFACE
#define INTERFACE DAODocument
DECLARE_INTERFACE_(DAODocument, _DAO)
{
	STDMETHOD( get_Name )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_Owner )						 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_Owner )						 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Container )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( get_UserName )					 ( 
    
 /* [retval][out] */ BSTR __RPC_FAR *pbstr ) PURE;
	STDMETHOD( put_UserName )					 ( 
    
 /* [in] */ BSTR bstr ) PURE;
	STDMETHOD( get_Permissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( put_Permissions )				 ( 
    
 /* [in] */ long permissions ) PURE;
	STDMETHOD( get_DateCreated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_LastUpdated )				 ( 
    
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	STDMETHOD( get_AllPermissions )				 ( 
    
 /* [retval][out] */ long __RPC_FAR *pl ) PURE;
	STDMETHOD( CreateProperty )					 ( 
    
 /* [optional][in] */ VARIANT Name,
 /* [optional][in] */ VARIANT Type,
 /* [optional][in] */ VARIANT Value,
 /* [optional][in] */ VARIANT DDL,
 /* [retval][out] */ DAOProperty __RPC_FAR *__RPC_FAR *pprp ) PURE;
	};// end interface;

// Interface: DAODocuments
#undef INTERFACE
#define INTERFACE DAODocuments
DECLARE_INTERFACE_(DAODocuments, _DAOCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [in] */ VARIANT Item,
 /* [retval][out] */ DAODocument __RPC_FAR *__RPC_FAR *ppdoc ) PURE;
	};// end interface;

// Interface: DAOIndexFields
#undef INTERFACE
#define INTERFACE DAOIndexFields
DECLARE_INTERFACE_(DAOIndexFields, _DAODynaCollection)
{
	STDMETHOD( get_Item )						 ( 
    
 /* [optional][in] */ VARIANT Item,
 /* [retval][out] */ VARIANT __RPC_FAR *pvar ) PURE;
	};// end interface;

#endif // _DBDAOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\addguid.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// addguid.h

// Declaration of interface GUID for IDSAddIn.  IDSAddIn is defined in
//  addauto.h

// NOTE!!!  This file uses the DEFINE_GUID macro.  If you #include
//  this file in your project, then you must also #include it in
//  exactly one of your project's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <addguid.h>
//  If you fail to do this, you will get UNRESOLVED EXTERNAL linker errors.
//  The Developer Studio add-in wizard automatically does this for you.

#ifndef __ADDGUID_H__
#define __ADDGUID_H__

// {C0002F81-AE2E-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IDSAddIn, 
0xc0002f81, 0xae2e, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);


#endif //__ADDGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\dbdaoid.h ===
/************************************************************************
**	D B D A O I D . H													*
**																		*
**																		*
**	OLE DAO component class id definitions								*
**	DAO has been allocated the GUID::Data1 range of 0x00025eXX			*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

/*	The pre-3.5 GUIDs have been redefined with "30" added to the ID. For example:
	IID_IDAOIndex becomes IID30_IDAOIndex
	This way both the 30 and 3.5 GUIDs can be used at once
*/


DEFINE_OLEGUID(LIBID_CJETSQLHELP,		0x00025f01, 0, 0);

#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

// Type library
DEFINE_OLEGUID(LIBID_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID_CDAO25,			0x00025e04, 0, 0);

// StdObject
DEFINE_DAOGUID(IID_IDAOStdObject,		0x0000000A);

// StdCollection
DEFINE_DAOGUID(IID_IDAOStdCollection,	0x0000000C);

// Creatable Classes
DEFINE_DAOGUID(CLSID_CDAODBEngine,		0x00000010);
DEFINE_DAOGUID(CLSID_CDAOPrivDBEngine,	0x00000011);
DEFINE_DAOGUID(CLSID_CDAOConnection,	0x00000012);
DEFINE_DAOGUID(CLSID_CDAOTableDef,		0x00000013);
DEFINE_DAOGUID(CLSID_CDAOField, 		0x00000014);
DEFINE_DAOGUID(CLSID_CDAOIndex, 		0x00000015);
DEFINE_DAOGUID(CLSID_CDAOGroup, 		0x00000016);
DEFINE_DAOGUID(CLSID_CDAOUser,			0x00000017);
DEFINE_DAOGUID(CLSID_CDAOQueryDef,		0x00000018);
DEFINE_DAOGUID(CLSID_CDAORelation,		0x00000019);

// DBEngine
DEFINE_DAOGUID(IID_IDAODBEngine,		0x00000020);
DEFINE_DAOGUID(IID_IDAODBEngineW,		0x00000021);

// Error
DEFINE_DAOGUID(IID_IDAOError,			0x00000022);
DEFINE_DAOGUID(IID_IDAOErrorW,			0x00000023);
DEFINE_DAOGUID(IID_IDAOErrors,			0x00000024);
DEFINE_DAOGUID(IID_IDAOErrorsW,			0x00000025);

// Property
DEFINE_DAOGUID(IID_IDAOProperty,		0x00000026);
DEFINE_DAOGUID(IID_IDAOPropertyW,		0x00000027);
DEFINE_DAOGUID(IID_IDAOProperties,		0x00000028);
DEFINE_DAOGUID(IID_IDAOPropertiesW,		0x00000029);

// Recordset
DEFINE_DAOGUID(IID_IDAORecordset,		0x00000030);
DEFINE_DAOGUID(IID_IDAORecordsetW,		0x00000031);
DEFINE_DAOGUID(IID_IDAORecordsets,		0x00000032);
DEFINE_DAOGUID(IID_IDAORecordsetsW,		0x00000033);
DEFINE_OLEGUID(IID_ICDAORecordset,		0x00025e31, 0, 0);	//same as it was in 3.0

// Workspace
DEFINE_DAOGUID(IID_IDAOWorkspace,		0x00000038);
DEFINE_DAOGUID(IID_IDAOWorkspaceW,		0x00000039);
DEFINE_DAOGUID(IID_IDAOWorkspaces,		0x0000003A);
DEFINE_DAOGUID(IID_IDAOWorkspacesW,		0x0000003B);

// Connection
DEFINE_DAOGUID(IID_IDAOConnection,		0x00000040);
DEFINE_DAOGUID(IID_IDAOConnectionW,		0x00000041);
DEFINE_DAOGUID(IID_IDAOConnections,		0x00000042);
DEFINE_DAOGUID(IID_IDAOConnectionsW,	0x00000043);

// TableDef
DEFINE_DAOGUID(IID_IDAOTableDef,		0x00000048);
DEFINE_DAOGUID(IID_IDAOTableDefW,		0x00000049);
DEFINE_DAOGUID(IID_IDAOTableDefs,		0x0000004A);
DEFINE_DAOGUID(IID_IDAOTableDefsW,		0x0000004B);

// Field
DEFINE_DAOGUID(IID_IDAOField,			0x00000050);
DEFINE_DAOGUID(IID_IDAOFieldW,			0x00000051);
DEFINE_DAOGUID(IID_IDAOFields,			0x00000052);
DEFINE_DAOGUID(IID_IDAOFieldsW,			0x00000053);

// Index
DEFINE_DAOGUID(IID_IDAOIndex,			0x00000058);
DEFINE_DAOGUID(IID_IDAOIndexW,			0x00000059);
DEFINE_DAOGUID(IID_IDAOIndexes,			0x0000005A);
DEFINE_DAOGUID(IID_IDAOIndexesW,		0x0000005B);
DEFINE_DAOGUID(IID_IDAOIndexFields,		0x0000005C);
DEFINE_DAOGUID(IID_IDAOIndexFieldsW,	0x0000005D);

// Group
DEFINE_DAOGUID(IID_IDAOGroup,			0x00000060);
DEFINE_DAOGUID(IID_IDAOGroupW,			0x00000061);
DEFINE_DAOGUID(IID_IDAOGroups,			0x00000062);
DEFINE_DAOGUID(IID_IDAOGroupsW,			0x00000063);

// User
DEFINE_DAOGUID(IID_IDAOUser,			0x00000068);
DEFINE_DAOGUID(IID_IDAOUserW,			0x00000069);
DEFINE_DAOGUID(IID_IDAOUsers,			0x0000006A);
DEFINE_DAOGUID(IID_IDAOUsersW,			0x0000006B);

// Database
DEFINE_DAOGUID(IID_IDAODatabase,		0x00000070);
DEFINE_DAOGUID(IID_IDAODatabaseW,		0x00000071);
DEFINE_DAOGUID(IID_IDAODatabases,		0x00000072);
DEFINE_DAOGUID(IID_IDAODatabasesW,		0x00000073);

// QueryDef
DEFINE_DAOGUID(IID_IDAOQueryDef,		0x00000078);
DEFINE_DAOGUID(IID_IDAOQueryDefW,		0x00000079);
DEFINE_DAOGUID(IID_IDAOQueryDefs,		0x0000007A);
DEFINE_DAOGUID(IID_IDAOQueryDefsW,		0x0000007B);

// Parameter
DEFINE_DAOGUID(IID_IDAOParameter,		0x00000080);
DEFINE_DAOGUID(IID_IDAOParameterW,		0x00000081);
DEFINE_DAOGUID(IID_IDAOParameters,		0x00000082);
DEFINE_DAOGUID(IID_IDAOParametersW,		0x00000083);

// Relation
DEFINE_DAOGUID(IID_IDAORelation,		0x00000088);
DEFINE_DAOGUID(IID_IDAORelationW,		0x00000089);
DEFINE_DAOGUID(IID_IDAORelations,		0x0000008A);
DEFINE_DAOGUID(IID_IDAORelationsW,		0x0000008B);

// Container
DEFINE_DAOGUID(IID_IDAOContainer,		0x00000090);
DEFINE_DAOGUID(IID_IDAOContainerW,		0x00000091);
DEFINE_DAOGUID(IID_IDAOContainers,		0x00000092);
DEFINE_DAOGUID(IID_IDAOContainersW,		0x00000093);

// Document
DEFINE_DAOGUID(IID_IDAODocument,		0x00000098);
DEFINE_DAOGUID(IID_IDAODocumentW,		0x00000099);
DEFINE_DAOGUID(IID_IDAODocuments,		0x0000009A);
DEFINE_DAOGUID(IID_IDAODocumentsW,		0x0000009B);

// Collections 
DEFINE_DAOGUID(IID_IDAOCollection,		0x000000A0);
DEFINE_DAOGUID(IID_IDAODynaCollection,	0x000000A2);

// Connection points 
DEFINE_DAOGUID(IID_IDAOQueryCP,			0x000000B0);
DEFINE_DAOGUID(IID_IDAOQueryAS,			0x000000B2);

// Type library
DEFINE_OLEGUID(LIBID30_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID30_CDAO25,			0x00025e04, 0, 0);

// StdObject
DEFINE_OLEGUID(IID30_IDAOStdObject,		0x00025e02, 0, 0);

// StdCollection
DEFINE_OLEGUID(IID30_IDAOStdCollection,	0x00025e03, 0, 0);

/*
	NOTES:
	* Two sets of CLSIDs exist for the DBEngine object.
	* DBEngine and DBEngine30.  The 30 extension means
	* that this engine should load the 3.0 typelibrary
	* from the registry.  Otherwise, load the 2.5/3.0
	* compatability type library
*/

// DBEngine
DEFINE_OLEGUID(CLSID30_CDAODBEngine,		0x00025e15, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngine,		0x00025e16, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngineW,		0x00025e17, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDBEngine,	0x00025e18, 0, 0);
DEFINE_OLEGUID(CLSID30_CDAOPrivDBEngine,	0x00025e19, 0, 0);

// Error
DEFINE_OLEGUID(IID30_IDAOError,			0x00025e1d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorW,			0x00025e1e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrors,			0x00025e1f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorsW,			0x00025e20, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETError,		0x00025e21, 0, 0);	//used by Access, goes away post 3.0

// Property
DEFINE_OLEGUID(IID30_IDAOProperty,		0x00025e25, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertyW,		0x00025e26, 0, 0);
DEFINE_OLEGUID(IID30_IDAOProperties,		0x00025e27, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertiesW,		0x00025e28, 0, 0);

// Recordset
DEFINE_OLEGUID(IID30_IDAORecordset,		0x00025e2d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetW,		0x00025e2e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsets,		0x00025e2f, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetsW,		0x00025e30, 0, 0);
DEFINE_OLEGUID(IID30_ICDAORecordset,		0x00025e31, 0, 0);	//NOTE: No change for 3.1 or 3.5
DEFINE_OLEGUID(IID30_ICDAOJETRecordset,	0x00025e32, 0, 0);

// Snapshot
DEFINE_OLEGUID(IID30_IDAOSnapshot,		0x00025e33, 0, 0);

// Table
DEFINE_OLEGUID(IID30_IDAOTable,			0x00025e34, 0, 0);

// Dynaset
DEFINE_OLEGUID(IID30_IDAODynaset,			0x00025e35, 0, 0);

// Workspace
DEFINE_OLEGUID(IID30_IDAOWorkspace,		0x00025e3a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaceW,		0x00025e3b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaces,		0x00025e3c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspacesW,		0x00025e3d, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETWorkspace,	0x00025e3e, 0, 0);

// Connection (new to 3.1)
DEFINE_OLEGUID(CLSID30_CDAOConnection,	0x00025eb1, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnection,		0x00025eb2, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionW,		0x00025eb3, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnections,		0x00025eb4, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionsW,	0x00025eb5, 0, 0);

// TableDef
DEFINE_OLEGUID(CLSID30_CDAOTableDef,		0x00025e43, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDef,		0x00025e44, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefW,		0x00025e45, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefs,		0x00025e46, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefsW,		0x00025e47, 0, 0);

// Field
DEFINE_OLEGUID(CLSID30_CDAOField, 		0x00025e4c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOField,			0x00025e4d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldW,			0x00025e4e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFields,			0x00025e4f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldsW,			0x00025e50, 0, 0);
//DEFINE_OLEGUID(IID30_ICDAOJETField,		0x00025e51, 0, 0);	//used by Access, goes away post 3.0
DEFINE_OLEGUID(IID30_ICDAOJETField,		0x00025e49, 0, 0);	//used by Access, goes away post 3.0

// Index
DEFINE_OLEGUID(CLSID30_CDAOIndex, 		0x00025e55, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndex,			0x00025e56, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexW,			0x00025ed7, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexes,			0x00025e58, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexesW,		0x00025e59, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFields,		0x00025e5a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFieldsW,	0x00025e5b, 0, 0);

// Group
DEFINE_OLEGUID(CLSID30_CDAOGroup, 		0x00025e5f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroup,			0x00025e60, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupW,			0x00025e61, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroups,			0x00025e62, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupsW,			0x00025e63, 0, 0);

// User
DEFINE_OLEGUID(CLSID30_CDAOUser,			0x00025e68, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUser,			0x00025e69, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUserW,			0x00025e6a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsers,			0x00025e6b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsersW,			0x00025e6c, 0, 0);

// Database
DEFINE_OLEGUID(IID30_IDAODatabase,		0x00025e71, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabaseW,		0x00025e72, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabases,		0x00025e73, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabasesW,		0x00025e74, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDatabase,	0x00025e75, 0, 0);

// QueryDef
DEFINE_OLEGUID(CLSID30_CDAOQueryDef,		0x00025e7a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDef,		0x00025e7b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefW,		0x00025e7c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefs,		0x00025e7d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefsW,		0x00025e7e, 0, 0);

// Parameter
DEFINE_OLEGUID(IID30_IDAOParameter,		0x00025e83, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameterW,		0x00025e84, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameters,		0x00025e85, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParametersW,		0x00025e86, 0, 0);

// Relation
DEFINE_OLEGUID(CLSID30_CDAORelation,		0x00025e8b, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelation,		0x00025e8c, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationW,		0x00025e8d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelations,		0x00025e8e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationsW,		0x00025e8f, 0, 0);

// Container
DEFINE_OLEGUID(IID30_IDAOContainer,		0x00025e94, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainerW,		0x00025e95, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainers,		0x00025e96, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainersW,		0x00025e97, 0, 0);

// Document
DEFINE_OLEGUID(IID30_IDAODocument,		0x00025e9c, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentW,		0x00025e9d, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocuments,		0x00025e9e, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentsW,		0x00025e9f, 0, 0);

// Collections
DEFINE_OLEGUID(IID30_IDAOCollection,		0x00025ea4, 0, 0);
DEFINE_OLEGUID(IID30_IDAODynaCollection,	0x00025ea5, 0, 0);

// Connection points
DEFINE_OLEGUID(IID30_IDAOQueryCP,			0x00025eaa, 0, 0);	// Connection point
DEFINE_OLEGUID(IID30_IDAOQueryAS,			0x00025eab, 0, 0);	// Advise sink interface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\appdefs.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// appdefs.h

// Declaration of constants and error IDs used by objects in the type library
//  VISUAL STUDIO 97 SHARED OBJECTS (SharedIDE\bin\devshl.dll)

#ifndef __APPDEFS_H__
#define __APPDEFS_H__


///////////////////////////////////////////////////////////////////////
// Enumerations used by Automation Methods

// Application.WindowState
enum DsWindowState
{
	dsWindowStateMaximized	= 1,
	dsWindowStateMinimized	= 2,	
	dsWindowStateNormal		= 3,
};

// Windows.Arrange()
enum DsArrangeStyle
{
	dsMinimize			= 1,
	dsTileHorizontal	= 2,
	dsTileVertical		= 3,
	dsCascade			= 4
};

// Application.AddCommandBarButton
enum DsButtonType
{
	dsGlyph			= 1,
	dsText			= 2
};

// Save, Close, SaveAll CloseAll
enum DsSaveChanges
{
	dsSaveChangesYes	= 1, 
	dsSaveChangesNo		= 2,
	dsSaveChangesPrompt	= 3
};

// Return value for Save, Close, SaveAll, CloseAll
enum DsSaveStatus
{
	dsSaveSucceeded	= 1,	// The Save was successful.
	dsSaveCanceled	= 2		// The Save was canceled
};


///////////////////////////////////////////////////////////////////////
// Error constants returned by Automation Methods.

#define DS_E_START			   0x8004A000

// general failure
#define DS_E_UNKNOWN			0x8004A000

// The user gave an incorrect parameter VALUE (type is OK, but the value
// is not).
#define DS_E_BAD_PARAM_VALUE	0x8004A001

// The user tried to manipulate a Document object whose associated
// document in the IDE has been closed.
#define DS_E_DOC_RELEASED		0x8004A002

// The user tried to manipulate a Window object whose associated
// window in the IDE has been closed.
#define DS_E_WINDOW_RELEASED		0x8004A003

// The user tried to access a method or property on an object after
// Visual Studio was requested to be shut down (via the UI or
// the Application::Quit method), but before the object was
// released.  In this state, although the object still exists,
// its methods and properties all throw this error.
#define DS_E_SHUTDOWN_REQUESTED		0x8004A012

// The user tried to add a command bar button for a non-existent command.
#define DS_E_COMMAND_NOT_EXIST		0x8004A013

// AddCommandBarButton failed.  The command which the caller wishes to
//  to be assigned to a toolbar button does exist, but an unexpected
//  error occurred while trying to create the button itself.
#define DS_E_CANT_ADD_CMDBAR_BUTTON	0x8004A014

// These errors are used by the project build systems. When a makefile is
// loaded which needs to be converted, one of these errors will be
// generation.  If the makefile was generated with VC the first error 
// will have. If the makefile was created with an older version of 
// Visual Studio, the other error will be sent.
#define DS_E_PROJECT_OLD_MAKEFILE_VC		0x8004A015
#define DS_E_PROJECT_OLD_MAKEFILE_DEVSTUDIO	0x8004A016

// The project system generates this error when attempting to open an
// external makefile.
#define DS_E_PROJECT_EXTERNAL_MAKEFILE		0x8004A017

// Cannot create a new window.
#define DS_E_CANNOTCREATENEWWINDOW			0x8004A018

// The window specified by the Item method's index cannot be found.
#define DS_E_CANNOT_FIND_WINDOW				0x8004A019

// The document specified by the Item method's index cannot be found.
#define DS_E_CANNOT_FIND_DOCUMENT			0x8004A01A

//
// File IO Errors - Used by Open, Close, CloseAll, Save, SaveAll, etc...
//
// The following errors are mapped from CFileException

#define DS_E_FILENOTFOUND		0x8004A004

#define DS_E_ENDOFFILE			0x8004A005

// All or part of the path is invalid.
#define DS_E_BADPATH 			0x8004A006

//The file could not be accessed.
#define DS_E_ACCESSDENIED 		0x8004A007

//There was an attempt to use an invalid file handle.
#define DS_E_INVALIDFILE 		0x8004A008	

//The disk is full.
#define DS_E_DISKFULL 			0x8004A009	

#define DS_E_SHARINGVIOLATION	0x8004A00A

// The following are file errors are not part of CFileException.

// File is ReadOnly on disk.
#define DS_E_READONLY			0x8004A010

// The document does not have a filename and cannot be saved.
#define DS_E_NOFILENAME			0x8004A011


#endif // __APPDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\appguid.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// appguid.h

// Declaration of GUIDs used for objects found in the type library
//  VISUAL STUDIO 97 SHARED OBJECTS (SharedIDE\bin\devshl.dll)

// NOTE!!!  This file uses the DEFINE_GUID macro.  If you #include
//  this file in your project, then you must also #include it in
//  exactly one of your project's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <appguid.h>
//  If you fail to do this, you will get UNRESOLVED EXTERNAL linker errors.
//  The Developer Studio add-in wizard automatically does this for you.

#ifndef __APPGUID_H__
#define __APPGUID_H__

/////////////////////////////////////////////////////////////////////////
// Application Object IDs

// {EC1D73A1-8CC4-11cf-9BE9-00A0C90A632C}
DEFINE_GUID(IID_IApplication,
0xEC1D73A1L,0x8CC4,0x11CF,0x9B,0xE9,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// {8EA3F900-4A9F-11cf-8E4E-00AA004254C4}
DEFINE_GUID(IID_IApplicationEvents, 
0x8ea3f900, 0x4a9f, 0x11cf, 0x8e, 0x4e, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4);

// {FB7FDAE2-89B8-11cf-9BE8-00A0C90A632C}
DEFINE_GUID(CLSID_Application, 
0xfb7fdae2, 0x89b8, 0x11cf, 0x9b, 0xe8, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c);


/////////////////////////////////////////////////////////////////////////
// Document Object IID

// {FB7FDAE1-89B8-11cf-9BE8-00A0C90A632C}
DEFINE_GUID(IID_IGenericDocument, 
0xfb7fdae1, 0x89b8, 0x11cf, 0x9b, 0xe8, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c);


/////////////////////////////////////////////////////////////////////////
// Documents Collection Object IID

// {FB7FDAE3-89B8-11CF-9BE8-00A0C90A632C}
DEFINE_GUID(IID_IDocuments,
0xFB7FDAE3L,0x89B8,0x11CF,0x9B,0xE8,0x00,0xA0,0xC9,0x0A,0x63,0x2C);


/////////////////////////////////////////////////////////////////////////
// Window Object IID

// {FD20FC80-A9D2-11cf-9C13-00A0C90A632C}
DEFINE_GUID(IID_IGenericWindow,
0xFD20FC80L,0xA9D2,0x11CF,0x9C,0x13,0x00,0xA0,0xC9,0x0A,0x63,0x2C);


/////////////////////////////////////////////////////////////////////////
// Windows Collection Object IID

// {3928F551-96E6-11cf-9C00-00A0C90A632C}
DEFINE_GUID(IID_IWindows, 
0x3928f551L, 0x96e6, 0x11cf, 0x9c, 0x00, 0x00, 0xa0, 0xc9, 0xa, 0x63, 0x2c);


/////////////////////////////////////////////////////////////////////////
// Project Object IID

// {8CA5A960-FC7D-11cf-927D-00A0C9138C45}
DEFINE_GUID(IID_IGenericProject, 
0x8ca5a960, 0xfc7d, 0x11cf, 0x92, 0x7d, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);


/////////////////////////////////////////////////////////////////////////
// Projects Collection Object IID

// {13BF7741-A7E8-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IProjects,
0x13BF7741L,0xA7E8,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);


#endif //__APPGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\bldauto.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// bldauto.h

// Declaration of dual interfaces to objects found in the type library
//  VISUAL STUDIO 97 PROJECT SYSTEM (SharedIDE\bin\ide\devbld.pkg)

#ifndef __BLDAUTO_H__
#define __BLDAUTO_H__

#include "appauto.h"
#include "blddefs.h"

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/////////////////////////////////////////////////////////////////////////////
// Interfaces declared in this file:

// IGenericProject
	interface IBuildProject;

interface IConfiguration;
interface IConfigurations;


/////////////////////////////////////////////////////////////////////////
// BuildProject Object

// IBuildProject interface

#undef INTERFACE
#define INTERFACE IBuildProject

DECLARE_INTERFACE_(IBuildProject, IGenericProject)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IGenericProject methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pType) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
#endif

	/* IBuildProject methods */
    STDMETHOD(get_Configurations)(THIS_ IConfigurations FAR* FAR* Configurations) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Configuration object

// IConfiguration interface

#undef INTERFACE
#define INTERFACE IConfiguration

DECLARE_INTERFACE_(IConfiguration, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IConfiguration methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(AddToolSettings)(THIS_ BSTR szTool, BSTR szSettings, VARIANT Reserved) PURE;
    STDMETHOD(RemoveToolSettings)(THIS_ BSTR szTool, BSTR szSettings, VARIANT Reserved) PURE;
    STDMETHOD(AddCustomBuildStep)(THIS_ BSTR szCommand, BSTR szOutput, BSTR szDescription, VARIANT Reserved) PURE;
};


/////////////////////////////////////////////////////////////////////////
// Configurations collection object

// IConfigurations interface

#undef INTERFACE
#define INTERFACE IConfigurations

DECLARE_INTERFACE_(IConfigurations, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IConfigurations methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get_Parent)(THIS_ IBuildProject FAR* FAR* Parent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, IConfiguration FAR* FAR* Item) PURE;
};


#endif //__BLDAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\blddefs.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// blddefs.h

// Declaration of constants and error IDs used by objects in the type library
//  VISUAL STUDIO 97 PROJECT SYSTEM (SharedIDE\bin\ide\devbld.pkg)

#ifndef __BLDDEFS_H__
#define __BLDDEFS_H__


///////////////////////////////////////////////////////////////////////
// String constant used by Automation Methods

#define DS_BUILD_PROJECT	"Build"


///////////////////////////////////////////////////////////////////////
// Error constants returned by Automation Methods.

// The configuration represented by this object is no longer valid.
//  The configuration may have been removed by the user, or the
//  workspace closed since the configuration was last accessed.
#define DS_E_CONFIGURATION_NOT_VALID		0x80040301

// The settings can't be added or removed.  Perhaps the tool or options
//  specified do not exist.
#define DS_E_CANT_ADD_SETTINGS				0x80040302
#define DS_E_CANT_REMOVE_SETTINGS			0x80040303

// There was an error in the specification of the custom build step.
#define DS_E_CANT_ADD_BUILD_STEP			0x80040304

// The user attempted to manipulate a configuration of the wrong
//  platform.  For example, trying to manipulate an MIPS configuration
//  while running on an Intel machine will cause this error.
#define DS_E_CONFIGURATION_NOT_SUPPORTED	0x80040305

// The project represented by this object is no longer valid.  The
//  workspace containing that project may have been closed since
//  the project was last accessed, for example.
#define DS_E_PROJECT_NOT_VALID				0x80040306

// A build (or RebuildAll) can not be started when a build is already
//  in progress.  Attempting to do this can cause this error.
#define DS_E_CANT_SPAWN_BUILD				0x80040307


#endif //__BLDDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\bldguid.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// bldguid.h

// Declaration of GUIDs used for objects found in the type library
//  VISUAL STUDIO 97 PROJECT SYSTEM (SharedIDE\bin\ide\devbld.pkg)

// NOTE!!!  This file uses the DEFINE_GUID macro.  If you #include
//  this file in your project, then you must also #include it in
//  exactly one of your project's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <bldguid.h>
//  If you fail to do this, you will get UNRESOLVED EXTERNAL linker errors.
//  The Developer Studio add-in wizard automatically does this for you.

#ifndef __BLDGUID_H__
#define __BLDGUID_H__

/////////////////////////////////////////////////////////////////////////
// BuildProject Object IID

// {96961264-A819-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IBuildProject,
0x96961264L,0xA819,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);


/////////////////////////////////////////////////////////////////////////
// Configuration Object IID

// {96961263-A819-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IConfiguration,
0x96961263L,0xA819,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);


/////////////////////////////////////////////////////////////////////////
// Configurations Collection Object IID

// {96961260-A819-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IConfigurations,
0x96961260L,0xA819,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);



#endif //__BLDGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\dbgauto.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// dbgauto.h

// Declaration of dual interfaces to objects found in the type library
//  VISUAL STUDIO 97 DEBUGGER (SharedIDE\bin\ide\devdbg.pkg)

#ifndef __DBGAUTO_H__
#define __DBGAUTO_H__

#include "dbgdefs.h"

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/////////////////////////////////////////////////////////////////////////////
// Interfaces declared in this file:

interface IDebugger;
interface IDebuggerEvents;

interface IBreakpoint;
interface IBreakpoints;


/////////////////////////////////////////////////////////////////////////////
// Debugger object

// IDebugger interface

#undef INTERFACE
#define INTERFACE IDebugger

DECLARE_INTERFACE_(IDebugger, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IDebugger methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Breakpoints)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_DefaultRadix)(THIS_ long FAR* pLong) PURE;
    STDMETHOD(put_DefaultRadix)(THIS_ long l) PURE;
    STDMETHOD(get_State)(THIS_ DsExecutionState FAR* pState) PURE;
    STDMETHOD(get_JustInTimeDebugging)(THIS_ VARIANT_BOOL FAR* pBoolean) PURE;
    STDMETHOD(put_JustInTimeDebugging)(THIS_ VARIANT_BOOL bool) PURE;
    STDMETHOD(get_RemoteProcedureCallDebugging)(THIS_ VARIANT_BOOL FAR* pBoolean) PURE;
    STDMETHOD(put_RemoteProcedureCallDebugging)(THIS_ VARIANT_BOOL bool) PURE;
    STDMETHOD(Go)(THIS) PURE;
    STDMETHOD(StepInto)(THIS) PURE;
    STDMETHOD(StepOver)(THIS) PURE;
    STDMETHOD(StepOut)(THIS) PURE;
    STDMETHOD(Restart)(THIS) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(Break)(THIS) PURE;
    STDMETHOD(Evaluate)(THIS_ BSTR expr, BSTR FAR* pBSTR) PURE;
    STDMETHOD(ShowNextStatement)(THIS) PURE;
    STDMETHOD(RunToCursor)(THIS) PURE;
    STDMETHOD(SetNextStatement)(THIS_ VARIANT Selection) PURE;
};

// IDebuggerEvents interface

#undef INTERFACE
#define INTERFACE IDebuggerEvents

DECLARE_INTERFACE_(IDebuggerEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IDebuggerEvents methods */
    STDMETHOD(BreakpointHit)(THIS_ IDispatch * pBreakpoint) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Breakpoint object

// IBreakpoint interface

#undef INTERFACE
#define INTERFACE IBreakpoint

DECLARE_INTERFACE_(IBreakpoint, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IBreakpoint methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pBool) PURE;
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL bool) PURE;
    STDMETHOD(get_Location)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(get_File)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(get_Function)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(get_Executable)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(get_Condition)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(put_Condition)(THIS_ BSTR bstr) PURE;
    STDMETHOD(get_Elements)(THIS_ long FAR* pLong) PURE;
    STDMETHOD(get_PassCount)(THIS_ long FAR* pLong) PURE;
    STDMETHOD(get_Message)(THIS_ long FAR* pLong) PURE;
    STDMETHOD(get_WindowProcedure)(THIS_ BSTR FAR* pBSTR) PURE;
    STDMETHOD(get_Type)(THIS_ long FAR* pLong) PURE;
    STDMETHOD(Remove)(THIS) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Breakpoints object

// IBreakpoints interface

#undef INTERFACE
#define INTERFACE IBreakpoints

DECLARE_INTERFACE_(IBreakpoints, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IBreakpoints methods */
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item) PURE;
    STDMETHOD(RemoveAllBreakpoints)(THIS) PURE;	
    STDMETHOD(RemoveBreakpointAtLine)(THIS_ VARIANT sel, VARIANT_BOOL FAR* bool) PURE;
    STDMETHOD(AddBreakpointAtLine)(THIS_ VARIANT sel, IDispatch * FAR* Item) PURE;
};

#endif //__DBGAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\gl\glu.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glu.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Utility Library.

--*/

#ifndef __glu_h__
#ifndef __GLU_H__

#define __glu_h__
#define __GLU_H__

#include <GL/gl.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** Return the error string associated with a particular error code.
** This will return 0 for an invalid error code.
**
** The generic function prototype that can be compiled for ANSI or Unicode
** is defined as follows:
**
** LPCTSTR APIENTRY gluErrorStringWIN (GLenum errCode);
*/
#ifdef UNICODE
#define gluErrorStringWIN(errCode) ((LPCSTR)  gluErrorUnicodeStringEXT(errCode))
#else
#define gluErrorStringWIN(errCode) ((LPCWSTR) gluErrorString(errCode))
#endif

const GLubyte* APIENTRY gluErrorString (
    GLenum   errCode);

const wchar_t* APIENTRY gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* APIENTRY gluGetString (
    GLenum   name);

void APIENTRY gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void APIENTRY gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void APIENTRY gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void APIENTRY gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int APIENTRY gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int APIENTRY gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int APIENTRY gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int APIENTRY gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int APIENTRY gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

#ifdef __cplusplus

class GLUnurbs;
class GLUquadric;
class GLUtesselator;

/* backwards compatibility: */
typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;

#else

typedef struct GLUnurbs GLUnurbs;
typedef struct GLUquadric GLUquadric;
typedef struct GLUtesselator GLUtesselator;

/* backwards compatibility: */
typedef struct GLUnurbs GLUnurbsObj;
typedef struct GLUquadric GLUquadricObj;
typedef struct GLUtesselator GLUtesselatorObj;
typedef struct GLUtesselator GLUtriangulatorObj;

#endif


GLUquadric* APIENTRY gluNewQuadric (void);
void APIENTRY gluDeleteQuadric (
    GLUquadric          *state);

void APIENTRY gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void APIENTRY gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void APIENTRY gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void APIENTRY gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void APIENTRY gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void APIENTRY gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void APIENTRY gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (CALLBACK* fn)());

GLUtesselator* APIENTRY  gluNewTess(          
    void );

void APIENTRY  gluDeleteTess(       
    GLUtesselator       *tess );

void APIENTRY  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void APIENTRY  gluTessBeginContour( 
    GLUtesselator       *tess );

void APIENTRY  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void APIENTRY  gluTessEndContour(   
    GLUtesselator       *tess );

void APIENTRY  gluTessEndPolygon(   
    GLUtesselator       *tess );

void APIENTRY  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void APIENTRY  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void APIENTRY  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (CALLBACK *fn)());

void APIENTRY  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* APIENTRY gluNewNurbsRenderer (void);

void APIENTRY gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void APIENTRY gluBeginSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginTrim (
    GLUnurbs            *nobj);

void APIENTRY gluEndTrim (
    GLUnurbs            *nobj);

void APIENTRY gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void APIENTRY gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void APIENTRY 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void APIENTRY 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void APIENTRY 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void APIENTRY 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void APIENTRY 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (CALLBACK* fn)() );


/****           Callback function prototypes    ****/

/* gluQuadricCallback */
typedef void (CALLBACK* GLUquadricErrorProc) (GLenum);

/* gluTessCallback */
typedef void (CALLBACK* GLUtessBeginProc)        (GLenum);
typedef void (CALLBACK* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (CALLBACK* GLUtessVertexProc)       (void *);
typedef void (CALLBACK* GLUtessEndProc)          (void);
typedef void (CALLBACK* GLUtessErrorProc)        (GLenum);
typedef void (CALLBACK* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (CALLBACK* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (CALLBACK* GLUtessVertexDataProc)   (void *, void *);
typedef void (CALLBACK* GLUtessEndDataProc)      (void *);
typedef void (CALLBACK* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );

/* gluNurbsCallback */
typedef void (CALLBACK* GLUnurbsErrorProc)   (GLenum);


/****           Generic constants               ****/

/* Version */
#define GLU_VERSION_1_1                 1
#define GLU_VERSION_1_2                 1

/* Errors: (return value 0 = no error) */
#define GLU_INVALID_ENUM        100900
#define GLU_INVALID_VALUE       100901
#define GLU_OUT_OF_MEMORY       100902
#define GLU_INCOMPATIBLE_GL_VERSION     100903

/* StringName */
#define GLU_VERSION             100800
#define GLU_EXTENSIONS          100801

/* Boolean */
#define GLU_TRUE                GL_TRUE
#define GLU_FALSE               GL_FALSE


/****           Quadric constants               ****/

/* QuadricNormal */
#define GLU_SMOOTH              100000
#define GLU_FLAT                100001
#define GLU_NONE                100002

/* QuadricDrawStyle */
#define GLU_POINT               100010
#define GLU_LINE                100011
#define GLU_FILL                100012
#define GLU_SILHOUETTE          100013

/* QuadricOrientation */
#define GLU_OUTSIDE             100020
#define GLU_INSIDE              100021

/* Callback types: */
/*      GLU_ERROR               100103 */


/****           Tesselation constants           ****/

#define GLU_TESS_MAX_COORD              1.0e150

/* TessProperty */
#define GLU_TESS_WINDING_RULE           100140
#define GLU_TESS_BOUNDARY_ONLY          100141
#define GLU_TESS_TOLERANCE              100142

/* TessWinding */
#define GLU_TESS_WINDING_ODD            100130
#define GLU_TESS_WINDING_NONZERO        100131
#define GLU_TESS_WINDING_POSITIVE       100132
#define GLU_TESS_WINDING_NEGATIVE       100133
#define GLU_TESS_WINDING_ABS_GEQ_TWO    100134

/* TessCallback */
#define GLU_TESS_BEGIN          100100  /* void (CALLBACK*)(GLenum    type)  */
#define GLU_TESS_VERTEX         100101  /* void (CALLBACK*)(void      *data) */
#define GLU_TESS_END            100102  /* void (CALLBACK*)(void)            */
#define GLU_TESS_ERROR          100103  /* void (CALLBACK*)(GLenum    errno) */
#define GLU_TESS_EDGE_FLAG      100104  /* void (CALLBACK*)(GLboolean boundaryEdge)  */
#define GLU_TESS_COMBINE        100105  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut)     */
#define GLU_TESS_BEGIN_DATA     100106  /* void (CALLBACK*)(GLenum    type,  
                                                            void      *polygon_data) */
#define GLU_TESS_VERTEX_DATA    100107  /* void (CALLBACK*)(void      *data, 
                                                            void      *polygon_data) */
#define GLU_TESS_END_DATA       100108  /* void (CALLBACK*)(void      *polygon_data) */
#define GLU_TESS_ERROR_DATA     100109  /* void (CALLBACK*)(GLenum    errno, 
                                                            void      *polygon_data) */
#define GLU_TESS_EDGE_FLAG_DATA 100110  /* void (CALLBACK*)(GLboolean boundaryEdge,
                                                            void      *polygon_data) */
#define GLU_TESS_COMBINE_DATA   100111  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut,
                                                            void      *polygon_data) */

/* TessError */
#define GLU_TESS_ERROR1     100151
#define GLU_TESS_ERROR2     100152
#define GLU_TESS_ERROR3     100153
#define GLU_TESS_ERROR4     100154
#define GLU_TESS_ERROR5     100155
#define GLU_TESS_ERROR6     100156
#define GLU_TESS_ERROR7     100157
#define GLU_TESS_ERROR8     100158

#define GLU_TESS_MISSING_BEGIN_POLYGON  GLU_TESS_ERROR1
#define GLU_TESS_MISSING_BEGIN_CONTOUR  GLU_TESS_ERROR2
#define GLU_TESS_MISSING_END_POLYGON    GLU_TESS_ERROR3
#define GLU_TESS_MISSING_END_CONTOUR    GLU_TESS_ERROR4
#define GLU_TESS_COORD_TOO_LARGE        GLU_TESS_ERROR5
#define GLU_TESS_NEED_COMBINE_CALLBACK  GLU_TESS_ERROR6

/****           NURBS constants                 ****/

/* NurbsProperty */
#define GLU_AUTO_LOAD_MATRIX    100200
#define GLU_CULLING             100201
#define GLU_SAMPLING_TOLERANCE  100203
#define GLU_DISPLAY_MODE        100204
#define GLU_PARAMETRIC_TOLERANCE        100202
#define GLU_SAMPLING_METHOD             100205
#define GLU_U_STEP                      100206
#define GLU_V_STEP                      100207

/* NurbsSampling */
#define GLU_PATH_LENGTH                 100215
#define GLU_PARAMETRIC_ERROR            100216
#define GLU_DOMAIN_DISTANCE             100217


/* NurbsTrim */
#define GLU_MAP1_TRIM_2         100210
#define GLU_MAP1_TRIM_3         100211

/* NurbsDisplay */
/*      GLU_FILL                100012 */
#define GLU_OUTLINE_POLYGON     100240
#define GLU_OUTLINE_PATCH       100241

/* NurbsCallback */
/*      GLU_ERROR               100103 */

/* NurbsErrors */
#define GLU_NURBS_ERROR1        100251
#define GLU_NURBS_ERROR2        100252
#define GLU_NURBS_ERROR3        100253
#define GLU_NURBS_ERROR4        100254
#define GLU_NURBS_ERROR5        100255
#define GLU_NURBS_ERROR6        100256
#define GLU_NURBS_ERROR7        100257
#define GLU_NURBS_ERROR8        100258
#define GLU_NURBS_ERROR9        100259
#define GLU_NURBS_ERROR10       100260
#define GLU_NURBS_ERROR11       100261
#define GLU_NURBS_ERROR12       100262
#define GLU_NURBS_ERROR13       100263
#define GLU_NURBS_ERROR14       100264
#define GLU_NURBS_ERROR15       100265
#define GLU_NURBS_ERROR16       100266
#define GLU_NURBS_ERROR17       100267
#define GLU_NURBS_ERROR18       100268
#define GLU_NURBS_ERROR19       100269
#define GLU_NURBS_ERROR20       100270
#define GLU_NURBS_ERROR21       100271
#define GLU_NURBS_ERROR22       100272
#define GLU_NURBS_ERROR23       100273
#define GLU_NURBS_ERROR24       100274
#define GLU_NURBS_ERROR25       100275
#define GLU_NURBS_ERROR26       100276
#define GLU_NURBS_ERROR27       100277
#define GLU_NURBS_ERROR28       100278
#define GLU_NURBS_ERROR29       100279
#define GLU_NURBS_ERROR30       100280
#define GLU_NURBS_ERROR31       100281
#define GLU_NURBS_ERROR32       100282
#define GLU_NURBS_ERROR33       100283
#define GLU_NURBS_ERROR34       100284
#define GLU_NURBS_ERROR35       100285
#define GLU_NURBS_ERROR36       100286
#define GLU_NURBS_ERROR37       100287

/****           Backwards compatibility for old tesselator           ****/

void APIENTRY   gluBeginPolygon( GLUtesselator *tess );

void APIENTRY   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void APIENTRY   gluEndPolygon(   GLUtesselator *tess );

/* Contours types -- obsolete! */
#define GLU_CW          100120
#define GLU_CCW         100121
#define GLU_INTERIOR    100122
#define GLU_EXTERIOR    100123
#define GLU_UNKNOWN     100124

/* Names without "TESS_" prefix */
#define GLU_BEGIN       GLU_TESS_BEGIN
#define GLU_VERTEX      GLU_TESS_VERTEX
#define GLU_END         GLU_TESS_END
#define GLU_ERROR       GLU_TESS_ERROR
#define GLU_EDGE_FLAG   GLU_TESS_EDGE_FLAG

#ifdef __cplusplus
}
#endif

#endif /* __GLU_H__ */
#endif /* __glu_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\dbgdefs.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// dbgdefs.h

// Declaration of constants and error IDs used by objects in the type library
//  VISUAL STUDIO 97 DEBUGGER (SharedIDE\bin\ide\devdbg.pkg)

#ifndef __DBGDEFS_H
#define __DBGDEFS_H


///////////////////////////////////////////////////////////////////////
// Enumerations used by Automation Methods

// Debuggee's execution state
enum DsExecutionState
{
	dsNoDebugee,
	dsBreak,
	dsRunning,
};

enum DsBreakpointType
{
	dsLocation,
	dsLocationWithTrueExpression,
	dsLocationWithChangedExpression,
	dsTrueExpression,
	dsChangedExpression,
	dsMessage,
};


///////////////////////////////////////////////////////////////////////
// Error constants returned by Automation Methods.

// the user tried to set text of a column selection
#define DS_E_DBG_PKG_RELEASED	0x8004D001

// a breakpoint was already removed
#define DS_E_BP_REMOVED			0x8004D002

// can't evaluate this expression
#define DS_E_DBG_CANT_EVAL		0x8004D003

// can't set IP to this line
#define DS_E_DBG_SET_IP			0x8004D004

// this command is invalid if debuggee is running
#define DS_E_DBG_RUNNING		0x8004D005

#endif // __DBGDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\dbgguid.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// dbgguid.h

// Declaration of GUIDs used for objects found in the type library
//  VISUAL STUDIO 97 DEBUGGER (SharedIDE\bin\ide\devdbg.pkg)

// NOTE!!!  This file uses the DEFINE_GUID macro.  If you #include
//  this file in your project, then you must also #include it in
//  exactly one of your project's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <dbgguid.h>
//  If you fail to do this, you will get UNRESOLVED EXTERNAL linker errors.
//  The Developer Studio add-in wizard automatically does this for you.

#ifndef __DBGGUID_H__
#define __DBGGUID_H__

/////////////////////////////////////////////////////////////////////////
// Debugger Object IID's

// {34C63001-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDebugger,
0x34C63001L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// {34C6301A-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDebuggerEvents,
0x34C6301AL,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


/////////////////////////////////////////////////////////////////////////
// Breakpoint Object IID

// {34C63004-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IBreakpoint,
0x34C63004L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


/////////////////////////////////////////////////////////////////////////
// Breakpoints Collection Object IID

// {34C63007-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IBreakpoints,
0x34C63007L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


#endif // __DBGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\dao360\_dbdao.h ===
/************************************************************************
**	_ D B D A O . H													*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 			*
**		   All Rights Reserved					 						*
************************************************************************/
/*
	_DBDAO.H

	Internal definitions and prototypes for dbdao C++ classes
*/
#ifndef __DBDAO_H_
#define __DBDAO_H_


/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;
class CdbBStr;

/*****************************************************************************
* DAO runtime key
*/
const char szKEY[] = "mbmabptebkjcdlgtjmskjwtsdhjbmkmwtrak";

/*****************************************************************************
* Miscellaneous defines
*/
#define DAO_MAXSEEKFIELDS 13


/*****************************************************************************
* CdbBSTR (OLE BSTR helper)
*/
class DLLEXPORT CdbBSTR
	{
	public:
	CONSTRUCTOR			CdbBSTR				(BSTR=NULL);
	DESTRUCTOR			~CdbBSTR			(VOID);

	operator			BSTR *				(VOID);
	operator			LPCTSTR				(VOID);

	private:
	BSTR				m_bstr;
	};

/*****************************************************************************
* CdbVariant (OLE Variant helper)
*/
class CdbVariant : public COleVariant
	{
	public:
	CONSTRUCTOR						CdbVariant						(LONG l);
	CONSTRUCTOR                     CdbVariant                      (VOID);
	CONSTRUCTOR                     CdbVariant                      (LPCTSTR pstr);
	CONSTRUCTOR                     CdbVariant                      (SHORT s, BOOL bIsBool = FALSE);
	CONSTRUCTOR                     CdbVariant                      (LPVARIANT pv);
	CONSTRUCTOR                     CdbVariant                      (LPSAFEARRAY psa);

	VOID                            operator =                      (LPVARIANT pv);
	VOID                            operator =                      (LPCTSTR pstr);
	VOID                            operator =                      (SHORT s);
	VOID                            operator =                      (const int i);
	VOID                            operator =                      (LONG l);
	};

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	VOID) : COleVariant()
	{
	vt		= VT_ERROR;
	scode	= DISP_E_PARAMNOTFOUND;
	}

inline CdbVariant::CdbVariant (LONG l)
{
		if (l == -1)		
			{	
			vt		= VT_ERROR;
			scode	= DISP_E_PARAMNOTFOUND;
			}
		else
			{
			vt		= VT_I4;
			lVal	= l;
			}
}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPCTSTR pstr): COleVariant(pstr,VT_BSTRT)
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	SHORT s, BOOL bIsBool) : COleVariant(s)
	{
	if (bIsBool)
		{
		vt		= VT_BOOL;
		boolVal	= s;
		}
	else if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPVARIANT	pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPSAFEARRAY psa)
	{
	if (!psa)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_ARRAY|VT_UI1;
		parray	= psa;
		}
	}

inline VOID	CdbVariant::operator =(
	LPVARIANT pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline VOID	CdbVariant::operator =(
	LPCTSTR pstr) 
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
#ifdef UNICODE
		bstrVal = SysAllocString(pstr);
#else
		bstrVal = SysAllocStringByteLen(pstr, strlen(pstr));
#endif
		vt = VT_BSTR;
		}
	}


inline VOID	CdbVariant::operator =(
	SHORT s)
	{
	if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= s;
		}
	}

inline VOID	CdbVariant::operator =(
	const int i)
	{
	if (i==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= (SHORT)i;
		}
	}


inline VOID	CdbVariant::operator =(
	LONG 	l)
	{
	if (l==-1)
		{
		vt 		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I4;
		lVal	= l;
		}
	}


/*****************************************************************************
* CdbWide
*/
HRESULT	CdbWideFromAnsi(LPSTR, unsigned int, BSTR *);

class CdbWide
	{
	public:
	CONSTRUCTOR			CdbWide				(LPSTR pstr, unsigned int cb=0)
		{
		CdbWideFromAnsi(pstr, (pstr ? (cb==0 ? strlen(pstr) : cb) : 0), &m_bstr);
		}
	DESTRUCTOR			~CdbWide			()
		{
		SysFreeString(m_bstr);
		}

	operator			LPWSTR					()
		{
		return (LPWSTR)m_bstr;
		}
	operator			LPSTR					()
		{
		return (LPSTR)m_bstr;
		}

	ULONG				cBytes					()
		{
		return SysStringByteLen(m_bstr);
		}

	private:
	BSTR				m_bstr;
	};


/*****************************************************************************
* CdbOleObject
*/
class DLLEXPORT CdbOleObject : public CObject
	{
	public:
	CONSTRUCTOR                             CdbOleObject            (VOID);
	virtual DESTRUCTOR						~CdbOleObject           (VOID);
	BOOL                                    Exists                  (VOID);
	CdbOleObject &							operator =              (CdbOleObject &o);
											operator LPUNKNOWN		(){ return GetInterface();}
	VOID                                    SetInterface            (LPUNKNOWN punk, BOOL bAddRef=FALSE);
	VOID                                    SetInterface            (REFIID riidClass, REFIID riidInterface);
	VOID                                    SetInterfaceLic         (REFIID riidClass, REFIID riidInterface);
	LPUNKNOWN								GetInterface            (BOOL bAddRef=FALSE, BOOL bThrowException=TRUE) const;

	virtual VOID							OnInterfaceChange       (VOID);
	VOID                                    SetRichErrorInfo        (LPOLESTR pstrSource, LPOLESTR pstrDescription, LPOLESTR pstrHelpFile, ULONG ulHelpID) const;

	protected:
	BOOL                                    StartOLE                        (VOID);
	LPUNKNOWN                               m_punkInterface;
	};



/*****************************************************************************
* CdbCollection
*/
class DLLEXPORT CdbCollection : public CdbOleObject
	{
	public:

	// Methods
	virtual CdbObject               ObItem                  (LONG i) = 0;
	virtual CdbObject               ObItem                  (LPCTSTR pstr) = 0;
	virtual LONG                    GetCount                (VOID) = 0;
	virtual VOID                    ObAppend                (CdbObject &obj) = 0;
	virtual VOID                    Delete                  (LPCTSTR pstr) = 0;
	virtual VOID                    Refresh                 (VOID) = 0;
	};

class DLLEXPORT CdbStaticCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID) ;
	};

class DLLEXPORT CdbDynamicCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID);
	};

#define DAOMFC_STATIC_COLLECTION_DECL(objColl, objSingle, intSingle)    \
	class DLLEXPORT objColl : public CdbStaticCollection                                                    \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

#define DAOMFC_DYNAMIC_COLLECTION_DECL(objColl, objSingle, intSingle)   \
	class DLLEXPORT objColl : public CdbDynamicCollection                                                   \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		VOID                            Append                          (objSingle &o);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

DAOMFC_STATIC_COLLECTION_DECL(CdbErrors, CdbError, DAOError);
DAOMFC_STATIC_COLLECTION_DECL(CdbDatabases, CdbDatabase, DAODatabase);
//Connections are special cased so we can trap the copy constructor
DAOMFC_STATIC_COLLECTION_DECL(CdbRecordsets, CdbRecordset, DAORecordset);
DAOMFC_STATIC_COLLECTION_DECL(CdbParameters, CdbParameter, DAOParameter);
DAOMFC_STATIC_COLLECTION_DECL(CdbDocuments, CdbDocument, DAODocument);
DAOMFC_STATIC_COLLECTION_DECL(CdbContainers, CdbContainer, DAOContainer);

DAOMFC_DYNAMIC_COLLECTION_DECL(CdbProperties, CdbProperty, DAOProperty);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbFields, CdbField, DAOField);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbQueryDefs, CdbQueryDef, DAOQueryDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbTableDefs, CdbTableDef, DAOTableDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbIndexes, CdbIndex, DAOIndex);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbRelations, CdbRelation, DAORelation);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbUsers, CdbUser, DAOUser);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbGroups, CdbGroup, DAOGroup);

//Need some extra functions in CdbWorkspaces to support the delay in creating the 
//default workspace needed to support the JET/ODBC option.
class DLLEXPORT CdbWorkspaces : public CdbDynamicCollection
	{        
	friend CdbDBEngine;
	private:
	DAODBEngine	*					pDBEng;
	BOOL							m_bDontStart;

	public:                                                                                                                 
	CONSTRUCTOR                     CdbWorkspaces			(VOID){pDBEng = NULL;}
	CdbWorkspace                    Item                    (LONG i);                               
	CdbWorkspace                    Item                    (LPCTSTR pstr);                 
	VOID                            Append                  (CdbWorkspace &o);                 
	CdbWorkspace                    operator[]              (LONG i);                         
	CdbWorkspace                    operator[]              (LPCTSTR pstr);                
	VOID                            SetDBEngine	            (DAODBEngine	*peng){pDBEng = peng;}
	VOID	                        GetDelayedInterface     ();
	};

//Need to trap Connections in the copy constructor so the user can't
//get a "sorta-kinda" working Connections collection on a Jet workspace
class DLLEXPORT CdbConnections : public CdbStaticCollection
	{        
	public:
	CONSTRUCTOR						CdbConnections			(CdbConnections &Connections);
	CONSTRUCTOR						CdbConnections			(){pwrk = NULL;}
	CdbConnection                   Item                    (LONG i);                               
	CdbConnection                   Item                    (LPCTSTR pstr);                 
	CdbConnection                   operator[]              (LONG i);                               
	CdbConnection                   operator[]              (LPCTSTR pstr);               
	CdbConnections	&				operator =				(CdbConnections &o);
	LONG                            GetCount                (VOID);
	VOID                            Refresh                 (VOID) ;
	VOID							SetWorkspace			(DAOWorkspace * pParent){pwrk = pParent;}			

	private:
	VOID							CheckInterface();
	DAOWorkspace *					pwrk;
	};

/*****************************************************************************
* CdbObject
*/
class DLLEXPORT CdbObject : public CdbOleObject
	{
	public:
	CONSTRUCTOR                             CdbObject                       (VOID);
	CONSTRUCTOR                             CdbObject                       (LPUNKNOWN punk, BOOL bAddRef=FALSE);

	virtual CString                 GetName                         (VOID); 
	virtual VOID                    SetName                         (LPCTSTR pstr);

	CdbProperties                   Properties;
	};



/*****************************************************************************
* CdbGetRowsEx  (holds GetRowsEx for Recordset)
*/

class DLLEXPORT CdbGetRowsEx : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGetRowsEx            (VOID);
	CONSTRUCTOR                     CdbGetRowsEx            (ICDAORecordset *pGetRows, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGetRowsEx            (const CdbGetRowsEx &);
	CdbGetRowsEx &          operator =                      (const CdbGetRowsEx &);
	VOID                            OnInterfaceChange       (VOID);

	};

/*****************************************************************************
* Helper macros
*/

//Initialize a variant
#define DAOVINIT(var)						\
	do										\
		{									\
		(var).vt	= VT_ERROR;				\
		(var).scode	= DISP_E_PARAMNOTFOUND;	\
		}									\
	while (0)


// LPTSTR to VARIANT
#define STV(pstr)	CdbVariant(pstr)

// LPTSTR to BSTR
#define STB(pstr)	V_BSTR(((LPVARIANT)STV(pstr)))

// LONG to VARIANT
#define LTV(l)		CdbVariant(l)

// Optional LONG to VARIANT
#define OLTV(l)		CdbVariant((l))

// C/C++ bool to DAO bool
#define BTB(b)		((VARIANT_BOOL)(b?-1:0))

// C/C++ bool to VARIANT
#define BTV(b)		CdbVariant(BTB(b), TRUE)

// C/C++ short to VARIANT
#define SHTV(s)		CdbVariant((SHORT)s)

// OLE variant to VARIANT
#define VTV(pv)		CdbVariant(pv)

// SAFEARRAY to VARIANT
#define ATV(psa, var)								\
	do												\
		{											\
		if (!psa)									\
			{										\
			var.vt		= VT_ERROR;					\
			var.scode	= DISP_E_PARAMNOTFOUND;		\
			}										\
		else										\
			{										\
			var.vt		= VT_ARRAY|VT_UI1;			\
			SafeArrayCopy(psa, &var.parray);	\
			}										\
		}											\
	while (0)

#define DAOMFC_CALL(hr)						\
	do \
	{ \
    HRESULT  hresult = (hr);           \
		if(FAILED(hresult)) \
		{ \
			TRACE0("\nDBDAO Call Failed.\n\t"); \
			TRACE2("\nIn file %s on line %d\n", _T("DBDAO.CPP"), __LINE__); \
			TRACE1("hResult = %X\n", hresult); \
			if (GetScode(hresult) == E_OUTOFMEMORY) \
				AfxThrowMemoryException(); \
			else \
				throw CdbException(hresult); \
		} \
	} while (0)


/*****************************************************************************
* Property Set/Get helper macros
*/

// Get a LONG property
#define LPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		LONG		l	= 0;						\
													\
		DAOMFC_CALL(p->meth(&l));					\
													\
		return l;									\
		}											\
	while (0)

// Set a LONG property
#define LPROPSET(intDAO, meth, l)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(l));					\
		}											\
	while(0)

// Get a SHORT property
#define WPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		SHORT		s	= 0;						\
													\
		DAOMFC_CALL(p->meth(&s));					\
													\
		return s;									\
		}											\
	while (0)

// Set a SHORT property
#define WPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(s));					\
		}											\
	while(0)

// Get a STRING property
#define SPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		CdbBSTR		bstr;							\
													\
		DAOMFC_CALL(p->meth(bstr));					\
													\
		return bstr;								\
		}											\
	while (0)

// Set a STRING property
#define SPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(STB(s)));				\
		}											\
	while(0)

// Get a DATETIME property
#define DPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		VARIANT 	Var;								\
													\
		VariantInit(&Var);							\
		DAOMFC_CALL(p->meth(&Var));					\
		return Var;									\
		}											\
	while (0)

// Set a DATETIME property
#define DPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a BOOLEAN property
#define BPROPGET(intDAO, meth)							\
	do													\
		{												\
		intDAO *		p	= (intDAO *)GetInterface();	\
		VARIANT_BOOL	vb	= 0;						\
														\
		DAOMFC_CALL(p->meth(&vb));						\
														\
		return (BOOL)vb;								\
		}												\
	while (0)

// Set a BOOLEAN property
#define BPROPSET(intDAO, meth, b)						\
	do													\
		{												\
		intDAO *	p = (intDAO *)GetInterface();		\
														\
		DAOMFC_CALL(p->meth(BTB(b)));					\
		}												\
	while(0)

// Get a VARIANT property
#define VPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		COleVariant 	v;								\
													\
		VariantInit(&v);							\
		DAOMFC_CALL(p->meth(&v));					\
													\
		return &v;									\
		}											\
	while (0)

// Set a VARIANT property
#define VPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a DWORD property
#define DWPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		DWORD		dw	= 0;						\
													\
		DAOMFC_CALL(p->meth(&dw));					\
													\
		return dw;									\
		}											\
	while (0)


#define DAOMFC_STATIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

#define DAOMFC_DYNAMIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		VOID				objColl::Append				(objSingle &o)	{ ObAppend(o); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

DECLARE_INTERFACE_(DAOMFCSCollection, _DAOCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};

DECLARE_INTERFACE_(DAOMFCDCollection, _DAODynaCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};


#endif // __DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\textdefs.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// textdefs.h

// Declaration of constants used by objects in the type library
//  VISUAL STUDIO 97 TEXT EDITOR (SharedIDE\bin\devedit.pkg)

#ifndef __TEXTDEFS_H__
#define __TEXTDEFS_H__


///////////////////////////////////////////////////////////////////////
// Enumerations used by Automation Methods

// select vs. extend
enum DsMovementOptions
{
	dsMove		= 0,
	dsExtend	= 1
};

// TextSelection.StartOfLine
enum DsStartOfLineOptions
{
	dsFirstColumn	= 0,
	dsFirstText		= 1
};

// TextSelection.ChangeCase
enum DsCaseOptions
{
	dsLowercase		= 1,
	dsUppercase		= 2,
	dsCapitalize	= 3
};

// TextSelection.DeleteWhitespace
enum DsWhitespaceOptions
{
	dsHorizontal	= 0,
	dsVertical		= 1
};

// TextSelection.GoToLine
enum DsGoToLineOptions
{
	dsLastLine = -1
};

// TextEditor.Emulation
enum DsEmulation
{

	dsDevStudio		= 0,
	dsVC2			= 1,
	dsBrief			= 2,
	dsEpsilon		= 3,
	dsCustom		= 4
};


// TextSelection.FindText/ReplaceText
enum DsTextSearchOptions
{
	dsMatchWord			= 2,	// match whole words
	dsMatchCase			= 4,	// match is sensitive to case
	dsMatchNoRegExp		= 0,	// don't use regular expressions
	dsMatchRegExp		= 8,	// match Dev Studio regular expressions
	dsMatchRegExpB		= 16,	// match BRIEF(TM) regular expressions
	dsMatchRegExpE		= 32,	// match Epsilon(TM) regular expressions
	dsMatchRegExpCur	= 64,	// match using current reg exp setting
	dsMatchForward		= 0,	// search forward
	dsMatchBackward		= 128,	// search backwards
	dsMatchFromStart	= 256,	// do search from start or end of view
};


// string constants

#define DS_IDL				"ODL/IDL"
#define DS_VBS				"VBS Macro"
#define DS_CPP				"C/C++"
#define DS_JAVA				"Java"
#define DS_HTML_IE3			"HTML - IE 3.0"
#define DS_HTML_RFC1866		"HTML 2.0 (RFC 1866)"
#define DS_FORTRAN_FIXED	"Fortran Fixed"
#define DS_FORTRAN_FREE		"Fortran Free"

#define DS_TEXT_DOCUMENT	"Text"

#endif //__TEXTDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\textguid.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// textguid.h

// Declaration of GUIDs used for objects found in the type library
//  VISUAL STUDIO 97 TEXT EDITOR (SharedIDE\bin\devedit.pkg)

// NOTE!!!  This file uses the DEFINE_GUID macro.  If you #include
//  this file in your project, then you must also #include it in
//  exactly one of your project's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <textguid.h>
//  If you fail to do this, you will get UNRESOLVED EXTERNAL linker errors.
//  The Developer Studio add-in wizard automatically does this for you.

#ifndef __TEXTGUID_H__
#define __TEXTGUID_H__


/////////////////////////////////////////////////////////////////////////
// TextDocument Object IID

// {2A6DF201-8240-11CF-AB59,00AA00C091A1}
DEFINE_GUID(IID_ITextDocument,
0x2A6DF201L,0x8240,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


/////////////////////////////////////////////////////////////////////////
// TextSelection Object IID

// {05092F20-833F-11CF-AB59-00AA00C091A1}
DEFINE_GUID(IID_ITextSelection,
0x05092F20L,0x833F,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


/////////////////////////////////////////////////////////////////////////
// TextWindow Object IID

// {08541520-83D3-11CF-AB59-00AA00C091A1}
DEFINE_GUID(IID_ITextWindow,
0x08541520L,0x83D3,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


/////////////////////////////////////////////////////////////////////////
// TextEditor Object IID

// {0DE5B3A0-A420-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_ITextEditor,
0x0DE5B3A0L,0xA420,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);


#endif // __TEXTGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\gl\glaux.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glaux.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Auxiliary Library.

--*/

#ifndef __GLAUX_H__
#define __GLAUX_H__

/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** ToolKit Window Types
** In the future, AUX_RGBA may be a combination of both RGB and ALPHA
*/

#define AUX_RGB             0
#define AUX_RGBA            AUX_RGB
#define AUX_INDEX           1
#define AUX_SINGLE          0
#define AUX_DOUBLE          2
#define AUX_DIRECT          0
#define AUX_INDIRECT        4

#define AUX_ACCUM           8
#define AUX_ALPHA           16
#define AUX_DEPTH24         32      /* 24-bit depth buffer */
#define AUX_STENCIL         64
#define AUX_AUX             128
#define AUX_DEPTH16         256     /* 16-bit depth buffer */
#define AUX_FIXED_332_PAL   512
#define AUX_DEPTH           AUX_DEPTH16 /* default is 16-bit depth buffer */

/* 
** Window Masks
*/

#define AUX_WIND_IS_RGB(x)      (((x) & AUX_INDEX) == 0)
#define AUX_WIND_IS_INDEX(x)    (((x) & AUX_INDEX) != 0)
#define AUX_WIND_IS_SINGLE(x)   (((x) & AUX_DOUBLE) == 0)
#define AUX_WIND_IS_DOUBLE(x)   (((x) & AUX_DOUBLE) != 0)
#define AUX_WIND_IS_INDIRECT(x) (((x) & AUX_INDIRECT) != 0)
#define AUX_WIND_IS_DIRECT(x)   (((x) & AUX_INDIRECT) == 0)
#define AUX_WIND_HAS_ACCUM(x)   (((x) & AUX_ACCUM) != 0)
#define AUX_WIND_HAS_ALPHA(x)   (((x) & AUX_ALPHA) != 0)
#define AUX_WIND_HAS_DEPTH(x)   (((x) & (AUX_DEPTH24 | AUX_DEPTH16)) != 0)
#define AUX_WIND_HAS_STENCIL(x) (((x) & AUX_STENCIL) != 0)
#define AUX_WIND_USES_FIXED_332_PAL(x)  (((x) & AUX_FIXED_332_PAL) != 0)

/*
** ToolKit Event Structure
*/

typedef struct _AUX_EVENTREC {
    GLint event;
    GLint data[4];
} AUX_EVENTREC;

/* 
** ToolKit Event Types
*/
#define AUX_EXPOSE      1
#define AUX_CONFIG      2
#define AUX_DRAW        4
#define AUX_KEYEVENT    8
#define AUX_MOUSEDOWN   16
#define AUX_MOUSEUP     32
#define AUX_MOUSELOC    64

/*
** Toolkit Event Data Indices
*/
#define AUX_WINDOWX             0
#define AUX_WINDOWY             1
#define AUX_MOUSEX              0
#define AUX_MOUSEY              1
#define AUX_MOUSESTATUS         3
#define AUX_KEY                 0
#define AUX_KEYSTATUS           1

/*
** ToolKit Event Status Messages
*/
#define AUX_LEFTBUTTON          1
#define AUX_RIGHTBUTTON         2
#define AUX_MIDDLEBUTTON        4
#define AUX_SHIFT               1
#define AUX_CONTROL             2

/* 
** ToolKit Key Codes
*/
#define AUX_RETURN              0x0D
#define AUX_ESCAPE              0x1B
#define AUX_SPACE               0x20
#define AUX_LEFT                0x25
#define AUX_UP                  0x26
#define AUX_RIGHT               0x27
#define AUX_DOWN                0x28
#define AUX_A                   'A'
#define AUX_B                   'B'
#define AUX_C                   'C'
#define AUX_D                   'D'
#define AUX_E                   'E'
#define AUX_F                   'F'
#define AUX_G                   'G'
#define AUX_H                   'H'
#define AUX_I                   'I'
#define AUX_J                   'J'
#define AUX_K                   'K'
#define AUX_L                   'L'
#define AUX_M                   'M'
#define AUX_N                   'N'
#define AUX_O                   'O'
#define AUX_P                   'P'
#define AUX_Q                   'Q'
#define AUX_R                   'R'
#define AUX_S                   'S'
#define AUX_T                   'T'
#define AUX_U                   'U'
#define AUX_V                   'V'
#define AUX_W                   'W'
#define AUX_X                   'X'
#define AUX_Y                   'Y'
#define AUX_Z                   'Z'
#define AUX_a                   'a'
#define AUX_b                   'b'
#define AUX_c                   'c'
#define AUX_d                   'd'
#define AUX_e                   'e'
#define AUX_f                   'f'
#define AUX_g                   'g'
#define AUX_h                   'h'
#define AUX_i                   'i'
#define AUX_j                   'j'
#define AUX_k                   'k'
#define AUX_l                   'l'
#define AUX_m                   'm'
#define AUX_n                   'n'
#define AUX_o                   'o'
#define AUX_p                   'p'
#define AUX_q                   'q'
#define AUX_r                   'r'
#define AUX_s                   's'
#define AUX_t                   't'
#define AUX_u                   'u'
#define AUX_v                   'v'
#define AUX_w                   'w'
#define AUX_x                   'x'
#define AUX_y                   'y'
#define AUX_z                   'z'
#define AUX_0                   '0'
#define AUX_1                   '1'
#define AUX_2                   '2'
#define AUX_3                   '3'
#define AUX_4                   '4'
#define AUX_5                   '5'
#define AUX_6                   '6'
#define AUX_7                   '7'
#define AUX_8                   '8'
#define AUX_9                   '9'

/*
** ToolKit Gets and Sets
*/
#define AUX_FD                  1  /* return fd (long) */
#define AUX_COLORMAP            3  /* pass buf of r, g and b (unsigned char) */
#define AUX_GREYSCALEMAP        4
#define AUX_FOGMAP              5  /* pass fog and color bits (long) */
#define AUX_ONECOLOR            6  /* pass index, r, g, and b (long) */

/*
** Color Macros
*/

#define AUX_BLACK               0
#define AUX_RED                 13
#define AUX_GREEN               14
#define AUX_YELLOW              15
#define AUX_BLUE                16
#define AUX_MAGENTA             17
#define AUX_CYAN                18
#define AUX_WHITE               19

extern float auxRGBMap[20][3];

#define AUX_SETCOLOR(x, y) (AUX_WIND_IS_RGB((x)) ? \
                           glColor3fv(auxRGBMap[(y)]) : glIndexf((y)))

/*
** RGB Image Structure
*/

typedef struct _AUX_RGBImageRec {
    GLint sizeX, sizeY;
    unsigned char *data;
} AUX_RGBImageRec;

/*
** Prototypes
*/

void APIENTRY auxInitDisplayMode(GLenum);
void APIENTRY auxInitPosition(int, int, int, int);

/* GLenum APIENTRY auxInitWindow(LPCTSTR); */
#ifdef UNICODE
#define auxInitWindow auxInitWindowW
#else
#define auxInitWindow auxInitWindowA
#endif
GLenum APIENTRY auxInitWindowA(LPCSTR);
GLenum APIENTRY auxInitWindowW(LPCWSTR);

void APIENTRY auxCloseWindow(void);
void APIENTRY auxQuit(void);
void APIENTRY auxSwapBuffers(void);

typedef void (CALLBACK* AUXMAINPROC)(void);
void APIENTRY auxMainLoop(AUXMAINPROC);

typedef void (CALLBACK* AUXEXPOSEPROC)(int, int);
void APIENTRY auxExposeFunc(AUXEXPOSEPROC);

typedef void (CALLBACK* AUXRESHAPEPROC)(GLsizei, GLsizei);
void APIENTRY auxReshapeFunc(AUXRESHAPEPROC);

typedef void (CALLBACK* AUXIDLEPROC)(void);
void APIENTRY auxIdleFunc(AUXIDLEPROC);

typedef void (CALLBACK* AUXKEYPROC)(void);
void APIENTRY auxKeyFunc(int, AUXKEYPROC);

typedef void (CALLBACK* AUXMOUSEPROC)(AUX_EVENTREC *);
void APIENTRY auxMouseFunc(int, int, AUXMOUSEPROC);

int  APIENTRY auxGetColorMapSize(void);
void APIENTRY auxGetMouseLoc(int *, int *);
void APIENTRY auxSetOneColor(int, float, float, float);
void APIENTRY auxSetFogRamp(int, int);
void APIENTRY auxSetGreyRamp(void);
void APIENTRY auxSetRGBMap(int, float *);

/* AUX_RGBImageRec * APIENTRY auxRGBImageLoad(LPCTSTR); */
#ifdef UNICODE
#define auxRGBImageLoad auxRGBImageLoadW
#else
#define auxRGBImageLoad auxRGBImageLoadA
#endif
AUX_RGBImageRec * APIENTRY auxRGBImageLoadA(LPCSTR);
AUX_RGBImageRec * APIENTRY auxRGBImageLoadW(LPCWSTR);

#ifdef UNICODE
#define auxDIBImageLoad auxDIBImageLoadW
#else
#define auxDIBImageLoad auxDIBImageLoadA
#endif
AUX_RGBImageRec * APIENTRY auxDIBImageLoadA(LPCSTR);
AUX_RGBImageRec * APIENTRY auxDIBImageLoadW(LPCWSTR);

void APIENTRY auxCreateFont(void);
/* void APIENTRY auxDrawStr(LPCTSTR); */
#ifdef UNICODE
#define auxDrawStr auxDrawStrW
#else
#define auxDrawStr auxDrawStrA
#endif
void APIENTRY auxDrawStrA(LPCSTR);
void APIENTRY auxDrawStrW(LPCWSTR);

void APIENTRY auxWireSphere(GLdouble);
void APIENTRY auxSolidSphere(GLdouble);
void APIENTRY auxWireCube(GLdouble);
void APIENTRY auxSolidCube(GLdouble);
void APIENTRY auxWireBox(GLdouble, GLdouble, GLdouble);
void APIENTRY auxSolidBox(GLdouble, GLdouble, GLdouble);
void APIENTRY auxWireTorus(GLdouble, GLdouble);
void APIENTRY auxSolidTorus(GLdouble, GLdouble);
void APIENTRY auxWireCylinder(GLdouble, GLdouble);
void APIENTRY auxSolidCylinder(GLdouble, GLdouble);
void APIENTRY auxWireIcosahedron(GLdouble);
void APIENTRY auxSolidIcosahedron(GLdouble);
void APIENTRY auxWireOctahedron(GLdouble);
void APIENTRY auxSolidOctahedron(GLdouble);
void APIENTRY auxWireTetrahedron(GLdouble);
void APIENTRY auxSolidTetrahedron(GLdouble);
void APIENTRY auxWireDodecahedron(GLdouble);
void APIENTRY auxSolidDodecahedron(GLdouble);
void APIENTRY auxWireCone(GLdouble, GLdouble);
void APIENTRY auxSolidCone(GLdouble, GLdouble);
void APIENTRY auxWireTeapot(GLdouble);
void APIENTRY auxSolidTeapot(GLdouble);

/*
** Window specific functions
** hwnd, hdc, and hglrc valid after auxInitWindow()
*/
HWND  APIENTRY auxGetHWND(void);
HDC   APIENTRY auxGetHDC(void);
HGLRC APIENTRY auxGetHGLRC(void);

/*
** Viewperf support functions and constants
*/
/* Display Mode Selection Criteria */
enum {
    AUX_USE_ID = 1,
    AUX_EXACT_MATCH,
    AUX_MINIMUM_CRITERIA
};
void   APIENTRY auxInitDisplayModePolicy(GLenum);
GLenum APIENTRY auxInitDisplayModeID(GLint);
GLenum APIENTRY auxGetDisplayModePolicy(void);
GLint  APIENTRY auxGetDisplayModeID(void);
GLenum APIENTRY auxGetDisplayMode(void);

#ifdef __cplusplus
}
#endif

#endif /* __GLAUX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\gl\gl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-96, Microsoft Corporation

Module Name:

    gl.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    component.

--*/

#ifndef __gl_h_
#ifndef __GL_H__

#define __gl_h_
#define __GL_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1996 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

/*************************************************************/

/* Version */
#define GL_VERSION_1_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801


/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */
/*      GL_PHONG_HINT */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01


/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* Extensions */
#define GL_EXT_vertex_array               1
#define GL_EXT_bgra                       1
#define GL_EXT_paletted_texture           1
#define GL_WIN_swap_hint                  1
#define GL_WIN_draw_range_elements        1
// #define GL_WIN_phong_shading              1
// #define GL_WIN_specular_fog               1

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT               0x8074
#define GL_NORMAL_ARRAY_EXT               0x8075
#define GL_COLOR_ARRAY_EXT                0x8076
#define GL_INDEX_ARRAY_EXT                0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
#define GL_DOUBLE_EXT                     GL_DOUBLE

/* EXT_bgra */
#define GL_BGR_EXT                        0x80E0
#define GL_BGRA_EXT                       0x80E1

/* EXT_paletted_texture */

/* These must match the GL_COLOR_TABLE_*_SGI enumerants */
#define GL_COLOR_TABLE_FORMAT_EXT         0x80D8
#define GL_COLOR_TABLE_WIDTH_EXT          0x80D9
#define GL_COLOR_TABLE_RED_SIZE_EXT       0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_EXT     0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_EXT      0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_EXT     0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF

#define GL_COLOR_INDEX1_EXT               0x80E2
#define GL_COLOR_INDEX2_EXT               0x80E3
#define GL_COLOR_INDEX4_EXT               0x80E4
#define GL_COLOR_INDEX8_EXT               0x80E5
#define GL_COLOR_INDEX12_EXT              0x80E6
#define GL_COLOR_INDEX16_EXT              0x80E7

/* WIN_draw_range_elements */
#define GL_MAX_ELEMENTS_VERTICES_WIN      0x80E8
#define GL_MAX_ELEMENTS_INDICES_WIN       0x80E9

/* WIN_phong_shading */
#define GL_PHONG_WIN                      0x80EA 
#define GL_PHONG_HINT_WIN                 0x80EB 

/* WIN_specular_fog */
#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/*************************************************************/

WINGDIAPI void APIENTRY glAccum (GLenum op, GLfloat value);
WINGDIAPI void APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
WINGDIAPI GLboolean APIENTRY glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
WINGDIAPI void APIENTRY glArrayElement (GLint i);
WINGDIAPI void APIENTRY glBegin (GLenum mode);
WINGDIAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
WINGDIAPI void APIENTRY glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
WINGDIAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
WINGDIAPI void APIENTRY glCallList (GLuint list);
WINGDIAPI void APIENTRY glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
WINGDIAPI void APIENTRY glClear (GLbitfield mask);
WINGDIAPI void APIENTRY glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
WINGDIAPI void APIENTRY glClearDepth (GLclampd depth);
WINGDIAPI void APIENTRY glClearIndex (GLfloat c);
WINGDIAPI void APIENTRY glClearStencil (GLint s);
WINGDIAPI void APIENTRY glClipPlane (GLenum plane, const GLdouble *equation);
WINGDIAPI void APIENTRY glColor3b (GLbyte red, GLbyte green, GLbyte blue);
WINGDIAPI void APIENTRY glColor3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor3d (GLdouble red, GLdouble green, GLdouble blue);
WINGDIAPI void APIENTRY glColor3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue);
WINGDIAPI void APIENTRY glColor3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor3i (GLint red, GLint green, GLint blue);
WINGDIAPI void APIENTRY glColor3iv (const GLint *v);
WINGDIAPI void APIENTRY glColor3s (GLshort red, GLshort green, GLshort blue);
WINGDIAPI void APIENTRY glColor3sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
WINGDIAPI void APIENTRY glColor3ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor3ui (GLuint red, GLuint green, GLuint blue);
WINGDIAPI void APIENTRY glColor3uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor3us (GLushort red, GLushort green, GLushort blue);
WINGDIAPI void APIENTRY glColor3usv (const GLushort *v);
WINGDIAPI void APIENTRY glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
WINGDIAPI void APIENTRY glColor4bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
WINGDIAPI void APIENTRY glColor4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glColor4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
WINGDIAPI void APIENTRY glColor4iv (const GLint *v);
WINGDIAPI void APIENTRY glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
WINGDIAPI void APIENTRY glColor4sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
WINGDIAPI void APIENTRY glColor4ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
WINGDIAPI void APIENTRY glColor4uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
WINGDIAPI void APIENTRY glColor4usv (const GLushort *v);
WINGDIAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
WINGDIAPI void APIENTRY glColorMaterial (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
WINGDIAPI void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
WINGDIAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
WINGDIAPI void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
WINGDIAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glCullFace (GLenum mode);
WINGDIAPI void APIENTRY glDeleteLists (GLuint list, GLsizei range);
WINGDIAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
WINGDIAPI void APIENTRY glDepthFunc (GLenum func);
WINGDIAPI void APIENTRY glDepthMask (GLboolean flag);
WINGDIAPI void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar);
WINGDIAPI void APIENTRY glDisable (GLenum cap);
WINGDIAPI void APIENTRY glDisableClientState (GLenum array);
WINGDIAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
WINGDIAPI void APIENTRY glDrawBuffer (GLenum mode);
WINGDIAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
WINGDIAPI void APIENTRY glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glEdgeFlag (GLboolean flag);
WINGDIAPI void APIENTRY glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glEdgeFlagv (const GLboolean *flag);
WINGDIAPI void APIENTRY glEnable (GLenum cap);
WINGDIAPI void APIENTRY glEnableClientState (GLenum array);
WINGDIAPI void APIENTRY glEnd (void);
WINGDIAPI void APIENTRY glEndList (void);
WINGDIAPI void APIENTRY glEvalCoord1d (GLdouble u);
WINGDIAPI void APIENTRY glEvalCoord1dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord1f (GLfloat u);
WINGDIAPI void APIENTRY glEvalCoord1fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalCoord2d (GLdouble u, GLdouble v);
WINGDIAPI void APIENTRY glEvalCoord2dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord2f (GLfloat u, GLfloat v);
WINGDIAPI void APIENTRY glEvalCoord2fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
WINGDIAPI void APIENTRY glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
WINGDIAPI void APIENTRY glEvalPoint1 (GLint i);
WINGDIAPI void APIENTRY glEvalPoint2 (GLint i, GLint j);
WINGDIAPI void APIENTRY glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
WINGDIAPI void APIENTRY glFinish (void);
WINGDIAPI void APIENTRY glFlush (void);
WINGDIAPI void APIENTRY glFogf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glFogfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glFogi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glFogiv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glFrontFace (GLenum mode);
WINGDIAPI void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI GLuint APIENTRY glGenLists (GLsizei range);
WINGDIAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
WINGDIAPI void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
WINGDIAPI void APIENTRY glGetClipPlane (GLenum plane, GLdouble *equation);
WINGDIAPI void APIENTRY glGetDoublev (GLenum pname, GLdouble *params);
WINGDIAPI GLenum APIENTRY glGetError (void);
WINGDIAPI void APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetLightiv (GLenum light, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetMapdv (GLenum target, GLenum query, GLdouble *v);
WINGDIAPI void APIENTRY glGetMapfv (GLenum target, GLenum query, GLfloat *v);
WINGDIAPI void APIENTRY glGetMapiv (GLenum target, GLenum query, GLint *v);
WINGDIAPI void APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetPixelMapfv (GLenum map, GLfloat *values);
WINGDIAPI void APIENTRY glGetPixelMapuiv (GLenum map, GLuint *values);
WINGDIAPI void APIENTRY glGetPixelMapusv (GLenum map, GLushort *values);
WINGDIAPI void APIENTRY glGetPointerv (GLenum pname, GLvoid* *params);
WINGDIAPI void APIENTRY glGetPolygonStipple (GLubyte *mask);
WINGDIAPI const GLubyte * APIENTRY glGetString (GLenum name);
WINGDIAPI void APIENTRY glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
WINGDIAPI void APIENTRY glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glHint (GLenum target, GLenum mode);
WINGDIAPI void APIENTRY glIndexMask (GLuint mask);
WINGDIAPI void APIENTRY glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glIndexd (GLdouble c);
WINGDIAPI void APIENTRY glIndexdv (const GLdouble *c);
WINGDIAPI void APIENTRY glIndexf (GLfloat c);
WINGDIAPI void APIENTRY glIndexfv (const GLfloat *c);
WINGDIAPI void APIENTRY glIndexi (GLint c);
WINGDIAPI void APIENTRY glIndexiv (const GLint *c);
WINGDIAPI void APIENTRY glIndexs (GLshort c);
WINGDIAPI void APIENTRY glIndexsv (const GLshort *c);
WINGDIAPI void APIENTRY glIndexub (GLubyte c);
WINGDIAPI void APIENTRY glIndexubv (const GLubyte *c);
WINGDIAPI void APIENTRY glInitNames (void);
WINGDIAPI void APIENTRY glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
WINGDIAPI GLboolean APIENTRY glIsEnabled (GLenum cap);
WINGDIAPI GLboolean APIENTRY glIsList (GLuint list);
WINGDIAPI GLboolean APIENTRY glIsTexture (GLuint texture);
WINGDIAPI void APIENTRY glLightModelf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLightModeli (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightModeliv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLighti (GLenum light, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightiv (GLenum light, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLineStipple (GLint factor, GLushort pattern);
WINGDIAPI void APIENTRY glLineWidth (GLfloat width);
WINGDIAPI void APIENTRY glListBase (GLuint base);
WINGDIAPI void APIENTRY glLoadIdentity (void);
WINGDIAPI void APIENTRY glLoadMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glLoadMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glLoadName (GLuint name);
WINGDIAPI void APIENTRY glLogicOp (GLenum opcode);
WINGDIAPI void APIENTRY glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
WINGDIAPI void APIENTRY glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
WINGDIAPI void APIENTRY glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
WINGDIAPI void APIENTRY glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
WINGDIAPI void APIENTRY glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
WINGDIAPI void APIENTRY glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
WINGDIAPI void APIENTRY glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
WINGDIAPI void APIENTRY glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
WINGDIAPI void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glMateriali (GLenum face, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glMaterialiv (GLenum face, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glMatrixMode (GLenum mode);
WINGDIAPI void APIENTRY glMultMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glMultMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glNewList (GLuint list, GLenum mode);
WINGDIAPI void APIENTRY glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
WINGDIAPI void APIENTRY glNormal3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
WINGDIAPI void APIENTRY glNormal3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
WINGDIAPI void APIENTRY glNormal3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glNormal3i (GLint nx, GLint ny, GLint nz);
WINGDIAPI void APIENTRY glNormal3iv (const GLint *v);
WINGDIAPI void APIENTRY glNormal3s (GLshort nx, GLshort ny, GLshort nz);
WINGDIAPI void APIENTRY glNormal3sv (const GLshort *v);
WINGDIAPI void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI void APIENTRY glPassThrough (GLfloat token);
WINGDIAPI void APIENTRY glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
WINGDIAPI void APIENTRY glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
WINGDIAPI void APIENTRY glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
WINGDIAPI void APIENTRY glPixelStoref (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelTransferf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelTransferi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelZoom (GLfloat xfactor, GLfloat yfactor);
WINGDIAPI void APIENTRY glPointSize (GLfloat size);
WINGDIAPI void APIENTRY glPolygonMode (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
WINGDIAPI void APIENTRY glPolygonStipple (const GLubyte *mask);
WINGDIAPI void APIENTRY glPopAttrib (void);
WINGDIAPI void APIENTRY glPopClientAttrib (void);
WINGDIAPI void APIENTRY glPopMatrix (void);
WINGDIAPI void APIENTRY glPopName (void);
WINGDIAPI void APIENTRY glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
WINGDIAPI void APIENTRY glPushAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushClientAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushMatrix (void);
WINGDIAPI void APIENTRY glPushName (GLuint name);
WINGDIAPI void APIENTRY glRasterPos2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glRasterPos2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glRasterPos2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glRasterPos2iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glRasterPos2sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRasterPos3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glRasterPos3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glRasterPos3iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glRasterPos3sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glRasterPos4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glRasterPos4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glRasterPos4iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glRasterPos4sv (const GLshort *v);
WINGDIAPI void APIENTRY glReadBuffer (GLenum mode);
WINGDIAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
WINGDIAPI void APIENTRY glRectdv (const GLdouble *v1, const GLdouble *v2);
WINGDIAPI void APIENTRY glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
WINGDIAPI void APIENTRY glRectfv (const GLfloat *v1, const GLfloat *v2);
WINGDIAPI void APIENTRY glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
WINGDIAPI void APIENTRY glRectiv (const GLint *v1, const GLint *v2);
WINGDIAPI void APIENTRY glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
WINGDIAPI void APIENTRY glRectsv (const GLshort *v1, const GLshort *v2);
WINGDIAPI GLint APIENTRY glRenderMode (GLenum mode);
WINGDIAPI void APIENTRY glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScaled (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glSelectBuffer (GLsizei size, GLuint *buffer);
WINGDIAPI void APIENTRY glShadeModel (GLenum mode);
WINGDIAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
WINGDIAPI void APIENTRY glStencilMask (GLuint mask);
WINGDIAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
WINGDIAPI void APIENTRY glTexCoord1d (GLdouble s);
WINGDIAPI void APIENTRY glTexCoord1dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord1f (GLfloat s);
WINGDIAPI void APIENTRY glTexCoord1fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord1i (GLint s);
WINGDIAPI void APIENTRY glTexCoord1iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord1s (GLshort s);
WINGDIAPI void APIENTRY glTexCoord1sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord2d (GLdouble s, GLdouble t);
WINGDIAPI void APIENTRY glTexCoord2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord2f (GLfloat s, GLfloat t);
WINGDIAPI void APIENTRY glTexCoord2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord2i (GLint s, GLint t);
WINGDIAPI void APIENTRY glTexCoord2iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord2s (GLshort s, GLshort t);
WINGDIAPI void APIENTRY glTexCoord2sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
WINGDIAPI void APIENTRY glTexCoord3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
WINGDIAPI void APIENTRY glTexCoord3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord3i (GLint s, GLint t, GLint r);
WINGDIAPI void APIENTRY glTexCoord3iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord3s (GLshort s, GLshort t, GLshort r);
WINGDIAPI void APIENTRY glTexCoord3sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
WINGDIAPI void APIENTRY glTexCoord4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
WINGDIAPI void APIENTRY glTexCoord4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
WINGDIAPI void APIENTRY glTexCoord4iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
WINGDIAPI void APIENTRY glTexCoord4sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexGend (GLenum coord, GLenum pname, GLdouble param);
WINGDIAPI void APIENTRY glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
WINGDIAPI void APIENTRY glTexGenf (GLenum coord, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexGeni (GLenum coord, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTranslated (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glVertex2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glVertex2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glVertex2iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glVertex2sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glVertex3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glVertex3iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glVertex3sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glVertex4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glVertex4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glVertex4iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glVertex4sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_vertex_array */
typedef void (APIENTRY * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (APIENTRY * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (APIENTRY * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (APIENTRY * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (APIENTRY * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);

/* WIN_draw_range_elements */
typedef void (APIENTRY * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

/* WIN_swap_hint */
typedef void (APIENTRY * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_paletted_texture */
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);

#ifdef __cplusplus
}
#endif

#endif /* __GL_H__ */
#endif /* __gl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\appauto.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// appauto.h

// Declaration of dual interfaces to objects found in the type library
//  VISUAL STUDIO 97 SHARED OBJECTS (SharedIDE\bin\devshl.dll)

#ifndef __APPAUTO_H_
#define __APPAUTO_H_

#include "appdefs.h"

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/////////////////////////////////////////////////////////////////////////////
// Interfaces declared in this file:

interface IApplication;
interface IApplicationEvents;

interface IGenericDocument;
interface IDocuments;

interface IGenericWindow;
interface IWindows;

interface IGenericProject;
interface IProjects;


/////////////////////////////////////////////////////////////////////////////
// Application object

// IApplication interface

#undef INTERFACE
#define INTERFACE IApplication

DECLARE_INTERFACE_(IApplication, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplication methods */
    STDMETHOD(get_Height)(THIS_ long FAR* Height) PURE;
    STDMETHOD(put_Height)(THIS_ long Height) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* Width) PURE;
    STDMETHOD(put_Width)(THIS_ long Width) PURE;
    STDMETHOD(get_Top)(THIS_ long FAR* Top) PURE;
    STDMETHOD(put_Top)(THIS_ long Top) PURE;
    STDMETHOD(get_Left)(THIS_ long FAR* Left) PURE;
    STDMETHOD(put_Left)(THIS_ long Left) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_TextEditor)(THIS_ IDispatch * FAR* texteditor) PURE;
    STDMETHOD(get_Version)(THIS_ BSTR FAR* Version) PURE;
    STDMETHOD(get_Path)(THIS_ BSTR FAR* Path) PURE;
    STDMETHOD(get_CurrentDirectory)(THIS_ BSTR FAR* CurrentDirectory) PURE;
    STDMETHOD(put_CurrentDirectory)(THIS_ BSTR CurrentDirectory) PURE;
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* FullName) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_ActiveDocument)(THIS_ IDispatch * FAR* ActiveDocument) PURE;
    STDMETHOD(get_Windows)(THIS_ IDispatch * FAR* Windows) PURE;
    STDMETHOD(get_Documents)(THIS_ IDispatch * FAR* Documents) PURE;
    STDMETHOD(get_ActiveWindow)(THIS_ IDispatch * FAR* ActiveWindow) PURE;
    STDMETHOD(get_WindowState)(THIS_ DsWindowState FAR* windowstate) PURE;
    STDMETHOD(put_WindowState)(THIS_ DsWindowState windowstate) PURE;
    STDMETHOD(get_Debugger)(THIS_ IDispatch * FAR* ppDebugger) PURE;
    STDMETHOD(get_Projects)(THIS_ IDispatch * FAR* Projects) PURE;
    STDMETHOD(get_ActiveConfiguration)(THIS_ IDispatch * FAR* ActiveConfiguration) PURE;
    STDMETHOD(put_ActiveConfiguration)(THIS_ IDispatch * ActiveConfiguration) PURE;
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* Visible) PURE;
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Visible) PURE;
    STDMETHOD(get_ActiveProject)(THIS_ IDispatch * FAR* ActiveProject) PURE;
    STDMETHOD(put_ActiveProject)(THIS_ IDispatch * ActiveProject) PURE;
    STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) PURE;
    STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) PURE;
    STDMETHOD(GetPackageExtension)(THIS_ BSTR szExtensionName, IDispatch * FAR* pExt) PURE;
    STDMETHOD(Quit)(THIS) PURE;
    STDMETHOD(PrintToOutputWindow)(THIS_ BSTR Message) PURE;
    STDMETHOD(ExecuteCommand)(THIS_ BSTR szCommandName) PURE;
    STDMETHOD(AddCommandBarButton)(THIS_ long nButtonType, BSTR szCmdName, long dwCookie) PURE;
    STDMETHOD(AddKeyBinding)(THIS_ BSTR szKey, BSTR szCommandName, BSTR szEditor) PURE;
    STDMETHOD(Build)(THIS_ VARIANT Configuration) PURE;
    STDMETHOD(RebuildAll)(THIS_ VARIANT configuration) PURE;
    STDMETHOD(ExecuteConfiguration)(THIS_ VARIANT Reserved) PURE;
    STDMETHOD(SetAddInInfo)(THIS_ long nInstanceHandle, IDispatch * pCmdDispatch, long nIDBitmapResourceMedium, long nIDBitmapResourceLarge, long dwCookie) PURE;
    STDMETHOD(AddCommand)(THIS_ BSTR szCmdName, BSTR szMethodName, long nBitmapOffset, long dwCookie, VARIANT_BOOL FAR* pbResult) PURE;
    STDMETHOD(EnableModeless)(THIS_ VARIANT_BOOL bEnable) PURE;
};

// IApplicationEvents interface

#undef INTERFACE
#define INTERFACE IApplicationEvents

DECLARE_INTERFACE_(IApplicationEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationEvents methods */
    STDMETHOD(BeforeBuildStart)(THIS) PURE;
    STDMETHOD(BuildFinish)(THIS_ long nNumErrors, long nNumWarnings) PURE;
    STDMETHOD(BeforeApplicationShutDown)(THIS) PURE;
    STDMETHOD(DocumentOpen)(THIS_ IDispatch * theDocument) PURE;
    STDMETHOD(BeforeDocumentClose)(THIS_ IDispatch * theDocument) PURE;
    STDMETHOD(DocumentSave)(THIS_ IDispatch * theDocument) PURE;
    STDMETHOD(NewDocument)(THIS_ IDispatch * theDocument) PURE;
    STDMETHOD(WindowActivate)(THIS_ IDispatch * theWindow) PURE;
    STDMETHOD(WindowDeactivate)(THIS_ IDispatch * theWindow) PURE;
    STDMETHOD(WorkspaceOpen)(THIS) PURE;
    STDMETHOD(WorkspaceClose)(THIS) PURE;
    STDMETHOD(NewWorkspace)(THIS) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Document object

// IGenericDocument interface

#undef INTERFACE
#ifndef __IGenericDocument_INTERFACE_DEFINED__
#define __IGenericDocument_INTERFACE_DEFINED__
#define INTERFACE IGenericDocument

DECLARE_INTERFACE_(IGenericDocument, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IGenericDocument methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pPath) PURE;
    STDMETHOD(get_Saved)(THIS_ VARIANT_BOOL FAR* pSaved) PURE;
    STDMETHOD(get_ActiveWindow)(THIS_ IDispatch * FAR* ppWindow) PURE;
    STDMETHOD(get_ReadOnly)(THIS_ VARIANT_BOOL FAR* pReadOnly) PURE;
    STDMETHOD(put_ReadOnly)(THIS_ VARIANT_BOOL ReadOnly) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pType) PURE;
    STDMETHOD(get_Windows)(THIS_ IDispatch * FAR* ppWindows) PURE;
	STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) PURE;
	STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) PURE;
    STDMETHOD(NewWindow)(THIS_ IDispatch * FAR* ppWindow) PURE;
    STDMETHOD(Save)(THIS_ VARIANT vFilename, VARIANT vBoolPrompt, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Undo)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(Redo)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(PrintOut)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(Close)(THIS_ VARIANT vSaveChanges, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
};

#endif // __IGenericDocument_INTERFACE_DEFINED__


/////////////////////////////////////////////////////////////////////////////
// Documents collection object

// IDocuments interface

#undef INTERFACE
#define INTERFACE IDocuments

DECLARE_INTERFACE_(IDocuments, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IDocuments methods */
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item) PURE;
    STDMETHOD(SaveAll)(THIS_ VARIANT vtBoolPrompt, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(CloseAll)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Add)(THIS_ BSTR docType, VARIANT vtReserved, IDispatch * FAR* ppDocument) PURE;
    STDMETHOD(Open)(THIS_ BSTR filename, VARIANT vtDocType, VARIANT vtBoolReadOnly, IDispatch * FAR* ppDocument) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Window object

// IGenericWindow interface

#undef INTERFACE
#ifndef __IGenericWindow_INTERFACE_DEFINED__
#define __IGenericWindow_INTERFACE_DEFINED__
#define INTERFACE IGenericWindow

DECLARE_INTERFACE_(IGenericWindow, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IGenericWindow methods */
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) PURE;
    STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) PURE;
    STDMETHOD(put_Left)(THIS_ long lVal) PURE;
    STDMETHOD(get_Left)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Top)(THIS_ long lVal) PURE;
    STDMETHOD(get_Top)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Height)(THIS_ long lVal) PURE;
    STDMETHOD(get_Height)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Width)(THIS_ long lVal) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(get_Index)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(get_Next)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Previous)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(put_WindowState)(THIS_ DsWindowState lVal) PURE;
    STDMETHOD(get_WindowState)(THIS_ DsWindowState FAR* plVal) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(Close)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
};

#endif // __IGenericWindow_INTERFACE_DEFINED__


/////////////////////////////////////////////////////////////////////////////
// Windows collection object

// IWindows interface

#undef INTERFACE
#define INTERFACE IWindows

DECLARE_INTERFACE_(IWindows, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWindows methods */
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item) PURE;
    STDMETHOD(Arrange)(THIS_ VARIANT vtArrangeStyle) PURE;
    STDMETHOD(CloseAll)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Project object

// IGenericProject interface

#undef INTERFACE
#ifndef __IGenericProject_INTERFACE_DEFINED__
#define __IGenericProject_INTERFACE_DEFINED__
#define INTERFACE IGenericProject

DECLARE_INTERFACE_(IGenericProject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IGenericProject methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* Name) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pType) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
};

#endif // __IGenericProject_INTERFACE_DEFINED__


/////////////////////////////////////////////////////////////////////////
// Projects collection object

// IProjects interface

DECLARE_INTERFACE_(IProjects, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IProjects methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT Index, IGenericProject FAR* FAR* Item) PURE;
};

#endif //__APPAUTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\addsect\addsect.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//
//  Copyright (C) Microsoft Corporation, 1996-2001.
//
//  File:       addsect.cpp
//
//  Contents:   Add a data section to a PE binary.
//
//  History:    01-Nov-2000     GalenH      Created from Detours setdll.cpp.
//
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define arrayof(a)      (sizeof(a)/sizeof(a[0]))

///////////////////////////////////////////////////////////////////////////////
//
class CImage
{
  public:
    CImage();
    ~CImage();

  public:                                                   // File Functions
    BOOL                    Read(HANDLE hFile);
    BOOL                    Check(PCSTR pszSection);
    BOOL                    Write(HANDLE hFile, PBYTE pbData, UINT cbData,
                                  PCSTR pszSection);
    BOOL                    Close();

  public:                                                   // Manipulation Functions
    PBYTE                   DataSet(PBYTE pbData, DWORD cbData);

  protected:
    BOOL                    CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData);
    BOOL                    ZeroFileData(HANDLE hFile, DWORD cbData);
    BOOL                    AlignFileData(HANDLE hFile);

    BOOL                    SizeOutputBuffer(DWORD cbData);
    PBYTE                   AllocateOutput(DWORD cbData, DWORD *pnVirtAddr);

    PVOID                   RvaToVa(DWORD nRva);
    DWORD                   RvaToFileOffset(DWORD nRva);

    DWORD                   FileAlign(DWORD nAddr);
    DWORD                   SectionAlign(DWORD nAddr);

  private:
    HANDLE                  m_hMap;                     // Read & Write
    PBYTE                   m_pMap;                     // Read & Write

    DWORD                   m_nNextFileAddr;            // Write
    DWORD                   m_nNextVirtAddr;            // Write

    BOOLEAN                 m_f64bit;

    IMAGE_FILE_HEADER       m_FileHeader;
    IMAGE_OPTIONAL_HEADER64 m_OptionalHeader;
    IMAGE_SECTION_HEADER    m_SectionHeaders[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

    DWORD                   m_nFileHeaderOffset;
    DWORD                   m_nOptionalHeaderOffset;
    DWORD                   m_nSectionsOffset;
    DWORD                   m_nSectionsEndOffset;
    DWORD                   m_nSectionsMaxCount;
    DWORD                   m_nExtraOffset;
    DWORD                   m_nFileSize;

    PBYTE                   m_pbOutputBuffer;
    DWORD                   m_cbOutputBuffer;

    DWORD                   m_nOutputVirtAddr;
    DWORD                   m_nOutputVirtSize;
    DWORD                   m_nOutputFileAddr;
};

//////////////////////////////////////////////////////////////////////////////
//
static inline DWORD Max(DWORD a, DWORD b)
{
    return a > b ? a : b;
}

static inline DWORD Min(DWORD a, DWORD b)
{
    return a < b ? a : b;
}

static inline DWORD Align(DWORD a, DWORD size)
{
    size--;
    return (a + size) & ~size;
}

static inline DWORD QuadAlign(DWORD a)
{
    return Align(a, 8);
}

//////////////////////////////////////////////////////////////////////////////
//
CImage::CImage()
{
    m_hMap = NULL;
    m_pMap = NULL;

    m_nFileHeaderOffset = 0;
    m_nSectionsOffset = 0;

    m_pbOutputBuffer = NULL;
    m_cbOutputBuffer = 0;
}

CImage::~CImage()
{
    Close();
}

BOOL CImage::Close()
{
    if (m_pMap != NULL) {
        UnmapViewOfFile(m_pMap);
        m_pMap = NULL;
    }

    if (m_hMap) {
        CloseHandle(m_hMap);
        m_hMap = NULL;
    }

    if (m_pbOutputBuffer) {
        delete[] m_pbOutputBuffer;
        m_pbOutputBuffer = NULL;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::SizeOutputBuffer(DWORD cbData)
{
    if (m_cbOutputBuffer < cbData) {
        if (cbData < 1024)  //65536
            cbData = 1024;
        cbData = FileAlign(cbData);

        PBYTE pOutput = new BYTE [cbData];
        if (pOutput == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        if (m_pbOutputBuffer) {
            CopyMemory(pOutput, m_pbOutputBuffer, m_cbOutputBuffer);

            delete[] m_pbOutputBuffer;
            m_pbOutputBuffer = NULL;
        }

        ZeroMemory(pOutput + m_cbOutputBuffer, cbData - m_cbOutputBuffer),

        m_pbOutputBuffer = pOutput;
        m_cbOutputBuffer = cbData;
    }
    return TRUE;
}

PBYTE CImage::AllocateOutput(DWORD cbData, DWORD *pnVirtAddr)
{
    cbData = QuadAlign(cbData);

    PBYTE pbData = m_pbOutputBuffer + m_nOutputVirtSize;

    *pnVirtAddr = m_nOutputVirtAddr + m_nOutputVirtSize;
    m_nOutputVirtSize += cbData;

    if (m_nOutputVirtSize > m_cbOutputBuffer) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    ZeroMemory(pbData, cbData);

    return pbData;
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD CImage::FileAlign(DWORD nAddr)
{
    return Align(nAddr, m_OptionalHeader.FileAlignment);
}

DWORD CImage::SectionAlign(DWORD nAddr)
{
    return Align(nAddr, m_OptionalHeader.SectionAlignment);
}

//////////////////////////////////////////////////////////////////////////////
//
PVOID CImage::RvaToVa(DWORD nRva)
{
    if (nRva == 0) {
        return NULL;
    }

    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return (PBYTE)m_pMap
                + m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return NULL;
}

DWORD CImage::RvaToFileOffset(DWORD nRva)
{
    DWORD n;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData)
{
    DWORD cbDone = 0;
    return WriteFile(hFile, m_pMap + nOldPos, cbData, &cbDone, NULL);
}

BOOL CImage::ZeroFileData(HANDLE hFile, DWORD cbData)
{
    if (!SizeOutputBuffer(4096)) {
        return FALSE;
    }

    ZeroMemory(m_pbOutputBuffer, m_cbOutputBuffer);

    for (DWORD cbLeft = cbData; cbLeft > 0;) {
        DWORD cbStep = cbLeft > m_cbOutputBuffer ? m_cbOutputBuffer : cbLeft;
        DWORD cbDone = 0;

        if (!WriteFile(hFile, m_pbOutputBuffer, cbStep, &cbDone, NULL)) {
            return FALSE;
        }
        if (cbDone == 0)
            break;

        cbLeft -= cbDone;
    }
    return TRUE;
}

BOOL CImage::AlignFileData(HANDLE hFile)
{
    DWORD nLastFileAddr = m_nNextFileAddr;

    m_nNextFileAddr = FileAlign(m_nNextFileAddr);
    m_nNextVirtAddr = SectionAlign(m_nNextVirtAddr);

    if (hFile != INVALID_HANDLE_VALUE) {
        if (m_nNextFileAddr > nLastFileAddr) {
            if (SetFilePointer(hFile, nLastFileAddr, NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            return ZeroFileData(hFile, m_nNextFileAddr - nLastFileAddr);
        }
    }
    return TRUE;
}

BOOL CImage::Read(HANDLE hFile)
{
    DWORD n;
    IMAGE_OPTIONAL_HEADER32 oh32;

    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    ///////////////////////////////////////////////////////// Create mapping.
    //
    m_nFileSize = GetFileSize(hFile, NULL);
    if (m_nFileSize == ~0ul) {
        return FALSE;
    }

    m_hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMap == NULL) {
        return FALSE;
    }

    m_pMap = (PBYTE)MapViewOfFile(m_hMap, FILE_MAP_READ, 0, 0, 0);
    if (m_pMap == NULL) {
        return FALSE;
    }

    ////////////////////////////////////////////////////// Process DOS Header.
    //
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)m_pMap;
    if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
        m_nFileHeaderOffset = pDosHeader->e_lfanew + sizeof(DWORD);
        m_nOptionalHeaderOffset = m_nFileHeaderOffset + sizeof(m_FileHeader);

    }
    else {
        m_nFileHeaderOffset = 0;
        m_nOptionalHeaderOffset = m_nFileHeaderOffset + sizeof(m_FileHeader);
    }

    /////////////////////////////////////////////////////// Process PE Header.
    //
    CopyMemory(&m_FileHeader, m_pMap + m_nFileHeaderOffset, sizeof(m_FileHeader));
    if (m_FileHeader.SizeOfOptionalHeader == 0) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }

    ///////////////////////////////////////////////// Process Optional Header.
    //
    CopyMemory(&oh32, m_pMap + m_nOptionalHeaderOffset, sizeof(oh32));

    if (oh32.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        // Convert 32-bit optional header to internal 64-bit optional header
        m_f64bit = FALSE;

        ZeroMemory(&m_OptionalHeader, sizeof(m_OptionalHeader));
        m_OptionalHeader.Magic = oh32.Magic;
        m_OptionalHeader.MajorLinkerVersion = oh32.MajorLinkerVersion;
        m_OptionalHeader.MinorLinkerVersion = oh32.MinorLinkerVersion;
        m_OptionalHeader.SizeOfCode = oh32.SizeOfCode;
        m_OptionalHeader.SizeOfInitializedData = oh32.SizeOfInitializedData;
        m_OptionalHeader.SizeOfUninitializedData = oh32.SizeOfUninitializedData;
        m_OptionalHeader.AddressOfEntryPoint = oh32.AddressOfEntryPoint;
        m_OptionalHeader.BaseOfCode = oh32.BaseOfCode;
        m_OptionalHeader.ImageBase = oh32.ImageBase;
        m_OptionalHeader.SectionAlignment = oh32.SectionAlignment;
        m_OptionalHeader.FileAlignment = oh32.FileAlignment;
        m_OptionalHeader.MajorOperatingSystemVersion = oh32.MajorOperatingSystemVersion;
        m_OptionalHeader.MinorOperatingSystemVersion = oh32.MinorOperatingSystemVersion;
        m_OptionalHeader.MajorImageVersion = oh32.MajorImageVersion;
        m_OptionalHeader.MinorImageVersion = oh32.MinorImageVersion;
        m_OptionalHeader.MajorSubsystemVersion = oh32.MajorSubsystemVersion;
        m_OptionalHeader.MinorSubsystemVersion = oh32.MinorSubsystemVersion;
        m_OptionalHeader.Win32VersionValue = oh32.Win32VersionValue;
        m_OptionalHeader.SizeOfImage = oh32.SizeOfImage;
        m_OptionalHeader.SizeOfHeaders = oh32.SizeOfHeaders;
        m_OptionalHeader.CheckSum = oh32.CheckSum;
        m_OptionalHeader.Subsystem = oh32.Subsystem;
        m_OptionalHeader.DllCharacteristics = oh32.DllCharacteristics;
        m_OptionalHeader.SizeOfStackReserve = oh32.SizeOfStackReserve;
        m_OptionalHeader.SizeOfStackCommit = oh32.SizeOfStackCommit;
        m_OptionalHeader.SizeOfHeapReserve = oh32.SizeOfHeapReserve;
        m_OptionalHeader.SizeOfHeapCommit = oh32.SizeOfHeapCommit;
        m_OptionalHeader.LoaderFlags = oh32.LoaderFlags;
        m_OptionalHeader.NumberOfRvaAndSizes = oh32.NumberOfRvaAndSizes;

        for (n = 0; n < oh32.NumberOfRvaAndSizes; n++)
        {
            m_OptionalHeader.DataDirectory[n] = oh32.DataDirectory[n];
        }
    }
    else if (oh32.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        m_f64bit = TRUE;
        CopyMemory(&m_OptionalHeader,
                   m_pMap + m_nOptionalHeaderOffset, sizeof(m_OptionalHeader));
    }
    else
    {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    m_nSectionsOffset = m_nOptionalHeaderOffset + m_FileHeader.SizeOfOptionalHeader;

    ///////////////////////////////////////////////// Process Section Headers.
    //
    if (m_FileHeader.NumberOfSections > arrayof(m_SectionHeaders)) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    CopyMemory(&m_SectionHeaders,
               m_pMap + m_nSectionsOffset,
               sizeof(m_SectionHeaders[0]) * m_FileHeader.NumberOfSections);

    ////////////////////////////////////////////////////////// Parse Sections.
    //
    m_nSectionsEndOffset = m_nSectionsOffset + sizeof(m_SectionHeaders);
    m_nExtraOffset = 0;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        m_nExtraOffset = Max(m_SectionHeaders[n].PointerToRawData +
                             m_SectionHeaders[n].SizeOfRawData,
                             m_nExtraOffset);

        if (m_SectionHeaders[n].PointerToRawData != 0) {
            m_nSectionsEndOffset = Min(m_SectionHeaders[n].PointerToRawData,
                                       m_nSectionsEndOffset);
        }
    }

    m_nSectionsMaxCount = (m_nSectionsEndOffset - m_nSectionsOffset)
        / sizeof(IMAGE_SECTION_HEADER);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::Check(PCSTR pszSection)
{
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME];

    ZeroMemory(szName, sizeof(szName));
    strncpy(szName, pszSection, sizeof(szName));

    if ((DWORD)(m_FileHeader.NumberOfSections + 1) > m_nSectionsMaxCount) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }

    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (memcmp(szName, m_SectionHeaders[n].Name, sizeof(szName)) == 0)
        {
            SetLastError(ERROR_DUPLICATE_TAG);
            return FALSE;
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::Write(HANDLE hFile, PBYTE pbSectData, UINT cbSectData, PCSTR pszSection)
{
    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    m_nNextFileAddr = 0;
    m_nNextVirtAddr = 0;

    //////////////////////////////////////////////////////////// Copy Headers.
    //
    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!CopyFileData(hFile, 0, m_OptionalHeader.SizeOfHeaders)) {
        return FALSE;
    }

    m_nNextFileAddr = m_OptionalHeader.SizeOfHeaders;
    m_nNextVirtAddr = 0;
    if (!AlignFileData(hFile)) {
        return FALSE;
    }

    /////////////////////////////////////////////////////////// Copy Sections.
    //
    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].SizeOfRawData) {
            if (SetFilePointer(hFile,
                               m_SectionHeaders[n].PointerToRawData,
                               NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            if (!CopyFileData(hFile,
                              m_SectionHeaders[n].PointerToRawData,
                              m_SectionHeaders[n].SizeOfRawData)) {
                return FALSE;
            }
        }
        m_nNextFileAddr = Max(m_SectionHeaders[n].PointerToRawData +
                              m_SectionHeaders[n].SizeOfRawData,
                              m_nNextFileAddr);
        m_nNextVirtAddr = Max(m_SectionHeaders[n].VirtualAddress +
                              m_SectionHeaders[n].Misc.VirtualSize,
                              m_nNextVirtAddr);
        m_nExtraOffset = Max(m_nNextFileAddr, m_nExtraOffset);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }
    }

    /////////////////////////////////////////////////////////////// Old WriteSection
    DWORD cbDone;

    if (pbSectData) {

        /////////////////////////////////////////////////// Insert .detour Section.
        //
        DWORD nSection = m_FileHeader.NumberOfSections++;

        ZeroMemory(&m_SectionHeaders[nSection], sizeof(m_SectionHeaders[nSection]));

        strcpy((PCHAR)m_SectionHeaders[nSection].Name, pszSection);
        m_SectionHeaders[nSection].Characteristics
            = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

        m_nOutputVirtAddr = m_nNextVirtAddr;
        m_nOutputVirtSize = 0;
        m_nOutputFileAddr = m_nNextFileAddr;

        //////////////////////////////////////////////////////////////////////////
        //
        if (!SizeOutputBuffer(QuadAlign(cbSectData))) {
            return FALSE;
        }

        DWORD vaData = 0;
        PBYTE pbData = NULL;

        if ((pbData = AllocateOutput(cbSectData, &vaData)) == NULL) {
            return FALSE;
        }

        CopyMemory(pbData, pbSectData, cbSectData);

        //////////////////////////////////////////////////////////////////////////
        //
        m_nNextVirtAddr += m_nOutputVirtSize;
        m_nNextFileAddr += FileAlign(m_nOutputVirtSize);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }

        //////////////////////////////////////////////////////////////////////////
        //
        m_SectionHeaders[nSection].VirtualAddress = m_nOutputVirtAddr;
        m_SectionHeaders[nSection].Misc.VirtualSize = m_nOutputVirtSize;
        m_SectionHeaders[nSection].PointerToRawData = m_nOutputFileAddr;
        m_SectionHeaders[nSection].SizeOfRawData = FileAlign(m_nOutputVirtSize);

        m_OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
        m_OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

        //////////////////////////////////////////////////////////////////////////
        //
        if (SetFilePointer(hFile, m_SectionHeaders[nSection].PointerToRawData,
                           NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!WriteFile(hFile, pbData, m_SectionHeaders[nSection].SizeOfRawData,
                       &cbDone, NULL)) {
            return FALSE;
        }
    }

    ///////////////////////////////////////////////////// Adjust Extra Data.
    //
    LONG nExtraAdjust = m_nNextFileAddr - m_nExtraOffset;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].PointerToRawData > m_nExtraOffset)
            m_SectionHeaders[n].PointerToRawData += nExtraAdjust;
        if (m_SectionHeaders[n].PointerToRelocations > m_nExtraOffset)
            m_SectionHeaders[n].PointerToRelocations += nExtraAdjust;
        if (m_SectionHeaders[n].PointerToLinenumbers > m_nExtraOffset)
            m_SectionHeaders[n].PointerToLinenumbers += nExtraAdjust;
    }
    if (m_FileHeader.PointerToSymbolTable > m_nExtraOffset)
        m_FileHeader.PointerToSymbolTable += nExtraAdjust;

    m_OptionalHeader.CheckSum = 0;
    m_OptionalHeader.SizeOfImage = m_nNextVirtAddr;

    ////////////////////////////////////////////////// Adjust Debug Directory.
    //
    DWORD debugAddr = m_OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    DWORD debugSize = m_OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    if (debugAddr && debugSize) {
        DWORD nFileOffset = RvaToFileOffset(debugAddr);
        if (SetFilePointer(hFile, nFileOffset, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }

        PIMAGE_DEBUG_DIRECTORY pDir = (PIMAGE_DEBUG_DIRECTORY)RvaToVa(debugAddr);
        if (pDir == NULL) {
            return FALSE;
        }

        DWORD nEntries = debugSize / sizeof(*pDir);
        for (DWORD n = 0; n < nEntries; n++) {
            IMAGE_DEBUG_DIRECTORY dir = pDir[n];

            if (dir.PointerToRawData > m_nExtraOffset) {
                dir.PointerToRawData += nExtraAdjust;
            }
            if (!WriteFile(hFile, &dir, sizeof(dir), &cbDone, NULL)) {
                return FALSE;
            }
        }
    }

    ///////////////////////////////////////////////// Copy Left-over Data.
    //
    if (m_nFileSize > m_nExtraOffset) {
        if (SetFilePointer(hFile, m_nNextFileAddr, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!CopyFileData(hFile, m_nExtraOffset, m_nFileSize - m_nExtraOffset)) {
            return FALSE;
        }
    }

    //////////////////////////////////////////////////// Finalize Headers.
    //

    if (SetFilePointer(hFile, m_nFileHeaderOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_FileHeader, sizeof(m_FileHeader), &cbDone, NULL)) {
        return FALSE;
    }
    if (SetFilePointer(hFile, m_nOptionalHeaderOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (m_f64bit)
    {
        if (!WriteFile(hFile, &m_OptionalHeader, sizeof(m_OptionalHeader),
                       &cbDone, NULL)) {

            return FALSE;
        }
    }
    else
    {
        // Convert 32-bit optional header to internal 64-bit optional header
        IMAGE_OPTIONAL_HEADER32 oh32;

        ZeroMemory(&oh32, sizeof(oh32));
        oh32.Magic = m_OptionalHeader.Magic;
        oh32.MajorLinkerVersion = m_OptionalHeader.MajorLinkerVersion;
        oh32.MinorLinkerVersion = m_OptionalHeader.MinorLinkerVersion;
        oh32.SizeOfCode = m_OptionalHeader.SizeOfCode;
        oh32.SizeOfInitializedData = m_OptionalHeader.SizeOfInitializedData;
        oh32.SizeOfUninitializedData = m_OptionalHeader.SizeOfUninitializedData;
        oh32.AddressOfEntryPoint = m_OptionalHeader.AddressOfEntryPoint;
        oh32.BaseOfCode = m_OptionalHeader.BaseOfCode;
        oh32.ImageBase = (ULONG)m_OptionalHeader.ImageBase;
        oh32.SectionAlignment = m_OptionalHeader.SectionAlignment;
        oh32.FileAlignment = m_OptionalHeader.FileAlignment;
        oh32.MajorOperatingSystemVersion = m_OptionalHeader.MajorOperatingSystemVersion;
        oh32.MinorOperatingSystemVersion = m_OptionalHeader.MinorOperatingSystemVersion;
        oh32.MajorImageVersion = m_OptionalHeader.MajorImageVersion;
        oh32.MinorImageVersion = m_OptionalHeader.MinorImageVersion;
        oh32.MajorSubsystemVersion = m_OptionalHeader.MajorSubsystemVersion;
        oh32.MinorSubsystemVersion = m_OptionalHeader.MinorSubsystemVersion;
        oh32.Win32VersionValue = m_OptionalHeader.Win32VersionValue;
        oh32.SizeOfImage = m_OptionalHeader.SizeOfImage;
        oh32.SizeOfHeaders = m_OptionalHeader.SizeOfHeaders;
        oh32.CheckSum = m_OptionalHeader.CheckSum;
        oh32.Subsystem = m_OptionalHeader.Subsystem;
        oh32.DllCharacteristics = m_OptionalHeader.DllCharacteristics;
        oh32.SizeOfStackReserve = (ULONG)m_OptionalHeader.SizeOfStackReserve;
        oh32.SizeOfStackCommit = (ULONG)m_OptionalHeader.SizeOfStackCommit;
        oh32.SizeOfHeapReserve = (ULONG)m_OptionalHeader.SizeOfHeapReserve;
        oh32.SizeOfHeapCommit = (ULONG)m_OptionalHeader.SizeOfHeapCommit;
        oh32.LoaderFlags = m_OptionalHeader.LoaderFlags;
        oh32.NumberOfRvaAndSizes = m_OptionalHeader.NumberOfRvaAndSizes;

        for (int n = 0; n < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; n++)
        {
            oh32.DataDirectory[n] = m_OptionalHeader.DataDirectory[n];
        }

        if (!WriteFile(hFile, &oh32, sizeof(oh32), &cbDone, NULL)) {
            return FALSE;
        }
    }

    if (SetFilePointer(hFile, m_nSectionsOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_SectionHeaders,
                   sizeof(m_SectionHeaders[0])
                   * m_FileHeader.NumberOfSections,
                   &cbDone, NULL)) {
        return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////// CFileMap.
//
class CFileMap
{
  public:
    CFileMap();
    ~CFileMap();

  public:
    BOOL    Load(PCWSTR pszFile);
    PBYTE   Seek(UINT32 cbPos);
    UINT32  Size();
    VOID    Close();

  protected:
    PBYTE   m_pbData;
    UINT32  m_cbData;
};

CFileMap::CFileMap()
{
    m_pbData = NULL;
    m_cbData = 0;
}

CFileMap::~CFileMap()
{
    Close();
}

VOID CFileMap::Close()
{
    if (m_pbData) {
        UnmapViewOfFile(m_pbData);
        m_pbData = NULL;
    }
    m_cbData = 0;
}

UINT32 CFileMap::Size()
{
    return m_cbData;
}

PBYTE CFileMap::Seek(UINT32 cbPos)
{
    if (m_pbData && cbPos <= m_cbData) {
        return m_pbData + cbPos;
    }
    return NULL;
}

BOOL CFileMap::Load(PCWSTR pszFile)
{
    Close();

    HANDLE hFile = CreateFile(pszFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ULONG cbInFileData = GetFileSize(hFile, NULL);
    if (cbInFileData == ~0ul) {
        CloseHandle(hFile);
        return FALSE;
    }

    HANDLE hInFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    CloseHandle(hFile);
    if (hInFileMap == NULL) {
        return FALSE;
    }

    m_pbData = (PBYTE)MapViewOfFile(hInFileMap, FILE_MAP_COPY, 0, 0, 0);
    CloseHandle(hInFileMap);
    if (m_pbData == NULL) {
        return FALSE;
    }
    m_cbData = cbInFileData;
    return TRUE;
}

BOOL addsect_files(PCWSTR pszOutput, PCWSTR pszInput, PCWSTR pszData, PCSTR pszSection)
{
    HANDLE hInput = INVALID_HANDLE_VALUE;
    HANDLE hOutput = INVALID_HANDLE_VALUE;
    BOOL bGood = TRUE;
    CFileMap cfData;
    CImage image;

    if (!cfData.Load(pszData)) {
        fprintf(stderr, "ADDSECT: Could not open input data file: %ls\n", pszData);
        goto end;
    }

    hInput = CreateFile(pszInput,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hInput == INVALID_HANDLE_VALUE) {
        printf("ADDSECT: Couldn't open input file: %ls, error: %d\n",
               pszInput, GetLastError());
        bGood = FALSE;
        goto end;
    }

    hOutput = CreateFile(pszOutput,
                         GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hOutput == INVALID_HANDLE_VALUE) {
        printf("ADDSECT: Couldn't open output file: %ls, error: %d\n",
               pszOutput, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Read(hInput)) {
        fprintf(stderr, "ADDSECT: Image read failed: %d\n", GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Check(pszSection)) {
        fprintf(stderr, "ADDSECT: Can't insert section `%hs' into image: %d\n",
                pszSection, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Write(hOutput, cfData.Seek(0), cfData.Size(), pszSection)) {
        fprintf(stderr, "ADDSECT: Image write failed: %d\n", GetLastError());
        bGood = FALSE;
    }

    image.Close();

    if (bGood)
    {
        printf("ADDSECT: Added new section `%hs' of %d bytes to `%ls'.\n",
               pszSection, cfData.Size(), pszOutput);
    }


  end:
    if (hOutput != INVALID_HANDLE_VALUE) {
        CloseHandle(hOutput);
        hOutput = INVALID_HANDLE_VALUE;
    }
    if (hInput != INVALID_HANDLE_VALUE) {
        CloseHandle(hInput);
        hInput = INVALID_HANDLE_VALUE;
    }
    if (!bGood)
    {
        DeleteFile(pszOutput);
    }

    return TRUE;
}

int __cdecl wmain(int argc, PWCHAR *argv)
{
    BOOL fNeedHelp = FALSE;
    PCWSTR pszData = NULL;
    PCWSTR pszInput = NULL;
    PCWSTR pszOutput = NULL;
    CHAR szSection[IMAGE_SIZEOF_SHORT_NAME + 1] = ".ramfs\0\0";

    for (int arg = 1; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            PWCHAR argn = argv[arg]+1;                   // Argument name
            PWCHAR argp = argn;                          // Argument parameter

            while (*argp && *argp != ':' && *argp != '=') {
                argp++;
            }
            if (*argp == ':' || *argp == '=')
                *argp++ = '\0';

            switch (argn[0]) {

              case 'd':                                 // Input file.
              case 'D':
                pszData = argp;
                break;

              case 'i':                                 // Input file.
              case 'I':
                pszInput = argp;
                break;

              case 'o':                                 // Output file.
              case 'O':
                pszOutput = argp;
                break;

              case 's':                                 // Section Name.
              case 'S':
                _snprintf(szSection, arrayof(szSection)-1, "%ls", argp);
                szSection[arrayof(szSection)-1] = '\0';
                break;

              case 'h':                                 // Help
              case 'H':
              case '?':
                fNeedHelp = TRUE;
                break;

              default:
                fprintf(stderr, "ADDSECT: Unknown argument: %ls\n", argv[arg]);
                fNeedHelp = TRUE;
                break;
            }
        }
    }

    if (pszInput == NULL) {
        fNeedHelp = TRUE;
    }

    if (pszOutput == NULL) {
        fNeedHelp = TRUE;
    }

    if (pszData == NULL) {
        fNeedHelp = TRUE;
    }

    if (argc == 1) {
        fNeedHelp = TRUE;
    }

    if (fNeedHelp) {
        printf(
               "Usage:\n"
               "    ADDSECT [options] /I:input /O:output /D:data\n"
               "Options:\n"
               "    /O:output     Specify output file.\n"
               "    /I:input      Specify input file.\n"
               "    /D:data       Specify data file.\n"
               "    /S:section    Symbol (defaults to .ramfs).\n"
               "    /H or /?      Display this help screen.\n"
               "Summary:\n"
               "    Adds a new section to a PE binary.\n"
               );
        return 1;
    }

    if (!addsect_files(pszOutput, pszInput, pszData, szSection))
    {
        return 2;
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\adduser\adduser.c ===
#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <string.h>

VOID AddUser(LPSTR, LPSTR);

VOID
__cdecl main(USHORT argc, PCHAR *argv)
{

    if (argc != 3) {
        printf("Usage: AddUser <username> <password>\n");
        return;
    }

    AddUser(argv[1], argv[2]);

    return;

}
VOID
AddUser(
    LPSTR UserName,
    LPSTR Password
    )
{

    HANDLE ServerHandle = NULL;
    HANDLE DomainHandle = NULL;
    HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    ACCESS_MASK ServerAccessMask, DomainAccessMask;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo = NULL;
    STRING AccountNameAnsi;
    STRING AnsiPassword;
    UNICODE_STRING AccountName;
    UNICODE_STRING UnicodePassword;
    USER_SET_PASSWORD_INFORMATION pi;
    ULONG UserRid;
    NTSTATUS NtStatus;
    USHORT ControlInformation = USER_NORMAL_ACCOUNT;


    //
    // Get the Account domain SID from LSA
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = LsaOpenPolicy(NULL,
                             &ObjectAttributes,
                             POLICY_ALL_ACCESS,
                             &LsaHandle);
    if (NtStatus == STATUS_ACCESS_DENIED) {
        printf("You must be logged on as admin to use this command\n");
        return;
    }
    else if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't open Lsa Policy database, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    NtStatus = LsaQueryInformationPolicy(LsaHandle,
                                         PolicyAccountDomainInformation,
                                         &PolicyAccountDomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't query Lsa Policy database, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Connect to SAM
    //

    ServerAccessMask = SAM_SERVER_ALL_ACCESS;
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't connect to SAM, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Open the account domain
    //

    DomainAccessMask = DOMAIN_ALL_ACCESS;
    NtStatus = SamOpenDomain(
                   ServerHandle,
                   DomainAccessMask,
                   PolicyAccountDomainInfo->DomainSid,
                   &DomainHandle
                   );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't open account domain, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Create the User
    //

    RtlInitString( &AccountNameAnsi, UserName );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi,
        TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("RtlAnsiStringToUnicodeString failed, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );
    if (NtStatus == STATUS_USER_EXISTS) {
        printf("User %s already exists\n", UserName);
        goto cleanupandexit;
    }
    else if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't create user, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Create the cleartext UNICODE password and write it out.
    //

    RtlInitString(&AnsiPassword, Password);
    NtStatus = RtlAnsiStringToUnicodeString( &UnicodePassword, &AnsiPassword,
        TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("RtlAnsiStringToUnicodeString failed, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    pi.Password = UnicodePassword;
    pi.PasswordExpired = FALSE;

    NtStatus = SamSetInformationUser(
                   UserHandle,
                   UserSetPasswordInformation,
                   &pi
                   );

    RtlFreeUnicodeString(&UnicodePassword);

    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't set password for user, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Now make the user account active
    //

    NtStatus = SamSetInformationUser(
                   UserHandle,
                   UserControlInformation,
                   &ControlInformation
                   );

    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't activate the user account, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

cleanupandexit:

    if (PolicyAccountDomainInfo) {
        LsaFreeMemory(PolicyAccountDomainInfo);
    }
    if (UserHandle) {
        NtClose(UserHandle);
    }
    if (DomainHandle) {
        NtClose(DomainHandle);
    }
    if (ServerHandle) {
        NtClose(ServerHandle);
    }
    if (LsaHandle) {
        NtClose(LsaHandle);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\actools\qshimapp\qshimapp.c ===
/***************************************************************************
* Quick shim application tools
*
* Author: clupu (Feb 16, 2000)
* 
\**************************************************************************/

#include "windows.h"
#include "commctrl.h"
#include "commdlg.h"
#include "resource.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include "shimWin2000.h"
#include "shimWhistler.h"

#include "..\acFileAttr\acFileAttr.h"

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

char      g_szBinary[MAX_PATH];         // the full path of the main binary being shimmed
char      g_szShortName[128];           // the short name of the main EXE
char*     g_pszShimDLL;

char      g_szBinaryOther[MAX_PATH];    // the full path of the optional EXE that will
                                        // be launched instead (setup case)

HWND      g_hwndShimTree;               // the handle to the tree view control
                                        // containing all the shims available

HWND      g_hwndFilesTree;              // the handle to the tree view control
                                        // containing the matching files selected

BOOL      g_bWin2k;                     // are we running on Win2k or Whistler

BOOL      g_bRunOther;                  // TRUE - run g_szBinaryOther instead 

BOOL      g_bSimpleEdition;             // simple or dev edition

RECT      g_rcDlgBig, g_rcDlgSmall;     // rectangle of the simple and the dev edition
                                        // of the dialog

#if DBG

/*********************************************************************
* LogMsgDbg
*
*********************************************************************/
void LogMsgDbg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

#endif // DBG

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

/*********************************************************************
* AddMatchingFile
*
*  Adds a matching file and it's attributes to the tree
*
*********************************************************************/
VOID
AddMatchingFile(
    HWND  hdlg,
    char* pszFullPath,
    char* pszRelativePath,
    BOOL  bMainEXE)
{
    HANDLE         hMgr;
    TVINSERTSTRUCT is;
    HTREEITEM      hParent;
    int            i;
    int            nAttrCount;
    char           szItem[256];
    
    hMgr = ReadFileAttributes(pszFullPath, &nAttrCount);

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.lParam  = (LONG)hMgr;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.pszText = pszRelativePath;

    hParent = TreeView_InsertItem(g_hwndFilesTree, &is);

    is.hParent = hParent;
    
    is.item.mask    = TVIF_TEXT;
    is.item.pszText = szItem;

    is.item.mask   |= TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.iImage  = 0;
    
    is.item.iSelectedImage = 1;
    is.item.state          = INDEXTOSTATEIMAGEMASK(1);
    is.item.stateMask      = TVIS_STATEIMAGEMASK;

    for (i = 0; i < nAttrCount; i++) {
        
        PSTR      pszValue;
        DWORD     id;
        HTREEITEM hItem;

        if (!IsAttrAvailable(hMgr, i))
            continue;
        
        // filter the attributes for Whistler (temporary)

        if (!g_bWin2k) {
            id = GetAttrId(i);
            if (id != VTID_FILESIZE && id != VTID_CHECKSUM)
                continue;
        }

        pszValue = GetAttrValue(hMgr, i);
        
        if (pszValue == NULL)
            continue;
        
        wsprintf(szItem, "%s: %s", GetAttrName(i), pszValue);
        
        is.item.lParam = i;
        hItem = TreeView_InsertItem(g_hwndFilesTree, &is);
    }

    TreeView_Expand(g_hwndFilesTree, hParent, TVE_EXPAND);
}

/*********************************************************************
* AddNewMainBinary
*
*  Start with a new main executable
*
*********************************************************************/
VOID
AddNewMainBinary(
    HWND hdlg)
{
    char szMainEXE[128];

    TreeView_DeleteAllItems(g_hwndFilesTree);

    wsprintf(szMainEXE, "Main executable (%s)", g_szShortName);

    AddMatchingFile(hdlg, g_szBinary, szMainEXE, TRUE);
}

/*********************************************************************
* DoBrowseForApp
*
*  Browse for the main executable for which a shim will be applied
*
*********************************************************************/
VOID
DoBrowseForApp(
    HWND hdlg)
{
	OPENFILENAME ofn;
    
    g_szBinary[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szBinary;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = g_szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose an executable binary to shim";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        
        SetDlgItemText(hdlg, IDC_BINARY, g_szBinary);

        EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), TRUE);
        AddNewMainBinary(hdlg);
    }
}

/*********************************************************************
* DoBrowseOther
*
*  Browse for a different EXE that will be launched instead of the
*  main EXE selected. This is for the setup case where setup.exe
*  launches another process _INS0432._MP for example.
*
*********************************************************************/
VOID
DoBrowseOther(
    HWND hdlg)
{
	OPENFILENAME ofn;
    
    g_szBinaryOther[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szBinaryOther;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose the application to run";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        SetDlgItemText(hdlg, IDC_RUN_OTHER, g_szBinaryOther);
    }
}

/*********************************************************************
* DoAddMatchingFile
*
*********************************************************************/
VOID
DoAddMatchingFile(
    HWND hdlg)
{
	char         szFullPath[MAX_PATH];
    char         szShortName[128];
    char         szRelativePath[MAX_PATH];
    OPENFILENAME ofn;
    
    szFullPath[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose the application to run";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        
        char* pszBin;
        char* pszNew;

        // need to modify the path to be a relative path to g_szBinary

        if (g_szBinary[0] != szFullPath[0]) {
            MessageBox(hdlg, "A matching file must be located on the same drive",
                       "Warning", MB_ICONEXCLAMATION | MB_OK);
            return;
        }

        // walk both strings untill they differ
        
        pszBin = g_szBinary;
        pszNew = szFullPath;

        szRelativePath[0] = 0;

        while (*pszBin == *pszNew) {
            pszBin++;
            pszNew++;
        }

        // go back to the last \
        
        while (*(pszBin - 1) != '\\') {
            pszBin--;
            pszNew--;
        }

        while (lstrcmp(pszBin, g_szShortName) != 0) {
            
            // add ..\ each time a subdir is identified (not the short name)
            
            lstrcat(szRelativePath, "..\\");

            while (*pszBin != '\\')
                pszBin++;
            
            pszBin++;
        }
        lstrcat(szRelativePath, pszNew);
        
        // finally add the maching file
        AddMatchingFile(hdlg, szFullPath, szRelativePath, FALSE);
    }
}

/*********************************************************************
* PopulateTree
*
*********************************************************************/
VOID
PopulateTree(
    HWND hTree)
{
    TVINSERTSTRUCT is;
    PFIX           pFix;

    TreeView_DeleteAllItems(hTree);

    if (g_bWin2k) {
        pFix = ReadFixes_Win2000();
        if (pFix == NULL) {
            MessageBox(NULL,
                       "You need to have a copy of the file Shim2000.txt"
                       " in the directory where you started QShimApp.exe",
                       "Error", MB_ICONEXCLAMATION | MB_OK);
            return;
        }
    } else {
        pFix = ReadFixes_Whistler();
        
        if (pFix == NULL) {
            MessageBox(NULL,
                       "The shim database doesn't exist or it is corrupted",
                       "Error", MB_ICONEXCLAMATION | MB_OK);
            return;
        }
    }

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_SORT;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    
    // walk the list and add all the fixes to the tree view

    while (pFix != NULL) {
        is.item.lParam  = (LPARAM)pFix;
        is.item.pszText = pFix->pszName;
    
        TreeView_InsertItem(hTree, &is);

        pFix = pFix->pNext;
    }
}

/*********************************************************************
* RunShimmedApp
*
*********************************************************************/
DWORD WINAPI
RunShimmedApp(
    LPVOID lParam)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    
    ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

    // Try to run the app
    
    if (!CreateProcess(NULL,
                  (g_bRunOther ? g_szBinaryOther : g_szBinary),
                  NULL,
                  NULL,
                  FALSE,
                  NORMAL_PRIORITY_CLASS,
                  NULL,
                  NULL,
                  &si,
                  &pi)) {
        
        LogMsg("CreateProcess failed with status: 0x%X\n", GetLastError());
        return 0;
    }
    
    CloseHandle(pi.hThread);
    
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    
    if (g_bWin2k) {
        CleanupShimForApp_Win2000();
    } else {
        CleanupShimForApp_Whistler();
    }

    return 1;
}

/*********************************************************************
* DoRunApp
*
*********************************************************************/
VOID
DoRunApp(
    HWND hdlg)
{
    HANDLE hThread;
    DWORD  dwThreadId;
    BOOL   bCreateFile;
    
    // Make sure an app was selected first

    if (g_szBinary[0] == 0) {
        MessageBox(hdlg,
                   "You need to select the application first",
                   "Error", MB_ICONEXCLAMATION | MB_OK);
        return;
    }
    
    // check to see if another app was selected to run
    
    if (SendDlgItemMessage(hdlg, IDC_RUN_OTHER_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        
        g_bRunOther = TRUE;
    
        // Make sure the other app is selected
        
        if (g_szBinaryOther[0] == 0) {
        
            GetDlgItemText(hdlg, IDC_RUN_OTHER, g_szBinaryOther, MAX_PATH);

            if (g_szBinaryOther[0] == 0) {
                MessageBox(hdlg,
                           "You need to select the other application first",
                           "Error", MB_ICONEXCLAMATION | MB_OK);
                return;
            }
        }
    } else {
        g_bRunOther = FALSE;
    }
    
    bCreateFile = (SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_GETCHECK, 0, 0) == BST_CHECKED);
    
    if (g_bWin2k) {
        if (!AddShimForApp_Win2000(g_hwndShimTree, g_hwndFilesTree, g_szShortName, bCreateFile)) {
            LogMsg("AddShimForApp_Win2000 failed...\n");
            return;
        }
    } else {
        if (!AddShimForApp_Whistler(g_hwndShimTree, g_hwndFilesTree, g_szShortName, bCreateFile)) {
            LogMsg("AddShimForApp_Whistler failed...\n");
            return;
        }
    }
    
    // Create a thread that will run the app and wait on it to end.
    // This will allow the app to still process messages and thus it
    // will not block apps that broadcast messages blocking
    // themselves.
    
    hThread = CreateThread(
                        NULL,
                        0,
                        RunShimmedApp,
                        NULL,
                        0,
                        &dwThreadId);
    
    if (hThread != NULL) {
        CloseHandle(hThread);
    }
}

/*********************************************************************
* HideStrictGroup
*
*********************************************************************/
VOID
HideStrictGroup(
    HWND hdlg,
    BOOL bHide)
{
static BOOL sbFirstTime = TRUE;

    int   i, nShow;
    DWORD arrId[] = {IDC_STRICT_GROUP,
                     IDC_COMMENT,
                     IDC_ADD_MATCHING,
                     IDC_FILE_ATTRIBUTES_STATIC,
                     IDC_ATTRIBUTES,
                     IDC_CREATEFILE,
                     IDC_CREATEFILE_STATIC,
                     0};

    if (!bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgBig.right - g_rcDlgBig.left,
                     g_rcDlgBig.bottom - g_rcDlgBig.top,
                     SWP_NOMOVE | SWP_NOZORDER);
        nShow = SW_SHOW;
        g_bSimpleEdition = FALSE;
        SetDlgItemText(hdlg, IDC_DETAILS, "<< Simple");
        
        // The first time the user goes to the dev edition center
        // the big dialog on the screen

        if (sbFirstTime) {
            sbFirstTime = FALSE;
            CenterWindow(hdlg);
        }
    } else {
        nShow = SW_HIDE;
        g_bSimpleEdition = TRUE;
        SetDlgItemText(hdlg, IDC_DETAILS, "Advanced >>");
    }
    
    for (i = 0; arrId[i] != 0; i++) {
        ShowWindow(GetDlgItem(hdlg, arrId[i]), nShow);
    }

    if (bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgSmall.right - g_rcDlgSmall.left,
                     g_rcDlgSmall.bottom - g_rcDlgSmall.top,
                     SWP_NOMOVE | SWP_NOZORDER);
    }

}

/*********************************************************************
* DoDetails
*
*********************************************************************/
VOID
DoDetails(
    HWND hdlg)
{
    HideStrictGroup(hdlg, !g_bSimpleEdition);
}

/*********************************************************************
* Restart
*
*********************************************************************/
VOID
Restart(
    HWND hdlg)
{
    PopulateTree(g_hwndShimTree);
}

/*********************************************************************
* DoInitDialog
*
*********************************************************************/
VOID
DoInitDialog(
    HWND hdlg)
{
    HICON hIcon;
    RECT  rcGroup, rcList;

    g_hDlg = hdlg;

    GetWindowRect(hdlg, &g_rcDlgBig);

    GetWindowRect(GetDlgItem(hdlg, IDC_STRICT_GROUP), &rcGroup);
    GetWindowRect(GetDlgItem(hdlg, IDC_ATTRIBUTES), &rcList);

    g_rcDlgSmall.left   = g_rcDlgBig.left;
    g_rcDlgSmall.top    = g_rcDlgBig.top;
    g_rcDlgSmall.bottom = g_rcDlgBig.bottom;
    g_rcDlgSmall.right  = g_rcDlgBig.right -
                            (rcGroup.right - rcGroup.left) -
                            (rcList.left - rcGroup.left);

    HideStrictGroup(hdlg, TRUE);

    CenterWindow(hdlg);

    EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), FALSE);

    if (g_bWin2k) {
        SendDlgItemMessage(hdlg, IDC_WIN2K, BM_SETCHECK, BST_CHECKED, 0);
    } else {
        SendDlgItemMessage(hdlg, IDC_WHISTLER, BM_SETCHECK, BST_CHECKED, 0);
    }

    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

    g_hwndShimTree = GetDlgItem(hdlg, IDC_TREE);
    g_hwndFilesTree = GetDlgItem(hdlg, IDC_ATTRIBUTES);

    HIMAGELIST hImage = ImageList_Create(
    int cx, 	
    int cy, 	
    UINT flags, 	
    int cInitial, 	
    int cGrow	
   );	

    g_szBinary[0] = 0;

    PopulateTree(g_hwndShimTree);
}

/*********************************************************************
* QShimAppDlgProc
*
*********************************************************************/
INT_PTR CALLBACK
QShimAppDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_NOTIFY:
        
        if (wParam == IDC_TREE) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case TVN_SELCHANGED:
                {
                    LPNMTREEVIEW lpnmtv;
                    PFIX         pFix;

                    lpnmtv = (LPNMTREEVIEW)lParam;
                    pFix = (PFIX)lpnmtv->itemNew.lParam;
        
                    SetDlgItemText(hdlg, IDC_SHIM_DESCRIPTION, pFix->pszDesc);
                    break;
                }
            default:
                break;
            }
        }
        break;

    case WM_DESTROY:
        if (g_bWin2k) {
            CleanupShimForApp_Win2000();
        } else {
            CleanupShimForApp_Whistler();
        }
        
        break;

    case WM_COMMAND:
        switch (wCode) {
        
        case IDC_RUN:
            DoRunApp(hdlg);
            break;
        
        case IDC_WIN2K:
            g_bWin2k = TRUE;
            Restart(hdlg);
            break;
        
        case IDC_WHISTLER:
            g_bWin2k = FALSE;
            Restart(hdlg);
            break;
        
        case IDC_BROWSE:
            DoBrowseForApp(hdlg);
            break;
        
        case IDC_BROWSE_OTHER:
            DoBrowseOther(hdlg);
            break;
        
        case IDC_DETAILS:
            DoDetails(hdlg);
            break;

        case IDC_ADD_MATCHING:
            DoAddMatchingFile(hdlg);
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************
* WinMain
*
*********************************************************************/
int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    char   szShimDB[MAX_PATH];
    HANDLE hFile;

    InitCommonControls();

    g_hInstance = hInst;

    // find out if we're on Whistler or not

    GetSystemWindowsDirectory(szShimDB, MAX_PATH);
    lstrcat(szShimDB, "\\AppPatch\\sysmain.sdb");
    
    hFile = CreateFile(
                szShimDB,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LogMsg("Running on Win2k\n");
        g_bWin2k = TRUE;
    } else {
        CloseHandle(hFile);
        LogMsg("Running on Whistler\n");
        g_bWin2k = FALSE;
    }

    DialogBox(hInst,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              QShimAppDlgProc);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\published\sdk\inc\vc5\objmodel\textauto.h ===
// Microsoft Visual Studio Object Model
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// textauto.h

// Declaration of dual interfaces to objects found in the type library
//  VISUAL STUDIO 97 TEXT EDITOR (SharedIDE\bin\devedit.pkg)

#ifndef __TEXTAUTO_H__
#define __TEXTAUTO_H__

#include "appauto.h"
#include "textdefs.h"

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/////////////////////////////////////////////////////////////////////////////
// Interfaces declared in this file:

//IGenericDocument
	interface ITextDocument;

interface ITextSelection;

//IGenericWindow
	interface ITextWindow;

interface ITextEditor;


// to remove any redefinitions by the Windows headers
#undef FindText
#undef ReplaceText


/////////////////////////////////////////////////////////////////////////////
// TextDocument object

// ITextDocument interface

#undef INTERFACE
#define INTERFACE ITextDocument

DECLARE_INTERFACE_(ITextDocument, IGenericDocument)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IGenericDocument methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pPath) PURE;
    STDMETHOD(get_Saved)(THIS_ VARIANT_BOOL FAR* pSaved) PURE;
    STDMETHOD(get_ActiveWindow)(THIS_ IDispatch * FAR* ppWindow) PURE;
    STDMETHOD(get_ReadOnly)(THIS_ VARIANT_BOOL FAR* pReadOnly) PURE;
    STDMETHOD(put_ReadOnly)(THIS_ VARIANT_BOOL ReadOnly) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pType) PURE;
    STDMETHOD(get_Windows)(THIS_ IDispatch * FAR* ppWindows) PURE;
	STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) PURE;
    STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) PURE;
    STDMETHOD(NewWindow)(THIS_ IDispatch * FAR* ppWindow) PURE;
    STDMETHOD(Save)(THIS_ VARIANT vFilename, VARIANT vBoolPrompt, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Undo)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(Redo)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(PrintOut)(THIS_ VARIANT_BOOL FAR* pSuccess) PURE;
    STDMETHOD(Close)(THIS_ VARIANT vSaveChanges, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
#endif

    /* ITextDocument methods */
    STDMETHOD(get_Selection)(THIS_ IDispatch * FAR* ppSelection) PURE;
    STDMETHOD(put_IndentSize)(THIS_ long Size) PURE;
    STDMETHOD(get_IndentSize)(THIS_ long FAR* pSize) PURE;
    STDMETHOD(put_TabSize)(THIS_ long Size) PURE;
    STDMETHOD(get_TabSize)(THIS_ long FAR* pSize) PURE;
    STDMETHOD(put_Language)(THIS_ BSTR Language) PURE;
    STDMETHOD(get_Language)(THIS_ BSTR FAR* pLanguage) PURE;
    STDMETHOD(ReplaceText)(THIS_ BSTR FindText, BSTR ReplaceText, VARIANT Flags, VARIANT_BOOL FAR* pbRetVal) PURE;
    STDMETHOD(ClearBookmarks)(THIS) PURE;
    STDMETHOD(MarkText)(THIS_ BSTR FindText, VARIANT Flags, VARIANT_BOOL FAR* pbRetVal) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// TextSelection object

// ITextSelection interface

#undef INTERFACE
#define INTERFACE ITextSelection

DECLARE_INTERFACE_(ITextSelection, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextSelection methods */
    STDMETHOD(put_Text)(THIS_ BSTR newText) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pText) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApp) PURE;
    STDMETHOD(get_CurrentLine)(THIS_ long FAR* plLine) PURE;
    STDMETHOD(get_CurrentColumn)(THIS_ long FAR* plCol) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) PURE;
    STDMETHOD(get_BottomLine)(THIS_ long FAR* plLine) PURE;
    STDMETHOD(get_TopLine)(THIS_ long FAR* plLine) PURE;
	STDMETHOD(Delete)(THIS_ VARIANT Count) PURE;
    STDMETHOD(SelectLine)(THIS) PURE;
    STDMETHOD(Backspace)(THIS_ VARIANT Count) PURE;
    STDMETHOD(StartOfDocument)(THIS_ VARIANT Extend) PURE;
    STDMETHOD(Copy)(THIS) PURE;
    STDMETHOD(Cut)(THIS) PURE;
    STDMETHOD(Paste)(THIS) PURE;
    STDMETHOD(EndOfDocument)(THIS_ VARIANT Extend) PURE;
    STDMETHOD(SelectAll)(THIS) PURE;
    STDMETHOD(Tabify)(THIS) PURE;
    STDMETHOD(Untabify)(THIS) PURE;
    STDMETHOD(Indent)(THIS_ VARIANT Reserved) PURE;
    STDMETHOD(Unindent)(THIS_ VARIANT Reserved) PURE;
    STDMETHOD(CharLeft)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(CharRight)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(LineUp)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(LineDown)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(PageUp)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(PageDown)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(WordLeft)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(WordRight)(THIS_ VARIANT Extend, VARIANT Count) PURE;
    STDMETHOD(EndOfLine)(THIS_ VARIANT Extend) PURE;
    STDMETHOD(StartOfLine)(THIS_ VARIANT MoveTo, VARIANT Extend) PURE;
    STDMETHOD(SmartFormat)(THIS) PURE;
    STDMETHOD(ChangeCase)(THIS_ DsCaseOptions Type) PURE;
    STDMETHOD(DeleteWhitespace)(THIS_ VARIANT Direction) PURE;
    STDMETHOD(Cancel)(THIS) PURE;
    STDMETHOD(GoToLine)(THIS_ long Line, VARIANT Select) PURE;
    STDMETHOD(MoveTo)(THIS_ long Line, long Column, VARIANT Extend) PURE;
    STDMETHOD(FindText)(THIS_ BSTR FindString, VARIANT Flags, VARIANT_BOOL FAR* pbRet) PURE;
    STDMETHOD(PreviousBookmark)(THIS_ VARIANT_BOOL FAR* pbRet) PURE;
    STDMETHOD(NextBookmark)(THIS_ VARIANT_BOOL FAR* pbRet) PURE;
    STDMETHOD(SetBookmark)(THIS) PURE;
    STDMETHOD(ClearBookmark)(THIS_ VARIANT_BOOL FAR* pbRet) PURE;
	STDMETHOD(NewLine)(THIS_ VARIANT Reserved) PURE;
    STDMETHOD(ReplaceText)(THIS_ BSTR FindText, BSTR ReplaceText, VARIANT Flags, VARIANT_BOOL FAR* pbRetVal) PURE;
	STDMETHOD(DestructiveInsert)(THIS_ BSTR szText) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// TextWindow object

// ITextWindow interface

#undef INTERFACE
#define INTERFACE ITextWindow

DECLARE_INTERFACE_(ITextWindow, IGenericWindow)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IGenericWindow methods */
    STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrCaption) PURE;
    STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) PURE;
    STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) PURE;
    STDMETHOD(put_Left)(THIS_ long lVal) PURE;
    STDMETHOD(get_Left)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Top)(THIS_ long lVal) PURE;
    STDMETHOD(get_Top)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Height)(THIS_ long lVal) PURE;
    STDMETHOD(get_Height)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(put_Width)(THIS_ long lVal) PURE;
    STDMETHOD(get_Width)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(get_Index)(THIS_ long FAR* plVal) PURE;
    STDMETHOD(get_Next)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Previous)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(put_WindowState)(THIS_ DsWindowState lVal) PURE;
    STDMETHOD(get_WindowState)(THIS_ DsWindowState FAR* plVal) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(Close)(THIS_ VARIANT boolSaveChanges, DsSaveStatus FAR* pSaved) PURE;
    STDMETHOD(Reserved1)(THIS) PURE;
    STDMETHOD(Reserved2)(THIS) PURE;
    STDMETHOD(Reserved3)(THIS) PURE;
    STDMETHOD(Reserved4)(THIS) PURE;
    STDMETHOD(Reserved5)(THIS) PURE;
    STDMETHOD(Reserved6)(THIS) PURE;
    STDMETHOD(Reserved7)(THIS) PURE;
    STDMETHOD(Reserved8)(THIS) PURE;
    STDMETHOD(Reserved9)(THIS) PURE;
    STDMETHOD(Reserved10)(THIS) PURE;
#endif

    /* ITextWindow methods */
    STDMETHOD(get_Selection)(THIS_ IDispatch * FAR* ppDispatch) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// TextEditor object

// ITextEditor interface

#undef INTERFACE
#define INTERFACE ITextEditor

DECLARE_INTERFACE_(ITextEditor, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITextEditor methods */
    STDMETHOD(put_VisibleWhitespace)(THIS_ VARIANT_BOOL bVisible) PURE;
    STDMETHOD(get_VisibleWhitespace)(THIS_ VARIANT_BOOL FAR* pbVisible) PURE;
    STDMETHOD(put_Emulation)(THIS_ long lEmulation) PURE;
    STDMETHOD(get_Emulation)(THIS_ long FAR* plEmulation) PURE;
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) PURE;
    STDMETHOD(put_Overtype)(THIS_ VARIANT_BOOL bOvertype) PURE;
    STDMETHOD(get_Overtype)(THIS_ VARIANT_BOOL FAR* pbOvertype) PURE;
};


#endif //__TEXTAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apidll\apidllp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidllp.h

Abstract:

    Common header file for APIDLL data structures.

Author:

    Wesley Witt (wesw) 12-July-1995

Environment:

    User Mode

--*/
extern "C" {
#include <nt.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apimon.h"

#if defined(_M_ALPHA)
#define FRAME_SIZE          128
#else
#define FRAME_SIZE          96
#endif

#define MAX_FRAMES          512
#define MAX_STACK_SIZE      (MAX_FRAMES * FRAME_SIZE)

typedef struct _THREAD_STACK {
    DWORD_PTR Pointer;
    DWORD     ThreadNum;
    CHAR      Body[MAX_STACK_SIZE];
} THREAD_STACK, *PTHREAD_STACK;

extern "C" {
typedef DWORD  (__stdcall *PGETCURRENTTHREADID)(VOID);
typedef LPVOID (__stdcall *PTLSGETVALUE)(DWORD);
typedef BOOL   (__stdcall *PTLSSETVALUE)(DWORD,LPVOID);
typedef LPVOID (__stdcall *PVIRTUALALLOC)(LPVOID,DWORD,DWORD,DWORD);
typedef DWORD  (__stdcall *PGETLASTERROR)(VOID);
typedef VOID   (__stdcall *PSETLASTERROR)(DWORD);
typedef BOOL   (__stdcall *PQUERYPERFORMANCECOUNTER)(LARGE_INTEGER *);

extern PVOID                    MemPtr;
extern LPDWORD                  ApiCounter;
extern LPDWORD                  ApiTraceEnabled;
extern DWORD                    TlsReEnter;
extern DWORD                    TlsStack;
extern PTLSGETVALUE             pTlsGetValue;
extern PTLSSETVALUE             pTlsSetValue;
extern PGETLASTERROR            pGetLastError;
extern PSETLASTERROR            pSetLastError;
extern PQUERYPERFORMANCECOUNTER pQueryPerformanceCounter;
extern PVIRTUALALLOC            pVirtualAlloc;
extern DWORD                    ThunkOverhead;
extern DWORD                    ThunkCallOverhead;
}


enum {
    APITYPE_NORMAL,
    APITYPE_LOADLIBRARYA,
    APITYPE_LOADLIBRARYW,
    APITYPE_FREELIBRARY,
    APITYPE_REGISTERCLASSA,
    APITYPE_REGISTERCLASSW,
    APITYPE_GETPROCADDRESS,
    APITYPE_SETWINDOWLONG,
    APITYPE_WNDPROC
};


extern "C" void
ApiMonThunk(
    void
    );

extern "C" void
ApiMonThunkComplete(
    void
    );

extern "C" VOID
HandleDynamicDllLoadA(
    ULONG_PTR DllAddress,
    LPSTR     DllName
    );

extern "C" VOID
HandleDynamicDllLoadW(
    ULONG_PTR DllAddress,
    LPWSTR    DllName
    );

extern "C" VOID
HandleRegisterClassA(
    WNDCLASSA *pWndClassA
    );

extern "C" VOID
HandleRegisterClassW(
    WNDCLASSW *pWndClassW
    );

extern "C" LONG_PTR
HandleSetWindowLong(
    HWND    hWindow,
    LONG    lOffset,
    LPARAM  lValue
    );

extern "C" ULONG_PTR
HandleGetProcAddress(
    ULONG_PTR ProcAddress
    );

extern "C" void
__cdecl
dprintf(
    char *format,
    ...
    );

extern "C" BOOL
PentiumGetPerformanceCounter(
    PLARGE_INTEGER Counter
    );

LPSTR
UnDname(
    LPSTR sym,
    LPSTR undecsym,
    DWORD bufsize
    );

PUCHAR
CreateMachApiThunk(
    PULONG_PTR  IatAddress,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    );

extern "C" VOID
ApiTrace(
    PAPI_INFO   ApiInfo,
#ifdef _M_ALPHA
    DWORDLONG   Arg[MAX_TRACE_ARGS],
#else
    ULONG       Arg[MAX_TRACE_ARGS],
#endif
    ULONG       ReturnValue,
    ULONG       Caller,
    DWORDLONG   EnterTime,
    DWORDLONG   ExitTime,
    ULONG       LastError
    );

extern SYSTEM_INFO SystemInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apidll\apidll.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidll.cpp

Abstract:

    This file implements the non-architecture specific
    code for the api monitor trojan/support dll.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/
#include "apidllp.h"
#include <tchar.h>
#pragma hdrstop

typedef struct _BUF_INFO {
    LPSTR       BufferHead;
    LPSTR       Buffer;
} BUF_INFO, *PBUF_INFO;


PVOID                       MemPtr;
PDLL_INFO                   DllList;
HANDLE                      hLogFile;
PGETCURRENTTHREADID         pGetCurrentThreadId;
PUCHAR                      ThunksBase;
PUCHAR                      Thunks;
BOOL                        RunningOnNT;
BOOL                        StaticLink;
ULONG_PTR                   LoadLibraryA_Addr;
ULONG_PTR                   LoadLibraryW_Addr;
ULONG_PTR                   FreeLibrary_Addr;
ULONG_PTR                   GetProcAddress_Addr;
HANDLE                      ApiTraceMutex;
HANDLE                      ApiMemMutex;
PTRACE_BUFFER               TraceBuffer;
DWORD                       ThreadCnt;

DLL_INFO                    WndProcDllInfo;
BOOL                        printNow = 0;
extern "C" {
    LPDWORD                 ApiCounter;
    LPDWORD                 ApiTraceEnabled;
    LPDWORD                 ApiTimingEnabled;
    LPDWORD                 FastCounterAvail;
    LPDWORD                 ApiOffset;
    LPDWORD                 ApiStrings;
    LPDWORD                 ApiCount;
    LPDWORD                 WndProcEnabled;
    LPDWORD                 WndProcCount;
    LPDWORD                 WndProcOffset;
    DWORD                   TlsReEnter;
    DWORD                   TlsStack;
    DWORD                   ThunkOverhead;
    DWORD                   ThunkCallOverhead;
    PTLSGETVALUE            pTlsGetValue;
    PTLSSETVALUE            pTlsSetValue;
    PGETLASTERROR           pGetLastError;
    PSETLASTERROR           pSetLastError;
    PVIRTUALALLOC           pVirtualAlloc;
    PQUERYPERFORMANCECOUNTER pQueryPerformanceCounter;
}

extern API_MASTER_TABLE ApiTables[];
BOOL    ReDirectIat(VOID);
BOOL    ProcessDllLoad(VOID);
PUCHAR  CreateApiThunk(ULONG_PTR,PUCHAR,PDLL_INFO,PAPI_INFO);
BOOL    ProcessApiTable(PDLL_INFO DllInfo);
VOID    CreateWndProcApi(LPCSTR lpszClassName, WNDPROC *pWndProc);
VOID    CalibrateThunk();
VOID    Calib1Func(VOID);
VOID    Calib2Func(VOID);
VOID    (*Calib1Thunk)();
VOID    (*Calib2Thunk)();

extern "C" void
__cdecl
dprintf(
    char *format,
    ...
    )

/*++

Routine Description:

    Prints a debug string to the API monitor.

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    char    buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    pTlsSetValue( TlsReEnter, (LPVOID) 1 );
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);
    OutputDebugString( buf );
    pTlsSetValue( TlsReEnter, (LPVOID) 0 );
    return;
}

extern "C" {

DWORD
ApiDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        return ProcessDllLoad();
    }

    if (Reason == DLL_THREAD_ATTACH) {
        pTlsSetValue( TlsReEnter, (LPVOID) 1 );
        PTHREAD_STACK Stack = (PTHREAD_STACK) pVirtualAlloc( NULL, sizeof(THREAD_STACK), MEM_COMMIT, PAGE_READWRITE );

        if (!Stack) {
            return FALSE;
        }

        Stack->ThreadNum = ++ThreadCnt;

        // Start at 2nd entry so that there is always a parent frame
        Stack->Pointer = (DWORD_PTR)&Stack->Body[FRAME_SIZE];

        pTlsSetValue( TlsReEnter, (LPVOID) 0 );
        pTlsSetValue( TlsStack, Stack );

        return TRUE;
    }

    if (Reason == DLL_THREAD_DETACH) {
        return TRUE;
    }

    if (Reason == DLL_PROCESS_DETACH) {
        return TRUE;
    }

    return TRUE;
}

} //extern "C"

PDLL_INFO
AddDllToList(
    ULONG DllAddr,
    LPSTR DllName,
    ULONG DllSize
    )
{
    //
    // look for the dll entry in the list
    //
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }

    //
    // this check should be unnecessary
    // the debugger side (apimon.exe) takes
    // care of adding the dlls to the list when
    // it gets a module load from the debug
    // subsystem.  this code is here only so
    // a test program that is not a debugger
    // will work properly.
    //
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == 0) {
            DllList[i].BaseAddress = DllAddr;
            strcpy( DllList[i].Name, DllName );
            DllList[i].Size = DllSize;
            return &DllList[i];
        }
    }

    //
    // we could not find a dll in the list that matched
    // and we could not add it because the list is
    // is full. we're hosed.
    //
    return NULL;
}

BOOL
ProcessDllLoad(
    VOID
    )

/*++

Routine Description:

    Sets up the API thunks for the process that this dll
    is loaded into.

Arguments:

    None.

Return Value:

    TRUE        - Success
    FALSE       - Failure

--*/

{
    ULONG i;
    ULONG cnt;
    HANDLE hMap;

    //
    // see if we are running on NT
    // this is necessary because APIMON implements some
    // features that are NOT available on WIN95
    //
    OSVERSIONINFO OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx( &OsVersionInfo );
    RunningOnNT = OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    TlsReEnter = TlsAlloc();
    if (TlsReEnter == TLS_OUT_OF_INDEXES) {
        return FALSE;
    }
    TlsStack = TlsAlloc();
    if (TlsStack == TLS_OUT_OF_INDEXES) {
        return FALSE;
    }

    HMODULE hMod = GetModuleHandle( KERNEL32 );
    if (!hMod) {
        return FALSE;
    }
    pGetCurrentThreadId = (PGETCURRENTTHREADID) GetProcAddress( hMod, "GetCurrentThreadId" );
    if (!pGetCurrentThreadId) {
        return FALSE;
    }
    pGetLastError = (PGETLASTERROR) GetProcAddress( hMod, "GetLastError" );
    if (!pGetLastError) {
        return FALSE;
    }
    pSetLastError = (PSETLASTERROR) GetProcAddress( hMod, "SetLastError" );
    if (!pSetLastError) {
        return FALSE;
    }
    pQueryPerformanceCounter = (PQUERYPERFORMANCECOUNTER) GetProcAddress( hMod, "QueryPerformanceCounter" );
    if (!pQueryPerformanceCounter) {
        return FALSE;
    }
    pTlsGetValue = (PTLSGETVALUE) GetProcAddress( hMod, "TlsGetValue" );
    if (!pTlsGetValue) {
        return FALSE;
    }
    pTlsSetValue = (PTLSSETVALUE) GetProcAddress( hMod, "TlsSetValue" );
    if (!pTlsSetValue) {
        return FALSE;
    }
    pVirtualAlloc = (PVIRTUALALLOC) GetProcAddress( hMod, "VirtualAlloc" );
    if (!pVirtualAlloc) {
        return FALSE;
    }

    Thunks = (PUCHAR)VirtualAlloc( NULL, THUNK_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if (!Thunks) {
        return FALSE;
    }
    ThunksBase = Thunks;

    PTHREAD_STACK Stack = (PTHREAD_STACK) pVirtualAlloc( NULL, sizeof(THREAD_STACK), MEM_COMMIT, PAGE_READWRITE );
    if (!Stack) {
        return FALSE;
    }

    Stack->ThreadNum = ++ThreadCnt;

    // Start at 2nd entry so that there is always a parent frame
    Stack->Pointer = (DWORD_PTR)&Stack->Body[FRAME_SIZE];

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );
    pTlsSetValue( TlsStack, Stack );

    hMap = OpenFileMapping(
        FILE_MAP_WRITE,
        FALSE,
        "ApiWatch"
        );
    if (!hMap) {
        return FALSE;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        return FALSE;
    }

    ApiCounter       = (LPDWORD)   MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)   MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)   MemPtr + 2;
    FastCounterAvail = (LPDWORD)   MemPtr + 3;
    ApiOffset        = (LPDWORD)   MemPtr + 4;
    ApiStrings       = (LPDWORD)   MemPtr + 5;
    ApiCount         = (LPDWORD)   MemPtr + 6;
    WndProcEnabled   = (LPDWORD)   MemPtr + 7;
    WndProcCount     = (LPDWORD)   MemPtr + 8;
    WndProcOffset    = (LPDWORD)   MemPtr + 9;
    DllList          = (PDLL_INFO) ((LPDWORD)MemPtr + 10);

    //
    // open the shared memory region for the api trace buffer
    //
    hMap = OpenFileMapping(
        FILE_MAP_WRITE,
        FALSE,
        "ApiTrace"
        );
    if (!hMap) {
        return FALSE;
    }

    TraceBuffer = (PTRACE_BUFFER)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!TraceBuffer) {
        return FALSE;
    }

    ApiTraceMutex = OpenMutex( SYNCHRONIZE, FALSE, "ApiTraceMutex" );
    if (!ApiTraceMutex) {
        return FALSE;
    }

    ApiMemMutex = OpenMutex( SYNCHRONIZE, FALSE, "ApiMemMutex" );
    if (!ApiMemMutex) {
        return FALSE;
    }

    // Initialize dummy window proc Dll
    // (Only need the fields accesed by thunk and thunk creation)
    strcpy(WndProcDllInfo.Name, WNDPROCDLL);
    WndProcDllInfo.Enabled = TRUE;

    CalibrateThunk();

    ReDirectIat();

    // Disable close handle exceptions
    if (RunningOnNT) {
        NtCurrentPeb()->NtGlobalFlag &= ~FLG_ENABLE_CLOSE_EXCEPTIONS;
    }

    return TRUE;
}


PUCHAR
ProcessThunk(
    ULONG_PTR   ThunkAddr,
    ULONG_PTR   IatAddr,
    PUCHAR      Text
    )
{
    PDLL_INFO DllInfo;
    for (ULONG k=0; k<MAX_DLLS; k++) {
        DllInfo = &DllList[k];
        if (ThunkAddr >= DllInfo->BaseAddress &&
            ThunkAddr <  DllInfo->BaseAddress+DllInfo->Size) {
                break;
        }
    }
    if (k == MAX_DLLS) {
        return Text;
    }

    PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
    PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);
    PIMAGE_SECTION_HEADER SectionHdrs = IMAGE_FIRST_SECTION( nh );
    BOOL IsCode = FALSE;
    for (ULONG l=0; l<nh->FileHeader.NumberOfSections; l++) {
        if (ThunkAddr-DllInfo->BaseAddress >= SectionHdrs[l].VirtualAddress &&
            ThunkAddr-DllInfo->BaseAddress < SectionHdrs[l].VirtualAddress+SectionHdrs[l].SizeOfRawData) {
                if (SectionHdrs[l].Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                    IsCode = TRUE;
                    break;
                }
                break;
        }
    }
    if (!IsCode) {
        return Text;
    }
    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    for (l=0; l<DllInfo->ApiCount; l++) {
        if (ApiInfo[l].Address == ThunkAddr) {
            return CreateApiThunk( IatAddr, Text, DllInfo, &ApiInfo[l] );
        }
    }

    return Text;
}

PUCHAR
ProcessUnBoundImage(
    PDLL_INFO DllInfo,
    PUCHAR    Text
    )
{
    PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
    if (dh->e_magic != IMAGE_DOS_SIGNATURE) {
        return Text;
    }
    PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);

    PIMAGE_SECTION_HEADER SectionHdrs = IMAGE_FIRST_SECTION( nh );
    ULONG Address = nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    ULONG i;
    for (i=0; i<nh->FileHeader.NumberOfSections; i++) {
        if (Address >= SectionHdrs[i].VirtualAddress &&
            Address < SectionHdrs[i].VirtualAddress+SectionHdrs[i].SizeOfRawData) {
                break;
        }
    }
    if (i == nh->FileHeader.NumberOfSections) {
        return Text;
    }

    ULONG_PTR SeekPos = DllInfo->BaseAddress +
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    ULONG PageProt;
    ULONG ThunkProt;
    ULONG_PTR ImportStart = SeekPos;
    PUCHAR TextStart = Text;

    VirtualProtect(
        (PVOID)ImportStart,
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size,
        PAGE_READWRITE,
        &PageProt
        );

    while( TRUE ) {
        PIMAGE_IMPORT_DESCRIPTOR desc = (PIMAGE_IMPORT_DESCRIPTOR)SeekPos;

        SeekPos += sizeof(IMAGE_IMPORT_DESCRIPTOR);

        if ((desc->Characteristics == 0) && (desc->Name == 0) && (desc->FirstThunk == 0)) {
            //
            // End of import descriptors
            //
            break;
        }
        ULONG_PTR *ThunkAddr = (ULONG_PTR *)((ULONG)desc->FirstThunk + DllInfo->BaseAddress);
        while( *ThunkAddr ) {

#ifdef _X86_
            if (RunningOnNT) {
                Text = ProcessThunk(*ThunkAddr, (ULONG_PTR)ThunkAddr, Text );
            } else {
                Text = ProcessThunk(*(PULONG)(*ThunkAddr + 1), (ULONG)ThunkAddr, Text );
            }
#else
            Text = ProcessThunk(*ThunkAddr, (ULONG_PTR)ThunkAddr, Text );
#endif
            ThunkAddr += 1;
        }
    }

    VirtualProtect(
        (PVOID)ImportStart,
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size,
        PageProt,
        &PageProt
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)DllInfo->BaseAddress,
        DllInfo->Size
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)TextStart,
        (DWORD)(Text-TextStart)
        );

    return Text;
}

PUCHAR
ProcessBoundImage(
    PDLL_INFO DllInfo,
    PUCHAR    Text,
    PULONG    IatBase,
    ULONG     IatCnt
    )
{
    ULONG j;
    ULONG PageProt;
    ULONG ThunkProt;
    PUCHAR TextStart = Text;

    VirtualProtect(
        IatBase,
        IatCnt*4,
        PAGE_READWRITE,
        &PageProt
        );

    //
    // process the iat entries
    //
    for (j=0; j<IatCnt; j++) {
        if (IatBase[j]) {
#ifdef _X86_
            if (RunningOnNT) {
                Text = ProcessThunk( IatBase[j], (ULONG_PTR)&IatBase[j], Text );
            } else {
                Text = ProcessThunk(*(PULONG)(IatBase[j] + 1), (ULONG)&IatBase[j], Text );
            }
#else
            Text = ProcessThunk( IatBase[j], (ULONG_PTR)&IatBase[j], Text );
#endif
        }
    }

    VirtualProtect(
        IatBase,
        IatCnt*4,
        PageProt,
        &PageProt
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)DllInfo->BaseAddress,
        DllInfo->Size
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)TextStart,
        (DWORD)(Text-TextStart)
        );


    return Text;
}

BOOL
ReDirectIat(
    VOID
    )
{
    ULONG i;
    PUCHAR Text = Thunks;

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        if ((DllInfo->Snapped) || (DllInfo->Unloaded)) {
            continue;
        }
        PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
        PULONG IatBase = NULL;
        ULONG IatCnt = 0;
        if (dh->e_magic == IMAGE_DOS_SIGNATURE) {
            PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);
            if (nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress) {
                IatBase = (PULONG)(DllInfo->BaseAddress +
                    nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress);
                IatCnt = nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size / 4;
            }
        } else {
            continue;
        }

        if (!IatBase) {
            Text = ProcessUnBoundImage( DllInfo, Text );
        } else {
            Text = ProcessBoundImage( DllInfo, Text, IatBase, IatCnt );
        }
        DllInfo->Snapped = TRUE;

        ProcessApiTable( DllInfo );
    }

    Thunks = Text;

    return TRUE;
}

extern "C" {

VOID
HandleDynamicDllLoadA(
    ULONG_PTR DllAddress,
    LPSTR     DllName
    )
{
    if ( (!DllAddress) || (_stricmp(DllName,TROJANDLL)==0) ) {
        return;
    }

    ReDirectIat();
}

VOID
HandleDynamicDllLoadW(
    ULONG_PTR DllAddress,
    LPWSTR    DllName
    )
{
    CHAR AsciiBuf[512];
    ZeroMemory( AsciiBuf, sizeof(AsciiBuf) );
    WideCharToMultiByte(
        CP_ACP,
        0,
        DllName,
        wcslen(DllName),
        AsciiBuf,
        sizeof(AsciiBuf),
        NULL,
        NULL
        );
    if (!strlen(AsciiBuf)) {
        return;
    }
    HandleDynamicDllLoadA( DllAddress, AsciiBuf );
}


VOID
HandleRegisterClassA(
    WNDCLASSA   *pWndClass
    )
{
    if (!*WndProcEnabled)
        return;

    // Don't deal with call procedure handles or special addresses
#ifdef _WIN64
    if (HIWORD((((DWORD_PTR)pWndClass->lpfnWndProc) >> 32)) == 0xFFFF)
#else
    if (HIWORD(pWndClass->lpfnWndProc) == 0xFFFF)
#endif
        return;

    if ((ULONG_PTR)(pWndClass->lpfnWndProc) & 0x80000000) {
        return;
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    if ((ULONG_PTR)pWndClass->lpszClassName < 0x10000) {
        CreateWndProcApi("<Atom>", &pWndClass->lpfnWndProc);
    } else {
        CreateWndProcApi( pWndClass->lpszClassName, &pWndClass->lpfnWndProc );
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

}


VOID HandleRegisterClassW(
    WNDCLASSW *pWndClass
    )
{
    CHAR AsciiBuf[128];

    if (!*WndProcEnabled)
        return;

    // Don't deal with call procedure handles or special addresses
#ifdef _WIN64
    if ((HIWORD((((DWORD_PTR)pWndClass->lpfnWndProc) >> 32)) == 0xFFFF) ||
#else
    if (( HIWORD(pWndClass->lpfnWndProc) == 0xFFFF) ||
#endif
        ((ULONG_PTR)(pWndClass->lpfnWndProc) & 0x80000000) ) {
        return;
    }

    if ((ULONG_PTR)pWndClass->lpszClassName < 0x10000) {
       CreateWndProcApi( "<Atom>", &pWndClass->lpfnWndProc );
       return;
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    ZeroMemory( AsciiBuf, sizeof(AsciiBuf) );
    WideCharToMultiByte(
        CP_ACP,
        0,
        pWndClass->lpszClassName,
        wcslen(pWndClass->lpszClassName),
        AsciiBuf,
        sizeof(AsciiBuf),
        NULL,
        NULL
        );

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

    if (!strlen(AsciiBuf)) {
        return;
    }

    CreateWndProcApi( AsciiBuf, &pWndClass->lpfnWndProc );
}

LONG_PTR
HandleSetWindowLong(
    HWND    hWindow,
    LONG    lOffset,
    LPARAM  lValue
    )
{
    if (!*WndProcEnabled || (lOffset != GWLP_WNDPROC))
        return lValue;

     // Don't handle special addresses
#ifdef _WIN64
     if ((HIWORD((lValue >> 32)) == 0xFFFF) ||
#else
     if ( (HIWORD(lValue) == 0xFFFF)  ||
#endif
          ((ULONG_PTR)lValue & 0x80000000) ) {
        return lValue;
    }

    CreateWndProcApi( "Subclass", (WNDPROC*)&lValue );

    return lValue;
}


VOID
HandleDynamicDllFree(
    ULONG_PTR   DllAddress
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddress) {
            DllList[i].Unloaded = TRUE;
            // DllList[i].Enabled  = FALSE; Leave enable in case it's reloaded
            DllList[i].Snapped  = FALSE;
            break;
        }
    }
}


ULONG_PTR
HandleGetProcAddress(
    ULONG_PTR ProcAddress
    )
{
    if (ProcAddress == NULL)
        return NULL;

    Thunks = ProcessThunk(ProcAddress, (ULONG_PTR)&ProcAddress, Thunks);

    return ProcAddress;
}

} // extern "C"


VOID
CreateWndProcApi(
    LPCSTR  lpszClassName,
    WNDPROC *pWndProc
    )
{
    PAPI_INFO   ApiInfo;
    DWORD       i;
    PUCHAR      NewThunks;
    CHAR debugBuf[256];

    // Don't re-thunk one of our own thunks
    if (ThunksBase <= (PUCHAR)*pWndProc && (PUCHAR)*pWndProc < Thunks)
        return;

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    // Get exclusive access to API memory
    WaitForSingleObject( ApiMemMutex, INFINITE );


    // Check for existing thunk for this window proc
    ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
    for (i=0; i<*WndProcCount; i++,ApiInfo++) {
        if (ApiInfo->Address == (ULONG_PTR)*pWndProc) {
            *pWndProc = (WNDPROC)ApiInfo->ThunkAddress;
            ReleaseMutex(ApiMemMutex);
            pTlsSetValue( TlsReEnter, (LPVOID) 0 );
            return;
        }
    }

    // Allocate an API Info slot
    if (*ApiCount < MAX_APIS) {
        *WndProcOffset -= sizeof(API_INFO);
        *WndProcCount += 1;
        *ApiCount += 1;
        ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
        ApiInfo->Name = *ApiStrings;
        strcpy( (LPSTR)((LPSTR)MemPtr + *ApiStrings), lpszClassName );
        *ApiStrings += (strlen(lpszClassName) + 1);
    }
    else {
        ApiInfo = NULL;
    }


    if (ApiInfo != NULL) {

        ApiInfo->Count = 0;
        ApiInfo->NestCount = 0;
        ApiInfo->Time = 0;
        ApiInfo->CalleeTime = 0;
        ApiInfo->ThunkAddress = 0;
        ApiInfo->Address = (ULONG_PTR)*pWndProc;
        ApiInfo->DllOffset = 0;
        ApiInfo->HardFault  = 0;
        ApiInfo->SoftFault  = 0;
        ApiInfo->CodeFault  = 0;
        ApiInfo->DataFault  = 0;

        NewThunks = CreateMachApiThunk( (PULONG_PTR)pWndProc, Thunks, &WndProcDllInfo, ApiInfo );
        FlushInstructionCache( GetCurrentProcess(), (PVOID)Thunks, (DWORD)(NewThunks - Thunks));
        Thunks = NewThunks;
    }

    ReleaseMutex( ApiMemMutex );
    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

}

BOOL
ProcessApiTable(
    PDLL_INFO DllInfo
    )
{
    ULONG i,j;
    PAPI_MASTER_TABLE ApiMaster = NULL;

    i = 0;
    while( ApiTables[i].Name ) {
        if (_stricmp( ApiTables[i].Name, DllInfo->Name ) == 0) {
            ApiMaster = &ApiTables[i];
            break;
        }
        i += 1;
    }
    if (!ApiMaster) {
        return FALSE;
    }
    if (ApiMaster->Processed) {
        return TRUE;
    }

    i = 0;
    PAPI_TABLE ApiTable = ApiMaster->ApiTable;
    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    while( ApiTable[i].Name ) {
        for (j=0; j<DllInfo->ApiCount; j++) {
            if (strcmp( ApiTable[i].Name, (LPSTR)MemPtr+ApiInfo[j].Name ) == 0) {
                ApiInfo[j].ApiTable = &ApiTable[i];
                ApiInfo[j].ApiTableIndex = i + 1;
                break;
            }
        }
        i += 1;
    }

    ApiMaster->Processed = TRUE;

    return TRUE;
}

PUCHAR
CreateApiThunk(
    ULONG_PTR   IatAddr,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    )
{
    CHAR debugBuf[256];
#if DBG
    _stprintf(debugBuf, "CreateApiThunk: %s:%s\n",DllInfo->Name, (LPSTR)MemPtr + ApiInfo->Name);
    OutputDebugString(debugBuf);
#endif

    LPSTR Name = (LPSTR)MemPtr+ApiInfo->Name;
    if ((strcmp(Name,"FlushInstructionCache")==0)      ||
        (strcmp(Name,"NtFlushInstructionCache")==0)    ||
        (strcmp(Name,"ZwFlushInstructionCache")==0)    ||
        (strcmp(Name,"VirtualProtect")==0)             ||
        (strcmp(Name,"VirtualProtectEx")==0)           ||
        (strcmp(Name,"NtProtectVirtualMemory")==0)     ||
        (strcmp(Name,"ZwProtectVirtualMemory")==0)     ||
        (strcmp(Name,"QueryPerformanceCounter")==0)    ||
        (strcmp(Name,"NtQueryPerformanceCounter")==0)  ||
        (strcmp(Name,"ZwQueryPerformanceCounter")==0)  ||
        (strcmp(Name,"NtCallbackReturn")==0)           ||
        (strcmp(Name,"ZwCallbackReturn")==0)           ||
        (strcmp(Name,"_chkstk")==0)                    ||
        (strcmp(Name,"_alloca_probe")==0)              ||
        (strcmp(Name,"GetLastError")==0)               ||
        (strcmp(Name,"SetLastError")==0)               ||
        (strcmp(Name,"_setjmp")==0)                    ||
        (strcmp(Name,"_setjmp3")==0)                   ||
        (strcmp(Name,"longjmp")==0)                    ||
        (strcmp(Name,"_longjmpex")==0)                 ||
        (strcmp(Name,"TlsGetValue")==0)                ||
        (strcmp(Name,"TlsSetValue")==0)                ||
        (strncmp(Name,"_Ots",4)==0)) {
            return Text;
    }


    PUCHAR stat = CreateMachApiThunk( (PULONG_PTR)IatAddr, Text, DllInfo, ApiInfo );

    return stat;
}

LPSTR
UnDname(
    LPSTR sym,
    LPSTR undecsym,
    DWORD bufsize
    )
{
    if (*sym != '?') {
        return sym;
    }

    if (UnDecorateSymbolName( sym,
                          undecsym,
                          bufsize,
                          UNDNAME_COMPLETE                |
                          UNDNAME_NO_LEADING_UNDERSCORES  |
                          UNDNAME_NO_MS_KEYWORDS          |
                          UNDNAME_NO_FUNCTION_RETURNS     |
                          UNDNAME_NO_ALLOCATION_MODEL     |
                          UNDNAME_NO_ALLOCATION_LANGUAGE  |
                          UNDNAME_NO_MS_THISTYPE          |
                          UNDNAME_NO_CV_THISTYPE          |
                          UNDNAME_NO_THISTYPE             |
                          UNDNAME_NO_ACCESS_SPECIFIERS    |
                          UNDNAME_NO_THROW_SIGNATURES     |
                          UNDNAME_NO_MEMBER_TYPE          |
                          UNDNAME_NO_RETURN_UDT_MODEL     |
                          UNDNAME_NO_ARGUMENTS            |
                          UNDNAME_NO_SPECIAL_SYMS         |
                          UNDNAME_NAME_ONLY )) {

        return undecsym;
    }

    return sym;
}

extern "C" ULONG
GetApiInfo(
    PAPI_INFO   *ApiInfo,
    PDLL_INFO   *DllInfo,
    PULONG      ApiFlag,
    ULONG       Address
    )
{
    ULONG       i;
    ULONG       rval;
    LONG        High;
    LONG        Low;
    LONG        Middle;
    PAPI_INFO   ai;


    *ApiInfo = NULL;
    *DllInfo = NULL;
    *ApiFlag = APITYPE_NORMAL;


#if defined(_M_IX86)

    //
    // the call instruction use to call penter
    // is 5 bytes long
    //
    Address -= 5;
    rval = 1;

#elif defined(_M_MRX000)

    //
    // search for the beginning of the prologue
    //
    PULONG Instr = (PULONG) (Address - 4);
    i = 0;
    rval = 0;
    while( i < 16 ) {
        //
        // the opcode for the addiu instruction is 9
        //
        if ((*Instr >> 16) == 0xafbf) {
            //
            // find the return address
            //
            rval = *Instr & 0xffff;
            break;
        }
        Instr -= 1;
        i += 1;
    }
    if (i == 16 || rval == 0) {
        return 0;
    }

#elif defined(_M_ALPHA)

    rval = 1;

#elif defined(_M_PPC)

    //
    // On PPC, the penter call sequence looks like this:
    //
    //      mflr    r0
    //      stwu    sp,-0x40(sp)
    //      bl      ..penter
    //
    // So the function entry point is the return address - 12.
    //
    // (We really should do a function table lookup here, so
    // we're not dependent on the sequence...)
    //

    Address -= 12;
    rval = 1;

#else
#error( "unknown target machine" );
#endif

    for (i=0; i<MAX_DLLS; i++) {
        if (Address >= DllList[i].BaseAddress &&
            Address <  DllList[i].BaseAddress + DllList[i].Size) {
                *DllInfo = &DllList[i];
                break;
        }
    }

    if (!*DllInfo) {
        return 0;
    }

    ai = (PAPI_INFO)((*DllInfo)->ApiOffset + (ULONG_PTR)DllList);

    Low = 0;
    High = (*DllInfo)->ApiCount - 1;

    while (High >= Low) {
        Middle = (Low + High) >> 1;
        if (Address < ai[Middle].Address) {

            High = Middle - 1;

        } else if (Address > ai[Middle].Address) {

            Low = Middle + 1;

        } else {

            *ApiInfo = &ai[Middle];
            break;

        }
    }

    if (!*ApiInfo) {
        return 0;
    }

    if (Address == LoadLibraryA_Addr) {
        *ApiFlag = APITYPE_LOADLIBRARYA;
    } else if (Address == LoadLibraryW_Addr) {
        *ApiFlag = APITYPE_LOADLIBRARYW;
    } else if (Address == FreeLibrary_Addr) {
        *ApiFlag = APITYPE_FREELIBRARY;
    } else if (Address == GetProcAddress_Addr) {
        *ApiFlag = APITYPE_GETPROCADDRESS;
    }
    return rval;
}


extern "C" VOID
ApiTrace(
    PAPI_INFO   ApiInfo,
    ULONG_PTR   Arg[MAX_TRACE_ARGS],
    ULONG       ReturnValue,
    ULONG       Caller,
    DWORDLONG   EnterTime,
    DWORDLONG   Duration,
    ULONG       LastError
    )
{
    PTRACE_ENTRY TraceEntry;
    ULONG        TraceEntryLen;
    PTHREAD_STACK ThreadStack;
    LPSTR        TraceString;
    LPSTR        TraceLimit;
    CHAR         debugBuf[128];
    ULONG_PTR    len;
    DWORD        *dwPtr;
    ULONG        i;
    ULONG        ArgCount;

    __try {

        pTlsSetValue( TlsReEnter, (LPVOID) 1 );
        WaitForSingleObject( ApiTraceMutex, INFINITE );

        // if trace buffer has room for another entry
        if ( TraceBuffer->Offset + sizeof(TRACE_ENTRY) < TraceBuffer->Size ) {

            TraceEntry = (PTRACE_ENTRY)((PCHAR)TraceBuffer->Entry + TraceBuffer->Offset);
            TraceEntry->Address       = ApiInfo->Address;
            TraceEntry->ReturnValue   = ReturnValue;
            TraceEntry->Caller        = Caller;
            TraceEntry->LastError     = LastError;
            TraceEntry->ApiTableIndex = ApiInfo->ApiTableIndex;
            TraceEntry->EnterTime     = EnterTime;
            TraceEntry->Duration      = Duration;

            ArgCount = (ApiInfo->ApiTable && ApiInfo->ApiTable->ArgCount) ?
                        ApiInfo->ApiTable->ArgCount : DFLT_TRACE_ARGS;

            for (i=0; i<ArgCount; i++)
                TraceEntry->Args[i] = Arg[i];

            ThreadStack = (PTHREAD_STACK)pTlsGetValue(TlsStack);
            TraceEntry->ThreadNum = ThreadStack->ThreadNum;
            TraceEntry->Level = (DWORD)((ThreadStack->Pointer - (DWORD_PTR)ThreadStack->Body))
                                  / FRAME_SIZE - 1;

            TraceEntryLen = sizeof(TRACE_ENTRY);

            if (ApiInfo->ApiTable && ApiInfo->ApiTable->ArgCount) {

                PAPI_TABLE ApiTable = ApiInfo->ApiTable;

                TraceString = (LPSTR)TraceEntry + sizeof(TRACE_ENTRY);
                TraceLimit = (LPSTR)TraceBuffer->Entry + TraceBuffer->Size;

                for (ULONG i=0; i<ApiTable->ArgCount; i++) {

                    switch( LOWORD(ApiTable->ArgType[i]) ) {
                        case T_DWORD:
                            break;

                        case T_DWORDPTR:
                            if (TraceEntry->Args[i]) {
                                TraceEntry->Args[i] = *(DWORD*)(TraceEntry->Args[i] + HIWORD(ApiTable->ArgType[i]));
                            }
                            break;

                        case T_DLONGPTR:
                            // Warning - this type wipes out the following arg to save a DWORDLONG
                            if (TraceEntry->Args[i]) {
                                dwPtr = (DWORD*) (TraceEntry->Args[i] + HIWORD(ApiTable->ArgType[i]));
                                TraceEntry->Args[i] = dwPtr[0];
                                TraceEntry->Args[i+1] = dwPtr[1];
                            }
                            break;


                        case T_LPSTRC:
                        case T_LPSTR:
                            //
                            // go read the string
                            //
                            {
                                if (HIWORD(TraceEntry->Args[i]) == 0)
                                    len = 0;
                                else if (ApiTable->ArgType[i] == T_LPSTRC)
                                    len = TraceEntry->Args[i+1];
                                else {
                                    TraceEntry->Args[i] += HIWORD(ApiTable->ArgType[i]);
                                    len = strlen( (LPSTR) TraceEntry->Args[i] );
                                }

                                if ( TraceString + len >= TraceLimit )
                                    len = 0;

                                if (len)
                                    memcpy(TraceString, (LPSTR)TraceEntry->Args[i], len);

                                TraceString[len] = 0;

                                TraceString += Align(sizeof(WCHAR), (len + 1));
                            }
                            break;

                        case T_LPWSTRC:
                        case T_LPWSTR:
                            //
                            // go read the string
                            //
                            {
                                if (HIWORD(TraceEntry->Args[i]) == 0)
                                    len = 0;
                                else if (ApiTable->ArgType[i] == T_LPSTRC)
                                    len = TraceEntry->Args[i+1];
                                else {
                                    TraceEntry->Args[i] += HIWORD(ApiTable->ArgType[i]);
                                    len = (wcslen( (LPWSTR) TraceEntry->Args[i] ));
                                }

                                if ( TraceString + len * sizeof(WCHAR) >= TraceLimit )
                                    len = 0;

                                if (len)
                                    memcpy( (LPWSTR)TraceString, (LPWSTR) TraceEntry->Args[i], len * sizeof(WCHAR) );

                                ((LPWSTR)TraceString)[len] = 0;

                                 TraceString += (len + 1) * sizeof(WCHAR);
                            }
                            break;

                        case T_UNISTR:
                        case T_OBJNAME:
                            //
                            // go read the string
                            //
                            {
                                PUNICODE_STRING pustr;
                                ULONG   len;

                                if (ApiTable->ArgType[i] == T_OBJNAME)
                                    pustr = ((POBJECT_ATTRIBUTES)TraceEntry->Args[i])->ObjectName;
                                else
                                    pustr = (PUNICODE_STRING)TraceEntry->Args[i];

                                len = pustr->Length + sizeof(WCHAR);
                                if (pustr != NULL && TraceString + len < TraceLimit) {
                                    wcsncpy( (LPWSTR)TraceString, pustr->Buffer, pustr->Length/sizeof(WCHAR));
                                    ((LPWSTR)TraceString)[pustr->Length/sizeof(WCHAR)] = 0;
                                    }
                                else {
                                    len = sizeof(WCHAR);
                                    ((LPWSTR)TraceString)[0] = 0;
                                }

                                TraceString += len;
                            }
                            break;
                    }
                }
                // align overall entry length to DWORDLONG
                TraceEntryLen = (DWORD)(Align(sizeof(DWORDLONG), TraceString - (LPSTR)TraceEntry));
            }
            TraceBuffer->Count += 1;
            TraceEntry->SizeOfStruct = TraceEntryLen;
            TraceBuffer->Offset += TraceEntryLen;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        ;
    }

     ReleaseMutex( ApiTraceMutex );
     pTlsSetValue( TlsReEnter, (LPVOID) 0 );
}

VOID
CalibrateThunk(
    VOID
    )
{
    int         i;
    DLL_INFO    CalibDllInfo;
    API_INFO    Calib1ApiInfo,Calib2ApiInfo;
    PUCHAR      NewThunks;
    ULONGLONG   MinTime;
    CHAR        debugbuf[128];

    // Setup calibration Dll
    strcpy(CalibDllInfo.Name, "Calib");
    CalibDllInfo.Enabled = TRUE;

    // Setup calibration Api
    Calib1ApiInfo.Count = 0;
    Calib1ApiInfo.NestCount = 0;
    Calib1ApiInfo.Time = 0;
    Calib1ApiInfo.CalleeTime = 0;
    Calib1ApiInfo.ThunkAddress = 0;
    Calib1ApiInfo.TraceEnabled = 0;
    Calib1ApiInfo.Address = (ULONG_PTR)Calib1Func;

    Calib2ApiInfo.Count = 0;
    Calib2ApiInfo.NestCount = 0;
    Calib2ApiInfo.Time = 0;
    Calib2ApiInfo.CalleeTime = 0;
    Calib2ApiInfo.ThunkAddress = 0;
    Calib2ApiInfo.TraceEnabled = 0;
    Calib2ApiInfo.Address = (ULONG_PTR)Calib2Func;

    // Create thunks
    NewThunks = CreateMachApiThunk( (PULONG_PTR)&Calib1Thunk, Thunks, &CalibDllInfo, &Calib1ApiInfo );
    NewThunks = CreateMachApiThunk( (PULONG_PTR)&Calib2Thunk, NewThunks, &CalibDllInfo, &Calib2ApiInfo );
    FlushInstructionCache( GetCurrentProcess(), (PVOID)Thunks, (DWORD)(NewThunks - Thunks));
    Thunks = NewThunks;

    ThunkOverhead = 0;
    ThunkCallOverhead = 0;

    // Call the calibration function via the thunk
    MinTime = 1000000;
    for (i=0; i<1000; i++) {

        Calib1ApiInfo.Time = 0;

        (*Calib1Thunk)();

        if (Calib1ApiInfo.Time < MinTime)
            MinTime = Calib1ApiInfo.Time;
    }

    // Take min time as the overhead
    ThunkOverhead = (DWORD)MinTime;

    MinTime = 1000000;
    for (i=0; i<1000; i++) {

        Calib2ApiInfo.Time = 0;

        (*Calib2Thunk)();

        if (Calib2ApiInfo.Time < MinTime)
            MinTime = Calib1ApiInfo.Time;
    }

    ThunkCallOverhead = (DWORD)MinTime;
}

// Null function for measuring overhead
VOID
Calib1Func(
    VOID
    )
{
    return;
}

// Calling function for measuring overhead
VOID
Calib2Func(
    VOID
    )
{
    (*Calib1Thunk)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\alias\alias.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alias.c

Abstract:

    alias utility

Author:

    Therese Stowell (thereses) 22-Mar-1990

Revision History:

--*/

#include <windows.h>
#include <conapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cvtoem.h>

BOOL fVerbose;

DWORD
DisplayAliases(
    char *ExeName
    );

DWORD
DisplayAlias(
    LPSTR AliasName,
    LPSTR ExeName
    );

DWORD
DoAliasFile(
    char * FileName,
    char * ExeName,
    BOOL fDelete
    );

DWORD
DoAlias(
    char *Source,
    char *Target,
    char *ExeName
    );

void
usage( void )
{
    fprintf( stderr, "Usage: ALIAS [-v] [-p programName] [-f filespec] [<source> <target>]\n" );
    fprintf( stderr, "             [-v] means verbose output.\n" );
    fprintf( stderr, "             [-d] means delete aliases.\n" );
    fprintf( stderr, "             [-p programName] specifies which image file name these alias\n" );
    fprintf( stderr, "                              definitions are for.  Default is CMD.EXE\n" );
    fprintf( stderr, "             [-f filespec] specifies a file which contains the aliases.\n" );
    exit( 1 );
}

DWORD
DoAlias(
    char *Source,
    char *Target,
    char *ExeName
    )
{
    if (!AddConsoleAlias( Source, Target, ExeName )) {
        if (!Target) {
            fprintf( stderr,
                     "ALIAS: Unable to delete alias - %s\n",
                     Source,
                     Target
                   );
            }
        else {
            fprintf( stderr,
                     "ALIAS: Unable to add alias - %s = %s\n",
                     Source,
                     Target
                   );
            }

        return ERROR_NOT_ENOUGH_MEMORY;
        }
    else
    if (fVerbose) {
        if (!Target) {
            fprintf( stderr, "Deleted alias - %s\n", Source );
            }
        else {
            fprintf( stderr, "Added alias - %s = %s\n", Source, Target );
            }
        }

    return NO_ERROR;
}


DWORD
DoAliasFile(
    char * FileName,
    char * ExeName,
    BOOL fDelete
    )
{
    DWORD rc;
    FILE *fh;
    char LineBuffer[ 256 ], *Source, *Target, *s;

    if (!(fh = fopen( FileName, "rt" ))) {
        fprintf( stderr, "ALIAS: Unable to open file - %s\n", FileName );
        return ERROR_FILE_NOT_FOUND;
        }

    if (fVerbose) {
        fprintf( stderr,
                 "ALIAS: %s aliases defined in %s\n",
                 fDelete ? "Deleting" : "Loading",
                 FileName
               );
        }
    while (s = fgets( LineBuffer, sizeof( LineBuffer ), fh )) {
        while (*s <= ' ') {
            if (!*s) {
                break;
                }
            s++;
            }

        if (!*s || (*s == '/' && s[1] == '/')) {
            continue;
            }

        Source = s;
        while (*s > ' ') {
            s++;
            }
        *s++ = '\0';

        while (*s <= ' ') {
            if (!*s) {
                break;
                }
            s++;
            }

        Target = s;
        s += strlen( s );
        while (*s <= ' ') {
            *s-- = '\0';
            if (s < Target) {
                break;
                }
            }

        rc = DoAlias( Source, fDelete ? NULL : Target, ExeName );
        if (rc != NO_ERROR) {
            break;
            }
        }

    return rc;
}

DWORD
DisplayAlias(
    LPSTR AliasName,
    LPSTR ExeName
    )
{
    DWORD cb;
    CHAR AliasBuffer[512];

    if (cb = GetConsoleAlias( AliasName, AliasBuffer, sizeof( AliasBuffer ), ExeName )) {
        printf( "%-16s=%s\n", AliasName, AliasBuffer );
        return NO_ERROR;
        }
    else {
        printf( "%-16s *** Unable to read value of alias ***\n",
                AliasName
              );
        return ERROR_ENVVAR_NOT_FOUND;
        }
}

int __cdecl
CmpNamesRoutine(
    const VOID *Element1,
    const VOID *Element2
    )
{
    return( strcmp( *(LPSTR *)Element1, *(LPSTR *)Element2 ) );
}

DWORD
DisplayAliases(
    char *ExeName
    )
{
    DWORD cb, rc, nExeNames, nAliases, iExeName, iAlias;
    LPSTR FreeMem1, FreeMem2, AliasName, AliasValue, s, *SortedExeNames, *SortedAliasNames;

    if (ExeName == NULL) {
        cb = GetConsoleAliasExesLength();
        if (cb == 0) {
            return ERROR_ENVVAR_NOT_FOUND;
            }

        if (!(FreeMem1 = malloc( cb+2 ))) {
            fprintf( stderr, "ALIAS: Not enough memory for EXE names.\n" );
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        ExeName = FreeMem1;
        if (!GetConsoleAliasExes( ExeName, cb )) {
            fprintf( stderr, "ALIAS: Unable to read alias EXE names.\n" );
            return ERROR_ENVVAR_NOT_FOUND;
            }

        ExeName[ cb ] = '\0';
        ExeName[ cb+1 ] = '\0';

        nExeNames = 0;
        s = ExeName;
        while (*s) {
            _strupr( s );
            nExeNames++;
            while (*s++) {
                }
            }

        SortedExeNames = malloc( nExeNames * sizeof( LPSTR ) );
        if (SortedExeNames == NULL) {
            fprintf( stderr, "ALIAS: Not enough memory to sort .EXE names.\n" );
            }
        else {
            iExeName = 0;
            s = ExeName;
            while (*s) {
                SortedExeNames[ iExeName++ ] = s;
                while (*s++) {
                    }
                }

            qsort( SortedExeNames,
                   nExeNames,
                   sizeof( LPSTR ),
                   CmpNamesRoutine
                 );

            iExeName = 0;
            }

        }
    else {
        SortedExeNames = NULL;
        FreeMem1 = NULL;
        }

    rc = NO_ERROR;
    while (rc == NO_ERROR && *ExeName) {
        if (SortedExeNames != NULL) {
            ExeName = SortedExeNames[ iExeName++ ];
            }

        cb = GetConsoleAliasesLength(ExeName);
        if (cb == 0) {
            printf( "No aliases defined for %s in current console.\n", ExeName );
            }
        else {
            if (!(FreeMem2 = malloc( cb+2 ))) {
                fprintf( stderr, "ALIAS: Not enough memory for alias names.\n" );
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }

            SortedAliasNames = NULL;
            AliasName = FreeMem2;
            if (GetConsoleAliases( AliasName, cb, ExeName )) {
                AliasName[ cb ] = '\0';
                AliasName[ cb+1 ] = '\0';
                nAliases = 0;
                s = AliasName;
                while (*s) {
                    nAliases++;
                    while (*s++) {
                        }
                    }

                SortedAliasNames = malloc( nAliases * sizeof( LPSTR ) );
                if (SortedAliasNames == NULL) {
                    fprintf( stderr, "ALIAS: Not enough memory to sort alias names.\n" );
                    }
                else {
                    iAlias = 0;
                    s = AliasName;
                    while (*s) {
                        SortedAliasNames[ iAlias++ ] = s;
                        while (*s++) {
                            }
                        }

                    qsort( SortedAliasNames,
                           nAliases,
                           sizeof( LPSTR ),
                           CmpNamesRoutine
                         );

                    iAlias = 0;
                    }

                printf( "Dumping all defined aliases for %s.\n", ExeName );
                while (*AliasName) {
                    if (SortedAliasNames != NULL) {
                        AliasName = SortedAliasNames[ iAlias++ ];
                        }
                    AliasValue = AliasName;

                    while (*AliasValue) {
                        if (*AliasValue == '=') {
                            *AliasValue++ = '\0';
                            break;
                            }
                        else {
                            AliasValue++;
                            }
                        }

                    printf( "    %-16s=%s\n", AliasName, AliasValue );
                    if (SortedAliasNames != NULL) {
                        if (iAlias < nAliases) {
                            AliasName = " ";
                            }
                        else {
                            AliasName = "";
                            }
                        }
                    else {
                        AliasName = AliasValue;
                        while (*AliasName++) {
                            ;
                            }
                        }
                    }
                }
            else {
                fprintf( stderr, "ALIAS: unable to read aliases for %s.\n", ExeName );
                rc = ERROR_ENVVAR_NOT_FOUND;
                }

            free( FreeMem2 );
            if (SortedAliasNames != NULL) {
                free( SortedAliasNames );
                }
            }

        if (SortedExeNames != NULL) {
            if (iExeName < nExeNames) {
                ExeName = " ";
                }
            else {
                ExeName = "";
                }
            }
        else {
            while (*ExeName++) {
                ;
                }
            }
        }

    if (SortedExeNames != NULL) {
        free( SortedExeNames );
        }

    if (FreeMem1) {
        free( FreeMem1 );
        }

    return rc;
}

DWORD __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD rc;
    char *s, *s1, *AliasName;
    char *ExeName;
    BOOL fDelete;
    BOOL DisplayAllAliases;

    ConvertAppToOem( argc,argv );
    AliasName = NULL;
    ExeName = NULL;
    fVerbose = FALSE;
    fDelete = FALSE;
    DisplayAllAliases = TRUE;
    rc = NO_ERROR;
    while (rc == NO_ERROR && --argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( *s ) {
                    case '?':
                    case 'h':
                    case 'H':
                        usage();
                        break;

                    case 'd':
                    case 'D':
                        fDelete = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'p':
                    case 'P':
                        if (!--argc) {
                            fprintf( stderr, "ALIAS: Argument to -p switch missing.\n" );
                            usage();
                            }

                        if (ExeName != NULL) {
                            free( ExeName );
                            ExeName = NULL;
                            }
                        s1 = *++argv;
                        ExeName = calloc( 1, strlen( s1 )+2 );
                        if (ExeName) {
                            strcpy( ExeName, s1 );
                        }
                        break;

                    case 'f':
                    case 'F':
                        if (!--argc) {
                            fprintf( stderr, "ALIAS: Argument to -f switch missing.\n" );
                            usage();
                            }

                        DisplayAllAliases = FALSE;
                        rc = DoAliasFile( *++argv, ExeName ? ExeName : "CMD.EXE", fDelete );
                        break;

                    default:
                        fprintf( stderr, "ALIAS: invalid switch /%c\n", *s );
                        usage();
                        break;
                    }
                }
            }
        else {
            DisplayAllAliases = FALSE;
            if (AliasName == NULL) {
                if (fDelete) {
                    rc = DoAlias( s, NULL, ExeName ? ExeName : "CMD.EXE" );
                    }
                else {
                    AliasName = s;
                    }
                }
            else {
                if (fDelete) {
                    rc = DoAlias( AliasName, NULL, ExeName ? ExeName : "CMD.EXE" );
                    AliasName = s;
                    }
                else {
                    rc = DoAlias( AliasName, s, ExeName ? ExeName : "CMD.EXE" );
                    AliasName = NULL;
                    }
                }
            }
        }

    if (rc == NO_ERROR) {
        if (AliasName != NULL) {
            if (fDelete) {
                rc = DoAlias( AliasName, NULL, ExeName ? ExeName : "CMD.EXE" );
                }
            else {
                rc = DisplayAlias( AliasName, ExeName ? ExeName : "CMD.EXE" );
                }
            }
        else
        if (DisplayAllAliases) {
            rc = DisplayAliases( ExeName );
            }
        }

    if (ExeName != NULL) {
        free( ExeName );
        ExeName = NULL;
        }

    exit( rc );
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apidll\i386\thunk.asm ===
; Copyright (c) 1995  Microsoft Corporation
;
; Module Name:
;
;     thunk.s
;
; Abstract:
;
;     Implements the API thunk that gets executed for all
;     re-directed APIS.
;
; Author:
;
;     Wesley Witt (wesw) 28-June-1995
;
; Environment:
;
;     User Mode
;

.386p
include ks386.inc
include callconv.inc

TRACE   equ  0

EXTRNP  _HandleDynamicDllLoadA,2
EXTRNP  _HandleDynamicDllLoadW,2
EXTRNP  _HandleDynamicDllFree,1
EXTRNP  _HandleGetProcAddress,1
EXTRNP  _HandleRegisterClassA,1
EXTRNP  _HandleRegisterClassW,1
EXTRNP  _HandleSetWindowLong,3
EXTRNP  _QueryPerformanceCounter,1
EXTRNP  _ApiTrace,9
EXTRNP  _GetApiInfo,4


extrn   _FastCounterAvail:DWORD
extrn   _ApiCounter:DWORD
extrn   _ApiTimingEnabled:DWORD
extrn   _ApiTraceEnabled:DWORD
extrn   _pTlsGetValue:DWORD
extrn   _pTlsSetValue:DWORD
extrn   _pGetLastError:DWORD
extrn   _pSetLastError:DWORD
extrn   _TlsReEnter:DWORD
extrn   _TlsStack:DWORD
extrn   _ThunkOverhead:DWORD
extrn   _ThunkCallOverhead:DWORD

if TRACE
extrn   _dprintf:NEAR
endif

APITYPE_NORMAL          equ      0
APITYPE_LOADLIBRARYA    equ      1
APITYPE_LOADLIBRARYW    equ      2
APITYPE_FREELIBRARY     equ      3
APITYPE_REGISTERCLASSA  equ      4
APITYPE_REGISTERCLASSW  equ      5
APITYPE_GETPROCADDRESS  equ      6
APITYPE_SETWINDOWLONG   equ      7
APITYPE_WNDPROC         equ      8
APITYPE_INVALID         equ      9

DllEnabledOffset          equ     52

ApiInfoAddressOffset      equ      4
ApiInfoCountOffset        equ     12
ApiInfoTimeOffset         equ     16
ApiInfoCalleeTimeOffset   equ     24
ApiInfoNestCountOffset    equ     32
ApiInfoTraceEnabled       equ     36
ApiInfoTableOffset        equ     40

ApiTableCountOffset       equ     8

API_TRACE                 equ     1
API_FULLTRACE             equ     2

LastErrorSave             equ      0
EdiSave                   equ      4
EsiSave                   equ      8
EdxSave                   equ     12
EcxSave                   equ     16
EbxSave                   equ     20
EaxSave                   equ     24
ApiFlagSave               equ     28
DllInfoSave               equ     32
ApiInfoSave               equ     36
RetAddrSave               equ     40

StackSize                 equ     44

EbpFrm                    equ      0
DllInfoFrm                equ      4
ApiInfoFrm                equ      8
ApiFlagFrm                equ     12
ApiBiasFrm                equ     16
RetAddrFrm                equ     20
LastErrorFrm              equ     24
Arg0Frm                   equ     28
Arg1Frm                   equ     32
Arg2Frm                   equ     36
Arg3Frm                   equ     40
Arg4Frm                   equ     44
Arg5Frm                   equ     48
Arg6Frm                   equ     52
Arg7Frm                   equ     56
OverheadTimeFrm           equ     64
FuncTimeFrm               equ     72
CalleeTimeFrm             equ     80
TempTimeFrm               equ     88

FrameSize                 equ     96

;
; Routine Description:
;
;     This MACRO gets a performance counter value.
;     If we are running on a uni-processor pentium
;     then we can use the rdtsc instruction.  Otherwise
;     we must use the QueryPerformanceCounter API.
;
; Arguments:
;
;     CounterOffset     - the offset from ebp where the
;                         counter data is to be stored.
;
; Return Value:
;
;     None.
;
GET_PERFORMANCE_COUNTER macro CounterOffset
local   DoPentium,PentiumExit
        mov     eax,[_FastCounterAvail]
        mov     eax,[eax]
        or      eax,eax
        jnz     DoPentium
        mov     eax,ebp
        add     eax,CounterOffset
        push    eax
        call    _QueryPerformanceCounter@4
        jmp     PentiumExit
DoPentium:
        db      0fh,31h                 ; RDTSC instruction
        mov     [ebp+CounterOffset],eax
        mov     [ebp+CounterOffset+4],edx
PentiumExit:
        endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

if TRACE
Msg1 db 'ApiMonThunk()         0x%08x',0ah,00
Msg2 db 'ApiMonThunkComplete() 0x%08x',0ah,00
endif


;
; Routine Description:
;
;     This function is jumped to after a monitored
;     API has completed.  Here we do our cleanup
;     and then branch to the caller's return address.
;
; Arguments:
;
;     ebp - points to the api's frame on our parallel stack
;     eax - return value
;     edx - return value
;
; Return Value:
;
;     None.
;
cPublicProc _ApiMonThunkComplete,0

        ;
        ; save registers
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

if TRACE
        ;
        ; trace the call
        ;
        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoAddressOffset]
        push    eax
        push    offset FLAT:Msg2
        call    _dprintf
        add     esp,8
endif
        ;
        ; check for counting enabled
        ;
        mov    edx,[ebp+DllInfoFrm]
        mov    eax,[edx+DllEnabledOffset]
        or     eax,eax
        jz     NoCounting

        ;
        ; decrement nesting count for this api
        ;
        mov     eax,[ebp+ApiInfoFrm]
        dec     dword ptr [eax+ApiInfoNestCountOffset]

        ;
        ; Compute total function time
        ;
        GET_PERFORMANCE_COUNTER TempTimeFrm

        mov     eax,[ebp+TempTimeFrm]
        mov     edx,[ebp+TempTimeFrm+4]

        sub     eax,[ebp+FuncTimeFrm]
        sbb     edx,[ebp+FuncTimeFrm+4]

        sub     eax,_ThunkOverhead
        sbb     edx,0

        mov     [ebp+FuncTimeFrm],eax
        mov     [ebp+FuncTimeFrm+4],edx

        ;
        ; Remove function time from our overhead time
        ; by adding advancing the overhead start time
        ;
        add     [ebp+OverheadTimeFrm],eax
        adc     [ebp+OverheadTimeFrm+4],edx

        ;
        ; accumulate function time for the API
        ;
        mov     edi,[ebp+ApiInfoFrm]
        add     [edi+ApiInfoTimeOffset],eax
        adc     [edi+ApiInfoTimeOffset+4],edx
        
        ;
        ; add time to callee time of parent frame
        ;
        add     [ebp - FrameSize + CalleeTimeFrm],eax
        adc     [ebp - FrameSize + CalleeTimeFrm+4],edx

        ;
        ; accumulate own callee time for the API
        ;
        mov     eax, [ebp+CalleeTimeFrm]
        mov     edx, [ebp+CalleeTimeFrm+4]
        add     [edi+ApiInfoCalleeTimeOffset],eax
        adc     [edi+ApiInfoCalleeTimeOffset+4],edx

NoCounting:
        ;
        ; handle load library and get process address specialy
        ;
        mov     ecx,[ebp+ApiFlagFrm]
        or      ecx,ecx
        jz      ThunkNormal

        ;
        ; branch to the correct handler
        ;
        cmp     ecx,APITYPE_LOADLIBRARYA
        jz      DoLoadLibraryA
        cmp     ecx,APITYPE_LOADLIBRARYW
        jz      DoLoadLibraryW
        cmp     ecx,APITYPE_FREELIBRARY
        jz      DoFreeLibrary
        cmp     ecx,APITYPE_GETPROCADDRESS
        jz      DoGetProcAddress
        cmp     ecx,APITYPE_WNDPROC     ; no tracing for wnd procs yet
        jz      NoTracing
        jmp     ThunkNormal

DoFreeLibrary:
        push    [ebp+Arg0Frm]
        call    _HandleDynamicDllFree@4
        jmp     ThunkNormal

DoLoadLibraryW:
        push    [ebp+Arg0Frm]
        push    [esp+EaxSave+4]
        call    _HandleDynamicDllLoadW@8
        jmp     ThunkNormal

DoLoadLibraryA:
        push    [ebp+Arg0Frm]
        push    [esp+EaxSave+4]
        call    _HandleDynamicDllLoadA@8
        jmp     ThunkNormal

DoGetProcAddress:
        push    [esp+EaxSave]
        call    _HandleGetProcAddress@4
        mov     [esp+EaxSave],eax
        jmp     ThunkNormal

ThunkNormal:

        ;
        ; do the api tracing?
        ;
        mov     eax,[_ApiTraceEnabled]
        mov     eax,[eax]
        or      eax, eax
        jz      NoTracing

        mov     eax,[ebp+DllInfoFrm]
        mov     eax,[eax+DllEnabledOffset]
        or      eax,eax
        jz      NoTracing

        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoTraceEnabled]
        or      eax,eax
        jz      NoTracing

        ;
        ; trace the api
        ;
        mov     eax,[esp+EaxSave]    ; get ret value
        push    [esp+LastErrorSave]  ; last error value
        push    [ebp+FuncTimeFrm+4]  ; function duration
        push    [ebp+FuncTimeFrm]

        push    [ebp+TempTimeFrm+4]  ; exit time
        push    [ebp+TempTimeFrm]

        push    [ebp+RetAddrFrm]     ; caller's address
        push    eax                  ; return value
        lea     eax,[ebp+Arg0Frm]    ; parameter array
        push    eax
        push    [ebp+ApiInfoFrm]     ; apiinfo pointer
        call    _ApiTrace@36

NoTracing:

        ;
        ; Compute our overhead time
        ;
        GET_PERFORMANCE_COUNTER TempTimeFrm

        mov     eax,[ebp+TempTimeFrm]
        mov     edx,[ebp+TempTimeFrm+4]

        sub     eax,[ebp+OverheadTimeFrm]
        sbb     edx,[ebp+OverheadTimeFrm+4]

        add     eax,_ThunkCallOverhead
        adc     edx,0

        ;
        ; Subtract from parent's function time
        ; by advancing the function start time
        ;
        add     [ebp - FrameSize + FuncTimeFrm],eax
        adc     [ebp - FrameSize + FuncTimeFrm+4],edx

        ;
        ; destroy the frame on the stack
        ;
        push    _TlsStack
        call    _pTlsGetValue
        mov     [eax],ebp

        ;
        ; reset the last error value (already on the stack)
        ;
        call    _pSetLastError
             
        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        push    [ebp+RetAddrFrm]
        mov     ebp,[ebp]

        ;
        ; finally branch back to the caller
        ;
        ret

stdENDP _ApiMonThunkComplete


;
; Routine Description:
;
;     This function is the entry point for the api
;     monitor thunk.
;
; Arguments:
;
;     [esp+0]  - API flag
;     [esp+4]  - DLLINFO pointer
;     [esp+8]  - APIINFO pointer
;
; Return Value:
;
;     None.
;
cPublicProc _ApiMonThunk,0

        ;
        ; save regs
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

        ;
        ; get the reentry flag
        ;
        push    _TlsReEnter
        call    _pTlsGetValue

        ;
        ; don't enter if disallow flag is set
        ;
        or      eax,eax
        jz      ThunkOk

BadStack:
        ;
        ; replace ApiInfo pointer with Api address
        ; so we can ret to it
        ;
        mov     ebx,[esp+ApiInfoSave]
        mov     eax,dword ptr [ebx+ApiInfoAddressOffset]
        mov     [esp+ApiInfoSave],eax

        ;
        ; reset the last error value
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8        ; dump ApiFlag & DllInfo space
        ret                 ; jmp to real Api 

ThunkOk:

        ;
        ; get the parallel stack pointer
        ;
        push    _TlsStack
        call    _pTlsGetValue
        or      eax,eax
        jz      BadStack

        ;
        ; setup the frame pointer
        ;
        mov     edx,[eax]
        mov     [edx],ebp
        mov     ebp,edx

        ;
        ; create a frame on the stack by advancing the pointer
        ;
        add     edx,FrameSize
        mov     [eax],edx

        ;
        ; clear ApiBias, entry from _penter uses bias
        ;
        mov     [ebp+ApiBiasFrm],0

Thunk_Middle:

        ;
        ; get the arguments from the mini-thunk
        ;
        mov     eax,[esp+ApiFlagSave]
        mov     [ebp+ApiFlagFrm],eax

        mov     eax,[esp+DllInfoSave]
        mov     [ebp+DllInfoFrm],eax

        mov     eax,[esp+RetAddrSave]     
        mov     [ebp+RetAddrFrm],eax

        mov     eax,[esp+ApiInfoSave]
        mov     [ebp+ApiInfoFrm],eax

        ;
        ; save the real arguments
        ;
        mov     eax,[esp+StackSize]
        mov     [ebp+Arg0Frm],eax

        mov     eax,[esp+StackSize+4]
        mov     [ebp+Arg1Frm],eax

        mov     eax,[esp+StackSize+8]
        mov     [ebp+Arg2Frm],eax

        mov     eax,[esp+StackSize+12]
        mov     [ebp+Arg3Frm],eax

        mov     eax,[esp+StackSize+16]
        mov     [ebp+Arg4Frm],eax

        mov     eax,[esp+StackSize+20]
        mov     [ebp+Arg5Frm],eax

        mov     eax,[esp+StackSize+24]
        mov     [ebp+Arg6Frm],eax

        mov     eax,[esp+StackSize+28]
        mov     [ebp+Arg7Frm],eax

        ;   
        ; zero the callee time
        ;
        mov     [ebp+CalleeTimeFrm],0
        mov     [ebp+CalleeTimeFrm+4],0

        ;
        ; start the overhead timer, because it is variable from here on
        ;
        GET_PERFORMANCE_COUNTER OverheadTimeFrm

        ;
        ; Do special API processing
        ;
        mov     eax,[ebp+ApiFlagFrm]
        or      eax,eax
        jz      ThunkNotSpecial

        cmp     eax,APITYPE_REGISTERCLASSA
        jz      DoRegisterClassA
        cmp     eax,APITYPE_REGISTERCLASSW
        jz      DoRegisterClassW
        cmp     eax,APITYPE_SETWINDOWLONG
        jz      DoSetWindowLong
        jmp     ThunkNotSpecial

DoRegisterClassA:
        push    [ebp+Arg0Frm]  
        call    _HandleRegisterClassA@4
        jmp     ThunkNotSpecial
        
DoRegisterClassW:
        push    [ebp+Arg0Frm]
        call    _HandleRegisterClassW@4
        jmp     ThunkNotSpecial

DoSetWindowLong:
        push    [ebp+Arg2Frm]
        push    [ebp+Arg1Frm]
        push    [ebp+Arg0Frm]
        call    _HandleSetWindowLong@12
        mov     [esp+StackSize+8],eax    ; Replace new long value parameter

ThunkNotSpecial:
        ;      
        ; change the return address to point to completion routine
        ;
        mov     [esp+RetAddrSave],_ApiMonThunkComplete

if TRACE
        ;
        ; trace the call
        ;
        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoAddressOffset]
        push    eax
        push    offset FLAT:Msg1
        call    _dprintf
        add     esp,8
endif

        ;
        ; check to see if api counting is enabled
        ; if not then bypass the counting code
        ;
        mov     eax,[ebp+DllInfoFrm]
        mov     eax,[eax+DllEnabledOffset]
        or      eax, eax
        jz      ThunkBypass

        ;
        ; increment the api's counters
        ;
        mov     eax,[ebp+ApiInfoFrm]
        inc     dword ptr [eax+ApiInfoCountOffset]
        inc     dword ptr [eax+ApiInfoNestCountOffset]

        ;
        ; increment the global api counter
        ;
        mov     eax,_ApiCounter
        inc     dword ptr [eax]

ThunkBypass:

        ;
        ; Replace ApiInfo pointer with ApiAddr (+bias)
        ;
        mov     ebx,[ebp+ApiInfoFrm]
        mov     eax,dword ptr [ebx+ApiInfoAddressOffset]
        mov     ecx,[ebp+ApiBiasFrm]
        add     eax,ecx
        mov     [esp+ApiInfoSave],eax

        ;
        ; start the function timer here
        ;
        GET_PERFORMANCE_COUNTER FuncTimeFrm

        ;
        ; reset the last error value (already on stack)
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8        ; dump ApiFlag & DllInfo from stack
        ret                 ; jump to Api 

stdENDP _ApiMonThunk


;
; Routine Description:
;
;     This function is called when an application
;     is compiled with -Gh.  It performs the same
;     function as ApiMonThunk does for non-instrumented
;     code.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
align           dword
public          __penter
__penter        proc

        ;
        ; allot space on stack for two api thunk parameters
        ; the third will replace the return address
        ;
        sub     sp,8

        ;
        ; save regs
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

        ;
        ; get the parallel stack pointer
        ;
        push    _TlsStack
        call    _pTlsGetValue
        or      eax,eax
        jnz     Good_Stack

        ;
        ; reset the last error value
        ;
        call    _pSetLastError

        ;
        ; restore the stack
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8

        ;
        ; jump to the real api
        ;
        ret

Good_Stack:
        ;
        ; setup the frame pointer
        ;
        mov     edx,[eax]
        mov     [edx],ebp
        mov     ebp,edx

        ;
        ; create a frame on the stack
        ;
        add     edx,FrameSize
        mov     [eax],edx

        ;
        ; get Api info from the return address, which is really
        ; the address of the function that is being profiled
        ;
        mov     eax,[esp+ApiInfoSave]   ; this is really the return to the Api
        mov     [ebp+RetAddrFrm],eax    ; save for exit in case Api not found
        lea     ecx,[esp+ApiFlagSave]
        push    eax
        push    ecx
        add     ecx,4
        push    ecx
        add     ecx,4
        push    ecx
        call    _GetApiInfo@16

        or      eax,eax
        jz      Api_NotFound

        mov     [ebp+ApiBiasFrm],5
        jmp     Thunk_Middle

Api_NotFound:

        ;
        ; put back saved return address
        ;
        mov     eax,[ebp+RetAddrFrm]
        mov     [esp+ApiInfoSave],eax

        ;
        ; tear down this frame
        ;
        push    _TlsStack
        call    _pTlsGetValue
        mov     [eax],ebp
        ;
        ; reset the last error value (already on the stack)
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        mov     ebp,[ebp]

        ;
        ; discard unused api thunk space
        ;
        add     esp,8

        ;
        ; jump to the real api
        ;
        ret

__penter        endp


_TEXT   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apidll\apitable.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidll.cpp

Abstract:

    This file implements the non-architecture specific
    code for the api monitor trojan/support dll.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#include "apidllp.h"
#pragma hdrstop

//
// api tables
//

API_TABLE API_Kernel32[] =
{
    { "_hread", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_hwrite", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "_lclose", T_DWORD, 1, {T_DWORD} },
    { "_lcreat", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "_llseek", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_lopen", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "_lread", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_lwrite", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "AddAtomA", T_DWORD, 1, {T_LPSTR} },
    { "AddAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "AreFileApisANSI", T_DWORD, 1, {T_DWORD} },
    { "BackupRead", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BackupSeek", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BackupWrite", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "Beep", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "BeginUpdateResourceA", T_HANDLE, 2, {T_LPSTR, T_DWORD} },
    { "BeginUpdateResourceW", T_HANDLE, 2, {T_LPWSTR, T_DWORD} },
    { "BuildCommDCBA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "BuildCommDCBAndTimeoutsA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "BuildCommDCBAndTimeoutsW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "BuildCommDCBW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CallNamedPipeA", T_DWORD, 7, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CallNamedPipeW", T_DWORD, 7, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CancelIo", T_DWORD, 1, {T_HANDLE} },
    { "CancelWaitableTimer", T_DWORD, 1, {T_HANDLE} },
    { "ClearCommBreak", T_DWORD, 1, {T_HANDLE} },
    { "ClearCommError", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "CloseHandle", T_DWORD, 1, {T_HANDLE} },
    { "CommConfigDialogA", T_DWORD, 3, {T_LPSTR, T_HWND, T_DWORD} },
    { "CommConfigDialogW", T_DWORD, 3, {T_LPWSTR, T_HWND, T_DWORD} },
    { "CompareFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ConnectNamedPipe", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "ContinueDebugEvent", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "ConvertThreadToFiber", T_DWORD, 1, {T_DWORD} },
    { "CopyFileA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CopyFileExA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyFileExW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyFileW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CreateDirectoryExA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateDirectoryExW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CreateEventA", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateEventW", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateFiber", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreateFileA", T_HANDLE, 7, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HANDLE} },
    { "CreateFileMappingA", T_HANDLE, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateFileMappingW", T_HANDLE, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateFileW", T_HANDLE, 7, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HANDLE} },
    { "CreateIoCompletionPort", T_HANDLE, 4, {T_HANDLE, T_HANDLE, T_DWORD, T_DWORD} },
    { "CreateMailslotA", T_HANDLE, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateMailslotW", T_HANDLE, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateMutexA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateMutexW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateNamedPipeA", T_HANDLE, 8, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateNamedPipeW", T_HANDLE, 8, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreatePipe", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateProcessA", T_DWORD, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateProcessW", T_DWORD, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateRemoteThread", T_HANDLE, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateSemaphoreA", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateSemaphoreW", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateTapePartition", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateThread", T_HANDLE, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWaitableTimerA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateWaitableTimerW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "DebugActiveProcess", T_DWORD, 1, {T_DWORD} },
    { "DebugBreak", T_DWORD, 1, {T_DWORD} },
    { "DefineDosDeviceA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_LPSTR} },
    { "DefineDosDeviceW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "DeleteAtom", T_DWORD, 1, {T_DWORD} },
    { "DeleteCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "DeleteFiber", T_DWORD, 1, {T_DWORD} },
    { "DeleteFileA", T_DWORD, 1, {T_LPSTR} },
    { "DeleteFileW", T_DWORD, 1, {T_LPWSTR} },
    { "DeviceIoControl", T_DWORD, 8, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DisableThreadLibraryCalls", T_DWORD, 1, {T_DWORD} },
    { "DisconnectNamedPipe", T_DWORD, 1, {T_HANDLE} },
    { "DosDateTimeToFileTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "DuplicateHandle", T_DWORD, 7, {T_HANDLE, T_HANDLE, T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "EndUpdateResourceA", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "EndUpdateResourceW", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "EnterCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "EnumResourceLanguagesA", T_DWORD, 5, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumResourceLanguagesW", T_DWORD, 5, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumResourceNamesA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumResourceNamesW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumResourceTypesA", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EnumResourceTypesW", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EraseTape", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "EscapeCommFunction", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "ExitProcess", T_DWORD, 1, {T_DWORD} },
    { "ExitThread", T_DWORD, 1, {T_DWORD} },
    { "ExpandEnvironmentStringsA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "ExpandEnvironmentStringsW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "FatalAppExitA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "FatalAppExitW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "FatalExit", T_DWORD, 1, {T_DWORD} },
    { "FileTimeToDosDateTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "FileTimeToLocalFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FileTimeToSystemTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FindAtomA", T_DWORD, 1, {T_LPSTR} },
    { "FindAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "FindClose", T_DWORD, 1, {T_HANDLE} },
    { "FindCloseChangeNotification", T_DWORD, 1, {T_HANDLE} },
    { "FindFirstChangeNotificationA", T_HANDLE, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "FindFirstChangeNotificationW", T_HANDLE, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "FindFirstFileA", T_HANDLE, 2, {T_LPSTR, T_DWORD} },
    { "FindFirstFileExA", T_HANDLE, 6, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FindFirstFileExW", T_HANDLE, 6, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FindFirstFileW", T_HANDLE, 2, {T_LPWSTR, T_DWORD} },
    { "FindNextChangeNotification", T_DWORD, 1, {T_HANDLE} },
    { "FindNextFileA", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "FindNextFileW", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "FindResourceA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_LPSTR} },
    { "FindResourceExA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "FindResourceExW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "FindResourceW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "FlushFileBuffers", T_DWORD, 1, {T_HANDLE} },
    { "FlushInstructionCache", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "FlushViewOfFile", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FormatMessageA", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "FormatMessageW", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "FreeEnvironmentStringsA", T_DWORD, 1, {T_LPSTR} },
    { "FreeEnvironmentStringsW", T_DWORD, 1, {T_LPWSTR} },
    { "FreeLibrary", T_DWORD, 1, {T_DWORD} },
    { "FreeLibraryAndExitThread", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FreeResource", T_DWORD, 1, {T_HGLOBAL} },
    { "GetAtomNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetAtomNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetBinaryTypeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetBinaryTypeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetCommandLineA", T_LPSTR, 1, {T_DWORD} },
    { "GetCommandLineW", T_LPWSTR, 1, {T_DWORD} },
    { "GetCommConfig", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetCommMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommModemStatus", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommProperties", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommState", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommTimeouts", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCompressedFileSizeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetCompressedFileSizeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetCurrentDirectoryA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetCurrentDirectoryW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetCurrentProcess", T_HANDLE, 1, {T_DWORD} },
    { "GetCurrentProcessId", T_DWORD, 1, {T_DWORD} },
    { "GetCurrentThread", T_HANDLE, 1, {T_DWORD} },
    { "GetCurrentThreadId", T_DWORD, 1, {T_DWORD} },
    { "GetDefaultCommConfigA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "GetDefaultCommConfigW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceA", T_DWORD, 5, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceExA", T_DWORD, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceExW", T_DWORD, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceW", T_DWORD, 5, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDriveTypeA", T_DWORD, 1, {T_LPSTR} },
    { "GetDriveTypeW", T_DWORD, 1, {T_LPWSTR} },
    { "GetEnvironmentStrings", T_LPSTR, 1, {T_DWORD} },
    { "GetEnvironmentStringsW", T_LPWSTR, 1, {T_DWORD} },
    { "GetEnvironmentVariableA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetEnvironmentVariableW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetExitCodeProcess", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetExitCodeThread", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileAttributesA", T_DWORD, 1, {T_LPSTR} },
    { "GetFileAttributesExA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "GetFileAttributesExW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetFileAttributesW", T_DWORD, 1, {T_LPWSTR} },
    { "GetFileInformationByHandle", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileSize", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileTime", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetFileType", T_DWORD, 1, {T_HANDLE} },
    { "GetFullPathNameA", T_DWORD, 4, {T_LPSTR, T_DWORD, T_LPSTR, T_LPSTR} },
    { "GetFullPathNameW", T_DWORD, 4, {T_LPWSTR, T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "GetHandleInformation", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetLastError", T_DWORD, 1, {T_DWORD} },
    { "GetLocalTime", T_DWORD, 1, {T_DWORD} },
    { "GetLogicalDrives", T_DWORD, 1, {T_DWORD} },
    { "GetLogicalDriveStringsA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetLogicalDriveStringsW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetMailslotInfo", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetModuleFileNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetModuleFileNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetModuleHandleA", T_DWORD, 1, {T_LPSTR} },
    { "GetModuleHandleW", T_DWORD, 1, {T_LPWSTR} },
    { "GetNamedPipeHandleStateA", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetNamedPipeHandleStateW", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetNamedPipeInfo", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetOverlappedResult", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPriorityClass", T_DWORD, 1, {T_HANDLE} },
    { "GetPrivateProfileIntA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileIntW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileSectionA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileSectionNamesA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileSectionNamesW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileSectionW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileStringA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileStringW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileStructA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileStructW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_LPWSTR} },
    { "GetProcAddress", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetProcessAffinityMask", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetProcessHeap", T_HANDLE, 1, {T_DWORD} },
    { "GetProcessHeaps", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetProcessShutdownParameters", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessTimes", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetProcessVersion", T_DWORD, 1, {T_DWORD} },
    { "GetProcessWorkingSetSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetProfileIntA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileIntW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetProfileSectionA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileSectionW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetProfileStringA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileStringW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetQueuedCompletionStatus", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetShortPathNameA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetShortPathNameW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetStartupInfoA", T_DWORD, 1, {T_DWORD} },
    { "GetStartupInfoW", T_DWORD, 1, {T_DWORD} },
    { "GetStdHandle", T_HANDLE, 1, {T_DWORD} },
    { "GetSystemDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetSystemDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetSystemInfo", T_DWORD, 1, {T_DWORD} },
    { "GetSystemTime", T_DWORD, 1, {T_DWORD} },
    { "GetSystemTimeAdjustment", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "GetSystemTimeAsFileTime", T_DWORD, 1, {T_DWORD} },
    { "GetTapeParameters", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTapePosition", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTapeStatus", T_DWORD, 1, {T_HANDLE} },
    { "GetTempFileNameA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetTempFileNameW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetTempPathA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetTempPathW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetThreadContext", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetThreadPriority", T_DWORD, 1, {T_HANDLE} },
    { "GetThreadPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetThreadSelectorEntry", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetThreadTimes", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTickCount", T_DWORD, 1, {T_DWORD} },
    { "GetTimeZoneInformation", T_DWORD, 1, {T_DWORD} },
    { "GetVersion", T_DWORD, 1, {T_DWORD} },
    { "GetVersionExA", T_DWORD, 1, {T_DWORD} },
    { "GetVersionExW", T_DWORD, 1, {T_DWORD} },
    { "GetVolumeInformationA", T_DWORD, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetVolumeInformationW", T_DWORD, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetWindowsDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetWindowsDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GlobalAddAtomA", T_DWORD, 1, {T_LPSTR} },
    { "GlobalAddAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "GlobalAlloc", T_HGLOBAL, 2, {T_DWORD, T_DWORD} },
    { "GlobalCompact", T_DWORD, 1, {T_DWORD} },
    { "GlobalDeleteAtom", T_DWORD, 1, {T_DWORD} },
    { "GlobalFindAtomA", T_DWORD, 1, {T_LPSTR} },
    { "GlobalFindAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "GlobalFix", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalFlags", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalFree", T_HGLOBAL, 1, {T_HGLOBAL} },
    { "GlobalGetAtomNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GlobalGetAtomNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GlobalHandle", T_HGLOBAL, 1, {T_DWORD} },
    { "GlobalLock", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalMemoryStatus", T_DWORD, 1, {T_DWORD} },
    { "GlobalReAlloc", T_HGLOBAL, 3, {T_HGLOBAL, T_DWORD, T_DWORD} },
    { "GlobalSize", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnfix", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnlock", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnWire", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalWire", T_DWORD, 1, {T_HGLOBAL} },
    { "HeapAlloc", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapCompact", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "HeapCreate", T_HANDLE, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "HeapDestroy", T_DWORD, 1, {T_HANDLE} },
    { "HeapFree", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapLock", T_DWORD, 1, {T_HANDLE} },
    { "HeapReAlloc", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "HeapSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapUnlock", T_DWORD, 1, {T_HANDLE} },
    { "HeapValidate", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapWalk", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "InitAtomTable", T_DWORD, 1, {T_DWORD} },
    { "InitializeCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "InterlockedDecrement", T_DWORD, 1, {T_DWORD} },
    { "InterlockedExchange", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "InterlockedExchangeAdd", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "InterlockedIncrement", T_DWORD, 1, {T_DWORD} },
    { "IsBadCodePtr", T_DWORD, 1, {T_DWORD} },
    { "IsBadHugeReadPtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadHugeWritePtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadReadPtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadStringPtrA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "IsBadStringPtrW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "IsBadWritePtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsProcessorFeaturePresent", T_DWORD, 1, {T_DWORD} },
    { "LeaveCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "LoadLibraryA", T_DWORD, 1, {T_LPSTR} },
    { "LoadLibraryExA", T_DWORD, 3, {T_LPSTR, T_HANDLE, T_DWORD} },
    { "LoadLibraryExW", T_DWORD, 3, {T_LPWSTR, T_HANDLE, T_DWORD} },
    { "LoadLibraryW", T_DWORD, 1, {T_LPWSTR} },
    { "LoadModule", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "LoadResource", T_HGLOBAL, 2, {T_DWORD, T_DWORD} },
    { "LocalAlloc", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalCompact", T_DWORD, 1, {T_DWORD} },
    { "LocalFileTimeToFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalFlags", T_DWORD, 1, {T_DWORD} },
    { "LocalFree", T_DWORD, 1, {T_DWORD} },
    { "LocalHandle", T_DWORD, 1, {T_DWORD} },
    { "LocalLock", T_DWORD, 1, {T_DWORD} },
    { "LocalReAlloc", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "LocalShrink", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalSize", T_DWORD, 1, {T_DWORD} },
    { "LocalUnlock", T_DWORD, 1, {T_DWORD} },
    { "LockFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LockFileEx", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LockResource", T_DWORD, 1, {T_HGLOBAL} },
    { "lstrcatA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcatW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcmpA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcmpiA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcmpiW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcmpW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcpyA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcpynA", T_LPSTR, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "lstrcpynW", T_LPWSTR, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "lstrcpyW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrlenA", T_DWORD, 1, {T_LPSTR} },
    { "lstrlenW", T_DWORD, 1, {T_LPWSTR} },
    { "MapViewOfFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MapViewOfFileEx", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MoveFileA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "MoveFileExA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "MoveFileExW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "MoveFileW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "MulDiv", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenEventA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenEventW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenFile", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "OpenFileMappingA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenFileMappingW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenMutexA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenMutexW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenProcess", T_HANDLE, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenSemaphoreA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenSemaphoreW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenWaitableTimerA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenWaitableTimerW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OutputDebugStringA", T_DWORD, 1, {T_LPSTR} },
    { "OutputDebugStringW", T_DWORD, 1, {T_LPWSTR} },
    { "PeekNamedPipe", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostQueuedCompletionStatus", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "PrepareTape", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "PulseEvent", T_DWORD, 1, {T_HANDLE} },
    { "PurgeComm", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "QueryDosDeviceA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "QueryDosDeviceW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "QueryPerformanceCounter", T_DWORD, 1, {T_DWORD} },
    { "QueryPerformanceFrequency", T_DWORD, 1, {T_DWORD} },
    { "QueueUserAPC", T_DWORD, 3, {T_DWORD, T_HANDLE, T_DWORD} },
    { "RaiseException", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadDirectoryChangesW", T_DWORD, 8, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadProcessMemory", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReleaseMutex", T_DWORD, 1, {T_HANDLE} },
    { "ReleaseSemaphore", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "RemoveDirectoryA", T_DWORD, 1, {T_LPSTR} },
    { "RemoveDirectoryW", T_DWORD, 1, {T_LPWSTR} },
    { "ResetEvent", T_DWORD, 1, {T_HANDLE} },
    { "ResumeThread", T_DWORD, 1, {T_HANDLE} },
    { "SearchPathA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR, T_LPSTR} },
    { "SearchPathW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "SetCommBreak", T_DWORD, 1, {T_HANDLE} },
    { "SetCommConfig", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetCommMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCommState", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCommTimeouts", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCurrentDirectoryA", T_DWORD, 1, {T_LPSTR} },
    { "SetCurrentDirectoryW", T_DWORD, 1, {T_LPWSTR} },
    { "SetDefaultCommConfigA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "SetDefaultCommConfigW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "SetEndOfFile", T_DWORD, 1, {T_HANDLE} },
    { "SetEnvironmentVariableA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "SetEnvironmentVariableW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "SetErrorMode", T_DWORD, 1, {T_DWORD} },
    { "SetEvent", T_DWORD, 1, {T_HANDLE} },
    { "SetFileApisToANSI", T_DWORD, 1, {T_DWORD} },
    { "SetFileApisToOEM", T_DWORD, 1, {T_DWORD} },
    { "SetFileAttributesA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "SetFileAttributesW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "SetFilePointer", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetFileTime", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetHandleCount", T_DWORD, 1, {T_DWORD} },
    { "SetHandleInformation", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetLastError", T_DWORD, 1, {T_DWORD} },
    { "SetLocalTime", T_DWORD, 1, {T_DWORD} },
    { "SetMailslotInfo", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetNamedPipeHandleState", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPriorityClass", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessAffinityMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessShutdownParameters", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetProcessWorkingSetSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetStdHandle", T_DWORD, 2, {T_DWORD, T_HANDLE} },
    { "SetSystemTime", T_DWORD, 1, {T_DWORD} },
    { "SetSystemTimeAdjustment", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetTapeParameters", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetTapePosition", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetThreadAffinityMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadContext", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadIdealProcessor", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadPriority", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetTimeZoneInformation", T_DWORD, 1, {T_DWORD} },
    { "SetUnhandledExceptionFilter", T_DWORD, 1, {T_DWORD} },
    { "SetupComm", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetVolumeLabelA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "SetVolumeLabelW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "SetWaitableTimer", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SignalObjectAndWait", T_DWORD, 4, {T_HANDLE, T_HANDLE, T_DWORD, T_DWORD} },
    { "SizeofResource", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "Sleep", T_DWORD, 1, {T_DWORD} },
    { "SleepEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SuspendThread", T_DWORD, 1, {T_HANDLE} },
    { "SwitchToFiber", T_DWORD, 1, {T_DWORD} },
    { "SwitchToThread", T_DWORD, 1, {T_DWORD} },
    { "SystemTimeToFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SystemTimeToTzSpecificLocalTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "TerminateProcess", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TerminateThread", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TlsAlloc", T_DWORD, 1, {T_DWORD} },
    { "TlsFree", T_DWORD, 1, {T_DWORD} },
    { "TlsGetValue", T_DWORD, 1, {T_DWORD} },
    { "TlsSetValue", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "TransactNamedPipe", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TransmitCommChar", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TryEnterCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "UnhandledExceptionFilter", T_DWORD, 1, {T_DWORD} },
    { "UnlockFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "UnlockFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "UnmapViewOfFile", T_DWORD, 1, {T_DWORD} },
    { "UpdateResourceA", T_DWORD, 6, {T_HANDLE, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "UpdateResourceW", T_DWORD, 6, {T_HANDLE, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualAlloc", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualAllocEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualFree", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualFreeEx", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualLock", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "VirtualProtect", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualProtectEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualQuery", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualQueryEx", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualUnlock", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "WaitCommEvent", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitForDebugEvent", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "WaitForMultipleObjects", T_DWORD, 4, {T_DWORD, T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitForMultipleObjectsEx", T_DWORD, 5, {T_DWORD, T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "WaitForSingleObject", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "WaitForSingleObjectEx", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitNamedPipeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "WaitNamedPipeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "WinExec", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "WriteFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WriteFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WritePrivateProfileSectionA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WritePrivateProfileSectionW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WritePrivateProfileStringA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WritePrivateProfileStringW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WritePrivateProfileStructA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_LPSTR} },
    { "WritePrivateProfileStructW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_LPWSTR} },
    { "WriteProcessMemory", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WriteProfileSectionA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "WriteProfileSectionW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "WriteProfileStringA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WriteProfileStringW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WriteTapemark", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { NULL,                                0,          0,   }
};

API_TABLE API_Gdi32[] =
{
    { "AbortDoc", T_DWORD, 1, {T_HDC} },
    { "AbortPath", T_DWORD, 1, {T_HDC} },
    { "AddFontResourceA", T_DWORD, 1, {T_LPSTR} },
    { "AddFontResourceW", T_DWORD, 1, {T_LPWSTR} },
    { "AngleArc", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "AnimatePalette", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "Arc", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ArcTo", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BeginPath", T_DWORD, 1, {T_HDC} },
    { "BitBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "CancelDC", T_DWORD, 1, {T_HDC} },
    { "ChoosePixelFormat", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "Chord", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CloseEnhMetaFile", T_HENHMETAFILE, 1, {T_HDC} },
    { "CloseFigure", T_DWORD, 1, {T_HDC} },
    { "CloseMetaFile", T_HMETAFILE, 1, {T_HDC} },
    { "CombineRgn", T_DWORD, 4, {T_HRGN, T_HRGN, T_HRGN, T_DWORD} },
    { "CombineTransform", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CopyEnhMetaFileA", T_HENHMETAFILE, 2, {T_HENHMETAFILE, T_LPSTR} },
    { "CopyEnhMetaFileW", T_HENHMETAFILE, 2, {T_HENHMETAFILE, T_LPWSTR} },
    { "CopyMetaFileA", T_HMETAFILE, 2, {T_HMETAFILE, T_LPSTR} },
    { "CopyMetaFileW", T_HMETAFILE, 2, {T_HMETAFILE, T_LPWSTR} },
    { "CreateBitmap", T_HBITMAP, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateBitmapIndirect", T_HBITMAP, 1, {T_DWORD} },
    { "CreateBrushIndirect", T_HBRUSH, 1, {T_DWORD} },
    { "CreateCompatibleBitmap", T_HBITMAP, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "CreateCompatibleDC", T_HDC, 1, {T_HDC} },
    { "CreateDCA", T_HDC, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateDCW", T_HDC, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDIBitmap", T_HBITMAP, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDIBPatternBrush", T_HBRUSH, 2, {T_HGLOBAL, T_DWORD} },
    { "CreateDIBPatternBrushPt", T_HBRUSH, 2, {T_DWORD, T_DWORD} },
    { "CreateDIBSection", T_HBITMAP, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_HANDLE, T_DWORD} },
    { "CreateDiscardableBitmap", T_HBITMAP, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "CreateEllipticRgn", T_HRGN, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateEllipticRgnIndirect", T_HRGN, 1, {T_DWORD} },
    { "CreateEnhMetaFileA", T_HDC, 4, {T_HDC, T_LPSTR, T_DWORD, T_LPSTR} },
    { "CreateEnhMetaFileW", T_HDC, 4, {T_HDC, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "CreateFontA", T_HFONT, 8, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateFontIndirectA", T_HFONT, 1, {T_DWORD} },
    { "CreateFontIndirectW", T_HFONT, 1, {T_DWORD} },
    { "CreateFontW", T_HFONT, 8, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateHalftonePalette", T_HPALETTE, 1, {T_HDC} },
    { "CreateHatchBrush", T_HBRUSH, 2, {T_DWORD, T_DWORD} },
    { "CreateICA", T_HDC, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateICW", T_HDC, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateMetaFileA", T_HDC, 1, {T_LPSTR} },
    { "CreateMetaFileW", T_HDC, 1, {T_LPWSTR} },
    { "CreatePalette", T_HPALETTE, 1, {T_DWORD} },
    { "CreatePatternBrush", T_HBRUSH, 1, {T_HBITMAP} },
    { "CreatePen", T_HPEN, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreatePenIndirect", T_HPEN, 1, {T_DWORD} },
    { "CreatePolygonRgn", T_HRGN, 2, {T_DWORD, T_DWORD} },
    { "CreatePolyPolygonRgn", T_HRGN, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreateRectRgn", T_HRGN, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateRectRgnIndirect", T_HRGN, 1, {T_DWORD} },
    { "CreateRoundRectRgn", T_HRGN, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateScalableFontResourceA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_LPSTR} },
    { "CreateScalableFontResourceW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "CreateSolidBrush", T_HBRUSH, 1, {T_DWORD} },
    { "DeleteDC", T_DWORD, 1, {T_HDC} },
    { "DeleteEnhMetaFile", T_DWORD, 1, {T_HENHMETAFILE} },
    { "DeleteMetaFile", T_DWORD, 1, {T_HMETAFILE} },
    { "DeleteObject", T_DWORD, 1, {T_HGDIOBJ} },
    { "DescribePixelFormat", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DPtoLP", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "DrawEscape", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_LPSTR} },
    { "Ellipse", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "EndDoc", T_DWORD, 1, {T_HDC} },
    { "EndPage", T_DWORD, 1, {T_HDC} },
    { "EndPath", T_DWORD, 1, {T_HDC} },
    { "EnumEnhMetaFile", T_DWORD, 5, {T_HDC, T_HENHMETAFILE, T_DWORD, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesExA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesExW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumFontsA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumFontsW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumMetaFile", T_DWORD, 4, {T_HDC, T_HMETAFILE, T_DWORD, T_DWORD} },
    { "EnumObjects", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "EnumObjects", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "EqualRgn", T_DWORD, 2, {T_HRGN, T_HRGN} },
    { "Escape", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "ExcludeClipRect", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtCreatePen", T_HPEN, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtCreateRegion", T_HRGN, 2, {T_DWORD, T_DWORD} },
    { "ExtEscape", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_LPSTR} },
    { "ExtFloodFill", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtSelectClipRgn", T_DWORD, 3, {T_HDC, T_HRGN, T_DWORD} },
    { "ExtTextOutA", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtTextOutW", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FillPath", T_DWORD, 1, {T_HDC} },
    { "FillRgn", T_DWORD, 3, {T_HDC, T_HRGN, T_HBRUSH} },
    { "FixBrushOrgEx", T_DWORD, 1, {T_DWORD} },
    { "FlattenPath", T_DWORD, 1, {T_HDC} },
    { "FloodFill", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "FrameRgn", T_DWORD, 5, {T_HDC, T_HRGN, T_HBRUSH, T_DWORD, T_DWORD} },
    { "GdiComment", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GdiFlush", T_DWORD, 0, },
    { "GdiGetBatchLimit", T_DWORD, 0, },
    { "GdiSetBatchLimit", T_DWORD, 1, {T_DWORD} },
    { "GetArcDirection", T_DWORD, 1, {T_HDC} },
    { "GetAspectRatioFilterEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetBitmapBits", T_DWORD, 3, {T_HBITMAP, T_DWORD, T_DWORD} },
    { "GetBitmapDimensionEx", T_DWORD, 2, {T_HBITMAP, T_DWORD} },
    { "GetBkColor", T_DWORD, 1, {T_HDC} },
    { "GetBkMode", T_DWORD, 1, {T_HDC} },
    { "GetBoundsRect", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetBrushOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetCharABCWidthsA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsFloatA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsFloatW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharacterPlacementA", T_DWORD, 6, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharacterPlacementW", T_DWORD, 6, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidth32A", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidth32W", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthFloatA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthFloatW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetClipBox", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetClipRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "GetColorAdjustment", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetCurrentObject", T_HGDIOBJ, 2, {T_HDC, T_DWORD} },
    { "GetCurrentPositionEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetDCOrgEx", T_DWORD, 1, {T_HDCLPPOINT} },
    { "GetDeviceCaps", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetDIBColorTable", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDIBits", T_DWORD, 7, {T_HDC, T_HBITMAP, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileA", T_HENHMETAFILE, 1, {T_LPSTR} },
    { "GetEnhMetaFileBits", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileDescriptionA", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_LPSTR} },
    { "GetEnhMetaFileDescriptionW", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_LPWSTR} },
    { "GetEnhMetaFileHeader", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFilePaletteEntries", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFilePixelFormat", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileW", T_HENHMETAFILE, 1, {T_LPWSTR} },
    { "GetFontData", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetFontLanguageInfo", T_DWORD, 1, {T_HDC} },
    { "GetGlyphOutlineA", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetGlyphOutlineW", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetGraphicsMode", T_DWORD, 1, {T_HDC} },
    { "GetKerningPairsA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetKerningPairsW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetMapMode", T_DWORD, 1, {T_HDC} },
    { "GetMetaFileA", T_HMETAFILE, 1, {T_LPSTR} },
    { "GetMetaFileBitsEx", T_DWORD, 3, {T_HMETAFILE, T_DWORD, T_DWORD} },
    { "GetMetaFileW", T_HMETAFILE, 1, {T_LPWSTR} },
    { "GetMetaRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "GetMiterLimit", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetNearestColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetNearestPaletteIndex", T_DWORD, 2, {T_HPALETTE, T_DWORD} },
    { "GetObjectA", T_DWORD, 3, {T_HGDIOBJ, T_DWORD, T_DWORD} },
    { "GetObjectType", T_DWORD, 1, {T_HGDIOBJ} },
    { "GetObjectW", T_DWORD, 3, {T_HGDIOBJ, T_DWORD, T_DWORD} },
    { "GetOutlineTextMetricsA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetOutlineTextMetricsW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetPaletteEntries", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPath", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPixel", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetPixelFormat", T_DWORD, 1, {T_HDC} },
    { "GetPolyFillMode", T_DWORD, 1, {T_HDC} },
    { "GetRasterizerCaps", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetRegionData", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "GetRgnBox", T_DWORD, 2, {T_HRGN, T_DWORD} },
    { "GetROP2", T_DWORD, 1, {T_HDC} },
    { "GetStockObject", T_HGDIOBJ, 1, {T_DWORD} },
    { "GetStretchBltMode", T_DWORD, 1, {T_HDC} },
    { "GetSystemPaletteEntries", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetSystemPaletteUse", T_DWORD, 1, {T_HDC} },
    { "GetTextAlign", T_DWORD, 1, {T_HDC} },
    { "GetTextCharacterExtra", T_DWORD, 1, {T_HDC} },
    { "GetTextCharset", T_DWORD, 1, {T_HDC} },
    { "GetTextCharsetInfo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetTextColor", T_DWORD, 1, {T_HDC} },
    { "GetTextExtentExPointA", T_DWORD, 7, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTextExtentExPointW", T_DWORD, 7, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTextExtentPoint32A", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPoint32W", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPointA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPointW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetTextFaceA", T_DWORD, 3, {T_HDC, T_DWORD, T_LPSTR} },
    { "GetTextFaceW", T_DWORD, 3, {T_HDC, T_DWORD, T_LPWSTR} },
    { "GetTextMetricsA", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetTextMetricsW", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetViewportExtEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetViewportOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWindowExtEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWindowOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWinMetaFileBits", T_DWORD, 5, {T_HENHMETAFILE, T_DWORD, T_DWORD, T_DWORD, T_HDC} },
    { "GetWorldTransform", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "IntersectClipRect", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "InvertRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "LineDDA", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LineTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "LPtoDP", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "MaskBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "ModifyWorldTransform", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "MoveToEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "OffsetClipRgn", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "OffsetRgn", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "OffsetViewportOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "OffsetWindowOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PaintRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "PatBlt", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PathToRegion", T_HRGN, 1, {T_HDC} },
    { "Pie", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PlayEnhMetaFile", T_DWORD, 3, {T_HDC, T_HENHMETAFILE, T_DWORD} },
    { "PlayEnhMetaFileRecord", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PlayMetaFile", T_DWORD, 2, {T_HDC, T_HMETAFILE} },
    { "PlayMetaFileRecord", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PlgBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HBITMAP} },
    { "PolyBezier", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyBezierTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyDraw", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "Polygon", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "Polyline", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolylineTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyPolygon", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PolyPolyline", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PolyTextOutA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyTextOutW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PtInRegion", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "PtVisible", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "RealizePalette", T_DWORD, 1, {T_HDC} },
    { "Rectangle", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "RectInRegion", T_DWORD, 2, {T_HRGN, T_DWORD} },
    { "RectVisible", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "RemoveFontResourceA", T_DWORD, 1, {T_LPSTR} },
    { "RemoveFontResourceW", T_DWORD, 1, {T_LPWSTR} },
    { "ResetDCA", T_HDC, 2, {T_HDC, T_DWORD} },
    { "ResetDCW", T_HDC, 2, {T_HDC, T_DWORD} },
    { "ResizePalette", T_DWORD, 2, {T_HPALETTE, T_DWORD} },
    { "RestoreDC", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "RoundRect", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SaveDC", T_DWORD, 1, {T_HDC} },
    { "ScaleViewportExtEx", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ScaleWindowExtEx", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SelectClipPath", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SelectClipRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "SelectObject", T_HGDIOBJ, 2, {T_HDC, T_HGDIOBJ} },
    { "SelectPalette", T_HPALETTE, 3, {T_HDC, T_HPALETTE, T_DWORD} },
    { "SetAbortProc", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetArcDirection", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBitmapBits", T_DWORD, 3, {T_HBITMAP, T_DWORD, T_DWORD} },
    { "SetBitmapDimensionEx", T_DWORD, 4, {T_HBITMAP, T_DWORD, T_DWORD, T_DWORD} },
    { "SetBkColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBkMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBoundsRect", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetBrushOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetColorAdjustment", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetDIBColorTable", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDIBits", T_DWORD, 7, {T_HDC, T_HBITMAP, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDIBitsToDevice", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetEnhMetaFileBits", T_HENHMETAFILE, 2, {T_DWORD, T_DWORD} },
    { "SetGraphicsMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMapMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMapperFlags", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMetaFileBitsEx", T_HMETAFILE, 2, {T_DWORD, T_DWORD} },
    { "SetMetaRgn", T_DWORD, 1, {T_HDC} },
    { "SetMiterLimit", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetPaletteEntries", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPixel", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPixelFormat", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetPixelV", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPolyFillMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetRectRgn", T_DWORD, 5, {T_HRGN, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetROP2", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetStretchBltMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetSystemPaletteUse", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextAlign", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextCharacterExtra", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextJustification", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetViewportExtEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetViewportOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowExtEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWinMetaFileBits", T_HENHMETAFILE, 4, {T_DWORD, T_DWORD, T_HDC, T_DWORD} },
    { "SetWorldTransform", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartDocA", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartDocW", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartPage", T_DWORD, 1, {T_HDC} },
    { "StretchBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "StretchDIBits", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "StrokeAndFillPath", T_DWORD, 1, {T_HDC} },
    { "StrokePath", T_DWORD, 1, {T_HDC} },
    { "SwapBuffers", T_DWORD, 1, {T_HDC} },
    { "TextOutA", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "TextOutW", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "TranslateCharsetInfo", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "UnrealizeObject", T_DWORD, 1, {T_HGDIOBJ} },
    { "UpdateColors", T_DWORD, 1, {T_HDC} },
    { "wglCopyContext", T_DWORD, 3, {T_HGLRC, T_HGLRC, T_DWORD} },
    { "wglCreateContext", T_HGLRC, 1, {T_HDC} },
    { "wglCreateLayerContext", T_HGLRC, 2, {T_HDC, T_DWORD} },
    { "wglDeleteContext", T_DWORD, 1, {T_HGLRC} },
    { "wglDescribeLayerPlane", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglGetCurrentContext", T_HGLRC, 1, {T_DWORD} },
    { "wglGetCurrentDC", T_HDC, 1, {T_DWORD} },
    { "wglGetLayerPaletteEntries", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglGetProcAddress", T_DWORD, 1, {T_LPSTR} },
    { "wglMakeCurrent", T_DWORD, 2, {T_HDC, T_HGLRC} },
    { "wglRealizeLayerPalette", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "wglSetLayerPaletteEntries", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglShareLists", T_DWORD, 2, {T_HGLRC, T_HGLRC} },
    { "wglSwapLayerBuffers", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "wglUseFontBitmapsA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontBitmapsW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontOutlinesA", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontOutlinesW", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WidenPath", T_DWORD, 1, {T_HDC} },
    { NULL, 0, 0, }
};

API_TABLE API_User32[] =
{
    { "ActivateKeyboardLayout", T_DWORD, 2, {T_HKL, T_DWORD} },
    { "ActivateKeyboardLayout", T_HKL, 2, {T_HKL, T_DWORD} },
    { "AdjustWindowRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "AdjustWindowRectEx", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "AnyPopup", T_DWORD, 1, {T_DWORD} },
    { "AppendMenuA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_LPSTR} },
    { "AppendMenuW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_LPWSTR} },
    { "ArrangeIconicWindows", T_DWORD, 1, {T_HWND} },
    { "AttachThreadInput", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "BeginDeferWindowPos", T_HDWP, 1, {T_DWORD} },
    { "BeginPaint", T_HDC, 2, {T_HWND, T_DWORD} },
    { "BringWindowToTop", T_DWORD, 1, {T_HWND} },
    { "BroadcastSystemMessageA", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BroadcastSystemMessageW", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CallMsgFilterA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CallMsgFilterW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CallNextHookEx", T_DWORD, 4, {T_HHOOK, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcA", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcA", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcW", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcW", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CascadeWindows", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ChangeClipboardChain", T_DWORD, 2, {T_HWND, T_HWND} },
    { "ChangeDisplaySettingsA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsExA", T_DWORD, 5, {T_LPSTR, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsExW", T_DWORD, 5, {T_LPWSTR, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ChangeMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "ChangeMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "CharLowerA", T_LPSTR, 1, {T_LPSTR} },
    { "CharLowerBuffA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CharLowerBuffW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CharLowerW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CharNextA", T_LPSTR, 1, {T_LPSTR} },
    { "CharNextExA", T_LPSTR, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "CharNextW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CharPrevA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "CharPrevExA", T_LPSTR, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CharPrevW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "CharToOemA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "CharToOemBuffA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CharToOemBuffW", T_DWORD, 3, {T_LPWSTR, T_LPSTR, T_DWORD} },
    { "CharToOemW", T_DWORD, 2, {T_LPWSTR, T_LPSTR} },
    { "CharUpperA", T_LPSTR, 1, {T_LPSTR} },
    { "CharUpperBuffA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CharUpperBuffW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CharUpperW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CheckDlgButton", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "CheckMenuItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "CheckMenuRadioItem", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CheckRadioButton", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "ChildWindowFromPoint", T_HWND, 2, {T_HWND, T_DWORD} },
    { "ChildWindowFromPointEx", T_HWND, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ClientToScreen", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ClipCursor", T_DWORD, 1, {T_DWORD} },
    { "CloseClipboard", T_DWORD, 1, {T_DWORD} },
    { "CloseDesktop", T_DWORD, 1, {T_HDESK} },
    { "CloseWindow", T_DWORD, 1, {T_HWND} },
    { "CloseWindowStation", T_DWORD, 1, {T_HWINSTA} },
    { "CopyAcceleratorTableA", T_DWORD, 3, {T_HACCEL, T_DWORD, T_DWORD} },
    { "CopyAcceleratorTableW", T_DWORD, 3, {T_HACCEL, T_DWORD, T_DWORD} },
    { "CopyIcon", T_HICON, 1, {T_HICON} },
    { "CopyImage", T_HANDLE, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CountClipboardFormats", T_DWORD, 1, {T_DWORD} },
    { "CreateAcceleratorTableA", T_HACCEL, 2, {T_DWORD, T_DWORD} },
    { "CreateAcceleratorTableW", T_HACCEL, 2, {T_DWORD, T_DWORD} },
    { "CreateCaret", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateCursor", T_HCURSOR, 7, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDesktopA", T_HDESK, 6, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDesktopW", T_HDESK, 6, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDialogIndirectParamA", T_HWND, 5, {T_HINSTANCE, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "CreateDialogIndirectParamW", T_HWND, 5, {T_HINSTANCE, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "CreateDialogParamA", T_HWND, 5, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDialogParamW", T_HWND, 5, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIcon", T_HICON, 7, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconFromResource", T_HICON, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconFromResourceEx", T_HICON, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconIndirect", T_HICON, 1, {T_DWORD} },
    { "CreateMDIWindowA", T_HWND, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND} },
    { "CreateMDIWindowW", T_HWND, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND} },
    { "CreateMenu", T_HMENU, 1, {T_DWORD} },
    { "CreatePopupMenu", T_HMENU, 1, {T_DWORD} },
    { "CreateWindowExA", T_HWND, 8, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowExW", T_HWND, 8, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowStationA", T_HWINSTA, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowStationW", T_HWINSTA, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DefDlgProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefDlgProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DeferWindowPos", T_HDWP, 8, {T_HDWP, T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefFrameProcA", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefFrameProcW", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefMDIChildProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefMDIChildProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefWindowProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefWindowProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DeleteMenu", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "DestroyAcceleratorTable", T_DWORD, 1, {T_HACCEL} },
    { "DestroyCaret", T_DWORD, 1, {T_DWORD} },
    { "DestroyCursor", T_DWORD, 1, {T_HCURSOR} },
    { "DestroyIcon", T_DWORD, 1, {T_HICON} },
    { "DestroyMenu", T_DWORD, 1, {T_HMENU} },
    { "DestroyWindow", T_DWORD, 1, {T_HWND} },
    { "DialogBoxIndirectParamA", T_DWORD, 5, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxIndirectParamW", T_DWORD, 5, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxParamA", T_DWORD, 5, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxParamW", T_DWORD, 5, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DispatchMessageA", T_DWORD, 1, {T_DWORD} },
    { "DispatchMessageW", T_DWORD, 1, {T_DWORD} },
    { "DlgDirListA", T_DWORD, 5, {T_HWND, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListComboBoxA", T_DWORD, 5, {T_HWND, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListComboBoxW", T_DWORD, 5, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListW", T_DWORD, 5, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirSelectComboBoxExA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectComboBoxExW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectExA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectExW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "DragDetect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "DragObject", T_DWORD, 5, {T_HWND, T_HWND, T_DWORD, T_DWORD, T_HCURSOR} },
    { "DrawAnimatedRects", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawCaption", T_DWORD, 4, {T_HWND, T_HDC, T_DWORD, T_DWORD} },
    { "DrawEdge", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawFocusRect", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "DrawFrameControl", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawIcon", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_HICON} },
    { "DrawIconEx", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_HICON, T_DWORD, T_DWORD, T_DWORD, T_HBRUSH} },
    { "DrawMenuBar", T_DWORD, 1, {T_HWND} },
    { "DrawStateA", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawStateW", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextA", T_DWORD, 5, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextExA", T_DWORD, 6, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextExW", T_DWORD, 6, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextW", T_DWORD, 5, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "EmptyClipboard", T_DWORD, 1, {T_DWORD} },
    { "EnableMenuItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "EnableScrollBar", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnableWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EndDeferWindowPos", T_DWORD, 1, {T_HDWP} },
    { "EndDialog", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EndPaint", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumChildWindows", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumClipboardFormats", T_DWORD, 1, {T_DWORD} },
    { "EnumDesktopsA", T_DWORD, 3, {T_HWINSTA, T_DWORD, T_DWORD} },
    { "EnumDesktopsW", T_DWORD, 3, {T_HWINSTA, T_DWORD, T_DWORD} },
    { "EnumDesktopWindows", T_DWORD, 3, {T_HDESK, T_DWORD, T_DWORD} },
    { "EnumDisplaySettingsA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumDisplaySettingsW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumPropsA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumPropsExA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumPropsExW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumPropsW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumThreadWindows", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EnumWindows", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EnumWindowStationsA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EnumWindowStationsW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EqualRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ExcludeUpdateRgn", T_DWORD, 2, {T_HDC, T_HWND} },
    { "ExitWindowsEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FillRect", T_DWORD, 3, {T_HDC, T_DWORD, T_HBRUSH} },
    { "FindWindowA", T_HWND, 2, {T_DWORD, T_LPSTR} },
    { "FindWindowExA", T_HWND, 4, {T_HWND, T_HWND, T_LPSTR, T_LPSTR} },
    { "FindWindowExW", T_HWND, 4, {T_HWND, T_HWND, T_LPWSTR, T_LPWSTR} },
    { "FindWindowW", T_HWND, 2, {T_DWORD, T_LPWSTR} },
    { "FlashWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "FrameRect", T_DWORD, 3, {T_HDC, T_DWORD, T_HBRUSH} },
    { "GetActiveWindow", T_HWND, 1, {T_DWORD} },
    { "GetAsyncKeyState", T_DWORD, 1, {T_DWORD} },
    { "GetCapture", T_HWND, 1, {T_DWORD} },
    { "GetCaretBlinkTime", T_DWORD, 1, {T_DWORD} },
    { "GetCaretPos", T_DWORD, 1, {T_DWORD} },
    { "GetClassInfoA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetClassInfoExA", T_DWORD, 3, {T_HINSTANCE, T_LPSTR, T_DWORD} },
    { "GetClassInfoExW", T_DWORD, 3, {T_HINSTANCE, T_LPWSTR, T_DWORD} },
    { "GetClassInfoW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetClassLongA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClassLongW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClassNameA", T_DWORD, 3, {T_HWND, T_LPSTR, T_DWORD} },
    { "GetClassNameW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_DWORD} },
    { "GetClassWord", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClientRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClipboardData", T_HANDLE, 1, {T_DWORD} },
    { "GetClipboardFormatNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetClipboardFormatNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetClipboardOwner", T_HWND, 1, {T_DWORD} },
    { "GetClipboardViewer", T_HWND, 1, {T_DWORD} },
    { "GetClipCursor", T_DWORD, 1, {T_DWORD} },
    { "GetCursor", T_HCURSOR, 1, {T_DWORD} },
    { "GetCursorPos", T_DWORD, 1, {T_DWORD} },
    { "GetDC", T_HDC, 1, {T_HWND} },
    { "GetDCEx", T_HDC, 3, {T_DWORD, T_HRGN, T_DWORD} },
    { "GetDesktopWindow", T_HWND, 1, {T_DWORD} },
    { "GetDialogBaseUnits", T_DWORD, 1, {T_DWORD} },
    { "GetDlgCtrlID", T_DWORD, 1, {T_HWND} },
    { "GetDlgItem", T_HWND, 2, {T_HWND, T_DWORD} },
    { "GetDlgItemInt", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDlgItemTextA", T_DWORD, 4, {T_HWND, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetDlgItemTextW", T_DWORD, 4, {T_HWND, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetDoubleClickTime", T_DWORD, 1, {T_DWORD} },
    { "GetFocus", T_HWND, 1, {T_DWORD} },
    { "GetForegroundWindow", T_HWND, 1, {T_DWORD} },
    { "GetIconInfo", T_DWORD, 2, {T_HICON, T_DWORD} },
    { "GetInputState", T_DWORD, 1, {T_DWORD} },
    { "GetKBCodePage", T_DWORD, 1, {T_DWORD} },
    { "GetKeyboardLayout", T_HKL, 1, {T_DWORD} },
    { "GetKeyboardLayoutList", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetKeyboardLayoutNameA", T_DWORD, 1, {T_LPSTR} },
    { "GetKeyboardLayoutNameW", T_DWORD, 1, {T_LPWSTR} },
    { "GetKeyboardState", T_DWORD, 1, {T_DWORD} },
    { "GetKeyboardType", T_DWORD, 1, {T_DWORD} },
    { "GetKeyNameTextA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetKeyNameTextW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetKeyState", T_DWORD, 1, {T_DWORD} },
    { "GetLastActivePopup", T_HWND, 1, {T_HWND} },
    { "GetMenu", T_HMENU, 1, {T_HWND} },
    { "GetMenuCheckMarkDimensions", T_DWORD, 1, {T_DWORD} },
    { "GetMenuContextHelpId", T_DWORD, 1, {T_HMENU} },
    { "GetMenuDefaultItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuItemCount", T_DWORD, 1, {T_HMENU} },
    { "GetMenuItemID", T_DWORD, 2, {T_HMENU, T_DWORD} },
    { "GetMenuItemInfoA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMenuItemInfoW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMenuItemRect", T_DWORD, 4, {T_HWND, T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuState", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuStringA", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetMenuStringW", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetMessageA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMessageExtraInfo", T_DWORD, 1, {T_DWORD} },
    { "GetMessagePos", T_DWORD, 1, {T_DWORD} },
    { "GetMessageTime", T_DWORD, 1, {T_DWORD} },
    { "GetMessageW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetNextDlgGroupItem", T_HWND, 3, {T_HWND, T_HWND, T_DWORD} },
    { "GetNextDlgTabItem", T_HWND, 3, {T_HWND, T_HWND, T_DWORD} },
    { "GetOpenClipboardWindow", T_HWND, 1, {T_DWORD} },
    { "GetParent", T_HWND, 1, {T_HWND} },
    { "GetPriorityClipboardFormat", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessWindowStation", T_HWINSTA, 1, {T_DWORD} },
    { "GetPropA", T_HANDLE, 2, {T_HWND, T_LPSTR} },
    { "GetPropW", T_HANDLE, 2, {T_HWND, T_LPWSTR} },
    { "GetQueueStatus", T_DWORD, 1, {T_DWORD} },
    { "GetScrollInfo", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "GetScrollPos", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetScrollRange", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "GetSubMenu", T_HMENU, 2, {T_HMENU, T_DWORD} },
    { "GetSysColor", T_DWORD, 1, {T_DWORD} },
    { "GetSysColorBrush", T_HBRUSH, 1, {T_DWORD} },
    { "GetSystemMenu", T_HMENU, 2, {T_HWND, T_DWORD} },
    { "GetSystemMetrics", T_DWORD, 1, {T_DWORD} },
    { "GetTabbedTextExtentA", T_DWORD, 5, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTabbedTextExtentW", T_DWORD, 5, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetThreadDesktop", T_HDESK, 1, {T_DWORD} },
    { "GetTopWindow", T_HWND, 1, {T_HWND} },
    { "GetUpdateRect", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "GetUpdateRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "GetUserObjectInformationA", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetUserObjectInformationW", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetUserObjectSecurity", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetWindow", T_HWND, 2, {T_HWND, T_DWORD} },
    { "GetWindowContextHelpId", T_DWORD, 1, {T_HWND} },
    { "GetWindowDC", T_HDC, 1, {T_HWND} },
    { "GetWindowLongA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowLongW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowPlacement", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowRgn", T_DWORD, 2, {T_HWND, T_HRGN} },
    { "GetWindowTextA", T_DWORD, 3, {T_HWND, T_LPSTR, T_DWORD} },
    { "GetWindowTextLengthA", T_DWORD, 1, {T_HWND} },
    { "GetWindowTextLengthW", T_DWORD, 1, {T_HWND} },
    { "GetWindowTextW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_DWORD} },
    { "GetWindowThreadProcessId", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowWord", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GrayStringA", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GrayStringW", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "HideCaret", T_DWORD, 1, {T_HWND} },
    { "HiliteMenuItem", T_DWORD, 4, {T_HWND, T_HMENU, T_DWORD, T_DWORD} },
    { "InflateRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InSendMessage", T_DWORD, 1, {T_DWORD} },
    { "InsertMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "InsertMenuItemA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "InsertMenuItemW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "InsertMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "IntersectRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InvalidateRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InvalidateRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "InvertRect", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "IsCharAlphaA", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaNumericA", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaNumericW", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaW", T_DWORD, 1, {T_DWORD} },
    { "IsCharLowerA", T_DWORD, 1, {T_DWORD} },
    { "IsCharLowerW", T_DWORD, 1, {T_DWORD} },
    { "IsCharUpperA", T_DWORD, 1, {T_DWORD} },
    { "IsCharUpperW", T_DWORD, 1, {T_DWORD} },
    { "IsChild", T_DWORD, 2, {T_HWND, T_HWND} },
    { "IsClipboardFormatAvailable", T_DWORD, 1, {T_DWORD} },
    { "IsDialogMessageA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsDialogMessageW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsDlgButtonChecked", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsIconic", T_DWORD, 1, {T_HWND} },
    { "IsMenu", T_DWORD, 1, {T_HMENU} },
    { "IsRectEmpty", T_DWORD, 1, {T_DWORD} },
    { "IsWindow", T_DWORD, 1, {T_HWND} },
    { "IsWindowEnabled", T_DWORD, 1, {T_HWND} },
    { "IsWindowUnicode", T_DWORD, 1, {T_HWND} },
    { "IsWindowVisible", T_DWORD, 1, {T_HWND} },
    { "IsZoomed", T_DWORD, 1, {T_HWND} },
    { "keybd_event", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "KillTimer", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "LoadAcceleratorsA", T_HACCEL, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadAcceleratorsW", T_HACCEL, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadBitmapA", T_HBITMAP, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadBitmapW", T_HBITMAP, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadCursorA", T_HCURSOR, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadCursorFromFileA", T_HCURSOR, 1, {T_LPSTR} },
    { "LoadCursorFromFileW", T_HCURSOR, 1, {T_LPWSTR} },
    { "LoadCursorW", T_HCURSOR, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadIconA", T_HICON, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadIconW", T_HICON, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadImageA", T_HANDLE, 6, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LoadImageW", T_HANDLE, 6, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LoadKeyboardLayoutA", T_HKL, 2, {T_LPSTR, T_DWORD} },
    { "LoadKeyboardLayoutW", T_HKL, 2, {T_LPWSTR, T_DWORD} },
    { "LoadMenuA", T_HMENU, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadMenuIndirectA", T_HMENU, 1, {T_DWORD} },
    { "LoadMenuIndirectW", T_HMENU, 1, {T_DWORD} },
    { "LoadMenuW", T_HMENU, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadStringA", T_DWORD, 4, {T_HINSTANCE, T_DWORD, T_LPSTR, T_DWORD} },
    { "LoadStringW", T_DWORD, 4, {T_HINSTANCE, T_DWORD, T_LPWSTR, T_DWORD} },
    { "LockWindowUpdate", T_DWORD, 1, {T_HWND} },
    { "LookupIconIdFromDirectory", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LookupIconIdFromDirectoryEx", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MapDialogRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "MapVirtualKeyA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "MapVirtualKeyExA", T_DWORD, 3, {T_DWORD, T_DWORD, T_HKL} },
    { "MapVirtualKeyExW", T_DWORD, 3, {T_DWORD, T_DWORD, T_HKL} },
    { "MapVirtualKeyW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "MapWindowPoints", T_DWORD, 4, {T_HWND, T_HWND, T_DWORD, T_DWORD} },
    { "MenuItemFromPoint", T_DWORD, 3, {T_HWND, T_HMENU, T_DWORD} },
    { "MessageBeep", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "MessageBoxExA", T_DWORD, 5, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD} },
    { "MessageBoxExW", T_DWORD, 5, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD} },
    { "MessageBoxIndirectA", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxIndirectW", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "ModifyMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "ModifyMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "mouse_event", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MoveWindow", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MsgWaitForMultipleObjects", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MsgWaitForMultipleObjectsEx", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "OemKeyScan", T_DWORD, 1, {T_DWORD} },
    { "OemToCharA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "OemToCharBuffA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "OemToCharBuffW", T_DWORD, 3, {T_LPSTR, T_LPWSTR, T_DWORD} },
    { "OemToCharW", T_DWORD, 2, {T_LPSTR, T_LPWSTR} },
    { "OffsetRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenClipboard", T_DWORD, 1, {T_HWND} },
    { "OpenDesktopA", T_HDESK, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "OpenDesktopW", T_HDESK, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "OpenIcon", T_DWORD, 1, {T_HWND} },
    { "OpenInputDesktop", T_HDESK, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenWindowStationA", T_HWINSTA, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "OpenWindowStationW", T_HWINSTA, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "PaintDesktop", T_DWORD, 1, {T_HDC} },
    { "PeekMessageA", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PeekMessageW", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "PostMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "PostQuitMessage", T_DWORD, 1, {T_DWORD} },
    { "PostThreadMessageA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostThreadMessageW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PtInRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RedrawWindow", T_DWORD, 4, {T_HWND, T_DWORD, T_HRGN, T_DWORD} },
    { "RegisterClassA", T_DWORD, 1, {T_DWORD} },
    { "RegisterClassExA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RegisterClassExW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RegisterClassW", T_DWORD, 1, {T_DWORD} },
    { "RegisterClipboardFormatA", T_DWORD, 1, {T_LPSTR} },
    { "RegisterClipboardFormatW", T_DWORD, 1, {T_LPWSTR} },
    { "RegisterHotKey", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "RegisterWindowMessageA", T_DWORD, 1, {T_LPSTR} },
    { "RegisterWindowMessageW", T_DWORD, 1, {T_LPWSTR} },
    { "ReleaseCapture", T_DWORD, 1, {T_DWORD} },
    { "ReleaseDC", T_DWORD, 2, {T_HWND, T_HDC} },
    { "RemoveMenu", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "RemovePropA", T_HANDLE, 2, {T_HWND, T_LPSTR} },
    { "RemovePropW", T_HANDLE, 2, {T_HWND, T_LPWSTR} },
    { "ReplyMessage", T_DWORD, 1, {T_DWORD} },
    { "ScreenToClient", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ScrollDC", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HRGN, T_DWORD} },
    { "ScrollWindow", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ScrollWindowEx", T_DWORD, 8, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HRGN, T_DWORD, T_DWORD} },
    { "SendDlgItemMessageA", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendDlgItemMessageW", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageCallbackA", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageCallbackW", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageTimeoutA", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageTimeoutW", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendNotifyMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendNotifyMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetActiveWindow", T_HWND, 1, {T_HWND} },
    { "SetCapture", T_HWND, 1, {T_HWND} },
    { "SetCaretBlinkTime", T_DWORD, 1, {T_DWORD} },
    { "SetCaretPos", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetClassLongA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClassLongW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClassWord", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClipboardData", T_HANDLE, 2, {T_DWORD, T_HANDLE} },
    { "SetClipboardViewer", T_HWND, 1, {T_HWND} },
    { "SetCursor", T_HCURSOR, 1, {T_HCURSOR} },
    { "SetCursorPos", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetDebugErrorLevel", T_DWORD, 1, {T_DWORD} },
    { "SetDlgItemInt", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDlgItemTextA", T_DWORD, 3, {T_HWND, T_DWORD, T_LPSTR} },
    { "SetDlgItemTextW", T_DWORD, 3, {T_HWND, T_DWORD, T_LPWSTR} },
    { "SetDoubleClickTime", T_DWORD, 1, {T_DWORD} },
    { "SetFocus", T_HWND, 1, {T_HWND} },
    { "SetForegroundWindow", T_DWORD, 1, {T_HWND} },
    { "SetKeyboardState", T_DWORD, 1, {T_DWORD} },
    { "SetLastErrorEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetMenu", T_DWORD, 2, {T_HWND, T_HMENU} },
    { "SetMenuContextHelpId", T_DWORD, 2, {T_HMENU, T_DWORD} },
    { "SetMenuDefaultItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "SetMenuItemBitmaps", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_HBITMAP, T_HBITMAP} },
    { "SetMenuItemInfoA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "SetMenuItemInfoW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "SetMessageExtraInfo", T_DWORD, 1, {T_DWORD} },
    { "SetMessageQueue", T_DWORD, 1, {T_DWORD} },
    { "SetParent", T_HWND, 2, {T_HWND, T_HWND} },
    { "SetProcessWindowStation", T_DWORD, 1, {T_HWINSTA} },
    { "SetPropA", T_DWORD, 3, {T_HWND, T_LPSTR, T_HANDLE} },
    { "SetPropW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_HANDLE} },
    { "SetRect", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetRectEmpty", T_DWORD, 1, {T_DWORD} },
    { "SetScrollInfo", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetScrollPos", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetScrollRange", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetSysColors", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "SetSystemCursor", T_DWORD, 2, {T_HCURSOR, T_DWORD} },
    { "SetThreadDesktop", T_DWORD, 1, {T_HDESK} },
    { "SetTimer", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectInformationA", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectInformationW", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectSecurity", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetWindowContextHelpId", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SetWindowLongA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetWindowLongW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetWindowPlacement", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SetWindowPos", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "SetWindowsHookA", T_HHOOK, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookExA", T_HHOOK, 4, {T_DWORD, T_DWORD, T_HINSTANCE, T_DWORD} },
    { "SetWindowsHookExW", T_HHOOK, 4, {T_DWORD, T_DWORD, T_HINSTANCE, T_DWORD} },
    { "SetWindowsHookW", T_HHOOK, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetWindowTextA", T_DWORD, 2, {T_HWND, T_LPSTR} },
    { "SetWindowTextW", T_DWORD, 2, {T_HWND, T_LPWSTR} },
    { "SetWindowWord", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ShowCaret", T_DWORD, 1, {T_HWND} },
    { "ShowCursor", T_DWORD, 1, {T_DWORD} },
    { "ShowOwnedPopups", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ShowScrollBar", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ShowWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ShowWindowAsync", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SubtractRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "SwapMouseButton", T_DWORD, 1, {T_DWORD} },
    { "SwitchDesktop", T_DWORD, 1, {T_HDESK} },
    { "SystemParametersInfoA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SystemParametersInfoW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TabbedTextOutA", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TabbedTextOutW", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TileWindows", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ToAscii", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ToAsciiEx", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HKL} },
    { "ToUnicode", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "ToUnicodeEx", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD, T_HKL} },
    { "TrackMouseEvent", T_DWORD, 1, {T_DWORD} },
    { "TrackPopupMenu", T_DWORD, 7, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND, T_DWORD} },
    { "TrackPopupMenuEx", T_DWORD, 6, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_HWND, T_DWORD} },
    { "TranslateAcceleratorA", T_DWORD, 3, {T_HWND, T_HACCEL, T_DWORD} },
    { "TranslateAcceleratorW", T_DWORD, 3, {T_HWND, T_HACCEL, T_DWORD} },
    { "TranslateMDISysAccel", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "TranslateMessage", T_DWORD, 1, {T_DWORD} },
    { "UnhookWindowsHook", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "UnhookWindowsHookEx", T_DWORD, 1, {T_HHOOK} },
    { "UnionRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "UnloadKeyboardLayout", T_DWORD, 1, {T_HKL} },
    { "UnregisterClassA", T_DWORD, 2, {T_LPSTR, T_HINSTANCE} },
    { "UnregisterClassW", T_DWORD, 2, {T_LPWSTR, T_HINSTANCE} },
    { "UnregisterHotKey", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "UpdateWindow", T_DWORD, 1, {T_HWND} },
    { "ValidateRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ValidateRgn", T_DWORD, 2, {T_HWND, T_HRGN} },
    { "VkKeyScanA", T_DWORD, 1, {T_DWORD} },
    { "VkKeyScanExA", T_DWORD, 2, {T_DWORD, T_HKL} },
    { "VkKeyScanExW", T_DWORD, 2, {T_DWORD, T_HKL} },
    { "VkKeyScanW", T_DWORD, 1, {T_DWORD} },
    { "WaitForInputIdle", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "WaitMessage", T_DWORD, 1, {T_DWORD} },
    { "WindowFromDC", T_HWND, 1, {T_HDC} },
    { "WindowFromPoint", T_HWND, 1, {T_DWORD} },
    { "WinHelpA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "WinHelpW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "wsprintfA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "wsprintfW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "wvsprintfA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "wvsprintfW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { NULL, 0, 0, }
};


API_MASTER_TABLE ApiTables[] =
{
    { "kernel32.dll", FALSE, API_Kernel32 },
    { "user32.dll",   FALSE, API_User32   },
    { "gdi32.dll",    FALSE, API_Gdi32    },
    { NULL,           FALSE, NULL         }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\alias.cpp ===
/****************************** Module Header ******************************\
* Module Name: alias.cpp
*
* This module implements ApiMon aliasing.
*
* History:
* 06-11-96 vadimg         created
\***************************************************************************/

#include "apimonp.h"
#include "alias.h"

char *grgpsz[] = {"HACCEL", "HANDLE", "HBITMA", "HBRUSH", "HCURSO", "HDC",
        "HDCLP", "HDESK", "HDWP", "HENHME", "HFONT", "HGDIOB", "HGLOBA",
        "HGLRC", "HHOOK", "HICON", "HINSTA", "HKL", "HMENU", "HMETAF",
        "HPALET", "HPEN", "HRGN", "HWINST", "HWND"};

/*
    The hashing function.
*/

inline long Hash(ULONG_PTR ulHandle)
{
    return (long)(ulHandle % kulTableSize);
}

/*
   CAliasNode::CAliasNode
   Initialize the node.
*/

inline CAliasNode::CAliasNode(ULONG_PTR ulHandle, long nAlias)
{
    m_panodNext = NULL;
    m_ulHandle = ulHandle;
    m_nAlias = nAlias;
}

/*
   CAliasNode::CAliasNode
   An empty constructor for array declaration.
*/

inline CAliasNode::CAliasNode()
{
}

ULONG CAliasTable::s_ulAlias = 0;

/*
   CAliasTable::CAliasTable
   Initialize the hash table.
*/

CAliasTable::CAliasTable()
{
    memset(m_rgpanod, 0, sizeof(CAliasNode*)*kulTableSize);
}

/*
   CAliasTable::~CAliasTable
   Free the hash table.
*/

CAliasTable::~CAliasTable()
{
    for (int i = kulTableSize - 1; i >= 0; i--) {
        if (m_rgpanod[i] != NULL) {
            CAliasNode *panodT = m_rgpanod[i], *panodNext;
            while (panodT != NULL) {
                panodNext = panodT->m_panodNext;
                delete panodT;
                panodT = panodNext;
            }
        }
    }
}

/*
   CAliasTable::~CAliasTable
   Insert a new handle into the hash table.
*/

long CAliasTable::Insert(ULONG_PTR ulHandle)
{
    ULONG iHash = Hash(ulHandle), ulAlias = s_ulAlias++;
    CAliasNode *panod;

    if ((panod = new CAliasNode(ulHandle, ulAlias)) == NULL)
        return -1;

    if (m_rgpanod[iHash] == NULL) {
        m_rgpanod[iHash] = panod;
    } else {
        CAliasNode *panodT = m_rgpanod[iHash];
        m_rgpanod[iHash] = panod;
        panod->m_panodNext = panodT;
    }
    return ulAlias;
}

/*
   CAliasTable::Lookup
   Find an alias corresponding to the given handle.
*/

long CAliasTable::Lookup(ULONG_PTR ulHandle)
{
    CAliasNode *panodT = m_rgpanod[Hash(ulHandle)];
    while (panodT != NULL) {
        if (panodT->m_ulHandle == ulHandle) {
            return panodT->m_nAlias;
        }
        panodT = panodT->m_panodNext;
    }
    return -1;
}

/*
   CAliasTable::Alias
   Alias by the given type and handle.
*/

void CAliasTable::Alias(ULONG ulType, ULONG_PTR ulHandle, char szAlias[])
{
    if (ulHandle == 0) {
        strcpy(szAlias, "NULL");
        return;
    }

    long nAlias = Lookup(ulHandle);
    if (nAlias == -1) {
        if ((nAlias = Insert(ulHandle)) == -1) {
            strcpy(szAlias, "FAILED");
            return;
        }
    }

    sprintf(szAlias, "%6s%04x", grgpsz[ulType], nAlias);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apidll\i386\machine.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This file implements the CreateMachApiThunk() function.  This
    function is responsible for emitting the individual API thunks
    for the i386 architecture.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#include "apidllp.h"
#pragma hdrstop

PUCHAR
CreateMachApiThunk(
    PULONG      IatAddress,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    )

/*++

Routine Description:

    Emits the machine specific code for the API thunks.

Arguments:

    IatAddress  - Pointer to the IAT fir this API
    Text        - Pointer to a buffer to place the generated code
    DllInfo     - Pointer to the DLL_INFO structure
    ApiInfo     - Pointer to the API_INFO structure

Return Value:

    Pointer to the next byte to place more generated code.

--*/

{
    if (ApiInfo->ThunkAddress) {
        *IatAddress = ApiInfo->ThunkAddress;
        return Text;
    }

    *IatAddress = (ULONG)Text;
    ApiInfo->ThunkAddress = *IatAddress;
    PUCHAR Code = (PUCHAR)Text;

    Code[0] = 0x68;
    Code += 1;
    *(LPDWORD)Code = (ULONG)ApiInfo;
    Code += sizeof(DWORD);
    Code[0] = 0x68;
    Code += 1;
    *(LPDWORD)Code = (ULONG)DllInfo;
    Code += sizeof(DWORD);
    Code[0] = 0x68;
    Code += 1;

    if (_stricmp(DllInfo->Name,KERNEL32)==0) {
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),LOADLIBRARYA)==0) {
            *(LPDWORD)Code = APITYPE_LOADLIBRARYA;
        } else
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),LOADLIBRARYW)==0) {
            *(LPDWORD)Code = APITYPE_LOADLIBRARYW;
        } else
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),FREELIBRARY)==0) {
            *(LPDWORD)Code = APITYPE_FREELIBRARY;
        } else 
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),GETPROCADDRESS)==0) {
            *(LPDWORD)Code = APITYPE_GETPROCADDRESS;
        } else {
            *(LPDWORD)Code = APITYPE_NORMAL;
        }
    } else if (_stricmp(DllInfo->Name,USER32)==0) {
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),REGISTERCLASSA)==0) {
             *(LPDWORD)Code = APITYPE_REGISTERCLASSA;                         
         } else                                                               
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),REGISTERCLASSW)==0) {
             *(LPDWORD)Code = APITYPE_REGISTERCLASSW;                        
         } else                                                                
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),SETWINDOWLONGA)==0) { 
              *(LPDWORD)Code = APITYPE_SETWINDOWLONG;                           
         } else                                                                
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),SETWINDOWLONGW)==0) {
              *(LPDWORD)Code = APITYPE_SETWINDOWLONG;
         } else {
              *(LPDWORD)Code = APITYPE_NORMAL;
         }                             
    } else if (_stricmp(DllInfo->Name,WNDPROCDLL)==0) {
        *(LPDWORD)Code = APITYPE_WNDPROC;
    } else {
        *(LPDWORD)Code = APITYPE_NORMAL;
    }


    Code += sizeof(DWORD);

    Code[0] = 0xe9;
    Code += 1;
    *(LPDWORD)Code = (ULONG)((ULONG)ApiMonThunk-(((ULONG)Code-(ULONG)Text)+(ULONG)Text+4));
    Code += sizeof(DWORD);

    return Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\apimonp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonp.h

Abstract:

    Common header file for APIMON data structures.

Author:

    Wesley Witt (wesw) 12-July-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <windowsx.h>
#include <dbghelp.h>
#include <commctrl.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <crt\io.h>
#include <fcntl.h>
#include <psapi.h>
#include "resource.h"
#include "apimon.h"
#include "apictrl.h"

#if defined(_M_IX86)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_M_ALPHA)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA
#else
#error( "unknown target machine" );
#endif

#define LVIS_GCNOCHECK              0x1000
#define LVIS_GCCHECK                0x2000

#define SKIP_NONWHITE(p)                while( *p && *p != ' ') p++
#define SKIP_WHITE(p)                   while( *p && *p == ' ') p++

#define DISBUF_SIZE                     256
#define MAX_LINES                       20
#define BYTES_INSTR                     16
#define CODE_SIZE                       (MAX_LINES*BYTES_INSTR)

#define MAX_BREAKPOINTS                 256
#undef PAGE_ALIGN
#define PAGE_ALIGN(Va)                  ((ULONG_PTR)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

#define WM_TROJAN_COMPLETE              (WM_USER + 100)
#define WM_UPDATE_COUNTERS              (WM_USER + 101)
#define WM_INIT_PROGRAM                 (WM_USER + 102)
#define WM_REFRESH_LIST                 (WM_USER + 103)
#define WM_UPDATE_PAGE                  (WM_USER + 104)
#define WM_CREATE_GRAPH                 (WM_USER + 105)
#define WM_POPUP_TEXT                   (WM_USER + 106)
#define WM_FONT_CHANGE                  (WM_USER + 107)
#define WM_COLOR_CHANGE                 (WM_USER + 108)
#define WM_TOGGLE_LEGEND                (WM_USER + 109)


#define UBLACK                          RGB(000, 000, 000)
#define DARK_RED                        RGB(128, 000, 000)
#define DARK_GREEN                      RGB(000, 128, 000)
#define DARK_YELLOW                     RGB(128, 128, 000)
#define DARK_BLUE                       RGB(000, 000, 128)
#define DARK_MAGENTA                    RGB(128, 000, 128)
#define DARK_CYAN                       RGB(000, 128, 128)
#define DARK_GRAY                       RGB(128, 128, 128)
#define LIGHT_GRAY                      RGB(192, 192, 192)
#define LIGHT_RED                       RGB(255, 000, 000)
#define LIGHT_GREEN                     RGB(000, 255, 000)
#define LIGHT_YELLOW                    RGB(255, 255, 000)
#define LIGHT_BLUE                      RGB(000, 000, 255)
#define LIGHT_MAGENTA                   RGB(255, 000, 255)
#define LIGHT_CYAN                      RGB(000, 255, 255)
#define UWHITE                          RGB(255, 255, 255)

#ifdef _M_IX86

#define BP_INSTR                        0xcc
#define BP_SIZE                         1
#define PC_REG                          Eip
#define RV_REG                          Eax
#define STK_REG                         Esp
#undef PAGE_SIZE
#define PAGE_SIZE                       4096
#define IsBreakpoint(I) (*(PUCHAR)(I) == BP_INSTR)

#elif defined(_M_ALPHA)

#include <alphaops.h>

#define BP_INSTR                        0x00000080
#define BP_SIZE                         4
#define PC_REG                          Fir
#define RV_REG                          IntV0
#define STK_REG                         IntSp
#undef PAGE_SIZE
#define PAGE_SIZE                       8192
#define IsBreakpoint(I) \
    (*(PULONG)(I) == (CALLPAL_OP | CALLKD_FUNC)) || \
    (*(PULONG)(I) == (CALLPAL_OP |    BPT_FUNC)) || \
    (*(PULONG)(I) == (CALLPAL_OP |   KBPT_FUNC))

#else

#pragma error( "unknown machine type" )

#endif

typedef enum _SORT_TYPE {
    SortByName,
    SortByCounter,
    SortByTime
} SORT_TYPE;

#define IS_ICONIC   0x00000001
#define IS_ZOOMED   0x00000002
#define IS_FOCUS    0x00000004

#define NUMBER_OF_CUSTOM_COLORS 16

#define CHILD_DLL           1
#define CHILD_COUNTER       2
#define CHILD_PAGE          3
#define CHILD_GRAPH         4

typedef struct _POSITION {
    RECT        Rect;
    ULONG       Flags;
} POSITION, *PPOSITION;

typedef struct _OPTIONS {
    CHAR        ProgName[MAX_PATH];
    CHAR        ProgDir[MAX_PATH];
    CHAR        Arguments[MAX_PATH];
    CHAR        LogFileName[MAX_PATH];
    CHAR        TraceFileName[MAX_PATH];
    CHAR        SymbolPath[MAX_PATH*10];
    CHAR        LastDir[MAX_PATH];
    DWORD       Tracing;
    DWORD       Aliasing;
    DWORD       HeapChecking;
    DWORD       PreLoadSymbols;
    DWORD       ApiCounters;
    DWORD       GoImmediate;
    DWORD       FastCounters;
    DWORD       UseKnownDlls;
    DWORD       ExcludeKnownDlls;
    DWORD       MonitorPageFaults;
    INT         GraphFilterValue;
    BOOL        DisplayLegends;
    BOOL        FilterGraphs;
    BOOL        AutoRefresh;
    SORT_TYPE   DefaultSort;
    POSITION    FramePosition;
    POSITION    DllPosition;
    POSITION    CounterPosition;
    POSITION    PagePosition;
    LOGFONT     LogFont;
    COLORREF    Color;
    COLORREF    CustColors[16];
    CHAR        KnownDlls[2048];
} OPTIONS, *POPTIONS;

typedef struct _PROCESS_INFO    *PPROCESS_INFO;
typedef struct _THREAD_INFO     *PTHREAD_INFO;
typedef struct _BREAKPOINT_INFO *PBREAKPOINT_INFO;

typedef DWORD (*PBP_HANDLER)(PPROCESS_INFO,PTHREAD_INFO,PEXCEPTION_RECORD,PBREAKPOINT_INFO);

#define BPF_UNINSTANCIATED      0x00000001
#define BPF_DISABLED            0x00000002
#define BPF_TRACE               0x00000004
#define BPF_WATCH               0x00000008

typedef struct _BREAKPOINT_INFO {
    ULONG_PTR               Address;
    ULONG                   OriginalInstr;
    ULONG                   Flags;
    ULONG                   Number;
    LPSTR                   SymName;
    PBP_HANDLER             Handler;
    PVOID                   Text;
    ULONG                   TextSize;
    CONTEXT                 Context;
    LPSTR                   Command;
    struct _BREAKPOINT_INFO *LastBp;
} BREAKPOINT_INFO, *PBREAKPOINT_INFO;

typedef struct _THREAD_INFO {
    struct _THREAD_INFO     *Next;
    HANDLE                  hProcess;
    HANDLE                  hThread;
    ULONG                   ThreadId;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _PROCESS_INFO {
    struct _PROCESS_INFO    *Next;
    HANDLE                  hProcess;
    DWORD                   ProcessId;
    BOOL                    SeenLdrBp;
    BOOL                    FirstProcess;
    DWORD_PTR               LoadAddress;
    DWORD_PTR               EntryPoint;
    DWORD_PTR               TrojanAddress;
    THREAD_INFO             ThreadInfo;
    BREAKPOINT_INFO         Breakpoints[MAX_BREAKPOINTS];
    ULONG                   UserBpCount;
    BOOL                    StaticLink;
} PROCESS_INFO, *PPROCESS_INFO;

typedef struct _SYMBOL_ENUM_CXT {
    PAPI_INFO               ApiInfo;
    PDLL_INFO               DllInfo;
    DWORD                   Cnt;
} SYMBOL_ENUM_CXT, *PSYMBOL_ENUM_CXT;

typedef struct _REG {
    char    *psz;
    ULONG   value;
} REG, *LPREG;

typedef struct _SUBREG {
    ULONG   regindex;
    ULONG   shift;
    ULONG   mask;
} SUBREG, *LPSUBREG;

typedef union _CONVERTED_DOUBLE {
    double d;
    ULONG ul[2];
    LARGE_INTEGER li;
} CONVERTED_DOUBLE, *PCONVERTED_DOUBLE;

typedef struct _TOOLBAR_STATE {
    ULONG   Id;
    BOOL    State;
    LPSTR   Msg;
} TOOLBAR_STATE, *PTOOLBAR_STATE;


//
// function pointer types for PSAPI.DLL
//
typedef BOOL  (WINAPI *INITIALIZEPROCESSFORWSWATCH)(HANDLE);
typedef BOOL  (WINAPI *RECORDPROCESSINFO)(HANDLE,ULONG);
typedef BOOL  (WINAPI *GETWSCHANGES)(HANDLE,PPSAPI_WS_WATCH_INFORMATION,DWORD);


//
// externs
//
extern PIMAGEHLP_SYMBOL sym;
extern DWORDLONG        PerfFreq;
extern double           MSecConv;
extern PDLL_INFO        DllList;
extern PVOID            MemPtr;
extern OPTIONS          ApiMonOptions;
extern BOOL             DebugeeActive;
extern HANDLE           ReleaseDebugeeEvent;
extern HANDLE           CurrProcess;
extern DWORD            UiRefreshRate;
extern HWND             hwndFrame;
extern HFONT            hFont;
extern DWORD            ChildFocus;
extern HANDLE           CurrProcess;
extern COLORREF         CustomColors[];
extern HWND             hwndMDIClient;
extern HANDLE           hProcessWs;
extern HANDLE           ApiTraceMutex;
extern PTRACE_BUFFER    TraceBuffer;
extern LPSTR            CmdParamBuffer;
extern CHAR             KnownApis[2048];

extern HMODULE                      hModulePsApi;
extern INITIALIZEPROCESSFORWSWATCH  pInitializeProcessForWsWatch;
extern RECORDPROCESSINFO            pRecordProcessInfo;
extern GETWSCHANGES                 pGetWsChanges;

#ifdef __cplusplus
extern "C" {
#endif
    extern LPDWORD      ApiCounter;
    extern LPDWORD      FastCounterAvail;
    extern LPDWORD      ApiTraceEnabled;
    extern BOOL         RunningOnNT;
#ifdef __cplusplus
}
#endif


typedef int (__cdecl *PCOMPARE_ROUTINE)(const void*,const void*);

//
// prototypes
//
BOOL
RegInitialize(
    POPTIONS o
    );

BOOL
RegSave(
    POPTIONS o
    );

void
__cdecl
dprintf(
    char *format,
    ...
    );

VOID
__cdecl
PopUpMsg(
    char *format,
    ...
    );

VOID
Fail(
    UINT Error
    );

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    );

BOOL
BrowseForFileName(
    LPSTR FileName,
    LPSTR Extension,
    LPSTR FileDesc
    );

BOOL
WinApp(
    HINSTANCE   hInstance,
    INT         nShowCmd,
    LPSTR       ProgName,
    LPSTR       Arguments,
    BOOL        GoImmediate
    );

DWORD
DebuggerThread(
    LPSTR CmdLine
    );

BOOL
LogApiCounts(
    PCHAR   FileName
    );

BOOL
LogApiTrace(
    PCHAR   FileName
    );

VOID
SaveOptions(
    VOID
    );

CLINKAGE ULONG
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    );

CLINKAGE BOOL
WriteMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    );

CLINKAGE VOID
DisableHeapChecking(
    HANDLE  hProcess,
    PVOID   HeapHandle
    );

LPSTR
UnDname(
    LPSTR sym
    );

PDLL_INFO
GetModuleForAddr(
    ULONG_PTR Addr
    );

PAPI_INFO
GetApiForAddr(
    ULONG_PTR Addr
    );

VOID
PrintRegisters(
    VOID
    );

PPROCESS_INFO
GetProcessInfo(
    HANDLE hProcess
    );

PTHREAD_INFO
GetThreadInfo(
    HANDLE hProcess,
    HANDLE hThread
    );

PBREAKPOINT_INFO
SetBreakpoint(
    PPROCESS_INFO   ThisProcess,
    DWORD_PTR       Address,
    DWORD           Flags,
    LPSTR           SymName,
    PBP_HANDLER     Handler
    );

LPSTR
GetAddress(
    LPSTR   CmdBuf,
    DWORD_PTR *Address
    );

BOOL
InstanciateBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    );

BOOL
ResumeAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    );

BOOL
SuspendAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    );

DWORD
ConsoleDebugger(
    HANDLE              hProcess,
    HANDLE              hThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    BOOL                FirstChance,
    BOOL                UnexpectedException,
    LPSTR               InitialCommand
    );

ULONG_PTR
GetNextOffset(
    HANDLE    hProcess,
    ULONG_PTR Address,
    BOOL      Step
    );

BOOL
ClearBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    );

PBREAKPOINT_INFO
GetAvailBreakpoint(
    PPROCESS_INFO   ThisProcess
    );

LPVOID
MemAlloc(
    ULONG Size
    );

VOID
MemFree(
    LPVOID MemPtr
    );

BOOL
CreateDebuggerConsole(
    VOID
    );

BOOL
PrintOneInstruction(
    HANDLE  hProcess,
    ULONG_PTR   Address
    );

ULONG
GetIntRegNumber(
    ULONG index
    );

DWORDLONG
GetRegFlagValue(
    ULONG RegNum
    );

DWORDLONG
GetRegValue(
    ULONG RegNum
    );

VOID
GetFloatingPointRegValue(
    ULONG               regnum,
    PCONVERTED_DOUBLE   dv
    );

DWORDLONG
GetRegPCValue(
    ULONG_PTR * Address
    );

LONG
GetRegString(
    LPSTR RegString
    );

BOOL
LoadSymbols(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    HANDLE              hFile
    );

BOOL
IsDelayInstruction(
    HANDLE  hProcess
    );

ULONG_PTR
GetExpression(
    LPSTR CommandString
    );

BOOL
GetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    );

BOOL
SetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    );

BOOL
disasm(
    HANDLE     hProcess,
    ULONG_PTR *poffset,
    LPSTR      bufptr,
    BOOL       fEAout
    );

DWORD
TraceBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

HWND
ChildCreate(
    HWND    hwnd
    );

VOID
SetMenuState(
    DWORD id,
    DWORD st
    );

VOID
SaveWindowPos(
    HWND        hwnd,
    PPOSITION   Pos,
    BOOL        ChildWindow
    );

VOID
ProcessHelpRequest(
    HWND hwnd,
    INT  DlgCtrl
    );

BOOL
CreateOptionsPropertySheet(
    HINSTANCE   hInstance,
    HWND        hwnd
    );

VOID
SetApiCounterEnabledFlag(
    BOOL  Flag,
    LPSTR DllName
    );

VOID
ClearApiCounters(
    VOID
    );

VOID
ClearApiTrace(
    VOID
    );

LRESULT CALLBACK
MDIChildWndProcCounters(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcPage(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcDlls(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcGraph(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcTrace(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
SetWindowPosition(
    HWND        hwnd,
    PPOSITION   Pos
    );

BOOL
GetOffsetFromSym(
    LPSTR   pString,
    PULONG_PTR pOffset
    );

PAPI_INFO
GetApiInfoByAddress(
    ULONG_PTR    Address,
    PDLL_INFO   *DllInfo
    );

VOID
EnableToolbarState(
    DWORD   Id
    );

VOID
DisableToolbarState(
    DWORD   Id
    );

VOID
ReallyDisableToolbarState(
    DWORD   Id
    );

PDLL_INFO
AddDllToList(
    PTHREAD_INFO    ThisThread,
    ULONG_PTR       DllAddr,
    LPSTR           DllName,
    ULONG           DllSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\apimonwn.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonwin.h

Abstract:

    Implemenation for the base ApiMon child window class.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


ApiMonWindow::ApiMonWindow()
{
    hInstance    = GetModuleHandle( NULL );
    hwndWin      = NULL;
    hwndList     = NULL;
    SortRoutine  = NULL;
    hFont        = NULL;
    Color        = 0;
    ZeroMemory( &Position, sizeof(POSITION) );
}


ApiMonWindow::~ApiMonWindow()
{
}


BOOL
ApiMonWindow::Create(
    LPSTR   ClassName,
    LPSTR   Title
    )
{
    hwndWin = CreateMDIWindow(
        ClassName,
        Title,
        0,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        hwndMDIClient,
        hInstance,
        (LPARAM) this
        );

    if (!hwndWin) {
        return FALSE;
    }

    ShowWindow(
        hwndWin,
        SW_SHOW
        );

    return TRUE;
}


BOOL
ApiMonWindow::Register(
    LPSTR   ClassName,
    ULONG   ChildIconId,
    WNDPROC WindowProc
    )
{
    WNDCLASSEX  wc;

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(ChildIconId));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
    wc.lpszMenuName  = NULL;
    wc.hIconSm       = (HICON)LoadImage(
                           hInstance,
                           MAKEINTRESOURCE(ChildIconId),
                           IMAGE_ICON,
                           16,
                           16,
                           0
                           );

    wc.lpfnWndProc   = WindowProc;
    wc.lpszClassName = ClassName;

    return RegisterClassEx( &wc );
}


void
ApiMonWindow::ChangeFont(
    HFONT hFont
    )
{
    if (hwndList) {
        ApiMonWindow::hFont = hFont;
        SendMessage(
            hwndList,
            WM_SETFONT,
            (WPARAM)hFont,
            MAKELPARAM( TRUE, 0 )
            );
    }
}


void
ApiMonWindow::ChangeColor(
    COLORREF Color
    )
{
    if (hwndList) {
        ApiMonWindow::Color = Color;
        ListView_SetBkColor( hwndList, Color );
        ListView_SetTextBkColor( hwndList, Color );

        InvalidateRect( hwndList, NULL, TRUE );
        UpdateWindow( hwndList );
    }
}


void
ApiMonWindow::ChangePosition(
    PPOSITION Position
    )
{
    ApiMonWindow::Position = *Position;
    SetWindowPosition( hwndWin, Position );
}


void
ApiMonWindow::SetFocus()
{
    BringWindowToTop( hwndWin );
    SetForegroundWindow( hwndWin );
}


BOOL
ApiMonWindow::Update(
    BOOL ForceUpdate
    )
{
    if ((!hwndWin) || (!hwndList)) {
        return FALSE;
    }
    return TRUE;
}

void
ApiMonWindow::DeleteAllItems()
{
    ListView_DeleteAllItems( hwndList );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\apimon.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimon.cpp

Abstract:

    Main entrypoint code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#include "alias.h"
#pragma hdrstop

extern HWND                 hwndDlg;
extern DWORD                BaseTime;
extern DWORD                StartingTick;
extern DWORD                EndingTick;
extern SYSTEMTIME           StartingLocalTime;
extern API_MASTER_TABLE     ApiTables[];

HANDLE                      ReleaseDebugeeEvent;
HANDLE                      hMap;
HANDLE                      ApiTraceMutex;
HANDLE                      ApiMemMutex;
PVOID                       MemPtr;
PTRACE_BUFFER               TraceBuffer;
ULONG                       TraceBufSize = MAX_MEM_ALLOC;
LPSTR                       CmdParamBuffer;
PDLL_INFO                   DllList;
HANDLE                      ApiMonMutex;
DWORDLONG                   PerfFreq;
OPTIONS                     ApiMonOptions;
DWORD                       UiRefreshRate = 1000;
BOOL                        BreakInNow;
BOOL                        StopOnFirstChance;
BOOL                        CallTreeTrace;
BOOL                        PatchWndProcs;
HMODULE                     hModulePsApi;
INITIALIZEPROCESSFORWSWATCH pInitializeProcessForWsWatch;
RECORDPROCESSINFO           pRecordProcessInfo;
GETWSCHANGES                pGetWsChanges;
CHAR                        KnownApis[2048];
FILE                        *fThunkLog;
double                      MSecConv;


#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;


extern "C" {
    LPDWORD                 ApiCounter;
    LPDWORD                 ApiTraceEnabled;
    LPDWORD                 ApiTimingEnabled;
    LPDWORD                 FastCounterAvail;
    LPDWORD                 ApiOffset;
    LPDWORD                 ApiStrings;
    LPDWORD                 ApiCount;
    LPDWORD                 WndProcEnabled;
    LPDWORD                 WndProcCount;
    LPDWORD                 WndProcOffset;
    BOOL                    RunningOnNT;
}

INT_PTR CALLBACK
HelpDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    if (uMessage == WM_INITDIALOG) {
        CenterWindow( hdlg, NULL );
    }
    if (uMessage == WM_COMMAND) {
        EndDialog( hdlg, 0 );
    }
    return FALSE;
}

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nShowCmd
    )
{
    CHAR            ProgName[MAX_PATH];
    CHAR            Arguments[MAX_PATH*2];
    DWORD           i;
    LPSTR           pchApi;
    OSVERSIONINFO   OsVersionInfo;


    //
    // see if we are running on NT
    // this is necessary because APIMON implements some
    // features that are NOT available on WIN95
    //
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx( &OsVersionInfo );
    RunningOnNT = OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    sym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    sym->MaxNameLength = MAX_SYMNAME_SIZE;

    //
    // jack up our priority class
    //
    SetPriorityClass(
        GetCurrentProcess(),
        HIGH_PRIORITY_CLASS
        );

    //
    // process the command line
    //
    LPSTR p = NULL;
    DWORD GoImmediate = 0;
    ProgName[0] = 0;
    Arguments[0] = 0;
    // skip any white space
    //
    while( *lpCmdLine && *lpCmdLine == ' ' ) {
        lpCmdLine += 1;
    }
    //
    // get the command line options
    //
    while( *lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/') ) {
        lpCmdLine += 1;
        CHAR ch = (CHAR)tolower(*lpCmdLine);
        lpCmdLine += 1;
        switch( ch ) {

            case 'a':
                // Find the end of KnownApis multistring
                // (2nd zero of terminating double zero)
                pchApi = KnownApis;
                if (*pchApi) {
                    while (*pchApi++ || *pchApi);
                }

                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');


                while (ch != ' ' && ch != '\t' && ch != 0) {
                    *pchApi++ = ch;
                    ch = *lpCmdLine++;
                }
                *pchApi++ = 0;
                *pchApi = 0;

                break;

            case 'b':
                BreakInNow = TRUE;
                break;

            case 'c':
                CallTreeTrace = TRUE;
                break;

            case 'g':
                GoImmediate = TRUE;
                break;


            case 'f':
                StopOnFirstChance = TRUE;
                break;

            case 'm':
                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');
                i=0;
                while (ch >= '0' && ch <= '9') {
                    i = i * 10 + ch - '0';
                    ch = *lpCmdLine++;
                }
                TraceBufSize = i * 1024 * 1024;
                break;

            case 't':
                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');
                i=0;
                while (ch >= '0' && ch <= '9') {
                    i = i * 10 + ch - '0';
                    ch = *lpCmdLine++;
                }
                UiRefreshRate = i;
                break;

            case 'w':
                PatchWndProcs = TRUE;
                break;

            case '?':
                DialogBox( hInstance, MAKEINTRESOURCE( IDD_HELP ), NULL, HelpDialogProc );
                ExitProcess(0);
                break;

            default:
                printf( "unknown option\n" );
                return 1;
        }
        while( *lpCmdLine == ' ' ) {
            lpCmdLine += 1;
        }
    }

    if (*lpCmdLine) {
        //
        // skip any white space
        //
        while( *lpCmdLine && *lpCmdLine == ' ' ) {
            lpCmdLine += 1;
        }
        //
        // get the program name
        //
        p = ProgName;
        while( *lpCmdLine && *lpCmdLine != ' ' ) {
            *p++ = *lpCmdLine;
            lpCmdLine += 1;
        }
        *p = 0;
        if (*lpCmdLine) {
            //
            // skip any white space
            //
            while( *lpCmdLine && *lpCmdLine == ' ' ) {
                lpCmdLine += 1;
            }
            if (*lpCmdLine) {
                //
                // get the program arguments
                //
                p = Arguments;
                while( *lpCmdLine ) {
                    *p++ = *lpCmdLine;
                    lpCmdLine += 1;
                }
                *p = 0;
            }
        }
    }

    ReleaseDebugeeEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!ReleaseDebugeeEvent) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    ApiMonMutex = CreateMutex( NULL, FALSE, "ApiMonMutex" );
    if (!ApiMonMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    ApiMemMutex = CreateMutex( NULL, FALSE, "ApiMemMutex" );
    if (!ApiMemMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    //
    // create the shared memory region for the api counters
    //
    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        MAX_MEM_ALLOC,
        "ApiWatch"
        );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    ApiCounter       = (LPDWORD)   MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)   MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)   MemPtr + 2;
    FastCounterAvail = (LPDWORD)   MemPtr + 3;
    ApiOffset        = (LPDWORD)   MemPtr + 4;
    ApiStrings       = (LPDWORD)   MemPtr + 5;
    ApiCount         = (LPDWORD)   MemPtr + 6;
    WndProcEnabled   = (LPDWORD)   MemPtr + 7;
    WndProcCount     = (LPDWORD)   MemPtr + 8;
    WndProcOffset    = (LPDWORD)   MemPtr + 9;
    DllList          = (PDLL_INFO) ((LPDWORD)MemPtr + 10);

    *ApiOffset       = (MAX_DLLS * sizeof(DLL_INFO));
    *WndProcOffset   = (MAX_APIS * sizeof(API_INFO)) + *ApiOffset;
    *ApiStrings      = (DWORD)(*WndProcOffset + ((ULONG_PTR)DllList - (ULONG_PTR)MemPtr));
    *WndProcEnabled  = PatchWndProcs;

    //
    // create the shared memory region for the api trace buffer
    //
    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        TraceBufSize,
        "ApiTrace"
        );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    TraceBuffer = (PTRACE_BUFFER)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!TraceBuffer) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    TraceBuffer->Size = TraceBufSize - sizeof(TRACE_BUFFER);
    TraceBuffer->Offset = 0;
    TraceBuffer->Count = 0;

    ApiTraceMutex = CreateMutex( NULL, FALSE, "ApiTraceMutex" );
    if (!ApiTraceMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    //
    // create the shared memory region for remote commands
    //
    hMap = CreateFileMapping(
         INVALID_HANDLE_VALUE,
         NULL,
         PAGE_READWRITE | SEC_COMMIT,
         0,
         CMD_PARAM_BUFFER_SIZE,
         CMD_PARAM_BUFFER_NAME
         );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    CmdParamBuffer = (LPSTR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );

    if (!CmdParamBuffer) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    InitCommonControls();

    QueryPerformanceFrequency( (LARGE_INTEGER*)&PerfFreq );
    MSecConv = 1000.0 / (double)(LONGLONG)PerfFreq;

    hModulePsApi = LoadLibrary( "psapi.dll" );
    if (hModulePsApi) {
        pInitializeProcessForWsWatch = (INITIALIZEPROCESSFORWSWATCH) GetProcAddress(
            hModulePsApi,
            "InitializeProcessForWsWatch"
            );
        pRecordProcessInfo = (RECORDPROCESSINFO) GetProcAddress(
            hModulePsApi,
            "RecordProcessInfo"
            );
        pGetWsChanges = (GETWSCHANGES) GetProcAddress(
            hModulePsApi,
            "GetWsChanges"
            );
    } else {
        PopUpMsg( "Page fault profiling is not available.\nPSAPI.DLL is missing." );
    }

#if CREATE_THUNK_LOG
    fThunkLog = fopen( "thunk.log", "w" );
    if (!fThunkLog) {
        PopUpMsg( "Could not open thunk log file" );
        return FALSE;
    }
#endif //CREATE_THUNK_LOG

    WinApp(
        hInstance,
        nShowCmd,
        ProgName,
        Arguments,
        GoImmediate
        );

    if (ProgName[0]) {
        SaveOptions();
    }

#if CREATE_THUNK_LOG
    fclose(fThunkLog);
#endif //CREATE_THUNK_LOG

    return 0;
}

VOID
PrintLogTimes(
    FILE *fout
    )
{
    DWORD EndTime = EndingTick ? EndingTick : GetTickCount();
    SYSTEMTIME EndingLocalTime;

    GetLocalTime( &EndingLocalTime );
    fprintf( fout, "Starting Time: %02d:%02d:%02d.%03d\n",
        StartingLocalTime.wHour,
        StartingLocalTime.wMinute,
        StartingLocalTime.wSecond,
        StartingLocalTime.wMilliseconds
        );
    fprintf( fout, "Ending Time:   %02d:%02d:%02d.%03d\n",
        EndingLocalTime.wHour,
        EndingLocalTime.wMinute,
        EndingLocalTime.wSecond,
        EndingLocalTime.wMilliseconds
        );
    DWORD ElapsedTime         = EndTime - StartingTick;
    DWORD ElapsedHours        = ElapsedTime / (1000 * 60 * 60);
    ElapsedTime               = ElapsedTime % (1000 * 60 * 60);
    DWORD ElapsedMinutes      = ElapsedTime / (1000 * 60);
    ElapsedTime               = ElapsedTime % (1000 * 60);
    DWORD ElapsedSeconds      = ElapsedTime / 1000;
    DWORD ElapsedMilliseconds = ElapsedTime % 1000;
    fprintf(
        fout, "Elapsed Time:  %02d:%02d:%02d.%03d\n",
        ElapsedHours,
        ElapsedMinutes,
        ElapsedSeconds,
        ElapsedMilliseconds
        );
    fprintf( fout, "\n" );
}


void PrintLogType(FILE *fout, CAliasTable *pals, ULONG ulType, ULONG_PTR ulHandle, PUCHAR *pp)
{
    char szAlias[kcchAliasNameMax];
    ULONG len;

    switch(ulType) {
    case T_LPSTR:
        __try {
            len = strlen((LPSTR) *pp);
            if (len != 0) {
                fprintf( fout, "%10.10s ", *pp );
            } else {
                fprintf( fout, "%10.10s ", "NULL");
            }
            *pp += Align (sizeof(WCHAR), (len + 1));
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            fprintf( fout, "%10.10s ", "***GPF***");
            return;
        }
        break;
    case T_LPWSTR:
        __try {
            len = wcslen((LPWSTR) *pp );
            if (len != 0) {
                fprintf( fout, "%10.10ws ", *pp );
            } else {
                fprintf( fout, "%10.10s ", "NULL");
            }
            *pp += (len + 1) * sizeof(WCHAR);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            fprintf( fout, "%10.10s ", "***GPF***");
            return;
        }
        break;
    case T_HACCEL:
    case T_HANDLE:
    case T_HBITMAP:
    case T_HBRUSH:
    case T_HCURSOR:
    case T_HDC:
    case T_HDCLPPOINT:
    case T_HDESK:
    case T_HDWP:
    case T_HENHMETAFILE:
    case T_HFONT:
    case T_HGDIOBJ:
    case T_HGLOBAL:
    case T_HGLRC:
    case T_HHOOK:
    case T_HICON:
    case T_HINSTANCE:
    case T_HKL:
    case T_HMENU:
    case T_HMETAFILE:
    case T_HPALETTE:
    case T_HPEN:
    case T_HRGN:
    case T_HWINSTA:
    case T_HWND:
        pals->Alias(ulType, ulHandle, szAlias);
        fprintf( fout, "%10.10s ", szAlias);
        break;
    case T_DWORD:
    case T_DWORDPTR:
    case T_DLONGPTR:
        fprintf( fout, "0x%08x ", ulHandle);
        break;
    }
}

BOOL
LogApiCounts(
    PCHAR  FileName
    )
{
    FILE *fout;
    ULONG i,j,k,len;
    LPSTR Name;
    DWORDLONG Time;
    DWORDLONG BaseTime;
    double NewTime;
    double NewCalleeTime;
    CHAR LogFileName[MAX_PATH];
    PTRACE_ENTRY TraceEntry;
    PAPI_INFO ApiInfo;
    PDLL_INFO DllInfo;
    PAPI_MASTER_TABLE ApiMaster;
    PAPI_TABLE ApiTable;
    PUCHAR p;

    ExpandEnvironmentStrings(
        FileName,
        LogFileName,
        MAX_PATH
        );
    fout = fopen( LogFileName, "w" );
    if (!fout) {
        PopUpMsg( "Could not open log file" );
        return FALSE;
    }

    fprintf( fout, "-------------------------------------------\n" );
    fprintf( fout, "-API Monitor Report\n" );
    fprintf( fout, "-\n" );
    if (*FastCounterAvail) {
        fprintf( fout, "-Times are in raw processor clock cycles\n" );
    } else {
        fprintf( fout, "-Times are in milliseconds\n" );
    }
    fprintf( fout, "-\n" );
    fprintf( fout, "-------------------------------------------\n" );
    fprintf( fout, "\n" );

    PrintLogTimes( fout );

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
        if (!DllList[i].ApiCount) {
            continue;
        }
#if DEBUG_DUMP
        k = DllList[i].ApiCount;
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "%s\n", DllInfo->Name );
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "       Address  ThunkAddr    Count             Time   Name\n" );
        fprintf( fout, "---------------------------------------------------------------\n" );
#else
        ULONG_PTR *ApiAry = NULL;
        ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
        for (j=0,k=0; j<DllList[i].ApiCount; j++) {
            if (ApiInfo[j].Count) {
                k += 1;
            }
        }
        if (!k) {
            continue;
        }
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (!ApiAry) {
            continue;
        }
        for (j=0,k=0; j<DllList[i].ApiCount; j++) {
            if (ApiInfo[j].Count) {
                ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
            }
        }
        fprintf( fout, "-----------------------------------------------------------\n" );

        if (DllInfo->LoadCount > 1)
            fprintf( fout, "%s (Loaded %d times)\n", DllInfo->Name, DllInfo->LoadCount);
        else
            fprintf( fout, "%s\n", DllInfo->Name );

        fprintf( fout, "-----------------------------------------------------------\n" );
        fprintf( fout, "         Count              Time    Time - Callees   Name\n" );
        fprintf( fout, "-----------------------------------------------------------\n" );


#endif
        for (j=0; j<k; j++) {
#if DEBUG_DUMP
            PAPI_INFO ApiData = &ApiInfo[j];
#else
            PAPI_INFO ApiData = (PAPI_INFO)ApiAry[j];
#endif
            Name = (LPSTR)(ApiData->Name + (LPSTR)MemPtr);
            NewTime = (double)(LONGLONG)ApiData->Time;
            NewCalleeTime = (double)(LONGLONG)ApiData->CalleeTime;

            if (!*FastCounterAvail) {
                NewTime = NewTime * MSecConv;
                NewCalleeTime = NewCalleeTime * MSecConv;
            }

#if DEBUG_DUMP
            fprintf(
                fout,
                "      %08x   %08x %8d %16.4f   %s\n",
                ApiData->Address,
                ApiData->ThunkAddress,
                ApiData->Count,
                NewTime,
                Name
                );
#else
            fprintf(
                fout,
                "      %8d %16.4f %16.4f   %s",
                ApiData->Count,
                NewTime,
                NewTime - NewCalleeTime,
                Name
                );

            if (ApiData->NestCount != 0)
                fprintf(fout,"*\n");
            else
                fprintf(fout,"\n");
#endif
        }
#ifndef DEBUG_DUMP
        MemFree( ApiAry );
#endif
    }

    if (*WndProcCount) {

        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "Window Procedures\n");
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "         Count              Time    Time - Callees   Class Name\n" );
        fprintf( fout, "---------------------------------------------------------------\n" );


        ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
        for (i=0; i<*WndProcCount; i++,ApiInfo++) {

            if (ApiInfo->Count != 0) {
                Name = (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr);

                NewTime = (double)(LONGLONG) ApiInfo->Time;
                NewCalleeTime = (double)(LONGLONG) ApiInfo->CalleeTime;

                if (!*FastCounterAvail) {
                    NewTime = NewTime * MSecConv;
                    NewCalleeTime = NewCalleeTime * MSecConv;
                }

                fprintf(
                    fout,
                    "      %8d %16.4f %16.4f   %s",
                    ApiInfo->Count,
                    NewTime,
                    NewTime - NewCalleeTime,
                    Name
                    );

                if (ApiInfo->NestCount != 0)
                    fprintf(fout,"*\n");
                else
                    fprintf(fout,"\n");
            }
        }
    }

    fclose( fout );
    return TRUE;
}


BOOL
LogApiTrace(
    PCHAR  FileName
    )
{
    FILE *fout;
    ULONG i,j,k,len, ArgCount;
    LPSTR Name;
    DWORDLONG Time;
    DWORDLONG BaseTime;
    double EnterTime;
    double Duration;
    CHAR LogFileName[MAX_PATH];
    PTRACE_ENTRY TraceEntry;
    PAPI_INFO ApiInfo;
    PDLL_INFO DllInfo;
    PDLL_INFO CallerDllInfo;
    LPSTR     DllName;
    PAPI_MASTER_TABLE ApiMaster;
    PAPI_TABLE ApiTable;
    PUCHAR p;

    ExpandEnvironmentStrings(
        FileName,
        LogFileName,
        MAX_PATH
        );
    fout = fopen( LogFileName, "w" );
    if (!fout) {
        PopUpMsg( "Could not open trace file" );
        return FALSE;
    }

    WaitForSingleObject( ApiTraceMutex, INFINITE );

    if (ApiMonOptions.Aliasing) {
        fprintf(
            fout,
            "LastError  ReturnVal  Name\n"
            );
    }
    else {
        fprintf(
            fout,
            "Thd Lev    Start Time        Duration      ReturnVal  LastError           Caller           Name       Arguments\n"
        );
    }

    CAliasTable als;

    TraceEntry = TraceBuffer->Entry;
    BaseTime = TraceEntry->EnterTime;

    for (i=0; i<TraceBuffer->Count; i++) {
        ApiInfo = GetApiInfoByAddress( TraceEntry->Address, &DllInfo );

        if (ApiInfo) {
            EnterTime = (double)(LONGLONG)(TraceEntry->EnterTime - BaseTime);
            Duration = (double)(LONGLONG)TraceEntry->Duration;

            if (!*FastCounterAvail) {
                EnterTime = EnterTime * MSecConv;
                Duration = Duration * MSecConv;
            }

            CallerDllInfo = GetModuleForAddr(TraceEntry->Caller);
            if (CallerDllInfo)
                DllName = CallerDllInfo->Name;
            else
                DllName = "???";

            ApiTable = NULL;
            if (TraceEntry->ApiTableIndex) {
                p = (PUCHAR) ((PUCHAR)TraceEntry + sizeof(TRACE_ENTRY));
                j = 0;
                while( ApiTables[j].Name ) {
                    if (_stricmp( ApiTables[j].Name, DllInfo->Name ) == 0) {
                        ApiTable = &ApiTables[j].ApiTable[TraceEntry->ApiTableIndex-1];
                        break;
                    }
                    j += 1;
                }
            }

            if (ApiMonOptions.Aliasing) {
                if (ApiTable) {
                    p = (PUCHAR) ((PUCHAR)TraceEntry + sizeof(TRACE_ENTRY));
                    fprintf( fout, "0x%08x ", TraceEntry->LastError);
                    PrintLogType(fout, &als, ApiTable->RetType, TraceEntry->ReturnValue, &p);
                    fprintf( fout, "%-25.25s ", (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr));
                    for (k=0; k<ApiTable->ArgCount; k++) {
                        PrintLogType(fout, &als, LOWORD(ApiTable->ArgType[k]), TraceEntry->Args[k], &p);
                    }
                    fprintf( fout, "\n");
                }
            }
            else {
                fprintf(
                    fout,
                    "%3d %3d %16.4f %16.4f 0x%08x 0x%08x %-12s 0x%08x %-24s",
                    TraceEntry->ThreadNum,
                    TraceEntry->Level,
                    EnterTime,
                    Duration,
                    TraceEntry->ReturnValue,
                    TraceEntry->LastError,
                    DllName,
                    TraceEntry->Caller,
                    (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr));

                ArgCount = (ApiTable && ApiTable->ArgCount) ? ApiTable->ArgCount : DFLT_TRACE_ARGS;
                for (k=0; k<ArgCount; k++)
                    fprintf(fout, " 0x%08x",TraceEntry->Args[k]);

                fprintf(fout, "\n");

                if (ApiTable) {
                    for (k=0; k<ApiTable->ArgCount; k++) {
                        switch( LOWORD(ApiTable->ArgType[k]) ) {

                            case T_LPSTR:
                            case T_LPSTRC:
                                fprintf( fout, "%s\n", p );
                                len = strlen( (LPSTR) p ) + 1;
                                len = Align( sizeof(WCHAR), len );
                                p += len;
                                break;

                            case T_LPWSTR:
                            case T_LPWSTRC:
                            case T_UNISTR:
                            case T_OBJNAME:
                                fwprintf( fout, L"%s\n", p );
                                len = (wcslen( (LPWSTR) p ) + 1) * sizeof(WCHAR);
                                p += len;
                                break;
                        }
                    }
                }
            }

            TraceEntry = (PTRACE_ENTRY) ((PUCHAR)TraceEntry + TraceEntry->SizeOfStruct);
        }
    }

    ReleaseMutex( ApiTraceMutex );

    fclose( fout );

    return TRUE;
}

PDLL_INFO
GetDllInfoByName(
    LPSTR DllName
    )
{
    ULONG i;


    if (!DllName) {
        return NULL;
    }

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        if (_stricmp(DllName, DllInfo->Name) == 0) {
            return DllInfo;
        }
    }

    return NULL;
}


PAPI_INFO
GetApiInfoByAddress(
    ULONG_PTR   Address,
    PDLL_INFO   *DllInfo
    )
{
    ULONG     i;
    PAPI_INFO ApiInfo;
    LONG      High;
    LONG      Low;
    LONG      Middle;


    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress &&
            Address >= DllList[i].BaseAddress &&
            Address < DllList[i].BaseAddress + DllList[i].Size) {
                //
                // find the api in the dll
                //
                ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);

                Low = 0;
                High = DllList[i].ApiCount - 1;

                while (High >= Low) {
                    Middle = (Low + High) >> 1;
                    if (Address < ApiInfo[Middle].Address) {

                        High = Middle - 1;

                    } else if (Address > ApiInfo[Middle].Address) {

                        Low = Middle + 1;

                    } else {

                        *DllInfo = &DllList[i];
                        return &ApiInfo[Middle];

                    }
                }
        }
    }
    return NULL;
}


VOID
SetApiCounterEnabledFlag(
    BOOL  Flag,
    LPSTR DllName
    )
{
    ULONG i;

    if (DllName) {
        PDLL_INFO DllInfo = GetDllInfoByName( DllName );
        if (DllInfo) {
            DllInfo->Enabled = Flag;
        }
        return;
    }

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        DllInfo->Enabled = Flag;
    }
}

VOID
ClearApiCounters(
    VOID
    )
{
    ULONG i,j;

    *ApiCounter = 0;

    PAPI_INFO ApiInfo;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                ApiInfo[j].Count      = 0;
                ApiInfo[j].Time       = 0;
                ApiInfo[j].CalleeTime = 0;
                ApiInfo[j].HardFault  = 0;
                ApiInfo[j].SoftFault  = 0;
                ApiInfo[j].CodeFault  = 0;
                ApiInfo[j].DataFault  = 0;
            }
        }
    }

    ApiInfo = (PAPI_INFO)(*WndProcOffset + (PUCHAR)DllList);
    for (i=0; i<*WndProcCount; i++) {
        ApiInfo[i].Count      = 0;
        ApiInfo[i].Time       = 0;
        ApiInfo[i].CalleeTime = 0;
        ApiInfo[i].HardFault  = 0;
        ApiInfo[i].SoftFault  = 0;
        ApiInfo[i].CodeFault  = 0;
        ApiInfo[i].DataFault  = 0;
    }

    StartingTick = GetTickCount();
    GetLocalTime(&StartingLocalTime);
}

VOID
ClearApiTrace(
    VOID
    )
{
    WaitForSingleObject( ApiTraceMutex, INFINITE );
    TraceBuffer->Offset = 0;
    TraceBuffer->Count = 0;
    ReleaseMutex(ApiTraceMutex);
}

void
__cdecl
dprintf(char *format, ...)
{
    char    buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);
    OutputDebugString( buf );
    return;
}

LPVOID
MemAlloc(
    ULONG Size
    )
{
    PVOID MemPtr = malloc( Size );
    if (MemPtr) {
        ZeroMemory( MemPtr, Size );
    }
    return MemPtr;
}

VOID
MemFree(
    LPVOID MemPtr
    )
{
    free( MemPtr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\alias.h ===
/****************************** Module Header ******************************\
* Module Name: alias.h
*
* Declarations necessary for ApiMon aliasing.
*
* History:
* 06-11-96 vadimg         created
\***************************************************************************/

#ifndef __ALIAS_H__
#define __ALIAS_H__

const ULONG kcchAliasNameMax = 20;
const ULONG kulTableSize = 257;

class CAliasNode;  /* forward declaration */

class CAliasNode {  /* anod -- node in the hash table */
public:
    CAliasNode();
    CAliasNode(ULONG_PTR ulHandle, long nAlias);

    ULONG_PTR m_ulHandle;  /* handle type */
    long m_nAlias;  /* alias value */

    CAliasNode *m_panodNext;
};

class CAliasTable {  /* als -- open hash table */
public:
    CAliasTable();
    ~CAliasTable();

    void Alias(ULONG ulType, ULONG_PTR ulHandle, char szAlias[]);

private:
    long Lookup(ULONG_PTR ulHandle);
    long Insert(ULONG_PTR ulHandle);

    static ULONG s_ulAlias;
    CAliasNode* m_rgpanod[kulTableSize];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\apitable.cpp ===
#include "..\apidll\apitable.cpp"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\apimonwn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonwin.h

Abstract:

    Class definition for all ApiMon child windows.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

class ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    ApiMonWindow();
    ~ApiMonWindow();

    //
    // create a new instance of the window
    //
    BOOL
    Create(
        LPSTR   ClassName,
        LPSTR   Title
        );

    //
    // class registration (only done once)
    //
    BOOL
    Register(
        LPSTR   ClassName,
        ULONG   ChildIconId,
        WNDPROC WindowProc
        );

    //
    // allow the window to use a new font selection
    //
    void ChangeFont(HFONT);

    //
    // allow the window to use a new background color
    //
    void ChangeColor(COLORREF);

    //
    // change the current position of the window
    //
    void ChangePosition(PPOSITION);

    //
    // give focus to the window
    //
    void SetFocus();

    //
    // clears the list
    //
    void DeleteAllItems();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);


    //
    // data items
    //
    HINSTANCE           hInstance;
    HWND                hwndWin;
    HWND                hwndList;
    PCOMPARE_ROUTINE    SortRoutine;
    HFONT               hFont;
    COLORREF            Color;
    POSITION            Position;

};


class DllListWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    DllListWindow();
    ~DllListWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        LPSTR     DllName,
        ULONG_PTR Address,
        BOOL      Enabled
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};

// Counter window list items
enum {
    CNTR_ITEM_NAME,
    CNTR_ITEM_DLL,
    CNTR_ITEM_COUNT,
    CNTR_ITEM_TIME,
    CNTR_ITEM_CALLEES
    };

class CountersWindow : public ApiMonWindow
{
public:

    // Enable primary sort by Dll
    BOOL    DllSort;

    //
    // constructor & destructor
    //
    CountersWindow();
    ~CountersWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        ULONG       Counter,
        DWORDLONG   Time,
        DWORDLONG   CalleeTime,
        LPSTR       ApiName,
        LPSTR       DllName
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};


#define WORKING_SET_BUFFER_ENTRYS   4096

class PageFaultWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    PageFaultWindow();
    ~PageFaultWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    PageFaultWindow::AddItemToList(
        LPSTR     ApiName,
        ULONG_PTR Hard,
        ULONG_PTR Soft,
        ULONG_PTR Data,
        ULONG_PTR Code
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );

    //
    // data
    //
    PSAPI_WS_WATCH_INFORMATION  WorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];
};


#define BAR_SEP                 5
#define LEGEND_LINE_HEIGHT      7
#define LEGEND_COLOR_WIDTH      50
#define LEGEND_BORDER           5
#define LEGEND_SEP              1
#define LEGEND_ITEM_HEIGHT(f)   ((f)+(LEGEND_SEP*2))
#define LEGEND_HEIGHT(f,n)      (LEGEND_ITEM_HEIGHT(f)*(n))
#define LEGEND_DEFAULT_LINES    3


typedef struct _GRAPH_VALUE {
    CHAR            Name[64];
    ULONG_PTR       Address;
    BOOL            Used;
    COLORREF        Color;
    RECT            Rect;
    DWORD           Hits;
    LONGLONG        Value;
    float           Pct;
} GRAPH_VALUE, *PGRAPH_VALUE;


typedef struct _GRAPH_DATA {
    ULONG           NumberOfBars;
    RECT            SplitRect;
    RECT            LegendRect;
    BOOL            DrawLegend;
    GRAPH_VALUE     Bar[1];
} GRAPH_DATA, *PGRAPH_DATA;


typedef struct _FONT_COLOR_CHANGE {
    HWND            hwndGraph;
    COLORREF        GraphColor;
    HFONT           GraphFont;
} FONT_COLOR_CHANGE, *PFONT_COLOR_CHANGE;


class GraphWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    GraphWindow();
    ~GraphWindow();

    //
    // create a new instance of the window
    //
    BOOL Create(BOOL IsBase);

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // allow the window to use a new font selection
    //
    void ChangeFont(HFONT);

    //
    // allow the window to use a new background color
    //
    void ChangeColor(COLORREF);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        ULONG       Counter,
        DWORDLONG   Time,
        LPSTR       ApiName
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );


    PGRAPH_DATA CreateGraphData();

    PGRAPH_DATA CreateGraphDataApi( ULONG_PTR BaseAddress );

    BOOL DrawBarGraph( PGRAPH_DATA GraphData );

    void ChangeToolTipsRect( PGRAPH_DATA GraphData );

    void CreateToolTips( PGRAPH_DATA GraphData );

    void GraphWindow::DeleteToolTips( PGRAPH_DATA GraphData );


    //
    // data
    //
    HWND            hwndToolTip;
    HCURSOR         GraphCursor;
    HCURSOR         ArrowCursor;
    HCURSOR         HorizSplitCursor;
    PGRAPH_VALUE    Bar;
    PGRAPH_DATA     GraphData;
    HCURSOR         hCursor;
    HWND            hwndLegend;
    TEXTMETRIC      tm;
    BOOL            ApiGraph;
    BOOL            MouseDown;
    POINT           LastPos;
    BOOL            Base;
};


class TraceWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    TraceWindow();
    ~TraceWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void AddItemToList(PTRACE_ENTRY);

    void FillList();

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\browse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    browse.c

Abstract:
    This file implements the functions that make use of the common
    file _open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 20-June-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


UINT_PTR APIENTRY
BrowseHookProc(
    HWND   hwnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure to cause the window to be the foreground
    window and centered.

Arguments:

    hwnd       - window handle to the dialog box
    message    - message number
    wParam     - first message parameter
    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    if (message == WM_INITDIALOG) {
        SetForegroundWindow( hwnd );
        CenterWindow( hwnd, hwndFrame );
    }

    return FALSE;
}

BOOL
BrowseForFileName(
    LPSTR FileName,
    LPSTR Extension,
    LPSTR FileDesc
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    file name;

Arguments:

    FileName - name of the selected file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the FileName is changed to have the selected file name.

--*/

{
    OPENFILENAME   of;
    char           ftitle[MAX_PATH];
    char           title[MAX_PATH];
    char           fname[MAX_PATH];
    char           filter[1024];
    char           szDrive    [_MAX_DRIVE];
    char           szDir      [_MAX_DIR];
    char           szFname    [_MAX_FNAME];
    char           szExt      [_MAX_EXT];


    ftitle[0] = 0;
    sprintf( fname, "*.%s", Extension );
    of.lStructSize = sizeof( OPENFILENAME );
    of.hwndOwner = NULL;
    of.hInstance = GetModuleHandle( NULL );
    sprintf( filter, "%s(*.%s)\0*.%s\0", FileDesc, Extension, Extension );
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    of.lpstrInitialDir = ApiMonOptions.LastDir;
    strcpy( title, "File Selection" );
    of.lpstrTitle = title;
    of.Flags = OFN_ENABLEHOOK;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = Extension;
    of.lCustData = 0;
    of.lpfnHook = BrowseHookProc;
    of.lpTemplateName = NULL;
    if (GetOpenFileName( &of )) {
        strcpy( FileName, fname );
        _splitpath( fname, szDrive, szDir, szFname, szExt );
        strcpy( ApiMonOptions.LastDir, szDrive );
        strcat( ApiMonOptions.LastDir, szDir );
        return TRUE;
    }
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\cntrs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cntrs.cpp

Abstract:

    All user interface code for the api counters monitor window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



int __cdecl
CounterCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return (p2->Count - p1->Count);
    } else {
        return 1;
    }
}


int __cdecl
TimeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->Time > p1->Time) {
            return 1;
        } else if (p2->Time < p1->Time) {
            return -1;
        } else {
            return 0;
        }
    } else {
        return 1;
    }
}

int __cdecl
CalleeTimeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->Time - p2->CalleeTime > p1-> Time - p1->CalleeTime) {
            return 1;
        } else if (p2->Time - p2->CalleeTime < p1->Time - p1->CalleeTime) {
            return -1;
        } else {
            return 0;
        }
    } else {
        return 1;
    }
}

int __cdecl
NameCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( (LPSTR)(p1->Name+(LPSTR)MemPtr), (LPSTR)(p2->Name+(LPSTR)MemPtr) );
    } else {
        return 1;
    }
}

int __cdecl
DllCompare(
    const void *e1,
    const void *e2
    )
{
    PDLL_INFO p1;
    PDLL_INFO p2;

    p1 = (*(PDLL_INFO *)e1);
    p2 = (*(PDLL_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( p1->Name, p2->Name );
    } else {
        return 1;
    }
}

CountersWindow::CountersWindow()
{
}


CountersWindow::~CountersWindow()
{
}


BOOL
CountersWindow::Create()
{
    switch (ApiMonOptions.DefaultSort) {
        case SortByName:
            SortRoutine = NameCompare;
            break;

        case SortByCounter:
            SortRoutine = CounterCompare;
            break;

        case SortByTime:
            SortRoutine = TimeCompare;
            break;

        default:
            SortRoutine = CounterCompare;
            break;
    }

    DllSort = FALSE;

    return ApiMonWindow::Create(
        "ApiMonCounters",
        "Api Counters"
        );
}


BOOL
CountersWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonCounters",
        IDI_CHILDICON,
        MDIChildWndProcCounters
        );
}


BOOL
CountersWindow::Update(
    BOOL ForceUpdate
    )
{
    static ULONG LastApiCounter = 0;
    CHAR OutputBuffer[ 512 ];
    ULONG i,j,k;
    ULONG kStart;
    ULONG DllCnt;
    BOOL  DllUsed;
    PDLL_INFO DllAry[MAX_DLLS];

    if (!hwndList) {
        return FALSE;
    }

    if ((!ForceUpdate) && (LastApiCounter == *ApiCounter)) {
        return FALSE;
    }

    LastApiCounter = *ApiCounter;

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );

    DeleteAllItems();

    PAPI_INFO ApiInfo = NULL;
    DllCnt = 0;
    ULONG_PTR *ApiAry = NULL;
    for (i=0,k=0; i<MAX_DLLS; i++) {
        DllUsed = FALSE;
        if (DllList[i].ApiCount) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Count) {
                    k += 1;
                    DllUsed = TRUE;
                }
            }
        }

        if (DllUsed) {
            DllAry[DllCnt++] = &DllList[i];
        }
    }

    if (DllSort) {
       qsort( DllAry, DllCnt, sizeof(PDLL_INFO), DllCompare);
    }

    if (k) {
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (ApiAry) {

            for (i=0,k=0; i<DllCnt; i++) {
                if (DllAry[i]->ApiCount) {
                    ApiInfo = (PAPI_INFO)(DllAry[i]->ApiOffset + (PUCHAR)DllList);
                    kStart = k;
                    for (j=0; j<DllAry[i]->ApiCount; j++) {
                        if (ApiInfo[j].Count) {
                            ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
                        }
                    }

                    if (DllSort) {
                        qsort(&ApiAry[kStart], k - kStart, sizeof(ULONG_PTR), SortRoutine);
                    }
                }
            }

            if (!DllSort) {
                qsort( ApiAry, k, sizeof(ULONG_PTR), SortRoutine );
            }

            for (i=0; i<k; i++) {
               ApiInfo = (PAPI_INFO)ApiAry[i];
               AddItemToList(
                    ApiInfo->Count,
                    ApiInfo->Time,
                    ApiInfo->CalleeTime,
                    (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr),
                    ((PDLL_INFO)(ApiInfo->DllOffset + (PUCHAR)DllList))->Name
                    );
            }
            MemFree( ApiAry );
        }
    }

    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );

    return TRUE;
}


void
CountersWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "API Name";
    lvc.iSubItem = CNTR_ITEM_NAME;
    lvc.cx = 200;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_NAME, &lvc );

    lvc.pszText = "DLL";
    lvc.iSubItem = CNTR_ITEM_DLL;
    lvc.cx = 20;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_DLL, &lvc );

    lvc.pszText = "Count";
    lvc.iSubItem = CNTR_ITEM_COUNT;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_COUNT, &lvc );

    lvc.pszText = "Time";
    lvc.iSubItem = CNTR_ITEM_TIME;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_TIME, &lvc );

    lvc.pszText = "Time - Callees";
    lvc.iSubItem = CNTR_ITEM_CALLEES;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_CALLEES, &lvc );
}


void
CountersWindow::AddItemToList(
    ULONG       Counter,
    DWORDLONG   Time,
    DWORDLONG   CalleeTime,
    LPSTR       ApiName,
    LPSTR       DllName
    )
{
    LV_ITEM             lvi = {0};
    CHAR                NumText[32];
    int                 iItem;
    double              NewTime;
    double              NewCalleeTime;


    if (!hwndList) {
        return;
    }

    lvi.pszText = ApiName;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = CNTR_ITEM_NAME;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    lvi.pszText = DllName;
    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_DLL;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( NumText, "%5d", Counter );
    lvi.pszText = NumText;
    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_COUNT;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    NewTime = (double)(LONGLONG) Time;
    NewCalleeTime = (double)(LONGLONG) CalleeTime;

    if (!*FastCounterAvail) {
        NewTime = NewTime * MSecConv;
        NewCalleeTime = NewCalleeTime * MSecConv;
    }

    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_TIME;
    lvi.mask = LVIF_TEXT;
    sprintf( NumText, "%7.3f", NewTime );
    lvi.pszText = NumText;
    ListView_SetItem( hwndList, &lvi );

    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_CALLEES;
    lvi.mask = LVIF_TEXT;
    sprintf( NumText, "%7.3f", NewTime - NewCalleeTime );
    lvi.pszText = NumText;
    ListView_SetItem( hwndList, &lvi );

}


void
CountersWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    if (NmHdr->code == LVN_COLUMNCLICK) {
        switch( ((LPNM_LISTVIEW)NmHdr)->iSubItem ) {

            case CNTR_ITEM_NAME:
                //
                // sort by name
                //
                SortRoutine = NameCompare;
                break;

            case CNTR_ITEM_COUNT:
                //
                // sort by count
                //
                SortRoutine = CounterCompare;
                break;

            case CNTR_ITEM_TIME:
                //
                // sort by time
                //
                SortRoutine = TimeCompare;
                break;

            case CNTR_ITEM_CALLEES:
                //
                // sort by time
                //
                SortRoutine = CalleeTimeCompare;
                break;

            case CNTR_ITEM_DLL:
                //
                // Toggle sort by DLL
                //
                DllSort = !DllSort;
                break;

        }
        PostMessage( hwndFrame, WM_UPDATE_COUNTERS, 0, 0 );
    }
}


LRESULT CALLBACK
MDIChildWndProcCounters(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    CountersWindow *cw = (CountersWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMessage) {
        case WM_CREATE:
            cw = (CountersWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) cw );
            cw->hwndList = ChildCreate( hwnd );
            cw->InitializeList();
            SetMenuState( IDM_NEW_COUNTER, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_COUNTER;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.CounterPosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.CounterPosition, TRUE );
            MoveWindow( cw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_NAME, Width * .30 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_DLL, Width * .10 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_COUNT, Width * .20 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_TIME, Width * .20 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_CALLEES, Width * .20 );
            break;

        case WM_NOTIFY:
            cw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_COUNTER, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\dlllist.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dlllist.cpp

Abstract:

    All user interface code for the DLL list window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


DllListWindow::DllListWindow()
{
}


DllListWindow::~DllListWindow()
{
}


BOOL
DllListWindow::Create()
{
    return ApiMonWindow::Create(
        "ApiMonDlls",
        "DLLs In Use"
        );
}


BOOL
DllListWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonDlls",
        IDI_CHILDICON,
        MDIChildWndProcDlls
        );
}


BOOL
DllListWindow::Update(
    BOOL ForceUpdate
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if ((DllList[i].BaseAddress) && (!DllList[i].InList)) {
            AddItemToList(
                DllList[i].Name,
                DllList[i].BaseAddress,
                DllList[i].Enabled
                );
            DllList[i].InList = TRUE;
        }
    }

    return TRUE;
}


void
DllListWindow::InitializeList()
{
    //
    // set/initialize the image list(s)
    //
    HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

    ImageList_AddMasked(
        himlState,
        LoadBitmap( hInstance, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
        RGB (255,0,0)
        );

    ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

    //
    // set/initialize the columns
    //
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 198;
    lvc.pszText = "DLL Name";
    lvc.iSubItem = 0;
    ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
    lvc.pszText = "Address";
    lvc.iSubItem = 1;
    lvc.cx = 75;
    ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
}


void
DllListWindow::AddItemToList(
    LPSTR     DllName,
    ULONG_PTR Address,
    BOOL      Enabled
    )
{
    if (!hwndList) {
        return;
    }

    int iItem = 0;
    LV_ITEM lvi;
    lvi.pszText = _strlwr( DllName );
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.iImage = 0;
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvi.state = Enabled ? LVIS_GCCHECK : LVIS_GCNOCHECK;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    iItem = ListView_InsertItem( hwndList, &lvi );
    if (iItem != -1) {
        lvi.iItem = iItem;
        lvi.iSubItem = 1;
        lvi.mask = LVIF_TEXT;
        lvi.state = 0;
        CHAR AddrText[16];
        sprintf( AddrText, "0x%08x", Address );
        lvi.pszText = AddrText;
        ListView_SetItem( hwndList, &lvi );
    }
}


void
DllListWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    DWORD           dwpos;
    LV_HITTESTINFO  lvhti;
    int             iItemClicked;
    UINT            state;
    CHAR            DllName[64];


    if (NmHdr->code != NM_CLICK) {
        return;
    }

    //
    // Find out where the cursor was
    //
    dwpos = GetMessagePos();
    lvhti.pt.x = LOWORD(dwpos);
    lvhti.pt.y = HIWORD(dwpos);

    MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

    //
    // Now do a hittest with this point.
    //
    iItemClicked = ListView_HitTest( hwndList, &lvhti );

    if (lvhti.flags & LVHT_ONITEMSTATEICON) {
        //
        // Now lets get the state from the item and toggle it.
        //
        state = ListView_GetItemState(
            hwndList,
            iItemClicked,
            LVIS_STATEIMAGEMASK
            );

        state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

        ListView_SetItemState(
            hwndList,
            iItemClicked,
            state,
            LVIS_STATEIMAGEMASK
            );

        ListView_GetItemText( hwndList, iItemClicked, 0, DllName, sizeof(DllName) );
        SetApiCounterEnabledFlag( state == LVIS_GCCHECK, DllName );
    }
}

LRESULT CALLBACK
MDIChildWndProcDlls(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width, i;
    DllListWindow *dlw = (DllListWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );


    switch (uMessage) {
        case WM_CREATE:
            dlw = (DllListWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) dlw );
            dlw->hwndList = ChildCreate( hwnd );
            dlw->InitializeList();
            SetMenuState( IDM_NEW_DLL, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_DLL;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.DllPosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.DllPosition, TRUE );
            MoveWindow( dlw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( dlw->hwndList, 0, Width * .60 );
            ListView_SetColumnWidth( dlw->hwndList, 1, Width * .40 );
            break;

        case WM_NOTIFY:
            dlw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_DLL, MF_ENABLED );
            for (i=0; i<MAX_DLLS; i++) {
                if (DllList[i].BaseAddress) {
                    DllList[i].InList = FALSE;
                }
            }
            return 0;
    }

    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\condebug.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    condebug.cpp

Abstract:

    This module contains a simple console mode debugger.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

extern HANDLE       CurrProcess;
extern HANDLE       CurrThread;
extern PDLL_INFO    DllList;
extern BOOL         BreakInNow;
extern ULONG        BpSize;
extern ULONG        BpInstr;
extern HANDLE       BreakinEvent;
extern BOOL         ExprError;
extern PUCHAR       pchCommand;


BOOL                ConsoleCreated;
CONTEXT             CurrContext;
BOOL                Stepped;
BOOL                PrintRegistersFlag = TRUE;


BOOL
GetOffsetFromSym(
    LPSTR   pString,
    ULONG_PTR *pOffset
    )
{
    CHAR   SuffixedString[256+64];
    CHAR   Suffix[4];

    //
    // Nobody should be referencing a 1 character symbol!  It causes the
    // rest of us to pay a huge penalty whenever we make a typo.  Please
    // change to 2 character instead of removing this hack!
    //

    if ( strlen(pString) == 1 || strlen(pString) == 0 ) {
        return FALSE;
    }

    if (SymGetSymFromName( CurrProcess, pString, sym )) {
        *pOffset = sym->Address;
        return TRUE;
    }

    return FALSE;
}

LPSTR
GetAddress(
    LPSTR   CmdBuf,
    PDWORD_PTR Address
    )
{
    *Address = GetExpression( CmdBuf );
    return (LPSTR) pchCommand;
}

BOOL
CmdStackTrace(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    CONTEXT     Context;
    STACKFRAME  StackFrame = {0};
    BOOL        rVal = FALSE;



    CopyMemory( &Context, &CurrContext, sizeof(CONTEXT) );

#if defined(_M_IX86)
    StackFrame.AddrPC.Offset       = Context.Eip;
    StackFrame.AddrPC.Mode         = AddrModeFlat;
    StackFrame.AddrFrame.Offset    = Context.Ebp;
    StackFrame.AddrFrame.Mode      = AddrModeFlat;
    StackFrame.AddrStack.Offset    = Context.Esp;
    StackFrame.AddrStack.Mode      = AddrModeFlat;
#endif

    printf( "\n" );
    do {
        rVal = StackWalk(
            MACHINE_TYPE,
            hProcess,
            0,
            &StackFrame,
            &Context,
            (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
            SymFunctionTableAccess,
            SymGetModuleBase,
            NULL
            );
        if (rVal) {
            ULONG_PTR Displacement;
            printf( "%08x %08x ",
                StackFrame.AddrFrame.Offset,
                StackFrame.AddrReturn.Offset
                );
            if (SymGetSymFromAddr( hProcess, StackFrame.AddrPC.Offset, &Displacement, sym )) {
                printf( "%s\n", sym->Name );
            } else {
                printf( "0x%08x\n", StackFrame.AddrPC.Offset );
            }
        }
    } while( rVal );

    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayMemory(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    static ULONG_PTR Address = 0;

    //
    // skip any command modifiers & white space that may follow
    //
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    ULONG_PTR ThisAddress;
    GetAddress( CmdBuf, &ThisAddress );
    if (ThisAddress) {
        Address = ThisAddress;
    }

    ULONG DataSize = 20*16;  // 20 lines @ 16 bytes per line
    LPSTR DataBuf = (LPSTR) MemAlloc( DataSize );
    if (!DataBuf) {
        return FALSE;
    }

    ULONG cb;
    if (!ReadMemory( hProcess, (PVOID)Address, DataBuf, DataSize )) {
        printf( "could not read memory\n" );
        MemFree( DataBuf );
        return FALSE;
    }

    ULONG i,j;
    printf( "\n" );
    for( i = 0; i < DataSize/16; i++ ) {
        j = i * 16;
        printf( "%08x  %08x %08x %08x %08x   %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                  j + Address,
                  *(LPDWORD)&DataBuf[ j + 0 ],
                  *(LPDWORD)&DataBuf[ j + 4 ],
                  *(LPDWORD)&DataBuf[ j + 8 ],
                  *(LPDWORD)&DataBuf[ j + 12 ],
                  isprint( DataBuf[ j +  0 ]) ? DataBuf[ j +  0 ] : '.',
                  isprint( DataBuf[ j +  1 ]) ? DataBuf[ j +  1 ] : '.',
                  isprint( DataBuf[ j +  2 ]) ? DataBuf[ j +  2 ] : '.',
                  isprint( DataBuf[ j +  3 ]) ? DataBuf[ j +  3 ] : '.',
                  isprint( DataBuf[ j +  4 ]) ? DataBuf[ j +  4 ] : '.',
                  isprint( DataBuf[ j +  5 ]) ? DataBuf[ j +  5 ] : '.',
                  isprint( DataBuf[ j +  6 ]) ? DataBuf[ j +  6 ] : '.',
                  isprint( DataBuf[ j +  7 ]) ? DataBuf[ j +  7 ] : '.',
                  isprint( DataBuf[ j +  8 ]) ? DataBuf[ j +  8 ] : '.',
                  isprint( DataBuf[ j +  9 ]) ? DataBuf[ j +  9 ] : '.',
                  isprint( DataBuf[ j + 10 ]) ? DataBuf[ j + 10 ] : '.',
                  isprint( DataBuf[ j + 11 ]) ? DataBuf[ j + 11 ] : '.',
                  isprint( DataBuf[ j + 12 ]) ? DataBuf[ j + 12 ] : '.',
                  isprint( DataBuf[ j + 13 ]) ? DataBuf[ j + 13 ] : '.',
                  isprint( DataBuf[ j + 14 ]) ? DataBuf[ j + 14 ] : '.',
                  isprint( DataBuf[ j + 15 ]) ? DataBuf[ j + 15 ] : '.'
                );
    }
    printf( "\n" );

    Address += DataSize;
    MemFree( DataBuf );

    return TRUE;
}

size_t
DisAddrToSymbol(
    struct DIS *pdis,
    ULONG_PTR   addr,
    char       *buf,
    size_t      bufsize,
    DWORD_PTR  *displacement
    )
{
    if (SymGetSymFromAddr( CurrProcess, addr, displacement, sym )) {
        strncpy( buf, sym->Name, bufsize );
    } else {
        *displacement = 0;
        buf[0] = 0;
    }

    return strlen(buf);
}

size_t
DisFixupToSymbol(
    struct DIS  *pdis,
    ULONG_PTR   addr,
    size_t      fixup,
    char        *buf,
    size_t      bufsize,
    DWORD_PTR  *displacement
    )
{
    if (!ReadMemory( CurrProcess, (PVOID)addr, &addr, 4 )) {
        *displacement = 0;
        return 0;
    }

    if (SymGetSymFromAddr( CurrProcess, addr, displacement, sym )) {
        strncpy( buf, sym->Name, bufsize );
    } else {
        *displacement = 0;
        buf[0] = 0;
    }

    return strlen(buf);
}

BOOL
CmdDisplayCode(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    static ULONG_PTR Address = 0;
    ULONG_PTR ThisAddress;
    CHAR    DisBuf[512];
    ULONG   i;

    //
    // skip any command modifiers & white space that may follow
    //
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    GetAddress( CmdBuf, &ThisAddress );
    if (ThisAddress) {
        Address = ThisAddress;
    }

    printf( "\n" );

    for (i=0; i<20; i++) {
        if (!disasm( hProcess, &Address, DisBuf, TRUE )) {
            break;
        }
        printf( "%s\n", DisBuf );
    }

    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayRegisters(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PrintRegisters();
    return TRUE;
}

DWORD
UserBpStepHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    WriteMemory(
        ThisProcess->hProcess,
        (PVOID) BreakpointInfo->LastBp->Address,
        &BpInstr,
        BpSize
        );
    BreakpointInfo->LastBp = NULL;
    ResumeAllThreads( ThisProcess, ThisThread );
    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
UserBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    if (BreakpointInfo->Number) {
        printf( "Breakpoint #%d hit\n", BreakpointInfo->Number );
    } else {
        printf( "Hardcoded breakpoint hit\n" );
    }

    if (PrintRegistersFlag) PrintRegisters();
    PrintOneInstruction( ThisProcess->hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );

    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        BreakpointInfo->Command
        );

    if (BreakpointInfo->Address && (!Stepped)) {
        //
        // the bp is still present so we must step off it
        //
        SuspendAllThreads( ThisProcess, ThisThread );
        ULONG_PTR Address = GetNextOffset(
            ThisProcess->hProcess,
            (ULONG_PTR)ExceptionRecord->ExceptionAddress,
            TRUE
            );
        if (Address != (ULONG)-1) {
            PBREAKPOINT_INFO bp = SetBreakpoint(
                ThisProcess,
                Address,
                0,
                NULL,
                UserBpStepHandler
                );
            if (bp) {
                bp->LastBp = BreakpointInfo;
            } else {
                printf( "could not set off of the breakpoint\n" );
            }
        } else {
#ifdef _M_IX86
            CurrContext.EFlags |= 0x100;
            SetRegContext( ThisThread->hThread, &CurrContext );
            PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
            if (bp) {
                bp->Flags   |= BPF_TRACE;
                bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
                bp->Handler  = TraceBpHandler;
                bp->LastBp   = BreakpointInfo;
            } else {
                printf( "could not step off of the breakpoint\n" );
            }
#else
            printf( "could not step off of the breakpoint\n" );
#endif
        }
    }

    return ContinueStatus;
}

BOOL
PrintOneInstruction(
    HANDLE  hProcess,
    ULONG_PTR   Address
    )
{
    CHAR    DisBuf[512];

    if (disasm( hProcess, &Address, DisBuf, TRUE )) {
        printf( "%s\n", DisBuf );
    } else {
        printf( "*** error in disassembly\n" );
    }

    return TRUE;
}

DWORD
TraceBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
#ifdef _M_IX86
    if (BreakpointInfo->Flags & BPF_TRACE) {
        CurrContext.EFlags &= ~0x100;
        SetRegContext( ThisThread->hThread, &CurrContext );
    }
#endif

    if (BreakpointInfo->LastBp) {
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID) BreakpointInfo->LastBp->Address,
            &BpInstr,
            BpSize
            );
        BreakpointInfo->LastBp = NULL;
    }

    //
    // clear the trace breakpoint
    //
    ClearBreakpoint( ThisProcess, BreakpointInfo );

    //
    // print the registers
    //
    if (PrintRegistersFlag) {
        PrintRegisters();
    }

    //
    // print the code
    //
    PrintOneInstruction( ThisProcess->hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );

    //
    // enter the debugger
    //
    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        BreakpointInfo->Command
        );

    //
    // continue the debuggee
    //
    return ContinueStatus;
}

BOOL
CmdTrace(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SuspendAllThreads( ThisProcess, ThisThread );

#ifdef _M_IX86
    CurrContext.EFlags |= 0x100;
    SetRegContext( ThisThread->hThread, &CurrContext );
    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (bp) {
        bp->Flags   |= BPF_TRACE;
        bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
        bp->Handler  = TraceBpHandler;
    }
#else
    ULONG_PTR Address = GetNextOffset(
        ThisProcess->hProcess,
        (ULONG_PTR)ExceptionRecord->ExceptionAddress,
        FALSE
        );
    if (Address == (ULONG_PTR)ExceptionRecord->ExceptionAddress) {
        printf( "could not trace the instruction\n" );
        return FALSE;
    }
    PBREAKPOINT_INFO bp = SetBreakpoint(
        ThisProcess,
        Address,
        0,
        NULL,
        TraceBpHandler
        );
    if (!bp) {
        printf( "could not trace the instruction\n" );
        return FALSE;
    }
#endif

    return TRUE;
}

BOOL
CmdStep(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SuspendAllThreads( ThisProcess, ThisThread );

    ULONG_PTR Address = GetNextOffset(
        ThisProcess->hProcess,
        (ULONG_PTR)ExceptionRecord->ExceptionAddress,
        TRUE
        );

    if (Address == (ULONG_PTR)-1) {
#ifdef _M_IX86
        CurrContext.EFlags |= 0x100;
        SetRegContext( ThisThread->hThread, &CurrContext );
        PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
        if (bp) {
            bp->Flags   |= BPF_TRACE;
            bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
            bp->Handler  = TraceBpHandler;
        }
#else
        printf( "could not trace the instruction\n" );
#endif
    } else {
        PBREAKPOINT_INFO bp = SetBreakpoint(
            ThisProcess,
            Address,
            0,
            NULL,
            TraceBpHandler
            );
        if (!bp) {
            printf( "could not trace the instruction\n" );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CmdBreakPoint(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    CHAR BpCmd = (CHAR)tolower(CmdBuf[1]);
    ULONG_PTR Address = 0;
    PBREAKPOINT_INFO bp;
    PPROCESS_INFO ThisProcess;
    ULONG Flags;
    LPSTR p;
    LPSTR SymName;
    ULONG i;
    IMAGEHLP_MODULE mi;


    ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );
    p = CmdBuf;

    switch ( BpCmd ) {
        case 'p':
            Flags = 0;
            CmdBuf = GetAddress( CmdBuf, &Address );
            SymName = (LPSTR) MemAlloc( (ULONG)(CmdBuf - p + 16) );
            if (!SymName) {
                printf( "could not allocate memory for bp command\n" );
                break;
            }
            strncpy( SymName, p, (size_t)(CmdBuf - p) );
            if (!Address) {
                Flags = BPF_UNINSTANCIATED;
                printf( "breakpoint not instanciated\n" );
            }
            bp = SetBreakpoint(
                ThisProcess,
                Address,
                Flags,
                SymName,
                UserBpHandler
                );
            MemFree( SymName );
            if (!bp) {
                printf( "could not set breakpoint\n" );
            }
            ThisProcess->UserBpCount += 1;
            bp->Number = ThisProcess->UserBpCount;
            SKIP_WHITE( CmdBuf );
            if (CmdBuf[0]) {
                if (CmdBuf[0] == '/') {
                    switch (tolower(CmdBuf[1])) {
                        case 'c':
                            CmdBuf += 3;
                            if (CmdBuf[0] != '\"') {
                                printf( "invalid syntax\n" );
                                return FALSE;
                            }
                            CmdBuf += 1;
                            p = strchr( CmdBuf, '\"' );
                            if (!p) {
                                printf( "invalid syntax\n" );
                                return FALSE;
                            }
                            p[0] = 0;
                            bp->Command = _strdup( CmdBuf );
                            break;

                        default:
                            break;
                    }
                }
            }
            break;

        case 'l':
            for (i=0; i<MAX_BREAKPOINTS; i++) {
                if (ThisProcess->Breakpoints[i].Number) {
                    ULONG_PTR disp = 0;
                    if (ThisProcess->Breakpoints[i].Flags & BPF_WATCH) {
                        printf( "#%d %c%c\t          \tWatch\n",
                            ThisProcess->Breakpoints[i].Number,
                            ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                            ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E'
                            );
                    } else if ((ThisProcess->Breakpoints[i].Address != 0) &&
                        (ThisProcess->Breakpoints[i].Address != 0xffffffff)) {
                        SymGetModuleInfo(
                            ThisProcess->hProcess,
                            ThisProcess->Breakpoints[i].Address,
                            &mi
                            );
                        if (SymGetSymFromAddr(
                            ThisProcess->hProcess,
                            ThisProcess->Breakpoints[i].Address,
                            &disp,
                            sym
                            )) {
                                printf( "#%d %c%c\t0x%08x\t%s!%s\n",
                                    ThisProcess->Breakpoints[i].Number,
                                    ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                                    ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E',
                                    ThisProcess->Breakpoints[i].Address,
                                    mi.ModuleName,
                                    sym ? sym->Name : ""
                                    );
                        }
                    } else {
                        printf( "#%d %c%c\t          \t%s\n",
                            ThisProcess->Breakpoints[i].Number,
                            ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                            ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E',
                            ThisProcess->Breakpoints[i].SymName
                            );
                    }
                }
            }
            break;

        case 'c':
            if (!CmdBuf[0]) {
                printf( "missing breakpoint number\n" );
                return FALSE;
            }
            if (CmdBuf[0] == '*') {
                for (i=0; i<MAX_BREAKPOINTS; i++) {
                    if (ThisProcess->Breakpoints[i].Number) {
                        ClearBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
                    }
                }
                return TRUE;
            }
            if (isdigit(CmdBuf[0])) {
                ULONG BpNum = atoi( CmdBuf );
                for (i=0; i<MAX_BREAKPOINTS; i++) {
                    if (ThisProcess->Breakpoints[i].Number == BpNum) {
                        ClearBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
                        return TRUE;
                    }
                }
            }
            printf( "invalid breakpoint number\n" );
            return FALSE;

        case 'd':
            break;

        case 'e':
            break;

        case 'a':
#if defined(_M_IX86)
            CmdBuf = GetAddress( CmdBuf, &Address );

            bp = GetAvailBreakpoint( ThisProcess );
            if (!bp) {
                printf( "could not set breakpoint\n" );
                return FALSE;
            }

            bp->Address = Address;
            bp->Handler = UserBpHandler;
            bp->Flags   = BPF_WATCH;

            ThisProcess->UserBpCount += 1;
            bp->Number = ThisProcess->UserBpCount;

            CurrContext.Dr0 = Address;
            CurrContext.Dr6 = 0x000d0002;
            SetRegContext( ThisThread->hThread, &CurrContext );
#else
            printf( "only available on x86\n" );
#endif
            break;

        default:
            break;
    }

    return TRUE;
}

BOOL
CmdListNear(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    ULONG_PTR Address;
    GetAddress( CmdBuf, &Address );
    if (Address) {
        ULONG_PTR Displacement;
        if (SymGetSymFromAddr( hProcess, Address, &Displacement, sym )) {
            printf( "0x%p %s\n", sym->Address, sym->Name );
        }
    }
    return TRUE;
}

BOOL
CmdDisplayModules(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    IMAGEHLP_MODULE ModuleInfo;


    printf( "\n" );
    printf( "Address    Size                   Name  Symbol Status\n" );
    printf( "------------------------------------------------------------------\n" );
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress && !DllList[i].Unloaded) {
            printf( "0x%08x 0x%08x %16s\t",
                DllList[i].BaseAddress,
                DllList[i].Size,
                DllList[i].Name
                );
            if (SymGetModuleInfo( hProcess, DllList[i].BaseAddress, &ModuleInfo )) {
                if (ModuleInfo.SymType != SymNone) {
                    printf( "(symbols loaded)\t" );
                } else {
                    printf( "(symbols *NOT* loaded)\t" );
                }
                printf( "%s\t", ModuleInfo.LoadedImageName );
            } else {
                printf( "(symbols *NOT* loaded)\t" );
            }
            printf( "\n" );
        }
    }
    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayHelp(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    printf( "\n" );
    printf( "  ?            - display this screen\n" );
    printf( "  g            - continue the process\n" );
    printf( "  q            - quit the debugger\n" );
    printf( "  bp <address> - set a new breakpoint\n" );
    printf( "  r            - display registers\n" );
    printf( "  k            - stack trace\n" );
    printf( "  d <address>  - display memory\n" );
    printf( "  u <address>  - display disassembled code\n" );
    printf( "\n" );
    printf( "  all addresses are represented in hexadecimal\n" );
    printf( "  and all addressed input to the debugger must\n" );
    printf( "  be in hexadecimal radix\n" );
    printf( "\n" );

    return TRUE;
}

CLINKAGE DWORD
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    ULONG cbRead,cb;
    BOOL rVal = ReadProcessMemory(
        hProcess,
        Address,
        Buffer,
        Length,
        &cbRead
        );
    if (!rVal) {
        return 0;
    }

    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        return 0;
    }

    //
    // make sure that the view of the va is correct
    // and does NOT show bp instructions where
    // breakpoints have been set
    //
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (((ULONG_PTR)Address >= ThisProcess->Breakpoints[i].Address &&
            (ULONG_PTR)Address <  ThisProcess->Breakpoints[i].Address+BpSize) && (!ThisProcess->Breakpoints[i].Text)) {

                SIZE_T cb = ThisProcess->Breakpoints[i].Address - (ULONG_PTR)Address;
                CopyMemory(
                    (LPSTR)Buffer + cb,
                    &ThisProcess->Breakpoints[i].OriginalInstr,
                    BpSize
                    );
                break;

        }
    }

    return cbRead;
}

CLINKAGE BOOL
WriteMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    ULONG cb;
    BOOL rVal = WriteProcessMemory(
        hProcess,
        Address,
        Buffer,
        Length,
        &cb
        );
    if (!rVal || cb != Length) {
        return FALSE;
    }
    return TRUE;
}

BOOL
ConsoleHandler(
    DWORD   CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT) {
        printf( "^C pressed\n" );
        SetEvent( BreakinEvent );
        return TRUE;
    }
    return FALSE;
}

BOOL
CreateDebuggerConsole(
    VOID
    )
{
    if (!AllocConsole()) {
        return FALSE;
    }

    SetConsoleCtrlHandler( ConsoleHandler, TRUE );

    int hCrt;
    FILE *hf;
    hCrt = _open_osfhandle( (LONG_PTR) GetStdHandle(STD_OUTPUT_HANDLE), _O_TEXT );
    hf = _fdopen( hCrt, "w" );
    if (hf)
        *stdout = *hf;
    setvbuf( stdout, NULL, _IONBF, 0 );

    hCrt = _open_osfhandle( (LONG_PTR) GetStdHandle(STD_INPUT_HANDLE), _O_TEXT );
    hf = _fdopen( hCrt, "r" );
    if (hf)
        *stdin = *hf;
    setvbuf( stdin, NULL, _IONBF, 0 );
    ConsoleCreated = TRUE;
    puts( "*----------------------------------------------------------\n"
          "Microsoft(R) Windows NT APIMON Version 4.0\n"
          "(C) 1989-2000 Microsoft Corp. All rights reserved\n"
          "\n"
          "APIMON Console Debugger Interface\n"
          "\n"
          "Use the ? command for help\n"
          "*----------------------------------------------------------\n"
          "\n" );

    return TRUE;
}

DWORD
ConsoleDebugger(
    HANDLE              hProcess,
    HANDLE              hThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    BOOL                FirstChance,
    BOOL                UnexpectedException,
    LPSTR               InitialCommand
    )
{
    PPROCESS_INFO ThisProcess;
    DWORD ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
    static CHAR CmdBuf[512];

    Stepped = FALSE;

    if (!ConsoleCreated) {
        CmdBuf[0] = 0;
        if (!CreateDebuggerConsole()) {
            return ContinueStatus;
        }
    }

    ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
    }

    if (UnexpectedException) {
        printf( "\n" );
        printf( "*---------------------------------------\n" );
        printf( "An unexpected error has occurred\n" );
        printf( "Address:     0x%p\n", ExceptionRecord->ExceptionAddress );
        printf( "Error code:  0x%08x\n", ExceptionRecord->ExceptionCode );
        if (!FirstChance) {
            printf( "Second chance!\n");
        }
        printf( "*---------------------------------------\n" );
        PrintRegisters();
        PrintOneInstruction( hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );
    }

    if (BreakInNow) {
        BreakInNow = FALSE;
        printf( "*** Initial breakpoint\n\n" );
    }

    //
    // check to see if any modules need symbols loading
    //
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress && !DllList[i].Unloaded) {
            IMAGEHLP_MODULE ModuleInfo;
            if (!SymGetModuleInfo( hProcess, DllList[i].BaseAddress, &ModuleInfo )) {
                if (ThisProcess) {
                    printf( "loading 0x%08x %s\n",
                        DllList[i].BaseAddress,
                        DllList[i].Name
                        );
                    LoadSymbols(
                        ThisProcess,
                        &DllList[i],
                        NULL
                        );
                }
            }
        }
    }

    CurrProcess = hProcess;
    if (InitialCommand) {
        strcpy( CmdBuf, InitialCommand );
    }
    while( TRUE ) {
retry:
        if (!InitialCommand) {
            printf( "ApiMon> " );
            if (scanf( "%[^\n]", CmdBuf ) != 1) {
                printf( "****>>> invalid command\n" );
                goto retry;
            }
            getchar();
        }

        LPSTR p = CmdBuf;

        while (p[0]) {
            LPSTR s = p;
            while (*s) {
                if (*s == '\"') {
                    s += 1;
                    while (*s && *s != '\"') {
                        s += 1;
                    }
                    if (*s == '\"') {
                        s += 1;
                    }
                }
                if (*s == ';') {
                    break;
                }
                s += 1;
            }
            if (*s == ';') {
                s[0] = 0;
            } else {
                s = NULL;
            }

            switch( tolower(p[0]) ) {
                case 'q':
                    ExitProcess( 0 );
                    break;

                case 'g':
                    ContinueStatus = DBG_CONTINUE;
                    goto exit;

                case 'k':
                    CmdStackTrace( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'd':
                    CmdDisplayMemory( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'r':
                    if (p[1] == 't') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    CmdDisplayRegisters( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'u':
                    CmdDisplayCode( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'b':
                    CmdBreakPoint( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'l':
                    if (tolower(p[1]) == 'm') {
                        CmdDisplayModules( p, hProcess, hThread, ExceptionRecord );
                    } else if (tolower(p[1]) == 'n') {
                        CmdListNear( p, hProcess, hThread, ExceptionRecord );
                    } else {
                        goto invalid_command;
                    }
                    break;

                case 't':
                    if (p[1] == 'r') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    if (CmdTrace( p, hProcess, hThread, ExceptionRecord )) {
                        ContinueStatus = DBG_CONTINUE;
                        Stepped = TRUE;
                        goto exit;
                    }
                    break;

                case 'p':
                    if (p[1] == 'r') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    if (CmdStep( p, hProcess, hThread, ExceptionRecord )) {
                        ContinueStatus = DBG_CONTINUE;
                        Stepped = TRUE;
                        goto exit;
                    }
                    break;

                case 'h':
                    if (tolower(p[1]) == 'e' && tolower(p[2]) == 'l' && tolower(p[3]) == 'p') {
                        CmdDisplayHelp( p, hProcess, hThread, ExceptionRecord );
                    }
                    break;

                case '?':
                    {
                        ULONG_PTR val = GetExpression( p+1 );
                        if (!ExprError) {
                            printf( "Evaluate expression: %d = %p\n", val, val );
                        }
                    }
                    break;

                default:
invalid_command:
                    printf( "****>>> invalid command\n" );
                    break;
            }
            if (s) {
                p = s + 1;
            } else {
                p += strlen(p);
            }
        }
    }

exit:

    return ContinueStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\debug.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    This module contains all debug interfaces.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


extern HANDLE       ReleaseDebugeeEvent;
extern PDLL_INFO    DllList;
extern PVOID        MemPtr;
extern HANDLE       BreakinEvent;
extern HWND         hwndFrame;
extern BOOL         BreakInNow;
extern BOOL         StopOnFirstChance;
extern CONTEXT      CurrContext;

extern "C" {
    extern LPDWORD  ApiOffset;
    extern LPDWORD  ApiStrings;
    extern LPDWORD  ApiCount;
    extern BOOL     RunningOnNT;
}


PROCESS_INFO        ProcessHead;
ULONG               BpSize = BP_SIZE;
ULONG               BpInstr = BP_INSTR;
HANDLE              CurrProcess;
HANDLE              CurrThread;
BOOL                DebugeeActive;
ULONG_PTR           CreateHeapAddr;
ULONG               ReDirectIat;
HANDLE              hProcessWs;



HANDLE
StartDebuggee(
    LPSTR ProgName
    );

ULONG_PTR
CreateTrojanHorse(
    PUCHAR  Text,
    ULONG_PTR   ExceptionAddress
    );

DWORD
HandleBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    );

DWORD
HandleSingleStep(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    );

DWORD
BreakinBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

DWORD
CreateHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

DWORD
UserBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

BOOL
GetImageName(
    PPROCESS_INFO   ThisProcess,
    ULONG_PTR       ImageBase,
    PVOID           ImageNamePtr,
    LPSTR           ImageName,
    DWORD           ImageNameLength
    );

BOOL
SymEnumFunction(
    LPSTR               SymName,
    DWORD_PTR           Address,
    DWORD               Size,
    PSYMBOL_ENUM_CXT    Cxt
    );

ULONG
AddApisForDll(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo
    );

BOOL
InstanciateAllBreakpoints(
    PPROCESS_INFO   ThisProcess
    );


BOOL __inline
IsKnownApi(
    LPSTR ApiName
    )
{
    // If none are known then all are traced
    if (KnownApis[0] == 0)
        return TRUE;

    LPSTR p = KnownApis;
    while( *p ) {
        if (_stricmp( ApiName, p ) == 0) {
            return TRUE;
        }
        p += (strlen(p) + 1);
    }

    return FALSE;
}


BOOL __inline
IsKnownDll(
    LPSTR DllName
    )
{
    LPSTR p = ApiMonOptions.KnownDlls;
    while( *p ) {
        if (_stricmp( DllName, p ) == 0) {
            return TRUE;
        }
        p += (strlen(p) + 1);
    }
    return FALSE;
}

int __cdecl
ApiInfoSortRoutine(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1 = (PAPI_INFO) e1;
    PAPI_INFO p2 = (PAPI_INFO) e2;

    if ( p1 && p2 ) {
        if (p1->Address < p2->Address) {
            return -1;
        } else if (p1->Address == p2->Address) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}


DWORD
DebuggerThread(
    LPSTR  CmdLine
    )
{
    DEBUG_EVENT         de;
    ULONG               ContinueStatus;
    ULONG               i;
    BOOL                FirstProcess = TRUE;
    PPROCESS_INFO       ThisProcess;
    PTHREAD_INFO        ThisThread;
    WCHAR               UnicodeBuf[256];
    CHAR                AsciiBuf[256];
    CHAR                DllName[32];
    CHAR                Ext[_MAX_EXT];
    ULONG               cb;
    PDLL_INFO           DllInfo;
    IMAGE_DOS_HEADER    dh;
    IMAGE_NT_HEADERS    nh;
    DWORD               DllSize;
    HANDLE              hProcess;
    ULONG_PTR           ImageBase;
    BOOL                SymsLoaded;
    PAPI_INFO           ApiInfo;

    hProcess = StartDebuggee( CmdLine );
    if (!hProcess) {
        goto exit;
    }
    hProcessWs = hProcess;

    DebugeeActive = TRUE;

    CreateHeapAddr = (ULONG_PTR)GetProcAddress( GetModuleHandle( NTDLL ), CREATEHEAP );

    if (BreakInNow) {
        CreateDebuggerConsole();
    }

    while (TRUE) {
        if (!WaitForDebugEvent( &de, 100 )) {
            if (WaitForSingleObject( BreakinEvent, 0 ) == WAIT_OBJECT_0) {
                ResetEvent( BreakinEvent );
                SuspendAllThreads( ThisProcess, NULL );
                CONTEXT Context;
                GetRegContext( ThisThread->hThread, &Context );
                PBREAKPOINT_INFO bp = SetBreakpoint(
                    ThisProcess,
                    (DWORD_PTR)Context.PC_REG,
                    0,
                    NULL,
                    BreakinBpHandler
                    );
                if (!bp) {
                    PopUpMsg( "could not break into process" );
                }
                ResumeAllThreads( ThisProcess, NULL );
            }
            continue;
        }

        ThisProcess = &ProcessHead;
        while (ThisProcess->Next) {
            if (ThisProcess->ProcessId == de.dwProcessId) {
                break;
            }
            ThisProcess = ThisProcess->Next;
        }
        if (ThisProcess->ProcessId != de.dwProcessId) {
            ThisProcess->Next = (PPROCESS_INFO) MemAlloc( sizeof(PROCESS_INFO) );
            ThisProcess = ThisProcess->Next;
            ThisProcess->ProcessId = de.dwProcessId;
        }
        ThisThread = &ThisProcess->ThreadInfo;
        while( ThisThread->Next ) {
            if (ThisThread->ThreadId == de.dwThreadId) {
                break;
            }
            ThisThread = ThisThread->Next;
        }
        if (ThisThread->ThreadId != de.dwThreadId) {
            ThisThread->Next = (PTHREAD_INFO) MemAlloc( sizeof(THREAD_INFO) );
            ThisThread = ThisThread->Next;
            ThisThread->ThreadId = de.dwThreadId;
        }

        CurrProcess = ThisProcess->hProcess;
        CurrThread  = ThisThread->hThread;

        GetRegContext( ThisThread->hThread, &CurrContext );

        ContinueStatus = DBG_CONTINUE;
        switch (de.dwDebugEventCode) {
            case EXCEPTION_DEBUG_EVENT:
                if ((!ThisProcess->SeenLdrBp) && (BreakInNow)) {
                    ContinueStatus = ConsoleDebugger(
                        ThisThread->hProcess,
                        ThisThread->hThread,
                        &de.u.Exception.ExceptionRecord,
                        de.u.Exception.dwFirstChance,
                        FALSE,
                        NULL
                        );
                }
                if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT) {
                    ContinueStatus = HandleBreakpoint(
                        ThisProcess,
                        ThisThread,
                        &de.u.Exception.ExceptionRecord
                        );
                    if (!ContinueStatus) {
                        ContinueStatus = ConsoleDebugger(
                            ThisThread->hProcess,
                            ThisThread->hThread,
                            &de.u.Exception.ExceptionRecord,
                            de.u.Exception.dwFirstChance,
                            TRUE,
                            NULL
                            );
                    }
                } else if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_SINGLE_STEP) {
                    ContinueStatus = HandleSingleStep(
                        ThisProcess,
                        ThisThread,
                        &de.u.Exception.ExceptionRecord
                        );
                } else {
                    if (de.u.Exception.dwFirstChance && (!StopOnFirstChance)) {
                        ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                        break;
                    }
                    ContinueStatus = ConsoleDebugger(
                        ThisThread->hProcess,
                        ThisThread->hThread,
                        &de.u.Exception.ExceptionRecord,
                        de.u.Exception.dwFirstChance,
                        TRUE,
                        NULL
                        );
                }
                if (!ThisProcess->SeenLdrBp) {
                    ThisProcess->SeenLdrBp = TRUE;
                    SetEvent( ReleaseDebugeeEvent );
                }
                break;

            case CREATE_THREAD_DEBUG_EVENT:
                ThisThread->hProcess    = ThisProcess->hProcess;
                ThisThread->hThread     = de.u.CreateThread.hThread;
                ThisThread->ThreadId    = de.dwThreadId;
                printf( "thread create %x\n", de.dwThreadId );
                break;

            case CREATE_PROCESS_DEBUG_EVENT:
                //
                // setup the process structure
                //
                ThisProcess->hProcess     = de.u.CreateProcessInfo.hProcess;
                ThisProcess->SeenLdrBp    = FALSE;
                ThisProcess->FirstProcess = FirstProcess;
                ThisProcess->LoadAddress  = (DWORD_PTR)de.u.CreateProcessInfo.lpBaseOfImage;
                ThisThread->hProcess      = ThisProcess->hProcess;
                ThisThread->hThread       = de.u.CreateProcessInfo.hThread;
                ThisThread->ThreadId      = de.dwThreadId;
                FirstProcess = FALSE;

                //
                // initialize the symbol handler
                //
                SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE );
                SymInitialize( ThisProcess->hProcess, ApiMonOptions.SymbolPath, FALSE );
                if (ApiMonOptions.MonitorPageFaults) {
                    //
                    // for WIN95 only, we need to call the hack-o-ramma
                    // api in psapi.dll so the the working set apis function properly
                    //
                    if (!RunningOnNT) {
                        if (pRecordProcessInfo) {
                            pRecordProcessInfo( hProcessWs, ThisProcess->ProcessId );
                        }
                    }
                    if (pInitializeProcessForWsWatch) {
                        pInitializeProcessForWsWatch( hProcessWs );
                    }
                }

                CurrProcess = ThisProcess->hProcess;
                //
                // load the image
                //
                ImageBase = ThisProcess->LoadAddress;
                strcpy( DllName, ApiMonOptions.ProgName );
                printf( "process create %x\n", de.dwProcessId );
                printf( "thread create %x\n", de.dwThreadId );
                goto LoadImage;

            case EXIT_THREAD_DEBUG_EVENT:
                break;

            case EXIT_PROCESS_DEBUG_EVENT:
                PopUpMsg(
                    "The monitored process has exited\nExit code = %d",
                    de.u.ExitProcess.dwExitCode
                    );
                if (!ThisProcess->FirstProcess) {
                    ZeroMemory( ThisProcess, sizeof(PROCESS_INFO) );
                    break;
                }
                ZeroMemory( ThisProcess, sizeof(PROCESS_INFO) );
                goto exit;

            case LOAD_DLL_DEBUG_EVENT:
                ImageBase = (ULONG_PTR)de.u.LoadDll.lpBaseOfDll;

                GetImageName(
                    ThisProcess,
                    ImageBase,
                    de.u.LoadDll.lpImageName,
                    AsciiBuf,
                    sizeof(AsciiBuf)
                    );

                _splitpath( AsciiBuf, NULL, NULL, DllName, Ext );
                strcat( DllName, Ext );

LoadImage:
                DllInfo = AddDllToList( ThisThread, ImageBase, DllName, 0 );
                if (DllInfo) {
                    if (_stricmp(DllName,TROJANDLL)==0) {
                        DllInfo->Snapped = TRUE;
                        if (!ThisProcess->SeenLdrBp) {
                            //
                            // the debuggee is compiled with -Gh
                            // and has linked APIDLL statically
                            //
                            HMODULE hMod = LoadLibraryEx(
                                TROJANDLL,
                                NULL,
                                DONT_RESOLVE_DLL_REFERENCES
                                );
                            LPVOID StaticLink = (LPVOID) GetProcAddress(
                                hMod,
                                "StaticLink"
                                );
                            FreeLibrary( hMod );
                            if (StaticLink) {
                                ThisProcess->StaticLink = TRUE;
                                WriteMemory(
                                    ThisProcess->hProcess,
                                    StaticLink,
                                    &ThisProcess->StaticLink,
                                    sizeof(ThisProcess->StaticLink)
                                    );
                            }
                        }
                    } else if (DllInfo->Enabled) {
                        AddApisForDll( ThisProcess, DllInfo );
                    }
                }

                if (DllInfo && ApiMonOptions.PreLoadSymbols) {
                    SymsLoaded = LoadSymbols( ThisProcess, DllInfo, de.u.LoadDll.hFile );
                } else {
                    SymsLoaded = FALSE;
                }

                //
                // now sort the api table by address
                //
                ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
                qsort( ApiInfo, DllInfo->ApiCount, sizeof(API_INFO), ApiInfoSortRoutine );

                //
                // print a notification to the console debugger
                //
                printf( "Module load: 0x%08x %s\t%s\n",
                    DllInfo->BaseAddress,
                    DllInfo->Name,
                    SymsLoaded ? "(Symbols Loaded)" : "(Symbols NOT Loaded)"
                    );

                InstanciateAllBreakpoints( ThisProcess );

                break;

            case UNLOAD_DLL_DEBUG_EVENT:
                for (i=0; i<MAX_DLLS; i++) {
                    if (DllList[i].BaseAddress == (ULONG_PTR)de.u.UnloadDll.lpBaseOfDll) {
                        DllList[i].Unloaded = TRUE;
                        DllList[i].Enabled  = FALSE;
                        DllList[i].Snapped  = FALSE;
                        break;
                    }
                }
                break;

            case OUTPUT_DEBUG_STRING_EVENT:
                {
                LPSTR String = (LPSTR) MemAlloc( de.u.DebugString.nDebugStringLength+32 );
                ReadMemory(
                    ThisThread->hProcess,
                    de.u.DebugString.lpDebugStringData,
                    String,
                    de.u.DebugString.nDebugStringLength
                    );
                OutputDebugString( String );
                printf( "%s", String );
                MemFree( String );
                }
                break;

            case RIP_EVENT:
                break;

            default:
                PopUpMsg( "invalid debug event" );
                break;
        }
        ContinueDebugEvent( de.dwProcessId, de.dwThreadId, ContinueStatus );
    }

exit:
    DebugeeActive = FALSE;
    return 0;
}


PDLL_INFO
FindDllByAddress(
    ULONG_PTR DllAddr
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindDllByName(
    LPSTR DllName
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Name[0] &&
            _stricmp( DllList[i].Name, DllName ) == 0) {
                return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindAvailDll(
    VOID
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (!DllList[i].BaseAddress) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
AddDllToList(
    PTHREAD_INFO        ThisThread,
    ULONG_PTR           DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   i;
    PDLL_INFO               DllInfo;


    //
    // first look to see if the dll is already in the list
    //
    DllInfo = FindDllByAddress( DllAddr );
    if (DllInfo) {
        return DllInfo;
    }

    if (!DllSize) {
        //
        // read the pe image headers to get the image size
        //
        if (!ReadMemory(
            ThisThread->hProcess,
            (PVOID) DllAddr,
            &dh,
            sizeof(dh)
            )) {
                return NULL;
        }

        if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
            if (!ReadMemory(
                ThisThread->hProcess,
                (PVOID)(DllAddr + dh.e_lfanew),
                &nh,
                sizeof(nh)
                )) {
                    return NULL;
            }
            DllSize = nh.OptionalHeader.SizeOfImage;
        } else {
            DllSize = 0;
        }
    }

    DllInfo = FindAvailDll();
    if (!DllInfo) {
        return NULL;
    }

    DllInfo->Size = DllSize;
    strncat( DllInfo->Name, DllName, MAX_NAME_SZ-1 );
    DllInfo->BaseAddress = DllAddr;
    DllInfo->InList = FALSE;
    BOOL KnownDll = IsKnownDll( DllName );
    if (ApiMonOptions.UseKnownDlls) {
        DllInfo->Enabled = KnownDll;
    } else if (ApiMonOptions.ExcludeKnownDlls) {
        if (KnownDll) {
            DllInfo->Enabled = FALSE;
        } else {
            DllInfo->Enabled = TRUE;
        }
    } else {
        DllInfo->Enabled = TRUE;
    }

    return DllInfo;
}

BOOL
LoadSymbols(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    HANDLE              hFile
    )
{
    if (!DllInfo) {
        return FALSE;
    }

    //
    // load the symbols
    //
    DWORD_PTR SymAddr = SymLoadModule(
        ThisProcess->hProcess,
        hFile,
        DllInfo->Name,
        NULL,
        DllInfo->BaseAddress,
        DllInfo->Size
        );

    if (!SymAddr) {
        //
        // imagehlp does not look along the exe path
        // for the symbols.  we really need to do this
        // because the symbola may still be in the exe
        // and the dir may not be on the symbol search
        // path.  so lets try.
        //
        ULONG cb;
        CHAR buf[MAX_PATH*2];
        if (ApiMonOptions.ProgDir[0]) {
            cb = SearchPath(
                ApiMonOptions.ProgDir,
                DllInfo->Name,
                NULL,
                sizeof(buf),
                buf,
                (LPSTR*)&cb
                );
        } else {
            cb = 0;
        }
        if (!cb) {
            cb = SearchPath(
                NULL,
                DllInfo->Name,
                NULL,
                sizeof(buf),
                buf,
                (LPSTR*)&cb
                );
        }
        if (cb) {
            SymAddr = SymLoadModule(
                ThisProcess->hProcess,
                NULL,
                buf,
                NULL,
                DllInfo->BaseAddress,
                DllInfo->Size
                );
        }
    }

    if (!SymAddr) {
        return FALSE;
    }

    if (ApiMonOptions.MonitorPageFaults || DllInfo->StaticProfile) {
        //
        // add the symbols to the apiinfo table
        //
        DllInfo->ApiCount = 0;
        DllInfo->ApiOffset = *ApiOffset;
        PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
        SYMBOL_ENUM_CXT Cxt;
        Cxt.ApiInfo = ApiInfo;
        Cxt.DllInfo = DllInfo;
        Cxt.Cnt = 0;

        SymEnumerateSymbols(
            ThisProcess->hProcess,
            DllInfo->BaseAddress,
            (PSYM_ENUMSYMBOLS_CALLBACK)SymEnumFunction,
            &Cxt
            );

        DllInfo->ApiCount = Cxt.Cnt;
        *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    }

    return TRUE;
}

DWORD
GetApisFromExportsDir(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    PIMAGE_DOS_HEADER   dh,
    PIMAGE_NT_HEADERS   nh
    )
{
    PIMAGE_SECTION_HEADER   sh       = NULL;
    PULONG                  names    = NULL;
    PULONG                  addrs    = NULL;
    PUSHORT                 ordinals = NULL;
    PUSHORT                 ordidx   = NULL;
    PAPI_INFO               ApiInfo  = NULL;
    LPSTR                   Strings  = NULL;
    ULONG                   cnt      = 0;
    ULONG                   idx      = 0;
    ULONG_PTR               DllOffset;
    IMAGE_EXPORT_DIRECTORY  expdir;
    ULONG                   i;
    ULONG                   j;
    ULONG                   k;
    LPSTR                   p;


    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress +
            nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(expdir)
        )) {
            goto exit;
    }

    names = (PULONG) MemAlloc( expdir.NumberOfNames * sizeof(ULONG) );
    addrs = (PULONG) MemAlloc( expdir.NumberOfFunctions * sizeof(ULONG) );
    ordinals = (PUSHORT) MemAlloc( expdir.NumberOfNames * sizeof(USHORT) );
    ordidx = (PUSHORT) MemAlloc( expdir.NumberOfFunctions * sizeof(USHORT) );

    if ((!names) || (!addrs) || (!ordinals) || (!ordidx)) {
        goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNames),
        names,
        expdir.NumberOfNames * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfFunctions),
        addrs,
        expdir.NumberOfFunctions * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNameOrdinals),
        ordinals,
        expdir.NumberOfNames * sizeof(USHORT)
        )) {
            goto exit;
    }

    //
    // read in the section headers
    //
    sh = (PIMAGE_SECTION_HEADER) MemAlloc(
        nh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER
        );
    if (!sh) {
        goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID) (DllInfo->BaseAddress +
            dh->e_lfanew +
            FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +
            nh->FileHeader.SizeOfOptionalHeader),
        sh,
        nh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER
        )) {
            goto exit;
    }

    //
    // look for the section that the export name strings are in
    //
    for (i=0,k=(DWORD)-1; i<nh->FileHeader.NumberOfSections; i++) {
        if (names[0] >= sh[i].VirtualAddress &&
            names[0] < sh[i].VirtualAddress + sh[i].SizeOfRawData) {
                //
                // found it
                //
                k = i;
                break;
        }
    }
    if (k == (DWORD)-1) {
        //
        // count not find the section
        //
        goto exit;
    }

    Strings = (LPSTR) MemAlloc( sh[k].SizeOfRawData );
    if (!Strings) {
        goto exit;
    }

    //
    // read in the strings
    //
    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + sh[k].VirtualAddress),
        Strings,
        sh[k].SizeOfRawData
        )) {
            goto exit;
    }

    DllOffset = (PCHAR)DllInfo - (PCHAR)DllList;

    DllInfo->ApiCount = expdir.NumberOfFunctions;
    DllInfo->ApiOffset = *ApiOffset;
    *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);

    if (*ApiCount < MAX_APIS) {
        for (i=0; i<expdir.NumberOfNames; i++) {
            idx = ordinals[i];
            ordidx[idx] = TRUE;
            ApiInfo[i].Count = 0;
            ApiInfo[i].ThunkAddress = 0;
            ApiInfo[i].Address = addrs[idx] + DllInfo->BaseAddress;
            strcpy(
                (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                Strings + names[i] - sh[k].VirtualAddress
                );
            ApiInfo[i].Name = *ApiStrings;
            ApiInfo[i].DllOffset = DllOffset;
            ApiInfo[i].TraceEnabled = IsKnownApi((LPSTR)MemPtr+*ApiStrings);

            *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
            *ApiCount += 1;
            if (*ApiCount == MAX_APIS) {
                break;
            }
        }
    }
    if (*ApiCount < MAX_APIS) {
        for (ULONG i=0,idx=expdir.NumberOfNames; i<expdir.NumberOfFunctions; i++) {
            if (!ordidx[i]) {
                ApiInfo[idx].Count = 0;
                ApiInfo[idx].ThunkAddress = 0;
                ApiInfo[idx].Address = addrs[i] + DllInfo->BaseAddress;
                sprintf(
                    (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                    "Ordinal%d",
                    i
                    );
                ApiInfo[idx].Name = *ApiStrings;
                ApiInfo[idx].DllOffset = DllOffset;
                ApiInfo[idx].TraceEnabled = IsKnownApi((LPSTR)MemPtr+*ApiStrings);

                *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
                *ApiCount += 1;
                if (*ApiCount == MAX_APIS) {
                    break;
                }
                idx += 1;
            }
        }
    }
    cnt = DllInfo->ApiCount;

exit:
    MemFree( sh );
    MemFree( Strings );
    MemFree( names );
    MemFree( addrs );
    MemFree( ordinals );
    MemFree( ordidx );

    return cnt;
}

DWORD
GetApisFromImportsDir(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    PIMAGE_DOS_HEADER   dh,
    PIMAGE_NT_HEADERS   nh
    )
{
    ULONG_PTR               SeekPos;
    IMAGE_IMPORT_DESCRIPTOR desc;
    CHAR                    DllName[MAX_PATH];

    //
    // check to see if this dll imports from apidll.dll
    // if it does then we know that this dll was compiled
    // with the -Gh switch turned on.  if this is the case
    // then we must enumerate the symbols from the public
    // symbol table instead of the exports directory.
    //

    if (!nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
        return 0;

    SeekPos = DllInfo->BaseAddress +
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    while( TRUE ) {
        if (!ReadMemory(
            ThisProcess->hProcess,
            (PVOID)(SeekPos),
            &desc,
            sizeof(desc)
            )) {
                return 0;
        }

        SeekPos += sizeof(IMAGE_IMPORT_DESCRIPTOR);

        if ((desc.Characteristics == 0) && (desc.Name == 0) && (desc.FirstThunk == 0)) {
            break;
        }

        if (!ReadMemory(
            ThisProcess->hProcess,
            (PVOID)(DllInfo->BaseAddress + desc.Name),
            DllName,
            sizeof(DllName)
            )) {
                return 0;
        }

        if (_stricmp( DllName, TROJANDLL ) == 0) {
            DllInfo->StaticProfile = TRUE;
            return 0;
        }
    }

    return 0;
}

ULONG
AddApisForDll(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   cnt = 0;


    if (*ApiCount == MAX_APIS) {
        return 0;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)DllInfo->BaseAddress,
        &dh,
        sizeof(dh)
        )) {
            return 0;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        return 0;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + dh.e_lfanew),
        &nh,
        sizeof(nh)
        )) {
            return 0;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        cnt = GetApisFromImportsDir(
            ThisProcess,
            DllInfo,
            &dh,
            &nh
            );
        return cnt;
    }

    cnt = GetApisFromImportsDir(
        ThisProcess,
        DllInfo,
        &dh,
        &nh
        );
    if (cnt) {
        return cnt;
    }

    cnt = GetApisFromExportsDir(
        ThisProcess,
        DllInfo,
        &dh,
        &nh
        );
    return cnt;
}

BOOL
SymEnumFunction(
    LPSTR               SymName,
    DWORD_PTR           Address,
    DWORD               Size,
    PSYMBOL_ENUM_CXT    Cxt
    )
{
    if (*ApiCount == MAX_APIS) {
        return FALSE;
    }

    PAPI_INFO ApiInfo = &Cxt->ApiInfo[Cxt->Cnt];

    ApiInfo->Count = 0;
    ApiInfo->ThunkAddress = 0;
    ApiInfo->Address = Address;
    ApiInfo->Size = Size;
    strcpy( (LPSTR)((LPSTR)MemPtr+*ApiStrings), SymName );
    ApiInfo->Name = *ApiStrings;
    *ApiStrings += (strlen(SymName) + 1);
    Cxt->Cnt += 1;
    *ApiCount += 1;

    return TRUE;
}

BOOL
GetImageName(
    PPROCESS_INFO   ThisProcess,
    ULONG_PTR       ImageBase,
    PVOID           ImageNamePtr,
    LPSTR           ImageName,
    DWORD           ImageNameLength
    )
{
    DWORD_PTR           i;
    WCHAR               UnicodeBuf[256];
    CHAR                DllName[32];
    CHAR                Ext[_MAX_EXT];
    ULONG               cb;

    if (!ReadMemory(
        ThisProcess->hProcess,
        ImageNamePtr,
        &i,
        sizeof(i)
        )) {
            goto GetFromExports;
    }
    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)i,
        UnicodeBuf,
        sizeof(UnicodeBuf)
        )) {
            goto GetFromExports;
    }
    ZeroMemory( ImageName, ImageNameLength );
    if (RunningOnNT) {
        WideCharToMultiByte(
            CP_ACP,
            0,
            UnicodeBuf,
            wcslen(UnicodeBuf),
            ImageName,
            ImageNameLength,
            NULL,
            NULL
            );
        if (!strlen(ImageName)) {
            goto GetFromExports;
        }
    } else {
        strcpy( ImageName, (LPSTR)UnicodeBuf );
    }

    return TRUE;

GetFromExports:

    IMAGE_DOS_HEADER dh;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)ImageBase,
        &dh,
        sizeof(IMAGE_DOS_HEADER)
        )) {
            return FALSE;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    IMAGE_NT_HEADERS nh;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase + dh.e_lfanew),
        &nh,
        sizeof(IMAGE_NT_HEADERS)
        )) {
            return FALSE;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        return FALSE;
    }

    IMAGE_EXPORT_DIRECTORY expdir;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase +
                 nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(IMAGE_EXPORT_DIRECTORY)
        )) {
            return FALSE;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase + expdir.Name),
        ImageName,
        ImageNameLength
        )) {
            return FALSE;
    }

    return TRUE;
}

HANDLE
StartDebuggee(
    LPSTR ProgName
    )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInformation;


    ZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(StartupInfo);

    BOOL rval = CreateProcess(
        NULL,
        ProgName,
        NULL,
        NULL,
        FALSE,
        DEBUG_ONLY_THIS_PROCESS | CREATE_SEPARATE_WOW_VDM,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation
        );
    if (!rval) {
        return NULL;
    }

    return ProcessInformation.hProcess;
}

BOOL
ResumeAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    )
{
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    while( ThisThread->Next ) {
        if (ExceptionThread && ExceptionThread->hThread == ThisThread->hThread) {
            ThisThread = ThisThread->Next;
            continue;
        }
        ResumeThread( ThisThread->hThread );
        ThisThread = ThisThread->Next;
    }
    return TRUE;
}

BOOL
SuspendAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    )
{
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    while( ThisThread->Next ) {
        if (ExceptionThread && ExceptionThread->hThread == ThisThread->hThread) {
            ThisThread = ThisThread->Next;
            continue;
        }
        SuspendThread( ThisThread->hThread );
        ThisThread = ThisThread->Next;
    }
    return TRUE;
}

PBREAKPOINT_INFO
GetAvailBreakpoint(
    PPROCESS_INFO   ThisProcess
    )
{
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Address == 0) {
            ZeroMemory( &ThisProcess->Breakpoints[i], sizeof(BREAKPOINT_INFO) );
            return &ThisProcess->Breakpoints[i];
        }
    }
    return NULL;
}

PBREAKPOINT_INFO
SetBreakpoint(
    PPROCESS_INFO   ThisProcess,
    DWORD_PTR       Address,
    DWORD           Flags,
    LPSTR           SymName,
    PBP_HANDLER     Handler
    )
{
    if (Address) {
        for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
            if (ThisProcess->Breakpoints[i].Address == Address) {
                return &ThisProcess->Breakpoints[i];
            }
        }
    }

    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (!bp) {
        return NULL;
    }

    bp->Address = Address;
    bp->Handler = Handler;
    bp->Flags   = Flags;

    if (Flags & BPF_UNINSTANCIATED) {
        if (SymName) {
            bp->SymName = _strdup( SymName );
        }
        bp->Address = 0xffffffff;
    } else {
        ReadMemory(
            ThisProcess->hProcess,
            (PVOID)Address,
            &bp->OriginalInstr,
            BpSize
            );
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID)Address,
            &BpInstr,
            BpSize
            );
    }

    return bp;
}

BOOL
ClearBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    )
{
    if ((!(bp->Flags & BPF_UNINSTANCIATED)) && (!(bp->Flags & BPF_TRACE))) {
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID) bp->Address,
            &bp->OriginalInstr,
            BpSize
            );
    }

    ZeroMemory( bp, sizeof(BREAKPOINT_INFO) );

    return TRUE;
}

BOOL
InstanciateBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    )
{
    if ((!bp) || (!bp->SymName) || (!bp->Flags&BPF_UNINSTANCIATED)) {
        return FALSE;
    }

    ULONG_PTR Address;
    GetAddress( bp->SymName, &Address );
    if (!Address) {
        return FALSE;
    }

    bp->Address = Address;
    bp->Flags &= ~BPF_UNINSTANCIATED;
    free( bp->SymName );
    bp->SymName = NULL;

    ReadMemory(
        ThisProcess->hProcess,
        (PVOID)Address,
        &bp->OriginalInstr,
        BpSize
        );
    WriteMemory(
        ThisProcess->hProcess,
        (PVOID)Address,
        &BpInstr,
        BpSize
        );

    if (bp->Number) {
        printf( "Breakpoint #%d instanciated\n", bp->Number );
    }

    return TRUE;
}

BOOL
InstanciateAllBreakpoints(
    PPROCESS_INFO   ThisProcess
    )
{
    BOOL rval = FALSE;
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED) {
            InstanciateBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
            rval = TRUE;
        }
    }
    return rval;
}

DWORD
BreakinBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        NULL
        );
    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return ContinueStatus;
}

DWORD
TrojanHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    WriteMemory(
        ThisThread->hProcess,
        (PVOID)ThisProcess->TrojanAddress,
        (PVOID)BreakpointInfo->Text,
        BreakpointInfo->TextSize
        );
    MemFree( BreakpointInfo->Text );

    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    if (Context.RV_REG == 0) {
        PopUpMsg( "Could not load dll into program" );
        return 0;
    }

    SetRegContext( ThisThread->hThread, &BreakpointInfo->Context );

    PostMessage( hwndFrame, WM_TROJAN_COMPLETE, 0, 0 );

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );

    return DBG_CONTINUE;
}

DWORD
DisableHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    DisableHeapChecking( ThisProcess->hProcess, (PVOID)Context.RV_REG );

    ResumeAllThreads( ThisProcess, ThisThread );

    if (CreateHeapAddr) {
        if (!SetBreakpoint( ThisProcess, CreateHeapAddr, 0, NULL, CreateHeapHandler )) {
            PopUpMsg( "Could not set breakpoint @ RtlCreateHeap" );
        }
    }

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
CreateHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    ULONG_PTR RetAddr;

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)Context.STK_REG,
        &RetAddr,
        sizeof(RetAddr)
        );

    SetBreakpoint(
        ThisProcess,
        RetAddr,
        0,
        NULL,
        DisableHeapHandler
        );

    ResumeAllThreads( ThisProcess, ThisThread );

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
EntryPointHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (!bp) {
        return DBG_EXCEPTION_NOT_HANDLED;
    }

    bp->Handler = TrojanHandler;

    bp->TextSize = PAGE_SIZE;
    bp->Text = MemAlloc( bp->TextSize );
    if (!bp->Text)
        return DBG_EXCEPTION_NOT_HANDLED;

    //
    // save the process memory
    //
    DWORD_PTR TrojanAddress = PAGE_ALIGN( ExceptionRecord->ExceptionAddress );
    ThisProcess->TrojanAddress = TrojanAddress;

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)TrojanAddress,
        bp->Text,
        bp->TextSize
        );

    PUCHAR Text = (PUCHAR) MemAlloc( bp->TextSize );
    if (!Text)
        return DBG_EXCEPTION_NOT_HANDLED;

    ZeroMemory( Text, bp->TextSize );

    bp->Address = CreateTrojanHorse(Text, TrojanAddress );

    GetRegContext( ThisThread->hThread, &bp->Context );
    DWORD_PTR savedPC = (DWORD_PTR)bp->Context.PC_REG;
    bp->Context.PC_REG = TrojanAddress;
    SetRegContext( ThisThread->hThread, &bp->Context );
    bp->Context.PC_REG = savedPC;

    WriteMemory(
        ThisThread->hProcess,
        (PVOID)TrojanAddress,
        (PVOID)Text,
        bp->TextSize
        );
    //printf( "*** trojan written at 0x%08x\n", TrojanAddress );

    FlushInstructionCache( ThisThread->hProcess, (PVOID)TrojanAddress, bp->TextSize );

    MemFree( Text );

    if (ApiMonOptions.HeapChecking && CreateHeapAddr) {
        PBREAKPOINT_INFO bp2 = SetBreakpoint(
            ThisProcess,
            CreateHeapAddr,
            0,
            NULL,
            CreateHeapHandler
            );
        if (!bp2) {
            PopUpMsg( "Could not set breakpoint @ RtlCreateHeap" );
        }
    }

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );

    return DBG_CONTINUE;
}

DWORD
HandleSingleStep(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    )
{
    ULONG ContinueStatus = DBG_CONTINUE;

    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Flags & BPF_TRACE) {
            if (ThisProcess->Breakpoints[i].Handler) {
                ContinueStatus = ThisProcess->Breakpoints[i].Handler(
                    ThisProcess,
                    ThisThread,
                    ExceptionRecord,
                    &ThisProcess->Breakpoints[i]
                    );
                break;
            }
        }
    }

    return ContinueStatus;
}

DWORD
HandleBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    )
{
    ULONG ContinueStatus = DBG_CONTINUE;
    ULONG Instr = 0;
    ULONG cb;
    PUCHAR Text;

    if (!ThisProcess->SeenLdrBp) {
        //
        // this is the loader breakpoint
        //
        if (ThisProcess->StaticLink) {
            PostMessage( hwndFrame, WM_TROJAN_COMPLETE, 0, 0 );
        } else {
            IMAGE_DOS_HEADER dh;
            IMAGE_NT_HEADERS nh;
            DWORD_PTR address = ThisProcess->LoadAddress;
            ReadMemory(
                ThisThread->hProcess,
                (PVOID)address,
                &dh,
                sizeof(dh)
                );
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                goto exit;
            }
            address += dh.e_lfanew;
            ReadMemory(
                ThisThread->hProcess,
                (PVOID)address,
                &nh,
                sizeof(nh)
                );

            ThisProcess->EntryPoint =
                ThisProcess->LoadAddress + nh.OptionalHeader.AddressOfEntryPoint;

#ifndef _M_IX86
            ThisProcess->EntryPoint += BP_SIZE;
#endif

            SetBreakpoint(
                ThisProcess,
                ThisProcess->EntryPoint,
                0,
                NULL,
                EntryPointHandler
                );
        }
    } else {
        for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
            if (ThisProcess->Breakpoints[i].Address == (ULONG_PTR)ExceptionRecord->ExceptionAddress) {
#ifdef _M_IX86
                //
                // reset the pc to re-execute the code - ONLY ON X86!
                //
                CONTEXT Context;
                GetRegContext( ThisThread->hThread, &Context );
                Context.PC_REG -= BP_SIZE;
                CurrContext.PC_REG -= BP_SIZE;
                SetRegContext( ThisThread->hThread, &Context );
#endif
                //
                // restore the original instruction
                //
                WriteMemory(
                    ThisThread->hProcess,
                    (PVOID)ExceptionRecord->ExceptionAddress,
                    &ThisProcess->Breakpoints[i].OriginalInstr,
                    BpSize
                    );
                //
                // call the assigned handler
                //
                if (ThisProcess->Breakpoints[i].Handler) {
                    ContinueStatus = ThisProcess->Breakpoints[i].Handler(
                        ThisProcess,
                        ThisThread,
                        ExceptionRecord,
                        &ThisProcess->Breakpoints[i]
                        );
                }
                //
                // continue the debug event
                //
                goto exit;
            }
        }
        ConsoleDebugger(
            ThisThread->hProcess,
            ThisThread->hThread,
            ExceptionRecord,
            TRUE,
            TRUE,
            NULL
            );
    }

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)ExceptionRecord->ExceptionAddress,
        &Instr,
        BP_SIZE
        );
    if (IsBreakpoint(&Instr)) {
        //
        // skip over the hard coded bp
        //
#ifndef _M_IX86
        CONTEXT Context;
        GetRegContext( ThisThread->hThread, &Context );
        Context.PC_REG += BpSize;
        SetRegContext( ThisThread->hThread, &Context );
#endif
    } else {
        ContinueStatus = 0;
    }

exit:
    return ContinueStatus;
}

PDLL_INFO
GetModuleForAddr(
    ULONG_PTR Addr
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (Addr >= DllList[i].BaseAddress &&
            Addr <  DllList[i].BaseAddress+DllList[i].Size) {
                return &DllList[i];
        }
    }
    return NULL;
}

PAPI_INFO
GetApiForAddr(
    ULONG_PTR Addr
    )
{
    PDLL_INFO DllInfo = GetModuleForAddr( Addr );
    if (!DllInfo) {
        return NULL;
    }

    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    for (ULONG i=0; i<DllInfo->ApiCount; i++) {
        if (Addr == ApiInfo[i].Address) {
            return &ApiInfo[i];
        }
    }

    return NULL;
}

PPROCESS_INFO
GetProcessInfo(
    HANDLE hProcess
    )
{
    PPROCESS_INFO ThisProcess = &ProcessHead;
    do {
        if (ThisProcess->hProcess == hProcess) {
            return ThisProcess;
        }
        ThisProcess = ThisProcess->Next;
    } while (ThisProcess);
    return NULL;
}

PTHREAD_INFO
GetThreadInfo(
    HANDLE hProcess,
    HANDLE hThread
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        return NULL;
    }
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    do {
        if (ThisThread->hThread == hThread) {
            return ThisThread;
        }
        ThisThread = ThisThread->Next;
    } while (ThisThread);
    return NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\expr.cpp ===
#include "apimonp.h"
#pragma hdrstop

#include <setjmp.h>

#define SYMBOLSIZE      256

extern HANDLE CurrProcess;

PUCHAR          pchCommand = NULL;
ULONG           baseDefault = 16;
BOOL            addrExpression = FALSE;
BOOL            ExprError;


ULONG   PeekToken(LONG_PTR *);
ULONG   GetTokenSym(LONG_PTR *);
ULONG   NextToken(LONG_PTR *);
void    AcceptToken(void);
UCHAR   PeekChar(void);

void    GetLowerString(PUCHAR, ULONG);
LONG_PTR GetExpr(void);
LONG_PTR GetLRterm(void);
LONG_PTR GetLterm(void);
LONG_PTR GetAterm(void);
LONG_PTR GetMterm(void);
LONG_PTR GetTerm(void);
ULONG_PTR tempAddr;
BOOLEAN SymbolOnlyExpr(void);
BOOL    GetMemByte(ULONG_PTR,PUCHAR);
BOOL    GetMemWord(ULONG_PTR,PUSHORT);
BOOL    GetMemDword(ULONG_PTR,PULONG);
ULONG   GetMemString(ULONG_PTR,PUCHAR,ULONG);


//  token classes (< 100) and types (>= 100)

#define EOL_CLASS       0
#define ADDOP_CLASS     1
#define ADDOP_PLUS      100
#define ADDOP_MINUS     101
#define MULOP_CLASS     2
#define MULOP_MULT      200
#define MULOP_DIVIDE    201
#define MULOP_MOD       202
#define MULOP_SEG       203
#define LOGOP_CLASS     3
#define LOGOP_AND       300
#define LOGOP_OR        301
#define LOGOP_XOR       302
#define LRELOP_CLASS    4
#define LRELOP_EQ       400
#define LRELOP_NE       401
#define LRELOP_LT       402
#define LRELOP_GT       403
#define UNOP_CLASS      5
#define UNOP_NOT        500
#define UNOP_BY         501
#define UNOP_WO         502
#define UNOP_DW         503
#define UNOP_POI        504
#define UNOP_LOW        505
#define UNOP_HI         506
#define LPAREN_CLASS    6
#define RPAREN_CLASS    7
#define LBRACK_CLASS    8
#define RBRACK_CLASS    9
#define REG_CLASS       10
#define NUMBER_CLASS    11
#define SYMBOL_CLASS    12
#define ERROR_CLASS     99              //only used for PeekToken

//  error codes

#define OVERFLOW        0x1000
#define SYNTAX          0x1001
#define BADRANGE        0x1002
#define VARDEF          0x1003
#define EXTRACHARS      0x1004
#define LISTSIZE        0x1005
#define STRINGSIZE      0x1006
#define MEMORY          0x1007
#define BADREG          0x1008
#define BADOPCODE       0x1009
#define SUFFIX          0x100a
#define OPERAND         0x100b
#define ALIGNMENT       0x100c
#define PREFIX          0x100d
#define DISPLACEMENT    0x100e
#define BPLISTFULL      0x100f
#define BPDUPLICATE     0x1010
#define BADTHREAD       0x1011
#define DIVIDE          0x1012
#define TOOFEW          0x1013
#define TOOMANY         0x1014
#define SIZE            0x1015
#define BADSEG          0x1016
#define RELOC           0x1017
#define BADPROCESS      0x1018
#define AMBIGUOUS       0x1019
#define FILEREAD        0x101a
#define LINENUMBER      0x101b
#define BADSEL          0x101c
#define SYMTOOSMALL     0x101d
#define BPIONOTSUP      0x101e
#define UNIMPLEMENT     0x1099

struct Res {
    UCHAR    chRes[3];
    ULONG    classRes;
    ULONG    valueRes;
    } Reserved[] = {
        { 'o', 'r', '\0', LOGOP_CLASS, LOGOP_OR  },
        { 'b', 'y', '\0', UNOP_CLASS,  UNOP_BY   },
        { 'w', 'o', '\0', UNOP_CLASS,  UNOP_WO   },
        { 'd', 'w', '\0', UNOP_CLASS,  UNOP_DW   },
        { 'h', 'i', '\0', UNOP_CLASS,  UNOP_HI   },
        { 'm', 'o', 'd',  MULOP_CLASS, MULOP_MOD },
        { 'x', 'o', 'r',  LOGOP_CLASS, LOGOP_XOR },
        { 'a', 'n', 'd',  LOGOP_CLASS, LOGOP_AND },
        { 'p', 'o', 'i',  UNOP_CLASS,  UNOP_POI  },
        { 'n', 'o', 't',  UNOP_CLASS,  UNOP_NOT  },
        { 'l', 'o', 'w',  UNOP_CLASS,  UNOP_LOW  }
#ifdef i386xx
       ,{ 'e', 'a', 'x',  REG_CLASS,   REGEAX   },
        { 'e', 'b', 'x',  REG_CLASS,   REGEBX   },
        { 'e', 'c', 'x',  REG_CLASS,   REGECX   },
        { 'e', 'd', 'x',  REG_CLASS,   REGEDX   },
        { 'e', 'b', 'p',  REG_CLASS,   REGEBP   },
        { 'e', 's', 'p',  REG_CLASS,   REGESP   },
        { 'e', 'i', 'p',  REG_CLASS,   REGEIP   },
        { 'e', 's', 'i',  REG_CLASS,   REGESI   },
        { 'e', 'd', 'i',  REG_CLASS,   REGEDI   },
        { 'e', 'f', 'l',  REG_CLASS,   REGEFL   }
#endif
        };

#define RESERVESIZE (sizeof(Reserved) / sizeof(struct Res))

ULONG   savedClass;
LONG_PTR savedValue;
UCHAR   *savedpchCmd;

ULONG   cbPrompt = 8;
PUCHAR  pchStart;
jmp_buf cmd_return;

static char szBlanks[] =
                  "                                                  "
                  "                                                  "
                  "                                                  "
                  "                                                ^ ";

ULONG_PTR EXPRLastExpression = 0;
extern  BOOLEAN fPhysicalAddress;


extern BOOL cdecl cmdHandler(ULONG);
extern BOOL cdecl waitHandler(ULONG);



void
error(
    ULONG errcode
    )
{
    ULONG count = cbPrompt;
    UCHAR *pchtemp = pchStart;

    while (pchtemp < pchCommand) {
        if (*pchtemp++ == '\t') {
            count = (count + 7) & ~7;
        } else {
            count++;
        }
    }

    printf( &szBlanks[sizeof(szBlanks) - (count + 1)] );

    switch (errcode) {
        case OVERFLOW:
            printf("Overflow");
            break;

        case SYNTAX:
            printf("Syntax");
            break;

        case BADRANGE:
            printf("Range");
            break;

        case VARDEF:
            printf("Variable definition");
            break;

        case EXTRACHARS:
            printf("Extra character");
            break;

        case LISTSIZE:
            printf("List size");
            break;

        case STRINGSIZE:
            printf("String size");
            break;

        case MEMORY:
            printf("Memory access");
            break;

        case BADREG:
            printf("Bad register");
            break;

        case BADOPCODE:
            printf("Bad opcode");
            break;

        case SUFFIX:
            printf("Opcode suffix");
            break;

        case OPERAND:
            printf("Operand");
            break;

        case ALIGNMENT:
            printf("Alignment");
            break;

        case PREFIX:
            printf("Opcode prefix");
            break;

        case DISPLACEMENT:
            printf("Displacement");
            break;

        case BPLISTFULL:
            printf("No breakpoint available");
            break;

        case BPDUPLICATE:
            printf("Duplicate breakpoint");
            break;

        case UNIMPLEMENT:
            printf("Unimplemented");
            break;

        case AMBIGUOUS:
            printf("Ambiguous symbol");
            break;

        case FILEREAD:
            printf("File read");
            break;

        case LINENUMBER:
            printf("Line number");
            break;

        case BADSEL:
            printf("Bad selector");
            break;

        case BADSEG:
            printf("Bad segment");
            break;

        case SYMTOOSMALL:
            printf("Symbol only 1 character");
            break;

        default:
            printf("Unknown");
            break;
    }

    printf(" error in '%s'\n", pchStart);

    ExprError = TRUE;

    longjmp( cmd_return, 1 );
}


/*** GetAddrExpression - read and evaluate address expression
*
*   Purpose:
*       Used to get an address expression.
*
*   Returns:
*       Pointer to address packet
*
*   Exceptions:
*       error exit: SYNTAX - empty expression or premature end-of-line
*
*
*************************************************************************/
ULONG_PTR GetAddrExpression (LPSTR CommandString, ULONG_PTR *Address)
{
    ULONG_PTR value;

    //  Do a normal GetExpression call

    value = GetExpression(CommandString);
    *Address = tempAddr;

    return *Address;
}



/*** GetExpression - read and evaluate expression (top-level)
*
*   Purpose:
*       From the current command line position at pchCommand,
*       read and evaluate the next possible expression and
*       return its value.  The expression is parsed and evaluated
*       using a recursive descent method.
*
*   Input:
*       pchCommand - command line position
*
*   Returns:
*       unsigned long value of expression.
*
*   Exceptions:
*       error exit: SYNTAX - empty expression or premature end-of-line
*
*   Notes:
*       the routine will attempt to parse the longest expression
*       possible.
*
*************************************************************************/


ULONG_PTR
GetExpression(
    LPSTR CommandString
    )
{
    PUCHAR            pchCommandSaved;
    UCHAR             chModule[40];
    UCHAR             chFilename[40];
    UCHAR             ch;
    ULONG_PTR         value;
    ULONG             baseSaved;
    PUCHAR            pchFilename;


    ExprError = FALSE;
    pchCommand = (PUCHAR)CommandString;
    pchStart = (PUCHAR)CommandString;
    savedClass = (ULONG)-1;
    pchCommandSaved = pchCommand;

    if (PeekChar() == '!') {
        pchCommand++;
    }

    GetLowerString(chModule, 40);
    ch = PeekChar();

    if (ch == '!') {
        pchCommand++;
        GetLowerString(chFilename, 40);
        ch = PeekChar();
    } else {
        strcpy( (LPSTR)chFilename, (LPSTR)chModule );
        chModule[0] = '\0';
    }

    pchCommand = pchCommandSaved;
    if (setjmp(cmd_return) == 0) {
        value = (ULONG_PTR)GetExpr();
    } else {
        value = 0;
    }

    EXPRLastExpression = value;

    return value;
}

void GetLowerString (PUCHAR pchBuffer, ULONG cbBuffer)
{
    UCHAR   ch;

    ch = PeekChar();
    ch = (UCHAR)tolower(ch);
    while ((ch == '_' || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) && --cbBuffer) {
        *pchBuffer++ = ch;
        ch = *++pchCommand;
    }
    *pchBuffer = '\0';
}

/*** GetExpr - Get expression
*
*   Purpose:
*       Parse logical-terms separated by logical operators into
*       expression value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<logic-op> <lterm>]*
*       <logic-op> = AND (&), OR (|), XOR (^)
*
*************************************************************************/

LONG_PTR GetExpr ()
{
    LONG_PTR value1;
    LONG_PTR value2;
    ULONG   opclass;
    LONG_PTR opvalue;


    value1 = GetLRterm();
    while ((opclass = PeekToken(&opvalue)) == LOGOP_CLASS) {
        AcceptToken();
        value2 = GetLRterm();
        switch (opvalue) {
            case LOGOP_AND:
                value1 &= value2;
                break;
            case LOGOP_OR:
                value1 |= value2;
                break;
            case LOGOP_XOR:
                value1 ^= value2;
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetLRterm - get logical relational term
*
*   Purpose:
*       Parse logical-terms separated by logical relational
*       operators into the expression value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<rel-logic-op> <lterm>]*
*       <logic-op> = '==' or '=', '!=', '>', '<'
*
*************************************************************************/

LONG_PTR GetLRterm ()
{
    LONG_PTR    value1;
    LONG_PTR    value2;
    ULONG   opclass;
    LONG_PTR    opvalue;


    value1 = GetLterm();
    while ((opclass = PeekToken(&opvalue)) == LRELOP_CLASS) {
        AcceptToken();
        value2 = GetLterm();
        switch (opvalue) {
            case LRELOP_EQ:
                value1 = (value1 == value2);
                break;
            case LRELOP_NE:
                value1 = (value1 != value2);
                break;
            case LRELOP_LT:
                value1 = (value1 < value2);
                break;
            case LRELOP_GT:
                value1 = (value1 > value2);
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetLterm - get logical term
*
*   Purpose:
*       Parse additive-terms separated by additive operators into
*       logical term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad logical term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <lterm> = <aterm> [<add-op> <aterm>]*
*       <add-op> = +, -
*
*************************************************************************/

LONG_PTR
GetLterm(
    VOID
    )
{
    LONG_PTR  value1;
    LONG_PTR  value2;
    ULONG   opclass;
    LONG_PTR  opvalue;


    value1 = GetAterm();
    while ((opclass = PeekToken(&opvalue)) == ADDOP_CLASS) {
        AcceptToken();
        value2 = GetAterm();
        if (addrExpression) {
                switch (opvalue) {
                        case ADDOP_PLUS:
                                value1 += tempAddr;
                                break;
                        case ADDOP_MINUS:
                                value1 -= tempAddr;
                                break;
                        default:
                                error(SYNTAX);
                }
        }
        else
        switch (opvalue) {
            case ADDOP_PLUS:
                value1 += value2;
                break;
            case ADDOP_MINUS:
                value1 -= value2;
                break;
            default:
                error(SYNTAX);
            }
    }
    return value1;
}

/*** GetAterm - get additive term
*
*   Purpose:
*       Parse multiplicative-terms separated by multipicative operators
*       into additive term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of product.
*
*   Exceptions:
*       error exit: SYNTAX - bad additive term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <aterm> = <mterm> [<mult-op> <mterm>]*
*       <mult-op> = *, /, MOD (%)
*
*************************************************************************/

LONG_PTR GetAterm ()
{
    LONG_PTR value1;
    LONG_PTR value2;
    ULONG   opclass;
    LONG_PTR opvalue;


    value1 = GetMterm();
    while ((opclass = PeekToken(&opvalue)) == MULOP_CLASS) {
        AcceptToken();
        value2 = GetAterm();
        switch (opvalue) {
            case MULOP_MULT:
                value1 *= value2;
                break;
            case MULOP_DIVIDE:
                value1 /= value2;
                break;
            case MULOP_MOD:
                value1 %= value2;
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetMterm - get multiplicative term
*
*   Purpose:
*       Parse basic-terms optionally prefaced by one or more
*       unary operators into a multiplicative term.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of multiplicative term.
*
*   Exceptions:
*       error exit: SYNTAX - bad multiplicative term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <mterm> = [<unary-op>] <term> | <unary-op> <mterm>
*       <unary-op> = <add-op>, ~ (NOT), BY, WO, DW, HI, LOW
*
*************************************************************************/

LONG_PTR
GetMterm(
    VOID
    )
{
    LONG_PTR value;
    USHORT  wvalue;
    UCHAR   bvalue;
    ULONG   opclass;
    LONG_PTR opvalue;


    if ((opclass = PeekToken(&opvalue)) == UNOP_CLASS || opclass == ADDOP_CLASS) {
        AcceptToken();
        value = GetMterm();
        switch (opvalue) {
            case UNOP_NOT:
                value = !value;
                break;
            case UNOP_BY:
            case UNOP_WO:
            case UNOP_DW:
            case UNOP_POI:
                tempAddr = value;
                switch (opvalue) {
                    case UNOP_BY:
                        if (!GetMemByte(tempAddr, &bvalue)) {
                            error(MEMORY);
                        }
                        value = (LONG)bvalue;
                        break;
                    case UNOP_WO:
                        if (!GetMemWord(tempAddr, &wvalue)) {
                            error(MEMORY);
                        }
                        value = (LONG)wvalue;
                        break;
                    case UNOP_DW:
                        if (!GetMemDword(tempAddr, (PULONG)&value)) {
                            error(MEMORY);
                        }
                        break;
                    case UNOP_POI:
                        //
                        // There should be some special processing for
                        // 16:16 or 16:32 addresses (i.e. take the DWORD)
                        // and make it back into a value with a possible
                        // segment, but I've left this for others who might
                        // know more of what they want.
                        //
                        if (!GetMemDword(tempAddr, (PULONG)&value)) {
                            error(MEMORY);
                        }
                        break;
                    }
                break;

            case UNOP_LOW:
                value &= 0xffff;
                break;
            case UNOP_HI:
                value >>= 16;
                break;
            case ADDOP_PLUS:
                break;
            case ADDOP_MINUS:
                value = -value;
                break;
            default:
                error(SYNTAX);
            }
        }
    else {
        value = GetTerm();
    }
    return value;
}

/*** GetTerm - get basic term
*
*   Purpose:
*       Parse numeric, variable, or register name into a basic
*       term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of basic term.
*
*   Exceptions:
*       error exit: SYNTAX - empty basic term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <term> = ( <expr> ) | <register-value> | <number> | <variable>
*       <register-value> = @<register-name>
*
*************************************************************************/

LONG_PTR
GetTerm(
    VOID
    )
{
    LONG_PTR    value = 0;
    ULONG   opclass;
    LONG_PTR    opvalue;

    opclass = GetTokenSym(&opvalue);
    if (opclass == LPAREN_CLASS) {
        value = GetExpr();
        if (GetTokenSym(&opvalue) != RPAREN_CLASS)
            error(SYNTAX);
    }
    else if (opclass == REG_CLASS) {
        value = (ULONG)GetRegFlagValue((DWORD)opvalue);
    }
    else if (opclass == NUMBER_CLASS || opclass == SYMBOL_CLASS) {
        value = opvalue;
    } else {
        error(SYNTAX);
    }

    return value;
}

/*** GetRange - parse address range specification
*
*   Purpose:
*       With the current command line position, parse an
*       address range specification.  Forms accepted are:
*       <start-addr>            - starting address with default length
*       <start-addr> <end-addr> - inclusive address range
*       <start-addr> l<count>   - starting address with item count
*
*   Input:
*       pchCommand - present command line location
*       size - nonzero - (for data) size in bytes of items to list
*                        specification will be "length" type with
*                        *fLength forced to TRUE.
*              zero - (for instructions) specification either "length"
*                     or "range" type, no size assumption made.
*
*   Output:
*       *addr - starting address of range
*       *value - if *fLength = TRUE, count of items (forced if size != 0)
*                              FALSE, ending address of range
*       (*addr and *value unchanged if no second argument in command)
*
*   Exceptions:
*       error exit:
*               SYNTAX - expression error
*               BADRANGE - if ending address before starting address
*
*************************************************************************/

void
GetRange(
    LPSTR       CommandString,
    ULONG_PTR * addr,
    ULONG_PTR * value,
    PBOOLEAN    fLength,
    ULONG       size
    )

{
    static ULONG_PTR EndRange;
    UCHAR    ch;
    PUCHAR   psz;
    BOOLEAN  fSpace = FALSE;
    BOOLEAN  fL = FALSE;

    PeekChar();          //  skip leading whitespace first

    //  Pre-parse the line, look for a " L"

    for (psz = pchCommand; *psz; psz++) {
        if ((*psz == 'L' || *psz == 'l') && fSpace) {
            fL = TRUE;
            *psz = '\0';
            break;
        }
        fSpace = (BOOLEAN)(*psz == ' ');
    }

    if ((ch = PeekChar()) != '\0' && ch != ';') {
        GetAddrExpression(CommandString,addr);
        if (((ch = PeekChar()) != '\0' && ch != ';') || fL) {
            if (!fL) {
                GetAddrExpression(CommandString,&EndRange);
                *value = (ULONG_PTR)&EndRange;
                if (*addr > EndRange) {
                    error(BADRANGE);
                }
                if (size) {
                    *value = (EndRange - *addr) / size + 1;
                    *fLength = TRUE;
                } else {
                    *fLength = FALSE;
                }
                return;
            } else {
                *fLength = TRUE;
                pchCommand = psz + 1;
                *value = GetExpression(CommandString);
                *psz = 'l';
            }
        }
    }
}

/*** PeekChar - peek the next non-white-space character
*
*   Purpose:
*       Return the next non-white-space character and update
*       pchCommand to point to it.
*
*   Input:
*       pchCommand - present command line position.
*
*   Returns:
*       next non-white-space character
*
*************************************************************************/

UCHAR PeekChar (void)
{
    UCHAR    ch;

    do
        ch = *pchCommand++;
    while (ch == ' ' || ch == '\t');
    pchCommand--;
    return ch;
}

/*** PeekToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the pchCommand pointer.
*
*   Input:
*       pchCommand - present command line position.
*
*   Output:
*       *pvalue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       savedClass, savedValue, and savedpchCmd saves the token getting
*       state for future peeks.  To get the next token, a GetToken or
*       AcceptToken call must first be made.
*
*************************************************************************/

ULONG PeekToken (LONG_PTR * pvalue)
{
    UCHAR    *pchTemp;

    //  Get next class and value, but do not
    //  move pchCommand, but save it in savedpchCmd.
    //  Do not report any error condition.

    if (savedClass == -1) {
        pchTemp = pchCommand;
        savedClass = NextToken(&savedValue);
        savedpchCmd = pchCommand;
        pchCommand = pchTemp;
        }
    *pvalue = savedValue;
    return savedClass;
}

/*** AcceptToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekToken saved variables so the next PeekToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void AcceptToken (void)
{
    savedClass = (ULONG)-1;
    pchCommand = savedpchCmd;
}

/*** GetToken - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekToken and AcceptToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer pchCommand.
*
*   Input:
*       pchCommand - present command string pointer
*
*   Output:
*       *pvalue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
GetTokenSym(
    LONG_PTR *pvalue
    )
{
    ULONG   opclass;

    if (savedClass != (ULONG)-1) {
        opclass = savedClass;
        savedClass = (ULONG)-1;
        *pvalue = savedValue;
        pchCommand = savedpchCmd;
        }
    else
        opclass = NextToken(pvalue);

    if (opclass == ERROR_CLASS)
        error((DWORD)*pvalue);

    return opclass;
}

/*** NextToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       pchCommand - pointer to present command string
*
*   Output:
*       *pvalue - optional value of token returned
*       pchCommand - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
NextToken(
    LONG_PTR * pvalue
    )
{
    ULONG           base;
    UCHAR           chSymbol[SYMBOLSIZE];
    UCHAR           chSymbolString[SYMBOLSIZE];
    UCHAR           chPreSym[9];
    ULONG           cbSymbol = 0;
    BOOLEAN         fNumber = TRUE;
    BOOLEAN         fSymbol = TRUE;
    BOOLEAN         fForceReg = FALSE;
    BOOLEAN         fForceSym = FALSE;
    ULONG           errNumber = 0;
    UCHAR           ch;
    UCHAR           chlow;
    UCHAR           chtemp;
    UCHAR           limit1 = '9';
    UCHAR           limit2 = '9';
    BOOLEAN         fDigit = FALSE;
    ULONG           value = 0;
    ULONG           tmpvalue;
    ULONG           index;
    //PMODULE_ENTRY   Module;
    PUCHAR          pchCmdSave;
    int             loaded = 0;
    int             instance = 0;
    ULONG           insValue = 0;


    base = baseDefault;

    //  skip leading white space.

    do {
        ch = *pchCommand++;
    } while (ch == ' ' || ch == '\t');

    chlow = (UCHAR)tolower(ch);

    //  test for special character operators and register variable

    switch (chlow) {
        case '\0':
        case ';':
            pchCommand--;
            return EOL_CLASS;
        case '+':
            *pvalue = ADDOP_PLUS;
            return ADDOP_CLASS;
        case '-':
            *pvalue = ADDOP_MINUS;
            return ADDOP_CLASS;
        case '*':
            *pvalue = MULOP_MULT;
            return MULOP_CLASS;
        case '/':
            *pvalue = MULOP_DIVIDE;
            return MULOP_CLASS;
        case '%':
            *pvalue = MULOP_MOD;
            return MULOP_CLASS;
        case '&':
            *pvalue = LOGOP_AND;
            return LOGOP_CLASS;
        case '|':
            *pvalue = LOGOP_OR;
            return LOGOP_CLASS;
        case '^':
            *pvalue = LOGOP_XOR;
            return LOGOP_CLASS;
        case '=':
            if (*pchCommand == '=')
                pchCommand++;
            *pvalue = LRELOP_EQ;
            return LRELOP_CLASS;
        case '>':
            *pvalue = LRELOP_GT;
            return LRELOP_CLASS;
        case '<':
            *pvalue = LRELOP_LT;
            return LRELOP_CLASS;
        case '!':
            if (*pchCommand != '=')
                break;
            pchCommand++;
            *pvalue = LRELOP_NE;
            return LRELOP_CLASS;
        case '~':
            *pvalue = UNOP_NOT;
            return UNOP_CLASS;
        case '(':
            return LPAREN_CLASS;
        case ')':
            return RPAREN_CLASS;
        case '[':
            return LBRACK_CLASS;
        case ']':
            return RBRACK_CLASS;
        case '.':
               GetRegPCValue(&tempAddr);
               *pvalue = tempAddr;
               return NUMBER_CLASS;
        case ':':
            *pvalue = MULOP_SEG;
            return MULOP_CLASS;
        }

    //  special prefixes - '@' for register - '!' for symbol

    if (chlow == '@' || chlow == '!') {
        fForceReg = (BOOLEAN)(chlow == '@');
        fForceSym = (BOOLEAN)!fForceReg;
        fNumber = FALSE;
        ch = *pchCommand++;
        chlow = (UCHAR)tolower(ch);
        }

    //  if string is followed by '!', but not '!=',
    //      then it is a module name and treat as text

    pchCmdSave = pchCommand;

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (chlow == '_') || (chlow == '$')) {
        chlow = (UCHAR)tolower(*pchCommand); pchCommand++;
    }

    //  treat as symbol if a nonnull string is followed by '!',
    //      but not '!='

    if (chlow == '!' && *pchCommand != '=' && pchCmdSave != pchCommand)
        fNumber = FALSE;

    pchCommand = pchCmdSave;
    chlow = (UCHAR)tolower(ch);       //  ch was NOT modified


    if (fNumber) {
        if (chlow == '\'') {
            *pvalue = 0;
            while (TRUE) {
                ch = *pchCommand++;
                if (ch == '\'') {
                    if (*pchCommand != '\'') {
                        break;
                        }
                    ch = *pchCommand++;
                    }
                else
                if (ch == '\\') {
                    ch = *pchCommand++;
                    }
                *pvalue = (*pvalue << 8) | ch;
                }

            return NUMBER_CLASS;
            }

        //  if first character is a decimal digit, it cannot
        //  be a symbol.  leading '0' implies octal, except
        //  a leading '0x' implies hexadecimal.

        if (chlow >= '0' && chlow <= '9') {
            if (fForceReg) {
                *pvalue = SYNTAX;
                return ERROR_CLASS;
                }
            fSymbol = FALSE;
            if (chlow == '0') {
                ch = *pchCommand++;
                chlow = (UCHAR)tolower(ch);
                if (chlow == 'x') {
                    base = 16;
                    ch = *pchCommand++;
                    chlow = (UCHAR)tolower(ch);
                    fDigit = TRUE;
                    }
                else if (chlow == 'n') {
                    base = 10;
                    ch = *pchCommand++;
                    chlow = (UCHAR)tolower(ch);
                    }
                else {
                    base = 8;
                    fDigit = TRUE;
                    }
                }
            }

        //  a number can start with a letter only if base is
        //  hexadecimal and it is a hexadecimal digit 'a'-'f'.

        else if ((chlow < 'a' || chlow > 'f') || base != 16)
            fNumber = FALSE;

        //  set limit characters for the appropriate base.

        if (base == 8)
            limit1 = '7';
        if (base == 16)
            limit2 = 'f';
        }

    //  perform processing while character is a letter,
    //  digit, underscore, or dollar-sign.

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (chlow == '_') || (chlow == '$')) {

        //  if possible number, test if within proper range,
        //  and if so, accumulate sum.

        if (fNumber) {
            if ((chlow >= '0' && chlow <= limit1) ||
                    (chlow >= 'a' && chlow <= limit2)) {
                fDigit = TRUE;
                tmpvalue = value * base;
                if (tmpvalue < value)
                    errNumber = OVERFLOW;
                chtemp = (UCHAR)(chlow - '0');
                if (chtemp > 9)
                    chtemp -= 'a' - '0' - 10;
                value = tmpvalue + (ULONG)chtemp;
                if (value < tmpvalue)
                    errNumber = OVERFLOW;
                }
            else {
                fNumber = FALSE;
                errNumber = SYNTAX;
                }
            }
        if (fSymbol) {
            if (cbSymbol < 9)
                chPreSym[cbSymbol] = chlow;
            if (cbSymbol < SYMBOLSIZE - 1)
                chSymbol[cbSymbol++] = ch;
            }
        ch = *pchCommand++;
        chlow = (UCHAR)tolower(ch);
        }

    //  back up pointer to first character after token.

    pchCommand--;

    if (cbSymbol < 9)
        chPreSym[cbSymbol] = '\0';

    //  if fForceReg, check for register name and return
    //      success or failure

    if (fForceReg) {
        if ((*pvalue = GetRegString((LPSTR)chPreSym)) != -1)
            return REG_CLASS;
        else {
            *pvalue = BADREG;
            return ERROR_CLASS;
            }
        }

    //  test if number

    if (fNumber && !errNumber && fDigit) {
        *pvalue = value;
        return NUMBER_CLASS;
        }

    //  next test for reserved word and symbol string

    if (fSymbol && !fForceReg) {

        //  check lowercase string in chPreSym for text operator
        //  or register name.
        //  otherwise, return symbol value from name in chSymbol.

        if (!fForceSym && (cbSymbol == 2 || cbSymbol == 3))
            for (index = 0; index < RESERVESIZE; index++)
                if (!strncmp((LPSTR)chPreSym, (LPSTR)Reserved[index].chRes, 3)) {
                    *pvalue = Reserved[index].valueRes;
                    return Reserved[index].classRes;
                    }

        //  start processing string as symbol

        chSymbol[cbSymbol] = '\0';

        //  test if symbol is a module name (followed by '!')
        //  if so, get next token and treat as symbol

        if (PeekChar() == '!') {
            // chSymbolString holds the name of the symbol to be searched.
            // chSymbol holds the symbol image file name.

            pchCommand++;
            ch = PeekChar();
            pchCommand++;
            cbSymbol = 0;
            while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') ||
                   (ch >= '0' && ch <= '9') || (ch == '_') || (ch == '$') || (ch == '.')) {
                chSymbolString[cbSymbol++] = ch;
                ch = *pchCommand++;
            }
            chSymbolString[cbSymbol] = '\0';
            pchCommand--;

            LPSTR SymName = (LPSTR) MemAlloc( strlen((LPSTR)chSymbol) + strlen((LPSTR)chSymbolString) + 32 );
            if (SymName) {
                strcpy( SymName, (LPSTR) chSymbol );
                strcat( SymName, "!" );
                strcat( SymName, (LPSTR) chSymbolString );

                if (GetOffsetFromSym( SymName, (PULONG_PTR) pvalue )) {
                    MemFree( SymName );
                    tempAddr = *pvalue;
                    return SYMBOL_CLASS;
                }

                MemFree( SymName );
            }

        } else {

            if (GetOffsetFromSym( (LPSTR) chSymbol, (PULONG_PTR) pvalue )) {
                tempAddr = *pvalue;
                return SYMBOL_CLASS;
            }
        }

        //  symbol is undefined.
        //  if a possible hex number, do not set the error type

        if (!fNumber) {
            errNumber = VARDEF;
        }
    }

    //  last chance, undefined symbol and illegal number,
    //      so test for register, will handle old format

    if (!fForceSym && (*pvalue = GetRegString((LPSTR)chPreSym)) != -1)
        return REG_CLASS;

    //  no success, so set error message and return

    *pvalue = (ULONG)errNumber;
    return ERROR_CLASS;
}

BOOLEAN
SymbolOnlyExpr(
    VOID
    )
{
    PUCHAR  pchComSaved = pchCommand;
    LONG_PTR pvalue;
    ULONG   cclass;
    BOOLEAN fResult;

    fResult = (BOOLEAN)(NextToken(&pvalue) == SYMBOL_CLASS &&
                (cclass = NextToken(&pvalue)) != ADDOP_CLASS &&
                cclass != MULOP_CLASS && cclass != LOGOP_CLASS);
    pchCommand = pchComSaved;
    return fResult;
}

/*** LookupSymbolInDll - Find the numeric value for a symbol from a
*                        specific DLL
*
*   Input:
*       symName - string with the symbol name to lookup
*       dllName - string with dll name in which to look
*
*   Output:
*       none
*
*   Returns:
*       returns value of symbol, or 0 if no symbol found in this dll.
*
*************************************************************************/

ULONG
LookupSymbolInDll (
    PCHAR symName,
    PCHAR dllName
    )
{
    ULONG           retValue;
    //PMODULE_ENTRY   Module;
    char            *imageStr;
    char            *dllStr;


    // skip over whitespace
    while (*symName == ' ' || *symName == '\t') {
        symName++;
    }

    dllStr = _strdup(dllName);
    _strlwr(dllStr);

    //  First check all the exported symbols, if none found on
    //      first pass, force symbol load on second.

// should call module.c
#if 0
    for (pImage = pProcessCurrent->pImageHead;
         pImage;
         pImage = pImage->pImageNext) {
        imageStr = _strdup(pImage->szModuleName);
        _strlwr(imageStr);
        if (!strcmp(imageStr,dllStr)) {
            GetOffsetFromSym(symName, &retValue, pImage->index);
            free(imageStr);
            free(dllStr);
            return(retValue);
        }
        free(imageStr);
    }
#endif
    free(dllStr);
    return(0);
}


BOOL
GetMemByte(
    ULONG_PTR Address,
    PUCHAR  Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(UCHAR)
        );
    return cb > 0;
}

BOOL
GetMemWord(
    ULONG_PTR   Address,
    PUSHORT Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(USHORT)
        );
    return cb > 0;
}

BOOL
GetMemDword(
    ULONG_PTR   Address,
    PULONG  Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(DWORD)
        );
    return cb > 0;
}

ULONG
GetMemString(
    ULONG_PTR   Address,
    PUCHAR  Value,
    ULONG   Length
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        Length
        );
    return Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\graph.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    graph.cpp

Abstract:

    All user interface code for the bar graph window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



GraphWindow::GraphWindow()
{
    GraphCursor      = LoadCursor( hInstance, MAKEINTRESOURCE( IDC_HAND_INTERNAL) );
    HorizSplitCursor = LoadCursor( hInstance, MAKEINTRESOURCE( IDC_HSPLIT) );
    ArrowCursor      = LoadCursor( NULL, IDC_ARROW );
    hwndToolTip      = NULL;
    Bar              = NULL;
    GraphData        = NULL;
    hCursor          = NULL;
    hwndLegend       = NULL;
    ApiGraph         = FALSE;
    MouseDown        = FALSE;
    ZeroMemory( &tm, sizeof(TEXTMETRIC) );
    ZeroMemory( &LastPos, sizeof(POINT) );
}


GraphWindow::~GraphWindow()
{
    DeleteObject( GraphCursor );
    DeleteObject( HorizSplitCursor );
    DeleteObject( ArrowCursor );
}


BOOL
GraphWindow::Create(BOOL isbase)
{
    Base = isbase;
    return ApiMonWindow::Create(
        "ApiMonGraph",
        "Graph"
        );
}

BOOL
GraphWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonGraph",
        IDI_CHILDICON,
        MDIChildWndProcGraph
        );
}


BOOL
GraphWindow::Update(
    BOOL    ForceUpdate
    )
{
    return FALSE;
}


void
GraphWindow::ChangeFont(
    HFONT hFont
    )
{
    ApiMonWindow::hFont = hFont;
    PostMessage( hwndWin, WM_FONT_CHANGE, 0, (LPARAM) hFont );
}


void
GraphWindow::ChangeColor(
    COLORREF    Color
    )
{
    ApiMonWindow::Color = Color;
    PostMessage( hwndWin, WM_COLOR_CHANGE, 0, (LPARAM) Color );
}


PGRAPH_DATA
GraphWindow::CreateGraphData()
{
    ULONG       i;
    ULONG       j;
    ULONG       Cnt;
    PAPI_INFO   ApiInfo;
    PGRAPH_DATA GraphData;


    for (Cnt=0,i=0; i<MAX_DLLS; i++) {
        DllList[i].Hits = 0;
        if (DllList[i].BaseAddress && DllList[i].ApiCount) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Time) {
                    DllList[i].Hits += 1;
                }
            }
            if (DllList[i].Hits) {
                Cnt += 1;
            }
        }
    }
    if (!Cnt) {
        return NULL;
    }

    i = sizeof(GRAPH_DATA) + (sizeof(GRAPH_VALUE) * Cnt);
    GraphData = (PGRAPH_DATA) LocalAlloc( LPTR, i );
    if (!GraphData) {
        return NULL;
    }
    ZeroMemory( GraphData, i );

    GraphData->NumberOfBars = Cnt;
    for (Cnt=0,i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Hits) {
            GraphData->Bar[Cnt].Value = 0;
            GraphData->Bar[Cnt].Address = DllList[i].BaseAddress;
            strcpy( GraphData->Bar[Cnt].Name, DllList[i].Name );
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Time) {
                    GraphData->Bar[Cnt].Value += ApiInfo[j].Time;
                    GraphData->Bar[Cnt].Hits  += ApiInfo[j].Count;
                }
            }
            Cnt += 1;
        }
    }

    return GraphData;
}

PGRAPH_DATA
GraphWindow::CreateGraphDataApi(
    ULONG_PTR   BaseAddress
    )
{
    ULONG i;
    ULONG Cnt = 0;
    PAPI_INFO ApiInfo;
    PGRAPH_DATA GraphData;
    PDLL_INFO DllInfo = NULL;


    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == BaseAddress) {
            DllInfo = &DllList[i];
            ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (PUCHAR)DllList);
            break;
        }
    }
    if (!DllInfo) {
        return NULL;
    }

    for (i=0; i<DllInfo->ApiCount; i++) {
        if (ApiInfo[i].Time) {
            Cnt += 1;
        }
    }

    i = sizeof(GRAPH_DATA) * (sizeof(GRAPH_VALUE) * Cnt);
    GraphData = (PGRAPH_DATA) LocalAlloc( LPTR, i );
    if (!GraphData) {
        return NULL;
    }
    ZeroMemory( GraphData, i );

    GraphData->NumberOfBars = Cnt;
    for (Cnt=0,i=0; i<DllInfo->ApiCount; i++) {
        if (ApiInfo[i].Time) {
            GraphData->Bar[Cnt].Value = ApiInfo[i].Time;
            GraphData->Bar[Cnt].Address = ApiInfo[i].Address;
            GraphData->Bar[Cnt].Hits = ApiInfo[i].Count;
            strcpy( GraphData->Bar[Cnt].Name, (LPSTR)(ApiInfo[i].Name+(LPSTR)MemPtr) );
            Cnt += 1;
        }
    }

    return GraphData;
}

BOOL
GraphWindow::DrawBarGraph(
    PGRAPH_DATA GraphData
    )
{
    if (!GraphData) {
        return FALSE;
    }

    PAINTSTRUCT ps;
    HDC hdc = BeginPaint( hwndWin, &ps );
    if (!hdc) {
        return FALSE;
    }

    ULONG i,j;
    ULONG LongestName = 0;
    ULONG Cnt;
    RECT rc;
    HBRUSH hBrush;
    ULONG LegendHeight = 0;
    TEXTMETRIC tm;
    GetClientRect( hwndWin, &rc );

    LONGLONG HighValue = 0;

    //
    // first iterate thru the values and
    // determine if it has a count.  if there is
    // a count then assign a color
    //
    for (i=0; i<GraphData->NumberOfBars; i++) {
        if (GraphData->Bar[i].Value > HighValue) {
            HighValue = GraphData->Bar[i].Value;
        }
        if (strlen(GraphData->Bar[i].Name) > LongestName) {
            LongestName = strlen(GraphData->Bar[i].Name);
        }
    }

    if (!HighValue) {
        HighValue = 1;
    }

    for (i=0,Cnt=0; i<GraphData->NumberOfBars; i++) {
        GraphData->Bar[i].Pct = (float) ((float)GraphData->Bar[i].Value / (float)HighValue);
        if (GraphData->Bar[i].Pct < .01) {
            GraphData->Bar[i].Pct = (float) .01;
        }
        if (ApiMonOptions.FilterGraphs) {
            j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
            if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                continue;
            }
        }
        if (GraphData->Bar[i].Value) {
            GraphData->Bar[i].Color = CustomColors[Cnt%NUMBER_OF_CUSTOM_COLORS];
            Cnt += 1;
        }
    }

    if (GraphData->DrawLegend) {
        //
        // next, draw the legend at the bottom of the window
        //
        SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
        SelectObject( hdc, hFont );
        GetTextMetrics( hdc, &tm );
        GetClientRect( hwndWin, &rc );
        LegendHeight = GraphData->LegendRect.bottom - GraphData->LegendRect.top;
        rc.top = rc.bottom - LegendHeight - LEGEND_LINE_HEIGHT;
        rc.bottom = rc.top + LEGEND_LINE_HEIGHT;
        GraphData->SplitRect = rc;
        GraphData->SplitRect.top += (LEGEND_LINE_HEIGHT / 2);
        GraphData->SplitRect.bottom -= ((LEGEND_LINE_HEIGHT / 2) - 1);
        DrawEdge( hdc, &rc, EDGE_RAISED, BF_TOP | BF_BOTTOM | BF_MIDDLE );
        SendMessage( hwndLegend, WM_SETREDRAW, FALSE, 0 );
        SendMessage( hwndLegend, LB_RESETCONTENT, 0, 0 );
        for (i=0,j=0; i<GraphData->NumberOfBars; i++) {
            if (ApiMonOptions.FilterGraphs) {
                j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
                if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                    continue;
                }
            }
            if (GraphData->Bar[i].Value) {
                SendMessage( hwndLegend, LB_ADDSTRING, 0, (LPARAM) &GraphData->Bar[i] );
            }
        }
        SendMessage( hwndLegend, WM_SETREDRAW, TRUE, 0 );
        LegendHeight += (LEGEND_LINE_HEIGHT + BAR_SEP);
    }

    //
    // now draw the bars
    //

    GetClientRect( hwndWin, &rc );
    rc.bottom -= LegendHeight;
    rc.top += BAR_SEP;

    ULONG BarWidth = (rc.right - rc.left - BAR_SEP - (Cnt * BAR_SEP)) / Cnt;
    ULONG BarLeft = rc.left + BAR_SEP;
    ULONG BarTop = 0;
    ULONG BarBottom = rc.bottom - BAR_SEP;


    for (i=0; i<GraphData->NumberOfBars; i++) {
        if (!GraphData->Bar[i].Value) {
            continue;
        }

        if (ApiMonOptions.FilterGraphs) {
            j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
            if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                continue;
            }
        }

        BarTop = (ULONG) (GraphData->Bar[i].Pct * (float)(BarBottom-BAR_SEP));
        BarTop = BarBottom - BarTop;

        SetRect(
            &GraphData->Bar[i].Rect,
            BarLeft,
            BarTop,
            BarLeft + BarWidth,
            BarBottom
            );

        hBrush = CreateSolidBrush( GraphData->Bar[i].Color );
        if (hBrush) {
            SelectObject( hdc, hBrush );

            Rectangle(
                hdc,
                BarLeft,
                BarTop,
                BarLeft + BarWidth,
                BarBottom
                );

            DeleteObject( hBrush );
        }

        BarLeft += (BarWidth + BAR_SEP);

    }

    EndPaint( hwndWin, &ps );

    return TRUE;
}


void
GraphWindow::ChangeToolTipsRect(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_NEWTOOLRECT, 0, (LPARAM) &ti );
    }
}


void
GraphWindow::CreateToolTips(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_ADDTOOL, 0, (LPARAM) &ti );
    }
}


void
GraphWindow::DeleteToolTips(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_DELTOOL, 0, (LPARAM) &ti );
    }
}


BOOL CALLBACK
ChildWindowEnumerator(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    PFONT_COLOR_CHANGE FontColor = (PFONT_COLOR_CHANGE) lParam;
    CHAR ClassName[64];
    if (hwnd == FontColor->hwndGraph) {
        return TRUE;
    }
    if (!GetClassName( hwnd, ClassName, sizeof(ClassName)-1 )) {
        return TRUE;
    }
    if (strcmp(ClassName, "ApiMonGraph") == 0) {
        if (FontColor->GraphFont) {
            SendMessage(
                hwnd,
                WM_FONT_CHANGE,
                1,
                (LPARAM) FontColor->GraphFont
                );
        } else {
            SendMessage(
                hwnd,
                WM_COLOR_CHANGE,
                1,
                (LPARAM) FontColor->GraphColor
                );
        }
    }

    return TRUE;
}

LRESULT CALLBACK
MDIChildWndProcGraph(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    GraphWindow         *gw = (GraphWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );
    PGRAPH_VALUE        Bar;
    ULONG               i;
    BOOL                IsInRect;
    POINT               pt;
    MSG                 msg;
    LPMEASUREITEMSTRUCT mis;
    LPDRAWITEMSTRUCT    dis;
    HDC                 hdc;
    RECT                rc;
    HBRUSH              hBrush;
    CHAR                buf[1024];
    CHAR                tmp1[32];
    CHAR                tmp2[32];
    int                 hdcSave;
    FONT_COLOR_CHANGE   FontColor;
    double              dTime;


    switch (uMessage) {
        case WM_CREATE:
            gw = (GraphWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) gw );
            if (gw->Base) {
                ReallyDisableToolbarState(IDM_GRAPH);
            }
            gw->hCursor = gw->ArrowCursor;
            hdc = GetDC( hwnd );
            if (!hdc)
                return 1;
            SelectObject( hdc, gw->hFont );
            GetTextMetrics( hdc, &gw->tm );
            ReleaseDC( hwnd, hdc );
            gw->hwndToolTip = CreateWindow(
                TOOLTIPS_CLASS,
                NULL,
                TTS_ALWAYSTIP,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                hwnd,
                NULL,
                gw->hInstance,
                NULL
                );
            PostMessage( hwnd, WM_CREATE_GRAPH, 0, 0 );
            break;

        case WM_CREATE_GRAPH:
            if (gw->ApiGraph) {
                gw->GraphData = gw->CreateGraphDataApi( gw->Bar->Address );
                SetWindowText( hwnd, gw->Bar->Name );
            } else {
                gw->GraphData = gw->CreateGraphData();
                SetWindowText( hwnd, ApiMonOptions.ProgName );
            }
            if (gw->GraphData) {
                gw->GraphData->DrawLegend = ApiMonOptions.DisplayLegends;
                GetClientRect( hwnd, &rc );
                gw->GraphData->LegendRect.left   = rc.left;
                gw->GraphData->LegendRect.top    = rc.bottom - LEGEND_HEIGHT(gw->tm.tmHeight,LEGEND_DEFAULT_LINES);
                gw->GraphData->LegendRect.right  = rc.right;
                gw->GraphData->LegendRect.bottom = rc.bottom;
                gw->CreateToolTips( gw->GraphData );
            }
            return 0;

        case WM_SIZE:
            if (gw->GraphData) {
                GetClientRect( hwnd, &rc );
                gw->GraphData->LegendRect.top     = rc.bottom -
                    (gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top);
                gw->GraphData->LegendRect.left    = rc.left;
                gw->GraphData->LegendRect.bottom  = rc.bottom;
                gw->GraphData->LegendRect.right   = rc.right;
                MoveWindow(
                    gw->hwndLegend,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    TRUE
                    );
                InvalidateRect( hwnd, NULL, TRUE );
                UpdateWindow( hwnd );
            }
            return 0;

        case WM_SETFOCUS:
            ChildFocus = CHILD_GRAPH;
            break;

        case WM_KILLFOCUS:
            break;

        case WM_PAINT:
            if ((!gw->GraphData->DrawLegend) && gw->hwndLegend) {
                DestroyWindow( gw->hwndLegend );
                gw->hwndLegend = NULL;
            } else if (gw->GraphData->DrawLegend && (!gw->hwndLegend)) {
                gw->hwndLegend = CreateWindow(
                    "LISTBOX",
                    NULL,
                    WS_VSCROLL                 |
                        WS_HSCROLL             |
                        WS_CHILD               |
                        WS_VISIBLE             |
                        LBS_NOSEL              |
                        LBS_NOINTEGRALHEIGHT   |
                        LBS_OWNERDRAWFIXED,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    hwnd,
                    NULL,
                    GetModuleHandle( NULL ),
                    NULL
                    );
            }
            gw->DrawBarGraph( gw->GraphData );
            if (gw->hwndToolTip) {
                gw->ChangeToolTipsRect( gw->GraphData );
            }
            return 0;

        case WM_FONT_CHANGE:
            gw->hFont = (HFONT) lParam;
            hdc = GetDC( hwnd );
            if (!hdc)
                return 1;
            SelectObject( hdc, gw->hFont );
            GetTextMetrics( hdc, &gw->tm );
            ReleaseDC( hwnd, hdc );
            SendMessage( gw->hwndLegend, LB_SETITEMHEIGHT, 0, MAKELPARAM( LEGEND_ITEM_HEIGHT(gw->tm.tmHeight), 0 ) );
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            if (!wParam && !gw->ApiGraph) {
                FontColor.GraphFont = gw->hFont;
                FontColor.GraphColor = 0;
                FontColor.hwndGraph = hwnd;
                EnumChildWindows( hwndMDIClient, ChildWindowEnumerator, (LPARAM) &FontColor );
            }
            return 0;

        case WM_COLOR_CHANGE:
            gw->Color = (COLORREF) lParam;
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            if (!wParam && !gw->ApiGraph) {
                FontColor.GraphColor = gw->Color;
                FontColor.GraphFont = NULL;
                FontColor.hwndGraph = hwnd;
                EnumChildWindows( hwndMDIClient, ChildWindowEnumerator, (LPARAM) &FontColor );
            }
            return 0;

        case WM_TOGGLE_LEGEND:
            if (gw->GraphData->DrawLegend) {
                gw->GraphData->DrawLegend = FALSE;
            } else {
                gw->GraphData->DrawLegend = TRUE;
            }
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            return 0;

        case WM_CTLCOLORLISTBOX:
            if ((HWND)lParam == gw->hwndLegend) {
                SetBkColor( (HDC)wParam, gw->Color );
                return (LPARAM)CreateSolidBrush( gw->Color );
            }
            break;

        case WM_MOUSEMOVE:
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            IsInRect = FALSE;
            if (gw->MouseDown) {
                //
                // the slider bar is being dragged
                //
                if (!(wParam & MK_LBUTTON)) {
                    gw->MouseDown = FALSE;
                    ReleaseCapture();
                    return 0;
                }

                if (pt.y < gw->GraphData->SplitRect.top) {
                    //
                    // going up
                    //
                    gw->GraphData->LegendRect.top += (pt.y - gw->LastPos.y);
                } else if (pt.y > gw->GraphData->SplitRect.bottom) {
                    //
                    // going down
                    //
                    gw->GraphData->LegendRect.top -= (gw->LastPos.y - pt.y);
                }
                MoveWindow(
                    gw->hwndLegend,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    TRUE
                    );
                IsInRect = TRUE;
                InvalidateRect( hwnd, NULL, TRUE );
                UpdateWindow( hwnd );
            } else {
                for (i=0; i<gw->GraphData->NumberOfBars; i++) {
                    if (gw->GraphData->Bar[i].Value) {
                        if (PtInRect( &gw->GraphData->Bar[i].Rect, pt )) {
                            gw->hCursor = gw->GraphCursor;
                            IsInRect = TRUE;
                            break;
                        }
                    }
                }
            }
            if (!IsInRect) {
                gw->hCursor = gw->ArrowCursor;
            }
            if (PtInRect( &gw->GraphData->SplitRect, pt )) {
                gw->hCursor = gw->HorizSplitCursor;
                IsInRect = TRUE;
            }
            SetCursor( gw->hCursor );
            msg.hwnd     = hwnd;
            msg.message  = uMessage;
            msg.wParam   = wParam;
            msg.lParam   = lParam;
            msg.time     = 0;
            msg.pt.x     = 0;
            msg.pt.y     = 0;
            SendMessage( gw->hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg );
            gw->LastPos = pt;
            return 0;

        case WM_LBUTTONDOWN:
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (PtInRect( &gw->GraphData->SplitRect, pt )) {
                gw->MouseDown = TRUE;
                SetCapture( hwnd );
            }
            return 0;

        case WM_LBUTTONUP:
            gw->MouseDown = FALSE;
            ReleaseCapture();
            return 0;

        case WM_LBUTTONDBLCLK:
            if (gw->ApiGraph) {
                MessageBeep( MB_ICONEXCLAMATION );
                return 0;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            for (i=0; i<gw->GraphData->NumberOfBars; i++) {
                if (gw->GraphData->Bar[i].Value) {
                    if (PtInRect( &gw->GraphData->Bar[i].Rect, pt )) {
                        if (gw->GraphData->Bar[i].Used) {
                            MessageBeep( MB_ICONEXCLAMATION );
                            break;
                        }
                        GraphWindow *agw = new GraphWindow;
                        agw->ApiGraph = TRUE;
                        agw->Bar = &gw->GraphData->Bar[i];
                        agw->Create( FALSE );
                        agw->ChangeFont( gw->hFont );
                        agw->ChangeColor( gw->Color );
                        gw->GraphData->Bar[i].Used = TRUE;
                        break;
                    }
                }
            }
            return 0;

        case WM_MEASUREITEM:
            mis = (LPMEASUREITEMSTRUCT) lParam;
            mis->CtlType      = ODT_LISTBOX;
            mis->CtlID        = 0;
            mis->itemID       = 0;
            mis->itemWidth    = 0;
            mis->itemHeight   = LEGEND_ITEM_HEIGHT(gw->tm.tmHeight);
            mis->itemData     = 0;
            return 0;

        case WM_DRAWITEM:
            dis = (LPDRAWITEMSTRUCT) lParam;
            Bar = (PGRAPH_VALUE) dis->itemData;
            hdcSave = SaveDC( dis->hDC );
            SelectObject( dis->hDC, gw->hFont );
            hBrush = CreateSolidBrush( Bar->Color );
            if (!hBrush)
                return 1;
            SelectObject( dis->hDC, hBrush );
            Rectangle(
                dis->hDC,
                dis->rcItem.left+LEGEND_BORDER,
                dis->rcItem.top+LEGEND_SEP,
                dis->rcItem.left+LEGEND_COLOR_WIDTH,
                dis->rcItem.top+gw->tm.tmHeight
                );
            DeleteObject( hBrush );
            sprintf( tmp1, "Hits(%d)", Bar->Hits );

            dTime = (double)Bar->Value;
            if (!*FastCounterAvail)
                dTime *= MSecConv;
            sprintf( tmp2, "Time(%.4f)", dTime );

            sprintf( buf, "%-16s  %-12s %-24s", Bar->Name, tmp1, tmp2 );
            TextOut( dis->hDC, dis->rcItem.left+LEGEND_COLOR_WIDTH+LEGEND_BORDER, dis->rcItem.top, buf, strlen(buf) );
            RestoreDC( dis->hDC, hdcSave );
            return 0;

        case WM_DESTROY:
            if (gw->Bar) {
                gw->Bar->Used = FALSE;
            }
            if (gw->Base) {
                EnableToolbarState(IDM_GRAPH);
            }
            gw->DeleteToolTips( gw->GraphData );
            DeleteObject( gw->ArrowCursor );
            DeleteObject( gw->GraphCursor );
            DeleteObject( gw->HorizSplitCursor );
            DestroyWindow( gw->hwndToolTip );
            DestroyWindow( gw->hwndLegend );
            LocalFree( gw->GraphData );
            gw->ArrowCursor       = NULL;
            gw->GraphCursor       = NULL;
            gw->HorizSplitCursor  = NULL;
            gw->hwndToolTip       = NULL;
            gw->hwndLegend        = NULL;
            gw->GraphData         = NULL;
            gw->Bar               = NULL;
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\help.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    help.cpp

Abstract:

    All user interface code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


extern HWND     hwndFrame;
extern BOOL     InMenu;
extern DWORD    MenuId;
extern CHAR     HelpFileName[];


typedef struct _HELP_IDS {
    DWORD   Context;
    DWORD   HelpId;
} HELP_IDS, *PHELP_IDS;

HELP_IDS HelpTable[] =
    {
    IDC_LOG_FILE_NAME,              IDH_LOG_FILE_NAME,
    IDC_TRACE_FILE_NAME,            IDH_TRACE_FILE_NAME,
    IDC_ENABLE_TRACING,             IDH_ENABLE_TRACING,
    IDC_SYMBOL_PATH,                IDH_SYMBOL_PATH,
    IDC_DISABLE_HEAP,               IDH_DISABLE_HEAP,
    IDC_PRELOAD_SYMBOLS,            IDH_PRELOAD_SYMBOLS,
    IDC_ENABLE_COUNTERS,            IDH_ENABLE_COUNTERS,
    IDC_GO_IMMEDIATE,               IDH_GO_IMMEDIATE,
    IDC_DISABLE_FAST_COUNTERS,      IDH_DISABLE_FAST_COUNTERS,
    IDC_DEFSORT_NAME,               IDH_DEFSORT_NAME,
    IDC_DEFSORT_COUNTER,            IDH_DEFSORT_COUNTER,
    IDC_DEFSORT_TIME,               IDH_DEFSORT_TIME,
    IDC_USE_KNOWN_DLLS,             IDH_USE_KNOWN_DLLS,
    IDC_EXCLUDE_KNOWN_DLLS,         IDH_EXCLUDE_KNOWN_DLLS,
    IDC_KNOWN_DLLS,                 IDH_KNOWN_DLLS,
    IDC_PAGE_FAULTS,                IDH_PAGE_FAULTS,
    IDM_EXIT,                       IDH_EXIT,
    IDM_WINDOWTILE,                 IDH_WINDOWTILE,
    IDM_WINDOWCASCADE,              IDH_WINDOWCASCADE,
    IDM_WINDOWICONS,                IDH_WINDOWICONS,
    IDM_ABOUT,                      IDH_ABOUT,
    IDM_STATUSBAR,                  IDH_STATUSBAR,
    IDM_START,                      IDH_START,
    IDM_STOP,                       IDH_STOP,
    IDM_TOOLBAR,                    IDH_TOOLBAR,
    IDM_OPTIONS,                    IDH_OPTIONS,
    IDM_SAVE_OPTIONS,               IDH_SAVE_OPTIONS,
    IDM_FILEOPEN,                   IDH_FILEOPEN,
    IDM_WRITE_LOG,                  IDH_WRITE_LOG,
    IDM_FONT,                       IDH_FONT,
    IDM_COLOR,                      IDH_COLOR,
    IDM_NEW_DLL,                    IDH_NEW_DLL,
    IDM_NEW_COUNTER,                IDH_NEW_COUNTER,
    IDM_CLEAR_COUNTERS,             IDH_CLEAR_COUNTERS,
    IDM_NEW_PAGE,                   IDH_NEW_PAGE,
    IDM_WINDOWTILE_HORIZ,           IDH_WINDOWTILE_HORIZ
    };

#define MAX_HELP_IDS (sizeof(HelpTable)/sizeof(HELP_IDS))


DWORD __inline
GetHelpId(
    DWORD Context
    )
{
    for (DWORD i=0; i<MAX_HELP_IDS; i++) {
        if (HelpTable[i].Context == Context) {
            return HelpTable[i].HelpId;
        }
    }
    return 0;
}

VOID
ProcessHelpRequest(
    HWND hwnd,
    INT  DlgCtrl
    )
{
    DWORD HelpId = 0;
    DWORD HelpType = HELP_CONTEXT;
    if (DlgCtrl) {
        HelpId = GetHelpId( DlgCtrl );
    } else if (hwnd == hwndFrame) {
        if (InMenu && MenuId) {
            HelpId = GetHelpId( MenuId );
        } else {
            HelpType = HELP_CONTENTS;
        }
    } else {
        HelpId = GetWindowContextHelpId( hwnd );
    }

    if (!HelpId) {
        HelpType = HELP_CONTENTS;
    }

    if (!WinHelp( hwnd, HelpFileName, HelpType, HelpId )) {
        PopUpMsg( "Could not start WinHelp" );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\ntheap.c ===
#pragma warning(4:4005)

#include <nt.h>
#include <ntrtl.h>
//#include <ntrtlp.h>
#undef LOBYTE
#undef HIBYTE
#include <nturtl.h>
//#include <heap.h>
#include <windows.h>

typedef __int64 LONGLONG;
typedef unsigned __int64 DWORDLONG;

#include "apimonp.h"

extern CLINKAGE BOOL RunningOnNT;


typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG,PULONG);
typedef NTSTATUS (NTAPI *PNTSETINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG);

PNTQUERYINFORMATIONPROCESS  pNtQueryInformationProcess;
PNTSETINFORMATIONPROCESS    pNtSetInformationProcess;


CLINKAGE VOID
DisableHeapChecking(
    HANDLE  hProcess,
    PVOID   HeapHandle
    )
{
#if 0

    the heap package should export an entrypoint to disable heap checking globally in a process\
    until that happens, this functionality is just plain disabled. The heap structures are not accessible
    outside of the base project


    HEAP Heap;


    if (!RunningOnNT) {
        return;
    }

    if (!ReadMemory( hProcess, HeapHandle, &Heap, sizeof(HEAP) )) {
        return;
    }

    if (Heap.Signature != HEAP_SIGNATURE) {
        return;
    }

    Heap.Flags &= ~(HEAP_VALIDATE_PARAMETERS_ENABLED |
                    HEAP_VALIDATE_ALL_ENABLED        |
                    HEAP_TAIL_CHECKING_ENABLED       |
                    HEAP_FREE_CHECKING_ENABLED
                   );

    if (!WriteMemory( hProcess, HeapHandle, &Heap, sizeof(HEAP) )) {
        return;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\optdlgs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    optdlgs.cpp

Abstract:

    All user interface code for the options proprty sheet dialogs.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


BOOL
ValidateFileName(
    HWND    hdlg,
    UINT    id
    )
{
    CHAR buf[MAX_PATH*2];
    CHAR buf2[MAX_PATH*2];
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR Fname[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];



    GetDlgItemText( hdlg, id, buf, sizeof(buf) );
    ExpandEnvironmentStrings( buf, buf2, sizeof(buf2) );
    _splitpath( buf2, Drive, Dir, Fname, Ext );
    strcpy( buf, Drive );
    strcat( buf, Dir );
    if (GetFileAttributes( buf ) == 0xffffffff) {
        return FALSE;
    }
    return TRUE;
}


BOOL
ValidatePathName(
    HWND    hdlg,
    UINT    id
    )
{
    CHAR buf[MAX_PATH*10];
    CHAR buf2[MAX_PATH*10];
    LPSTR p,p1;


    GetDlgItemText( hdlg, id, buf, sizeof(buf) );
    ExpandEnvironmentStrings( buf, buf2, sizeof(buf2) );
    p = buf2;
    while( p && *p ) {
        p1 = strchr( p, ';' );
        if (p1 ) {
            *p1 = 0;
        }
        if (GetFileAttributes( p ) == 0xffffffff) {
            return FALSE;
        }
        p += strlen(p);
        if (p1 ) {
            *p1 = ';';
            p += 1;
        }
    }
    return TRUE;
}

INT_PTR
CALLBACK
FileNamesDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static BOOL IgnoreChange = FALSE;

    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == EN_CHANGE && (!IgnoreChange)) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    IgnoreChange = TRUE;
                    SetDlgItemText( hdlg, IDC_LOG_FILE_NAME,   ApiMonOptions.LogFileName   );
                    SetDlgItemText( hdlg, IDC_TRACE_FILE_NAME, ApiMonOptions.TraceFileName );
                    SetDlgItemText( hdlg, IDC_SYMBOL_PATH,     ApiMonOptions.SymbolPath    );
                    IgnoreChange = FALSE;
                    break;

                case PSN_KILLACTIVE:
                    {
                        DWORD rslt = 0;
                        if (!ValidateFileName( hdlg, IDC_LOG_FILE_NAME )) {
                            PopUpMsg( "Invalid log file name" );
                            rslt = 1;
                        }
                        if (!ValidateFileName( hdlg, IDC_TRACE_FILE_NAME )) {
                            PopUpMsg( "Invalid trace file name" );
                            rslt = 1;
                        }
                        if (!ValidatePathName( hdlg, IDC_SYMBOL_PATH )) {
                            PopUpMsg( "Invalid symbol path" );
                            rslt = 1;
                        }
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, rslt );
                    }
                    break;

                case PSN_APPLY:
                    GetDlgItemText( hdlg, IDC_LOG_FILE_NAME,   ApiMonOptions.LogFileName,   sizeof(ApiMonOptions.LogFileName)   );
                    GetDlgItemText( hdlg, IDC_TRACE_FILE_NAME, ApiMonOptions.TraceFileName, sizeof(ApiMonOptions.TraceFileName) );
                    GetDlgItemText( hdlg, IDC_SYMBOL_PATH,     ApiMonOptions.SymbolPath,    sizeof(ApiMonOptions.SymbolPath)    );
                    SaveOptions();
                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
MiscDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    CheckDlgButton( hdlg, IDC_ENABLE_TRACING,        ApiMonOptions.Tracing                      );
                    CheckDlgButton( hdlg, IDC_ENABLE_ALIASING,       ApiMonOptions.Aliasing                     );
                    CheckDlgButton( hdlg, IDC_DISABLE_HEAP,          ApiMonOptions.HeapChecking                 );
                    CheckDlgButton( hdlg, IDC_PRELOAD_SYMBOLS,       ApiMonOptions.PreLoadSymbols               );
                    CheckDlgButton( hdlg, IDC_ENABLE_COUNTERS,       ApiMonOptions.ApiCounters                  );
                    CheckDlgButton( hdlg, IDC_GO_IMMEDIATE,          ApiMonOptions.GoImmediate                  );
                    CheckDlgButton( hdlg, IDC_DISABLE_FAST_COUNTERS, ApiMonOptions.FastCounters                 );
                    CheckDlgButton( hdlg, IDC_USE_KNOWN_DLLS,        ApiMonOptions.UseKnownDlls                 );
                    CheckDlgButton( hdlg, IDC_EXCLUDE_KNOWN_DLLS,    ApiMonOptions.ExcludeKnownDlls             );
                    CheckDlgButton( hdlg, IDC_PAGE_FAULTS,           ApiMonOptions.MonitorPageFaults            );
                    CheckDlgButton( hdlg, IDC_AUTO_REFRESH,          ApiMonOptions.AutoRefresh            );
                    CheckDlgButton( hdlg, IDC_DEFSORT_NAME,          ApiMonOptions.DefaultSort == SortByName    );
                    CheckDlgButton( hdlg, IDC_DEFSORT_COUNTER,       ApiMonOptions.DefaultSort == SortByCounter );
                    CheckDlgButton( hdlg, IDC_DEFSORT_TIME,          ApiMonOptions.DefaultSort == SortByTime    );
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    ApiMonOptions.Tracing           = IsDlgButtonChecked( hdlg, IDC_ENABLE_TRACING        );
                    ApiMonOptions.Aliasing          = IsDlgButtonChecked( hdlg, IDC_ENABLE_ALIASING       );
                    ApiMonOptions.HeapChecking      = IsDlgButtonChecked( hdlg, IDC_DISABLE_HEAP          );
                    ApiMonOptions.PreLoadSymbols    = IsDlgButtonChecked( hdlg, IDC_PRELOAD_SYMBOLS       );
                    ApiMonOptions.ApiCounters       = IsDlgButtonChecked( hdlg, IDC_ENABLE_COUNTERS       );
                    ApiMonOptions.GoImmediate       = IsDlgButtonChecked( hdlg, IDC_GO_IMMEDIATE          );
                    ApiMonOptions.FastCounters      = IsDlgButtonChecked( hdlg, IDC_DISABLE_FAST_COUNTERS );
                    ApiMonOptions.UseKnownDlls      = IsDlgButtonChecked( hdlg, IDC_USE_KNOWN_DLLS        );
                    ApiMonOptions.ExcludeKnownDlls  = IsDlgButtonChecked( hdlg, IDC_EXCLUDE_KNOWN_DLLS    );
                    ApiMonOptions.MonitorPageFaults = IsDlgButtonChecked( hdlg, IDC_PAGE_FAULTS           );
                    ApiMonOptions.AutoRefresh       = IsDlgButtonChecked( hdlg, IDC_AUTO_REFRESH          );
                    if (ApiMonOptions.MonitorPageFaults) {
                        ApiMonOptions.PreLoadSymbols = TRUE;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_NAME )) {
                        ApiMonOptions.DefaultSort = SortByName;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_COUNTER )) {
                        ApiMonOptions.DefaultSort = SortByCounter;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_TIME )) {
                        ApiMonOptions.DefaultSort = SortByTime;
                    }
                    SaveOptions();

                    *ApiTraceEnabled = ApiMonOptions.Tracing || (KnownApis[0] != 0);

                    if (ApiMonOptions.FastCounters) {
                        *FastCounterAvail = FALSE;
                    } else {
                        SYSTEM_INFO SystemInfo;
                        GetSystemInfo( &SystemInfo );
                        *FastCounterAvail = (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM &&
                                            SystemInfo.dwNumberOfProcessors == 1);
                    }

                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
KnownDllsDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HWND hwndDlls;

    switch (uMessage) {
        case WM_INITDIALOG:
            {
                hwndDlls = GetDlgItem( hdlg, IDC_KNOWN_DLLS );
                SetWindowContextHelpId( hwndDlls, IDH_DLLS_OPTIONS );
                CenterWindow( GetParent( hdlg ), hwndFrame );
                //
                // set/initialize the image list(s)
                //
                HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );
                ImageList_AddMasked(
                    himlState,
                    LoadBitmap (GetModuleHandle(NULL),MAKEINTRESOURCE(IDB_CHECKSTATES)),
                    RGB (255,0,0)
                    );
                ListView_SetImageList( hwndDlls, himlState, LVSIL_STATE );
                //
                // set/initialize the columns
                //
                LV_COLUMN lvc = {0};
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.pszText = "DLL Name";
                lvc.iSubItem = 0;
                lvc.cx = 260;
                lvc.fmt = LVCFMT_LEFT;
                ListView_InsertColumn( hwndDlls, 0, &lvc );
            }
            // Fall into refresh case for initial list loading

        case WM_REFRESH_LIST:
            {
                LPSTR p = ApiMonOptions.KnownDlls;
                LV_ITEM lvi = {0};
                int iItem = 0;

                ListView_DeleteAllItems( hwndDlls );

                while( p && *p ) {
                    lvi.pszText = p;
                    lvi.iItem = iItem;
                    iItem += 1;
                    lvi.iSubItem = 0;
                    lvi.iImage = 0;
                    lvi.mask = LVIF_TEXT;
                    lvi.state = 0;
                    lvi.stateMask = 0;
                    ListView_InsertItem( hwndDlls, &lvi );
                    p += (strlen(p) + 1);
                }
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    SaveOptions();
                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case NM_CLICK:
                    {
                        DWORD dwpos = GetMessagePos();
                        LV_HITTESTINFO lvhti = {0};
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);
                        MapWindowPoints( HWND_DESKTOP, hwndDlls, &lvhti.pt, 1 );
                        int iItemClicked = ListView_HitTest( hwndDlls, &lvhti );
                        if (iItemClicked == -1) {
                            //
                            // add a new item
                            //
                            LV_ITEM lvi = {0};
                            lvi.pszText = "";
                            lvi.iItem = ListView_GetItemCount( hwndDlls );
                            lvi.iSubItem = 0;
                            lvi.iImage = 0;
                            lvi.mask = LVIF_TEXT;
                            lvi.state = 0;
                            lvi.stateMask = 0;
                            iItemClicked = ListView_InsertItem( hwndDlls, &lvi );
                        }
                        ListView_EditLabel( hwndDlls, iItemClicked );
                    }
                    break;

                case LVN_ENDLABELEDIT:
                    {
                        LPSTR nk;
                        LPSTR p1;
                        LV_DISPINFO *DispInfo = (LV_DISPINFO*)lParam;
                        LPSTR p = ApiMonOptions.KnownDlls;
                        ULONG i = 0;

                        if (DispInfo->item.pszText == NULL || DispInfo->item.iItem == -1)
                            break;

                        nk = (LPSTR) MemAlloc( 2048 );
                        if (!nk) {
                            break;
                        }
                        p1 = nk;

                        while( i != (ULONG)DispInfo->item.iItem ) {
                            strcpy( p1, p );
                            p1 += (strlen(p) + 1);
                            p  += (strlen(p) + 1);
                            i += 1;
                        }
                        p  += (strlen(p) + 1);
                        if (DispInfo->item.pszText[0]) {
                            strcpy( p1, DispInfo->item.pszText );
                            p1 += (strlen(DispInfo->item.pszText) + 1);
                        }
                        while( p && *p ) {
                            strcpy( p1, p );
                            p1 += (strlen(p) + 1);
                            p  += (strlen(p) + 1);
                        }
                        *p1 = 0;
                        memcpy( ApiMonOptions.KnownDlls, nk, 2048 );
                        MemFree( nk );
                        PostMessage( hdlg, WM_REFRESH_LIST, 0, 0 );
                    }
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
GraphDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    CHAR buf[64];
    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;


        case WM_HSCROLL:
            if ((HWND)lParam != GetDlgItem( hdlg, IDC_FILTER_SLIDER)) {
                return FALSE;
            }
            dprintf( "%d %d\n", LOWORD(wParam), HIWORD(wParam) );
            switch( LOWORD(wParam) ) {
                case TB_BOTTOM:
                    ApiMonOptions.GraphFilterValue = 100;
                    break;

                case TB_ENDTRACK:
                    break;

                case TB_LINEDOWN:
                    ApiMonOptions.GraphFilterValue += 1;
                    break;

                case TB_LINEUP:
                    ApiMonOptions.GraphFilterValue -= 1;
                    break;

                case TB_PAGEDOWN:
                    ApiMonOptions.GraphFilterValue += 10;
                    break;

                case TB_PAGEUP:
                    ApiMonOptions.GraphFilterValue -= 10;
                    break;

                case TB_THUMBPOSITION:
                    break;

                case TB_THUMBTRACK:
                    ApiMonOptions.GraphFilterValue = HIWORD(wParam);
                    break;

                case TB_TOP:
                    ApiMonOptions.GraphFilterValue = 1;
                    break;
            }
            if (ApiMonOptions.GraphFilterValue < 1) {
                MessageBeep( MB_ICONEXCLAMATION );
                ApiMonOptions.GraphFilterValue = 1;
            }
            if (ApiMonOptions.GraphFilterValue > 100) {
                MessageBeep( MB_ICONEXCLAMATION );
                ApiMonOptions.GraphFilterValue = 100;
            }
            _itoa( ApiMonOptions.GraphFilterValue, buf, 10 );
            SetDlgItemText( hdlg, IDC_FILTER_NUMBER, buf );
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETTICFREQ, 10, 1 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETRANGE, TRUE, (LPARAM) MAKELONG(1,100) );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETPAGESIZE, 0, 10 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETLINESIZE, 0, 1 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETTHUMBLENGTH, 3, 0 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETPOS, TRUE, ApiMonOptions.GraphFilterValue );
                    _itoa( ApiMonOptions.GraphFilterValue, buf, 10 );
                    SetDlgItemText( hdlg, IDC_FILTER_NUMBER, buf );
                    CheckDlgButton( hdlg, IDC_DISPLAY_LEGENDS, ApiMonOptions.DisplayLegends );
                    CheckDlgButton( hdlg, IDC_FILTER_BAR, ApiMonOptions.FilterGraphs );

                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    ApiMonOptions.DisplayLegends = IsDlgButtonChecked( hdlg, IDC_DISPLAY_LEGENDS  );
                    ApiMonOptions.FilterGraphs   = IsDlgButtonChecked( hdlg, IDC_FILTER_BAR       );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

BOOL
CreateOptionsPropertySheet(
    HINSTANCE   hInstance,
    HWND        hwnd
    )
{
    PROPSHEETPAGE   psp[4];
    PROPSHEETHEADER psh;


    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[0].hInstance   = hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_MISC);
    psp[0].pszIcon     = NULL;
    psp[0].pfnDlgProc  = MiscDialogProc;
    psp[0].pszTitle    = "Miscellaneous Options";
    psp[0].lParam      = 0;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[1].hInstance   = hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_FILE_NAMES);
    psp[1].pszIcon     = NULL;
    psp[1].pfnDlgProc  = FileNamesDialogProc;
    psp[1].pszTitle    = "File Names";
    psp[1].lParam      = 0;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[2].hInstance   = hInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_KNOWN_DLLS);
    psp[2].pszIcon     = NULL;
    psp[2].pfnDlgProc  = KnownDllsDialogProc;
    psp[2].pszTitle    = "Known DLLs";
    psp[2].lParam      = 0;

    psp[3].dwSize      = sizeof(PROPSHEETPAGE);
    psp[3].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[3].hInstance   = hInstance;
    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_GRAPH);
    psp[3].pszIcon     = NULL;
    psp[3].pfnDlgProc  = GraphDialogProc;
    psp[3].pszTitle    = "Graphing";
    psp[3].lParam      = 0;

    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.hwndParent     = hwnd;
    psh.hInstance      = hInstance;
    psh.pszIcon        = "";
    psh.pszCaption     = (LPSTR)"ApiMon Options";
    psh.nPages         = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp           = (LPCPROPSHEETPAGE) psp;
    psh.nStartPage     = 0;

    INT_PTR stat = PropertySheet(&psh);

    if (stat > 0) {
        SaveOptions();
        return TRUE;
    }
    else if (stat < 0)
    {
        DWORD dwErr = GetLastError();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\pageflt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pageflt.cpp

Abstract:

    All user interface code for the page fault monitor window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


int __cdecl
PageHardCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->HardFault < p1->HardFault) {
            return -1;
        } else if (p2->HardFault == p1->HardFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageSoftCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->SoftFault < p1->SoftFault) {
            return -1;
        } else if (p2->SoftFault == p1->SoftFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageCodeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->CodeFault < p1->CodeFault) {
            return -1;
        } else if (p2->CodeFault == p1->CodeFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageDataCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->DataFault < p1->DataFault) {
            return -1;
        } else if (p2->DataFault == p1->DataFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageNameCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( (LPSTR)(p1->Name+(LPSTR)MemPtr), (LPSTR)(p2->Name+(LPSTR)MemPtr) );
    } else {
        return 1;
    }
}

PageFaultWindow::PageFaultWindow()
{
}


PageFaultWindow::~PageFaultWindow()
{
}


BOOL
PageFaultWindow::Create()
{
    if ((!ApiMonOptions.MonitorPageFaults) || (!pGetWsChanges)) {
        return FALSE;
    }

    SortRoutine = PageSoftCompare;

    return ApiMonWindow::Create(
        "ApiMonPage",
        "Page Faults"
        );
}


BOOL
PageFaultWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonPage",
        IDI_CHILDICON,
        MDIChildWndProcPage
        );
}


BOOL
PageFaultWindow::Update(
    BOOL    ForceUpdate
    )
{
    PAPI_INFO           PcSymbol;
    PAPI_INFO           VaSymbol;
    ULONG_PTR           Pc;
    ULONG_PTR           Va;
    ULONG               i,j,k;
    ULONG_PTR           Offset;

    if ((!hwndList) || (!ApiMonOptions.MonitorPageFaults) || (!pGetWsChanges)) {
        return FALSE;
    }

    if (!pGetWsChanges( hProcessWs, &WorkingSetBuffer[0], sizeof(WorkingSetBuffer ))) {
        return FALSE;
    }

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );

    ListView_DeleteAllItems( hwndList );

    for (i=0; i<WORKING_SET_BUFFER_ENTRYS; i++) {

        if ((!WorkingSetBuffer[i].FaultingPc) ||
            (!WorkingSetBuffer[i].FaultingVa)) {
            continue;
        }

        Pc = (ULONG_PTR)WorkingSetBuffer[i].FaultingPc;
        Va = (ULONG_PTR)WorkingSetBuffer[i].FaultingVa;

        if (!SymGetSymFromAddr( CurrProcess, Pc, &Offset, sym )) {
            continue;
        }
        PcSymbol = GetApiForAddr( sym->Address );
        if (!PcSymbol) {
            continue;
        }

        if (!SymGetSymFromAddr( CurrProcess, Va, &Offset, sym )) {
            continue;
        }
        VaSymbol = GetApiForAddr( sym->Address );
        if (!VaSymbol) {
            continue;
        }

        if (Va & 1) {

            //
            // soft fault
            //
            if (PcSymbol) {
                PcSymbol->SoftFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->SoftFault += 1;
            }

        } else {

            //
            // hard fault
            //
            if (PcSymbol) {
                PcSymbol->HardFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->HardFault += 1;
            }

        }
        Va = Va & 0xfffffffe;
        if ((Pc & 0xfffffffe) == Va) {

            //
            // code fault
            //
            if (PcSymbol) {
                PcSymbol->CodeFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->CodeFault += 1;
            }

        } else {

            //
            // data fault
            //
            if (PcSymbol) {
                PcSymbol->DataFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->DataFault += 1;
            }

        }
    }

    PAPI_INFO ApiInfo = NULL;
    ULONG_PTR *ApiAry = NULL;
    for (i=0,k=0; i<MAX_DLLS; i++) {
        if (DllList[i].ApiCount && DllList[i].Enabled) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].SoftFault || ApiInfo[j].HardFault ||
                    ApiInfo[j].CodeFault || ApiInfo[j].DataFault) {
                    k += 1;
                }
            }
        }
    }

    if (k) {
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (ApiAry) {
            for (i=0,k=0; i<MAX_DLLS; i++) {
                if (DllList[i].ApiCount && DllList[i].Enabled) {
                    ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
                    for (j=0; j<DllList[i].ApiCount; j++) {
                        if (ApiInfo[j].SoftFault || ApiInfo[j].HardFault ||
                            ApiInfo[j].CodeFault || ApiInfo[j].DataFault) {
                            ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
                        }
                    }
                }
            }
            qsort( ApiAry, k, sizeof(ULONG_PTR), SortRoutine );
            for (i=0; i<k; i++) {
                AddItemToList(
                    (LPSTR)(((PAPI_INFO)ApiAry[i])->Name + (LPSTR)MemPtr),
                    ((PAPI_INFO)ApiAry[i])->HardFault,
                    ((PAPI_INFO)ApiAry[i])->SoftFault,
                    ((PAPI_INFO)ApiAry[i])->DataFault,
                    ((PAPI_INFO)ApiAry[i])->CodeFault
                    );
            }
            MemFree( ApiAry );
        }
    }

    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );

    return TRUE;
}


void
PageFaultWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "API Name";
    lvc.iSubItem = 0;
    lvc.cx = 204;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 0, &lvc );

    lvc.pszText = "Soft";
    lvc.iSubItem = 1;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 1, &lvc );

    lvc.pszText = "Hard";
    lvc.iSubItem = 2;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 2, &lvc );

    lvc.pszText = "Code";
    lvc.iSubItem = 3;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 3, &lvc );

    lvc.pszText = "Data";
    lvc.iSubItem = 4;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 4, &lvc );
}


void
PageFaultWindow::AddItemToList(
    LPSTR   ApiName,
    ULONG_PTR   Hard,
    ULONG_PTR   Soft,
    ULONG_PTR   Data,
    ULONG_PTR   Code
    )
{
    LV_ITEM             lvi = {0};
    CHAR                NumText[32];
    int                 iItem;

    if (!hwndList) {
        return;
    }

    lvi.pszText = ApiName;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = 0;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    if (Hard) {
        sprintf( NumText, "%5d", Hard );
    } else {
        NumText[0] = 0;
    }
    lvi.pszText = NumText;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    if (Soft) {
        sprintf( NumText, "%5d", Soft );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 2;
    ListView_SetItem( hwndList, &lvi );

    if (Data) {
        sprintf( NumText, "%5d", Data );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 3;
    ListView_SetItem( hwndList, &lvi );

    if (Code) {
        sprintf( NumText, "%5d", Code );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 4;
    ListView_SetItem( hwndList, &lvi );
}


void
PageFaultWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    if (NmHdr->code == LVN_COLUMNCLICK) {
        switch( ((LPNM_LISTVIEW)NmHdr)->iSubItem ) {
            case 0:
                //
                // sort by name
                //
                SortRoutine = PageNameCompare;
                break;

            case 1:
                //
                // sort by soft
                //
                SortRoutine = PageSoftCompare;
                break;

            case 2:
                //
                // sort by hard
                //
                SortRoutine = PageHardCompare;
                break;

            case 3:
                //
                // sort by code
                //
                SortRoutine = PageCodeCompare;
                break;

            case 4:
                //
                // sort by data
                //
                SortRoutine = PageDataCompare;
                break;
        }
        PostMessage( hwndFrame, WM_UPDATE_PAGE, 0, 0 );
    }
}



LRESULT CALLBACK
MDIChildWndProcPage(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    PageFaultWindow *pw = (PageFaultWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );


    switch (uMessage) {
        case WM_CREATE:
            pw = (PageFaultWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) pw );
            pw->hwndList = ChildCreate( hwnd );
            pw->InitializeList();
            SetMenuState( IDM_NEW_PAGE, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_PAGE;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.PagePosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.PagePosition, TRUE );
            MoveWindow( pw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( pw->hwndList, 0, Width * .40 );
            ListView_SetColumnWidth( pw->hwndList, 1, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 2, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 3, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 4, Width * .15 );
            break;

        case WM_NOTIFY:
            pw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_PAGE, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\registry.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the apis for APIMON to _access the registry.
    All _access to the registry are done in this file.  If additional
    registry control is needed then a function should be added in this file
    and exposed to the other files in APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


//
// string constants for accessing the registry
// there is a string constant here for each key and each value
// that is accessed in the registry.
//
#define REGKEY_SOFTWARE             "software\\microsoft\\ApiMon"

#define REGKEY_LOGFILENAME          "LogFileName"
#define REGKEY_TRACEFILENAME        "TraceFileName"
#define REGKEY_SYMBOL_PATH          "SymbolPath"
#define REGKEY_LAST_DIR             "LastDir"
#define REGKEY_PROG_DIR             "ProgDir"
#define REGKEY_ARGUMENTS            "Arguments"
#define REGKEY_TRACING              "Tracing"
#define REGKEY_ALIASING             "Aliasing"
#define REGKEY_HEAP_CHECKING        "HeapChecking"
#define REGKEY_PRELOAD_SYMBOLS      "PreLoadSymbols"
#define REGKEY_API_COUNTERS         "ApiCounters"
#define REGKEY_GO_IMMEDIATE         "GoImmediate"
#define REGKEY_FAST_COUNTERS        "FastCounters"
#define REGKEY_DEFAULT_SORT         "DefaultSort"
#define REGKEY_FRAME_POSITION       "FramePosition"
#define REGKEY_DLL_POSITION         "DllPosition"
#define REGKEY_COUNTER_POSITION     "CounterPosition"
#define REGKEY_PAGE_POSITION        "PagePosition"
#define REGKEY_LOGFONT              "LogFont"
#define REGKEY_COLOR                "Color"
#define REGKEY_CUSTCOLORS           "CustColors"
#define REGKEY_USE_KNOWN_DLLS       "UseKnownDlls"
#define REGKEY_EXCLUDE_KNOWN_DLLS   "ExcludeKnownDlls"
#define REGKEY_KNOWN_DLLS           "KnownDlls"
#define REGKEY_PAGE_FAULTS          "PageFaults"
#define REGKEY_AUTO_REFRESH         "AutoRefresh"
#define REGKEY_GRAPH_FILTER_VALUE   "GraphFilterValue"
#define REGKEY_GRAPH_FILTER         "GraphFilter"
#define REGKEY_GRAPH_DISPLAY_LEGEND "GraphDisplayLegend"


LPSTR SystemDlls[] =
    {
        "ntdll.dll",
        "kernel32.dll"
    };

#define MAX_SYSTEM_DLLS (sizeof(SystemDlls)/sizeof(LPSTR))


//
// local prototypes
//
void  RegSetDWORD( HKEY hkey, LPSTR szSubKey, DWORD dwValue );
void  RegSetBOOL( HKEY hkey, LPSTR szSubKey, BOOL dwValue );
void  RegSetSZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetMULTISZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetBINARY( HKEY hkey, LPSTR szSubKey, LPVOID ValueData, DWORD Length );
void  RegSetEXPANDSZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetPOS(HKEY hkey, LPSTR szSubKey, PPOSITION Pos );
BOOL  RegQueryBOOL( HKEY hkey, LPSTR szSubKey );
DWORD RegQueryDWORD( HKEY hkey, LPSTR szSubKey );
void  RegQuerySZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegQueryMULTISZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegQueryBINARY( HKEY hkey, LPSTR szSubKey, LPVOID ValueData, DWORD Length );
void  RegQueryPOS(HKEY hkey, LPSTR szSubKey, PPOSITION Pos );
BOOL  RegSaveAllValues( HKEY hKey, POPTIONS o );
BOOL  RegGetAllValues( POPTIONS o, HKEY hKey );
BOOL  RegInitializeDefaults( HKEY hKey );
HKEY  RegGetAppKey( void );

extern "C" BOOL RunningOnNT;



BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY     hKey
    )

/*++

Routine Description:

    This functions retrieves all registry data for APIMON and puts
    the data in the OPTIONS structure passed in.

Arguments:

    o          - pointer to an OPTIONS structure
    hKey       - handle to a registry key for APIMON registry data

Return Value:

    TRUE       - retrieved all data without error
    FALSE      - errors occurred and did not get all data

--*/

{
    RegQuerySZ( hKey, REGKEY_LOGFILENAME,   o->LogFileName   );
    RegQuerySZ( hKey, REGKEY_TRACEFILENAME, o->TraceFileName );
    RegQuerySZ( hKey, REGKEY_SYMBOL_PATH,   o->SymbolPath    );
    RegQuerySZ( hKey, REGKEY_LAST_DIR,      o->LastDir       );
    RegQuerySZ( hKey, REGKEY_PROG_DIR,      o->ProgDir       );
    RegQuerySZ( hKey, REGKEY_ARGUMENTS,     o->Arguments     );

    RegQueryMULTISZ( hKey, REGKEY_KNOWN_DLLS, o->KnownDlls   );

    o->Tracing             = RegQueryBOOL(  hKey, REGKEY_TRACING         );
    o->Aliasing            = RegQueryBOOL(  hKey, REGKEY_ALIASING        );
    o->HeapChecking        = RegQueryBOOL(  hKey, REGKEY_HEAP_CHECKING   );
    o->PreLoadSymbols      = RegQueryBOOL(  hKey, REGKEY_PRELOAD_SYMBOLS );
    o->ApiCounters         = RegQueryBOOL(  hKey, REGKEY_API_COUNTERS    );
    o->GoImmediate         = RegQueryBOOL(  hKey, REGKEY_GO_IMMEDIATE    );
    o->FastCounters        = RegQueryBOOL(  hKey, REGKEY_FAST_COUNTERS   );
    o->UseKnownDlls        = RegQueryBOOL(  hKey, REGKEY_USE_KNOWN_DLLS  );
    o->ExcludeKnownDlls    = RegQueryBOOL(  hKey, REGKEY_EXCLUDE_KNOWN_DLLS  );
    o->MonitorPageFaults   = RegQueryBOOL(  hKey, REGKEY_PAGE_FAULTS     );
    o->AutoRefresh         = RegQueryBOOL(  hKey, REGKEY_AUTO_REFRESH    );
    o->DefaultSort         = (SORT_TYPE)RegQueryDWORD( hKey, REGKEY_DEFAULT_SORT    );
    o->Color               = RegQueryDWORD( hKey, REGKEY_COLOR           );
    o->DisplayLegends      = RegQueryBOOL(  hKey, REGKEY_GRAPH_DISPLAY_LEGEND );
    o->FilterGraphs        = RegQueryBOOL(  hKey, REGKEY_GRAPH_FILTER         );
    o->GraphFilterValue    = RegQueryDWORD( hKey, REGKEY_GRAPH_FILTER_VALUE   );

    RegQueryPOS( hKey, REGKEY_FRAME_POSITION,   &o->FramePosition   );
    RegQueryPOS( hKey, REGKEY_DLL_POSITION,     &o->DllPosition     );
    RegQueryPOS( hKey, REGKEY_COUNTER_POSITION, &o->CounterPosition );
    RegQueryPOS( hKey, REGKEY_PAGE_POSITION,    &o->PagePosition    );

    RegQueryBINARY( hKey, REGKEY_LOGFONT,    &o->LogFont,   sizeof(o->LogFont)    );
    RegQueryBINARY( hKey, REGKEY_CUSTCOLORS, o->CustColors, sizeof(o->CustColors) );

    return TRUE;
}

BOOL
RegSaveAllValues(
    HKEY     hKey,
    POPTIONS o
    )

/*++

Routine Description:

    This functions saves all registry data for APIMON that is passed
    in via the OPTIONS structure.

Arguments:

    hKey   - handle to a registry key for APIMON registry data
    o      - pointer to an OPTIONS structure

Return Value:

    TRUE   - saved all data without error
    FALSE  - errors occurred and did not save all data

--*/

{
    RegSetSZ(    hKey, REGKEY_LOGFILENAME,        o->LogFileName        );
    RegSetSZ(    hKey, REGKEY_TRACEFILENAME,      o->TraceFileName      );
    RegSetSZ(    hKey, REGKEY_SYMBOL_PATH,        o->SymbolPath         );
    RegSetSZ(    hKey, REGKEY_LAST_DIR,           o->LastDir            );
    RegSetSZ(    hKey, REGKEY_PROG_DIR,           o->ProgDir            );
    RegSetSZ(    hKey, REGKEY_ARGUMENTS,          o->Arguments          );

    RegSetMULTISZ( hKey, REGKEY_KNOWN_DLLS,       o->KnownDlls          );

    RegSetBOOL(  hKey, REGKEY_TRACING,            o->Tracing            );
    RegSetBOOL(  hKey, REGKEY_ALIASING,           o->Aliasing           );
    RegSetBOOL(  hKey, REGKEY_HEAP_CHECKING,      o->HeapChecking       );
    RegSetBOOL(  hKey, REGKEY_PRELOAD_SYMBOLS,    o->PreLoadSymbols     );
    RegSetBOOL(  hKey, REGKEY_API_COUNTERS,       o->ApiCounters        );
    RegSetBOOL(  hKey, REGKEY_GO_IMMEDIATE,       o->GoImmediate        );
    RegSetBOOL(  hKey, REGKEY_FAST_COUNTERS,      o->FastCounters       );
    RegSetBOOL(  hKey, REGKEY_USE_KNOWN_DLLS,     o->UseKnownDlls       );
    RegSetBOOL(  hKey, REGKEY_EXCLUDE_KNOWN_DLLS, o->ExcludeKnownDlls   );
    RegSetBOOL(  hKey, REGKEY_PAGE_FAULTS,        o->MonitorPageFaults  );
    RegSetBOOL(  hKey, REGKEY_AUTO_REFRESH,       o->AutoRefresh        );
    RegSetDWORD( hKey, REGKEY_DEFAULT_SORT,       o->DefaultSort        );
    RegSetDWORD( hKey, REGKEY_COLOR,              o->Color              );

    RegSetBOOL(  hKey, REGKEY_GRAPH_DISPLAY_LEGEND, o->DisplayLegends   );
    RegSetBOOL(  hKey, REGKEY_GRAPH_FILTER,         o->FilterGraphs     );
    RegSetDWORD( hKey, REGKEY_GRAPH_FILTER_VALUE,   o->GraphFilterValue );

    RegSetPOS(  hKey, REGKEY_FRAME_POSITION,     &o->FramePosition      );
    RegSetPOS(  hKey, REGKEY_DLL_POSITION,       &o->DllPosition        );
    RegSetPOS(  hKey, REGKEY_COUNTER_POSITION,   &o->CounterPosition    );
    RegSetPOS(  hKey, REGKEY_PAGE_POSITION,      &o->PagePosition       );

    RegSetBINARY( hKey, REGKEY_LOGFONT, &o->LogFont,   sizeof(o->LogFont)    );
    RegSetBINARY( hKey, REGKEY_CUSTCOLORS, o->CustColors, sizeof(o->CustColors) );

    return TRUE;
}

BOOL
RegInitializeDefaults(
    HKEY  hKey,
    LPSTR ProgName
    )

/*++

Routine Description:

    This functions initializes the registry with the default values.

Arguments:

    hKey   - handle to a registry key for APIMON registry data

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    OPTIONS o;

    ZeroMemory( &o, sizeof(o) );

    strcpy( o.ProgName,      ProgName                 );
    strcpy( o.LogFileName,   "%windir%\\apimon.log"   );
    strcpy( o.TraceFileName, "%windir%\\apitrace.log" );
    if (RunningOnNT) {
        strcpy( o.SymbolPath,    "%windir%\\symbols"  );
    } else {
        strcpy( o.SymbolPath,    "%windir%"  );
    }

    o.Tracing           = FALSE;
    o.Aliasing          = FALSE;
    o.HeapChecking      = FALSE;
    o.PreLoadSymbols    = FALSE;
    o.ApiCounters       = TRUE;
    o.GoImmediate       = FALSE;
    o.FastCounters      = TRUE;
    o.UseKnownDlls      = FALSE;
    o.ExcludeKnownDlls  = FALSE;
    o.DefaultSort       = SortByCounter;
    o.Color             = RGB(255,255,255);
    o.GraphFilterValue  = 1;
    o.DisplayLegends    = TRUE;
    o.FilterGraphs      = TRUE;
    o.AutoRefresh       = TRUE;

    ULONG i;
    LPSTR p = o.KnownDlls;
    for (i=0; i<MAX_SYSTEM_DLLS; i++) {
        strcpy( p, SystemDlls[i] );
        p += (strlen(p) + 1);
    }
    *p = 0;

    RegSaveAllValues( hKey, &o );

    return TRUE;
}

HKEY
RegGetAppKey(
    LPSTR ProgName
    )

/*++

Routine Description:

    This function gets a handle to the APIMON registry key.

Arguments:

    None.

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD   rc;
    DWORD   dwDisp;
    HKEY    hKey;
    CHAR    SubKey[128];


    if ((!ProgName) || (!ProgName[0])) {
        return NULL;
    }

    strcpy( SubKey, REGKEY_SOFTWARE );
    strcat( SubKey, "\\"            );
    strcat( SubKey, ProgName        );

    rc = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        SubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisp
        );

    if (rc != ERROR_SUCCESS) {
        return NULL;
    }

    if (dwDisp == REG_CREATED_NEW_KEY) {
        RegInitializeDefaults( hKey, ProgName );
    }

    return hKey;
}

BOOL
RegInitialize(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to initialize the OPTIONS structure passed in
    with the current values in the registry.  Note that if the registry
    is empty then the defaults are stored in the registry and also
    returned in the OPTIONS structure.

Arguments:

    None.

Return Value:

    TRUE           - all data was retrieved ok
    NULL           - could not get all data

--*/

{
    HKEY hKey = RegGetAppKey( o->ProgName );
    if (!hKey) {
        return FALSE;
    }

    if (!RegGetAllValues( o, hKey )) {
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}

BOOL
RegSave(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to save the data in the OPTIONS structure
    to the registry.

Arguments:

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE           - all data was saved ok
    NULL           - could not save all data

--*/

{
    HKEY    hKey;

    hKey = RegGetAppKey( o->ProgName );
    if (!hKey) {
        return FALSE;
    }
    RegSaveAllValues( hKey, o );
    RegCloseKey( hKey );

    return TRUE;
}

void
RegSetDWORD(
    HKEY hkey,
    LPSTR szSubKey,
    DWORD dwValue
    )

/*++

Routine Description:

    This function changes a DWORD value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
}

void
RegSetBOOL(
    HKEY hkey,
    LPSTR szSubKey,
    BOOL dwValue
    )

/*++

Routine Description:

    This function changes a BOOL value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
}

void
RegSetSZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_SZ, (PUCHAR)szValue, strlen(szValue)+1 );
}

void
RegSetMULTISZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    ULONG i = 1;
    ULONG j = 0;
    LPSTR p = szValue;
    while( TRUE ) {
        j = strlen( p ) + 1;
        i += j;
        p += j;
        if (!*p) {
            break;
        }
    }
    RegSetValueEx( hkey, szSubKey, 0, REG_MULTI_SZ, (PUCHAR)szValue, i );
}

void
RegSetBINARY(
    HKEY    hkey,
    LPSTR   szSubKey,
    LPVOID  ValueData,
    DWORD   Length
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_BINARY, (PUCHAR)ValueData, Length );
}

void
RegSetPOS(
    HKEY        hkey,
    LPSTR       szSubKey,
    PPOSITION   Pos
    )
{
    CHAR buf[64];
    sprintf(
        buf,
        "%d,%d,%d,%d,%d",
        Pos->Flags,
        Pos->Rect.top,
        Pos->Rect.left,
        Pos->Rect.right,
        Pos->Rect.bottom
        );
    RegSetSZ( hkey, szSubKey, buf );
}

void
RegSetEXPANDSZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_EXPAND_SZ, (PUCHAR)szValue, strlen(szValue)+1 );
}

BOOL
RegQueryBOOL(
    HKEY hkey,
    LPSTR szSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a FALSE value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    TRUE or FALSE.

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    BOOL    fValue = FALSE;

    len = 4;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = FALSE;
            RegSetBOOL( hkey, szSubKey, fValue );
        }
    }

    return fValue;
}

DWORD
RegQueryDWORD(
    HKEY hkey,
    LPSTR szSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    DWORD   fValue = 0;

    len = 4;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = 0;
            RegSetDWORD( hkey, szSubKey, fValue );
        }
    }

    return fValue;
}

void
RegQuerySZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024] = {0};

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            RegSetSZ( hkey, szSubKey, buf );
        }
    }

    strcpy( szValue, buf );
}

void
RegQueryMULTISZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024];

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            buf[1] = 0;
            len = 2;
            RegSetMULTISZ( hkey, szSubKey, buf );
        }
    }

    memcpy( szValue, buf, len );
}

void
RegQueryBINARY(
    HKEY    hkey,
    LPSTR   szSubKey,
    LPVOID  ValueData,
    DWORD   Length
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;

    len = Length;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)ValueData, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            ZeroMemory( ValueData, Length );
            RegSetBINARY( hkey, szSubKey, ValueData, Length );
        }
    }
}

void
RegQueryPOS(
    HKEY        hkey,
    LPSTR       szSubKey,
    PPOSITION   Pos
    )
{
    CHAR buf[64];
    RegQuerySZ( hkey, szSubKey, buf );
    LPSTR p = buf;
    LPSTR p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Flags = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    Pos->Rect.top = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Rect.left = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Rect.right = atoi( p );
    p = p1 + 1;
    Pos->Rect.bottom = atoi( p );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\tracevw.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tracevw.cpp

Abstract:

    All user interface code for the trace view window.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



TraceWindow::TraceWindow()
{
}


TraceWindow::~TraceWindow()
{
}


BOOL
TraceWindow::Create()
{
    return ApiMonWindow::Create(
        "ApiMonTrace",
        "Api Trace"
        );
}


BOOL
TraceWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonTrace",
        IDI_CHILDICON,
        MDIChildWndProcTrace
        );
}


BOOL
TraceWindow::Update(
    BOOL ForceUpdate
    )
{
    return TRUE;
}


void
TraceWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "Return";
    lvc.iSubItem = 0;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 0, &lvc );

    lvc.pszText = "Arg1";
    lvc.iSubItem = 1;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 1, &lvc );

    lvc.pszText = "Arg2";
    lvc.iSubItem = 2;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 2, &lvc );

    lvc.pszText = "Arg3";
    lvc.iSubItem = 3;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 3, &lvc );

    lvc.pszText = "Arg4";
    lvc.iSubItem = 4;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 4, &lvc );

    lvc.pszText = "Name";
    lvc.iSubItem = 5;
    lvc.cx = 100;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 5, &lvc );
}


void
TraceWindow::AddItemToList(
    PTRACE_ENTRY TraceEntry
    )
{
    LV_ITEM             lvi = {0};
    CHAR                buf[16];
    int                 iItem;
    ULONG               i;
    ULONG               j;
    PAPI_INFO           ApiInfo;
    PDLL_INFO           DllInfo;



    if (!hwndList) {
        return;
    }

    sprintf( buf, "%08x", TraceEntry->ReturnValue );
    lvi.pszText = buf;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = 0;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    sprintf( buf, "%08x", TraceEntry->Args[0] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[1] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 2;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[2] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 3;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[3] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 4;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    ApiInfo = GetApiInfoByAddress( TraceEntry->Address, &DllInfo );
    if (ApiInfo) {
        lvi.pszText = (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr);
        lvi.iItem = iItem;
        lvi.iSubItem = 5;
        lvi.mask = LVIF_TEXT;
        ListView_SetItem( hwndList, &lvi );
    }
}


void
TraceWindow::FillList()
{
    ULONG i;
    PTRACE_ENTRY TraceEntry;


    //
    // while we hold the trace mutex the monitored application
    // is effectivly stopped.  lets get the data displayed
    // as quickly as possible.
    //
    WaitForSingleObject( ApiTraceMutex, INFINITE );

    for (i=0,TraceEntry=TraceBuffer->Entry; i<TraceBuffer->Count; i++) {
        AddItemToList( TraceEntry );
        TraceEntry = (PTRACE_ENTRY) ((PUCHAR)TraceEntry + TraceEntry->SizeOfStruct);
    }

    ReleaseMutex( ApiTraceMutex );
}


void
TraceWindow::Notify(
   LPNMHDR  NmHdr
   )
{
}


LRESULT CALLBACK
MDIChildWndProcTrace(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    TraceWindow *tw = (TraceWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMessage) {
        case WM_CREATE:
            tw = (TraceWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) tw );
            tw->hwndList = ChildCreate( hwnd );
            tw->InitializeList();
            tw->FillList();
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_COUNTER;
            break;

        case WM_SIZE:
            MoveWindow( tw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( tw->hwndList, 0, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 1, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 2, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 3, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 4, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 5, Width * .40 );
            break;

        case WM_NOTIFY:
            tw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_COUNTER, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\ui.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ui.cpp

Abstract:

    All user interface code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"
#include <shellapi.h>



#define NUMIMAGES                   13

#define IMAGEWIDTH                  30
#define IMAGEHEIGHT                 28

#define BUTTONWIDTH                 30
#define BUTTONHEIGHT                28

#define SEPHEIGHT                   7
#define HELP_FILE_NAME              "apimon.hlp"
#define MAX_API_WINDOWS             4



DllListWindow               dw;
CountersWindow              cw;
PageFaultWindow             pw;
GraphWindow                 gw;
TraceWindow                 tw;

HINSTANCE                   hInst;
HWND                        hwndFrame;
HWND                        hwndMDIClient;
HWND                        hwndToolbar;
HWND                        hwndStatusbar;
DWORD                       ToolbarHeight;
DWORD                       StatusbarHeight;
UINT_PTR                    ApiMonTimerId;
BOOL                        MonitorRunning;
BOOL                        DebuggeStarted;
DWORD                       BaseTime;
HANDLE                      BreakinEvent;
DWORD                       EndingTick;
DWORD                       StartingTick;
SYSTEMTIME                  StartingLocalTime;
BOOL                        ApiCounterEnabled = TRUE;
CHAR                        ToolTipBuf[256];
HMENU                       hmenuFrame;
HFONT                       hFont;
DWORD                       ChildFocus;
BOOL                        InMenu;
DWORD                       MenuId;
CHAR                        HelpFileName[MAX_PATH];
CHAR                        LogFileName[MAX_PATH];
CHAR                        TraceFileName[MAX_PATH];

TBBUTTON TbButton[] =
    {
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  0, IDM_FILEOPEN,         TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  4, IDM_WRITE_LOG,        TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  7, IDM_START,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  8, IDM_STOP,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  5, IDM_REFRESH,          TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  9, IDM_CLEAR_COUNTERS,   TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        { 12, IDM_VIEW_TRACE,       TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  2, IDM_FONT,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  3, IDM_COLOR,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  1, IDM_GRAPH,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  6, IDM_LEGEND,           TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        { 11, IDM_OPTIONS,          TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        { 10, IDM_HELP,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 }

    };

TOOLBAR_STATE ToolbarState[] =
    {
        {  IDM_FILEOPEN,        TRUE,   "A program cannot be opened while another is being monitored" },
        {  IDM_WRITE_LOG,       FALSE,  "The log file cannot be written until the application is started"  },
        {  IDM_START,           FALSE,  "An application cannot be started until one is opened"  },
        {  IDM_STOP,            FALSE,  "The application cannot be stopped until it is started"  },
        {  IDM_REFRESH,         FALSE,  "Counters cannot be refreshed until the application is started"  },
        {  IDM_CLEAR_COUNTERS,  FALSE,  "Counters cannot be cleared until the application is started"  },
        {  IDM_VIEW_TRACE,      FALSE,  "API trace cannot be viewed until the application is started"  },
        {  IDM_FONT,            TRUE,   NULL },
        {  IDM_COLOR,           TRUE,   NULL },
        {  IDM_GRAPH,           FALSE,  "A graph cannot be created with zero counters" },
        {  IDM_LEGEND,          FALSE,  "Graph legends cannot be changed" },
        {  IDM_OPTIONS,         FALSE,  "Options cannot be changed until an application is opened"  },
        {  IDM_HELP,            TRUE,   NULL }
    };

#define MAX_TOOLBAR_STATES (sizeof(ToolbarState)/sizeof(TOOLBAR_STATE))

UINT idPopup[] =
    {
        IDS_MDISYSMENU,     // Maximized MDI child system menu
        IDS_FILEMENU,
        IDS_WINDOWMENU,
        IDS_HELPMENU,
    };

COLORREF CustomColors[] =
    {
        UBLACK,
        DARK_RED,
        DARK_GREEN,
        DARK_YELLOW,
        DARK_BLUE,
        DARK_MAGENTA,
        DARK_CYAN,
        DARK_GRAY,
        LIGHT_GRAY,
        LIGHT_RED,
        LIGHT_GREEN,
        LIGHT_YELLOW,
        LIGHT_BLUE,
        LIGHT_MAGENTA,
        LIGHT_CYAN,
        UWHITE
    };



VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hwnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hwnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}

VOID
ApiMonTimer(
    HWND  hwnd,
    UINT  msg,
    UINT_PTR  evtid,
    DWORD currtime
    )
{
    cw.Update( FALSE );
    dw.Update( FALSE );
    pw.Update( FALSE );
    gw.Update( FALSE );
    tw.Update( FALSE );
}

DWORD
CreateChildWindows(
    DWORD ChildType
    )
{
    DWORD ChildFocusSave = 0;
    POSITION PosSave = {0};


    if ((ApiMonOptions.CounterPosition.Flags & IS_ZOOMED) ||
        (ApiMonOptions.DllPosition.Flags     & IS_ZOOMED)) {
            //
            // set the flags
            //
            ApiMonOptions.CounterPosition.Flags |= IS_ZOOMED;
            ApiMonOptions.DllPosition.Flags     |= IS_ZOOMED;
            ApiMonOptions.PagePosition.Flags    |= IS_ZOOMED;
    }

    switch( ChildType ) {
        case CHILD_COUNTER:
            if (ApiMonOptions.CounterPosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_COUNTER;
            }
            PosSave = ApiMonOptions.CounterPosition;
            cw.Create();
            cw.ChangePosition( &PosSave );
            cw.ChangeFont( hFont );
            cw.ChangeColor( ApiMonOptions.Color );
            break;

        case CHILD_DLL:
            if (ApiMonOptions.DllPosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_DLL;
            }
            PosSave = ApiMonOptions.DllPosition;
            dw.Create();
            dw.ChangePosition( &PosSave );
            dw.ChangeFont( hFont );
            dw.ChangeColor( ApiMonOptions.Color );
            break;

        case CHILD_PAGE:
            if (ApiMonOptions.PagePosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_PAGE;
            }
            PosSave = ApiMonOptions.PagePosition;
            pw.Create();
            pw.ChangePosition( &PosSave );
            pw.ChangeFont( hFont );
            pw.ChangeColor( ApiMonOptions.Color );
            break;
    }

    return ChildFocusSave;
}

VOID __inline
UpdateStatusBar(
    LPSTR lpszStatusString,
    WORD  partNumber,
    WORD  displayFlags
    )
{
    SendMessage(
        hwndStatusbar,
        SB_SETTEXT,
        partNumber | displayFlags,
        (LPARAM)lpszStatusString
        );
}

VOID
SetMenuState(
    DWORD id,
    DWORD st
    )
{
    EnableMenuItem( hmenuFrame, id, st );
}

PTOOLBAR_STATE __inline
GetToolbarState(
    DWORD Id
    )
{
    for (int i=0; i<MAX_TOOLBAR_STATES; i++) {
        if (ToolbarState[i].Id == Id) {
            return &ToolbarState[i];
        }
    }
    return NULL;
}

VOID
EnableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = TRUE;
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, Id, MAKELONG(1,0) );
        EnableMenuItem( hmenuFrame, Id, MF_ENABLED );
    }
}

VOID
DisableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = FALSE;
        EnableMenuItem( hmenuFrame, Id, MF_GRAYED );
    }
}

VOID
ReallyDisableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = FALSE;
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, Id, 0 );
        EnableMenuItem( hmenuFrame, Id, MF_GRAYED );
    }
}


VOID
StatusBarTimer(
    HWND  hwnd,
    UINT  msg,
    UINT_PTR  evtid,
    DWORD currtime
    )
{
    char        szBuf[16];
    SYSTEMTIME  sysTime;

    GetLocalTime( &sysTime );
    wsprintf(
        szBuf,
        "%2d:%02d:%02d %s",
        (sysTime.wHour == 0 ? 12 :
        (sysTime.wHour <= 12 ? sysTime.wHour : sysTime.wHour -12)),
        sysTime.wMinute,
        sysTime.wSecond,
        (sysTime.wHour < 12 ? "AM":"PM")
        );

    UpdateStatusBar( szBuf, 2, 0 );
}

VOID
InitializeStatusBar(
    HWND hwnd
    )
{
    const cSpaceInBetween = 8;
    RECT rect;
    SIZE size;
    HDC hDC = GetDC( hwnd );
    GetClientRect( hwnd, &rect );
    int ptArray[3];
    ptArray[0] = 0;
    ptArray[1] = 0;
    ptArray[2] = rect.right;
    if (hDC) {
        if (GetTextExtentPoint( hDC, "00:00:00 PM", 12, &size )) {
            ptArray[1] = ptArray[2] - (size.cx) - cSpaceInBetween;
        }
        if (GetTextExtentPoint(hDC, "Time:", 6, &size)) {
            ptArray[0] = ptArray[1] - (size.cx) - cSpaceInBetween;
        }
        ReleaseDC( hwnd, hDC );
    }
    SendMessage(
        hwndStatusbar,
        SB_SETPARTS,
        sizeof(ptArray)/sizeof(ptArray[0]),
        (LPARAM)(LPINT)ptArray
        );
    UpdateStatusBar( "API Monitor", 0, 0 );
    UpdateStatusBar( "Time:", 1, SBT_POPOUT );
}

VOID
SaveWindowPos(
    HWND        hwnd,
    PPOSITION   Pos,
    BOOL        ChildWindow
    )
{
    GetWindowRect( hwnd, &Pos->Rect );

    if (ChildWindow) {
        ScreenToClient( hwndMDIClient, (LPPOINT)&Pos->Rect.left  );
        ScreenToClient( hwndMDIClient, (LPPOINT)&Pos->Rect.right );
    }

    Pos->Flags = 0;
    if (IsIconic( hwnd )) {
        Pos->Flags |= IS_ICONIC;
    } else if (IsZoomed( hwnd )) {
        Pos->Flags |= IS_ZOOMED;
    }
}

VOID
SetWindowPosition(
    HWND        hwnd,
    PPOSITION   Pos
    )
{
    if (Pos->Flags & IS_ICONIC) {
        ShowWindow( hwnd, SW_MINIMIZE );
        return;
    }

    if (Pos->Flags & IS_ZOOMED) {
        ShowWindow( hwnd, SW_MAXIMIZE );
        return;
    }

    if (Pos->Rect.top    == 0 && Pos->Rect.left  == 0 &&
        Pos->Rect.bottom == 0 && Pos->Rect.right == 0) {
            return;
    }

    MoveWindow(
        hwnd,
        Pos->Rect.left,
        Pos->Rect.top,
        Pos->Rect.right  - Pos->Rect.left,
        Pos->Rect.bottom - Pos->Rect.top,
        TRUE
        );
}

VOID
InitializeFrameWindow(
    HWND hwnd
    )
{
    RECT rect;
    hwndToolbar = CreateToolbarEx(
        hwnd,
        WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
        IDM_TOOLBAR,
        NUMIMAGES,
        hInst,
        IDB_TOOLBAR,
        TbButton,
        sizeof(TbButton)/sizeof(TBBUTTON),
        BUTTONWIDTH,
        BUTTONHEIGHT,
        IMAGEWIDTH,
        IMAGEHEIGHT,
        sizeof(TBBUTTON)
        );
    SendMessage( hwndToolbar, TB_AUTOSIZE, 0, 0 );
    GetWindowRect( hwndToolbar, &rect );
    ToolbarHeight = rect.bottom - rect.top;
    hwndStatusbar = CreateStatusWindow(
        WS_CHILD | WS_VISIBLE | WS_BORDER,
        "API Monitor",
        hwnd,
        IDM_STATUSBAR
        );
    GetWindowRect( hwndStatusbar, &rect );
    StatusbarHeight = rect.bottom - rect.top;
    InitializeStatusBar( hwnd );
    SetTimer( hwnd, 1, 1000, StatusBarTimer );

    CLIENTCREATESTRUCT ccs = {0};
    ccs.hWindowMenu  = GetSubMenu( GetMenu(hwnd), WINDOWMENU );
    ccs.idFirstChild = IDM_WINDOWCHILD;
    hwndMDIClient = CreateWindow(
        "MDICLIENT",
        NULL,
        WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL,
        0,0,0,0,
        hwnd,
        (HMENU)0xCAC,
        hInst,
        (LPVOID)&ccs
        );
    ShowWindow( hwndMDIClient, SW_SHOWNORMAL );
    BreakinEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    ApiCounterEnabled = TRUE;
}

LRESULT
MenuUpdateStatusBar(
    HWND    hwnd,
    UINT    uMessage,
    WPARAM  wparam,
    LPARAM  lparam
    )
{
    static char szBuffer[128];
    char   szTitle[32];
    LPSTR  lpTitle;
    UINT   nStringID = 0;
    UINT   fuFlags = GET_WM_MENUSELECT_FLAGS(wparam, lparam) & 0xffff;
    UINT   uCmd    = GET_WM_MENUSELECT_CMD(wparam, lparam);
    HMENU  hMenu   = GET_WM_MENUSELECT_HMENU(wparam, lparam);


    szBuffer[0] = 0;

    if (fuFlags == 0xffff && hMenu == NULL) {
        //
        // Menu has been closed
        //
        nStringID = IDS_DESCRIPTION;

    } else if (fuFlags & MFT_SEPARATOR) {
        //
        // Ignore separators
        //
        nStringID = 0;

    } else if (fuFlags & MF_POPUP) {
        //
        // Popup menu
        //
        if (fuFlags & MF_SYSMENU) {
            //
            // System menu
            //
            nStringID = IDS_SYSMENU;
        } else {
            //
            // If there is a maximized MDI child window,
            // its system menu will be added to the main
            // window's menu bar.  Since the string ID for
            // the MDI child's sysmenu is already in the
            // idPopup array, all we need to do is patch up
            // the popup menu index (uCmd) when the child's
            // system menu is NOT present.
            //

            HWND hwndChild = (HWND)SendMessage( hwndMDIClient, WM_MDIGETACTIVE, 0, 0 );

            if (!hwndChild || !IsZoomed(hwndChild)) {
                //
                // No MDI child sysmenu
                //
                uCmd++;
            }
            //
            // Get string ID for popup menu from idPopup array.
            //
            nStringID = ((uCmd < sizeof(idPopup)/sizeof(idPopup[0])) ? idPopup[uCmd] : 0);
        }
    } else {
        //
        // Must be a command item
        //
        // The Window menu has a dynamic part at the bottom
        // where the MDI Client window adds entries for each
        // child window that is open.  By getting the menu
        // item string we can customize the status bar string
        // with the name of the document.
        //

        if (uCmd >= IDM_WINDOWCHILD && uCmd < IDS_HELPMENU) {
            LoadString( hInst, IDM_WINDOWCHILD, szBuffer, sizeof(szBuffer) );
            GetMenuString(
                hMenu,
                uCmd,
                szTitle,
                sizeof(szTitle),
                MF_BYCOMMAND
                );

            lpTitle = szTitle;

            while (*lpTitle && *lpTitle != ' ') {
                lpTitle++;
            }

            lstrcat( szBuffer, lpTitle );

            nStringID = 0;
        } else {
            //
            // String ID == Command ID
            //
            nStringID = uCmd;
        }
    }

    //
    // Load the string if we have an ID
    //
    if (nStringID) {
        LoadString( hInst, nStringID, szBuffer, sizeof(szBuffer) );
    }

    //
    // Finally... send the string to the status bar
    //
    UpdateStatusBar( szBuffer, 0, 0 );

    return 0;
}

BOOL
InitializeProgram(
    LPSTR ProgName,
    LPSTR Arguments
    )
{
    CHAR    FullProgName[MAX_PATH*2];
    CHAR    Drive[MAX_PATH];
    CHAR    Dir[_MAX_DIR];
    CHAR    Fname[_MAX_FNAME];
    CHAR    Ext[_MAX_EXT];
    LPSTR   p;
    DWORD   ChildFocusSave = 0;
    DWORD   rval;


    if (!SearchPath( NULL, ProgName, ".exe", sizeof(FullProgName), FullProgName, &p )) {
        ApiMonOptions.ProgDir[0] = 0;
        ApiMonOptions.ProgName[0] = 0;
        PopUpMsg( "The program could not be located:\n\n%s", ProgName );
        return FALSE;
    }

    _splitpath( FullProgName, Drive, Dir, Fname, Ext );

    strcpy( ApiMonOptions.ProgName, Fname );
    strcat( ApiMonOptions.ProgName, Ext );

    RegInitialize( &ApiMonOptions );

    if (!ApiMonOptions.ProgDir[0]) {
        strcpy( ApiMonOptions.ProgDir,  Drive );
        strcat( ApiMonOptions.ProgDir,  Dir );
    } else {
        strcat( Drive, Dir );
        if (_stricmp( Drive, ApiMonOptions.ProgDir ) != 0) {
            strcpy( ApiMonOptions.ProgDir, Drive );
        }
    }

    if (ApiMonOptions.LogFont.lfFaceName[0]) {
        hFont = CreateFontIndirect( &ApiMonOptions.LogFont );
    }

    *ApiTraceEnabled = ApiMonOptions.Tracing || (KnownApis[0] != 0);

    if (Arguments) {
        strcpy( ApiMonOptions.Arguments, Arguments );
    }

    if (!ApiMonOptions.LastDir[0]) {
        strcpy( ApiMonOptions.LastDir, ApiMonOptions.ProgDir );
    }

    if (ApiMonOptions.FastCounters) {
        *FastCounterAvail = FALSE;
    } else {
        SYSTEM_INFO SystemInfo;
        GetSystemInfo( &SystemInfo );
        *FastCounterAvail = (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM &&
                             SystemInfo.dwNumberOfProcessors == 1);
    }

    EnableToolbarState( IDM_START );
    EnableToolbarState( IDM_OPTIONS );
    SetMenuState( IDM_SAVE_OPTIONS, MF_ENABLED );

    sprintf( FullProgName, "ApiMon <%s>", ProgName );
    SetWindowText( hwndFrame, FullProgName );

    SetWindowPosition( hwndFrame, &ApiMonOptions.FramePosition );

    rval = CreateChildWindows( CHILD_DLL );
    if (rval) {
        ChildFocusSave = rval;
    }
    rval = CreateChildWindows( CHILD_COUNTER );
    if (rval) {
        ChildFocusSave = rval;
    }
    rval = CreateChildWindows( CHILD_PAGE );
    if (rval) {
        ChildFocusSave = rval;
    }

    switch (ChildFocusSave) {
        case CHILD_COUNTER:
            cw.SetFocus();
            break;

        case CHILD_DLL:
            dw.SetFocus();
            break;

        case CHILD_PAGE:
            pw.SetFocus();
            break;
    }

    if (ApiMonOptions.GoImmediate) {
        PostMessage( hwndFrame, WM_COMMAND, IDM_START, 0 );
    }

    return TRUE;
}

LRESULT CALLBACK
WndProc(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    ULONG           i;
    LPSTR           CmdLine;
    DWORD           ThreadId;
    HANDLE          hThread;
    HANDLE          Handles[2];
    DWORD           WaitObj;
    PTOOLBAR_STATE  ToolbarState;



    switch (uMessage) {
        case WM_CREATE:
            hmenuFrame = GetMenu( hwnd );
            InitializeFrameWindow( hwnd );
            CenterWindow( hwnd, NULL );
            return 0;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.FramePosition, FALSE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.FramePosition, FALSE );
            SendMessage( hwndToolbar,   uMessage, wParam, lParam );
            SendMessage( hwndStatusbar, uMessage, wParam, lParam );
            InitializeStatusBar( hwnd );
            if (wParam != SIZE_MINIMIZED) {
                RECT rc;
                GetClientRect( hwnd, &rc );
                rc.top += (ToolbarHeight + SEPHEIGHT);
                rc.bottom -= StatusbarHeight;
                MoveWindow(
                    hwndMDIClient,
                    rc.left,
                    rc.top,
                    rc.right-rc.left,
                    rc.bottom-rc.top,
                    TRUE
                    );
            }
            if (wParam == SIZE_MINIMIZED) {
                KillTimer( hwnd, ApiMonTimerId );
                ApiMonTimerId = 0;
            } else if ((!ApiMonTimerId) && (DebuggeStarted) && (ApiMonOptions.AutoRefresh)) {
                ApiMonTimerId = SetTimer( hwnd, 2, UiRefreshRate, ApiMonTimer );
            }
            return 0;

        case WM_INIT_PROGRAM:
            InitializeProgram( (LPSTR)wParam, (LPSTR)lParam );
            return 0;

        case WM_SETFOCUS:
            RegisterHotKey( hwnd, VK_F1, 0, VK_F1 );
            break;

        case WM_KILLFOCUS:
            UnregisterHotKey( hwnd, VK_F1 );
            break;

        case WM_HOTKEY:
            if (wParam == VK_F1) {
                ProcessHelpRequest( hwnd, 0 );
            }
            return 0;

        case WM_ENTERMENULOOP:
            InMenu = TRUE;
            return 0;

        case WM_EXITMENULOOP:
            InMenu = FALSE;
            return 0;

        case WM_MENUSELECT:
            MenuId = LOWORD(wParam);
            MenuUpdateStatusBar( hwnd, uMessage, wParam, lParam );
            return 0;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rc;
                GetClientRect( hwnd, &rc );
                rc.top += ToolbarHeight;
                rc.bottom = rc.top + SEPHEIGHT;
                HDC hdc = BeginPaint( hwnd, &ps );
                DrawEdge( hdc, &rc, EDGE_RAISED, BF_TOP | BF_BOTTOM | BF_MIDDLE );
                EndPaint( hwnd, &ps );
            }
            return 0;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case TTN_NEEDTEXT:
                    {
                        LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT)lParam;
                        LoadString(
                            hInst,
                            (UINT)lpToolTipText->hdr.idFrom,
                            ToolTipBuf,
                            sizeof(ToolTipBuf)
                            );
                        lpToolTipText->lpszText = ToolTipBuf;
                    }
                    return 0;
            }
            break;

        case WM_DESTROY:
            if (LogFileName[0] != 0) {
               LogApiCounts(LogFileName);
               LogFileName[0] = 0;
            }
            else {
                LogApiCounts(ApiMonOptions.LogFileName);
            }

            if (TraceFileName[0] != 0) {
                LogApiTrace(TraceFileName);
                TraceFileName[0] = 0;
            }
            else {
                LogApiTrace(ApiMonOptions.TraceFileName);
            }
            PostQuitMessage( 0 );
            return 0;

        case WM_COMMAND:
            ToolbarState = GetToolbarState( (DWORD)wParam );
            if (ToolbarState) {
                if (!ToolbarState->State) {
                    if (ToolbarState->Msg) {
                        PopUpMsg( ToolbarState->Msg );
                    } else {
                        MessageBeep( MB_ICONEXCLAMATION );
                    }
                    return 0;
                }
            }
            switch( wParam ) {
                case IDM_START:
                    if (MonitorRunning) {
                        SendMessage( hwnd, WM_COMMAND, IDM_STOP, 0 );
                        break;
                    }

                    if (!ApiMonOptions.ProgName[0]) {
                        PopUpMsg( "You must first open a program for monitoring" );
                        break;
                    }

                    DisableToolbarState( IDM_START           );
                    DisableToolbarState( IDM_FILEOPEN        );
                    EnableToolbarState(  IDM_STOP            );
                    EnableToolbarState(  IDM_GRAPH           );
                    EnableToolbarState(  IDM_VIEW_TRACE      );
                    EnableToolbarState(  IDM_CLEAR_COUNTERS  );
                    EnableToolbarState(  IDM_REFRESH         );
                    EnableToolbarState(  IDM_WRITE_LOG       );

                    dw.DeleteAllItems();
                    cw.DeleteAllItems();
                    pw.DeleteAllItems();

                    for (i=0; i<MAX_DLLS; i++) {
                        if (!DllList[i].BaseAddress) {
                            break;
                        }
                        DllList[i].OrigEnable = DllList[i].Enabled;
                    }

                    CmdLine = (LPSTR) MemAlloc(
                        strlen(ApiMonOptions.ProgDir) +
                        strlen(ApiMonOptions.ProgName) +
                        strlen(ApiMonOptions.Arguments) + 32
                        );
                    if (!CmdLine) {
                        PopUpMsg( "Could not allocate memory for command line" );
                        break;
                    }
                    sprintf( CmdLine, "%s%s %s",
                        ApiMonOptions.ProgDir,
                        ApiMonOptions.ProgName,
                        ApiMonOptions.Arguments
                        );
                    hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)DebuggerThread,
                        (PVOID)CmdLine,
                        0,
                        &ThreadId
                        );
                    if (!hThread) {
                        PopUpMsg( "Could not start the program" );
                        break;
                    }
                    Handles[0] = hThread;
                    Handles[1] = ReleaseDebugeeEvent;
                    WaitObj = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );
                    if (WaitObj-WAIT_OBJECT_0 == 0) {
                        //
                        // could not launch the debuggee
                        //
                        PopUpMsg( "Could not start the program" );
                        break;
                    }
                    CloseHandle( hThread );
                    MonitorRunning = TRUE;
                    break;

                case IDM_STOP:
                    EnableToolbarState(  IDM_START );
                    DisableToolbarState( IDM_STOP  );

                    if (ApiMonTimerId) {
                        KillTimer( hwnd, ApiMonTimerId );
                    }
                    MonitorRunning = FALSE;
                    break;

                case IDM_REFRESH:
                    ApiMonTimer( hwnd, 0, 0, 0 );
                    break;

                case IDM_OPTIONS:
                    CreateOptionsPropertySheet( hInst, hwnd );
                    break;

                case IDM_EXIT:
                    SendMessage( hwnd, WM_CLOSE, 0, 0 );
                    return 0;

                case IDM_FILEOPEN:
                    {
                        CHAR ProgName[MAX_PATH];
                        if (BrowseForFileName( ProgName, "exe", "Executable Programs" )) {
                            SendMessage( hwnd, WM_INIT_PROGRAM, (WPARAM)ProgName, 0 );
                        }
                    }
                    return 0;

                case IDM_WRITE_LOG:
                    LogApiCounts(ApiMonOptions.LogFileName);
                    LogApiTrace(ApiMonOptions.TraceFileName);
                    return 0;

                case IDM_SAVE_OPTIONS:
                    SaveOptions();
                    return 0;

                case IDM_WINDOWTILE:
                    SendMessage( hwndMDIClient, WM_MDITILE, MDITILE_VERTICAL, 0 );
                    return 0;

                case IDM_WINDOWTILE_HORIZ:
                    SendMessage( hwndMDIClient, WM_MDITILE, MDITILE_HORIZONTAL, 0 );
                    return 0;

                case IDM_WINDOWCASCADE:
                    SendMessage( hwndMDIClient, WM_MDICASCADE, 0, 0 );
                    return 0;

                case IDM_WINDOWICONS:
                    SendMessage( hwndMDIClient, WM_MDIICONARRANGE, 0, 0 );
                    return 0;

                case IDM_FONT:
                    {
                        CHOOSEFONT cf = {0};
                        cf.lStructSize      = sizeof(CHOOSEFONT);
                        cf.hwndOwner        = hwnd;
                        cf.lpLogFont        = &ApiMonOptions.LogFont;
                        cf.Flags            = CF_BOTH | CF_INITTOLOGFONTSTRUCT;
                        if (ChooseFont( &cf )) {
                            HFONT hFontNew = CreateFontIndirect( &ApiMonOptions.LogFont );
                            if (hFontNew) {
                                SaveOptions();
                                cw.ChangeFont( hFontNew );
                                dw.ChangeFont( hFontNew );
                                pw.ChangeFont( hFontNew );
                                gw.ChangeFont( hFontNew );
                                tw.ChangeFont( hFontNew );
                                if (hFont) {
                                    DeleteObject( hFont );
                                }
                                hFont = hFontNew;
                            }
                        }
                    }
                    return 0;

                case IDM_COLOR:
                    {
                        CHOOSECOLOR cc = {0};
                        cc.lStructSize = sizeof(CHOOSECOLOR);
                        cc.hwndOwner = hwnd;
                        cc.Flags = CC_FULLOPEN;
                        cc.lpCustColors = ApiMonOptions.CustColors;
                        if (ApiMonOptions.CustColors[0] == 0) {
                            CopyMemory(
                                ApiMonOptions.CustColors,
                                CustomColors,
                                sizeof(CustomColors)
                                );
                        }
                        if (ChooseColor( &cc )) {
                            ApiMonOptions.Color = cc.rgbResult;
                            SaveOptions();
                            cw.ChangeColor( ApiMonOptions.Color );
                            dw.ChangeColor( ApiMonOptions.Color );
                            pw.ChangeColor( ApiMonOptions.Color );
                            gw.ChangeColor( ApiMonOptions.Color );
                            tw.ChangeColor( ApiMonOptions.Color );
                        }
                    }
                    return 0;

                case IDM_NEW_DLL:
                    CreateChildWindows( CHILD_DLL );
                    break;

                case IDM_NEW_COUNTER:
                    CreateChildWindows( CHILD_COUNTER );
                    break;

                case IDM_NEW_PAGE:
                    CreateChildWindows( CHILD_PAGE );
                    break;

                case IDM_CLEAR_COUNTERS:
                    cw.DeleteAllItems();
                    ClearApiCounters();
                    ClearApiTrace();
                    break;

                case IDM_GRAPH:
                    DisableToolbarState(IDM_GRAPH);
                    gw.Create(TRUE);
                    gw.ChangeFont( hFont );
                    gw.ChangeColor( ApiMonOptions.Color );
                    EnableToolbarState( IDM_LEGEND );
                    break;

                case IDM_LEGEND:
                    PostMessage( GetFocus(), WM_TOGGLE_LEGEND, 0, 0 );
                    break;

                case IDM_VIEW_TRACE:
                    tw.Create();
                    tw.ChangeFont( hFont );
                    tw.ChangeColor( ApiMonOptions.Color );
                    break;

                case IDM_HELP:
                    ProcessHelpRequest( hwnd, 0 );
                    break;

                case IDM_ABOUT:
                    ShellAbout( hwnd, "API Monitor", NULL, NULL );
                    break;

                default:
                    break;
            }
            break;

        case WM_TROJAN_COMPLETE:
            if ((ApiMonOptions.AutoRefresh)) {
                ApiMonTimerId = SetTimer( hwnd, 2, UiRefreshRate, ApiMonTimer );
            }
            GetLocalTime( &StartingLocalTime );
            BaseTime = GetTickCount();
            StartingTick = GetTickCount();
            EndingTick = 0;
            DebuggeStarted = TRUE;
            return 0;

        case WM_UPDATE_COUNTERS:
            cw.Update( TRUE );
            return 0;

        case WM_UPDATE_PAGE:
            pw.Update( TRUE );
            return 0;

        case WM_OPEN_LOG_FILE:
            if (strlen(CmdParamBuffer) >= MAX_PATH)
                return APICTRL_ERR_PARAM_TOO_LONG;

            if (CmdParamBuffer[0] != 0) {
                strcpy(LogFileName, CmdParamBuffer);
                strcpy(TraceFileName, CmdParamBuffer);
                strcat(TraceFileName,".trace");
            }
            else {
                LogFileName[0] = 0;
                TraceFileName[0] = 0;
            }

            ClearApiCounters();
            ClearApiTrace();
            return 0;

        case WM_CLOSE_LOG_FILE:
            if (strlen(CmdParamBuffer) >= MAX_PATH)
                return APICTRL_ERR_PARAM_TOO_LONG;

            if (CmdParamBuffer[0] != 0) {
                strcpy(LogFileName, CmdParamBuffer);
                strcpy(TraceFileName, CmdParamBuffer);
                strcat(TraceFileName,".trace");
            }

            if (LogFileName[0] == 0) {
                return APICTRL_ERR_NULL_FILE_NAME;
            }

            BOOL stat = LogApiCounts(LogFileName);
            stat |= LogApiTrace(TraceFileName);

            LogFileName[0] = 0;
            TraceFileName[0] = 0;

            return (stat ? 0 : APICTRL_ERR_FILE_ERROR);
    }
    return DefFrameProc( hwnd, hwndMDIClient, uMessage, wParam, lParam );
}

HWND
ChildCreate(
    HWND    hwnd
    )
{
    RECT rect;
    GetClientRect( hwnd, &rect );

    HWND hwndList = CreateWindow(
        WC_LISTVIEW,
        "",
        WS_CHILD | LVS_SINGLESEL | LVS_REPORT,
        0,
        0,
        rect.right - rect.left,
        rect.bottom - rect.top,
        hwnd,
        NULL,
        hInst,
        NULL
        );

    ShowWindow( hwndList, SW_SHOW );

    return hwndList;
}

BOOL
WinApp(
    HINSTANCE   hInstance,
    INT         nShowCmd,
    LPSTR       ProgName,
    LPSTR       Arguments,
    BOOL        GoImmediate
    )
{
    WNDCLASSEX  wc;
    MSG         msg;
    HACCEL      hAccelTable;
    LPSTR       p;


    hInst = hInstance;

    if (!SearchPath( NULL, HELP_FILE_NAME, NULL, sizeof(HelpFileName), HelpFileName, &p )) {
        strcpy( HelpFileName, HELP_FILE_NAME );
    }

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.hIconSm       = (HICON)LoadImage(
                           hInstance,
                           MAKEINTRESOURCE(IDI_APPICON),
                           IMAGE_ICON,
                           16,
                           16,
                           0
                           );
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName  = "ApiMon";
    wc.lpszClassName = "ApiMon";

    if (!RegisterClassEx(&wc)) {
        return FALSE;
    }

    cw.Register();
    dw.Register();
    pw.Register();
    gw.Register();
    tw.Register();

    hAccelTable = LoadAccelerators( hInstance, "ApiMon" );

    hwndFrame = CreateWindow(
        "ApiMon",
        "API Monitor",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    if (!hwndFrame) {
        return FALSE;
    }

    ShowWindow( hwndFrame, nShowCmd );
    UpdateWindow( hwndFrame );

    if (ProgName[0]) {
        PostMessage(
            hwndFrame,
            WM_INIT_PROGRAM,
            (WPARAM)ProgName,
            (LPARAM)Arguments
            );
        if (GoImmediate) {
            PostMessage( hwndFrame, WM_COMMAND, IDM_START, 0 );
        }
    }

    while (GetMessage( &msg, NULL, 0, 0 )) {
        if (!TranslateMDISysAccel( hwndMDIClient, &msg ))
            if (!TranslateAccelerator( msg.hwnd, hAccelTable, &msg )) {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
    }

    return TRUE;
}

VOID
__cdecl
PopUpMsg(
    char *format,
    ...
    )
{
    char buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);

    MessageBeep( MB_ICONEXCLAMATION );

    MessageBox(
        hwndFrame,
        buf,
        "ApiMon",
        MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION
        );
}

VOID
Fail(
    UINT Error
    )
{
    char szBuffer[1000];

    if (LoadString( hInst, Error, szBuffer, sizeof(szBuffer) )) {
        PopUpMsg(szBuffer);
    } else {
        LoadString( hInst, ERR_UNKNOWN, szBuffer, sizeof(szBuffer) );
        PopUpMsg(szBuffer, Error);
    }
    ExitProcess(1);
}

VOID
SaveOptions(
    VOID
    )
{
    switch (ChildFocus) {
        case CHILD_COUNTER:
            ApiMonOptions.CounterPosition.Flags |=  IS_FOCUS;
            ApiMonOptions.DllPosition.Flags     &= ~IS_FOCUS;
            ApiMonOptions.PagePosition.Flags    &= ~IS_FOCUS;
            break;

        case CHILD_DLL:
            ApiMonOptions.DllPosition.Flags     |=  IS_FOCUS;
            ApiMonOptions.CounterPosition.Flags &= ~IS_FOCUS;
            ApiMonOptions.PagePosition.Flags    &= ~IS_FOCUS;
            break;

        case CHILD_PAGE:
            ApiMonOptions.PagePosition.Flags    |=  IS_FOCUS;
            ApiMonOptions.CounterPosition.Flags &= ~IS_FOCUS;
            ApiMonOptions.DllPosition.Flags     &= ~IS_FOCUS;
            break;
    }

    RegSave( &ApiMonOptions );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\i386\disasm.cpp ===
#include "apimonp.h"
#pragma hdrstop

#include "disasm.h"
#include "reg.h"

/*****                     macros and defines                          *****/

#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)
#define MAXL     16
#define MAXOPLEN 10

#define OBOFFSET 26
#define OBOPERAND 34
#define OBLINEEND 77

/*****                     static tables and variables                 *****/

static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */
static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */
                           "bx+di",
                           "bp+si",
                           "bp+di",
                           "si",
                           "di",
                           "bp",
                           "bx"
                         };

static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */
                           "ecx",
                           "edx",
                           "ebx",
                           "esp",
                           "ebp",
                           "esi",
                           "edi"
                         };

static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS,
                           REGDS,  REGDS,  REGSS,  REGDS };
static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP,
                           REGESI, REGEDI, REGEBP, REGEBX };
static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI };

static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS,
                           REGSS,  REGSS,  REGDS,  REGDS };
static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX,
                           REGESP, REGEBP, REGESI, REGEDI };

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

static int              mod;            /* mod of mod/rm byte */
static int              rm;             /* rm of mod/rm byte */
static int              ttt;            /* return reg value (of mod/rm) */
static LPSTR            pMem;           /* current position in instruction */
static int              mode_32;        /* local addressing mode indicator */
static int              opsize_32;      /* operand size flag */

ULONG                   EAaddr[2];      //  offset of effective address
static int              EAsize[2];      //  size of effective address item
static char             *pchEAseg[2];   //  normal segment for operand

int                     G_mode_32 = 1;  /* global address mode indicator */

static BOOL          fMovX;          // indicates a MOVSX or MOVZX

//      internal function definitions

void DIdoModrm(HANDLE hProcess,char **, int, BOOL);

void OutputHexString(char **, char *, int);
void OutputHexValue(char **, char *, int, int);
void OutputHexCode(char **, char *, int);
void OutputString(char **, char *);
void OutputSymbol(HANDLE, char **, char *, int, int);

void OutputHexAddr(LPSTR*, ULONG);
USHORT GetSegRegValue(int);


/**** disasm - disassemble an 80x86/80x87 instruction
*
*  Input:
*       pOffset = pointer to offset to start disassembly
*       fEAout = if set, include EA (effective address)
*
*  Output:
*       pOffset = pointer to offset of next instruction
*       pchDst = pointer to result string
*
***************************************************************************/

BOOL
disasm(
    HANDLE hProcess,
    PULONG pOffset,
    LPSTR  pchDst,
    BOOL   fEAout
    )
{
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     cBytes=MAXL;                //  bytes read into instr buffer
    int     segOvr = 0;                 /* segment override opcode */
    char    membuf[MAXL];               /* current instruction buffer */
    char    *pEAlabel = "";             //  optional label for operand

    char    *pchResultBuf = pchDst;     //  working copy of pchDst pointer
    char    RepPrefixBuffer[32];        //  rep prefix buffer
    char    *pchRepPrefixBuf = RepPrefixBuffer; //  pointer to prefix buffer
    char    OpcodeBuffer[8];            //  opcode buffer
    char    *pchOpcodeBuf = OpcodeBuffer; //  pointer to opcode buffer
    char    OperandBuffer[80];          //  operand buffer
    char    *pchOperandBuf = OperandBuffer; //  pointer to operand buffer
    char    ModrmBuffer[80];            //  modRM buffer
    char    *pchModrmBuf = ModrmBuffer; //  pointer to modRM buffer
    char    EABuffer[42];               //  effective address buffer
    char    *pchEABuf = EABuffer;       //  pointer to EA buffer

    int     obOpcode = OBOFFSET;
    int     obOpcodeMin;
    int     obOpcodeMax;

    int     obOperand = OBOPERAND;
    int     obOperandMin;
    int     obOperandMax;

    int     cbOpcode;
    int     cbOperand;
    int     cbOffset;
    int     cbEAddr;

    int     fTwoLines = FALSE;

    fMovX = FALSE;
    EAsize[0] = EAsize[1] = 0;          //  no effective address
    pchEAseg[0] = dszDS_;
    pchEAseg[1] = dszES_;

    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */
    olen = alen = (1 + mode_32) << 1;   //  set operand/address lengths
                                        //  2 for 16-bit and 4 for 32-bit

    OutputHexAddr(&pchResultBuf, *pOffset);

    *pchResultBuf++ = ' ';

    if (!ReadMemory( hProcess, (PVOID) *pOffset, membuf, MAXL )) {
        return FALSE;
    }

                                        /* move full inst to local buffer */
    pMem = membuf;                      /* point to begin of instruction */
    opcode = (int)(UCHAR)*pMem++;             /* get opcode */
    OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
    action = actiontbl + distbl[opcode].opr; /* get operand action */

/*****          loop through all operand actions               *****/

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   /* alter the opcode if 32-bit */
                if (opsize_32) {
                    indx = *action++;
                    pchOpcodeBuf = &OpcodeBuffer[indx];
                    if (indx == 0)
                        OutputString(&pchOpcodeBuf, dszCWDE);
                    else {
                        *pchOpcodeBuf++ = 'd';
                        if (indx == 1)
                            *pchOpcodeBuf++ = 'q';
                        }
                    }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) {
                    if (opsize_32) {
                        indx = 4;
                        OpcodeBuffer[4] = 'd';
                        }
                    else
                        indx = 2;
                    }
                else
                    indx = 1;

                if (*action & 1) {
                    if (fEAout) {
                        EAaddr[0] = (ULONG)GetRegValue(REGESI);
                        EAsize[0] = indx;
                        }
                    }
                if (*action++ & 2) {
                    if (fEAout) {
                        EAaddr[1] = (ULONG)GetRegValue(REGEDI);
                        EAsize[1] = indx;
                        }
                    }
                break;

            case CHR:                   /* insert a character */
                *pchOperandBuf++ = *action++;
                break;

            case CREG:                  /* set debug, test or control reg */
                if ((opcode - 231) & 0x04)      //  remove bias from opcode
                    *pchOperandBuf++ = 't';
                else if ((opcode - 231) & 0x01)
                    *pchOperandBuf++ = 'd';
                else
                    *pchOperandBuf++ = 'c';
                *pchOperandBuf++ = 'r';
                *pchOperandBuf++ = (char)('0' + ttt);
                break;

            case SREG2:                 /* segment register */
                ttt = BIT53(opcode);    //  set value to fall through

            case SREG3:                 /* segment register */
                *pchOperandBuf++ = sregtab[ttt];  // reg is part of modrm
                *pchOperandBuf++ = 's';
                break;

            case BRSTR:                 /* get index to register string */
                ttt = *action++;        /*    from action table */
                goto BREGlabel;

            case BOREG:                 /* byte register (in opcode) */
                ttt = BIT20(opcode);    /* register is part of opcode */
                goto BREGlabel;

            case ALSTR:
                ttt = 0;                /* point to AL register */
BREGlabel:
            case BREG:                  /* general register */
                *pchOperandBuf++ = regtab[ttt * 2];
                *pchOperandBuf++ = regtab[ttt * 2 + 1];
                break;

            case WRSTR:                 /* get index to register string */
                ttt = *action++;        /*    from action table */
                goto WREGlabel;

            case VOREG:                 /* register is part of opcode */
                ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                ttt = 0;                /* point to eAX register */
VREGlabel:
            case VREG:                  /* general register */
                if (opsize_32)          /* test for 32bit mode */
                    *pchOperandBuf++ = 'e';
WREGlabel:
            case WREG:                  /* register is word size */
                *pchOperandBuf++ = regtab[ttt * 2 + 16];
                *pchOperandBuf++ = regtab[ttt * 2 + 17];
                break;

            case IST_ST:
                OutputString(&pchOperandBuf, "st(0),st");
                *(pchOperandBuf - 5) += (char)rm;
                break;

            case ST_IST:
                OutputString(&pchOperandBuf, "st,");
            case IST:
                OutputString(&pchOperandBuf, "st(0)");
                *(pchOperandBuf - 2) += (char)rm;
                break;

            case xBYTE:                 /* set instruction to byte only */
                EAsize[0] = 1;
                pEAlabel = "byte ptr ";
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                EAsize[0] = 2;
                pEAlabel = "word ptr ";
                break;

            case EDWORD:
                opsize_32 = 1;    //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                break;

            case QWORD:
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                break;

            case TTBYTE:
                EAsize[0] = 10;
                pEAlabel = "tbyte ptr ";
                break;

            case FARPTR:
                if (opsize_32) {
                    EAsize[0] = 6;
                    pEAlabel = "fword ptr ";
                    }
                else {
                    EAsize[0] = 4;
                    pEAlabel = "dword ptr ";
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (mod != 3)
                    OutputString(&pchOperandBuf, pEAlabel);
                else
                    EAsize[0] = 0;

            case MODRM:                 /* output modrm string */
                if (segOvr)             /* in case of segment override */
                    OutputString(&pchOperandBuf, distbl[segOvr].instruct);
                *pchModrmBuf = '\0';
                OutputString(&pchOperandBuf, ModrmBuffer);
                break;

            case ADDRP:                 /* address pointer */
                OutputHexString(&pchOperandBuf, pMem + olen, 2); // segment
                *pchOperandBuf++ = ':';
                OutputSymbol(hProcess, &pchOperandBuf, pMem, olen, segOvr);
                pMem += olen + 2;
                break;

            case REL8:                  /* relative address 8-bit */
                if (opcode == 0xe3 && mode_32) {
                    pchOpcodeBuf = OpcodeBuffer;
                    OutputString(&pchOpcodeBuf, dszJECXZ);
                    }
                tmp = (long)*(char *)pMem++; /* get the 8-bit rel offset */
                goto DoRelDispl;

            case REL16:                 /* relative address 16-/32-bit */
                tmp = 0;
                memmove(&tmp,pMem,sizeof(long));
                pMem += alen;           /* skip over offset */
DoRelDispl:
                tmp += *pOffset + (pMem - membuf); /* calculate address */
                OutputSymbol(hProcess, &pchOperandBuf, (char *) &tmp, alen, segOvr);
                                                   // address
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                OutputHexString(&pchOperandBuf, pMem, 1);  //  ubyte
                pMem++;
                break;

            case IB:                    /* operand is immediate byte */
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*pMem++ != 0x0a) // test post-opcode byte
                        OutputString(&pchOperandBuf, dszRESERVED);
                    break;
                    }
                olen = 1;               /* set operand length */
                goto DoImmed;

            case IW:                    /* operand is immediate word */
                olen = 2;               /* set operand length */

            case IV:                    /* operand is word or dword */
DoImmed:
                OutputHexValue(&pchOperandBuf, pMem, olen, FALSE);
                pMem += olen;
                break;

            case OFFS:                  /* operand is offset */
                EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             /* in case of segment override */
                    OutputString(&pchOperandBuf, distbl[segOvr].instruct);

                *pchOperandBuf++ = '[';
                OutputSymbol(hProcess,&pchOperandBuf, pMem, alen, segOvr);  //  offset
                pMem += alen;
                *pchOperandBuf++ = ']';
                break;

            case GROUP:                 /* operand is of group 1,2,4,6 or 8 */
                                        /* output opcode symbol */
                OutputString(&pchOpcodeBuf, group[*action++][ttt]);
                break;

            case GROUPT:                /* operand is of group 3,5 or 7 */
                indx = *action;         /* get indx into group from action */
                goto doGroupT;

            case EGROUPT:               /* x87 ESC (D8-DF) group index */
                indx = BIT20(opcode) * 2; /* get group index from opcode */
                if (mod == 3) {         /* some operand variations exists */
                                        /*   for x87 and mod == 3 */
                    ++indx;             /* take the next group table entry */
                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */
                        if (ttt > 3) {  /* for those D9 instructions */
                            indx = 12 + ttt; /* offset index to table by 12 */
                            ttt = rm;   /* set secondary index to rm */
                            }
                        }
                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */
                        if (ttt == 4)   /* only valid if ttt==4 */
                            ttt = rm;   /* set secondary group table index */
                        else
                            ttt = 7;    /* no an x87 instruction */
                        }
                    }
doGroupT:
                /* handle group with different types of operands */

                OutputString(&pchOpcodeBuf, groupt[indx][ttt].instruct);
                action = actiontbl + groupt[indx][ttt].opr;
                                                        /* get new action */
                break;

            case OPC0F:                 /* secondary opcode table (opcode 0F) */
                opcode = *pMem++;       /* get real opcode */
                fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 7) /* for the first 7 opcodes */
                    opcode += 256;      /* point begin of secondary opcode tab. */
                else if (opcode > 0x1f && opcode < 0x32)
                    opcode += 231;      /* adjust for non-existing opcodes */
                else if (opcode > 0x2f && opcode < 0x33)
                    opcode += 222;      /* adjust for non-existing opcodes */
                else if (opcode > 0x7e && opcode < 0xd0)
                    opcode += 148;      /* adjust for non-existing opcodes */
                else
                    opcode = 260;       /* all non-existing opcodes */
                goto getNxtByte1;

            case ADR_OVR:               /* address override */
                mode_32 = !G_mode_32;   /* override addressing mode */
                alen = (mode_32 + 1) << 1; /* toggle address length */
                goto getNxtByte;

            case OPR_OVR:               /* operand size override */
                opsize_32 = !G_mode_32; /* override operand size */
                olen = (opsize_32 + 1) << 1; /* toggle operand length */
                goto getNxtByte;

            case SEG_OVR:               /* handle segment override */
                segOvr = opcode;        /* save segment override opcode */
                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
                goto getNxtByte;

            case REP:                   /* handle rep/lock prefixes */
                *pchOpcodeBuf = '\0';
                if (pchRepPrefixBuf != RepPrefixBuffer)
                    *pchRepPrefixBuf++ = ' ';
                OutputString(&pchRepPrefixBuf, OpcodeBuffer);
                pchOpcodeBuf = OpcodeBuffer;
getNxtByte:
                opcode = (int)(UCHAR)*pMem++;        /* next byte is opcode */
getNxtByte1:
                action = actiontbl + distbl[opcode].opr;
                OutputString(&pchOpcodeBuf, distbl[opcode].instruct);

            default:                    /* opcode has no operand */
                break;
            }
        switch (action2) {              /* secondary action */
            case MRM:                   /* generate modrm for later use */
                if (!mrm) {             /* ignore if it has been generated */
                    DIdoModrm(hProcess, &pchModrmBuf, segOvr, fEAout);
                                        /* generate modrm */
                    mrm = TRUE;         /* remember its generation */
                    }
                break;

            case COM:                   /* insert a comma after operand */
                *pchOperandBuf++ = ',';
                break;

            case END:                   /* end of instruction */
                end = TRUE;
                break;
            }
 } while (!end);                        /* loop til end of instruction */

/*****       prepare disassembled instruction for output              *****/

    instlen = pMem - membuf;

    if (instlen < cBytes)
        cBytes = instlen;

    OutputHexCode(&pchResultBuf, membuf, cBytes);

    if (instlen > cBytes) {
        *pchResultBuf++ = '?';
        *pchResultBuf++ = '?';
        (*pOffset)++;                   //  point past unread byte
        }

    *pOffset += instlen;                /* set instruction length */

    if (instlen > cBytes) {
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + OBOFFSET);
        OutputString(&pchResultBuf, "???");
        *pchResultBuf++ = '\0';
        return FALSE;
        }

    //  if fEAout is set, build each EA with trailing space in EABuf
    //  point back over final trailing space if buffer nonnull

    if (fEAout) {

        for (indx = 0; indx < 2; indx++)
            if (EAsize[indx]) {
                OutputString(&pchEABuf, segOvr ? distbl[segOvr].instruct
                                               : pchEAseg[indx]);
                OutputHexAddr(&pchEABuf, EAaddr[indx]);
                *pchEABuf++ = '=';

                tmp = ReadMemory( hProcess, (PVOID) EAaddr[indx], membuf, EAsize[indx] );
                if (tmp == EAsize[indx])
                    OutputHexString(&pchEABuf, (char *)membuf, EAsize[indx]);
                else
                    while (EAsize[indx]--) {
                        *pchEABuf++ = '?';
                        *pchEABuf++ = '?';
                        }
                *pchEABuf++ = ' ';
                }
        if (pchEABuf != EABuffer)
            pchEABuf--;
        }

    //  compute lengths of component strings.
    //  if the rep string is nonnull,
    //      add the opcode string length to the operand
    //      make the rep string the opcode string

    cbOffset = pchResultBuf - pchDst;
    cbOperand = pchOperandBuf - OperandBuffer;
    cbOpcode = pchOpcodeBuf - OpcodeBuffer;
    if (pchRepPrefixBuf != RepPrefixBuffer) {
        cbOperand += cbOpcode + (cbOperand != 0);
        cbOpcode = pchRepPrefixBuf - RepPrefixBuffer;
        }
    cbEAddr = pchEABuf - EABuffer;

    //  for really long strings, where the opcode and operand
    //      will not fit on a 77-character line, make two lines
    //      with the opcode on offset 0 on the second line with
    //      the operand following after one space

    if (cbOpcode + cbOperand > OBLINEEND - 1) {
        fTwoLines = TRUE;
        obOpcode = 0;
        obOperand = cbOpcode + 1;
        }
    else {

        //  compute the minimum and maximum offset values for
        //      opcode and operand strings.
        //  if strings are nonnull, add extra for separating space

        obOpcodeMin = cbOffset + 1;
        obOperandMin = obOpcodeMin + cbOpcode + 1;
        obOperandMax = OBLINEEND - cbEAddr - (cbEAddr != 0) - cbOperand;
        obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;

        //  if minimum offset is more than the maximum, the strings
        //      will not fit on one line.  recompute the min/max
        //      values with no offset and EA strings.

        if (obOpcodeMin > obOpcodeMax) {
            fTwoLines = TRUE;
            obOpcodeMin = 0;
            obOperandMin = cbOpcode + 1;
            obOperandMax = OBLINEEND - cbOperand;
            obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;
            }

        //  compute the opcode and operand offsets.  set offset as
        //      close to the default values as possible.

        if (obOpcodeMin > OBOFFSET)
            obOpcode = obOpcodeMin;
        else if (obOpcodeMax < OBOFFSET)
            obOpcode = obOpcodeMax;

        obOperandMin = obOpcode + cbOpcode + 1;

        if (obOperandMin > OBOPERAND)
            obOperand = obOperandMin;
        else if (obOperandMax < OBOPERAND)
            obOperand = obOperandMax;
        }

    //  build the resultant string with the offsets computed

    //  if two lines are to be output,
    //      append the EAddr string
    //      output a new line and reset the pointer

    if (fTwoLines) {
        if (pchEABuf != EABuffer) {
            do
                *pchResultBuf++ = ' ';
            while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
            *pchEABuf = '\0';
            OutputString(&pchResultBuf, EABuffer);
            OutputString(&pchResultBuf, "\n        ");
            }
        pchDst = pchResultBuf;
        }

    //  output rep, opcode, and operand strings

    do
        *pchResultBuf++ = ' ';
    while (pchResultBuf < pchDst + obOpcode);

    if (pchRepPrefixBuf != RepPrefixBuffer) {
        *pchRepPrefixBuf = '\0';
        OutputString(&pchResultBuf, RepPrefixBuffer);
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + obOperand);
        }

    *pchOpcodeBuf = '\0';
    OutputString(&pchResultBuf, OpcodeBuffer);

    if (pchOperandBuf != OperandBuffer) {
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + obOperand);
        *pchOperandBuf = '\0';
        OutputString(&pchResultBuf, OperandBuffer);
        }

    //  if one line is to be output, append the EAddr string

    if (!fTwoLines && pchEABuf != EABuffer) {
        *pchEABuf = '\0';
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
        OutputString(&pchResultBuf, EABuffer);
        }

    *pchResultBuf = '\0';
    return TRUE;
}

/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void
DIdoModrm (HANDLE hProcess, char **ppchBuf, int segOvr, BOOL fEAout)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *pMem++;                      /* get the mrm byte from instruction */
    mod = BIT76(mrm);                   /* get mod */
    ttt = BIT53(mrm);                   /* get reg - used outside routine */
    rm  = BIT20(mrm);                   /* get rm */

    if (mod == 3) {                     /* register only mode */
        src = &regtab[rm * 2];          /* point to 16-bit register */
        if (EAsize[0] > 1) {
            src += 16;                  /* point to 16-bit register */
            if (opsize_32 && !fMovX)
                *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */
            }
        *(*ppchBuf)++ = *src++;         /* copy register name */
        *(*ppchBuf)++ = *src;
        EAsize[0] = 0;                  //  no EA value to output
        return;
        }

    if (mode_32) {                      /* 32-bit addressing mode */
        oldrm = rm;
        if (rm == 4) {                  /* rm == 4 implies sib byte */
            sib = *pMem++;              /* get s_i_b byte */
            rm = BIT20(sib);            /* return base */
            }

        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 5) {
            OutputSymbol(hProcess,ppchBuf, pMem, 4, segOvr); // offset
            pMem += 4;
            }
        else {
            if (fEAout) {
                if (segOvr) {
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                    pchEAseg[0] = distbl[segOvr].instruct;
                    }
                else if (reg32[rm] == REGEBP || reg32[rm] == REGESP) {
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                    pchEAseg[0] = dszSS_;
                    }
                else
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                }
            OutputString(ppchBuf, mrmtb32[rm]);
            }

        if (oldrm == 4) {               //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4) {
                *(*ppchBuf)++ = '+';
                OutputString(ppchBuf, mrmtb32[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1) {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                    }
                if (fEAout)
                    EAaddr[0] = (ULONG)GetRegValue(reg32[ind]);
                }
            }
        }
    else {                              //  16-bit addressing mode
        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 6) {
            OutputSymbol(hProcess,ppchBuf, pMem, 2, segOvr);   // 16-bit offset
            pMem += 2;
            }
        else {
            if (fEAout) {
                if (segOvr) {
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                    pchEAseg[0] = distbl[segOvr].instruct;
                    }
                else if (reg16[rm] == REGEBP) {
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                    pchEAseg[0] = dszSS_;
                    }
                else
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                if (rm < 4)
                    EAaddr[0] += (ULONG)GetRegValue(reg16_2[rm]);
            }
            OutputString(ppchBuf, mrmtb16[rm]);
            }
        }

    //  output any displacement

    if (mod == 1) {
        if (fEAout)
            EAaddr[0] += (ULONG)pMem;
        OutputHexValue(ppchBuf, pMem, 1, TRUE);
        pMem++;
        }
    else if (mod == 2) {
        long tmp = 0;
        if (mode_32) {
            memmove(&tmp,pMem,sizeof(long));
            if (fEAout)
                EAaddr[0] += (ULONG)tmp;
            OutputHexValue(ppchBuf, pMem, 4, TRUE);
            pMem += 4;
            }
        else {
            memmove(&tmp,pMem,sizeof(short));
            if (fEAout)
                EAaddr[0] += tmp;
            OutputHexValue(ppchBuf, pMem, 2, TRUE);
            pMem += 2;
            }
        }

    if (!mode_32 && fEAout) {
        EAaddr[0] &= 0xffff;
        EAaddr[1] &= 0xffff;
    }

    *(*ppchBuf)++ = ']';
}

/*** OutputHexValue - output hex value
*
*   Purpose:
*       Output the value pointed by *ppchBuf of the specified
*       length.  The value is treated as signed and leading
*       zeroes are not printed.  The string is prefaced by a
*       '+' or '-' sign as appropriate.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value (1, 2, and 4 supported)
*       fDisp - set if displacement to output '+'
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void OutputHexValue (char **ppchBuf, char *pchMemBuf, int length, int fDisp)
{
    long    value;
    int     index;
    char    digit[8];

    value = 0;
    if (length == 1)
        value = (long)(*(char *)pchMemBuf);
    else if (length == 2)
        memmove(&value,pchMemBuf,2);
    else
        memmove(&value,pchMemBuf,sizeof(long));

    length <<= 1;               //  shift once to get hex length

    if (value != 0 || !fDisp) {
        if (fDisp)
            if (value < 0 && length == 2) {   //  use neg value for byte
                value = -value;               //    displacement
                *(*ppchBuf)++ = '-';
                }
            else
                *(*ppchBuf)++ = '+';

        *(*ppchBuf)++ = '0';
        *(*ppchBuf)++ = 'x';
        for (index = length - 1; index != -1; index--) {
            digit[index] = (char)(value & 0xf);
            value >>= 4;
            }
        index = 0;
        while (digit[index] == 0 && index < length - 1)
            index++;
        while (index < length)
            *(*ppchBuf)++ = hexdigit[digit[index++]];
        }
}

/*** OutputHexString - output hex string
*
*   Purpose:
*       Output the value pointed by *ppchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*       *ppchMemBuf - pointer update to next memory byte
*
*************************************************************************/

void
OutputHexString (char **ppchBuf, char *pchValue, int length)
{
    unsigned char    chMem;

    pchValue += length;
    while (length--) {
        chMem = *--pchValue;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
        }
}

/*** OutputHexCode - output hex code
*
*   Purpose:
*       Output the code pointed by pchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.  This differs from OutputHexString
*       in that bytes are printed from low to high addresses.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputHexCode (char **ppchBuf, char *pchMemBuf, int length)
{
    unsigned char    chMem;

    while (length--) {
        chMem = *pchMemBuf++;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
        }
}

/*** OutputString - output string
*
*   Purpose:
*       Copy the string into the buffer pointed by *ppBuf.
*
*   Input:
*       *pStr - pointer to string
*
*   Output:
*       *ppBuf points to next character in buffer.
*
*************************************************************************/

void
OutputString (char **ppBuf, char *pStr)
{
    while (*pStr)
        *(*ppBuf)++ = *pStr++;
}

/*** OutputSymbol - output symbolic value
*
*   Purpose:
*       Output the value in outvalue into the buffer
*       pointed by *pBuf.  Express the value as a
*       symbol plus displacment, if possible.
*
*   Input:
*       *ppBuf - pointer to text buffer to fill
*       *pValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputSymbol (HANDLE hProcess, char **ppBuf, char *pValue, int length, int segOvr)
{
    ULONG               displacement;
    ULONG               value;
    char                *szSymName;

    value = 0;
    if (length == 1)
        value = (long)(*(char *)pValue);
    else if (length == 2)
        memmove(&value,pValue,sizeof(short));
    else
        memmove(&value,pValue,sizeof(long));

    EAaddr[0] = value;

    if (SymGetSymFromAddr( hProcess, value, &displacement, sym )) {
        OutputString(ppBuf, sym->Name);
        OutputHexValue(ppBuf, (char *)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
        }
    else
        OutputHexString(ppBuf, pValue, length);
}

/*** X86GetNextOffset - compute offset for trace or step
*
*   Purpose:
*       From a limited disassembly of the instruction pointed
*       by the FIR register, compute the offset of the next
*       instruction for either a trace or step operation.
*
*   Input:
*       fStep - TRUE if step offset returned - FALSE for trace offset
*
*   Returns:
*       step or trace offset if input is TRUE or FALSE, respectively
*       -1 returned for trace flag to be used
*
*************************************************************************/

ULONG
GetNextOffset(
    HANDLE  hProcess,
    ULONG   Address,
    BOOL    fStep
    )
{
    int     mode_32;
    int     opsize_32;
    int     cBytes = 0;
    char    membuf[MAXL];               //  current instruction buffer
    ULONG   addrReturn;
    USHORT  retAddr[3];                 //  return address buffer
    char    *pMem;
    UCHAR   opcode;
    int     fPrefix = TRUE;
    int     fRepPrefix = FALSE;
    int     ttt;
    int     rm;
    ULONG   instroffset;
    ULONG   pcaddr;
    int     subcode;

    //  read instruction stream bytes into membuf and set mode and
    //      opcode size flags

    if (Address) {
        pcaddr = Address;
    } else {
        pcaddr = (ULONG)GetRegValue(REGEIP);
    }
    instroffset = pcaddr;
    G_mode_32 = TRUE;
    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */

    cBytes = ReadMemory( hProcess, (PVOID) pcaddr, membuf, MAXL );
    if (!cBytes) {
        return (ULONG)-1;
    }

                                        /* move full inst to local buffer */
    pMem = membuf;                      /* point to begin of instruction */

    //  read and process any prefixes first

    do {
        opcode = (UCHAR)*pMem++;        /* get opcode */
        if (opcode == 0x66)
            opsize_32 = !G_mode_32;
        else if (opcode == 0x67)
            mode_32 = !G_mode_32;
        else if ((opcode & ~1) == 0xf2)
            fRepPrefix = TRUE;
        else if (opcode != 0xf0 && (opcode & ~0x18) != 0x26
                                && (opcode & ~1) != 0x64)
            fPrefix = FALSE;
        }
    while (fPrefix);

    //  for instructions that alter the TF (trace flag), return the
    //      offset of the next instruction despite the flag of fStep

    if (((opcode & ~0x3) == 0x9c))
        //  9c-9f, pushf, popf, sahf, lahf
        ;

    else if (opcode == 0xcf) {          //  cf - iret - get RA from stack

        addrReturn = (ULONG)GetRegValue(REGESP);
        if (!ReadMemory( hProcess, (PVOID) addrReturn, retAddr, sizeof(retAddr) )) {
            return (ULONG)-1;
        }
        return retAddr[2];
    }
    else if (opcode == 0xc4 && *pMem == 0xc4 ) {
            subcode = *(pMem+1);
            if ( subcode == 0x50 ||
                 subcode == 0x52 ||
                 subcode == 0x53 ||
                 subcode == 0x54 ||
                 subcode == 0x57 ||
                 subcode == 0x58 ||
                 subcode == 0x5D ) {
                pMem += 3;
            } else {
                pMem += 2;
            }
    }
    else if (!fStep) {
        instroffset = (ULONG)-1;
    }

    //  repeated string/port instructions

    if (opcode == 0xe8)            //  near direct jump
        pMem += (1 + opsize_32) * 2;

    else if (opcode == 0x9a)            //  far direct jump
        pMem += (2 + opsize_32) * 2;

    else if (opcode == 0xcd ||
             (opcode >= 0xe0 && opcode <= 0xe2)) //  loop / int nn instrs
        pMem++;

    else if (opcode == 0xff) {          //  indirect call - compute length
        opcode = *pMem++;               //  get modRM
        ttt = BIT53(opcode);
        if ((ttt & ~1) == 2) {
            mod = BIT76(opcode);
            if (mod != 3) {                     //  nonregister operand
                rm = BIT20(opcode);
                if (mode_32) {
                    if (rm == 4)
                        rm = BIT20(*pMem++);    //  get base from SIB
                    if (mod == 0) {
                        if (rm == 5)
                            pMem += 4;          //  long direct address
                        }                       //  else register
                    else if (mod == 1)
                        pMem++;                 //  register with byte offset
                    else
                        pMem += 4;              //  register with long offset
                    }
                else {                          //  16-bit mode
                    if (mod == 0) {
                        if (rm == 6)
                            pMem += 2;          //  short direct address
                        }
                    else
                        pMem += mod;            //  reg, byte, word offset
                    }
                }
            }
        else
            instroffset = (ULONG)-1;            //  0xff, but not call
        }

    else if (!((fRepPrefix && ((opcode & ~3) == 0x6c ||
                               (opcode & ~3) == 0xa4 ||
                               (opcode & ~1) == 0xaa ||
                               (opcode & ~3) == 0xac)) ||
                               opcode == 0xcc || opcode == 0xce))
        instroffset = (ULONG)-1;                //  not repeated string op
                                                //  or int 3 / into

    //  if not enough bytes were read for instruction parse,
    //      just give up and trace the instruction

    if (cBytes < pMem - membuf) {
        instroffset = (ULONG)-1;
    }

    //  if not tracing, compute the new instruction offset

    if (instroffset != (ULONG)-1) {
        instroffset += pMem - membuf;
    }

    return instroffset;
}

void
OutputHexAddr (LPSTR *ppBuffer, ULONG offset)
{
    OutputHexString(ppBuffer, (char *)&offset, sizeof(ULONG));
}

USHORT
GetSegRegValue (int segOpcode)
{
    ULONG    regnum;

    switch (segOpcode) {
        case 0x26:
            regnum = REGES;
            break;
        case 0x2e:
            regnum = REGCS;
            break;
        case 0x36:
            regnum = REGSS;
            break;
        case 0x64:
            regnum = REGFS;
            break;
        case 0x65:
            regnum = REGGS;
            break;
        case 0x3e:
        default:
            regnum = REGDS;
        }

    return (USHORT)GetRegValue(regnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for APIMON's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


//
// general
//
#define WINDOWMENU                      2
#define IDC_STATIC                     -1

//
// dialogs
//
#define IDD_FILE_NAMES                  101
#define IDD_MISC                        102
#define IDD_KNOWN_DLLS                  103
#define IDD_GRAPH                       104
#define IDD_HELP                        105

//
// strings
//
#define IDS_DESCRIPTION                 201
#define IDS_SYSMENU                     202
#define IDS_MDISYSMENU                  203
#define IDS_FILEMENU                    204
#define IDS_WINDOWMENU                  205
#define IDS_HELPMENU                    206
#define IDS_SCSIZE                      SC_SIZE
#define IDS_SCMOVE                      SC_MOVE
#define IDS_SCMINIMIZE                  SC_MINIMIZE
#define IDS_SCMAXIMIZE                  SC_MAXIMIZE
#define IDS_SCNEXTWINDOW                SC_NEXTWINDOW
#define IDS_SCPREVWINDOW                SC_PREVWINDOW
#define IDS_SCCLOSE                     SC_CLOSE
#define IDS_SCRESTORE                   SC_RESTORE
#define IDS_SCTASKLIST                  SC_TASKLIST

//
// menu items
//
#define IDM_EXIT                        301
#define IDM_WINDOWTILE                  302
#define IDM_WINDOWCASCADE               303
#define IDM_WINDOWICONS                 304
#define IDM_ABOUT                       305
#define IDM_STATUSBAR                   306
#define IDM_START                       307
#define IDM_STOP                        308
#define IDM_TOOLBAR                     309
#define IDM_OPTIONS                     310
#define IDM_SAVE_OPTIONS                311
#define IDM_FILEOPEN                    312
#define IDM_WRITE_LOG                   313
#define IDM_FONT                        314
#define IDM_COLOR                       315
#define IDM_NEW_DLL                     316
#define IDM_NEW_COUNTER                 317
#define IDM_CLEAR_COUNTERS              318
#define IDM_NEW_PAGE                    319
#define IDM_WINDOWTILE_HORIZ            320
#define IDM_GRAPH                       321
#define IDM_NEW_GRAPH                   322
#define IDM_REFRESH                     323
#define IDM_LEGEND                      324
#define IDM_HELP                        325
#define IDM_VIEW_TRACE                  326
#define IDM_WINDOWCHILD                 327   // MUST be the last IDM constant

//
// bitmaps
//
#define IDB_TOOLBAR                     401
#define IDB_CHECKSTATES                 402

//
// icons
//
#define IDI_APPICON                     501
#define IDI_CHILDICON                   502

//
// controls
//
#define IDC_LOG_FILE_NAME               600
#define IDC_TRACE_FILE_NAME             601
#define IDC_ENABLE_TRACING              602
#define IDC_SYMBOL_PATH                 603
#define IDC_DISABLE_HEAP                604
#define IDC_PRELOAD_SYMBOLS             605
#define IDC_ENABLE_COUNTERS             606
#define IDC_GO_IMMEDIATE                607
#define IDC_DISABLE_FAST_COUNTERS       608
#define IDC_DEFSORT_NAME                609
#define IDC_DEFSORT_COUNTER             610
#define IDC_DEFSORT_TIME                611
#define IDC_USE_KNOWN_DLLS              612
#define IDC_KNOWN_DLLS                  613
#define IDC_PAGE_FAULTS                 614
#define IDC_EXCLUDE_KNOWN_DLLS          615
#define IDC_DISPLAY_LEGENDS             616
#define IDC_FILTER_BAR                  617
#define IDC_FILTER_NUMBER               618
#define IDC_FILTER_SLIDER               619
#define IDC_AUTO_REFRESH                620
#define IDC_ENABLE_ALIASING             621
#define IDC_DLL_SORTING                 622

//
// help ids
//
#define IDH_ABOUT                       700
#define IDH_CLEAR_COUNTERS              701
#define IDH_COLOR                       702
#define IDH_COMMAND_LINE                703
#define IDH_CONTENTS                    704
#define IDH_DEFSORT_COUNTER             705
#define IDH_DEFSORT_NAME                706
#define IDH_DEFSORT_TIME                707
#define IDH_DISABLE_FAST_COUNTERS       708
#define IDH_DISABLE_HEAP                709
#define IDH_DLLS_OPTIONS                710
#define IDH_ENABLE_COUNTERS             711
#define IDH_ENABLE_TRACING              712
#define IDH_EXIT                        713
#define IDH_FILEOPEN                    714
#define IDH_FNAME_OPTIONS               715
#define IDH_FONT                        716
#define IDH_GO_IMMEDIATE                717
#define IDH_HOW_TO_USE                  718
#define IDH_KNOWN_DLLS                  719
#define IDH_LOG_FILE_NAME               720
#define IDH_MISC_OPTIONS                721
#define IDH_NEW_COUNTER                 722
#define IDH_NEW_DLL                     723
#define IDH_NEW_PAGE                    724
#define IDH_OPTIONS                     725
#define IDH_PAGE_FAULTS                 726
#define IDH_PRELOAD_SYMBOLS             727
#define IDH_SAVE_OPTIONS                728
#define IDH_START                       729
#define IDH_STATUSBAR                   730
#define IDH_STOP                        731
#define IDH_SYMBOL_PATH                 732
#define IDH_TOOLBAR                     733
#define IDH_TRACE_FILE_NAME             734
#define IDH_USE_KNOWN_DLLS              735
#define IDH_WHAT_IS                     736
#define IDH_WINDOWCASCADE               737
#define IDH_WINDOWICONS                 738
#define IDH_WINDOWTILE                  739
#define IDH_WINDOWTILE_HORIZ            740
#define IDH_WRITE_LOG                   741
#define IDH_EXCLUDE_KNOWN_DLLS          742

//
// cursors
//
#define IDC_HAND_INTERNAL               801
#define IDC_HSPLIT                      802


//
// Error IDs
//
#define ERR_UNKNOWN                             901
#define ERR_RESOURCE                            902
#define ERR_PAGEFILE                            903
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\i386\reg.h ===
#define	REGGS		0
#define	REGFS		1
#define	REGES		2
#define	REGDS		3
#define	REGEDI		4
#define	REGESI		5
#define	REGEBX		6
#define	REGEDX		7
#define	REGECX		8
#define	REGEAX		9
#define	REGEBP		10
#define	REGEIP		11
#define	REGCS		12
#define	REGEFL		13
#define	REGESP		14
#define	REGSS		15

#ifdef	KERNEL
#define REGCR0		16
#define REGCR2		17
#define REGCR3		18
#define REGCR4          19
#endif

#define REGDR0          20
#define REGDR1          21
#define REGDR2          22
#define REGDR3          23
#define REGDR6          24
#define REGDR7          25

#ifdef	KERNEL
#define REGGDTR         26
#define REGGDTL         27
#define REGIDTR         28
#define REGIDTL         29
#define REGTR           30
#define REGLDTR         31
#endif

// Pseudo-registers:
#define	PREGEA		40
#define PREGBASE    PREGEA
#define	PREGEXP		41
#define PREGRA		42
#define PREGP		43
#define	PREGU0		44
#define	PREGU1		45
#define	PREGU2		46
#define	PREGU3		47
#define	PREGU4		48
#define	PREGU5		49
#define	PREGU6		50
#define	PREGU7		51
#define	PREGU8		52
#define	PREGU9		53

#define	FLAGBASE	100
#define	REGDI		100
#define	REGSI		101
#define	REGBX		102
#define	REGDX		103
#define	REGCX		104
#define	REGAX		105
#define	REGBP		106
#define	REGIP		107
#define	REGFL		108
#define	REGSP		109
#define	REGBL		110
#define	REGDL		111
#define	REGCL		112
#define	REGAL		113
#define	REGBH		114
#define	REGDH		115
#define	REGCH		116
#define	REGAH		117
#define	FLAGIOPL	118
#define	FLAGOF		119
#define	FLAGDF		120
#define	FLAGIF		121
#define	FLAGTF		122
#define	FLAGSF		123
#define	FLAGZF		124
#define	FLAGAF		125
#define FLAGPF		126
#define FLAGCF		127

#define REGFIR		REGEIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\i386\disasm.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/



/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMP[]       = "cmp";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCS_[]       = "cs:";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDS_[]       = "ds:";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCOM[]      = "fcom";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOADALL[]   = "loadall";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMOV[]       = "mov";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszRCL[]       = "rcl";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszTEST[]      = "test";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TTBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulb         O_Ib+1
#define O_Imul          O_Imulb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_length        O_AX_oReg+3

#if( O_length > 255 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static UCHAR actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TTBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END
                  };
#ifdef _M_IX86
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    unsigned char opr;
    } Tdistbl;

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulb,                  /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Rel8,                   /* 70 JO                         */
    dszJNO,   O_Rel8,                   /* 71 JNO                        */
    dszJB,    O_Rel8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Rel8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Rel8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Rel8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Rel8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Rel8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Rel8,                   /* 78 JS                         */
    dszJNS,   O_Rel8,                   /* 79 JNS                        */
    dszJPE,   O_Rel8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Rel8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Rel8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Rel8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Rel8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Rel8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Rel8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    dszMULTI, O_GROUP6,                 /* 0 MULTI                       */
    dszMULTI, O_GROUP7,                 /* 1 MULTI                       */
    dszLAR,   O_Reg_Modrm,              /* 2 LAR                         */
    dszLSL,   O_Reg_Modrm,              /* 3 LSL                         */
    dszRESERVED, O_DoDB,                /* 4                             */
    dszLOADALL, O_NoOperands,           /* 5 LOADALL                     */
    dszCLTS,  O_NoOperands,             /* 6 CLTS                        */
    dszMOV,   O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    dszMOV,   O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    dszMOV,   O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    dszMOV,   O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    dszMOV,   O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,   O_CReg_Modrm,             /* 26 MOV Td,Rd                  */
    dszRESERVED, O_DoDB,                /* 27                            */
    dszRESERVED, O_DoDB,                /* 28                            */
    dszRESERVED, O_DoDB,                /* 29                            */
    dszRESERVED, O_DoDB,                /* 2A                            */
    dszRESERVED, O_DoDB,                /* 2B                            */
    dszRESERVED, O_DoDB,                /* 2C                            */
    dszRESERVED, O_DoDB,                /* 2D                            */
    dszRESERVED, O_DoDB,                /* 2E                            */
    dszRESERVED, O_DoDB,                /* 2F                            */
    dszRESERVED, O_DoDB,                /* 30                            */
    dszRDTSC, O_NoOperands,             /* 31 RDTSC                      */

    dszSETNL, O_bModrm,                 /* 7D SETNL                      */
    dszRESERVED, O_DoDB,                /* 7E                            */
    dszRESERVED, O_DoDB,                /* 7F                            */
    dszJO,    O_Rel16,                  /* 80 JO                         */
    dszJNO,   O_Rel16,                  /* 81 JNO                        */
    dszJB,    O_Rel16,                  /* 82 JB                         */
    dszJNB,   O_Rel16,                  /* 83 JNB                        */
    dszJE,    O_Rel16,                  /* 84 JE                         */
    dszJNE,   O_Rel16,                  /* 85 JNE                        */
    dszJBE,   O_Rel16,                  /* 86 JBE                        */
    dszJNBE,  O_Rel16,                  /* 87 JNBE                       */
    dszJS,    O_Rel16,                  /* 88 JS                         */
    dszJNS,   O_Rel16,                  /* 89 JNS                        */
    dszJP,    O_Rel16,                  /* 8A JP                         */
    dszJNP,   O_Rel16,                  /* 8B JNP                        */
    dszJL,    O_Rel16,                  /* 8C JL                         */
    dszJNL,   O_Rel16,                  /* 8D JNL                        */
    dszJLE,   O_Rel16,                  /* 8E JLE                        */
    dszJNLE,  O_Rel16,                  /* 8F JNLE                       */
    dszSETO,  O_bModrm,                 /* 90 SETO                       */
    dszSETNO, O_bModrm,                 /* 91 SETNO                      */
    dszSETB,  O_bModrm,                 /* 92 SETB                       */
    dszSETNB, O_bModrm,                 /* 93 SETNB                      */
    dszSETE,  O_bModrm,                 /* 94 SETE                       */
    dszSETNE, O_bModrm,                 /* 95 SETNE                      */
    dszSETBE, O_bModrm,                 /* 96 SETBE                      */
    dszSETA,  O_bModrm,                 /* 97 SETNBE                     */
    dszSETS,  O_bModrm,                 /* 98 SETS                       */
    dszSETNS, O_bModrm,                 /* 99 SETNS                      */
    dszSETP,  O_bModrm,                 /* 9A SETP                       */
    dszSETNP, O_bModrm,                 /* 9B SETNP                      */
    dszSETL,  O_bModrm,                 /* 9C SETL                       */
    dszSETGE, O_bModrm,                 /* 9D SETGE                      */
    dszSETLE, O_bModrm,                 /* 9E SETLE                      */
    dszSETNLE,O_bModrm,                 /* 9F SETNLE                     */
    dszPUSH,  O_sReg2,                  /* A0 PUSH FS                    */
    dszPOP,   O_sReg2,                  /* A1 POP FS                     */
    dszRESERVED, O_DoDB,                /* A2                            */
    dszBT,    O_Modrm_Reg,              /* A3 BT                         */
    dszSHLD,  O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    dszSHLD,  O_Modrm_Reg_CL,           /* A5 SHLD                       */
    dszCMPXCHG,O_bModrm_Reg,            /* A6 XBTS                       */
    dszCMPXCHG,O_Modrm_Reg,             /* A7 IBTS                       */
    dszPUSH,  O_sReg2,                  /* A8 PUSH GS                    */
    dszPOP,   O_sReg2,                  /* A9 POP GS                     */
    dszRESERVED, O_DoDB,                /* AA                            */
    dszBTS,   O_vModrm_Reg,             /* AB BTS                        */
    dszSHRD,  O_Modrm_Reg_Ib,           /* AC SHRD                       */
    dszSHRD,  O_Modrm_Reg_CL,           /* AD SHRD                       */
    dszRESERVED, O_DoDB,                /* AE                            */
    dszIMUL,  O_Reg_Modrm,              /* AF IMUL                       */
    dszRESERVED, O_DoDB,                /* B0                            */
    dszRESERVED, O_DoDB,                /* B1                            */
    dszLSS,   O_fReg_Modrm,             /* B2 LSS                        */
    dszBTR,   O_Modrm_Reg,              /* B3 BTR                        */
    dszLFS,   O_fReg_Modrm,             /* B4 LFS                        */
    dszLGS,   O_fReg_Modrm,             /* B5 LGS                        */
    dszMOVZX, O_Reg_bModrm,             /* B6 MOVZX                      */
    dszMOVZX, O_Reg_wModrm,             /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI, O_GROUP8,                 /* BA MULTI                      */
    dszBTC,   O_Modrm_Reg,              /* BB BTC                        */
    dszBSF,   O_Reg_Modrm,              /* BC BSF                        */
    dszBSR,   O_Reg_Modrm,              /* BD BSR                        */
    dszMOVSX, O_Reg_bModrm,             /* BE MOVSX                      */
    dszMOVSX, O_Reg_wModrm,             /* BF MOVSX                      */
    dszXADD,  O_bModrm_Reg,             /* C0 XADD                       */
    dszXADD,  O_Modrm_Reg,              /* C1 XADD                       */
    dszRESERVED, O_DoDB,                /* C2                            */
    dszRESERVED, O_DoDB,                /* C3                            */
    dszRESERVED, O_DoDB,                /* C4                            */
    dszRESERVED, O_DoDB,                /* C5                            */
    dszRESERVED, O_DoDB,                /* C6                            */
    dszRESERVED, O_DoDB,                /* C7                            */
    dszBSWAP, O_oReg,                   /* C8 BSWAP                      */
    dszBSWAP, O_oReg,                   /* C9 BSWAP                      */
    dszBSWAP, O_oReg,                   /* CA BSWAP                      */
    dszBSWAP, O_oReg,                   /* CB BSWAP                      */
    dszBSWAP, O_oReg,                   /* CC BSWAP                      */
    dszBSWAP, O_oReg,                   /* CD BSWAP                      */
    dszBSWAP, O_oReg,                   /* CE BSWAP                      */
    dszBSWAP, O_oReg                    /* CF BSWAP                      */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,      dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszRESERVED, dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC}

            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszRESERVED, O_DoDB,       /* DA-0         */
              dszRESERVED, O_DoDB,       /* DA-1         */
              dszRESERVED, O_DoDB,       /* DA-2         */
              dszRESERVED, O_DoDB,       /* DA-3         */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszRESERVED, O_DoDB,       /* DF-5         */
              dszRESERVED, O_DoDB,       /* DF-6         */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszRESERVED, O_DoDB }      /* 0F-7           */

            };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\help\apimon.hh ===
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
** Help Context Identifiers for APIMON.HH
** Generated by RoboHELP
**
** RoboHELP observes a polite protocol for dealing with this file.
** It will add new identifiers for new context strings that are
** added to the RTF file with the same name.
**
** RoboHELP will also preserve comments which are placed in this
** file, so documentation staff can insert notes to those crazy
** developers and vice versa.
**
** However, the numeric values of the identifiers are stored only
** in this file.  Therefore, if you change the numeric value here,
** it is changed for good.  RoboHELP will not try to change it back.
**
** Normally, RoboHELP will remove the symbols for context strings
** which have been removed from the .RTF file.  However, you can
** set a checkbox in your project setup to prevent RoboHELP from
** doing this.  You may want to do this and make use of the Alias
** capability of the help compiler.
**
*/

#define IDH_ABOUT                       700
#define IDH_CLEAR_COUNTERS              701
#define IDH_COLOR                       702
#define IDH_COMMAND_LINE                703
#define IDH_CONTENTS                    704
#define IDH_DEFSORT_COUNTER             705
#define IDH_DEFSORT_NAME                706
#define IDH_DEFSORT_TIME                707
#define IDH_DISABLE_FAST_COUNTERS       708
#define IDH_DISABLE_HEAP                709
#define IDH_DLLS_OPTIONS                710
#define IDH_ENABLE_COUNTERS             711
#define IDH_ENABLE_TRACING              712
#define IDH_EXIT                        713
#define IDH_FILEOPEN                    714
#define IDH_FNAME_OPTIONS               715
#define IDH_FONT                        716
#define IDH_GO_IMMEDIATE                717
#define IDH_HOW_TO_USE                  718
#define IDH_KNOWN_DLLS                  719
#define IDH_LOG_FILE_NAME               720
#define IDH_MISC_OPTIONS                721
#define IDH_NEW_COUNTER                 722
#define IDH_NEW_DLL                     723
#define IDH_NEW_PAGE                    724
#define IDH_OPTIONS                     725
#define IDH_PAGE_FAULTS                 726
#define IDH_PRELOAD_SYMBOLS             727
#define IDH_SAVE_OPTIONS                728
#define IDH_START                       729
#define IDH_STATUSBAR                   730
#define IDH_STOP                        731
#define IDH_SYMBOL_PATH                 732
#define IDH_TOOLBAR                     733
#define IDH_TRACE_FILE_NAME             734
#define IDH_USE_KNOWN_DLLS              735
#define IDH_WHAT_IS                     736
#define IDH_WINDOWCASCADE               737
#define IDH_WINDOWICONS                 738
#define IDH_WINDOWTILE                  739
#define IDH_WINDOWTILE_HORIZ            740
#define IDH_WRITE_LOG                   741
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\apimon\i386\machine.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    All machine specific code.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "reg.h"

extern ULONG ReDirectIat;

#define FLAGIOPL        118
#define FLAGOF          119
#define FLAGDF          120
#define FLAGIF          121
#define FLAGTF          122
#define FLAGSF          123
#define FLAGZF          124
#define FLAGAF          125
#define FLAGPF          126
#define FLAGCF          127
#define FLAGVIP         128
#define FLAGVIF         129

char    szGsReg[]    = "gs";
char    szFsReg[]    = "fs";
char    szEsReg[]    = "es";
char    szDsReg[]    = "ds";
char    szEdiReg[]   = "edi";
char    szEsiReg[]   = "esi";
char    szEbxReg[]   = "ebx";
char    szEdxReg[]   = "edx";
char    szEcxReg[]   = "ecx";
char    szEaxReg[]   = "eax";
char    szEbpReg[]   = "ebp";
char    szEipReg[]   = "eip";
char    szCsReg[]    = "cs";
char    szEflReg[]   = "efl";
char    szEspReg[]   = "esp";
char    szSsReg[]    = "ss";
char    szDiReg[]    = "di";
char    szSiReg[]    = "si";
char    szBxReg[]    = "bx";
char    szDxReg[]    = "dx";
char    szCxReg[]    = "cx";
char    szAxReg[]    = "ax";
char    szBpReg[]    = "bp";
char    szIpReg[]    = "ip";
char    szFlReg[]    = "fl";
char    szSpReg[]    = "sp";
char    szBlReg[]    = "bl";
char    szDlReg[]    = "dl";
char    szClReg[]    = "cl";
char    szAlReg[]    = "al";
char    szBhReg[]    = "bh";
char    szDhReg[]    = "dh";
char    szChReg[]    = "ch";
char    szAhReg[]    = "ah";
char    szIoplFlag[] = "iopl";
char    szFlagOf[]   = "of";
char    szFlagDf[]   = "df";
char    szFlagIf[]   = "if";
char    szFlagTf[]   = "tf";
char    szFlagSf[]   = "sf";
char    szFlagZf[]   = "zf";
char    szFlagAf[]   = "af";
char    szFlagPf[]   = "pf";
char    szFlagCf[]   = "cf";
char    szFlagVip[]  = "vip";
char    szFlagVif[]  = "vif";

REG regname[] = {
        { szGsReg,    REGGS    },
        { szFsReg,    REGFS    },
        { szEsReg,    REGES    },
        { szDsReg,    REGDS    },
        { szEdiReg,   REGEDI   },
        { szEsiReg,   REGESI   },
        { szEbxReg,   REGEBX   },
        { szEdxReg,   REGEDX   },
        { szEcxReg,   REGECX   },
        { szEaxReg,   REGEAX   },
        { szEbpReg,   REGEBP   },
        { szEipReg,   REGEIP   },
        { szCsReg,    REGCS    },
        { szEflReg,   REGEFL   },
        { szEspReg,   REGESP   },
        { szSsReg,    REGSS    },
        { szDiReg,    REGDI    },
        { szSiReg,    REGSI    },
        { szBxReg,    REGBX    },
        { szDxReg,    REGDX    },
        { szCxReg,    REGCX    },
        { szAxReg,    REGAX    },
        { szBpReg,    REGBP    },
        { szIpReg,    REGIP    },
        { szFlReg,    REGFL    },
        { szSpReg,    REGSP    },
        { szBlReg,    REGBL    },
        { szDlReg,    REGDL    },
        { szClReg,    REGCL    },
        { szAlReg,    REGAL    },
        { szBhReg,    REGBH    },
        { szDhReg,    REGDH    },
        { szChReg,    REGCH    },
        { szAhReg,    REGAH    },
        { szIoplFlag, FLAGIOPL },
        { szFlagOf,   FLAGOF   },
        { szFlagDf,   FLAGDF   },
        { szFlagIf,   FLAGIF   },
        { szFlagTf,   FLAGTF   },
        { szFlagSf,   FLAGSF   },
        { szFlagZf,   FLAGZF   },
        { szFlagAf,   FLAGAF   },
        { szFlagPf,   FLAGPF   },
        { szFlagCf,   FLAGCF   },
        { szFlagVip,  FLAGVIP  },
        { szFlagVif,  FLAGVIF  },
};

#define REGNAMESIZE (sizeof(regname) / sizeof(REG))

SUBREG subregname[] = {
        { REGEDI,  0, 0xffff },         //  DI register
        { REGESI,  0, 0xffff },         //  SI register
        { REGEBX,  0, 0xffff },         //  BX register
        { REGEDX,  0, 0xffff },         //  DX register
        { REGECX,  0, 0xffff },         //  CX register
        { REGEAX,  0, 0xffff },         //  AX register
        { REGEBP,  0, 0xffff },         //  BP register
        { REGEIP,  0, 0xffff },         //  IP register
        { REGEFL,  0, 0xffff },         //  FL register
        { REGESP,  0, 0xffff },         //  SP register
        { REGEBX,  0,   0xff },         //  BL register
        { REGEDX,  0,   0xff },         //  DL register
        { REGECX,  0,   0xff },         //  CL register
        { REGEAX,  0,   0xff },         //  AL register
        { REGEBX,  8,   0xff },         //  BH register
        { REGEDX,  8,   0xff },         //  DH register
        { REGECX,  8,   0xff },         //  CH register
        { REGEAX,  8,   0xff },         //  AH register
        { REGEFL, 12,      3 },         //  IOPL level value
        { REGEFL, 11,      1 },         //  OF (overflow flag)
        { REGEFL, 10,      1 },         //  DF (direction flag)
        { REGEFL,  9,      1 },         //  IF (interrupt enable flag)
        { REGEFL,  8,      1 },         //  TF (trace flag)
        { REGEFL,  7,      1 },         //  SF (sign flag)
        { REGEFL,  6,      1 },         //  ZF (zero flag)
        { REGEFL,  4,      1 },         //  AF (aux carry flag)
        { REGEFL,  2,      1 },         //  PF (parity flag)
        { REGEFL,  0,      1 },         //  CF (carry flag)
        { REGEFL, 20,      1 },         //  VIP (virtual interrupt pending)
        { REGEFL, 19,      1 }          //  VIF (virtual interrupt flag)
};

extern CONTEXT CurrContext;
extern HANDLE  CurrProcess;


ULONG
CreateTrojanHorse(
    PUCHAR  Text,
    ULONG   ExceptionAddress
    )
{
    ULONG BpAddr;

    //
    // construct the trojan horse
    //
    // the code looks like the following:
    //
    // |<-- jmp x
    // |    [trojan.dll - null term string]
    // |    [addr of loadlibrary - ulong]
    // |--> push [addr of string]
    //      push [return addr]
    //      jmp [load library]
    //      int 3
    //

    ULONG Address = 0;
    PUCHAR p = Text;
    LPDWORD pp = NULL;


    ULONG i = strlen( TROJANDLL ) + 1;
    //
    // jump around the data
    //
    p[0] = 0xeb;      // jmp
    p[1] = (UCHAR)(i + sizeof(DWORD));     // rel distance
    p += 2;
    //
    // store the trojan dll string
    //
    strcpy( (LPSTR)p, TROJANDLL );
    p += i;
    //
    // store the address of loadlibrarya()
    //
    Address = (ULONG)GetProcAddress(
        GetModuleHandle( KERNEL32 ),
        LOADLIBRARYA
        );
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // push the address of the trojan dll string
    //
    Address = ExceptionAddress + 2;
    p[0] = 0x68;      // push
    p += 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // push the return address
    //
    Address = ExceptionAddress + 33;
    BpAddr = Address;
    p[0] = 0x68;      // push
    p += 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // jump to loadlibrary()
    //
    p[0] = 0xff;
    p[1] = 0x25;      // jmp
    p += 2;
    Address = ExceptionAddress + 2 + strlen( TROJANDLL ) + 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // write the breakpoint instruction
    //
    p[0] = 0xcc;      // breakpoint
    p += 1;

    return BpAddr;
}

VOID
PrintRegisters(
    VOID
    )
{
    printf( "\n" );
    printf(
        "eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
        CurrContext.Eax,
        CurrContext.Ebx,
        CurrContext.Ecx,
        CurrContext.Edx,
        CurrContext.Esi,
        CurrContext.Edi
        );

    printf(
        "eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx %s %s %s %s %s %s %s %s %s %s\n",
        CurrContext.Eip,
        CurrContext.Esp,
        CurrContext.Ebp,
        GetRegFlagValue( FLAGIOPL ),
        GetRegFlagValue( FLAGVIP  ) ? "vip" : "   ",
        GetRegFlagValue( FLAGVIF  ) ? "vif" : "   ",
        GetRegFlagValue( FLAGOF   ) ? "ov" : "nv",
        GetRegFlagValue( FLAGDF   ) ? "dn" : "up",
        GetRegFlagValue( FLAGIF   ) ? "ei" : "di",
        GetRegFlagValue( FLAGSF   ) ? "ng" : "pl",
        GetRegFlagValue( FLAGZF   ) ? "zr" : "nz",
        GetRegFlagValue( FLAGAF   ) ? "ac" : "na",
        GetRegFlagValue( FLAGPF   ) ? "po" : "pe",
        GetRegFlagValue( FLAGCF   ) ? "cy" : "nc"
        );

    printf(
        "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  gs=%04lx             efl=%08lx\n",
        CurrContext.SegCs,
        CurrContext.SegSs,
        CurrContext.SegDs,
        CurrContext.SegEs,
        CurrContext.SegFs,
        CurrContext.SegGs,
        CurrContext.EFlags
        );
    printf( "\n" );
}

DWORDLONG
GetRegFlagValue(
    ULONG regnum
    )
{
    DWORDLONG value;

    if (regnum < FLAGBASE) {
        value = GetRegValue(regnum);
    } else {
        regnum -= FLAGBASE;
        value = GetRegValue(subregname[regnum].regindex);
        value = (value >> subregname[regnum].shift) & subregname[regnum].mask;
    }
    return value;
}

DWORDLONG
GetRegPCValue(
    PULONG Address
    )
{
    return GetRegValue( REGEIP );
}

DWORDLONG
GetRegValue(
    ULONG RegNum
    )
{
    switch (RegNum) {
        case REGGS:
            return CurrContext.SegGs;
        case REGFS:
            return CurrContext.SegFs;
        case REGES:
            return CurrContext.SegEs;
        case REGDS:
            return CurrContext.SegDs;
        case REGEDI:
            return CurrContext.Edi;
        case REGESI:
            return CurrContext.Esi;
        case REGSI:
            return(CurrContext.Esi & 0xffff);
        case REGDI:
            return(CurrContext.Edi & 0xffff);
        case REGEBX:
            return CurrContext.Ebx;
        case REGEDX:
            return CurrContext.Edx;
        case REGECX:
            return CurrContext.Ecx;
        case REGEAX:
            return CurrContext.Eax;
        case REGEBP:
            return CurrContext.Ebp;
        case REGEIP:
            return CurrContext.Eip;
        case REGCS:
            return CurrContext.SegCs;
        case REGEFL:
            return CurrContext.EFlags;
        case REGESP:
            return CurrContext.Esp;
        case REGSS:
            return CurrContext.SegSs;
        case PREGEA:
            return 0;
        case PREGEXP:
            return 0;
        case PREGRA:
            {
                struct {
                    ULONG   oldBP;
                    ULONG   retAddr;
                } stackRead;
                ReadMemory( CurrProcess, (LPVOID)CurrContext.Ebp, (LPVOID)&stackRead, sizeof(stackRead) );
                return stackRead.retAddr;
            }
        case PREGP:
            return 0;
        case REGDR0:
            return CurrContext.Dr0;
        case REGDR1:
            return CurrContext.Dr1;
        case REGDR2:
            return CurrContext.Dr2;
        case REGDR3:
            return CurrContext.Dr3;
        case REGDR6:
            return CurrContext.Dr6;
        case REGDR7:
            return CurrContext.Dr7;
        default:
            return 0;
        }
}

LONG
GetRegString(
    LPSTR RegString
    )
{
    ULONG   count;

    for (count = 0; count < REGNAMESIZE; count++) {
        if (!strcmp(RegString, regname[count].psz)) {
            return regname[count].value;
        }
    }
    return (ULONG)-1;
}

BOOL
GetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    )
{
    ZeroMemory( Context, sizeof(CONTEXT) );
    Context->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    return GetThreadContext( hThread, Context );
}

BOOL
SetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    )
{
    return SetThreadContext( hThread, Context );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\include\apictrl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apictrl.h

Abstract:

    Common types & structures for the ApiCtrl DLL.

Author:

    Rick Swaney (rswaney) 13-Mar-1996

Environment:

    User Mode

--*/

#ifndef _APICTRL_
#define _APICTRL_

//
// Error Codes
//
#define APICTRL_ERR_NO_APIMON_WINDOW    0x80000001  
#define APICTRL_ERR_PARAM_TOO_LONG      0x80000002
#define APICTRL_ERR_NULL_FILE_NAME      0x80000003
#define APICTRL_ERR_FILE_ERROR          0x80000004

//
// Command messages
//
#define WM_OPEN_LOG_FILE    (WM_USER + 200)
#define WM_CLOSE_LOG_FILE   (WM_USER + 201)

//
// Command Buffer mapped file
//
#define CMD_PARAM_BUFFER_NAME  "ApiMonCmdBuf"
#define CMD_PARAM_BUFFER_SIZE  1024
// 
// API Prototypes
//
DWORD
APIENTRY
ApiOpenLogFile( LPSTR pszFileName );

DWORD
APIENTRY
ApiCloseLogFile( LPSTR pszFileName );

#endif // _APICTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\include\apimon.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimon.h

Abstract:

    Common types & structures for the APIMON projects.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#ifndef _APIMON_
#define _APIMON_

#ifdef __cplusplus
#define CLINKAGE                        extern "C"
#else
#define CLINKAGE
#endif

#define TROJANDLL                       "apidll.dll"
#define MAX_NAME_SZ                     32
#define MAX_DLLS                        512
#define MEGABYTE                        (1024*1024)
#define MAX_MEM_ALLOC                   (MEGABYTE*32)
#define MAX_APIS                        ((MAX_MEM_ALLOC/2)/sizeof(API_INFO))
#define THUNK_SIZE                      MEGABYTE
#define Align(p,x)                      (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

#define KERNEL32                        "kernel32.dll"
#define NTDLL                           "ntdll.dll"
#define USER32                          "user32.dll"
#define WNDPROCDLL                      "wndprocs"
#define LOADLIBRARYA                    "LoadLibraryA"
#define LOADLIBRARYW                    "LoadLibraryW"
#define FREELIBRARY                     "FreeLibrary"
#define GETPROCADDRESS                  "GetProcAddress"
#define REGISTERCLASSA                  "RegisterClassA"
#define REGISTERCLASSW                  "RegisterClassW"
#define SETWINDOWLONGA                  "SetWindowLongA"
#define SETWINDOWLONGW                  "SetWindowLongW"
#define ALLOCATEHEAP                    "RtlAllocateHeap"
#define CREATEHEAP                      "RtlCreateHeap"

#if defined(_ALPHA_)

#define UPPER_ADDR(_addr) LOWORD(((LONG_PTR)(_addr) >> 32) + (HIGH_ADDR((_addr)) >> 15))
#define HIGH_ADDR(_addr)  LOWORD(HIWORD((_addr)) + (LOWORD((_addr)) >> 15))
#define LOW_ADDR(_addr)   LOWORD((_addr))

#endif

//
// api table type definitions
//
#define DFLT_TRACE_ARGS  8
#define MAX_TRACE_ARGS   8

//
// Handle type, index corresponds to the entries in the alias array
//

enum Handles { T_HACCEL, T_HANDLE, T_HBITMAP, T_HBRUSH, T_HCURSOR, T_HDC,
        T_HDCLPPOINT, T_HDESK, T_HDWP, T_HENHMETAFILE, T_HFONT, T_HGDIOBJ,
        T_HGLOBAL, T_HGLRC, T_HHOOK, T_HICON, T_HINSTANCE, T_HKL, T_HMENU,
        T_HMETAFILE, T_HPALETTE, T_HPEN, T_HRGN, T_HWINSTA, T_HWND};

#define T_DWORD          101
#define T_LPSTR          102
#define T_LPWSTR         103
#define T_UNISTR         104      // UNICODE string (counted)
#define T_OBJNAME        105      // Name from OBJECT_ATTRIBUTES struct
#define T_LPSTRC         106      // Counted string (count is following arg)
#define T_LPWSTRC        107      // Counted UNICODE string (count is following arg)
#define T_DWORDPTR       108      // Indirect DWORD
#define T_DLONGPTR       109      // Indirect DWORDLONG

// User macro for creating T_DWPTR type with offset encoded in high word
#define T_PDWORD(off) (((off)<<16) + T_DWORDPTR)
#define T_PDLONG(off) (((off)<<16) + T_DLONGPTR)
#define T_PSTR(off)   (((off)<<16) + T_LPSTR)
#define T_PWSTR(off)  (((off)<<16) + T_LPWSTR)

//
// api trace modes
#define API_TRACE        1      // Trace this api
#define API_FULLTRACE    2      // Trace this api and its callees

typedef struct _API_TABLE {
    LPSTR       Name;
    ULONG       RetType;
    ULONG       ArgCount;
    ULONG       ArgType[MAX_TRACE_ARGS];
} API_TABLE, *PAPI_TABLE;

typedef struct _API_MASTER_TABLE {
    LPSTR       Name;
    BOOL        Processed;
    PAPI_TABLE  ApiTable;
} API_MASTER_TABLE, *PAPI_MASTER_TABLE;

typedef struct _API_INFO {
    ULONG       Name;
    ULONG_PTR   Address;
    ULONG_PTR   ThunkAddress;
    ULONG       Count;
    DWORDLONG   Time;
    DWORDLONG   CalleeTime;
    ULONG       NestCount;
    ULONG       TraceEnabled;
    PAPI_TABLE  ApiTable;
    ULONG_PTR   HardFault;
    ULONG_PTR   SoftFault;
    ULONG_PTR   CodeFault;
    ULONG_PTR   DataFault;
    ULONG       Size;
    ULONG       ApiTableIndex;
    ULONG_PTR   DllOffset;
} API_INFO, *PAPI_INFO;

typedef struct _DLL_INFO {
    CHAR        Name[MAX_NAME_SZ];
    ULONG_PTR   BaseAddress;
    ULONG       Size;
    ULONG       ApiCount;
    ULONG       ApiOffset;
    ULONG       Unloaded;
    ULONG       Enabled;
    ULONG       OrigEnable;
    ULONG       Snapped;
    ULONG       InList;
    ULONG       StaticProfile;
    ULONG       Hits;
    ULONG       LoadCount;
} DLL_INFO, *PDLL_INFO;

typedef struct _TRACE_ENTRY {
    ULONG       SizeOfStruct;
    ULONG_PTR   Address;
    ULONG_PTR   ReturnValue;
    ULONG       LastError;
    ULONG_PTR   Caller;
    ULONG       ApiTableIndex;
    DWORDLONG   EnterTime;
    DWORDLONG   Duration;
    ULONG       ThreadNum;
    ULONG       Level;
    ULONG_PTR   Args[MAX_TRACE_ARGS];
} TRACE_ENTRY, *PTRACE_ENTRY;

typedef struct _TRACE_BUFFER {
    ULONG       Size;
    ULONG       Offset;
    ULONG       Count;
    TRACE_ENTRY Entry[1];
} TRACE_BUFFER, *PTRACE_BUFFER;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\apimon\test\test.c ===
#include <windows.h>
#include <stdio.h>
#include "apimon.h"

HANDLE                  ApiMonMutex;
PVOID                   MemPtr;
PDLL_INFO               DllList;

LPDWORD                 ApiCounter;
LPDWORD                 ApiTraceEnabled;
LPDWORD                 ApiTimingEnabled;
LPDWORD                 FastCounterAvail;
LPDWORD                 ApiOffset;
LPDWORD                 ApiStrings;
LPDWORD                 ApiCount;
LPSTR                   TraceFileName;


PDLL_INFO
AddDllToList(
    HANDLE              hProcess,
    ULONG               DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    );

ULONG
AddApisForDll(
    HANDLE              hProcess,
    PDLL_INFO           DllInfo
    );



int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE      hMap;
    PDLL_INFO   DllInfo;


    hMap = CreateFileMapping(
        (HANDLE)0xffffffff,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        MAX_MEM_ALLOC,
        "ApiWatch"
        );
    if (!hMap) {
        return 1;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        return 1;
    }
    ApiMonMutex = CreateMutex( NULL, FALSE, "ApiMonMutex" );
    if (!ApiMonMutex) {
        return FALSE;
    }

    ApiCounter       = (LPDWORD)MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)MemPtr + 2;
    FastCounterAvail = (LPDWORD)MemPtr + 3;
    ApiOffset        = (LPDWORD)MemPtr + 4;
    ApiStrings       = (LPDWORD)MemPtr + 5;
    ApiCount         = (LPDWORD)MemPtr + 6;
    TraceFileName    = (LPSTR)((LPDWORD)MemPtr + 7);
    DllList          = (PDLL_INFO)((LPDWORD)MemPtr + 8 + MAX_PATH);

    *ApiOffset       = (MAX_DLLS * sizeof(DLL_INFO)) + ((ULONG)DllList - (ULONG)MemPtr);
    *ApiStrings      = (MAX_APIS * sizeof(API_INFO)) + *ApiOffset;


#if 0
    DllInfo = AddDllToList( NULL,
        HANDLE              hProcess,
        ULONG               DllAddr,
        LPSTR               DllName,
        ULONG               DllSize
        );







#endif

    LoadLibrary( "apidll.dll" );

    return 0;
}

BOOL
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    CopyMemory( Buffer, Address, Length );
    return TRUE;
}

PDLL_INFO
FindDllByAddress(
    ULONG DllAddr
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindDllByName(
    LPSTR DllName
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Name[0] &&
            _stricmp( DllList[i].Name, DllName ) == 0) {
                return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindAvailDll(
    VOID
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (!DllList[i].BaseAddress) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
AddDllToList(
    HANDLE              hProcess,
    ULONG               DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   i;
    PDLL_INFO               DllInfo;


    //
    // first look to see if the dll is already in the list
    //
    DllInfo = FindDllByAddress( DllAddr );

    if (!DllSize) {
        //
        // read the pe image headers to get the image size
        //
        if (!ReadMemory(
            hProcess,
            (PVOID) DllAddr,
            &dh,
            sizeof(dh)
            )) {
                return NULL;
        }

        if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
            if (!ReadMemory(
                hProcess,
                (PVOID)(DllAddr + dh.e_lfanew),
                &nh,
                sizeof(nh)
                )) {
                    return NULL;
            }
            DllSize = nh.OptionalHeader.SizeOfImage;
        } else {
            DllSize = 0;
        }
    }

    DllInfo = FindAvailDll();
    if (!DllInfo) {
        return NULL;
    }

    DllInfo->Size = DllSize;
    strncat( DllInfo->Name, DllName, MAX_NAME_SZ-1 );
    DllInfo->BaseAddress = DllAddr;
    DllInfo->InList = FALSE;
    DllInfo->Enabled = TRUE;

    return DllInfo;
}

ULONG
AddApisForDll(
    HANDLE              hProcess,
    PDLL_INFO           DllInfo
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    IMAGE_EXPORT_DIRECTORY  expdir;
    PULONG                  names    = NULL;
    PULONG                  addrs    = NULL;
    PUSHORT                 ordinals = NULL;
    PUSHORT                 ordidx   = NULL;
    PAPI_INFO               ApiInfo  = NULL;
    ULONG                   cnt      = 0;
    ULONG                   idx      = 0;
    ULONG                   i;
    ULONG                   j;
    LPSTR                   p;


    if (*ApiCount == MAX_APIS) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)DllInfo->BaseAddress,
        &dh,
        sizeof(dh)
        )) {
            goto exit;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + dh.e_lfanew),
        &nh,
        sizeof(nh)
        )) {
            goto exit;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress +
            nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(expdir)
        )) {
            goto exit;
    }

    names = (PULONG) LocalAlloc( LPTR, expdir.NumberOfNames * sizeof(ULONG) );
    addrs = (PULONG) LocalAlloc( LPTR, expdir.NumberOfFunctions * sizeof(ULONG) );
    ordinals = (PUSHORT) LocalAlloc( LPTR, expdir.NumberOfNames * sizeof(USHORT) );
    ordidx = (PUSHORT) LocalAlloc( LPTR, expdir.NumberOfFunctions * sizeof(USHORT) );

    if ((!names) || (!addrs) || (!ordinals) || (!ordidx)) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNames),
        names,
        expdir.NumberOfNames * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfFunctions),
        addrs,
        expdir.NumberOfFunctions * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNameOrdinals),
        ordinals,
        expdir.NumberOfNames * sizeof(USHORT)
        )) {
            goto exit;
    }

    DllInfo->ApiCount = expdir.NumberOfFunctions;
    DllInfo->ApiOffset = *ApiOffset;
    *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG)DllList);

    if (*ApiCount < MAX_APIS) {
        for (i=0; i<expdir.NumberOfNames; i++) {
            idx = ordinals[i];
            ordidx[idx] = TRUE;
            ApiInfo[i].Count = 0;
            ApiInfo[i].ThunkAddress = 0;
            ApiInfo[i].Address = addrs[idx] + DllInfo->BaseAddress;
            j = 0;
            p = (LPSTR)((LPSTR)MemPtr+*ApiStrings);
            do {
                ReadMemory(
                    hProcess,
                    (PVOID)(DllInfo->BaseAddress + names[i] + j),
                    &p[j],
                    1
                    );
                j += 1;
            } while(p[j-1]);
            ApiInfo[i].Name = *ApiStrings;
            *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
            *ApiCount += 1;
            if (*ApiCount == MAX_APIS) {
                break;
            }
        }
    }
    if (*ApiCount < MAX_APIS) {
        for (i=0,idx=expdir.NumberOfNames; i<expdir.NumberOfFunctions; i++) {
            if (!ordidx[i]) {
                ApiInfo[idx].Count = 0;
                ApiInfo[idx].ThunkAddress = 0;
                ApiInfo[idx].Address = addrs[i] + DllInfo->BaseAddress;
                sprintf(
                    (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                    "Ordinal%d",
                    i
                    );
                ApiInfo[idx].Name = *ApiStrings;
                *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
                *ApiCount += 1;
                if (*ApiCount == MAX_APIS) {
                    break;
                }
                idx += 1;
            }
        }
    }
    cnt = DllInfo->ApiCount;

exit:
    LocalFree( names );
    LocalFree( addrs );
    LocalFree( ordinals );
    LocalFree( ordidx );

    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appcompat\appcompat.h ===
/*
Copyright (c) 1999  Microsoft Corporation

Module Name:

    appcompat.h

Abstract:
    Definition of the ID's for the various controls.

*/

#define FIRSTBUTTON      10
#define IDD_WINNT43      10
#define IDD_WINNT44      11
#define IDD_WINNT45      12
#define IDD_WIN98        13
#define IDD_WIN95        14
#define IDD_NONE         15
#define LASTBUTTON       15

#define IDD_BROWSE      150
#define IDD_LAUNCH      160
#define IDD_CLOSE       170
#define IDD_HELP        180

#define IDD_APPEDIT     200
#define IDD_APPNAME     201

#define IDD_CHECK1      401
#define IDD_CHECK2      402
#define IDD_CHECK3      403
#define IDD_CHECK4      404
#define IDD_DCOMFTM     405
#define IDD_OLDPATH     406


#define IDS_ERROFN      303
#define IDS_ERREDITCTRL 304

#define IDHH_HELP       TEXT("/topics/appcomp.htm")
#define IDHH_CMDSYNTAX  TEXT("/topics/appcomp_syntax.htm")

//#define EXTRA_APP_COMPAT    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    PSTR pszFile,
    int* pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appcompat\apphacks.c ===
// apphacks.c : Defines the entry point for the console application.
//
// This little utility is supposed to allow me a way to enter in data into
// Image File Execution Options without doing it by hand all the time.  Used
// specifically for apphack flags and taking version info out of the EXE to see
// if a match exists

#define UNICODE   1

#include <windows.h>
#include <commdlg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <winver.h>
#include <apcompat.h>





#define MIN_VERSION_RESOURCE	512
#define IMAGE_EXEC_OPTIONS      TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\")

extern TCHAR*  CheckExtension(TCHAR*);
extern VOID    SetRegistryVal(TCHAR* , TCHAR* , PTCHAR,DWORD);
extern VOID    DetailError1  (DWORD );

extern BOOLEAN g_fNotPermanent;
PVOID          g_lpPrevRegSettings;


UINT uVersionInfo[5][8]={  {4,0,1381,VER_PLATFORM_WIN32_NT,3,0,0,0},
                           {4,0,1381,VER_PLATFORM_WIN32_NT,4,0,0,0},
                           {4,0,1381,VER_PLATFORM_WIN32_NT,5,0,0,0},
                           {4,10,1998,VER_PLATFORM_WIN32_WINDOWS,0,0,0,0},
                           {4,0,950,VER_PLATFORM_WIN32_WINDOWS,0,0,0,0}
                           };

PTCHAR  pszVersionInfo[5]={
                           TEXT("Service Pack 3"),
                           TEXT("Service Pack 4"),
                           TEXT("Service Pack 5"),
                           TEXT(""),
                           TEXT("")
                           };

BOOLEAN g_GooAppendFlag;


VOID  SetRegistryValGoo(TCHAR* szTitle, TCHAR* szVal,PUCHAR szBuffer,DWORD dwType,UINT length)
{
  long         lResult;
  TCHAR        szSubKey[MAX_PATH];
  HKEY         hKey;

      wsprintf(szSubKey,
               TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),
               szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          RegSetValueEx(hKey,
                        szVal,
                        0,
                        dwType,
                        (CONST BYTE*)szBuffer,
                        length);

          RegCloseKey(hKey);
        }
}

VOID DeleteRegistryValueGoo(TCHAR*szTitle)
{
  long         lResult;
  TCHAR        szSubKey[MAX_PATH];
  HKEY         hKey;

      wsprintf(szSubKey,
               TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),
               szTitle);

       lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              KEY_WRITE,
                              &hKey
                              );
       if(lResult == ERROR_SUCCESS)
        {
          RegDeleteValue(hKey,TEXT("ApplicationGoo") );
          RegCloseKey(hKey);
        }
}


/*
 Check whether the registry contains an entry for "applicationgoo" for the given *.exe.
 If it does, check the "resource info." to determine whether they are same.
 If they are the same, don't worry, your work is already done. If not,
 the new one needs to get appended to the old one.
*/
BOOLEAN CheckGooEntry(PVOID pVersionInfo,
                      PAPP_COMPAT_GOO pExistingVersionInfo,
                      BOOL fImageHasResourceInfo,
                      DWORD VersionInfoSize,
                      DWORD dwSize,
                      LARGE_INTEGER *pAppCompatFlag,
                      PAPP_VARIABLE_INFO pOsVersionInfo,
                      ULONG TotalVersionInfoLength,
                      TCHAR* pszPath                             // Executable path.
                      )
{
  BOOLEAN fNeedAppend = FALSE;
  // Added for the addition and deletion from the registry.
  PAPP_COMPAT_GOO       pReplaceAppCompatGoo;
  PPRE_APP_COMPAT_INFO  pAppCompatEntry, pStoredAppCompatEntry = NULL;
  PPRE_APP_COMPAT_INFO  pDestAppCompatEntry, pReplaceAppCompatEntry;
  ULONG                 TotalGooLength, InputCompareLength, ReplaceCopyLength;
  ULONG                 OutputCompareLength, CopyLength, OffSet;
  PVOID                 ResourceInfo;
  UINT                  iLoop = 0;
  BOOL                  fMatchGot = FALSE;
  PVOID                 pExistingAppCompatFlag;
  PVOID                 pExistingOsVersionInfo;
  BOOLEAN               fAppCompatMatch = FALSE, fOsVersionMatch = FALSE;
  TCHAR                 szTitle[MAX_PATH];
  ULONG                 ReplaceGooLength;

  pAppCompatEntry = pExistingVersionInfo ->AppCompatEntry;
  TotalGooLength  = pExistingVersionInfo ->dwTotalGooSize -   \
                    sizeof(pExistingVersionInfo ->dwTotalGooSize);
  //Loop till we get a matching entry in the registry.
  while (TotalGooLength ){
        InputCompareLength = pAppCompatEntry->dwResourceInfoSize;
        ResourceInfo       = pAppCompatEntry + 1;

        if(fImageHasResourceInfo){
           if( InputCompareLength > VersionInfoSize)
              InputCompareLength = VersionInfoSize;

           OutputCompareLength = \
                       (ULONG)RtlCompareMemory(
                                   ResourceInfo,
                                   pVersionInfo,
                                   InputCompareLength
                                   );

        }
        else{
           OutputCompareLength = 0;
        }

        if( InputCompareLength != OutputCompareLength){
          // No match found...Need to continue thru till I find one or exhaust.
           TotalGooLength -= pAppCompatEntry->dwEntryTotalSize;
           (PUCHAR) pAppCompatEntry += pAppCompatEntry->dwEntryTotalSize;
           iLoop++;
           continue;
        }

        // We are a match !!
        pStoredAppCompatEntry = pAppCompatEntry;
        fMatchGot = TRUE;
        // Since we are a match, we won't add the ApplicationGoo but we need to check the
        // ApcompatFlag and the OSVersionInfo.
        if( (!pAppCompatFlag) && (!pOsVersionInfo) )
          break;

        OffSet = sizeof(PRE_APP_COMPAT_INFO) + \
                   pStoredAppCompatEntry->dwResourceInfoSize;
        if(pAppCompatFlag){
           (PUCHAR)pExistingAppCompatFlag = (PUCHAR) ( pStoredAppCompatEntry) + OffSet;
           InputCompareLength = sizeof(LARGE_INTEGER);
           OutputCompareLength = \
                            (ULONG) RtlCompareMemory(
                                       pAppCompatFlag,
                                       pExistingAppCompatFlag,
                                       InputCompareLength
                                       );
           if(OutputCompareLength ==  InputCompareLength)
              fAppCompatMatch = TRUE;
        }


        if(pOsVersionInfo){
           (PUCHAR)pExistingOsVersionInfo = (PUCHAR) (pStoredAppCompatEntry) + OffSet + \
                                                   sizeof(LARGE_INTEGER);
           InputCompareLength = pStoredAppCompatEntry->dwEntryTotalSize - \
                              (sizeof(PRE_APP_COMPAT_INFO) + \
                               pStoredAppCompatEntry->dwResourceInfoSize +\
                               sizeof(LARGE_INTEGER)
                              );
           if(InputCompareLength > TotalVersionInfoLength)
              InputCompareLength = TotalVersionInfoLength;

           OutputCompareLength = \
                            (ULONG) RtlCompareMemory(
                                       pOsVersionInfo,
                                       pExistingOsVersionInfo,
                                       InputCompareLength
                                       );
          if(OutputCompareLength ==  InputCompareLength)
             fOsVersionMatch = TRUE;
        }

        if( ( fOsVersionMatch == TRUE) &&
            ( fAppCompatMatch == TRUE) )
            break;
        else{ // one of these or both are different...
              /*
                The idea here is to replace that part of the AppCompatEntry, which is a
                mis-match. We go ahead and prepare the pReplaceAppCompatEntry
              */
           ReplaceCopyLength = sizeof(PRE_APP_COMPAT_INFO) + \
                        pStoredAppCompatEntry->dwResourceInfoSize + \
                        sizeof(LARGE_INTEGER) + \
                        TotalVersionInfoLength ;
           pReplaceAppCompatEntry = GlobalAlloc(GMEM_FIXED, ReplaceCopyLength);
           RtlCopyMemory((PUCHAR)pReplaceAppCompatEntry, (PUCHAR)pStoredAppCompatEntry, OffSet);
           RtlCopyMemory((PUCHAR)(pReplaceAppCompatEntry) + OffSet,(PUCHAR)pAppCompatFlag,sizeof(LARGE_INTEGER) );
           RtlCopyMemory((PUCHAR)(pReplaceAppCompatEntry)+(OffSet+sizeof(LARGE_INTEGER)),
                                                (PUCHAR)pOsVersionInfo,TotalVersionInfoLength);

           //Now prepare the GOO structure.
           ReplaceGooLength = pExistingVersionInfo ->dwTotalGooSize - \
                              pStoredAppCompatEntry->dwEntryTotalSize + \
                              ReplaceCopyLength;
           pReplaceAppCompatGoo = GlobalAlloc(GMEM_FIXED, ReplaceGooLength);
           pReplaceAppCompatGoo->dwTotalGooSize = ReplaceGooLength;

           pAppCompatEntry = pExistingVersionInfo->AppCompatEntry;
           pDestAppCompatEntry = ((PAPP_COMPAT_GOO)pReplaceAppCompatGoo)->AppCompatEntry;

           ReplaceGooLength -= sizeof(pExistingVersionInfo->dwTotalGooSize);
           while(ReplaceGooLength){
             CopyLength = pAppCompatEntry->dwEntryTotalSize;
             if(pAppCompatEntry != pStoredAppCompatEntry){
                RtlCopyMemory(pDestAppCompatEntry,pAppCompatEntry ,CopyLength);
                (PUCHAR)pDestAppCompatEntry += CopyLength;
             }
             else{
                RtlCopyMemory(pDestAppCompatEntry,pReplaceAppCompatEntry,ReplaceCopyLength);
                pDestAppCompatEntry->dwEntryTotalSize = ReplaceCopyLength;
                (PUCHAR)pDestAppCompatEntry += ReplaceCopyLength;
                (PUCHAR)pAppCompatEntry += pAppCompatEntry->dwEntryTotalSize;
                ReplaceGooLength -= ReplaceCopyLength;
                continue;
             }

             (PUCHAR)pAppCompatEntry += CopyLength;
             ReplaceGooLength -= CopyLength;
            } // End while
           // Delete the key from the registry and add back the updated one.

           GetFileTitle(pszPath,szTitle,MAX_PATH);
           if(CheckExtension(szTitle) == NULL)
             lstrcat(szTitle,TEXT(".exe"));
           DeleteRegistryValueGoo(szTitle);
           SetRegistryValGoo(szTitle,
                             TEXT("ApplicationGoo"),
                             (PUCHAR)pReplaceAppCompatGoo,
                             REG_BINARY,
                             pReplaceAppCompatGoo->dwTotalGooSize
                             );

          GlobalFree(pReplaceAppCompatEntry);
          GlobalFree(pReplaceAppCompatGoo);
        } // Else..

        break;
  } // End while (TotalGooLength )


  if(FALSE == fMatchGot){
    // No match available for this version.
    fNeedAppend = TRUE;
    // Reset the iteration count.
    iLoop  =  0;
  }

  if(g_fNotPermanent){
     // The user has chosen not to make the registry settings permanent and we have the
     // "Append" flag set indicating that there were entries appended to the ApplicationGoo.
     // We need to remove the correct entry for this executable.

     // The idea here is to copy the whole of "ApplicationGoo" to a global buffer leaving just
     // the one that needs to be deleted. Our job is made easier as we have the stored AppCompat
     // entry. We just need to go till there and copy the rest on to the global buffer.

     if(pStoredAppCompatEntry){
        pAppCompatEntry = pExistingVersionInfo->AppCompatEntry;
        TotalGooLength  = pExistingVersionInfo->dwTotalGooSize;
        g_lpPrevRegSettings = (PAPP_COMPAT_GOO)GlobalAlloc(GMEM_FIXED, TotalGooLength );
        ((PAPP_COMPAT_GOO)g_lpPrevRegSettings)->dwTotalGooSize = pExistingVersionInfo->dwTotalGooSize -
                                                                 pStoredAppCompatEntry->dwEntryTotalSize ;
        pDestAppCompatEntry = ((PAPP_COMPAT_GOO)g_lpPrevRegSettings)->AppCompatEntry;
        TotalGooLength -= sizeof(pExistingVersionInfo->dwTotalGooSize);
        while(TotalGooLength){
             CopyLength = pAppCompatEntry->dwEntryTotalSize;
             if(pAppCompatEntry != pStoredAppCompatEntry){
                RtlCopyMemory(pDestAppCompatEntry,pAppCompatEntry ,CopyLength);
                (PUCHAR)pDestAppCompatEntry += CopyLength;
                g_GooAppendFlag = TRUE;
             }

            (PUCHAR)pAppCompatEntry += CopyLength;
            TotalGooLength -= CopyLength;
        } // End while.
     }
     else{ // We do not have a stored AppCompatEntry. This means our target is to remove the
           // the first entry and leave the rest intact. i.e copy the rest onto the global buffer
           // for it to be copied.
           TotalGooLength = pExistingVersionInfo->dwTotalGooSize;
           g_lpPrevRegSettings = (PAPP_COMPAT_GOO)GlobalAlloc(GMEM_FIXED, TotalGooLength );
           RtlCopyMemory(g_lpPrevRegSettings,pExistingVersionInfo, TotalGooLength);
           g_GooAppendFlag = TRUE;
     }
  }

    return fNeedAppend;
  }



int MakeAppCompatGoo(TCHAR* TmpBuffer,LARGE_INTEGER* pAppCompatFlag, UINT uOsVer)
{
	BOOLEAN fImageHasVersionInfo = FALSE;
	BOOLEAN fOsVersionLie = FALSE;
	BOOLEAN fEntryPresent = FALSE;
 	TCHAR Buffer[MAX_PATH];
	TCHAR StringBuffer[MAX_PATH];
	TCHAR RegPath[MAX_PATH];
	TCHAR InChar;
	LONG status;
	HKEY hKey;
	PTCHAR pBuf;
	PTCHAR pAppGooBuf;
	PUCHAR pData;
	PTCHAR OutBuffer;
	PWCHAR uniBuffer;
	DWORD VersionInfoSize;
	DWORD dwHandle;
	DWORD dwBytesWritten;
	DWORD dwType;
	DWORD dwSize;
	ULONG i, j;
	ULONG EXELength;
	ULONG AppCompatHigh;
	ULONG AppCompatLow;
	ULONG TotalGooSize;
	ULONG TotalVersionInfoLength=0;
	ULONG OutBufferSize;
	PVOID lpData;
	PVOID ResourceInfo;
	PVOID VersionInfo;
	PAPP_COMPAT_GOO AppCompatGoo;
	PAPP_VARIABLE_INFO VariableInfo=NULL;
	PAPP_VARIABLE_INFO AppVariableInfo=NULL;
	EFFICIENTOSVERSIONINFOEXW OSVersionInfo, *pOsVersionInfo;

	// Remove the trailing and leading " " if PRESENT.
	    if(*TmpBuffer == TEXT('\"') ){
           lstrcpy(Buffer, TmpBuffer+1);
		   *(Buffer + (lstrlen(Buffer) - 1) )= TEXT('\0');
		 }
		 else
		   	lstrcpy(Buffer, TmpBuffer);
		   	
	// Quick check to see if its got any version info in its header
	VersionInfoSize = GetFileVersionInfoSize(&Buffer[0], &dwHandle);
	if (VersionInfoSize) {
		// It does, so alloc space for it to pull it in below
		VersionInfo = LocalAlloc(GMEM_FIXED, VersionInfoSize);
		if (VersionInfo) {
			// Get the version info
			if (GetFileVersionInfo(&Buffer[0], dwHandle, VersionInfoSize, VersionInfo)) {
				// Set global flag to be inspected later
				fImageHasVersionInfo = TRUE;
			}
		}
	}

	// Enter the app compat flags (decimal) - its defined as a LARGE_INTEGER	
    AppCompatHigh = 0x0;
    AppCompatLow  = 0x0;
    AppCompatLow  = pAppCompatFlag->LowPart;
    AppCompatHigh = pAppCompatFlag->HighPart;

	
	// Determine goo size, start with main goo
	TotalGooSize = sizeof(APP_COMPAT_GOO);

	

	// Add sizeof compatibility flags (large integer)
	TotalGooSize += sizeof(LARGE_INTEGER);
	// if we actually got version information add the length of that.  We take the minimum
	// of whatever the EXE has or 0x200 bytes to try and identify the app.  I've found that
	// anything less than 0x200 bytes doesn't supply enough info to be useful.
	if (fImageHasVersionInfo) {
		VersionInfoSize = min(VersionInfoSize, MIN_VERSION_RESOURCE);
		TotalGooSize += VersionInfoSize;
	}

	// See if they requested version lying, if so we got a bunch more horseshit todo
	if (AppCompatLow & KACF_VERSIONLIE) {
       fOsVersionLie  = TRUE;
	
       OSVersionInfo.dwMajorVersion = uVersionInfo[uOsVer][0];
       OSVersionInfo.dwMinorVersion = uVersionInfo[uOsVer][1];
       OSVersionInfo.dwBuildNumber  = uVersionInfo[uOsVer][2];
       OSVersionInfo.dwPlatformId   = uVersionInfo[uOsVer][3];
       OSVersionInfo.wServicePackMajor = (WORD)uVersionInfo[uOsVer][4];
       OSVersionInfo.wServicePackMinor = (WORD)uVersionInfo[uOsVer][5];
       OSVersionInfo.wSuiteMask      = (WORD)uVersionInfo[uOsVer][6];
       OSVersionInfo.wProductType    = (BYTE)uVersionInfo[uOsVer][7];
       lstrcpy( (TCHAR*) OSVersionInfo.szCSDVersion, pszVersionInfo[uOsVer]);


		// Start with the length of the full struct
		TotalVersionInfoLength = sizeof(EFFICIENTOSVERSIONINFOEXW);
		// subtract the size of the szCSDVersion field	
		TotalVersionInfoLength -= sizeof(OSVersionInfo.szCSDVersion);

				// add the strlen amount plus 1 for the NULL wchar
        TotalVersionInfoLength += lstrlen((TCHAR*)OSVersionInfo.szCSDVersion )*sizeof(WCHAR)+sizeof(WCHAR);

        // Add the size of the variable length structure header (since VerInfo is var length)
		TotalVersionInfoLength += sizeof(APP_VARIABLE_INFO);
		// Add the total version info length to the goo size
		TotalGooSize += TotalVersionInfoLength;
		// Allocate space for the variable length version info
		AppVariableInfo = (PAPP_VARIABLE_INFO) LocalAlloc(GMEM_FIXED, sizeof(APP_VARIABLE_INFO) + TotalVersionInfoLength);
		if (!AppVariableInfo) {
			return -1;
		}
		// fill in the pertinent data in the variable length info header
		AppVariableInfo->dwVariableInfoSize = sizeof(APP_VARIABLE_INFO) + TotalVersionInfoLength;
		AppVariableInfo->dwVariableType = AVT_OSVERSIONINFO;
		// Do a pointer +1 operation here to get past the header to the actual data
		VariableInfo = AppVariableInfo + 1;
		// Copy the actual data in
		memcpy(VariableInfo, &OSVersionInfo, TotalVersionInfoLength);
	
	}

	//
	// See if an entry already exists in the registry.  If so, we'll have to glom
	// this entry into the other already existing one.
	//
	// Get the registry path all figured out
	memset(&RegPath[0], 0, sizeof(RegPath));
	lstrcat(&RegPath[0], IMAGE_EXEC_OPTIONS);
	EXELength = lstrlen(&Buffer[0]);
	pBuf = &Buffer[0];
	pBuf += EXELength;
	// work backward in the path til we find the the last backslash
	while ((*pBuf != '\\') && (pBuf != &Buffer[0])) {
		pBuf--;	
	}
	if (*pBuf == '\\') {
		pBuf++;
	}

	if(CheckExtension(pBuf) == NULL)
     lstrcat(pBuf,TEXT(".exe"));

	// cat the image.exe name to the end of the registry path
	lstrcat(&RegPath[0], pBuf);
	// try to open this key
	status = RegOpenKey(HKEY_LOCAL_MACHINE, &RegPath[0], &hKey);
	if (status == ERROR_SUCCESS) {	
		dwSize = 1;
		// do a query once with small size to figure out how big the binary entry is
		status = RegQueryValueEx(hKey, TEXT("ApplicationGoo"), NULL, &dwType, NULL, &dwSize);
		if( status == ERROR_SUCCESS){
			//
			// There's an entry already there.  Take the size of this Goo entry and add it
			// to the TotalGooSize LESS the size of the first dword in the APP_COMPAT_GOO
			// struct (as there already was one there).
			//
			
		//  Added here after checkin
            if(dwSize > 1){
                lpData = LocalAlloc(GMEM_FIXED, dwSize);
                if(lpData){
                  status = RegQueryValueEx(hKey, TEXT("ApplicationGoo"), NULL, &dwType, (PUCHAR) lpData, &dwSize);
                 // if(VersionInfo) ...Remove this as it is not necessary.
              //    if(fOsVersionLie)
                //    pOsVersionInfo = VariableInfo;

        	      fEntryPresent = CheckGooEntry( VersionInfo,
        			                             (PAPP_COMPAT_GOO)lpData,
        			                             fImageHasVersionInfo,
        			                             VersionInfoSize,
        			                             dwSize,
        			                             pAppCompatFlag,
        			                             AppVariableInfo,
        			                             TotalVersionInfoLength,
        			                             Buffer
        			                            );
     			  }
     		    }	

       // End add


            if(fEntryPresent)
			  TotalGooSize += dwSize - sizeof(AppCompatGoo->dwTotalGooSize);
			
			else{  // Nothing to append....return as it is the same.
			  if(fImageHasVersionInfo)
                LocalFree(VersionInfo);
              if(fOsVersionLie)
                LocalFree(AppVariableInfo);

              return 0;
			}
			
			

	  RegCloseKey(hKey);
	}
   }

	// Allocate the memory for the entire app compat goo
	AppCompatGoo = (PAPP_COMPAT_GOO) LocalAlloc(GMEM_FIXED, TotalGooSize);
	if (!AppCompatGoo) {
		return -1;
	}

	// fill in the total size
	AppCompatGoo->dwTotalGooSize = TotalGooSize;
	// if there was version info for this entry we need to fill that in now, else zero
	if (fImageHasVersionInfo) {
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize = VersionInfoSize;
	}
	else {
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize = 0;
	}
	AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize = \
		sizeof(AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize) +
		sizeof(AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize) +
		TotalVersionInfoLength +						// In case app needed VER lying
		sizeof(LARGE_INTEGER);							// For app compatibility flags

	// Entry size is whatever it was plus any resource info we've got
	AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize += \
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize;
	// do the pointer +1 thing so we can be pointing at the data area
	ResourceInfo = AppCompatGoo->AppCompatEntry + 1;
	// copy the data in
	memcpy(ResourceInfo, VersionInfo, VersionInfoSize);

	// filling in the app compat flags here
	pData = (PUCHAR) ResourceInfo + AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize;
	memcpy(pData, &AppCompatLow, sizeof(AppCompatLow));
	pData += sizeof(AppCompatLow);
	memcpy(pData, &AppCompatHigh, sizeof(AppCompatHigh));
	pData += sizeof(AppCompatHigh);
	// if there was any version resource info, copy that in here too
	if (AppVariableInfo) {
		memcpy(pData, AppVariableInfo, TotalVersionInfoLength);
	}
	pData += TotalVersionInfoLength;
	//
	// If an already existing entry was there, we need to ask append what was there to the
	// tail of the entry.   (i.e. what's already there gets auto appended to the tail).  If
	// someone wants to write a 1-N positioning for entries within the Goo - they'll have to
	// add that support here
	//
	if (fEntryPresent) {
		// Start at offset + 4 cuz the previous Total Goo size must be skipped.
		memcpy(pData, (PUCHAR) lpData+4, dwSize - sizeof(AppCompatGoo->dwTotalGooSize));
	}


    pData = (PUCHAR) AppCompatGoo;
    SetRegistryValGoo(pBuf, TEXT("ApplicationGoo"),pData,REG_BINARY,AppCompatGoo->dwTotalGooSize);


    if(fImageHasVersionInfo)
       LocalFree(VersionInfo);
    if(fOsVersionLie)
       LocalFree(AppVariableInfo);
    if(fEntryPresent)
       LocalFree(lpData);
    LocalFree(AppCompatGoo);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparse.h ===
#ifndef APPPARSE_H
#define APPPARSE_H

#include <windows.h>
#include <stdio.h>

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparsecui.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    appparsecui.cpp

 Abstract:

    Command line interface for appparse

    
 History:

    06/27/2000 t-michkr  Created

--*/
#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shfolder.h>
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include "appparse.h"

// These are needed for command line compiling
#define stricmp     _stricmp
#define strnicmp    _strnicmp
#define getche      _getche

// Print a help screen to the console.
void PrintHelp()
{
    printf("Display application import information.\n");
    printf("APPPARSE target [outputfile]");
    printf("[/C] [/R] [/S] [/A] [/V] [/K:func]\n");
    printf("  target     Specifies the target filename or directory to be profiled.\n");
    printf("    A valid directory or binary file must be specified.  In the case of:\n");
    printf("    DIRECTORY   -   All binary files in the directory will be profiled.\n");
    printf("    FILENAME    -   The file and its dependencies will be profiled.\n");
    printf("\n");
    printf("  outputfile Specifies output file name.  Default is [targetfile].XML.\n");
    printf("  /C         Ignore output file, and send output to console.\n");
    printf("  /R         Raw format. (No XML tags, default for non-XML output file.)\n");
    printf("  /S         Profile subfolders.  Only valid when target is a directory.\n");
    printf("  /A         API logging only.\n");

    printf("\n");
    printf("Advanced Features\n");
    printf("  /V       Verbose\n");
    printf("  /K:func    Only return those functions matching the key func (case insensitive, wildcards)\n");
    printf("\n\n");
    printf("Example: appparse \"C:\\Program Files\\foo /V /K:Create*\n");
}

// Get a default Output file name for a path, trim dir and extension info.
char* GetOutputFileName(const char* szPath)
{
    int iOffset = strlen(szPath);
    char* szTemp = 0;

    // If its a drive, use the volume name for output file.
    if(szPath[strlen(szPath)-1] == ':' ||
        (szPath[strlen(szPath)-1] == '\\' &&
        szPath[strlen(szPath)-2] == ':'))
    {
        char szBuffer[MAX_PATH];
        if(GetVolumeInformation(szPath, szBuffer, MAX_PATH, 0, 0, 0, 0, 0))
        {
            szTemp = new char[strlen(szBuffer)+strlen(".xml")+1];
            strcpy(szTemp, szBuffer);
            strcat(szTemp, ".xml");
            return szTemp;
        }
    }

    for(; iOffset >= 0; iOffset--)
    {
        if(szPath[iOffset] == '\\')
        {
            if(iOffset == static_cast<int>(strlen(szPath)))
            {
                strcpy(szTemp, szPath);
                break;
            }
            szTemp = new char[strlen(szPath)-iOffset + 5];
            strcpy(szTemp, &szPath[iOffset+1]);
            break;
        }
    }

    if(iOffset < 0)
    {
        szTemp = new char[strlen(szPath) + 5];
        strcpy(szTemp, szPath);
    }

    for(iOffset = strlen(szTemp); iOffset >= static_cast<int>((strlen(szTemp)-4)); iOffset--)
    {
        if(szTemp[iOffset] == '.')
        {
            szTemp[iOffset] = '\0';
            break;
        }
    }

    strcat(szTemp, ".xml");
    return szTemp;
}

int __cdecl main(int argc, char** argv)
{
    char* szAppName, szOutput[MAX_PATH];
    bool fRaw = false, fAPILogging = false, fVerbose = false,
        fRecurse = false;
    char* szSearch = "*";
    FILE* pFile = 0;

    if(argc < 2)
    {
        PrintHelp();
        return 0;
    }

    if(strnicmp(argv[1], "/?", strlen("/?"))==0)
    {
        PrintHelp();
        return 0;

    }

    // Get command line options
    szAppName = argv[1];    

    int i = 2;

    // Check for output file
    if(argc > 2 && *argv[i] != '/')
    {
        // Output file specified.
        strcpy(szOutput,argv[i]);

        if(!strchr(szOutput, '.'))
            strcat(szOutput, ".xml");
        else
        {
            // Switch to raw output if non XML extension specified.
            if(szOutput[strlen(szOutput)-4] != '.'
                || szOutput[strlen(szOutput)-3] != 'x'
                || szOutput[strlen(szOutput)-2] != 'm'
                || szOutput[strlen(szOutput)-1] != 'l')
            {
                fRaw = true;
            }
        }

        i++;
    }
    else
    {
        // No output specified, just use appname
        strcpy(szOutput,GetOutputFileName(szAppName));
    }


    // Loop through all command line options.
    for(; i < argc; i++)
    {
        // Output to console
        if(strnicmp(argv[i], "/C", 2)==0)
        {
            pFile = stdout;
        }
        // Raw mode, no XML tags.
        else if(strnicmp(argv[i], "/R", 2)==0)
        {
            fRaw = true;
        }
        // Recurse into subdirectories for directory profiling
        else if(strnicmp(argv[i], "/S", 2)==0)
        {
            fRecurse = true;
        }
        // Do not print import module info, just functions.
        else if(strnicmp(argv[i], "/A", 2)==0)
        {
            fAPILogging = true;
        }
        // Verbose mode, print out extended information
        else if(strnicmp(argv[i], "/V", 2)==0)
        {
            fVerbose = true;
        }
        // Use a search key
        else if(strnicmp(argv[i], "/K:", 3)==0)
        {
            if(strlen(argv[i]) == 3)
            {
                if(i == (argc - 1))
                {
                    printf("Missing search string\n");
                    return 0;
                }
                else
                {
                    szSearch = argv[i+1];
                    i++;
                }
            }
            else
            {
                szSearch = &((argv[i])[3]);
            }
        }
        // Print help
        else if(strnicmp(argv[i], "/?", 2)==0)
        {
            PrintHelp();
            return 0;
        }
        else
        {
            printf("Unrecognized option, %s\n", argv[i]);
            return 0;
        }

    }

       // If pFile wasn't already set to stdout
    if(!pFile)
    {
        // Check if it already exists
        if(GetFileAttributes(szOutput) != -1)
        {
            printf("Output file already exists, overwrite? ");

            if(getche() != 'y')
                return 0;
        }

        // Try to open file
        pFile = fopen(szOutput, "wt+");        
        if(!pFile)
        {
            printf("\nUnable to open output file %s\n", szOutput);

            // Try in My Documents folder
            char szBuffer[MAX_PATH+1];
            HRESULT hr = SHGetFolderPath(0, CSIDL_PERSONAL,0, 
                0, szBuffer);

            if(SUCCEEDED(hr))
            {
                if((strlen(szBuffer) + strlen(szOutput) + 1) < MAX_PATH)
                {
                    strcat(szBuffer, "\\");
                    strcat(szBuffer, szOutput);                    

                    if(GetFileAttributes(szBuffer) != -1)
                    {
                        printf("%s already exists, overwrite? ", szBuffer);
                        if(getche() != 'y')
                            return 0;
                    }
                    pFile = fopen(szBuffer, "wt+");
                    if(!pFile)
                    {
                        printf("\nUnable to open output file %s\n", szBuffer);
                        hr = E_FAIL;
                    }
                    else
                        strcpy(szOutput, szBuffer);
                }
                else
                    hr = E_FAIL;
            }
            
            if(FAILED(hr))
            {
                // Try in "temp" directory
                char szBuffer[MAX_PATH + 1];
                if(GetTempPath(MAX_PATH, szBuffer))
                {
                    if((strlen(szBuffer) + strlen(szOutput) + 1) < MAX_PATH)
                    {
                        strcat(szBuffer, szOutput);                        
                        if(GetFileAttributes(szBuffer) != -1)
                        {
                            printf("%s already exists, overwrite? ", szBuffer);
                            if(getche() != 'y')
                                return 0;
                        }
                        
                        pFile = fopen(szBuffer, "wt+");
                        if(!pFile)
                        {
                            printf("\nUnable to open output file\n");
                            return 0;
                        }
                        else
                            strcpy(szOutput, szBuffer);
                    }
                    else
                    {
                        printf("\nUnable to open output file\n");
                        return 0;
                    }
                }
                else
                {
                    printf("\nUnable to open output file\n"); 
                    return 0;
                }
            }
        }
    }

    printf("\nProfiling . . .\n");
    DWORD dwError = AppParse(szAppName, pFile, fRaw, fAPILogging, fRecurse, fVerbose, 
        szSearch, 0);
    
    switch(dwError)
    {    
    case ERROR_SUCCESS:
        if(pFile != stdout)
            printf("Output successfully written to %s.\n", szOutput);
        break;
    case ERROR_FILE_NOT_FOUND:
        printf("The system was not able to find the file specified.\n");
        break;
    default:
        printf("Unknown error\n");
        break;
    }

    if(pFile && pFile != stdout)
        fclose(pFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\stdafx.h ===
// No Precompiled headers currently used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparse.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    appparse.cpp

 Abstract:

    Core Engine for dumping importing information from DLL's
    and executables into an XML file

    Used by command line appparse and web-based appparse

    
 History:

    06/07/2000 t-michkr  Created

--*/

//#define PJOB_SET_ARRAY int

#include "stdafx.h"

#include <windows.h>
#include <delayimp.h>
#include <shlwapi.h>
#include <sfc.h>
#include <lmcons.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <new.h>
#include "acFileAttr.h"


// These are needed for command line compiling
#define stricmp     _stricmp

// Global heap for AppParse.  If 0, Process Heap is used instead.
HANDLE g_hHeap = 0;

// Global search string
char* g_szSearch = "*";

// Whether we are in "verbose" mode, or not.
bool g_fVerbose = false;

// To sort output by DLLs
bool g_fAPILogging = false;

// True if no XML tags are to be printed, false otherwise
bool g_fRaw = false;

// Whether to recurse into subdirectories.
bool g_fRecurse = false;

// Current path relative to start, used by CModule
char g_szCurrentPath[MAX_PATH] = {'\0'};

// Returns true if szFileName is a system DLL (like gdi32, user32, etc.)
bool IsSystemDLL(const char* szFileName);

// Resolve a linker name to a "normal" name (unmangle C++ names, etc.)
void LinkName2Name(char* szLinkName, char* szName);

// Just do indentation, save repetitious code
void Indent(int iLevel, FILE* pFile = stdout);

// Check if function matches global search string
bool MatchFunction(const char* szFunc);

// Go through a directory and profile EXE's.
void ProfileDirectory(char* szDirectory, HANDLE hEvent);

void* __cdecl operator new(size_t size);
void __cdecl operator delete(void* pVal);

// Replace XML reserved characters like > with &gt
void WriteXMLOKString(char* szString, FILE* pFile);

// Parsing history for modules
class CModuleParseStack
{
private:
    struct SNode
    {
        char* szName;
        SNode* pNext;

        SNode()
        {
            szName  = 0;
            pNext   = 0;            
        }

        ~SNode()
        {
            if(szName)
            {
                delete szName;
                szName = 0;
            }
        }
    };
    SNode* m_pList;

public:

    // Constructor, setup empty list.
    CModuleParseStack()
    {
        m_pList = 0;
    }
    
    // Add a name to the top of the parse stack
    void PushName(char* szName)
    {
        assert(!IsBadReadPtr(szName, 1));
        SNode* pNode = new SNode;
        pNode->szName = new char[strlen(szName)+1];
        strcpy(pNode->szName, szName);
        pNode->pNext = m_pList;
        m_pList = pNode;
    }

    // Remove a name from the top of the parse stack
    void Pop()
    {
        assert(m_pList);
        SNode* pTemp = m_pList->pNext;
        delete m_pList;
        m_pList = pTemp;
    }

    // Return true if module has already been parsed
    bool CheckModuleParsed(char* szName)
    {
        assert(!IsBadReadPtr(szName, 1));
        SNode* pNode = m_pList;
        while(pNode)
        {
            if(stricmp(pNode->szName, szName) == 0)
                return true;
            pNode = pNode->pNext;
        }

        return false;
    }

    bool IsEmpty()
    {
        return (m_pList == 0);
    }

    void ClearParseHistory()
    {
        SNode* pNode = m_pList;
        while(pNode)
        {
            SNode* pNext = pNode->pNext;

            delete pNode;
            pNode = pNext;
        }
        m_pList = 0;
    }
};

// CFunction, an imported function and associated information.
class CFunction
{
private:
    // Name of function (if imported by name)
    char* m_szName;

    // Name of function actually pointed to.
    char* m_szForwardName;

    // Ordinal, older style importing
    int m_iOrdinal;

    // Quick lookup info
    int m_iHint;

    // Address of function, if bound
    DWORD m_dwAddress;

    // Whether this function is a delayed import or not.
    bool m_fDelayed;

    // Next function in list
    CFunction* m_pNext;

    // No default construction or copying allowed
    CFunction();
    CFunction operator=(const CFunction&);

public:
    CFunction(char* szName, int iHint, int iOrdinal, DWORD dwAddress, 
        bool fDelayed)
    {
        assert(!IsBadReadPtr(szName, 1));
        m_szName = new char[strlen(szName)+1];
        strcpy(m_szName, szName);
        m_iOrdinal = iOrdinal;
        m_iHint = iHint;
        m_dwAddress = dwAddress;
        m_pNext = 0;
        m_fDelayed = fDelayed;
        m_szForwardName = 0;
    }

    CFunction(const CFunction& fn)
    {
        m_szName = new char[strlen(fn.m_szName)+1];
        strcpy(m_szName, fn.m_szName);
        m_iOrdinal = fn.m_iOrdinal;
        m_iHint = fn.m_iHint;
        m_dwAddress = fn.m_dwAddress;
        m_pNext = 0;
        m_fDelayed = fn.m_fDelayed;

        if(fn.m_szForwardName)
        {
            m_szForwardName = new char[strlen(fn.m_szForwardName)+1];
            strcpy(m_szForwardName, fn.m_szForwardName);
        }
        else
            m_szForwardName = 0;
    }
        
    ~CFunction()
    {
        if(m_szName)
        {
            delete m_szName;
            m_szName = 0;
        }

        if(m_szForwardName)
        {
            delete m_szForwardName;
            m_szForwardName = 0;
        }
    }

    CFunction* Next()
    { return m_pNext; }

    char* Name()
    { return m_szName; }

    void SetForwardName(char* szForward)
    {
        assert(!IsBadReadPtr(szForward, 1));
        m_szForwardName = new char[strlen(szForward)+1];
        strcpy(m_szForwardName, szForward);
    }

    void SetNext(CFunction* pFunc)
    {
        assert(pFunc == 0 || !IsBadReadPtr(pFunc, 1));
        m_pNext = pFunc;
    }

    // Display function info, either to console
    // or to XML file.
    static void WriteHeader(int iIndentLevel, FILE* pFile);
    void WriteFunction(int iIndentLevel, FILE* pFile);
};

// COrdinalImport
// A function imported by ordinal, to be resolved to a CFunction
class COrdinalImport
{
private:
    int m_iOrdinal;
    COrdinalImport* m_pNext;
    bool m_fDelayed;

    COrdinalImport();
    COrdinalImport(const COrdinalImport&);
    COrdinalImport& operator = (const COrdinalImport&);

public:
    COrdinalImport(int iOrd, bool fDelayed = false)
    {
        m_iOrdinal = iOrd;
        m_fDelayed = fDelayed;
    }

    int GetOrdinal()
    { return m_iOrdinal;}
    
    bool GetDelayed()
    { return m_fDelayed; }

    COrdinalImport* Next()
    { return m_pNext; }

    void SetNext(COrdinalImport* pNext)
    { m_pNext = pNext; }
};

// CModule, an executable image with imports
class CModule
{
    friend class CGlobalModuleList;
private:
    // The name of this module (in the form path\foo.exe)
    char* m_szName;

    // The name of this module relative to the starting path
    char* m_szFullName;

    // Base pointer of the image in memory.
    void* m_pvImageBase;

    // DLL's imported by this module.
    CModule* m_pImportedDLLs;

    // Functions imported from this module by its parent.
    CFunction* m_pFunctions;

    // Functions imported by ordinal from this module
    COrdinalImport* m_pOrdinals;

    // Image headers
    PIMAGE_OPTIONAL_HEADER  m_pioh;
    PIMAGE_SECTION_HEADER   m_pish;
    PIMAGE_FILE_HEADER      m_pifh;

    // Next module in a list
    CModule* m_pNext;

    // Text description of any errors that may have occurred
    char* m_szError;

    // Whether or not this module is an OS module
    bool m_fSystem;    
    
    // Version info
    WORD m_wDosDate;
    WORD m_wDosTime;

    int m_nAttrCount;
    char** m_szAttrValues;
    char** m_szAttrNames;

    bool WalkImportTable();
    bool WalkDelayImportTable();

    static void InsertFunctionSorted(CFunction* pFunc, CFunction** ppList);

    bool ResolveForwardedFunctionsAndOrdinals();
    
    bool ParseImportTables();

    void InsertOrdinal(int iOrdinal, bool fDelayed = false);

    CModule* FindChild(char* szName);

    bool Empty();

    void GetAllFunctions(CFunction** ppFunctionList);

    void* RVAToPtr(const void* pAddr)
    { return RVAToPtr(reinterpret_cast<DWORD>(pAddr)); }

    void* RVAToPtr(DWORD dwRVA);

    void GetFileVerInfo(HANDLE hFile, char* szFileName);

  
public:
    CModule(char* szName);
    ~CModule();

    bool ParseModule(HANDLE hEvent);
    void InsertChildModuleSorted(CModule* pcm);

    // Functions to write module info to either the console or an XML file
    void WriteModule(bool fTopLevel, int iIndentLevel, FILE* pFile);
};

// List of all top-level modules being profiled
class CGlobalModuleList
{
private:
    CModule* m_pModules;
public:
    CGlobalModuleList()
    {
        m_pModules = 0;
    }
    ~CGlobalModuleList()
    {
        Clear();        
    }

    void Clear()
    {
        CModule* pMod = m_pModules;
        while(pMod)
        {
            CModule* pNext = pMod->m_pNext;
            delete pMod;
            pMod = pNext;
        }
        m_pModules = 0;
    }

    void InsertModuleSorted(CModule* pMod)
    {
        assert(!IsBadReadPtr(pMod, 1));
        // Special case, insert at front
        if(m_pModules == 0
            || stricmp(m_pModules->m_szFullName, pMod->m_szFullName) > 0)
        {
            pMod->m_pNext = m_pModules;
            m_pModules = pMod;
            return;
        }
        CModule* pPrev = m_pModules;
        CModule* pTemp = m_pModules->m_pNext;

        while(pTemp)
        {
            if(stricmp(pTemp->m_szFullName, pMod->m_szFullName) > 0)
            {
                pMod->m_pNext = pTemp;
                pPrev->m_pNext = pMod;;
                return;
            }
            pPrev = pTemp;
            pTemp = pTemp->m_pNext;
        }

        // Insert at end
        pMod->m_pNext = 0;
        pPrev->m_pNext = pMod;;
    }

    void Write(FILE* pFile, char* szProjectName, int iPtolemyID)
    {
        if(!g_fRaw)
        {
            fprintf(pFile, "<APPPARSERESULTS>\n");
            fprintf(pFile, "<PROJECT NAME=\"%s\" ID=\"%d\">\n", 
                szProjectName, iPtolemyID);
        }

        CModule* pMod = m_pModules;
        while(pMod)
        {
            pMod->WriteModule(true, 0, pFile);
            pMod = pMod->m_pNext;
        }

        if(!g_fRaw)
        {
            fprintf(pFile, "</PROJECT>\n");
            fprintf(pFile, "</APPPARSERESULTS>\n");
        }
    }    
};

// Global parsing history
CModuleParseStack g_ParseStack;

// Empty global module, containing all modules parsed
CGlobalModuleList g_modules;

CModule::CModule(char* szName)
{
    assert(!IsBadReadPtr(szName, 1));
    m_szName = new char[strlen(szName)+1];
    strcpy(m_szName, szName);

    WIN32_FIND_DATA ffd;
    
    // Only give it the full relative path if it is in this directory
    // If elsewhere, give it just the filename.
    HANDLE hSearch = FindFirstFile(szName, &ffd);
    if(hSearch == INVALID_HANDLE_VALUE)
    {
        m_szFullName = new char[strlen(m_szName) + 1];
        strcpy(m_szFullName, m_szName);
    }
    else
    {
        m_szFullName = new char[strlen(m_szName) + strlen(g_szCurrentPath)+1];
        strcpy(m_szFullName, g_szCurrentPath);
        strcat(m_szFullName, m_szName);
        FindClose(hSearch);
    }

    m_pvImageBase = 0;
    m_pImportedDLLs = 0;
    m_pFunctions = 0;
    m_pOrdinals = 0;
    m_pioh = 0;
    m_pish = 0;
    m_pifh = 0;
    m_pNext = 0;
    m_szError = 0;
    m_fSystem = false;
    m_nAttrCount = 0;
    m_szAttrValues = 0;
    m_szAttrNames = 0;
    m_wDosDate = 0;
    m_wDosTime = 0;
}

CModule::~CModule()
{
    if(m_szName)
    {
        delete m_szName;
        m_szName = 0;
    }

    if(m_szFullName)
    {
        delete m_szFullName;
        m_szFullName = 0;
    }    

    CFunction* pFunc = m_pFunctions;
    while(pFunc)
    {
        CFunction* pNext = pFunc->Next();
        delete pFunc;
        pFunc = pNext;
    }
    m_pFunctions = 0;
    
    COrdinalImport* pOrd = m_pOrdinals;
    while(pOrd)
    {
        COrdinalImport* pNext = pOrd->Next();
        delete pOrd;
        pOrd = pNext;
    }
    m_pOrdinals = 0;

    for(int i = 0; i < m_nAttrCount; i++)
    {
        if(m_szAttrNames)
        {
            if(m_szAttrNames[i])
            {
                delete m_szAttrNames[i];
                m_szAttrNames[i] = 0;
            }
        }
        
        if(m_szAttrValues)
        {
            if(m_szAttrValues[i])
            {
                delete m_szAttrValues[i];
                m_szAttrValues[i] = 0;
            }
        }

    }
    if(m_szAttrNames)
    {
        delete m_szAttrNames;
        m_szAttrNames = 0;
    }

    if(m_szAttrValues)
    {
        delete m_szAttrValues;
        m_szAttrValues = 0;
    }
}

// Return true no functions are imported from this module,
// or any of its children modules.
bool CModule::Empty()
{
    if(m_pFunctions != 0 || m_pOrdinals != 0)
        return false;

    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        if(!pMod->Empty())
            return false;
        pMod = pMod->m_pNext;
    }
    return true;
}

// Convert a relative virtual address to an absolute address
void* CModule::RVAToPtr(DWORD dwRVA)
{
    assert(!IsBadReadPtr(m_pifh, sizeof(*m_pifh)));
    assert(!IsBadReadPtr(m_pish, sizeof(*m_pish)));
    assert(!IsBadReadPtr(m_pvImageBase, 1));

    PIMAGE_SECTION_HEADER pish = m_pish;

    // Go through each section
    for (int i = 0; i < m_pifh->NumberOfSections; i++)
    {
        // If it's in this section, computer address and return it.
        if ((dwRVA >= pish->VirtualAddress) &&
            (dwRVA < (pish->VirtualAddress + pish->SizeOfRawData)))
        {
            void* pAddr = 
                reinterpret_cast<void*>(reinterpret_cast<DWORD>(m_pvImageBase) + 
                pish->PointerToRawData + dwRVA - pish->VirtualAddress);
            return pAddr;
        }
        pish++;
    }

    // This indicates an invalid RVA, meaning an invalid image, so
    // throw an exception
    throw;
    return 0;
}

// Return a pointer to the first child matching szName, false otehrwise
CModule* CModule::FindChild(char* szName)
{
    assert(!IsBadReadPtr(szName, 1));
    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        if(stricmp(pMod->m_szName, szName)==0)
            return pMod;

        pMod = pMod->m_pNext;
    }
    return 0;
}

// Add an ordinal import to the module.
void CModule::InsertOrdinal(int iOrdinal, bool fDelayed)
{
    COrdinalImport* pNew = new COrdinalImport(iOrdinal, fDelayed);
 
    pNew->SetNext(m_pOrdinals);
    m_pOrdinals = pNew;
}

// Add an imported function to a function list.
void CModule::InsertFunctionSorted(CFunction* pFunc, CFunction** ppList)
{
    // Special case, insert at front
    if((*ppList)== 0
        || stricmp((*ppList)->Name(), pFunc->Name()) > 0)
    {
        pFunc->SetNext(*ppList);
        (*ppList) = pFunc;
        return;
    }
    CFunction* pPrev = *ppList;
    CFunction* pTemp = (*ppList)->Next();

    while(pTemp)
    {
        // Don't insert duplicates.  This is mainly for API logging only.
        if(strcmp(pTemp->Name(), pFunc->Name())==0)
            return;

        if(stricmp(pTemp->Name(), pFunc->Name()) > 0)
        {
            pFunc->SetNext(pTemp);
            pPrev->SetNext(pFunc);
            return;
        }        

        pPrev = pTemp;
        pTemp = pTemp->Next();
    }

    // Insert at end
    pFunc->SetNext(0);
    pPrev->SetNext(pFunc);
}

// Add a child module to this module.
void CModule::InsertChildModuleSorted(CModule* pcm)
{
    // Special case, insert at front
    if(m_pImportedDLLs == 0
        || stricmp(m_pImportedDLLs->m_szName, pcm->m_szName) > 0)
    {
        pcm->m_pNext = m_pImportedDLLs;
        m_pImportedDLLs = pcm;
        return;
    }
    CModule* pPrev = m_pImportedDLLs;
    CModule* pTemp = m_pImportedDLLs->m_pNext;

    while(pTemp)
    {
        if(stricmp(pTemp->m_szName, pcm->m_szName) > 0)
        {
            pcm->m_pNext = pTemp;
            pPrev->m_pNext = pcm;;
            return;
        }
        pPrev = pTemp;
        pTemp = pTemp->m_pNext;
    }

    // Insert at end
    pcm->m_pNext = 0;
    pPrev->m_pNext = pcm;;
}

// Add all functions imported from this module to the function list
// Used mainly for API logging.
void CModule::GetAllFunctions(CFunction** ppFunctionList)
{
    CFunction* pFunc = m_pFunctions;
    
    while(pFunc)
    {
        // Copy pFunc
        CFunction* pNew = new CFunction(*pFunc);
        InsertFunctionSorted(pNew, ppFunctionList);

        pFunc = pFunc->Next();
    }

    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        pMod->GetAllFunctions(ppFunctionList);
        pMod = pMod->m_pNext;
    }
}

// Go through a modules export table and get forwarding information
// and resolve ordinal imports to name.
bool CModule::ResolveForwardedFunctionsAndOrdinals()
{
    // Get virtual address of export table
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    
    // Get export table info
    PIMAGE_EXPORT_DIRECTORY pied = 
        reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(RVAToPtr(dwVAImageDir));

    DWORD* pdwNames = reinterpret_cast<DWORD*>(RVAToPtr(pied->AddressOfNames));

    WORD* pwOrdinals = reinterpret_cast<WORD*>(RVAToPtr(pied->AddressOfNameOrdinals));

    DWORD* pdwAddresses = reinterpret_cast<DWORD*>(RVAToPtr(pied->AddressOfFunctions));

    // Go through each entry in the export table
    for(unsigned uiHint = 0; uiHint < pied->NumberOfNames; uiHint++)
    {
        // Get function name, ordinal, and address info.
        char* szFunction = reinterpret_cast<char*>(RVAToPtr(pdwNames[uiHint]));
        int ordinal = pied->Base + static_cast<DWORD>(pwOrdinals[uiHint]);
        DWORD dwAddress = pdwAddresses[ordinal-pied->Base];
        char* szForward = 0;
        
        // Check if this function has been forwarded to another DLL
        // Function has been forwarded if address is in this section.
        // NOTE: The DEPENDS 1.0 source says otherwise, but is incorrect.
        if( (dwAddress >= dwVAImageDir) &&
            (dwAddress < (dwVAImageDir + 
            m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)))
            szForward = reinterpret_cast<char*>(RVAToPtr(dwAddress));

        // Check if we have an ordinal import refering to this
        COrdinalImport* pOrd = m_pOrdinals;
        CFunction* pFunc = 0;
        
        // See if we have a matching ordinal import.
        while(pOrd)
        {
            if(pOrd->GetOrdinal() == ordinal)
                break;
            pOrd = pOrd->Next();
        }

        if(pOrd != 0)
        {
            char szTemp[1024];

            // Unmangle forwarded name.
            LinkName2Name(szFunction, szTemp);

            // Check against search string
            if(MatchFunction(szTemp))
            {
                // Insert into module.
                pFunc = new CFunction(szTemp, -1, ordinal, 
                    dwAddress, pOrd->GetDelayed());
                InsertFunctionSorted(pFunc, &m_pFunctions);
            }
        }
        // No matching ordinal import, check normal imports.
        else
        {
            // Duck out early if this function isn't used in the executable.
            pFunc = m_pFunctions;
            while(pFunc)
            {
                if(strcmp(pFunc->Name(), szFunction)==0)
                    break;

                pFunc = pFunc->Next();
            }

            if(pFunc == 0)
                continue;
        }

        // Set forwarding info
        if(szForward && pFunc)
            pFunc->SetForwardName(szForward);
    }

    return true;
}

// Get delayed import info from module.
bool CModule::WalkDelayImportTable()
{
    // Bail early if no delayed import table.
    if(m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size == 0)
        return true;

    // Locate the directory section
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress;

    // Get the import descriptor array
    PImgDelayDescr pidd = reinterpret_cast<PImgDelayDescr>(RVAToPtr(dwVAImageDir));

    while(pidd->pINT)
    {
        char* szName;
        if(pidd->grAttrs & 1)        
            szName = reinterpret_cast<char*>(RVAToPtr(pidd->szName));
        else
            szName = reinterpret_cast<char*>(RVAToPtr(pidd->szName - m_pioh->ImageBase));

        PIMAGE_THUNK_DATA pitdf;
        if(pidd->grAttrs & 1)        
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(pidd->pINT));
        else
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(
            reinterpret_cast<DWORD>(pidd->pINT) - 
            static_cast<DWORD>(m_pioh->ImageBase)));

        // Locate child module, or create new if it does not exist.
        CModule* pcm = FindChild(szName);
        if(!pcm)
        {
            pcm = new CModule(szName);
            InsertChildModuleSorted(pcm);
        }

        // Loop through all imported functions
        while(pitdf->u1.Ordinal)
        {
            int iOrdinal;
            int iHint;

            // Check if imported by name or ordinal
            if(!IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
            {
                // Get name import info

                PIMAGE_IMPORT_BY_NAME piibn = 
                    reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
                    RVAToPtr(pitdf->u1.AddressOfData - m_pioh->ImageBase));

                char* szTemp = reinterpret_cast<char*>(piibn->Name);
                char szBuffer[1024];

                // Unmangle link name
                LinkName2Name(szTemp, szBuffer);                

                // Ordinal info is invalid
                iOrdinal = -1;

                iHint = piibn->Hint;

                // Check against search string
                if(MatchFunction(szBuffer))
                {
                    // Insert into function list
                    CFunction* psf = new CFunction(szBuffer, iHint, iOrdinal,
                        static_cast<DWORD>(-1), true);

                    pcm->InsertFunctionSorted(psf, &pcm->m_pFunctions);
                }
            }
            else
            {
                // Insert a new delayed ordinal import
                iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));

                pcm->InsertOrdinal(iOrdinal, true);
            }

            // Move on to next function
            pitdf++;
        }

        // Move to next delay import descriptor
        pidd++;
    }

    return true;
}

// Determine all functions imported by this module
bool CModule::WalkImportTable()
{
    // Bail out early if no directory
    if(m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0)
        return true;

    // Locate the directory section
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;    

    // Get the import descriptor array
    PIMAGE_IMPORT_DESCRIPTOR piid = 
        reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(RVAToPtr(dwVAImageDir));

    // Loop through all imported modules
    while(piid->FirstThunk || piid->OriginalFirstThunk)
    {

        // Get module name
        char* szName = reinterpret_cast<char*>(RVAToPtr(piid->Name));

        // Find child, or create new if it does not exist.
        CModule* pcm = FindChild(szName);
        if(!pcm)
        {
            pcm = new CModule(szName);
            InsertChildModuleSorted(pcm);
        }

        // Get all imports from this module
        PIMAGE_THUNK_DATA pitdf = 0;
        PIMAGE_THUNK_DATA pitda = 0;

        // Check for MS or Borland format
        if(piid->OriginalFirstThunk)
        {
            // MS format, function array is original first thunk
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->OriginalFirstThunk));

            // If the time stamp is set, this module has
            // been bound and the first thunk is the bound address array
            if(piid->TimeDateStamp)
                pitda = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->FirstThunk));
        }
        else
        {
            // Borland format uses first thunk for function array
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->FirstThunk));
        }

        // Loop through all imported functions
        while(pitdf->u1.Ordinal)
        {
            int iOrdinal;
            int iHint;

            // Determine if imported by ordinal or name
            if(!IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
            {
                // Get name import info
                PIMAGE_IMPORT_BY_NAME piibn = 
                    reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
                    RVAToPtr(pitdf->u1.AddressOfData));

                // Get function name
                char* szTemp = reinterpret_cast<char*>(piibn->Name);

                // Unmangle
                char szBuffer[1024];
                LinkName2Name(szTemp, szBuffer);                

                iOrdinal = -1;
                iHint = piibn->Hint;

                // Check against search string
                if(MatchFunction(szBuffer))
                {
                    // Insert into function list
                    CFunction* psf = new CFunction(szBuffer, iHint, iOrdinal,
                        pitda ? pitda->u1.Function : static_cast<DWORD>(-1),
                        false);

                    pcm->InsertFunctionSorted(psf, &pcm->m_pFunctions);
                }
            }
            else
            {
                // Insert an ordinal import into the module.
                iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));
                pcm->InsertOrdinal(iOrdinal);
            }

            // Move to next function
            pitdf++;

            if(pitda)
                pitda++;
        }

        // Move to next module
        piid++;
    }

    return true;
}

// Parse all import tables
bool CModule::ParseImportTables()
{
    return (WalkImportTable()
        && WalkDelayImportTable());
}

// Load a module into memory, and parse it.
bool CModule::ParseModule(HANDLE hEvent)
{
    // Cancel parsing if user canceled
    if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0) 
        return false;

    bool fSucceeded = false;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = 0;

    bool fPushed = false;

    m_pvImageBase = 0;

    // Wrap in a __try block, because an invalid executable image
    // may have bad pointers in our memory mapped region.
    __try
    {
        // Open the file
        char szFileName[1024];
        char* szJunk;
        if(!SearchPath(0, m_szName, 0, 1024, szFileName, &szJunk))
        {
            m_szError = "Unable to find file";
            __leave;
        }

        hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
            0, OPEN_EXISTING, 0, 0);
        if(hFile == INVALID_HANDLE_VALUE)
        {
            m_szError = "Unable to open file";
            __leave;
        }

        GetFileVerInfo(hFile, szFileName);

        // Map the file into memory
        hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
        if(hMap == 0)
        {
            m_szError = "Unable to map file";
            __leave;
        }

        m_pvImageBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
        if(m_pvImageBase == 0)
        {
            m_szError = "Unable to map file";
            __leave;
        }

        // Get header information and verify this is a valid executable
        // Get the MS-DOS compatible header
        PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(m_pvImageBase);
        if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
        {
            m_szError = "Invalid image, no MS-DOS header";
            __leave;
        }

        // Get the NT header and verify
        PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
            reinterpret_cast<DWORD>(m_pvImageBase) + pidh->e_lfanew);

        if(pinth->Signature != IMAGE_NT_SIGNATURE)
        {
            // Not a valid Win32 executable, may be a Win16 or OS/2 exe
            m_szError = "Invalid image, no PE signature";
            __leave;
        }

        // Get the other headers
        m_pifh = &pinth->FileHeader;
        m_pioh = &pinth->OptionalHeader;
        m_pish = IMAGE_FIRST_SECTION(pinth);

        // Check if anyone is importing
        // functions from us, and if so resolve
        // function forwarding and ordinals
        if(m_pFunctions || m_pOrdinals)
        {
            if(!ResolveForwardedFunctionsAndOrdinals())
                __leave;
        }

        // Parse import tables (only if not a system DLL or if parsing
        // this module may result in a dependency loop)
        m_fSystem = IsSystemDLL(m_szName);
        if(!m_fSystem && !g_ParseStack.CheckModuleParsed(m_szName))
        {
            // Add to parse stack
            g_ParseStack.PushName(m_szName);
            fPushed = true;

            // Parse
            if(!ParseImportTables())
                __leave;
        }        
        
        // Loop through each DLL imported
        CModule* pModule = m_pImportedDLLs;
        while(pModule)
        {
            // Parse each child module
            pModule->ParseModule(hEvent);                
            pModule = pModule->m_pNext;
        }

        fSucceeded = true;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_szError = "Unable to parse module";
        fSucceeded = false;
    }

    // Cleanup . . .
    if(m_pvImageBase)
        UnmapViewOfFile(m_pvImageBase);

    if(hMap != 0)
        CloseHandle(hMap);

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if(fPushed)
        g_ParseStack.Pop();

    return fSucceeded;
}

void CModule::GetFileVerInfo(HANDLE hFile, char* szFileName)
{
    if(g_fRaw || !g_fVerbose)
        return;

    // Get file version info
    HANDLE hVersionInfo = ReadFileAttributes(szFileName, &m_nAttrCount);

    // Get date info
    BY_HANDLE_FILE_INFORMATION fileInfo;
    GetFileInformationByHandle(hFile, &fileInfo);
    FILETIME ftDate;
    memcpy(&ftDate, &fileInfo.ftLastWriteTime, sizeof(FILETIME));
    
    CoFileTimeToDosDateTime(&ftDate, &m_wDosDate, &m_wDosTime);

    if(m_nAttrCount)
    {
        m_szAttrValues = new char*[m_nAttrCount];
        m_szAttrNames = new char*[m_nAttrCount];
        ZeroMemory(m_szAttrValues, sizeof(char*)*m_nAttrCount);
        ZeroMemory(m_szAttrNames, sizeof(char*)*m_nAttrCount);
        if(hVersionInfo)
            for(int i = 0; i < m_nAttrCount; i++)
            {
                char* szVal = GetAttrValue(hVersionInfo, i);                
                if(szVal)
                {
                    m_szAttrValues[i] = new char[strlen(szVal)+1];
                    strcpy(m_szAttrValues[i], szVal);

                    char* szAttrName = GetAttrNameXML(i);
                    if(szAttrName)
                    {
                        m_szAttrNames[i] = new char[strlen(szAttrName)+1];
                        strcpy(m_szAttrNames[i], szAttrName);
                    }
                }                
            }
    }

    if(hVersionInfo)
        CleanupFileManager(hVersionInfo);
}

// Return true if module is a system DLL, false otherwise
// We use the system file protection system, and assume all system
// files are protected.
bool IsSystemDLL(const char* szFileName)
{
    char szBuffer[1024], *szJunk;

    if(!SearchPath(0, szFileName, 0, 1024, szBuffer, &szJunk))
       return false;

    // Only check DLL's
    if(!StrStrI(szFileName, ".dll"))
        return false;

    wchar_t* wszFileName = new wchar_t[strlen(szBuffer) + 1];
    MultiByteToWideChar(CP_ACP, 0, szBuffer, strlen(szBuffer)+1,
        wszFileName, strlen(szBuffer)+1);

    bool fRet = (SfcIsFileProtected(0, wszFileName) != FALSE);
    delete wszFileName;

    return fRet;
}

// LinkName2Name()
// Resolve name mangling
void LinkName2Name(char* szLinkName, char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
  
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;
    bool fIsStdcall = false, fIsFastcall = false;
    char szFunction[1024];
    char szClass[1024];

    // Unmangle stdcall and fastcall names
    char* szAtSymbol = strrchr(szLinkName, '@');
    fIsFastcall = (szLinkName[0] == '@') && szAtSymbol && isdigit(szAtSymbol[1]);
    fIsStdcall = (szLinkName[0] == '_') && szAtSymbol && isdigit(szAtSymbol[1]);
    if(fIsFastcall || fIsStdcall)
    {
        szLinkName++;

        // Modifying the link name, so make a copy.
        // The file is mapped as read-only, and if it
        // were read/write, changes would be made to the
        // executable.
        char* szTemp = new char[strlen(szLinkName)+1];
        strcpy(szTemp, szLinkName);
        szLinkName = szTemp;

        *(strchr(szLinkName, '@'))= '\0';

        // ?????
        // I think we need to keep going, because it is possible
        // to have C++ name mangling on a stdcall name.
    }


    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", szFunction, szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", szFunction, szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", szClass, szFunction);
    } else {
        sprintf(szName, "%s", szFunction);
    }

    // stdcall and fastcall unmangling do a slight modification to 
    // the link name, we need to free it here.
    if(fIsStdcall || fIsFastcall)
        delete szLinkName;
}

// Parse a top level module
void ParseHighLevelModule(char* szName, HANDLE hEvent)
{
    // Create a new module
    CModule* pModule = new CModule(szName);

    assert(g_ParseStack.IsEmpty());
    g_ParseStack.ClearParseHistory();

    pModule->ParseModule(hEvent);

    // Add to global module list
    g_modules.InsertModuleSorted(pModule);
}

// Functions to print to console or XML file
// Just do indentation, save repetitious code
void Indent(int iLevel, FILE* pFile)
{
    for(int i = 0; i < iLevel; i++)
        fprintf(pFile, "\t");
}

// Write function header info for raw output
void CFunction::WriteHeader(int iIndentLevel, FILE* pFile)
{
    if(g_fVerbose && g_fRaw)
    {
        Indent(iIndentLevel, pFile);
        fprintf(pFile, "%-40s%-10s%-6s%-8s%-40s%-6s\n", "Name", "Address", "Hint", 
            "Ordinal", "Forwarded to", "Delayed");
    }
}

// Write a function, raw or XML
void CFunction::WriteFunction(int iIndentLevel, FILE* pFile)
{
    Indent(iIndentLevel, pFile);

    if(!g_fRaw)
    {        
        if(g_fVerbose)
        {       
            fprintf(pFile, "<FUNCTION NAME=\"");
            WriteXMLOKString(m_szName, pFile);
            fprintf(pFile, "\" ", m_szName);

            if(m_dwAddress != static_cast<DWORD>(-1))
                fprintf(pFile, "ADDRESS=\"0x%x\" ", m_dwAddress);

            if(m_iHint != -1)
                fprintf(pFile, "HINT=\"%d\" ", m_iHint);
       
            if(m_iOrdinal != -1)
                fprintf(pFile, "ORDINAL=\"%d\" ", m_iOrdinal);
    
            if(m_szForwardName != 0)
            {
                fprintf(pFile, "FORWARD_TO=\"");
                WriteXMLOKString(m_szForwardName, pFile);
                fprintf(pFile, "\" ");
            }

            fprintf(pFile, "DELAYED=\"%s\"/>\n", m_fDelayed ? "true" : "false");
        }
        else
        {
            fprintf(pFile, "<FUNCTION NAME=\"");
            WriteXMLOKString(m_szName, pFile);
            fprintf(pFile, "\"/>\n");
        }
    }
    else
    {
        if(g_fVerbose)
        {
            char szAddress[16] = "N/A";
            if(m_dwAddress != static_cast<DWORD>(-1))
                sprintf(szAddress, "0x%x", m_dwAddress);

            char szOrdinal[16] = "N/A";
            if(m_iOrdinal != -1)
                sprintf(szOrdinal, "0x%x", m_iOrdinal);

            char szHint[16] = "N/A";
            if(m_iHint != -1)
                sprintf(szHint, "%d", m_iHint);

            fprintf(pFile, "%-40s%-10s%-6s%-8s%-40s%-6s\n", m_szName, szAddress, 
                szHint, szOrdinal, m_szForwardName ? m_szForwardName : "N/A", 
                m_fDelayed ? "true" : "false");
        }
        else
        {
            fprintf(pFile, "%s\n", m_szName);
        }
    }
}

// Write an XML-compliant string (no <'s and >'s, replace with &gt, &lt, etc.)
void WriteXMLOKString(char* szString, FILE* pFile)
{ 
    const int c_nChars = 5;
    char acIllegal[] = {'<','>', '&', '\'', '\"'};
    char* szEntities[] = {"&lt;", "&gt;", "&amp;", "&apos;", "&quot;"};

    while(*szString)
    {
        int i;
        for(i = 0; i < c_nChars; i++)
        {
            if(*szString == acIllegal[i])
            {
                fprintf(pFile, szEntities[i]);
                break;
            }
        }
        if(i == c_nChars)
            fputc(*szString, pFile);
        szString++;
    }
}

// Write an entire module as output, either raw or XML.
void CModule::WriteModule(bool fTopLevel, int iIndentLevel, FILE* pFile)
{
    if(Empty() && m_szError == 0)
        return;

    Indent(iIndentLevel, pFile);

    if(!g_fRaw)
    {     
        if(fTopLevel)
            fprintf(pFile, "<EXE NAME=\"");
        else
            fprintf(pFile, "<DLL NAME=\"");
               
        WriteXMLOKString(m_szFullName, pFile);
        fprintf(pFile,"\">\n");
    }
    else
    {
        fprintf(pFile, "%s:\n", m_szFullName);
    }

    if(!g_fRaw && g_fVerbose && (m_nAttrCount || m_wDosDate))
    {
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "<INFO>\n");
        
        // Print out date information        
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "<DATE>%d/%d/%d</DATE>\n", (m_wDosDate & 0x1E0) >> 5,
            m_wDosDate & 0x1F, ((m_wDosDate & 0xFE00) >> 9) + 1980);

        for(int i = 0; i < m_nAttrCount; i++)
        {            
            if(m_szAttrValues[i])
            {                                                
                if(m_szAttrNames[i])
                {
                    if(strlen(m_szAttrNames[i]) != 0)
                    {                        
                        Indent(iIndentLevel+1, pFile);
                        fprintf(pFile, "<");
                        WriteXMLOKString(m_szAttrNames[i], pFile);
                        fprintf(pFile,">");
                        WriteXMLOKString(m_szAttrValues[i], pFile);
                        fprintf(pFile,"</");
                        WriteXMLOKString(m_szAttrNames[i], pFile);
                        fprintf(pFile, ">\n");                                        
                    }
                }                              
            }
            
        }
        
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "</INFO>\n");
    }

    // If an error occured in parsing
    if(m_szError)
    {
        Indent(iIndentLevel+1, pFile);       
        if(!g_fRaw)
        {
            fprintf(pFile, "<ERROR TYPE=\"");
            WriteXMLOKString(m_szError, pFile);
            fprintf(pFile,"\"/>\n");
        }
        else
            fprintf(pFile, "Parse Error: %s\n", m_szError);        
    }

    if(g_fVerbose)
    {
        Indent(iIndentLevel+1, pFile);

        if(m_fSystem)
        {            
            if(!g_fRaw)
                fprintf(pFile, "<SYSTEMMODULE VALUE=\"1\"/>\n");
            else
                fprintf(pFile, "(System Module)\n");
        }
        else
        {
            if(!g_fRaw)
                fprintf(pFile, "<SYSTEMMODULE VALUE =\"0\"/>\n");
            else
                fprintf(pFile, "(Private Module)\n");
        }
    }

    // Print all functions imported from this module

    if(g_fAPILogging && fTopLevel)
    {
        CFunction* pAllFunctions = 0;
        GetAllFunctions(&pAllFunctions);

        if(pAllFunctions)
            pAllFunctions->WriteHeader(iIndentLevel+1, pFile);
        
        while(pAllFunctions)
        {
            CFunction* pOld;
            pAllFunctions->WriteFunction(iIndentLevel+1, pFile);
            pOld = pAllFunctions;
            pAllFunctions = pAllFunctions->Next();
            delete pOld;
        }
    }
    else
    {

        CFunction* pFunc = m_pFunctions;
    
        if(pFunc)
            pFunc->WriteHeader(iIndentLevel, pFile);

        while(pFunc)
        {
            pFunc->WriteFunction(iIndentLevel, pFile);
            pFunc = pFunc->Next();
        }

        CModule* pMod = m_pImportedDLLs;
        while(pMod)
        {
            pMod->WriteModule(false, iIndentLevel + 1, pFile);
            pMod = pMod->m_pNext;
        }
    }

    Indent(iIndentLevel, pFile);
    if(!g_fRaw)
    {
        if(fTopLevel)
            fprintf(pFile, "</EXE>\n");
        else
            fprintf(pFile, "</DLL>\n");
    }

    fprintf(pFile, "\n");

    // Child modules no longer needed, delete
    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        CModule* pNext = pMod->m_pNext;
        delete pMod;
        pMod = pNext;
    }
    m_pImportedDLLs = 0;
}

// Write out the XML header
void WriteXMLHeader(FILE* pFile)
{
    if(g_fRaw)
        return;

    static char* szMonths[] =
    {"",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"};

    static char* szDays[] = 
    {"Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"};

    SYSTEMTIME st;
    GetLocalTime(&st);

    fprintf(pFile, "<?xml version = \"1.0\"?>\n");
    fprintf(pFile, "<!--\n");
    fprintf(pFile, "\tAppParse Datafile\n");
    fprintf(pFile, "\tGenerated: %s, %s %d, %d %2d:%2d:%2d\n",
        szDays[st.wDayOfWeek], szMonths[st.wMonth], st.wDay, st.wYear,
        st.wHour, st.wMinute, st.wSecond);

    fprintf(pFile, "-->\n\n");
}

// Return true if function name matches search string, false otherwise.
bool MatchFunction(const char* szFunc)
{
    if(strcmp(g_szSearch, "*") == 0)
        return true;

    char* szSearch = g_szSearch;
    while(*szSearch != '\0' && *szFunc != '\0')
    {
        // If we get a ?, we don't care and move on to the next
        // character.
        if(*szSearch == '?')
        {
            szSearch++;
            szFunc++;
            continue;
        }

        // If we have a wildcard, move to next search string and search for substring
        if(*szSearch == '*')
        {
            char* szCurrSearch;
            szSearch++;

            if(*szSearch == '\0')
                return true;

            // Don't change starting point.
            szCurrSearch = szSearch;
            for(;;)
            {
                // We're done if we hit another wildcard
                if(*szCurrSearch == '*' ||
                    *szCurrSearch == '?')
                {
                    // Update the permanent search position.
                    szSearch = szCurrSearch;
                    break;
                }
                // At end of both strings, return true.
                if((*szCurrSearch == '\0') && (*szFunc == '\0'))
                    return true;

                // We never found it
                if(*szFunc == '\0')                     
                    return false;

                // If it doesn't match, start over
                if(toupper(*szFunc) != toupper(*szCurrSearch))
                {
                    // If mismatch on first character
                    // of search string, move to next
                    // character in function string.
                    if(szCurrSearch == szSearch)
                        szFunc++;
                    else
                        szCurrSearch = szSearch;
                }
                else
                {
                    szFunc++;
                    szCurrSearch++;
                }
            }
        }
        else
        {
            if(toupper(*szFunc) != toupper(*szSearch))
            {
                return false;
            }

            szFunc++;
            szSearch++;
        }
    }

    if((*szFunc == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
        return true;
    else
        return false;
}

// Profile an entire directory
void ProfileDirectory(char* szDirectory, HANDLE hEvent)
{
    if(!SetCurrentDirectory(szDirectory))
        return;
 
    WIN32_FIND_DATA ffd;

    // Find and parse all EXE's.
    HANDLE hSearch = FindFirstFile("*.exe", &ffd);
    if(hSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            ParseHighLevelModule(ffd.cFileName, hEvent);
            
            // Terminate parsing if user canceled
            if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0)
            {
                FindClose(hSearch);
                SetCurrentDirectory("..");
                return;
            }
        }
        while(FindNextFile(hSearch, &ffd));

        FindClose(hSearch);
    }

    // See if we should go deeper into directories.
    if(g_fRecurse)
    {
        hSearch = FindFirstFile("*", &ffd);
        if(hSearch == INVALID_HANDLE_VALUE)
        {
            SetCurrentDirectory("..");
            return;
        }

        do
        {
            if(GetFileAttributes(ffd.cFileName) & FILE_ATTRIBUTE_DIRECTORY)
            {
                // Don't do an infinite recursion.
                if(ffd.cFileName[0] != '.')
                {
                    int nCurrLength = strlen(g_szCurrentPath);
                    strcat(g_szCurrentPath, ffd.cFileName);
                    strcat(g_szCurrentPath, "\\");
                    ProfileDirectory(ffd.cFileName, hEvent);

                    g_szCurrentPath[nCurrLength] = '\0';
                }

                // Terminate search if user signaled
                if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0)
                {
                    FindClose(hSearch);
                    SetCurrentDirectory("..");
                    return;
                }
            }
        } while(FindNextFile(hSearch, &ffd));
    }

    FindClose(hSearch);

    SetCurrentDirectory("..");
}


void* __cdecl operator new(size_t size)
{ 
    void* pv = 0;
    
    if(!g_hHeap)
        pv = HeapAlloc(GetProcessHeap(), 0, size);
    else
        pv = HeapAlloc(g_hHeap, 0, size);    

    if(!pv)
    {
        MessageBox(0, TEXT("Out of memory, terminating."), TEXT("ERROR"), 
            MB_OK | MB_ICONERROR);
        exit(-1);
    }

    return pv;
}

void __cdecl operator delete(void* pVal)
{
    if(g_hHeap)
        HeapFree(g_hHeap, 0, pVal);
    else
        HeapFree(GetProcessHeap(), 0, pVal);
}

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent)
{    
    g_fRaw = fRaw;
    g_fAPILogging = fAPILogging;
    g_fVerbose = fVerbose;
    g_szSearch = szSearchKey;
    g_fRecurse = fRecurse;

    bool fProfileDirectory = false;
    
    // Check if it is a directory, or a regular file.
    DWORD dwAttributes = GetFileAttributes(szAppName);
    if(dwAttributes != static_cast<DWORD>(-1) && 
        (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
        fProfileDirectory = true;
 
    // Check for directory profiling
    if(fProfileDirectory)
    {
        // Search for all EXE's in this Directory
        // Remove trailing \, if present
        if(szAppName[strlen(szAppName)-1]== '\\')
            szAppName[strlen(szAppName)-1] = '\0';

        char szBuff[MAX_PATH];
        strcpy(szBuff, szAppName);

        // If we're profiling a drive, don't include
        // the drive letter in the path
        if(szBuff[strlen(szBuff)-1]==':')
        {
                *g_szCurrentPath='\0';
        }
        else
        {
            if(strrchr(szBuff, '\\'))
                strcpy(g_szCurrentPath, strrchr(szBuff, '\\')+1);            
            else
                strcpy(g_szCurrentPath, szBuff);
            strcat(g_szCurrentPath, "\\");
        }
    
        ProfileDirectory(szAppName, hEvent);
    }
    else
    {
        // Maybe they left off the .exe
        if(GetFileAttributes(szAppName) == static_cast<DWORD>(-1))
        {
            char szBuffer[MAX_PATH+1];
            strcpy(szBuffer, szAppName);
            strcat(szBuffer, ".exe");
            dwAttributes = GetFileAttributes(szBuffer);
            if(dwAttributes == static_cast<DWORD>(-1))
            {                                
                return ERROR_FILE_NOT_FOUND;
            }           
            szAppName = szBuffer;
        }

        // Get the directory name
        char szBuffer[MAX_PATH+1];
        strcpy(szBuffer, szAppName);

        char* p;
        for(p = &szBuffer[strlen(szBuffer)]; p != szBuffer; p--)
        {
            if(*p == '\\')
            {
                *p = '\0';
                break;
            }
        }

        if(p != szBuffer)
        {
            SetCurrentDirectory(szBuffer);
            szAppName = p+1;
        }
        
        ParseHighLevelModule(szAppName, hEvent);
    }

    char* szProjectName = "";
    if(fProfileDirectory)
    {
        // If a directory, get the volume name
        if(strrchr(szAppName, '\\'))
            szAppName = strrchr(szAppName, '\\') + 1;

        // If we're profiling a drive, get volume name
        if(szAppName[strlen(szAppName)-1]==':')
        {
            char szBuffer[MAX_PATH];
            if(GetVolumeInformation(szAppName, szBuffer, MAX_PATH, 0, 0,
                0, 0, 0))            
                szProjectName = szBuffer;            
            else
                szProjectName = szAppName;        
        }        
        else    
            szProjectName = szAppName;
    }
    else
    {
        szProjectName = szAppName;
        char* szExtension = strstr(szAppName, ".exe");

        if(szExtension)
            *szExtension = '\0';
    }

    // Only write if there wasn't an event object, or user canceled.
    if(!hEvent || WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)
    {
        // Write all output
        WriteXMLHeader(pFile);
        g_modules.Write(pFile, szProjectName, iPtolemyID);
    }

    g_modules.Clear();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    PSTR pszFile,
    int* pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appcompat\appcompat.c ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    appcompat.c

Abstract:
    An application to launch a required APP with the
    version and the APPCOMPAT flags set.

*/

/* INCLUDES */

#define UNICODE   1

#include <windows.h>
#include <commdlg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <shellapi.h>
#include <tchar.h>
#include <htmlhelp.h>
#include <apcompat.h>

#include "appcompat.h"


#define MAXRES   256
#define MAXKEY   100
#define MAXDATA  10
#define MAXTITLE 100



BOOL CALLBACK DialogProc(HWND , UINT, WPARAM, LPARAM );
int MakeAppCompatGoo(TCHAR*, LARGE_INTEGER*, UINT);
long DeleteSpecificVal(HKEY );
extern TCHAR* CheckExtension(TCHAR*);
/* Global */
// Pattern string..  MajorVersion, MinorVersion, BuildNumber,ServicePackMajor, ServicePackMinor,
//                   PlatformID, CSDVersion string....
const TCHAR* pVersionVal[] = {
                         TEXT("4,0,1381,3,0,2,Service Pack 3"),
                         TEXT("4,0,1381,4,0,2,Service Pack 4"),
                         TEXT("4,0,1381,5,0,2,Service Pack 5"),
                         TEXT("4,10,1998,0,0,1,"),
                         TEXT("4,0,950,0,0,1,"),
                         NULL
                        };

#define MAXVERNUM   ( sizeof(pVersionVal)/sizeof(TCHAR*) ) - 1

const TCHAR szFilter[] = TEXT("EXE Files (*.EXE)\0*.exe\0") \
                         TEXT("All Files (*.*)\0*.*\0\0");

HINSTANCE g_hInstance;
extern    PVOID    g_lpPrevRegSettings;
BOOL      g_fAppCompatGoo = FALSE;
BOOLEAN   g_fNotPermanent = FALSE;
extern    BOOLEAN g_GooAppendFlag;


// Converts Text to interger.
int TextToInt(
        const TCHAR *nptr
        )
{
        int c;              /* current char */
        int total;          /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        /* skip whitespace */
        while ( *nptr  == TEXT(' ') )
            ++nptr;

        c = (int)*nptr++;
        sign = c;           /* save sign indication */
        if (c == TEXT('-') || c == TEXT('+') )
            c = (int)*nptr++;    /* skip sign */
        total = 0;

        while ( (c>=TEXT('0')) && (c <= TEXT('9')) ) {
            total = 10 * total + (c - TEXT('0') );     /* accumulate digit */
            c = (int)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}


TCHAR* CheckExtension(TCHAR* szTitle)
{
  TCHAR *pCh;
  pCh = szTitle;

  while(*pCh != TEXT('.'))
  {
   if(*pCh == TEXT('\0'))
    break;
   pCh++;
  }
  if(*pCh == TEXT('\0'))
   return NULL;
  else
   {
     pCh++;
     return pCh;
   }
}


VOID GetTitleAndCommandLine(TCHAR* pEditBuf, TCHAR* pszTitle, TCHAR* pszCommandLine)
{
  TCHAR  szTitleAndCommandLine[_MAX_PATH];
  TCHAR* pszTemp, *pszTmpTitle;
  UINT   i = 0;

  lstrcpy(szTitleAndCommandLine, pEditBuf);
  pszTmpTitle = pszTemp = szTitleAndCommandLine;

  if(*pszTemp == TEXT('\"') ){ // The title has quotes(" "). It has command line params.
    pszTemp++;
    while(*pszTemp != TEXT('\"') ){
         pszTemp++;
         if(*pszTemp == TEXT('\0') )
          break;
         if(*pszTemp == TEXT('\\') )
           pszTmpTitle = pszTemp + 1;
     }

  }
  else{ // No quotes(" ")...This means that there are no command line parameters.
      GetFileTitle(pEditBuf,pszTitle,MAX_PATH);
      pszCommandLine = NULL;
      return;
  }

  RtlZeroMemory(pszCommandLine, MAX_PATH);
  if(*pszTemp != TEXT('\0') ){  // There are command line paramaters for the APP.
     *(pszTemp ) = TEXT('\0');
     lstrcpy(pEditBuf, szTitleAndCommandLine);

     // For Paths beginning with a '"' and ending with a '"'.
     if(*pEditBuf == TEXT('\"') )
        lstrcat(pEditBuf, TEXT("\"") );
    // Now copy over the Command line parameters.
     pszTemp++;
     while( (*pszTemp) != TEXT('\0') ){
          *(pszCommandLine + i) = *pszTemp;
          i++;
          pszTemp++;
      }
      *(pszCommandLine + i) = TEXT('\0');
  }

  lstrcpy(pszTitle, pszTmpTitle);
 }

VOID GetFileExtension(TCHAR* pEditBuf, TCHAR* pszTitle,TCHAR* pszCommandLine)
{
   GetTitleAndCommandLine(pEditBuf, pszTitle, pszCommandLine);
   if(CheckExtension(pszTitle) == NULL)
     lstrcat(pszTitle,TEXT(".exe"));
}

TCHAR* GetNextWord(BOOLEAN* pfEndOfLine,TCHAR* pStr)
{
 TCHAR* pCh;

  pCh = pStr;
  //Skip white spaces..
  while((*pCh == TEXT(' ')) || (*pCh == TEXT('\t')))
   pCh++;

   // Fix for Command line parameters (from the command line within " " :)) ).
   if( *pCh == TEXT('\"') ){
      pCh++;
      while( *pCh != TEXT('\0') ) // Scan till the end when the string starts with a '"'.
            pCh++;
      *pfEndOfLine = TRUE;
      return pCh;
   }
   // End ..Fix for Command line parameters (from the command line within " " :)) ).

  while( ((*pCh)!=TEXT('-')) && ((*pCh)!=TEXT('\0')) )
  {
    pCh++;
  }
  if((*pCh) == TEXT('\0'))
      *pfEndOfLine = TRUE;
  else
      *pfEndOfLine = FALSE;

      return pCh;
}

void SkipBlanks(TCHAR* pStr)
{
 TCHAR* pTemp;

  if(*(pStr - 1) == TEXT(' '))
  {
   pTemp = pStr;
   while(*(pTemp - 1) == TEXT(' '))
    pTemp--;
   *pTemp = TEXT('\0');
  }
}

VOID  SetRegistryVal(TCHAR* szTitle, TCHAR* szVal,PTCHAR szBuffer,DWORD dwType)
{
  long         lResult;
  TCHAR        szSubKey[MAXKEY];
  HKEY         hKey;

      wsprintf(szSubKey, TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          RegSetValueEx(hKey,szVal,
                        0, dwType,(CONST BYTE*)szBuffer, lstrlen(szBuffer) + 1);

          RegCloseKey(hKey);
        }
}

long RestoreRegistryVal(szTitle)
{
  long         lResult;
  TCHAR        szSubKey[MAXKEY];
  HKEY         hKey;

      wsprintf(szSubKey, TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          lResult = RegSetValueEx(hKey,TEXT("ApplicationGoo"),
                        0, REG_BINARY,(CONST BYTE*)g_lpPrevRegSettings, *((PULONG)g_lpPrevRegSettings) );

          if(ERROR_SUCCESS != lResult)
            MessageBox(NULL,TEXT("Appending ApplicationGoo failed !!"),TEXT(""),IDOK);

          RegCloseKey(hKey);
        }
    return lResult;
}

long DeleteKey(TCHAR* szTitle, BOOL bGooKeyPresent)
{
  long lRet;
  HKEY hKey;

  lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options"),
                       0,
                       KEY_WRITE,
                       &hKey);

  if(ERROR_SUCCESS == lRet){
    if((!g_fAppCompatGoo) &&
      ( TRUE == bGooKeyPresent) ){ // We did not set ApplicationGoo at all. So, we cannot delete it !
       lRet = DeleteSpecificVal(hKey);
       return lRet;
    }
    RegDeleteKey(hKey, szTitle);
    RegCloseKey(hKey);
    // If there was a previous entry of ApplicationGoo in the registry.
    if(g_GooAppendFlag)
      lRet =  RestoreRegistryVal(szTitle);

  }// If ERROR_SUCCESS
 return lRet;
}

long DeleteSpecificVal(HKEY hKey)
{
  if(g_fNotPermanent == TRUE){
     if(g_fAppCompatGoo){
        RegDeleteValue(hKey, TEXT("ApplicationGoo") );
        if(g_GooAppendFlag){
           if( RegSetValueEx(hKey,
                         TEXT("ApplicationGoo"),
                         0,
                         REG_BINARY,
                         (CONST BYTE*)g_lpPrevRegSettings,
                         *((PULONG)g_lpPrevRegSettings)
                          ) != ERROR_SUCCESS )
            MessageBox(NULL,TEXT("Appending ApplicationGoo failed !!"),TEXT(""),IDOK);
         }
      }
   }
  return( RegDeleteValue( hKey,TEXT("DisableHeapLookAside") ) );
}

long CheckAndDeleteKey(TCHAR* szTitle, BOOL Check)
{
  long lResult,lRet = -1;
  TCHAR szSubKey[MAXKEY], szData[MAXDATA], szKeyName[MAXKEY],szResult[MAXDATA];
  int   Size,KeyLength, indx =0;
  HKEY  hKey;
  DWORD dwType;
  BOOLEAN bSpecificKey = FALSE, bGooKeyPresent = FALSE;

  wsprintf(szSubKey,TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

  lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szSubKey,
                         0,
                         KEY_SET_VALUE | KEY_QUERY_VALUE,
                         &hKey);

  if(ERROR_SUCCESS == lResult){
    Size = sizeof(szData) + 1;
    lResult = RegQueryValueEx(hKey,
                           TEXT("DisableHeapLookAside"),
                           NULL,
                           &dwType,
                           (LPBYTE)szData,
                           &Size);
    if(Check)
      return lResult;

        /*
       This is done to check whether this is the only value under this KEY.
       If there are other values under this key, only this value is deleted
     */
      KeyLength = sizeof(szKeyName) + 1;
      while(RegEnumValue(hKey,
                         indx,
                         szKeyName,
                         &KeyLength,
                         NULL,
                         NULL,
                         NULL,
                         NULL) != ERROR_NO_MORE_ITEMS)
      {
         if(lstrcmpi(szKeyName,TEXT("DisableHeapLookAside"))!=0){
           if(lstrcmpi(szKeyName,TEXT("ApplicationGoo"))!=0 ||
               g_fNotPermanent == FALSE){ // ApplicationGoo is present but it should be permanent...
             bSpecificKey = TRUE;
             lRet = DeleteSpecificVal(hKey);
             break;
           }
           bGooKeyPresent = TRUE;    // If it has come here, then it is equal to "ApplicationGoo"
         }
         indx++;
         KeyLength = sizeof(szKeyName) + 1;
      }
      RegCloseKey(hKey);

      if(!bSpecificKey){
        lRet = DeleteKey(szTitle, bGooKeyPresent);
      }

  }
 return lRet;
}



void DetailError(DWORD dwErrMsg)
{
   LPVOID lpMsgBuf;
   if(FormatMessage(
                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_SYSTEM     |
                 FORMAT_MESSAGE_IGNORE_INSERTS,
                 NULL,
                 dwErrMsg,
                 MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                 (LPTSTR)&lpMsgBuf,
                 0,
                 NULL
                ) != 0){
      MessageBox(NULL, lpMsgBuf, TEXT(""), IDOK);
   }
   LocalFree(lpMsgBuf);
}



VOID ExecuteApp(HWND hWnd, TCHAR* AppName,TCHAR* szTitle,TCHAR* pszCommandLine, BOOLEAN fMask)
{
 SHELLEXECUTEINFO sei;
 MSG              msg;
 static int       cnt = 0;

  memset(&sei, 0, sizeof(SHELLEXECUTEINFO) );
  sei.cbSize = sizeof(SHELLEXECUTEINFO);
  sei.hwnd   = hWnd;
  sei.lpVerb = TEXT("open");
  sei.lpFile = AppName;
  sei.nShow  = SW_SHOWDEFAULT;
  sei.lpParameters = pszCommandLine;

  if(fMask){
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
  }
  if(ShellExecuteEx(&sei) == FALSE) {          /* If the API fails */
    CheckAndDeleteKey(szTitle, FALSE);
    DetailError( GetLastError() );
  }
  else{  // Was successful in launching the application.
    // Wait till the process terminates...
    if(fMask){
      if(NULL != sei.hProcess ){  // The hProcess can be NULL sometimes....
        while(WaitForSingleObject(sei.hProcess, 5000)== WAIT_TIMEOUT){
          while(PeekMessage(&msg, NULL, 0, 0,PM_REMOVE)){
               TranslateMessage(&msg);
               DispatchMessage(&msg);
          }
          cnt++;
          if(cnt == 15)
            break;
        }
        CheckAndDeleteKey(szTitle, FALSE );
        CloseHandle(sei.hProcess);
      }
      else
        MessageBox(NULL, TEXT(" Process Handle is NULL"), TEXT(""), IDOK);
     }
  }


}

VOID SetTempPath(VOID)
{
  TCHAR szEnv[_MAX_PATH],szTemp[_MAX_PATH];
  int   indx1=0,indx2 =0;

  GetEnvironmentVariable(TEXT("TEMP"),szTemp,_MAX_PATH);

  szEnv[0] = szTemp[0];
  lstrcpy(&szEnv[1],TEXT(":\\Temp"));
  if(SetEnvironmentVariable(TEXT("TEMP"), szEnv) == 0){
     DetailError(GetLastError());
  }
}

VOID GetDirectoryPath(LPTSTR pszModulePath,LPTSTR pszDirectoryPath)
{
   TCHAR* pTmp, *pSwap;

   pTmp = (TCHAR*) malloc( sizeof(TCHAR) * (lstrlen((LPCTSTR)pszModulePath) + 1) );
   if(pTmp){
     lstrcpy(pTmp, pszModulePath);
     pSwap = pTmp;
     pTmp += lstrlen((LPCTSTR)pszModulePath);
     while(*pTmp != TEXT('\\') ){
         pTmp--;
     }
     *pTmp = TEXT('\0');
     pTmp  = pSwap;
     lstrcpy(pszDirectoryPath, pTmp);
     free(pTmp);
   }
}

VOID GetHelpPath(LPTSTR pszPath)
{
   TCHAR szFilePath[_MAX_PATH] = {0};

   GetModuleFileName(NULL,szFilePath,_MAX_PATH);
   GetDirectoryPath(szFilePath, pszPath);
   lstrcat(pszPath, TEXT("\\w2rksupp.chm") );
}




/* Main Entry point */

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
  const static TCHAR szAppName [] = TEXT("AppCompat");
  MSG         msg;
  WNDCLASS    wndclass;

 /* Addition for Command line Parameters*/
  TCHAR        *AppName = NULL, *pCh = NULL, *pNextWord=NULL;
  BOOLEAN      fEnd = FALSE, fDisableHeapLookAside = FALSE, fSetTemp = FALSE,fHelpDisplay = FALSE;
  BOOL         fKeepRegistrySetting = FALSE;
  UINT         VersionNum = 5,indx,length;
  HKEY         hKey;
  TCHAR        szTitle[_MAX_PATH], szSubKey[MAXKEY],szKeyName[MAXKEY];
  TCHAR        szCommandLine[_MAX_PATH];
  LPTSTR       pStr;
  long         lResult;
  LPTSTR       lpszCommandLn;
  TCHAR        szDirectoryPath[_MAX_PATH];
  HWND         hHelpWnd;
  static       LARGE_INTEGER AppCompatFlag;
  static       TCHAR  szCurDir[MAX_PATH];

  g_hInstance = hInstance;
  // For Unicode
  lpszCommandLn = GetCommandLine();
  pStr = (TCHAR*)malloc( sizeof(TCHAR) * ( lstrlen((LPCTSTR)lpszCommandLn) + 1) );
  if(pStr != NULL)
  {
    lstrcpy(pStr, (LPCTSTR)lpszCommandLn);
    pCh = pStr;
  }
  else{
      return 0;
  }
  // Skip till the first delimiter
  while(*pCh != TEXT('-') ){
       if(*pCh == TEXT('\0') )
         break;
       pCh++;
  }

  if(*pCh == TEXT('-') )
  {
      pCh++;                             /* If '-' is found, skip to the next
                                            character */
    if(*pCh != TEXT('\0') ){
      do
      {
       pCh++;
       pNextWord =  GetNextWord(&fEnd,pCh);
       switch(LOWORD( CharLower((LPTSTR)*(pCh - 1))) )
       {

        case TEXT('d'):
                                         /* For Disable Heap look-aside */
              fDisableHeapLookAside = TRUE;
              break;

        case TEXT('k'):
                                         /* For Keep the Registry settings */
              fKeepRegistrySetting = TRUE;
              break;

        case TEXT('g'):
                                         /* For GetDiskFreespace in AppCompatGoo registry setting */
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |= KACF_GETDISKFREESPACE;
              break;

#ifdef EXTRA_APP_COMPAT
        case TEXT('f'):                // Pre-Windows 2000 Free Threading Model(FTM).
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |= KACF_FTMFROMCURRENTAPT;
              break;

        case TEXT('o'):
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |=KACF_OLDGETSHORTPATHNAME;
#endif

      case TEXT('t'):
                                         /* For Disable Heap look-aside */
              fSetTemp = TRUE;
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |=KACF_GETTEMPPATH;
              break;

      case TEXT('v'):
             SkipBlanks(pNextWord);
             VersionNum = TextToInt((LPCTSTR)pCh) - 1;
             if(VersionNum >= MAXVERNUM) {

               fHelpDisplay = TRUE;
               GetHelpPath(szDirectoryPath);
               hHelpWnd = HtmlHelp(NULL, szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
               while(IsWindow(hHelpWnd) )
                     Sleep(200);

                return 0;
               //break;
             }
             // Set the appcompatgoo flag .
             if(VersionNum <= (MAXVERNUM - 1)){
                g_fAppCompatGoo = TRUE;
                AppCompatFlag.LowPart |= KACF_VERSIONLIE;
             }

             break;

      case TEXT('x'): // NOTE: To pass command line parameters to the App. pass it in " " after
                     //        -x .  Eg. apcompat -x"yyy.exe " ..Command line params..blah..blah..

            SkipBlanks(pNextWord);
            AppName = (TCHAR*)malloc(sizeof(TCHAR) * ( lstrlen(pCh) + 1) );
            if(AppName != NULL)
              lstrcpy(AppName,pCh);

            break;

      case TEXT('h'):
      default :

            GetHelpPath(szDirectoryPath);
            hHelpWnd = HtmlHelp(GetDesktopWindow(), szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
          // Loop till the Help window exists.
            while(IsWindow(hHelpWnd) )
                  Sleep(200);

            if(AppName)
              free(AppName);
             return 0;

      } // End switch

      if(fEnd == FALSE)
        pCh = pNextWord+1;

    }while( FALSE == fEnd);
  }

     if((AppName == NULL) ||
         lstrlen(AppName) == 0)/* Return if no Application name given */
     {
           if(FALSE == fHelpDisplay ){
               GetHelpPath(szDirectoryPath);
               hHelpWnd = HtmlHelp(NULL, szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
               while(IsWindow(hHelpWnd) )
                     Sleep(200);

            }
        return 0;
     }


    memset(szCommandLine, 0, MAX_PATH);
    GetFileExtension(AppName,szTitle,szCommandLine);
    GetDirectoryPath(AppName, szCurDir);
    SetCurrentDirectory(szCurDir);

    if(fDisableHeapLookAside)
    {
       SetRegistryVal(szTitle,TEXT("DisableHeapLookAside"), TEXT("1"),REG_SZ );
    }
  else{
       CheckAndDeleteKey(szTitle,FALSE);
     } //End Else

  if(fSetTemp){
    SetTempPath();
  }

  if(!fKeepRegistrySetting)
      g_fNotPermanent = TRUE;
  if(g_fAppCompatGoo)
   MakeAppCompatGoo(AppName,&AppCompatFlag,VersionNum);

   if(SetEnvironmentVariable(TEXT("_COMPAT_VER_NNN"), pVersionVal[VersionNum]) == 0)
     {
       if( ERROR_ENVVAR_NOT_FOUND != GetLastError() )
         DetailError( GetLastError() );
     }

  // Execute the application.
  if(fKeepRegistrySetting)
    ExecuteApp(NULL, AppName,szTitle,szCommandLine,FALSE);
  else{
    ExecuteApp(NULL, AppName,szTitle,szCommandLine,TRUE);
    }

   if(AppName)
     free(AppName);
   if(pStr)
     free(pStr);

   GlobalFree(g_lpPrevRegSettings);
   return 0;
}

     /* Create a MODAL Dialog */
     DialogBox(hInstance, TEXT("DialogProc"),(HWND)NULL,
                               (DLGPROC)DialogProc);

    while(GetMessage(&msg, NULL, 0, 0))
    {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
    }
  return (int)msg.wParam ;
}


/* Dialog procedure... */
BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
 int              dCharCnt,indx,length;
 TCHAR            EditCtrlBuf[_MAX_PATH];
 static int       BufCnt;
 TCHAR            FileBuf[_MAX_PATH];
 TCHAR            FileTitle[_MAX_PATH],szCommandLine[MAX_PATH];
 TCHAR            szDirectoryPath[_MAX_PATH];
 static HANDLE    hEditCtrl;
 static HANDLE    hRadioBtn;
 static HANDLE    hBrowseBtn;
 static HANDLE    hLaunchBtn,hCheck1,hCheck2,hCheck3,hCheck4,hDCOMFTM,hOldPathName;
 static const TCHAR*    pEnvVal = NULL;
 OPENFILENAME     ofn;
 HKEY             hKey;
 TCHAR            szTitle[MAXTITLE],szKeyName[MAXKEY],szSubKey[MAXKEY];
 TCHAR            szFileName[_MAX_PATH];
 DWORD            dwEnvSetError;
 static LARGE_INTEGER    AppCompatFlag ;
 static UINT             uOsVerID = IDD_NONE;
 static BOOL      fOfnFlag = FALSE;
 static TCHAR     szCurDir[MAX_PATH];

  switch(uMsg)
  {
   case WM_INITDIALOG:

        hEditCtrl = GetDlgItem(hwndDlg, IDD_APPEDIT);     /* To be used when reading and
                                                             writing from the EDIT control */
        hRadioBtn  = GetDlgItem(hwndDlg, IDD_NONE);
        SendMessage(hRadioBtn , BM_SETCHECK, 1, 0L);
        SetFocus(hEditCtrl);
        return TRUE;

    case WM_CLOSE:
         EndDialog(hwndDlg, 0);
         break;

    case WM_DESTROY:
         PostQuitMessage(0);
         return 0;

    case WM_COMMAND:

       if(FALSE==fOfnFlag){
         if( LOWORD(wParam) == IDD_APPEDIT ){
           if( HIWORD(wParam) == EN_UPDATE){
             GetWindowText(hEditCtrl,EditCtrlBuf, _MAX_PATH);
             /* Check whether the *.exe is present in Registry */
             GetFileExtension(EditCtrlBuf,szTitle,szCommandLine);
             if(CheckAndDeleteKey(szTitle,TRUE) == ERROR_SUCCESS){
               /* The executable already has an entry
                  in the registry */

                  hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                  SendMessage(hCheck1,BM_SETCHECK, 1, 0L);
             }
             else{ // Uncheck if previously checked only.
                  if( SendMessage(hCheck1,BM_GETCHECK, 0, 0L) )
                     SendMessage(hCheck1,BM_SETCHECK, 0, 0L);
             }
           }
         }
        }

         switch(wParam)
         {
          case IDCANCEL:
               EndDialog(hwndDlg, 0);
               break;

          case IDD_HELP:
               GetHelpPath(szDirectoryPath);
               lstrcat(szDirectoryPath, TEXT("::/topics/appcomp.htm>mainwin") );
               HtmlHelp(GetDesktopWindow(), szDirectoryPath, HH_DISPLAY_TOPIC,(DWORD_PTR) NULL);
               break;
        /*
           For the Browse button, Open the FileOpen dialog and get the
           application path.
           Display the path in the Edit box.

         */
          case IDD_BROWSE:
               GetDlgItemText(hwndDlg, IDD_APPEDIT, EditCtrlBuf, _MAX_PATH);
               memset(&ofn, 0, sizeof(OPENFILENAME) );
               FileBuf[0]         = TEXT('\0');
               /* Initialize the Ofn structure */
               ofn.lStructSize    = sizeof (OPENFILENAME) ;
               ofn.hwndOwner      = hwndDlg;
               ofn.lpstrFilter    = szFilter;
               ofn.lpstrFile      = FileBuf;
               ofn.nMaxFile       = _MAX_PATH ;
               ofn.lpstrInitialDir= EditCtrlBuf;
               ofn.Flags          = OFN_PATHMUSTEXIST |
                                    OFN_FILEMUSTEXIST;

              if( GetOpenFileName (&ofn) != 0){
               /* Got the file name ...*/
               // To put a '"' before and after what is typed...
                 if( (*FileBuf) != TEXT('\"') ){
                    memset(EditCtrlBuf, 0, MAX_PATH);
                    *(EditCtrlBuf) = TEXT('\"');
                    lstrcat(EditCtrlBuf, FileBuf);
                    lstrcat(EditCtrlBuf, TEXT("\""));
                    SetWindowText(hEditCtrl,EditCtrlBuf);
                  }
                 // Set the flag so that anything entered after this will not be taken over by
                 // the Edit control input...
                 fOfnFlag = TRUE;
                 /* Check whether the *.exe is present in Registry */

                  GetFileExtension(FileBuf,szTitle,szCommandLine);
                  if(CheckAndDeleteKey(szTitle,TRUE) == ERROR_SUCCESS){
                      /* The executable already has an entry
                         in the registry */
                      hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                      SendMessage(hCheck1,BM_SETCHECK, 1, 0L);
                  }
                 /* At this pt. set focus on the 'LAUNCH' button */
                 hLaunchBtn = GetDlgItem(hwndDlg, IDD_LAUNCH);
                 SetFocus(hLaunchBtn);
              }

             break;

        /*
          When any of the Radio buttons in the OS version group is checked,
          get the version ID and store the corresponding COMPAT flag.. in the
          local variable.
         */
          case IDD_WIN95:
          case IDD_WIN98:
          case IDD_WINNT43:
          case IDD_WINNT44:
          case IDD_WINNT45:
          case IDD_NONE:
               if(wParam != IDD_NONE){
                 g_fAppCompatGoo = TRUE;
                 AppCompatFlag.LowPart |= KACF_VERSIONLIE;
               }
               uOsVerID = (UINT)(wParam - FIRSTBUTTON);
               CheckRadioButton(hwndDlg,(int)FIRSTBUTTON,(int)LASTBUTTON,(int)wParam);
               pEnvVal = pVersionVal[wParam - FIRSTBUTTON];
               break;

          case IDD_LAUNCH:
               dCharCnt = GetWindowTextLength( hEditCtrl );
               if(dCharCnt > 0){
                    /*
                       Go in only if something is present in the
                       EDIT box
                    */

                  if(GetWindowText(hEditCtrl, EditCtrlBuf, dCharCnt + 1) == 0){
                     DetailError(GetLastError() );
                  }
                  else{ /* Launch the APP using ShellExecuteEx */
                    memset(szCommandLine, 0, MAX_PATH);
                    GetFileExtension(EditCtrlBuf,szTitle,szCommandLine);
                    GetDirectoryPath(EditCtrlBuf, szCurDir);
                    SetCurrentDirectory(szCurDir);

                    hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                    if( SendMessage(hCheck1, BM_GETSTATE, 0, 0L)){
                      /* The checkbox has been checked
                         - DisableHeapLookAside */

                       SetRegistryVal(szTitle, TEXT("DisableHeapLookAside"), TEXT("1"),REG_SZ );
                     }
                     else{
                       // If it is not thru the BROWSE button...user has got
                       // here by typing the path in the Edit Ctrl...

                         CheckAndDeleteKey(szTitle,FALSE);
                     }

                     hCheck2  = GetDlgItem(hwndDlg, IDD_CHECK2);
                     if( SendMessage(hCheck2, BM_GETSTATE, 0, 0L)){
                        // Short Temp path.
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |=KACF_GETTEMPPATH;
                        SetTempPath();
                     }

                     hCheck4 = GetDlgItem(hwndDlg, IDD_CHECK4);
                     if( SendMessage(hCheck4, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_GETDISKFREESPACE;
                     }
               #ifdef EXTRA_APP_COMPAT
                     hDCOMFTM = GetDlgItem(hwndDlg, IDD_DCOMFTM);
                     if( SendMessage(hDCOMFTM, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_FTMFROMCURRENTAPT;
                     }

                     hOldPathName = GetDlgItem(hwndDlg, IDD_OLDPATH);
                     if( SendMessage(hOldPathName, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_OLDGETSHORTPATHNAME;
                     }
               #endif

                     hCheck3  = GetDlgItem(hwndDlg, IDD_CHECK3);
                     if( SendMessage(hCheck3, BM_GETSTATE, 0, 0L) == 0)
                       g_fNotPermanent = TRUE;

                     if(g_fAppCompatGoo)
                       MakeAppCompatGoo(EditCtrlBuf,&AppCompatFlag,uOsVerID);

                  /* Set the ENVIRONMENT Variable "_COMPAT_VER_NNN"
                     flag  with the version checked before calling
                     ShellExecuteEx()
                   */
                    if(SetEnvironmentVariable(TEXT("_COMPAT_VER_NNN"), pEnvVal) == 0){
                          dwEnvSetError = GetLastError();
                          if( ERROR_ENVVAR_NOT_FOUND != dwEnvSetError )
                             DetailError( GetLastError() );
                    }


                   if( g_fNotPermanent){
                      ExecuteApp(hwndDlg, EditCtrlBuf,szTitle,szCommandLine, TRUE);
                   }
                   else{
                         ExecuteApp(hwndDlg, EditCtrlBuf,szTitle,szCommandLine, FALSE);
                       }
                   EndDialog(hwndDlg, 0);
                 }
               }
             break;

          case IDD_CLOSE:
               EndDialog(hwndDlg, 0);
        }

    GlobalFree(g_lpPrevRegSettings);
    return TRUE;
  }
 return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparse.h ===
#ifndef APPPARSE_H
#define APPPARSE_H

#include <windows.h>
#include <stdio.h>

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\filebrowser.h ===
#ifndef FILEBROWSER_H
#define FILEBROWSER_H

#include <windows.h>

// Display browse dialog box, and return dir string.  String does
// not need to be freed, will be overwritten by subsequent calls.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparseweb.cpp ===
// AppParseWeb.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AppParseWebps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AppParseWeb.h"

#include "AppParseWeb_i.c"
#include "AppParseWrapper.h"

extern HANDLE g_hHeap;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AppParse, CAppParse)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hHeap = HeapCreate(0, 0, 0);
        _Module.Init(ObjectMap, hInstance, &LIBID_APPPARSEWEBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		HeapDestroy(g_hHeap);
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\browsedlg.cpp ===
// BrowseDlg.cpp
// Dialog box to enable user to select a directory and/or files.

// Author: t-michkr (June 22, 2000)

#include <windows.h>
#include "stdafx.h"


// We make use of some Win2K specific controls

#include <shellapi.h>
#include <shlwapi.h>
#include <tchar.h>
#include <assert.h>
#include "filebrowser.h"
#include "resource.h"
#include "commctrl.h"

// Display browse dialog box, and return dir string.
PSTR BrowseForFolder(HWND hwnd, PSTR szInitialPath, UINT uiFlags);

// Expand a tree item to include sub items.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent);

// Remove a tree item's subitems
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent);

void CheckTreeSubItems(HWND hwTree, HTREEITEM hChild);

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath);

// Get full item path.  Assumes szPath is a buffer of MAX_PATH size,
// initialized with '\0'.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath);

// Browse dialog proc
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// Browse dialog box message handlers.
BOOL HandleInitBrowse(HWND hwnd);
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwChild);
void HandleBrowseNotify(HWND hwnd, void* pvArg);

// Buffer to hold returned path
static TCHAR s_szPathBuffer[MAX_PATH];
static PTSTR s_szInitialPath = 0;
static HIMAGELIST s_himlSystem = 0;

// Create browse dialog box, and return a path string, or
// NULL if cancel was selected.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath)
{
    CoInitialize(0);

    s_szInitialPath = szInitialPath;

    PTSTR szRet = reinterpret_cast<TCHAR*>(DialogBox(_Module.GetModuleInstance(), 
        MAKEINTRESOURCE(IDD_BROWSE), hwnd, BrowseDialogProc));

    CoUninitialize();
    return szRet;
}

// Browse dialog box proc.
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uiMsg)
    {
    case WM_INITDIALOG:
        return HandleInitBrowse(hwnd);
        break;
    case WM_COMMAND:
        HandleBrowseCommand(hwnd, LOWORD(wParam), HIWORD(wParam),
            reinterpret_cast<HWND>(lParam));
        break;
    case WM_NOTIFY:
        HandleBrowseNotify(hwnd, reinterpret_cast<void*>(lParam));
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

// Dialog box initialization, init tree and root tree items.
BOOL HandleInitBrowse(HWND hwnd)
{
    // Get the treeview control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    if(!hwTree)
        return FALSE;

    SHFILEINFO sfi;

    TreeView_SetImageList(hwTree, reinterpret_cast<HIMAGELIST>(SHGetFileInfo(TEXT("C:\\"),
        0,&sfi, sizeof(SHFILEINFO), SHGFI_SYSICONINDEX | SHGFI_SMALLICON)), 
        TVSIL_NORMAL);

    // Get all user drives
    DWORD dwLength = GetLogicalDriveStrings(0,0);
    if(dwLength == 0)
        return FALSE;

    TCHAR* szDrives = new TCHAR[dwLength+1];
    if(!szDrives)     
        return FALSE;    

    GetLogicalDriveStrings(dwLength, szDrives);
    TCHAR* szCurrDrive = szDrives;

    // Go through each drive
    while(*szCurrDrive)
    {
        // Only pay attention to fixed drives (non-network, non-CD, non-floppy)
        if(GetDriveType(szCurrDrive) == DRIVE_FIXED)           
        {
            SHGetFileInfo(szCurrDrive, 0, &sfi, sizeof(sfi), 
                SHGFI_SYSICONINDEX);

            // Get rid of the terminating '\'
            szCurrDrive[lstrlen(szCurrDrive)-1] = TEXT('\0');

            // Insert a disk drive item into the tree root.
            TVINSERTSTRUCT tvis;
            tvis.hParent = TVI_ROOT;
            tvis.hInsertAfter = TVI_LAST;
            tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE| TVIF_TEXT;
            tvis.itemex.iImage = sfi.iIcon;
            tvis.itemex.iSelectedImage = sfi.iIcon;
            tvis.itemex.pszText = szCurrDrive;
            tvis.itemex.cchTextMax = lstrlen(szCurrDrive);

            HTREEITEM hTreeItem = TreeView_InsertItem(hwTree, &tvis);
            
            assert(hTreeItem);

            // Add subitems to the item
            AddTreeSubItems(hwTree, hTreeItem);

            // Move to next drive
            szCurrDrive += lstrlen(szCurrDrive) + 2;
        }
        else        
            // Move to next drive.
            szCurrDrive += lstrlen(szCurrDrive) + 1;
    }

    delete szDrives;

    // Select the first element.
    HTREEITEM hItem = TreeView_GetChild(hwTree, TVI_ROOT);
    TreeView_SelectItem(hwTree, hItem);

    // Force tree to update, and restore original focus
    SetFocus(hwTree);
    SetFocus(GetDlgItem(hwnd, IDOK));

    return TRUE;
}

// Catch notification messages, so we can control expansion/collapsing.
void HandleBrowseNotify(HWND hwnd, void* pvArg)
{
    // Get tree control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    HWND hwFileList = GetDlgItem(hwnd, IDC_FILELISTCOMBO);
    if(!hwTree || !hwFileList)
    {
        DestroyWindow(GetParent(hwnd));
        return;
    }

    HTREEITEM hItem;
    TCHAR szPath[MAX_PATH] = TEXT("\0");

    // Get notification headers
    NMHDR* pHdr = reinterpret_cast<NMHDR*>(pvArg);
    LPNMTREEVIEW pnmTreeView = reinterpret_cast<LPNMTREEVIEW>(pvArg);    

    switch(pHdr->code)
    {
        // Expanding or collapsing, called for each child.
    case TVN_ITEMEXPANDED:

        // If we're expanding, get the sub items of all children
        if(pnmTreeView->action & TVE_EXPAND)
        {
            // Switch our parent to an open folder icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Add all sub-items to this item.
            AddTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);

            // Go through each child, and and check if expansion should be allowed
            HTREEITEM hChild = TreeView_GetChild(hwTree, pnmTreeView->itemNew.hItem);
            while(hChild != NULL)
            {
                CheckTreeSubItems(hwTree, hChild);                
                hChild = TreeView_GetNextSibling(hwTree, hChild);
            }
        }
        else if(pnmTreeView->action & TVE_COLLAPSE)
        {
            // Switch parent to a closed icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE |  TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Remove all subitems for every child.
            RemoveTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);
            CheckTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);            
        }
        break;
    case TVN_SELCHANGED:

        // Only bother updating edit box if the tree has the focus
        if(GetFocus() == hwTree)
        {
            GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
            SetWindowText(hwFileList, szPath);         
        }

        break;

        // When treeview gains focus, make sure file list and tree view
        // selection are in sync.
    case NM_SETFOCUS:        
        hItem = TreeView_GetSelection(hwTree);        

        GetItemPath(hwTree, hItem, szPath);
        SetWindowText(hwFileList, szPath);         
        break;
    }
}

// Handle a command message.
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwCtrl)
{
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);    
    HTREEITEM hSelected;
    TVITEMEX tvItem;

    TCHAR szPath[MAX_PATH];

    switch(uiCtrlID)
    {
        // Get path of item, and return it.
    case IDOK:               
        // Retrieve item from tree view.
        hSelected = TreeView_GetSelection(hwTree);
        if(!hSelected)
        {
            MessageBeep(0);
            break;
        }
        
        s_szPathBuffer[0] = TEXT('\0');
        
        GetItemPath(hwTree, hSelected, s_szPathBuffer);
        if(s_szPathBuffer[lstrlen(s_szPathBuffer)-1]== TEXT('\\'))
            s_szPathBuffer[lstrlen(s_szPathBuffer)-1] = TEXT('\0');

        // Validate the path
        if(GetFileAttributes(s_szPathBuffer)==static_cast<DWORD>(-1))
            ::MessageBox(0, TEXT("Invalid Path"), TEXT("ERROR"), 
            MB_OK | MB_ICONINFORMATION);
        else 
            EndDialog(hwnd, reinterpret_cast<INT_PTR>(s_szPathBuffer));        

        break;

    case IDCANCEL:
        // User selected cancel, just return null.
        EndDialog(hwnd, 0);
        break;

    case IDC_FILELISTCOMBO:
        switch(uiNotify)
        {
        case CBN_EDITCHANGE:
            SendMessage(hwCtrl, WM_GETTEXT, MAX_PATH, 
                reinterpret_cast<LPARAM>(szPath));

            SelectItemFromFullPath(hwTree, szPath);
            break;

        case CBN_DROPDOWN:            
            // clear the combo box.
            SendMessage(hwCtrl, CB_RESETCONTENT, 0, 0);

            // Fill the combo box with all the lowest level items under
            // treeview selection
            hSelected = TreeView_GetSelection(hwTree);
            tvItem.mask = TVIF_STATE | TVIF_HANDLE;
            tvItem.hItem = hSelected;            

            TreeView_GetItem(hwTree, &tvItem);

            if(tvItem.state & TVIS_EXPANDED)
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hSelected, szPath);

                SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                    reinterpret_cast<LPARAM>(szPath));

                HTREEITEM hItem = TreeView_GetChild(hwTree, tvItem.hItem);
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }
            else
            {
                HTREEITEM hItem;
                hItem = TreeView_GetParent(hwTree, tvItem.hItem);
                hItem = TreeView_GetChild(hwTree, hItem);
  
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }

            break;
        }
        break;
    };
}

// Expand an item to get its full path.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    assert(hwTree);
    assert(hItem);
    assert(szPath);
    assert(szPath[0] == TEXT('\0'));

    // Recurse to get parent's path.
    HTREEITEM hParent = TreeView_GetParent(hwTree, hItem);
    if(hParent)
    {
        GetItemPath(hwTree, hParent, szPath);
        lstrcat(szPath, TEXT("\\"));
    }

    // Get item text, concatenate on current path..
    TVITEMEX tvItem;

    tvItem.mask = TVIF_TEXT | TVIF_HANDLE;
    tvItem.hItem = hItem;
    tvItem.pszText = szPath + lstrlen(szPath);
    tvItem.cchTextMax = MAX_PATH - lstrlen(szPath);
    
    TreeView_GetItem(hwTree, &tvItem);
}

// Remove all subitems below an element.
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);
    
    // Go through each child and delete.
    HTREEITEM hChild = TreeView_GetChild(hwTree, hParent);
    while(hChild != NULL)
    {
        HTREEITEM hSibling = TreeView_GetNextSibling(hwTree, hChild);

        // Recursively delete all subitems in this child.
        RemoveTreeSubItems(hwTree, hChild);

        // Remove this item.
        TreeView_DeleteItem(hwTree, hChild);

        // Move to next.
        hChild = hSibling;        
    }
}

// Add items below an element.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Clear-out (to ensure we don't add items twice)
    RemoveTreeSubItems(hwTree, hParent);

    // Do an early out if the item has already been expanded
    TVITEMEX tvitem;
    tvitem.mask = TVIF_CHILDREN | TVIF_HANDLE;
    tvitem.hItem = hParent;
    TreeView_GetItem(hwTree, &tvitem);
    if(tvitem.cChildren)
        return;
    
    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if(findData.cFileName[0] != TEXT('.'))
        {
            if(StrStrI(findData.cFileName, ".exe") || (
                findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                SHFILEINFO sfi;

                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hParent, szPath);
                lstrcat(szPath, TEXT("\\"));
                lstrcat(szPath, findData.cFileName);
                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX);
            
                // Insert an item representing this directory.
                TVINSERTSTRUCT tvis;
                tvis.hParent = hParent;
                tvis.hInsertAfter = TVI_SORT;
                tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                tvis.itemex.iImage = sfi.iIcon;
                tvis.itemex.iSelectedImage = sfi.iIcon;
                tvis.itemex.pszText = findData.cFileName;
                tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

                TreeView_InsertItem(hwTree, &tvis);
            }
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

void CheckTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if((findData.cFileName[0] != TEXT('.')))
        {
            if(StrStrI(findData.cFileName, ".exe") || (
                findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                SHFILEINFO sfi;

                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hParent, szPath);
                lstrcat(szPath, TEXT("\\"));
                lstrcat(szPath, findData.cFileName);
                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX);
            
                // Insert an item representing this directory.
                TVINSERTSTRUCT tvis;
                tvis.hParent = hParent;
                tvis.hInsertAfter = TVI_SORT;
                tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                tvis.itemex.iImage = sfi.iIcon;
                tvis.itemex.iSelectedImage = sfi.iIcon;
                tvis.itemex.pszText = findData.cFileName;
                tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

                TreeView_InsertItem(hwTree, &tvis);

                FindClose(hSearch);
                return;
            }
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

// Given a relative path and a tree item, select a subitem from the relative path.
// Returns true if item successfully selected, false otherwise.
bool SelectSubitemFromPartialPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    bool fExpandIt = false;
    TCHAR* szPathDelim = _tcschr(szPath, TEXT('\\'));

    if(szPathDelim)
    {
        if(szPathDelim == szPath)
            return false;
        *szPathDelim = TEXT('\0');
        if(szPathDelim[1] == TEXT('\0'))
        {
            szPathDelim = 0;
            fExpandIt = true;
        }
    }

    // Find this path.
    HTREEITEM hClosestChild = 0;
    HTREEITEM hChild = TreeView_GetChild(hwTree, hItem);
    while(hChild)
    {
        TCHAR szItemPath[MAX_PATH];

        TVITEMEX tvitem;
        tvitem.mask = TVIF_HANDLE | TVIF_TEXT;
        tvitem.hItem = hChild;
        tvitem.pszText = szItemPath;
        tvitem.cchTextMax = MAX_PATH;

        TreeView_GetItem(hwTree, &tvitem);

        if(lstrcmpi(szPath,tvitem.pszText) == 0)
            break;
        else if((StrStrI(tvitem.pszText, szPath) == tvitem.pszText) && !fExpandIt)
        {
            hClosestChild = hChild;
            break;
        }

        hChild = TreeView_GetNextSibling(hwTree, hChild);
    }

    if(!hChild)
    {
        if(!hClosestChild)
            return false;
        else
        {
            hChild = hClosestChild;
            szPathDelim = 0;
        }
    }

    // If nothing more on the path, select this item,
    // or expand and continue
    if(szPathDelim == 0)
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);

        TreeView_SelectItem(hwTree, hChild);
    }
    else
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);        

        if(!SelectSubitemFromPartialPath(hwTree, hChild, szPathDelim+1))
            return false;
    }

    return true;
}

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
// szPath is trashed.
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath)
{
    if(!SelectSubitemFromPartialPath(hwTree, 0, szPath))
        TreeView_SelectItem(hwTree, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparsewrapper.cpp ===
// AppParse.cpp : Implementation of CAppParse
#include "stdafx.h"
#include "AppParseWeb.h"
#include "AppParseWrapper.h"
#include "AppParse.h"
#include <oledb.h>
#include <shlobj.h>
#include <comdef.h>
#include <rpcdce.h>
#include <msxml.h>
#include <icrsint.h>
#include <assert.h>
#include "filebrowser.h"

// Progress dialog functions
void InitProgressDialog(char* szText, HANDLE hEvent);
void KillProgressDialog();

// Save time by creating only seven ADO objects, and sharing, when parsing information
// into the database.
struct SADOInfo
{
    _ConnectionPtr pConn;
    IADORecordBinding* prbProjects;    
    IADORecordBinding* prbModules;
    IADORecordBinding* prbFuncs;    

    SProjectRecord pr;
    SModuleRecord mr;
    SFunctionRecord fr;
};

// Display an error message, then throw a COM error
void APError(char* szMessage, HRESULT hr)
{
    ::MessageBox(0, szMessage, "AppParse Error", MB_OK | MB_ICONERROR);
    _com_issue_error(hr);
}

// Get text subordinate to another node (e.g., <SIZE>0xabcdefg</SIZE>)
bool GetChildText(IXMLDOMNode* pXMLNode, variant_t* pVtVal)
{
    HRESULT hr;

    IXMLDOMNode* pXMLTextNode   = 0;

    // Try to get first child node, return FALSE if not present
    hr = pXMLNode->get_firstChild(&pXMLTextNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    if(!pXMLTextNode)
        return false;

    // Check if it is a text node.
    DOMNodeType domNodeType;

    hr = pXMLTextNode->get_nodeType(&domNodeType);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    // If so, copy text into variant, otherwise return
    if(domNodeType == NODE_TEXT)
    {        
        hr = pXMLTextNode->get_nodeValue(pVtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        SafeRelease(pXMLTextNode);
        return true;
    }    
    else
    {
        SafeRelease(pXMLTextNode);
        return false;
    }

    SafeRelease(pXMLTextNode);
}

// Convert a Month/Day/Year date into a DB-friendly date.
// A DB Friendly date is a double, indicating number of days since
// 1899 in the whole part, time in the fractional.  We disregard time.
double DateToDBDate(int month, int day, int year)
{
    // Check that the date is even valid.
    assert (month > 0 && month < 13);
    assert(day > 0 && day < 32);
    assert(year > 1899);

    // Quick lookup for number of days in each month.
    int DaysInMonth[] = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    double dbDate = 0;

    // Get full years
    dbDate = (year - 1899 - 1) * 365;

    // Adjust for leap years
    dbDate += ((year-1899-1)/4);
    dbDate -= ((year-1899-1)/100);
    dbDate += ((year-1899-1)/400);

    // Add days for each month.
    for(int i = 1; i < month; i++)
        dbDate += DaysInMonth[i];

    // Add the day of month to total.
    dbDate += day;

    return dbDate;
}

// Get file information for the image from an <INFO> node.
void GetImageInfo(IXMLDOMNode* pXMLInfoNode, SImageFileInfo* pInfo)
{
    HRESULT hr;

    IXMLDOMNode*        pXMLAttrChild   = 0;
    IXMLDOMNodeList*    pXMLChildList   = 0;
    IXMLDOMNode*        pXMLTextNode    = 0;

    // Get list of child nodes and move to first.
    hr = pXMLInfoNode->get_childNodes(&pXMLChildList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildList->nextNode(&pXMLAttrChild);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    // As long as there is a child node
    while(pXMLAttrChild)
    {

        // Get thename of the node
        BSTR bstrName;

        hr = pXMLAttrChild->get_nodeName(&bstrName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
        bstr_t bsz(bstrName, false);

        // Extract info based on node type
        if(stricmp(bsz, "DATE")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {               
                int month, day, year;
                sscanf(static_cast<bstr_t>(vtVal), "%d/%d/%d", &month, 
                    &day, &year);

                pInfo->Date = DateToDBDate(month, day, year);
                pInfo->DateStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "SIZE")==0)
        {
            variant_t vtVal;            
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                sscanf(static_cast<bstr_t>(vtVal), "%x", &pInfo->Size);
                pInfo->SizeStatus = adFldOK;                               
            }
        }
        else if(stricmp(bsz, "BIN_FILE_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->BinFileVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->BinFileVersion[49] = '\0';
                pInfo->BinFileVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "BIN_PRODUCT_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->BinProductVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->BinProductVersion[49] = '\0';
                pInfo->BinProductVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "CHECKSUM")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                sscanf(static_cast<bstr_t>(vtVal), "%x", &pInfo->CheckSum);
                pInfo->CheckSumStatus = adFldOK;                               
            }
        }
        else if(stricmp(bsz, "COMPANY_NAME")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->CompanyName, static_cast<bstr_t>(vtVal),255);
                pInfo->CompanyName[254] = '\0';
                pInfo->CompanyNameStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "PRODUCT_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->ProductVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->ProductVersion[49];
                pInfo->ProductVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "PRODUCT_NAME")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->ProductName, static_cast<bstr_t>(vtVal),255);
                pInfo->ProductName[254] = '\0';
                pInfo->ProductNameStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "FILE_DESCRIPTION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->FileDesc, static_cast<bstr_t>(vtVal),255);
                pInfo->FileDesc[254] = '\0';
                pInfo->FileDescStatus = adFldOK;
            }
        }

        SafeRelease(pXMLAttrChild);

        // Move to next node
        hr = pXMLChildList->nextNode(&pXMLAttrChild);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    SafeRelease(pXMLChildList);
    SafeRelease(pXMLAttrChild);
    SafeRelease(pXMLTextNode);
}

// Get all info related to a function from XML
void GetFunctionInfo(IXMLDOMNode* pXMLFunctionNode, ULONG lModuleID, SADOInfo* pADOInfo)
{
    HRESULT hr;    
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;

    // Start with no members valid.
    pADOInfo->fr.AddressStatus = pADOInfo->fr.HintStatus = 
        pADOInfo->fr.OrdinalStatus = pADOInfo->fr.ForwardNameStatus = adFldNull;
    
    // Get parent ID
    pADOInfo->fr.ModuleID = lModuleID;

    // Get all attribute nodes
    hr = pXMLFunctionNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    // Loop through the list.
    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        // Get attribute name and value.
        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        bstr_t bszVal = vtVal;
        
        // Copy info into struct
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {            
            strncpy(pADOInfo->fr.Name, static_cast<PSTR>(bszVal), 255);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "HINT")== 0)
        {
            pADOInfo->fr.HintStatus = adFldOK;
            pADOInfo->fr.Hint = atoi(bszVal);
        }
        else if (stricmp(static_cast<PSTR>(bsz), "ORDINAL") == 0)
        {
            pADOInfo->fr.OrdinalStatus = adFldOK;
            pADOInfo->fr.Ordinal = atoi(bszVal);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "ADDRESS") == 0)
        {
            pADOInfo->fr.AddressStatus = adFldOK;
            pADOInfo->fr.Address = atoi(bszVal);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "FORWARD_TO")==0)
        {
            pADOInfo->fr.ForwardNameStatus = adFldOK;
            strncpy(pADOInfo->fr.ForwardName, bszVal, 255);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "DELAYED") == 0)
        {
            pADOInfo->fr.Delayed = (stricmp(bszVal, "true")==0);
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    
    // Add a new record to the database.
    hr = pADOInfo->prbFuncs->AddNew(&pADOInfo->fr);
    if(FAILED(hr))
        APError("Unable to add new function record to database", hr);
        
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);
}

// Get all info related to a module.
void GetModuleInfo(IXMLDOMNode* pXMLModuleNode, ULONG lParentID, SADOInfo* pADOInfo, 
                   HANDLE hEvent, bool fTopLevel = false)
{
    if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        return;

    HRESULT hr;
    IXMLDOMNode*            pXMLChildNode = 0;
    IXMLDOMNodeList*        pXMLNodeList = 0;
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;    
    
    // All members are initially invalid.
    pADOInfo->mr.info.BinFileVersionStatus = 
        pADOInfo->mr.info.BinProductVersionStatus =
        pADOInfo->mr.info.CheckSumStatus = 
        pADOInfo->mr.info.CompanyNameStatus = 
        pADOInfo->mr.info.DateStatus = 
        pADOInfo->mr.info.FileDescStatus = 
        pADOInfo->mr.info.ProductNameStatus = 
        pADOInfo->mr.info.ProductVersionStatus =
        pADOInfo->mr.info.SizeStatus = 
        pADOInfo->mr.ParentIDStatus = 
        pADOInfo->mr.PtolemyIDStatus = adFldNull;
    
    // Copy parent ID
    pADOInfo->mr.ParentID = lParentID;

    // Check appropriate parent.
    if(fTopLevel)
        pADOInfo->mr.PtolemyIDStatus = adFldOK;
    else
        pADOInfo->mr.ParentIDStatus = adFldOK;

    // Get attributes
    hr = pXMLModuleNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    // Loop through attribute list.
    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        // Get attribute name and value.
        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {
            bstr_t bszTemp = vtVal;            
            strncpy(pADOInfo->mr.Name, static_cast<PSTR>(bszTemp), 100);
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    // Get info block, if present, for this module.
    hr = pXMLModuleNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            // If info node, get info block.
            if(stricmp(bszName, "Info") == 0)
                GetImageInfo(pXMLChildNode, &pADOInfo->mr.info);
            // Otherwise, if a systemmodule node, get systemmodule state.
            else if(stricmp(bszName, "SYSTEMMODULE")==0)
            {
                hr = pXMLChildNode->get_attributes(&pXMLAttrList);
                if(FAILED(hr) || !pXMLAttrList)
                    APError("Unable to parse XML output", hr);

                hr = pXMLAttrList->nextNode(&pXMLAttrNode);
                if(FAILED(hr) || !pXMLAttrNode)
                    APError("Unable to parse XML output", hr);

                while(pXMLAttrNode)
                {
                    BSTR bszAttrName;
                    variant_t vtVal;

                    hr = pXMLAttrNode->get_nodeName(&bszAttrName);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);

                    hr = pXMLAttrNode->get_nodeValue(&vtVal);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);

                    bstr_t bsz(bszAttrName, false);
                    if(stricmp(static_cast<PSTR>(bsz), "VALUE")==0)
                    {
                        bstr_t bszTemp = vtVal;            
                        pADOInfo->mr.SysMod = atoi(bszTemp);                                               
                    }

                    SafeRelease(pXMLAttrNode);
                    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);
                }
            }
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
  
    // Add a new module record to the database
    hr = pADOInfo->prbModules->AddNew(&pADOInfo->mr);
    if(FAILED(hr))
        APError("Unable to new module record to database", hr);

    ULONG lThisModuleID = pADOInfo->mr.ModuleID;

    // Get all functions's imported by this module, and DLL's
    hr = pXMLModuleNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))        
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            if(stricmp(bszName, "Function") == 0)
                GetFunctionInfo(pXMLChildNode, lThisModuleID, pADOInfo);
            else if(stricmp(bszName, "DLL") == 0)
                GetModuleInfo(pXMLChildNode, lThisModuleID, pADOInfo, hEvent);
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    SafeRelease(pXMLChildNode);
    SafeRelease(pXMLNodeList);
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);    
}

// Get project information from XML
void GetProjectInfo(IXMLDOMNode* pXMLProjectNode, SADOInfo* pADOInfo, HANDLE hEvent)
{
    if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        return;

    HRESULT hr;
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;
    IXMLDOMNode*            pXMLChildNode = 0;
    IXMLDOMNodeList*        pXMLNodeList = 0;       

    pADOInfo->pr.PtolemyID = -1;
    pADOInfo->pr.Name[0] = '\0';

    // Get name and ptolemy id attributes
    hr = pXMLProjectNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {
            bstr_t bszTemp = vtVal;
            strncpy(pADOInfo->pr.Name, static_cast<PSTR>(bszTemp), 100);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "ID") == 0)
        {
            bstr_t bszTemp = vtVal;
            pADOInfo->pr.PtolemyID = atoi(static_cast<PSTR>(bszTemp));
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    hr = pADOInfo->prbProjects->AddNew(&pADOInfo->pr);
    if(FAILED(hr))
        APError("Unable to add new project record to database", hr);
    
    // Parse all Exe's included in this project
    hr = pXMLProjectNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            if(stricmp(bszName, "EXE") == 0)
                GetModuleInfo(pXMLChildNode, pADOInfo->pr.PtolemyID, pADOInfo, hEvent, true);
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }    
    
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);
    SafeRelease(pXMLNodeList);
    SafeRelease(pXMLChildNode);
}

// Functions for walking an XML DOM object and storing
// information to the database
void ParseXMLWriteDB(const char* szXML, const char* szConnect, HANDLE hEvent)
{
    HRESULT hr;

    // Get DOM object associated with Projects node
    IXMLDOMDocument*    pXMLDoc = 0;    
    IXMLDOMNode*        pXMLRootNode = 0;
    IXMLDOMNode*        pXMLChildNode = 0;
    IXMLDOMNode*        pXMLProjectNode = 0;

    IXMLDOMNodeList*    pXMLChildNodeList = 0;

    // Create all ADO objects needed.
    SADOInfo adoInfo;    

    _ConnectionPtr pConn = 0;
    _RecordsetPtr pRSProjects = 0;
    _RecordsetPtr pRSModules = 0;    
    _RecordsetPtr pRSFuncs = 0;

    pConn.CreateInstance(__uuidof(Connection));
    pRSProjects.CreateInstance(__uuidof(Recordset));
    pRSModules.CreateInstance(__uuidof(Recordset));    
    pRSFuncs.CreateInstance(__uuidof(Recordset));

    hr = pRSProjects->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbProjects));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);
    
    hr = pRSModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbModules));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);

    hr = pRSFuncs->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbFuncs));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);

    pConn->Open(szConnect, "", "", adConnectUnspecified);

    pConn->BeginTrans();

    pRSProjects->Open("Projects", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);

    pRSModules->Open("Modules", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);
    
    pRSFuncs->Open("Functions", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);
    
    adoInfo.pConn = pConn;    
    
    adoInfo.pr.Name[0] = '\0';
    adoInfo.pr.PtolemyID = -1;
    
    adoInfo.mr.info.BinFileVersionStatus = 
        adoInfo.mr.info.BinProductVersionStatus =
        adoInfo.mr.info.CheckSumStatus = 
        adoInfo.mr.info.CompanyNameStatus = 
        adoInfo.mr.info.DateStatus = 
        adoInfo.mr.info.FileDescStatus = 
        adoInfo.mr.info.ProductNameStatus = 
        adoInfo.mr.info.ProductVersionStatus =
        adoInfo.mr.info.SizeStatus = 
        adoInfo.mr.ParentIDStatus = 
        adoInfo.mr.PtolemyIDStatus = 
        adoInfo.fr.AddressStatus = 
        adoInfo.fr.HintStatus = 
        adoInfo.fr.OrdinalStatus = 
        adoInfo.fr.ForwardNameStatus = adFldNull;

    hr = adoInfo.prbProjects->BindToRecordset(&adoInfo.pr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);

    hr = adoInfo.prbModules->BindToRecordset(&adoInfo.mr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);
    
    hr = adoInfo.prbFuncs->BindToRecordset(&adoInfo.fr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);

    hr = CoCreateInstance(CLSID_DOMDocument, 0, CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument, reinterpret_cast<void**>(&pXMLDoc));
    if(FAILED(hr))    
        APError("Unable to create IE XML DOM object", hr);

    VARIANT_BOOL fSuccess;
    hr = pXMLDoc->load(variant_t(szXML), &fSuccess);
    if(FAILED(hr) || fSuccess == VARIANT_FALSE)
        APError("Unable to load XML output", hr);

    // Walk the tree until we find the top-level project node
    // which is the only top-level node we care about.
    hr = pXMLDoc->QueryInterface(IID_IXMLDOMNode, 
        reinterpret_cast<void**>(&pXMLRootNode));

    if(FAILED(hr))
        APError("Unable to retrieve IE XML interface", hr);

    hr = pXMLRootNode->get_childNodes(&pXMLChildNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        // Check if this is the projects node.
        DOMNodeType domNodeType;
        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bszName;
            hr = pXMLChildNode->get_nodeName(&bszName);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);


            _bstr_t bsz(bszName, false);
            if(stricmp(static_cast<PSTR>(bsz), "AppParseResults")==0)
            {                
                break;
            }            
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLChildNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    SafeRelease(pXMLChildNodeList);

    // No child node, record not found.
    if(!pXMLChildNode)    
        APError("Unable to parse XML output", hr);    

    // Locate project node in that.
    hr = pXMLChildNode->get_childNodes(&pXMLChildNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildNodeList->nextNode(&pXMLProjectNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLProjectNode)
    {
        // Check if this is the projects node.
        DOMNodeType domNodeType;
        hr = pXMLProjectNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bszName;
            hr = pXMLProjectNode->get_nodeName(&bszName);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);


            _bstr_t bsz(bszName, false);
            if(stricmp(static_cast<PSTR>(bsz), "Project")==0)
            {
                GetProjectInfo(pXMLProjectNode, &adoInfo, hEvent);
            }            
        }

        SafeRelease(pXMLProjectNode);
        hr = pXMLChildNodeList->nextNode(&pXMLProjectNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    
    pRSProjects->UpdateBatch(adAffectAll);   

    pRSModules->UpdateBatch(adAffectAll);
    
    pRSFuncs->UpdateBatch(adAffectAll);

    // Important, skip commit if cancel was clicked by user.
    if(WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)     
        pConn->CommitTrans();

    pRSProjects->Close();

    pRSModules->Close();    
    
    pRSFuncs->Close();

    pConn->Close();

    SafeRelease(adoInfo.prbProjects);
    SafeRelease(adoInfo.prbModules);    
    SafeRelease(adoInfo.prbFuncs);
    
    SafeRelease(pXMLChildNodeList);
    SafeRelease(pXMLChildNode);
    SafeRelease(pXMLRootNode);
    SafeRelease(pXMLDoc);

}

/////////////////////////////////////////////////////////////////////////////
// CAppParse
STDMETHODIMP CAppParse::Parse()
{
    if(!m_szPath)
    {
        ::MessageBox(0, TEXT("Please select a path to profile"), TEXT("AppParse"),
            MB_OK | MB_ICONERROR);
        return S_OK;
    }

    if(m_ID == -1)
    {
        ::MessageBox(0, TEXT("Please enter a Ptolemy ID"), TEXT("AppParse"),
            MB_OK | MB_ICONERROR);
        return S_OK;
    }    

    // Show the progress dialog (reset the event to cancel)
    ResetEvent(m_hEvent);
    InitProgressDialog("Parsing, please do not close your browser window.", m_hEvent);

    // Generate a unique temp file name
    GUID guid;
    unsigned char* szUUID;

    char szFileName[MAX_PATH];

    HRESULT hr = CoCreateGuid(&guid);
    if(FAILED(hr))
        return hr;

    UuidToString(&guid, &szUUID);

    GetTempPath(MAX_PATH, szFileName);
    strcat(szFileName, reinterpret_cast<char*>(szUUID));
    strcat(szFileName, ".xml");

    FILE* pFile = fopen(szFileName, "wb");
    if(!pFile)
        APError("Unable to open output file", E_FAIL);

    // Parse the application
    AppParse(m_szPath, pFile, false, false, true, true, 
        "*", m_ID);

    fclose(pFile);

    RpcStringFree(&szUUID);

    // If user didn't cancel . . .
    if(WaitForSingleObject(m_hEvent, 0) != WAIT_OBJECT_0)
    {
            
        // Write results to DB
        try
        {
            ParseXMLWriteDB(szFileName, m_szConnect, m_hEvent);
        }
        catch(_com_error& e)
        {    
            ::MessageBox(0, (LPCSTR)e.ErrorMessage(), "COM Error", MB_OK);
        }
    }
    
    // Terminate temp file
    DeleteFile(szFileName);

    // Remove progress dialog box.
    KillProgressDialog();

    return S_OK;
}

STDMETHODIMP CAppParse::Browse()
{
    PTSTR szPath = BrowseForFolder(0, 0);

    if(!szPath)
        return S_FALSE;

    if(m_szPath)
        delete m_szPath;

    m_szPath = new char[strlen(szPath)+1];
    strcpy(m_szPath,szPath);    

    return S_OK;
}

STDMETHODIMP CAppParse::get_path(BSTR *pVal)
{
    if(m_szPath)
    {
        OLECHAR* sz;
        sz = new OLECHAR[strlen(m_szPath)+1];
        MultiByteToWideChar(CP_ACP, 0, m_szPath, -1, sz, strlen(m_szPath)+1);
        *pVal = SysAllocString(sz);
        delete sz;
    }
    else
        *pVal = SysAllocString(L"");

    return S_OK;
}

STDMETHODIMP CAppParse::put_path(BSTR newVal)
{
    if(m_szPath)
    {
        delete m_szPath;
        m_szPath = 0;
    }

    _bstr_t bstrGhostLoc(newVal);
    LPSTR szGhostLoc = (LPSTR)bstrGhostLoc;
    m_szPath = new char[strlen(szGhostLoc)+1];
    strcpy(m_szPath, szGhostLoc);

    return S_OK;
}

STDMETHODIMP CAppParse::get_PtolemyID(long *pVal)
{
    *pVal = m_ID;
    return S_OK;
}

STDMETHODIMP CAppParse::put_PtolemyID(long newVal)
{
    m_ID = newVal;
    return S_OK;
}

STDMETHODIMP CAppParse::get_ConnectionString(BSTR *pVal)
{
    if(m_szConnect)
    {
        OLECHAR* sz;
        sz = new OLECHAR[strlen(m_szConnect)+1];
        MultiByteToWideChar(CP_ACP, 0, m_szConnect, -1, sz, strlen(m_szConnect)+1);
        *pVal = SysAllocString(sz);
        delete sz;
    }
    else
        *pVal = SysAllocString(L"");


    return S_OK;
}

STDMETHODIMP CAppParse::put_ConnectionString(BSTR newVal)
{
    if(m_szConnect)
    {
        delete m_szConnect;
        m_szConnect = 0;
    }

    _bstr_t bstrGhostLoc(newVal);
    LPSTR szGhostLoc = (LPSTR)bstrGhostLoc;
    m_szConnect = new char[strlen(szGhostLoc)+1];
    strcpy(m_szConnect, szGhostLoc);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparsewrapper.h ===
// AppParse.h : Declaration of the CAppParse

#ifndef __APPPARSE_H_
#define __APPPARSE_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <windows.h>
#include <icrsint.h>
#include <oledb.h>

#import "C:\Program Files\Common Files\System\ADO\msado15.dll" \
    no_namespace rename("EOF", "EndOfFile")

void APError(char* szMessage, HRESULT hr);

/////////////////////////////////////////////////////////////////////////////
// CAppParse
class ATL_NO_VTABLE CAppParse : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IAppParse, &IID_IAppParse, &LIBID_APPPARSEWEBLib>,
	public CComControl<CAppParse>,
	public IPersistStreamInitImpl<CAppParse>,
	public IOleControlImpl<CAppParse>,
	public IOleObjectImpl<CAppParse>,
	public IOleInPlaceActiveObjectImpl<CAppParse>,
	public IViewObjectExImpl<CAppParse>,
	public IOleInPlaceObjectWindowlessImpl<CAppParse>,
	public IPersistStorageImpl<CAppParse>,
	public ISpecifyPropertyPagesImpl<CAppParse>,
	public IQuickActivateImpl<CAppParse>,
	public IDataObjectImpl<CAppParse>,
	public IProvideClassInfo2Impl<&CLSID_AppParse, NULL, &LIBID_APPPARSEWEBLib>,
    public CComCoClass<CAppParse, &CLSID_AppParse>,
    public IObjectSafetyImpl<CAppParse, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IObjectSafetyImpl<CAppParse, INTERFACESAFE_FOR_UNTRUSTED_DATA>

{
private:
    char* m_szConnect;
    char* m_szPath;
    long    m_ID;	

    HANDLE m_hEvent;
public:
	CAppParse()
	{
        m_hEvent = 0;

        m_szConnect = 0;
        m_szPath = 0;
        m_ID = -1;
        m_hEvent = CreateEvent(0, TRUE, FALSE, 0);
        if(!m_hEvent)
            APError("Unable to create kernel object", E_FAIL);
	}

    ~CAppParse()
    {
        if(m_hEvent)
            CloseHandle(m_hEvent);

        if(m_szPath)
            delete m_szPath;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_APPPARSE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAppParse)
	COM_INTERFACE_ENTRY(IAppParse)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CAppParse)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CAppParse)
	CHAIN_MSG_MAP(CComControl<CAppParse>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IAppParse
public:	
	STDMETHOD(QueryDB)(long PtolemyID, BSTR bstrFunction);
	STDMETHOD(get_ConnectionString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ConnectionString)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_PtolemyID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_PtolemyID)(/*[in]*/ long newVal);
	STDMETHOD(get_path)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_path)(/*[in]*/ BSTR newVal);
	STDMETHOD(Browse)();
	STDMETHOD(Parse)();

	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : AppParse");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}
};

// All information associated with an EXE or DLL.
struct SImageFileInfo
{
    int DateStatus;
    double Date;
    
    int SizeStatus;
    int Size;
    int BinFileVersionStatus;
    CHAR BinFileVersion[50];

    int BinProductVersionStatus;
    CHAR BinProductVersion[50];

    int CheckSumStatus;
    ULONG CheckSum;

    int CompanyNameStatus;
    CHAR CompanyName[255];

    int ProductVersionStatus;
    CHAR ProductVersion[50];

    int ProductNameStatus;
    CHAR ProductName[255];

    int FileDescStatus;
    CHAR FileDesc[255];
};

// Record bindings, eases associating database records with C++ structures.

// A Project record, a single entry in the "Projects" table
struct SProjectRecord : public CADORecordBinding
{
BEGIN_ADO_BINDING(SProjectRecord)

	// All fields optional
    ADO_NUMERIC_ENTRY2(1, adInteger, PtolemyID, 5, 0, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY4(2, adVarChar, Name, 255, TRUE)

END_ADO_BINDING()
    
	// A unique identifier for this project.
    ULONG PtolemyID;
	
	// A user-friendly name for the project
    CHAR Name[255];
};

// A Module (EXE or DLL) record
struct SModuleRecord : public CADORecordBinding
{
    BEGIN_ADO_BINDING(SModuleRecord)

    // Query the autonumber DllID, don't change
    ADO_NUMERIC_ENTRY2(1, adInteger, ModuleID, 5, 0, FALSE)

    // At least one of these fields must be present
    ADO_NUMERIC_ENTRY(2, adInteger, ParentID, 5, 0, PtolemyIDStatus, TRUE)
    ADO_NUMERIC_ENTRY(3, adInteger, ParentID, 5, 0, ParentIDStatus, TRUE)

    // Required fields    
    ADO_VARIABLE_LENGTH_ENTRY4(4, adVarChar, Name, 255, TRUE)
    ADO_FIXED_LENGTH_ENTRY2(5, adBoolean, SysMod, TRUE)

    // Optional fields
    ADO_FIXED_LENGTH_ENTRY(6, adDate, info.Date, info.DateStatus, TRUE)
    ADO_NUMERIC_ENTRY(7, adInteger, info.Size, 5, 0, info.SizeStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(8, adVarChar, info.BinFileVersion, 50,
        info.BinFileVersionStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(9, adVarChar, info.BinProductVersion, 50,
        info.BinProductVersionStatus, TRUE)
    ADO_NUMERIC_ENTRY(10, adInteger, info.CheckSum, 5, 0, info.CheckSumStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(11, adVarChar, info.CompanyName, 255, info.CompanyNameStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(12, adVarChar, info.ProductVersion, 50, info.ProductVersionStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(13, adVarChar, info.ProductName, 255, info.ProductNameStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(14, adVarChar, info.FileDesc, 255, info.FileDescStatus, TRUE)

END_ADO_BINDING()

public:

	// Unique ID for this entry (autonumber, done by DB)
    ULONG ModuleID;
    
	// Whether this module belongs to a project or 
	// is a child of another module
    int PtolemyIDStatus;
    int ParentIDStatus;

	// Parent's ID (either Ptolemy or Module)
    ULONG ParentID;

	// Filename of this module.
    CHAR Name[255];

	// File info
    SImageFileInfo info;

	// Whether or not this is a "system" module (like kernel32, user, gdi, advapi, etc.)
    DWORD SysMod;
};

// A Function Record
struct SFunctionRecord : public CADORecordBinding
{
BEGIN_ADO_BINDING(SFunctionRecord)

    // Required fields
    ADO_NUMERIC_ENTRY2(1, adInteger, FunctionID, 5, 0, FALSE)
    ADO_NUMERIC_ENTRY2(2, adInteger, ModuleID, 5, 0, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY4(3, adVarChar, Name, 255, TRUE)

    ADO_FIXED_LENGTH_ENTRY2(8, adBoolean, Delayed, TRUE)

    // Optional fields
    ADO_NUMERIC_ENTRY(4, adInteger, Address, 5,0,AddressStatus, TRUE)
    ADO_NUMERIC_ENTRY(5, adInteger, Ordinal, 5, 0, OrdinalStatus, TRUE)
    ADO_NUMERIC_ENTRY(6, adInteger, Hint, 5, 0, HintStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(7, adVarChar, ForwardName, 255, 
        ForwardNameStatus, TRUE)
    

END_ADO_BINDING()

public:

	// Unique ID for this function (autonumber, given by the DB)
    ULONG FunctionID;

	// Parent module
    ULONG ModuleID;

	// Imported function name
    CHAR Name[255];

	// Address, if bound
    int AddressStatus;
    ULONG Address;

	// Ordinal, if ordinal import
    int OrdinalStatus;
    ULONG Ordinal;

	// Hint, if name import
    int HintStatus;
    ULONG Hint;

	// Forwarded name (e.g., HeapAlloc->RtlAllocateHeap)
    int ForwardNameStatus;
    CHAR ForwardName[255];

	// Whether this is a delayed import or not.
    DWORD Delayed;
};

// "Safely" release a COM object.
template<class T>
inline void SafeRelease(T& obj)
{
    if(obj)
	{
        obj->Release();
		obj = 0;
	}
}

#endif //__APPPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparseweb_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppParse,0xBAF56261,0x3C9F,0x44F9,0x9F,0x30,0x69,0x22,0xDD,0x29,0xBD,0x81);


MIDL_DEFINE_GUID(IID, LIBID_APPPARSEWEBLib,0x8FD727E1,0xFD34,0x43C5,0xAB,0xD2,0x76,0x1C,0x18,0x60,0xFE,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_AppParse,0x083BE70B,0xA07B,0x46FA,0xBC,0xB1,0x8D,0x85,0xD2,0x62,0xC6,0x99);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppParse,0xBAF56261,0x3C9F,0x44F9,0x9F,0x30,0x69,0x22,0xDD,0x29,0xBD,0x81);


MIDL_DEFINE_GUID(IID, LIBID_APPPARSEWEBLib,0x8FD727E1,0xFD34,0x43C5,0xAB,0xD2,0x76,0x1C,0x18,0x60,0xFE,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_AppParse,0x083BE70B,0xA07B,0x46FA,0xBC,0xB1,0x8D,0x85,0xD2,0x62,0xC6,0x99);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\progdialog.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <commctrl.h>
#include "resource.h"

HANDLE g_hThread = 0;
DWORD g_dwThreadID = 0;

char szProgressText[512];
INT_PTR CALLBACK ProgressDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, 
                                 LPARAM lParam)
{     
	static HANDLE hEvent;
    switch(uiMsg)
    {
    case WM_INITDIALOG:
		hEvent = reinterpret_cast<HANDLE>(lParam);
        return TRUE;
 
    case WM_COMMAND:
		if(LOWORD(wParam)==IDC_CANCELBUTTON)
			SetEvent(hEvent);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DWORD WINAPI ThreadProc(PVOID hEvent)
{
    HWND hwDlg = CreateDialogParam(_Module.GetModuleInstance(), 
        MAKEINTRESOURCE(IDD_PROGRESS), 0, ProgressDlgProc,
		reinterpret_cast<LPARAM>(hEvent));

    ShowWindow(hwDlg, SW_SHOWNORMAL);

    // Add the animation control.
    HWND hwChild;
    RECT rcChild;    
    POINT pt;

    HWND hwAnim = Animate_Create(hwDlg, 50, 
        WS_CHILD | ACS_CENTER | ACS_TRANSPARENT, _Module.GetModuleInstance());

    hwChild = GetDlgItem(hwDlg, IDC_ANIMHOLDER);
    GetWindowRect(hwChild, &rcChild);    

    DestroyWindow(hwChild);
    pt.x = rcChild.left;
    pt.y = rcChild.top;
    ScreenToClient(hwDlg, &pt);
    SetWindowPos(hwAnim, 0, pt.x, pt.y, rcChild.right-rcChild.left,
        rcChild.bottom - rcChild.top, SWP_NOZORDER);

    Animate_Open(hwAnim, MAKEINTRESOURCE(IDR_PARSING));    

    Animate_Play(hwAnim, 0, -1, -1);

    hwChild = GetDlgItem(hwDlg, IDC_PROGRESSTEXT);
    ::SetWindowText(hwChild, szProgressText);

    ShowWindow(hwAnim, SW_SHOW);
    MSG msg;
    while(GetMessage(&msg, 0, 0, 0))
    {
        if(msg.message == WM_USER + 1)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return 0;
}

void InitProgressDialog(char* szText, HANDLE hEvent)
{
    strcpy(szProgressText, szText);
    g_hThread = CreateThread(0, 0, ThreadProc, reinterpret_cast<void*>(hEvent), 
		0, &g_dwThreadID);
}

void KillProgressDialog()
{
    if(g_hThread)
    {
        while(!PostThreadMessage(g_dwThreadID, WM_USER+1, 0, 0))
            Sleep(0);

        CloseHandle(g_hThread);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\appparseweb.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __appparseweb_h__
#define __appparseweb_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAppParse_FWD_DEFINED__
#define __IAppParse_FWD_DEFINED__
typedef interface IAppParse IAppParse;
#endif 	/* __IAppParse_FWD_DEFINED__ */


#ifndef __AppParse_FWD_DEFINED__
#define __AppParse_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppParse AppParse;
#else
typedef struct AppParse AppParse;
#endif /* __cplusplus */

#endif 	/* __AppParse_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IAppParse_INTERFACE_DEFINED__
#define __IAppParse_INTERFACE_DEFINED__

/* interface IAppParse */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppParse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAF56261-3C9F-44F9-9F30-6922DD29BD81")
    IAppParse : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Parse( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Browse( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_path( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PtolemyID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PtolemyID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionString( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryDB( 
            long PtolemyID,
            BSTR bstrFunction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppParseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppParse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppParse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppParse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppParse * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppParse * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppParse * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppParse * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Parse )( 
            IAppParse * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Browse )( 
            IAppParse * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_path )( 
            IAppParse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_path )( 
            IAppParse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PtolemyID )( 
            IAppParse * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PtolemyID )( 
            IAppParse * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionString )( 
            IAppParse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectionString )( 
            IAppParse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryDB )( 
            IAppParse * This,
            long PtolemyID,
            BSTR bstrFunction);
        
        END_INTERFACE
    } IAppParseVtbl;

    interface IAppParse
    {
        CONST_VTBL struct IAppParseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppParse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppParse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppParse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppParse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppParse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppParse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppParse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppParse_Parse(This)	\
    (This)->lpVtbl -> Parse(This)

#define IAppParse_Browse(This)	\
    (This)->lpVtbl -> Browse(This)

#define IAppParse_get_path(This,pVal)	\
    (This)->lpVtbl -> get_path(This,pVal)

#define IAppParse_put_path(This,newVal)	\
    (This)->lpVtbl -> put_path(This,newVal)

#define IAppParse_get_PtolemyID(This,pVal)	\
    (This)->lpVtbl -> get_PtolemyID(This,pVal)

#define IAppParse_put_PtolemyID(This,newVal)	\
    (This)->lpVtbl -> put_PtolemyID(This,newVal)

#define IAppParse_get_ConnectionString(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionString(This,pVal)

#define IAppParse_put_ConnectionString(This,newVal)	\
    (This)->lpVtbl -> put_ConnectionString(This,newVal)

#define IAppParse_QueryDB(This,PtolemyID,bstrFunction)	\
    (This)->lpVtbl -> QueryDB(This,PtolemyID,bstrFunction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_Parse_Proxy( 
    IAppParse * This);


void __RPC_STUB IAppParse_Parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_Browse_Proxy( 
    IAppParse * This);


void __RPC_STUB IAppParse_Browse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_path_Proxy( 
    IAppParse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAppParse_get_path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_path_Proxy( 
    IAppParse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppParse_put_path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_PtolemyID_Proxy( 
    IAppParse * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IAppParse_get_PtolemyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_PtolemyID_Proxy( 
    IAppParse * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppParse_put_PtolemyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_ConnectionString_Proxy( 
    IAppParse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAppParse_get_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_ConnectionString_Proxy( 
    IAppParse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppParse_put_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_QueryDB_Proxy( 
    IAppParse * This,
    long PtolemyID,
    BSTR bstrFunction);


void __RPC_STUB IAppParse_QueryDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppParse_INTERFACE_DEFINED__ */



#ifndef __APPPARSEWEBLib_LIBRARY_DEFINED__
#define __APPPARSEWEBLib_LIBRARY_DEFINED__

/* library APPPARSEWEBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPPARSEWEBLib;

EXTERN_C const CLSID CLSID_AppParse;

#ifdef __cplusplus

class DECLSPEC_UUID("083BE70B-A07B-46FA-BCB1-8D85D262C699")
AppParse;
#endif
#endif /* __APPPARSEWEBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppParseWeb.rc
//
#define IDS_PROJNAME                    100
#define IDB_APPPARSE                    101
#define IDR_APPPARSE                    102
#define IDD_PROGRESS                    201
#define IDC_PROGRESS                    201
#define IDC_PROGRESSTEXT                202
#define IDR_PARSING                     203
#define IDC_BROWSE                      204
#define IDC_ANIMHOLDER                  204
#define IDC_DIRTREE                     205
#define IDC_CANCELBUTTON                205
#define IDC_FILELISTCOMBO               206
#define IDD_BROWSE                      207

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\appverif.h ===
// appverif.h : main header file for the APPVERIF application
//

#if !defined(AFX_APPVERIF_H__7F4651EB_4FF9_49B7_9AAA_255A1E4D484E__INCLUDED_)
#define AFX_APPVERIF_H__7F4651EB_4FF9_49B7_9AAA_255A1E4D484E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAppverifApp:
// See appverif.cpp for the implementation of this class
//

class CAppverifApp : public CWinApp
{
public:
	CAppverifApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppverifApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAppverifApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_APPVERIF_H__7F4651EB_4FF9_49B7_9AAA_255A1E4D484E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\appverif.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: appverif.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//
// Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "appverif.h"

#include "AVSheet.h"
#include "AVGlobal.h"
#include "AVUtil.h"
#include "CmdLine.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAppverifApp

BEGIN_MESSAGE_MAP(CAppverifApp, CWinApp)
	//{{AFX_MSG_MAP(CAppverifApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAppverifApp construction

CAppverifApp::CAppverifApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CAppverifApp object

CAppverifApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CAppverifApp initialization

BOOL CAppverifApp::InitInstance()
{
    DWORD dwExitCode;
    static CAppverifSheet dlg;

    AfxEnableControlContainer();

    dwExitCode = AV_EXIT_CODE_SUCCESS;

    //
    // Initialize the global data
    //

    if( AVInitalizeGlobalData() == FALSE )
    {
        AVMesssageFromResource( IDS_CANNOT_INITIALIZE_DATA );
        
        dwExitCode = AV_EXIT_CODE_ERROR;

        goto ExitApp;
    }

    m_pszAppName = _tcsdup( (LPCTSTR)g_strAppName );

    //
    // Check for command line arguments
    //

    if( __argc > 1 )
    {
        //
        // Run just in command line mode
        //

        _tsetlocale( LC_ALL, _T( ".OCP" ) );

        g_bCommandLineMode = TRUE;

        dwExitCode = CmdLineExecute( __argc, __targv );

        goto ExitApp;
    }
    else
    {
        //
        // GUI mode - free the console
        //

        FreeConsole();

        //
        // Display the wizard
        //

        
	    m_pMainWnd = &dlg;
	    dlg.DoModal();
    }

ExitApp:

    //
    // All done, exit the app
    //

    exit( dwExitCode );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED_)
#define AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appparse\appparseweb\querydb.cpp ===
// QueryDB.cpp: Database querying methods.
#include "stdafx.h"
#include "AppParseWeb.h"
#include "AppParseWrapper.h"
#include <oledb.h>
#include <comdef.h>
#include <mshtml.h>
#include <assert.h>

// Progress dialog functions
void InitProgressDialog(char* szText, HANDLE hEvent);
void KillProgressDialog();

// Return true if name matches search string, false otherwise.
bool MatchName(char* szString, char* szSearchIn);

// Tree used to represent parse information
class CTreeNode
{
private:    
    enum {c_Root, c_Project, c_Module, c_Function} m_eType;
    
    int m_nChildren;
    CTreeNode** m_ppChildren;

	// Relevent info retrieved from DB
    union
    {
        struct
        {
            char szName[256];
            long lPtolemyID;
        } m_ProjectInfo;

        struct
        {
            char szName[256];
        } m_ModuleInfo;

        struct
        {
            char szName[256];
        } m_FunctionInfo;
    };    

	// HTML generation members

	// Unique table and div ID's.
	static int m_iCurrDiv;
	static int m_iCurrTab;

	// Amount of space set aside for HTML content.
	static int m_iAllocSize;

	// Pointer to HTML content.
	static char* m_szHTML;
	// Pointer to where the more HTML should be inserted.
	static char* m_szCurrHTML;

	// Pointer a few kilobytes before the end of the HTML buffer, reaching
	// here means we should allocate more space.
	static char* m_szFencePost;

	// True if this node or one of its subtrees contains the function, false otherwise.
    bool ContainsFunction(char* szFuncName)
    {  
        if(m_eType == c_Function)
            return MatchName(m_FunctionInfo.szName, szFuncName);

        for(int i = 0; i < m_nChildren; i++)
        {
            if(m_ppChildren[i]->ContainsFunction(szFuncName))
                    return true;                            
        }

        return false;
    }

	// Write all HTML output
	void WriteHTML()
    {
        static int iDepth = 0;        
        switch(m_eType)
        {
        case c_Root:
            break;
        case c_Project:

            // Create a new table and Div in the project
            m_iCurrTab++;
            m_iCurrDiv++;

            wsprintf(m_szCurrHTML,
                "<table ID = TAB%d border = 1 width = 100%% style=\"float:right\">\n"
                "<tr>\n<td width=1%%>\n"
                "<input type=\"button\" ID=DIV%dButton value = \"+\" "
                "onClick=\"ShowItem(\'DIV%d\')\">"
                "</td>\n"
                "<td>%s</td><td width=20%%>%d</td>\n</tr>\n"
                "</table>\n"
                "<DIV ID=DIV%d style=\"display:none;\">\n",
                m_iCurrTab, m_iCurrDiv, m_iCurrDiv, 
                m_ProjectInfo.szName, m_ProjectInfo.lPtolemyID,
                m_iCurrDiv);
            
            m_szCurrHTML += strlen(m_szCurrHTML);
                                                                                
            break;
        case c_Module:
            // Create a new table and div in the project
            m_iCurrTab++;
            m_iCurrDiv++;

            wsprintf(m_szCurrHTML, 
                "<table ID = TAB%d border = 1 width = %d%% style=\"float:right\">\n"
                "<tr>\n<td width=1%%>"
                "<input type=\"button\" ID=DIV%dButton value = \"+\" "
                "onClick=\"ShowItem(\'DIV%d\')\">"
                "</td>\n"
                "<td>%s</td>\n</tr>\n"
                "</table>\n"
                "<DIV ID=DIV%d style=\"display:none;\">\n",
                m_iCurrTab, 100-iDepth*5, m_iCurrDiv, m_iCurrDiv,
                m_ModuleInfo.szName, m_iCurrDiv );

            m_szCurrHTML += strlen(m_szCurrHTML);                        
                                                                       
            break;
        case c_Function:
            // Create a new table in the project
            m_iCurrTab++;
            wsprintf(m_szCurrHTML, 
                "<table ID = TAB%d border = 1 width = %d%% style=\"float:right\">\n"
                "<tr>"
                "<td>%s</td>\n</tr>\n"
                "</table>\n",
                m_iCurrTab, 100-iDepth*5, m_FunctionInfo.szName);
            m_szCurrHTML += strlen(m_szCurrHTML);
            break;
        default:
            assert(0);
            break;
        }

		// Put in all the HTML for the children
        if(m_ppChildren)
        {
            iDepth++;
            for(int i = 0; i < m_nChildren; i++)            
                m_ppChildren[i]->WriteHTML();

            iDepth--;
        }

        switch(m_eType)
        {
        case c_Function:
        case c_Root:
            break;
        case c_Project:
        case c_Module:        
            wsprintf(m_szCurrHTML, "</DIV>\n");
            m_szCurrHTML += strlen(m_szCurrHTML);
            break;        
        }

        // Check if we should allocate more
        if(m_szCurrHTML > m_szFencePost)
        {
            m_iAllocSize *= 2;
            char* szNewBuffer = new char[m_iAllocSize];
            m_szFencePost = &szNewBuffer[m_iAllocSize - 2 * 1024];
            strcpy(szNewBuffer, m_szHTML);
            m_szCurrHTML = &szNewBuffer[strlen(szNewBuffer)];
            delete m_szHTML;
            m_szHTML = szNewBuffer;
        }

    }
public:
    CTreeNode()
    {		
        m_eType = c_Root;
        m_nChildren = 0;
        m_ppChildren = 0;
		assert(m_eType < 50);
    }

    CTreeNode(SProjectRecord pr)
    {
        m_eType = c_Project;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_ProjectInfo.szName, pr.Name);
        m_ProjectInfo.lPtolemyID = pr.PtolemyID;		
		assert(m_eType < 50);
    }

    CTreeNode(SModuleRecord mr)
    {
        m_eType = c_Module;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_ModuleInfo.szName, mr.Name);
		assert(m_eType < 50);
    }

    CTreeNode(SFunctionRecord fr)
    {
        m_eType = c_Function;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_FunctionInfo.szName, fr.Name);
		assert(m_eType < 50);
    }

    ~CTreeNode()
    {		
        RemoveChildren();
    }

	// Remove tree nodes that contain no nodes matching the search criteria.
	// Returns true if node should be removed, false otherwise.
    bool Prune(char* szFunc)
    {
		assert(m_eType < 50);
		// Go through each child
        for(int i = 0; i < m_nChildren; i++)
        {
			// Check if needs to be removed
            if(m_ppChildren[i]->Prune(szFunc))
            {
                // Remove this child.
                delete m_ppChildren[i];
                m_ppChildren[i] = 0;
            }
        }


		// Update the child list
        int nChildren = 0;
        for(i = 0; i < m_nChildren; i++)
        {
            if(m_ppChildren[i])
                nChildren++;
        }

        if(nChildren)
        {
            CTreeNode** pNew = new CTreeNode*[nChildren];
            int iCurr = 0;
            for(i = 0; i < m_nChildren; i++)
            {
                if(m_ppChildren[i])
                {
                    pNew[iCurr++] = m_ppChildren[i];
                }
            }

            delete m_ppChildren;
            m_ppChildren = pNew;

            assert(iCurr == nChildren);
        }
        else
        {
            if(m_ppChildren)
            {
                delete m_ppChildren;
                m_ppChildren = 0;
            }
        }

        m_nChildren = nChildren;

		// If we contain no children and we're not a function, we should be removed.
        if(m_nChildren == 0 && m_eType != c_Function)
            return true;

		// Return whether we don't contain the function or not.
        return !ContainsFunction(szFunc);            
    }    

	// Return a string representing the HTML representation of this tree.
	char* GetHTML()
	{
		// Should only be called on root.
		assert(m_eType == c_Root);		

		// Initially reserve space for 64K of HTML.
		m_iAllocSize = 64 * 1024;
		if(m_szHTML)
			delete m_szHTML;

        m_szHTML = new char[m_iAllocSize];
        m_szHTML[0] = '\0';
        m_szCurrHTML = m_szHTML;
        m_szFencePost = &m_szHTML[m_iAllocSize - 2 * 1024];

		// Fill it with the HTML for this node and all child nodes.
		WriteHTML();		

		char* szRet = m_szHTML;
		
		m_szHTML = 0;
		
		return szRet;
	}

	// Remove all children from this node.
    void RemoveChildren()
    {
		assert(m_eType < 50);
        while(m_nChildren)
        {
            delete m_ppChildren[m_nChildren-1];
            m_ppChildren[m_nChildren-1] = 0;
            m_nChildren--;
        }
        if(m_ppChildren)
            delete m_ppChildren;

        m_ppChildren = 0;
		assert(m_eType < 50);
    }

	// Insert a new child.
    void InsertChild(CTreeNode* pNew)
    {
        assert(pNew);
		assert(pNew->m_eType < 50);
        m_nChildren++;
        CTreeNode** pNewList = new CTreeNode*[m_nChildren];
        
        if(m_ppChildren)
        {
            memcpy(pNewList, m_ppChildren, (m_nChildren-1)*sizeof(CTreeNode*));
            delete m_ppChildren;
        }
        m_ppChildren = pNewList;
        m_ppChildren[m_nChildren-1] = pNew;
		assert(m_eType < 50);
    }
};

// Define the static members of CTreeNode
int CTreeNode::m_iCurrDiv = 0;
int CTreeNode::m_iCurrTab = 0;
int CTreeNode::m_iAllocSize = 0;
char* CTreeNode::m_szHTML = 0;
char* CTreeNode::m_szCurrHTML = 0;
char* CTreeNode::m_szFencePost = 0;

// Global tree info.
CTreeNode g_InfoTreeRoot;

// Return true if name matches search string, false otherwise.
bool MatchName(char* szString, char* szSearchIn)
{
	if(strcmp(szSearchIn, "*") == 0)
		return true;

    char* szSearch = szSearchIn;
	while(*szSearch != '\0' && *szString != '\0')
	{
		// If we get a ?, we don't care and move on to the next
		// character.
		if(*szSearch == '?')
		{
			szSearch++;
			szString++;
			continue;
		}

		// If we have a wildcard, move to next search string and search for substring
		if(*szSearch == '*')
		{
			char* szCurrSearch;
			szSearch++;

			if(*szSearch == '\0')
				return true;

			// Don't change starting point.
			szCurrSearch = szSearch;
			for(;;)
			{
				// We're done if we hit another wildcard
				if(*szCurrSearch == '*' ||
					*szCurrSearch == '?')
				{
					// Update the permanent search position.
					szSearch = szCurrSearch;
					break;
				}
				// At end of both strings, return true.
				if((*szCurrSearch == '\0') && (*szString == '\0'))
					return true;

				// We never found it
				if(*szString == '\0')						
					return false;

				// If it doesn't match, start over
				if(toupper(*szString) != toupper(*szCurrSearch))
				{
					// If mismatch on first character
					// of search string, move to next
					// character in function string.
					if(szCurrSearch == szSearch)
						szString++;
					else
						szCurrSearch = szSearch;
				}
				else
				{
					szString++;
					szCurrSearch++;
				}
			}
		}
		else
		{
			if(toupper(*szString) != toupper(*szSearch))
			{
				return false;
			}

			szString++;
			szSearch++;
		}
	}

	if((*szString == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
		return true;
	else
		return false;
}

// Add all functions from a module to the tree.
void BuildFunctions(long lParentID, CTreeNode* pParent, _ConnectionPtr pConn)
{
    _RecordsetPtr pFunctions = 0;
    pFunctions.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];

	// Open a recordset of all functions that match
    wsprintf(szQuery, "SELECT * FROM FUNCTIONS WHERE MODULEID = %d", lParentID);    
        
    pFunctions->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);


	// Bind the record set to a local structure.
    IADORecordBinding* pRBFunctions = 0;
    HRESULT hr = pFunctions->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBFunctions));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SFunctionRecord fr;

    hr = pRBFunctions->BindToRecordset(&fr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

	// Go through each record in the set
    VARIANT_BOOL fEOF;
    pFunctions->get_EndOfFile(&fEOF);
    while(!fEOF)
    {		
		// Create a new node.
        CTreeNode* pNewNode = new CTreeNode(fr);
        pParent->InsertChild(pNewNode);        
                
        pFunctions->MoveNext();
        pFunctions->get_EndOfFile(&fEOF);
    }

    pFunctions->Close();

    SafeRelease(pRBFunctions);
}


// Add all modules to the tree.
void BuildModules(long lParentID, CTreeNode* pParent, bool fTopLevel,
                  _ConnectionPtr pConn, HANDLE hEvent)
{
	// Check if we should termiante early.
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pModules = 0;
    pModules.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];
    
	// Get recordset that matches
    if(fTopLevel)
        wsprintf(szQuery, "SELECT * FROM MODULES WHERE PTOLEMYID = %d", lParentID);
    else
        wsprintf(szQuery, "SELECT * FROM MODULES WHERE PARENTID = %d", lParentID);

        
    pModules->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);


    IADORecordBinding* pRBModules = 0;
    HRESULT hr = pModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBModules));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SModuleRecord mr;

    hr = pRBModules->BindToRecordset(&mr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

	// Go through each record
    VARIANT_BOOL fEOF;
    pModules->get_EndOfFile(&fEOF);
    while(!fEOF)
    {
		// Insert into tree
        CTreeNode* pNewNode = new CTreeNode(mr);
        pParent->InsertChild(pNewNode);

		// Build all child modules
        BuildModules(mr.ModuleID, pNewNode, false, pConn, hEvent);

		// Build all functions
        BuildFunctions(mr.ModuleID, pNewNode, pConn);
                
        pModules->MoveNext();
        pModules->get_EndOfFile(&fEOF);
    }

    pModules->Close();

    SafeRelease(pRBModules);
}

// Add a project to the tree
void BuildProjects(long PtolemyID, char* szFunc, _ConnectionPtr pConn, HANDLE hEvent)
{
    assert(PtolemyID > 0);

	// Check if we should terminate early
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pProjects = 0;
    pProjects.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];   
    
	// Get a recordset that matches
    wsprintf(szQuery, "SELECT * FROM PROJECTS WHERE PTOLEMYID = %d", PtolemyID);
    
    pProjects->Open(szQuery, variant_t((IDispatch*)pConn, true),adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBProjects = 0;
    HRESULT hr = pProjects->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBProjects));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SProjectRecord pr;

    hr = pRBProjects->BindToRecordset(&pr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

    VARIANT_BOOL fEOF;
    pProjects->get_EndOfFile(&fEOF);
    while(!fEOF)
    {
		// Insert the node at the root.
        CTreeNode* pNewNode = new CTreeNode(pr);
        g_InfoTreeRoot.InsertChild(pNewNode);

		// Get all child modules
        BuildModules(pr.PtolemyID, pNewNode, true, pConn, hEvent);

		// Save memory by trimming tree now.
        pNewNode->Prune(szFunc);        
                
        pProjects->MoveNext();
        pProjects->get_EndOfFile(&fEOF);
    }

    pProjects->Close();

    SafeRelease(pRBProjects);
}

long GetModulePtolemy(long lModuleID, _ConnectionPtr pConn)
{
    _RecordsetPtr pModules = 0;
    pModules.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];

	// Get a single record recordset containing the module.
    wsprintf(szQuery, "SELECT * FROM MODULES WHERE MODULEID = %d", lModuleID);
        
    pModules->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBModules = 0;
    HRESULT hr = pModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBModules));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SModuleRecord mr;

    hr = pRBModules->BindToRecordset(&mr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);
    

	// Either return ptolemy ID, if valid, otherwise call on parent module.
    long lParent = mr.ParentID;
    if(mr.ParentIDStatus != adFldNull)
    {
        pModules->Close();
        SafeRelease(pRBModules);        
        return GetModulePtolemy(lParent, pConn);
    }
    else
    {
        pModules->Close();
        SafeRelease(pRBModules);        
        return lParent;
    }
}
    
long GetFuncPtolemy(SFunctionRecord fr, _ConnectionPtr pConn)
{
    return GetModulePtolemy(fr.ModuleID, pConn);
}

// Build a list projects that contain a function that matches szFunc.
void BuildProjectsFromFunction(char* szFunc, _ConnectionPtr pConn, HANDLE hEvent)
{
	// Check if we should terminate early.
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pFunctions = 0;
    pFunctions.CreateInstance(__uuidof(Recordset));
    char* szQuery = "SELECT * FROM FUNCTIONS";   
    
    pFunctions->Open(szQuery, variant_t((IDispatch*)pConn, true),adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBFunctions = 0;
    HRESULT hr = pFunctions->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBFunctions));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SFunctionRecord fr;

    hr = pRBFunctions->BindToRecordset(&fr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

    VARIANT vtBookMark;
    hr = pFunctions->get_Bookmark(&vtBookMark);
    if(FAILED(hr))
        APError("Unable to get recordset bookmark", hr);

	// Do a search for the function
    char szFind[512];
	int FunctionList[1024] = {0};
    wsprintf(szFind, "Name like \'%s\'", szFunc);
    pFunctions->Find(szFind, 0, adSearchForward, vtBookMark);	
    while(!pFunctions->EndOfFile)
    {

        // Get which module imports this function
        long lPtolemy = GetFuncPtolemy(fr, pConn);
        assert(lPtolemy > 0);
        
		// Make sure we haven't already touched this module.
		bool fInUse = false;
		for(int i = 0; i < 1024; i++)
		{
			if(FunctionList[i] == 0)
			{
				FunctionList[i] = lPtolemy;
				break;
			}
			else if(FunctionList[i] == lPtolemy)
			{
				fInUse = true;
			}			
		}
		if(!fInUse)
			BuildProjects(lPtolemy, szFunc, pConn, hEvent);

        hr = pFunctions->get_Bookmark(&vtBookMark);
        if(FAILED(hr))
            APError("Unable to acquire recordset bookmark", hr);
        pFunctions->Find(szFind, 1, adSearchForward, vtBookMark);
    }
    
    SafeRelease(pRBFunctions);
    pFunctions->Close();
}

STDMETHODIMP CAppParse::QueryDB(long PtolemyID, BSTR bstrFunction)
{
	assert(m_hEvent);

    try
    {
		// Start cancelation dialog
		ResetEvent(m_hEvent);
        InitProgressDialog("Querying database . . .", m_hEvent);
        
		bstr_t bszFunctionSearch = bstrFunction;
        
        char* szFunctionSearch = static_cast<char*>(bszFunctionSearch);    

        HRESULT hr;

        _ConnectionPtr pConn = 0;
    
        pConn.CreateInstance(__uuidof(Connection));

		// Connect to the DB
        pConn->Open(m_szConnect, "","", adConnectUnspecified);
		
		// Build projects
        if(PtolemyID > 0)
            BuildProjects(PtolemyID, szFunctionSearch, pConn, m_hEvent);
        else
            BuildProjectsFromFunction(szFunctionSearch, pConn, m_hEvent);

        pConn->Close();

		// Check if results should be shown.
        if(WaitForSingleObject(m_hEvent, 0) == WAIT_OBJECT_0)
		{
			g_InfoTreeRoot.RemoveChildren();
			KillProgressDialog();
			return S_OK;
		}

		// Trim the tree down.
        g_InfoTreeRoot.Prune(szFunctionSearch);

		// Get our container document.
        CComPtr<IOleContainer> pContainer = 0;

        m_spClientSite->GetContainer(&pContainer);
        CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc(pContainer);
        if(!pDoc)       
			APError("Unable to acquire container HTML document", E_FAIL);

        CComPtr<IHTMLElementCollection> pElements;
        pDoc->get_all(&pElements);
        CComPtr<IDispatch> pDispatch = 0;

		// Get the element that will contain all HTML output (the "Results" DIV)
        hr = pElements->item(variant_t("Results"), variant_t(0L), &pDispatch);

        if(FAILED(hr) || !pDispatch)
            return E_FAIL;
        
        CComQIPtr<IHTMLElement, &IID_IHTMLElement> pDivElem(pDispatch);
                   
		// Get HTML representation of tree.
        char* szHTML = g_InfoTreeRoot.GetHTML();

		// Convert to wide characters
        OLECHAR* oszInnerHTML = new OLECHAR[strlen(szHTML) + 1];

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szHTML, 
            -1, oszInnerHTML,
            (strlen(szHTML)+1)*sizeof(OLECHAR));

		delete szHTML;

		// Convert to a BSTR
        BSTR bszInnerHTML = SysAllocString(oszInnerHTML);
        delete oszInnerHTML;

		// Write the HTML into the document.
        hr = pDivElem->put_innerHTML(bszInnerHTML);
        if(FAILED(hr))
            APError("Unable to write HTML to container document", hr);
        
        SysFreeString(bszInnerHTML);
    }
    catch(_com_error& e)
    {       
        ::MessageBox(0, (LPCSTR)e.ErrorMessage(), "COM Error", MB_OK);
    }

    g_InfoTreeRoot.RemoveChildren();
    KillProgressDialog();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avglobal.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVGlobal.h
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//  Global data declaration.
//

#ifndef __APP_VERIFIER_GLOBAL_H__
#define __APP_VERIFIER_GLOBAL_H__

//
// Application name ("Application Verifier Manager")
//

extern CString g_strAppName;

//
// GUI mode or command line mode?
//

extern BOOL g_bCommandLineMode;

//
// Exe module handle - used for loading resources
//

extern HMODULE g_hProgramModule;

//
// Help file name
//

extern TCHAR g_szAVHelpFile[];

//
// Previous page IDs - used for implementing the "back"
// button functionality
//

extern CDWordArray g_aPageIds;

/////////////////////////////////////////////////////////////////////////////
BOOL AVInitalizeGlobalData();


#endif //#ifndef __APP_VERIFIER_GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avglobal.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVGlobal.cpp
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//  Global data and initialization code
//

#include "stdafx.h"
#include "appverif.h"

#include "AVGlobal.h"
#include "AVUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Application name ("Application Verifier Manager")
//

CString g_strAppName;

//
// GUI mode or command line mode?
//

BOOL g_bCommandLineMode = FALSE;

//
// Exe module handle - used for loading resources
//

HMODULE g_hProgramModule;

//
// Help file name
//

TCHAR g_szAVHelpFile[] = _T( "appverif.hlp" );;

//
// Previous page IDs - used for implementing the "back"
// button functionality
//

CDWordArray g_aPageIds;


////////////////////////////////////////////////////////////////
BOOL AVInitalizeGlobalData( VOID )
{
    BOOL bSuccess;

    bSuccess = FALSE;

    //
    // Exe module handle - used for loading resources
    //

    g_hProgramModule = GetModuleHandle( NULL );

    //
	// Load the app name from the resources
	//

	TRY
	{
		bSuccess = AVLoadString( IDS_APPTITLE,
                                  g_strAppName );

		if( TRUE != bSuccess )
		{
			AVErrorResourceFormat( IDS_CANNOT_LOAD_APP_TITLE );
		}
	}
	CATCH( CMemoryException, pMemException )
	{
		AVErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
	}
    END_CATCH

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avpage.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VerfPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//  
// Common parent for all our wizard property page classes
//

#include "stdafx.h"
#include "appverif.h"

#include "AVPage.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAppverifPage property page

IMPLEMENT_DYNAMIC(CAppverifPage, CPropertyPage)

CAppverifPage::CAppverifPage(ULONG uDialogId) : 
    CPropertyPage( uDialogId )
{
	//{{AFX_DATA_INIT(CAppverifPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pParentSheet = NULL;
}

CAppverifPage::~CAppverifPage()
{
}

BEGIN_MESSAGE_MAP(CAppverifPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAppverifPage)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CAppverifPage::GetDialogId() const
{ 
    //
    // Oops, how did we get here ?!?
    // This is a virtual pure function.
    //

    //ASSERT( FALSE ); 

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Return the previous page ID, based on our history array
// and remove it from the array because will activate. Called
// by our property pages when the "back" button is clicked
//

ULONG CAppverifPage::GetAndRemovePreviousDialogId()
{
    ULONG uPrevId;
    INT_PTR nCrtWizardStep;

    nCrtWizardStep = g_aPageIds.GetSize();

    ASSERT( nCrtWizardStep > 0 );

    uPrevId = g_aPageIds.GetAt( nCrtWizardStep - 1 );

    g_aPageIds.RemoveAt( nCrtWizardStep - 1 ); 

    return uPrevId;
}

/////////////////////////////////////////////////////////////////////////////
//
// Property pages derived from this class should notify us 
// whenever we go to a next page to record the current page ID in 
// the global array g_aPageIds
//

VOID CAppverifPage::GoingToNextPageNotify( LRESULT lNextPageId )
{
    ULONG uMyDialogId;

    if( -1 != lNextPageId )
    {
        //
        // Will go to the next page. Add our ID to the global IDs array 
        // used for implementing the "back" button functionality.
        //

        uMyDialogId = GetDialogId();

        ASSERT( ( 0 == g_aPageIds.GetSize() ) || ( uMyDialogId != g_aPageIds.GetAt( g_aPageIds.GetSize() - 1 ) ) );

        g_aPageIds.Add( uMyDialogId );
    }
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CAppverifPage::OnWizardBack() 
{
    return GetAndRemovePreviousDialogId();
}

/////////////////////////////////////////////////////////////////////////////
// CAppverifPage message handlers

BOOL CAppverifPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avpage.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVPage.h
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// Common parent for all our wizard property page classes
//

#if !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
#define AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AVPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppverifPage dialog

class CAppverifPage : public CPropertyPage
{
    DECLARE_DYNAMIC(CAppverifPage)

// Construction
public:
	CAppverifPage( ULONG uDialogId );
	~CAppverifPage();

public:
    VOID SetParentSheet( CPropertySheet *pParentSheet ) 
    { 
        m_pParentSheet = pParentSheet; 
    };

protected:
    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const = 0;

    //
    // Return the previous page ID, based on our history array
    // and remove it from the array because will activate. Called
    // by our property pages when the "back" button is clicked
    //

    ULONG GetAndRemovePreviousDialogId();

    //
    // Property pages derived from this class should notify us 
    // whenever we go to a next page to record the current page ID in 
    // the global array m_aPageIds
    //

    VOID GoingToNextPageNotify( LRESULT lNextPageId );

protected:
    //
    // Data
    //
    
    CPropertySheet      *m_pParentSheet;

    //
    // Overrides
    //

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CAppverifPage)
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAppverifPage)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avsheet.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVSheet.h
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//  Property sheet class.
//

#if !defined(AFX_AVSHEET_H__F86AAFC4_97F7_4D59_A3B2_317B4506E5C7__INCLUDED_)
#define AFX_AVSHEET_H__F86AAFC4_97F7_4D59_A3B2_317B4506E5C7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TaskPage.h"
#include "SelApp.h"
#include "ChooseExe.h"
#include "Options.h"
#include "StartApp.h"
#include "ViewLog.h"
#include "ViewSett.h"

/////////////////////////////////////////////////////////////////////////////
// CAppverifSheet property sheet

class CAppverifSheet : public CPropertySheet
{
// Construction
public:
    CAppverifSheet();   

protected:

    VOID HideHelpButton();

protected:
    HICON m_hIcon;

    CTaskPage           m_TaskPage;
    CSelectAppPage      m_SelectAppPage;
    CChooseExePage      m_ChooseExePage;
    COptionsPage        m_OptionsPage;
    CStartAppPage       m_StartAppPage;
    CViewLogPage        m_ViewLogPage;
    CViewSettPage       m_ViewSettPage;

    //
    // Dialog Data
    //

    //{{AFX_DATA(CAppverifSheet)
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAppverifSheet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAppverifSheet)
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AVSHEET_H__F86AAFC4_97F7_4D59_A3B2_317B4506E5C7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\chooseexe.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.h
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Choose an executable to run" wizard page class.
//

#if !defined(AFX_CHOOSEEXE_H_INCLUDED_)
#define AFX_CHOOSEEXE_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"

extern DWORD        g_dwRegFlags;
extern TCHAR        g_szAppFullPath[];
extern TCHAR        g_szAppShortName[];
extern TCHAR        g_szCrashDumpFile[];
extern BOOL         g_bDebuggeeExited;
extern BOOL         g_bStandardSettings;

/////////////////////////////////////////////////////////////////////////////
// CChooseExePage dialog

class CChooseExePage : public CAppverifPage
{
    DECLARE_DYNCREATE(CChooseExePage)

// Construction
public:
    CChooseExePage();
    ~CChooseExePage();

protected:

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CChooseExePage)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Dialog Data
    //{{AFX_DATA(CChooseExePage)
    enum { IDD = IDD_CHOOSEEXE_PAGE };
    CEdit       m_ExeName;
    int         m_nIndSettings;
	CStatic	    m_NextDescription;
    //}}AFX_DATA



protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CChooseExePage)
    virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnChooseExe();
    afx_msg void OnChangeExeName();
	afx_msg void OnUpdateNextDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSEEXE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avutil.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVUtil.h
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//

#ifndef __APP_VERIFIER_UTIL_H__
#define __APP_VERIFIER_UTIL_H__

///////////////////////////////////////////////////////////////////////////
//
// ARRAY_LENGTH macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array )   ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH


///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl AVErrorResourceFormat( UINT uIdResourceFormat,
                                     ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl AVTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void AVPrintStringFromResources( UINT uIdString );

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void AVMesssageFromResource( UINT uIdString );

///////////////////////////////////////////////////////////////////////////
//
// Display a message box with a message from the resources.
//

INT AVMesssageBoxFromResource( UINT uIdString,
                               UINT uMsgBoxType );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL AVLoadString( ULONG uIdResource,
                   TCHAR *szBuffer,
                   ULONG uBufferLength );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL AVLoadString( ULONG uIdResource,
                   CString &strText );

/////////////////////////////////////////////////////////////////////////////
BOOL AVSetWindowText( CWnd &Wnd,
                      ULONG uIdResourceString );


/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger( LPCTSTR String,
                    IN ULONG Base OPTIONAL,
                    OUT PULONG Value );

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue );


#endif //#ifndef __APP_VERIFIER_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avutil.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVGlobal.cpp
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//

#include "stdafx.h"
#include "appverif.h"

#include "AVUtil.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl AVErrorResourceFormat( UINT uIdResourceFormat,
                                     ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    //
    // Load the format string from the resources
    //

    bResult = AVLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        if( g_bCommandLineMode )
        {
            //
            // Command console mode
            //

            _putts( szMessage );
            
            TRACE( _T( "%s\n" ), szMessage );
        }
        else
        {
            //
            // GUI mode
            //

            AfxMessageBox( szMessage, 
                           MB_OK | MB_ICONSTOP );
        }

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl AVTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    ASSERT( g_bCommandLineMode );

    //
    // Load the format string from the resources
    //

    bResult = AVLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        _putts( szMessage );

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void AVPrintStringFromResources( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    ASSERT( g_bCommandLineMode );

    VERIFY( AVLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    _putts( szMessage );
}

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void AVMesssageFromResource( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    VERIFY( AVLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    if( g_bCommandLineMode )
    {
        //
        // Command console mode
        //

        _putts( szMessage );
    }
    else
    {
        //
        // GUI mode
        //

        AfxMessageBox( szMessage, 
                       MB_OK | MB_ICONINFORMATION );
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Display a message box with a message from the resources.
//

INT AVMesssageBoxFromResource( UINT uIdString,
                               UINT uMsgBoxType )
{
    TCHAR szMessage[ 256 ];

    VERIFY( AVLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    ASSERT( FALSE == g_bCommandLineMode );

    //
    // GUI mode
    //

    return AfxMessageBox( szMessage, 
                          uMsgBoxType );
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL AVLoadString( ULONG uIdResource,
                    TCHAR *szBuffer,
                    ULONG uBufferLength )
{
    ULONG uLoadStringResult;

    if( uBufferLength < 1 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    uLoadStringResult = LoadString (
        g_hProgramModule,
        uIdResource,
        szBuffer,
        uBufferLength );

    //
    // We should never try to load non-existent strings.
    //

    ASSERT (uLoadStringResult > 0);

    return (uLoadStringResult > 0);
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL AVLoadString( ULONG uIdResource,
                    CString &strText )
{
    TCHAR szText[ 256 ];
    BOOL bSuccess;

    bSuccess = AVLoadString( uIdResource,
                          szText,
                          ARRAY_LENGTH( szText ) );

    if( TRUE == bSuccess )
    {
        strText = szText;
    }
    else
    {
        strText = "";
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL AVSetWindowText( CWnd &Wnd,
                       ULONG uIdResourceString )
{
    BOOL bLoaded;
    CString strText;

    //
    // It's safe to use CString::LoadString here because we are 
    // in GUI mode
    //

    ASSERT( FALSE == g_bCommandLineMode );

    bLoaded = strText.LoadString( uIdResourceString );

    ASSERT( TRUE == bLoaded );

    Wnd.SetWindowText( strText );

    return ( TRUE == bLoaded );
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger( LPCTSTR String,
                    IN ULONG Base OPTIONAL,
                    OUT PULONG Value )
{
    TCHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= _T( ' ' )) {
        if (!*String) {
            String--;
            break;
            }
        }

    c = Sign;
    if (c == _T( '-' ) || c == _T( '+' ) ) {
        c = *String++;
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)(Base) )) {
        Base = 10;
        Shift = 0;
        if (c == _T( '0' ) ) {
            c = *String++;
            if (c == _T( 'x' ) ) {
                Base = 16;
                Shift = 4;
                }
            else
            if (c == _T( 'o' ) ) {
                Base = 8;
                Shift = 3;
                }
            else
            if (c == _T( 'b' ) ) {
                Base = 2;
                Shift = 1;
                }
            else {
                String--;
                }

            c = *String++;
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return FALSE;
            }
        }

    Result = 0;
    while (c) {
        if (c >= _T( '0' ) && c <= _T( '9' ) ) {
            Digit = c - '0';
            }
        else
        if (c >= _T( 'A' ) && c <= _T( 'F' ) ) {
            Digit = c - 'A' + 10;
            }
        else
        if (c >= _T( 'a' ) && c <= _T( 'f' ) ) {
            Digit = c - _T( 'a' ) + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *String++;
        }

    if (Sign == _T( '-' ) ) {
        Result = (ULONG)(-(LONG)Result);
        }

    *Value = Result;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue )
{
    LONG lResult;
    TCHAR szValue[ 32 ];

    _stprintf(
        szValue,
        _T( "0x%08X" ),
        dwValue );

    lResult = RegSetValueEx( 
        hKey,
        szValueName,
        0,
        REG_SZ,
        (BYTE *)szValue,
        _tcslen( szValue ) * sizeof( TCHAR ) + sizeof( TCHAR ) );

    return ( lResult == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\avsheet.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: AVSheet.cpp
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//  Property sheet class.
//

#include "stdafx.h"
#include "appverif.h"

#include "AVSheet.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAppverifSheet property sheet

CAppverifSheet::CAppverifSheet()
    : CPropertySheet(IDS_APPTITLE)
{
    //{{AFX_DATA_INIT(CAppverifSheet)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    
    m_TaskPage.SetParentSheet( this );
    m_SelectAppPage.SetParentSheet( this );
    m_ChooseExePage.SetParentSheet( this );
    m_OptionsPage.SetParentSheet( this );
    m_StartAppPage.SetParentSheet( this );
    m_ViewLogPage.SetParentSheet( this );
    m_ViewSettPage.SetParentSheet( this );

    m_TaskPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_SelectAppPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_ChooseExePage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_OptionsPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_StartAppPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_ViewLogPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_ViewSettPage.m_psp.dwFlags &= ~PSH_HASHELP;

    m_psh.dwFlags &= ~PSH_HASHELP;
    //m_psh.dwFlags |= PSH_WIZARDCONTEXTHELP;

    AddPage( &m_TaskPage );
    AddPage( &m_SelectAppPage );
    AddPage( &m_ChooseExePage );
    AddPage( &m_OptionsPage );
    AddPage( &m_StartAppPage );
    AddPage( &m_ViewLogPage );
    AddPage( &m_ViewSettPage );
    
    SetWizardMode();

    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CAppverifSheet::DoDataExchange(CDataExchange* pDX)
{
    CPropertySheet::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAppverifSheet)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppverifSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CAppverifSheet)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CAppverifSheet::HideHelpButton()
{
    INT xDelta;
    CRect rect1;
    CRect rect2;
    CWnd *pButton;

    //
    // Help button
    //

    pButton = GetDlgItem( IDHELP );

    if( NULL == pButton )
    {
        //
        // No help button?!?
        //

        goto Done;
    }

    pButton->ShowWindow( SW_HIDE );

    pButton->GetWindowRect( &rect1 );
    ScreenToClient( &rect1 );

    //
    // Cancel button
    //

    pButton = GetDlgItem( IDCANCEL );

    if( NULL == pButton )
    {
        //
        // No Cancel button?!?
        //

        goto Done;
    }

    pButton->GetWindowRect( &rect2 );
    ScreenToClient( &rect2 );

    xDelta = rect1.left - rect2.left;
    
    rect2.OffsetRect( xDelta, 0 );
    pButton->MoveWindow( rect2 );

    //
    // Back button
    //

    pButton = GetDlgItem( ID_WIZBACK );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Next button
    //

    pButton = GetDlgItem( ID_WIZNEXT );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Finish button
    //

    pButton = GetDlgItem( ID_WIZFINISH );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
// CAppverifSheet message handlers

BOOL CAppverifSheet::OnInitDialog()
{
    CPropertySheet::OnInitDialog();

    //
    // Add "About..." menu item to system menu.
    //

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    //
    // Set the icon for this dialog.  The framework does this automatically
    // when the application's main window is not a dialog.
    //

    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    
    //
    // Hide the big Help button - NT keeps creating it even if we
    // have specified ~PSH_HASHELP
    //

    HideHelpButton();

    //
    // Add the context sensitive button to the titlebar
    //

//    LONG lStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
//    lStyle |= WS_EX_CONTEXTHELP;
//    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, lStyle);


    return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
void CAppverifSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        ShellAbout( m_hWnd, 
                    (LPCTSTR)g_strAppName, 
                    NULL, 
                    m_hIcon );
    }
    else
    {
        CPropertySheet::OnSysCommand(nID, lParam);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
//

void CAppverifSheet::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CPropertySheet::OnPaint();
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
//

HCURSOR CAppverifSheet::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CAppverifSheet::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}

/////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\cmdline.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: CmdLine.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//
// Command line support
//

#include "stdafx.h"
#include "appverif.h"

#include "CmdLine.h"
#include "AVUtil.h"
#include "Setting.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
VOID CmdLinePrintHelpInformation()
{
    AVTPrintfResourceFormat( IDS_HELP_LINE1, VER_PRODUCTVERSION_STR );

    puts( VER_LEGALCOPYRIGHT_STR );

    AVPrintStringFromResources( IDS_HELP_LINE3 );
    AVPrintStringFromResources( IDS_HELP_LINE4 );
    AVPrintStringFromResources( IDS_HELP_LINE5 );
    AVPrintStringFromResources( IDS_HELP_LINE6 );
    AVPrintStringFromResources( IDS_HELP_LINE7 );
    AVPrintStringFromResources( IDS_HELP_LINE8 );
    AVPrintStringFromResources( IDS_HELP_LINE9 );
    AVPrintStringFromResources( IDS_HELP_LINE10 );
    AVPrintStringFromResources( IDS_HELP_LINE11 );
    AVPrintStringFromResources( IDS_HELP_LINE12 );
}

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked for help and print out the help strings
// 

BOOL CmdLineExecuteIfHelp( INT argc, 
                           TCHAR *argv[] )
{
    BOOL bPrintedHelp;
    TCHAR szCmdLineSwitch[ 64 ];

    bPrintedHelp = FALSE;

    VERIFY( AVLoadString( IDS_HELP_CMDLINE_SWITCH,
                          szCmdLineSwitch,
                          ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for help switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[ 1 ], szCmdLineSwitch) == 0)
    {
        CmdLinePrintHelpInformation();

        bPrintedHelp = TRUE;
    }

    return bPrintedHelp;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuerySettings( INT argc,
                                    TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    TCHAR szCmdLineSwitch[ 64 ];

    bFoundCmdLineSwitch = FALSE;

    VERIFY( AVLoadString( IDS_QUERYSETT_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for our switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[1], szCmdLineSwitch) == 0)
    {
        bFoundCmdLineSwitch = TRUE;

        AVDumpRegistrySettingsToConsole();
    }

    return bFoundCmdLineSwitch;
}

/////////////////////////////////////////////////////////////////////////////
VOID CmdLineGetFlagsAppsReset( INT argc,
                               TCHAR *argv[],
                               DWORD &dwNewFlags,
                               CStringArray &astrNewApps,
                               BOOL &bHaveReset )
{
    INT nCrtArg;
    INT nCrtVerifierFlag;
    BOOL bThisIsAppName;
    TCHAR szResetCmdLineOption[ 64 ];
    TCHAR szReservedCmdLineOption[ 64 ];

    dwNewFlags = 0;

    //
    // Load the switches from the resources
    //

    VERIFY( AVLoadString( IDS_RESET_CMDLINE_SWITCH,
                           szResetCmdLineOption,
                           ARRAY_LENGTH( szResetCmdLineOption ) ) );

    //
    // Parse all the cmd line arguments, looking for ours
    //

    for( nCrtArg = 1; nCrtArg < argc; nCrtArg += 1 )
    {
        bThisIsAppName = TRUE;

        if( _tcsicmp( argv[ nCrtArg ], szResetCmdLineOption ) == 0 )
        {
            //
            // Have /reset
            //

            bHaveReset = TRUE;

            bThisIsAppName = FALSE;
        }
        else
        {
            for( nCrtVerifierFlag = 0; nCrtVerifierFlag < ARRAY_LENGTH( g_AllNamesAndBits ); nCrtVerifierFlag += 1 )
            {
                //
                // Load the cmd line argument reserved for this bit
                //

                VERIFY( AVLoadString( g_AllNamesAndBits[ nCrtVerifierFlag ].m_uCmdLineStringId,
                                       szReservedCmdLineOption,
                                       ARRAY_LENGTH( szReservedCmdLineOption ) ) );

                if( _tcsicmp( argv[ nCrtArg ], szReservedCmdLineOption ) == 0 )
                {
                    //
                    // Enable this bit since we found it in the cmd line
                    //

                    dwNewFlags |= g_AllNamesAndBits[ nCrtVerifierFlag ].m_dwBit;

                    bThisIsAppName = FALSE;
                }
            }
        }

        //
        // If the current cmd line arg is not a reserve one consider it's an app name
        //

        if( FALSE != bThisIsAppName )
        {
            astrNewApps.Add( argv[ nCrtArg ] );
        }
    }

    if( 0 == dwNewFlags )
    {
        //
        // If the user didn't specify any flags we will 
        // enable all the standard checks
        //

        dwNewFlags = AV_ALL_STANDARD_VERIFIER_FLAGS;
    }
}

/////////////////////////////////////////////////////////////////////////////
DWORD CmdLineExecute( INT argc, TCHAR *argv[] )
{
    DWORD dwExitCode;
    BOOL bFoundCmdLineSwitch;
    BOOL bHaveReset;
    DWORD dwNewFlags;
    INT_PTR nAppsNo;
    INT_PTR nCrtApp;
    CStringArray astrNewApps;

    dwExitCode = AV_EXIT_CODE_SUCCESS;
    
    //
    // See if the user asked for help
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfHelp( argc,
                                                argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done printing out the help strings
        //

        goto Done;
    }

    //
    // See if the user asked to dump the current registry settings 
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfQuerySettings( argc,
                                                         argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done with the settings query
        //

        goto Done;
    }

    //
    // Get the new flags and apps if they have been specified
    //

    bHaveReset = FALSE;

    CmdLineGetFlagsAppsReset(
        argc,
        argv,
        dwNewFlags,
        astrNewApps,
        bHaveReset );

    //
    // Transform our array of names in the global g_NewSettings data
    //

    g_NewSettings.m_SettingsType = AVSettingsTypeCustom;

    nAppsNo = astrNewApps.GetSize();

    for( nCrtApp = 0; nCrtApp < nAppsNo; nCrtApp += 1 )
    {
        g_NewSettings.m_aApplicationData. AddNewAppDataConsoleMode( astrNewApps.GetAt( nCrtApp ),
                                                                    dwNewFlags );                              
    }

    //
    // Save the new settings. 
    //
    // If bHaveReset is set to TRUE the old app verifier settings for 
    // apps not mentioned in this command line will be deleted.
    //

    if( AVSaveNewSettings( bHaveReset ) )
    {
        dwExitCode = AV_EXIT_CODE_RESTART;
    }
    else
    {
        dwExitCode = AV_EXIT_CODE_ERROR;
    }

Done:

    return dwExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\chooseexe.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.cpp
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Select individual tests" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "ChooseExe.h"
#include "AVUtil.h"
#include "AVGlobal.h"
#include "Setting.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


TCHAR  g_szAppFullPath[MAX_PATH];
TCHAR  g_szAppShortName[MAX_PATH];

BOOL   g_bStandardSettings;


//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CChooseExePage property page

IMPLEMENT_DYNCREATE(CChooseExePage, CAppverifPage)

CChooseExePage::CChooseExePage() : CAppverifPage(CChooseExePage::IDD)
{
    //{{AFX_DATA_INIT(CChooseExePage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nIndSettings = 0;
}

CChooseExePage::~CChooseExePage()
{
}

void CChooseExePage::DoDataExchange(CDataExchange* pDX)
{
    CAppverifPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChooseExePage)
    DDX_Control(pDX, IDC_EXE_NAME, m_ExeName);
    DDX_Radio(pDX, IDC_STANDARD_SETTINGS, m_nIndSettings);
    DDX_Control(pDX, IDC_CHOOSEEXE_NEXTDESCR_STATIC, m_NextDescription);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseExePage, CAppverifPage)
    //{{AFX_MSG_MAP(CChooseExePage)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_WM_CONTEXTMENU()
    ON_BN_CLICKED(IDC_BROWSE, OnChooseExe)
    ON_EN_CHANGE(IDC_EXE_NAME, OnChangeExeName)
	ON_BN_CLICKED(IDC_STANDARD_SETTINGS, OnUpdateNextDescription)
	ON_BN_CLICKED(IDC_ADVANCED_SETTINGS, OnUpdateNextDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CChooseExePage::GetDialogId() const
{
    return IDD_CHOOSEEXE_PAGE;
}

/////////////////////////////////////////////////////////////////////////////

void CChooseExePage::OnChooseExe() 
{
    TCHAR        szFilter[] = _T("Executable files (*.exe)\0*.exe\0");
    OPENFILENAME ofn;

    g_szAppFullPath[0] = 0;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = m_hWndTop;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = g_szAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = _T("Choose a program to run");
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("EXE");

    if ( !GetOpenFileName(&ofn) )
    {
        return;
    }

    m_ExeName.SetWindowText(g_szAppFullPath);
}

void CChooseExePage::OnChangeExeName() 
{
    if ( m_ExeName.GetWindowTextLength() == 0 )
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK );
    }
    else
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CChooseExePage message handlers

/////////////////////////////////////////////////////////////
LONG CChooseExePage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp(
             (HWND) lpHelpInfo->hItemHandle,
             g_szAVHelpFile,
             HELP_WM_HELP,
             (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CChooseExePage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp(
             pWnd->m_hWnd,
             g_szAVHelpFile,
             HELP_CONTEXTMENU,
             (DWORD_PTR) MyHelpIds );
}


/////////////////////////////////////////////////////////////////////////////
LRESULT CChooseExePage::OnWizardNext() 
{
    UpdateData(TRUE);
    
    LRESULT lNextPage = ( m_nIndSettings == 0 ? IDD_STARTAPP_PAGE : IDD_OPTIONS_PAGE );

    g_bStandardSettings = (m_nIndSettings == 0);

    if ( g_bStandardSettings )
    {
        g_dwRegFlags = AV_ALL_STANDARD_VERIFIER_FLAGS;
    }
    
    GoingToNextPageNotify( lNextPage );

    m_ExeName.GetWindowText( g_szAppFullPath, MAX_PATH );

    return lNextPage;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CChooseExePage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    if ( m_ExeName.GetWindowTextLength() == 0 )
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK );
    }
    else
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    }

    return CAppverifPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
void CChooseExePage::OnUpdateNextDescription() 
{
    UpdateData(TRUE);
    
    if ( m_nIndSettings == 0 )
    {
        AVSetWindowText( m_NextDescription, IDS_CHOOSEEXE_NEXTDESCR_RUNEXE_STATIC );
    }
    else
    {
        AVSetWindowText( m_NextDescription, IDS_CHOOSEEXE_NEXTDESCR_OPTIONS_STATIC );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CChooseExePage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    AVSetWindowText( m_NextDescription, IDS_CHOOSEEXE_NEXTDESCR_RUNEXE_STATIC );
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CChooseExePage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\cmdline.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: CmdLine.h
// author: DMihai
// created: 02/23/2001
//
// Description:
//  
//  Command line support
//

#ifndef __APP_VERIFIER_CMDLINE_H__
#define __APP_VERIFIER_CMDLINE_H__

#define AV_EXIT_CODE_SUCCESS    0
#define AV_EXIT_CODE_RESTART    1
#define AV_EXIT_CODE_ERROR      2

/////////////////////////////////////////////////////////////////////////////
DWORD CmdLineExecute( INT argc, TCHAR *agrv[] );

#endif //#ifndef __APP_VERIFIER_CMDLINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\dbsupport.h ===
#ifndef __APPVERIFIER_DBSUPPORT_H_
#define __APPVERIFIER_DBSUPPORT_H_


BOOL
AppCompatSaveSettings(
    CStringArray &astrExeNames
    );

BOOL
AppCompatDeleteSettings(
    void
    );

#endif // __APPVERIFIER_DBSUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\dbsupport.cpp ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dbsupport.cpp

    Abstract:

        

    Author:

        clupu     created     04/11/2001

    Revision History:

--*/

#include "stdafx.h"
#include "appverif.h"

#include "AVUtil.h"
#include "dbsupport.h"
#include "log.h"

char   g_szXML[2048];
TCHAR  g_szCmd[1024];

BOOL AppCompatSaveSettings( CStringArray &astrExeNames )
{
    char                szBuff[256]          = "";
    TCHAR               szTempPath[MAX_PATH] = _T("");
    TCHAR               szXmlFile[MAX_PATH]  = _T("");
    TCHAR               szSdbFile[MAX_PATH]  = _T("");
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               bytesWritten;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                bReturn = FALSE;
    INT_PTR             nCount;
    char                szExeName[128];

    nCount = astrExeNames.GetSize();

    if ( nCount == 0 )
    {
        return AppCompatDeleteSettings();
    }

    //
    // Check for shimdbc.exe
    //
    GetSystemWindowsDirectory(szTempPath, MAX_PATH);

    lstrcat(szTempPath, _T("\\shimdbc.exe"));

    hFile = CreateFile(szTempPath,
                       GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        AVMesssageFromResource( IDS_NO_SHIMDBC );
        return FALSE;
    }

    CloseHandle(hFile);

    //
    // Construct the XML...
    //
    lstrcpyA(g_szXML,
             "<?xml version=\"1.0\"?>\r\n"
             "<DATABASE NAME=\"Application Verifier Database\" ID=\"{448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}\">\r\n"
             "    <APP NAME=\"All EXEs to be verified\" VENDOR=\"Various\">\r\n");

    for ( INT_PTR i = 0; i < nCount; i++ )
    {

        //
        // Convert the EXE name to ANSI
        //
        WideCharToMultiByte(CP_ACP,
                            0,
                            (LPCTSTR)astrExeNames.GetAt(i),
                            -1,
                            szExeName,
                            128,
                            NULL,
                            NULL);

        wsprintfA(szBuff,
                  "        <EXE NAME=\"%s\">\r\n"
                  "            <LAYER NAME=\"AppVerifierLayer\"/>\r\n"
                  "        </EXE>\r\n",
                  szExeName);

        lstrcatA(g_szXML, szBuff);
    }

    lstrcatA(g_szXML,
             "    </APP>\r\n"
             "</DATABASE>");

    if ( GetTempPath(MAX_PATH, szTempPath) == 0 )
    {
        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] GetTempPath failed."));
        goto cleanup;
    }

    //
    // Obtain a temp name for the XML file
    //
    if ( GetTempFileName(szTempPath, _T("XML"), NULL, szXmlFile) == 0 )
    {
        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] GetTempFilePath for XML failed."));
        goto cleanup;
    }

    hFile = CreateFile(szXmlFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] CreateFile '%s' failed 0x%X."),
                   szXmlFile, GetLastError());
        goto cleanup;
    }

    if ( WriteFile(hFile, g_szXML, lstrlenA(g_szXML), &bytesWritten, NULL) == 0 )
    {
        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] WriteFile \"%s\" failed 0x%X."),
                   szXmlFile, GetLastError());
        goto cleanup;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    // Obtain a temp name for the SDB file
    //
    wsprintf(szSdbFile, _T("%stempdb.sdb"), szTempPath);

    DeleteFile(szSdbFile);

    //
    // Invoke the compiler to generate the SDB file
    //

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    wsprintf(g_szCmd, _T("shimdbc.exe fix -q \"%s\" \"%s\""), szXmlFile, szSdbFile);

    if ( !CreateProcess(NULL,
                        g_szCmd,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                        NULL,
                        NULL,
                        &si,
                        &pi) )
    {

        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X."),
                   g_szCmd, GetLastError());
        goto cleanup;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    //
    // The SDB file is generated. Install the database now.
    //
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    wsprintf(g_szCmd, _T("sdbinst.exe -q \"%s\""), szSdbFile);

    if ( !CreateProcess(NULL,
                        g_szCmd,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                        NULL,
                        NULL,
                        &si,
                        &pi) )
    {

        LogMessage(LOG_ERROR, _T("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X."),
                   g_szCmd, GetLastError());
        goto cleanup;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    bReturn = TRUE;

    cleanup:
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(hFile);
    }

    DeleteFile(szXmlFile);
    DeleteFile(szSdbFile);

    return bReturn;
}

BOOL AppCompatDeleteSettings( void )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szCmd[MAX_PATH];
    
    ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );

    lstrcpy( szCmd, _T("sdbinst.exe -q -u -g {448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}") );

    if ( !CreateProcess( NULL,
                         szCmd,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                         NULL,
                         NULL,
                         &si,
                         &pi) )
    {

        LogMessage(LOG_ERROR, _T("[AppCompatDeleteSettings] CreateProcess \"%s\" failed 0x%X."),
                   szCmd, GetLastError());
        return FALSE;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\debugger.h ===
#ifndef __APPVERIFIER_DEBUGGER_H_
#define __APPVERIFIER_DEBUGGER_H_

#define MAX_BREAKPOINTS     32
#ifdef _X86_
#define BP_INSTR            0xcc
#define BP_SIZE             1
#else
#pragma message("Debugger Breakpoint support needed for this architecture")
#endif

typedef struct tagBP_INFO      *PBP_INFO;
typedef struct tagTHREAD_INFO  *PTHREAD_INFO;
typedef struct tagPROCESS_INFO *PPROCESS_INFO;

typedef DWORD (*PBP_HANDLER)(PPROCESS_INFO,
                             PTHREAD_INFO,
                             PEXCEPTION_RECORD,
                             PBP_INFO);

typedef struct tagBP_INFO {
    LPVOID        Address;
    ULONG         OriginalInstr;
    PBP_HANDLER   Handler;
} BP_INFO, *PBP_INFO;

typedef struct tagTHREAD_INFO {
    PTHREAD_INFO  pNext;
    HANDLE        hProcess;
    HANDLE        hThread;
    ULONG         dwThreadId;
    CONTEXT       Context;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct tagPROCESS_INFO {
    PPROCESS_INFO pNext;
    HANDLE        hProcess;
    DWORD         dwProcessId;
    BOOL          bSeenLdrBp;
    LPVOID        EntryPoint;
    DEBUG_EVENT   DebugEvent;
    PTHREAD_INFO  pFirstThreadInfo;
    BP_INFO       bp[MAX_BREAKPOINTS];
} PROCESS_INFO, *PPROCESS_INFO;


SIZE_T
ReadMemoryDbg(
    HANDLE  hProcess,
    LPVOID  Address,
    LPVOID  Buffer,
    SIZE_T  Length
    );

BOOL
WriteMemoryDbg(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    SIZE_T  Length
    );

DWORD WINAPI
ExecuteAppThread(
    LPVOID lParam
    );

#endif // __APPVERIFIER_DEBUGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\debugger.cpp ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        Debugger.cpp

    Abstract:

        This module implements the AppVerifier.exe debugger.

    Author:

        clupu     created     01/25/2001

    Revision History:

--*/

#include "stdafx.h"
#include "appverif.h"

#include "Log.h"

#include <memory.h>
#include <stdlib.h>
#include "wdbgexts.h"

#include "Debugger.h"
#include "Setting.h"
#include "UserDump.h"
#include "DbgHelp.h"
#include "ChooseExe.h"

#ifdef BP_SIZE
ULONG     g_BpSize  = BP_SIZE;
#endif
#ifdef BP_INSTR
ULONG     g_BpInstr = BP_INSTR;
#endif

typedef void (*PFNDBGEXT)(HANDLE                    hCurrentProcess,
                          HANDLE                    hCurrentThread,
                          DWORD                     dwUnused,
                          PWINDBG_EXTENSION_APIS    lpExtensionApis,
                          LPSTR                     lpArgumentString);



PFNDBGEXT               g_pfnPhextsInit;

BOOL                    g_bInitialBreakpoint = TRUE;

PROCESS_INFORMATION     g_ProcessInformation;

WINDBG_EXTENSION_APIS   ExtensionAPIs;


typedef struct tagLOADEDDLL
{
    struct tagLOADEDDLL* pNext;
    LPTSTR               pszName;
    LPVOID               lpBaseOfDll;
} LOADEDDLL, *PLOADEDDLL;

PLOADEDDLL g_pFirstDll;


PPROCESS_INFO   g_pProcessHead  = NULL;
PPROCESS_INFO   g_pFirstProcess = NULL;


//
// BUGBUG: what's this for ?
//
TCHAR g_szDbgString[1024];


//
// Local function prototypes
//

void DebuggerLoop(void);



DWORD WINAPI ExecuteAppThread( LPVOID lParam )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Launch the debuggee.
--*/
{
    BOOL        bRet;
    STARTUPINFO StartupInfo;

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    //
    // Set some pageheap flags
    //
    AVSetVerifierFlagsForExe(g_szAppShortName, (DWORD)(LPARAM)lParam);

    bRet = CreateProcess(NULL,
                         g_szAppFullPath,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_SEPARATE_WOW_VDM | DEBUG_ONLY_THIS_PROCESS,
                         NULL,
                         NULL,
                         &StartupInfo,
                         &g_ProcessInformation);

    if ( !bRet )
    {
        LogMessage(LOG_ERROR, _T("[ExecuteApp] Couldn't start \"%s\""), g_szAppFullPath);
        return 0;
    }

    LogMessage(LOG_INFO,
               _T("[ExecuteApp] CreateProcess hProcess 0x%X. \"%s\""),
               g_ProcessInformation.hProcess,
               g_szAppFullPath);

    if ( g_ProcessInformation.hProcess != NULL )
    {

        //
        // Start the debugger loop.
        //
        DebuggerLoop();

        //
        // Free the memory.
        //
        PPROCESS_INFO pProcess = g_pProcessHead;
        PPROCESS_INFO pProcessNext;

        while ( pProcess != NULL )
        {
            pProcessNext = pProcess->pNext;

            PTHREAD_INFO pThread = pProcess->pFirstThreadInfo;
            PTHREAD_INFO pThreadNext;

            while ( pThread != NULL )
            {
                pThreadNext = pThread->pNext;

                HeapFree(GetProcessHeap(), 0, pThread);

                pThread = pThreadNext;
            }

            HeapFree(GetProcessHeap(), 0, pProcess);

            pProcess = pProcessNext;
        }

        g_pProcessHead = NULL;

        PLOADEDDLL pDll = g_pFirstDll;
        PLOADEDDLL pDllNext;

        while ( pDll != NULL )
        {
            pDllNext = pDll->pNext;

            HeapFree(GetProcessHeap(), 0, pDll->pszName);
            HeapFree(GetProcessHeap(), 0, pDll);

            pDll = pDllNext;
        }

        g_pFirstDll = NULL;

        g_bDebuggeeExited = TRUE;

        CloseHandle(g_ProcessInformation.hProcess);
        CloseHandle(g_ProcessInformation.hThread);

        ZeroMemory(&g_ProcessInformation, sizeof(PROCESS_INFORMATION));
    }

    //
    // Delete the pageheap flags
    //
    AVSetVerifierFlagsForExe(g_szAppShortName, 0);

    return 1;
}


PPROCESS_INFO GetProcessInfo( HANDLE hProcess )
{
    PPROCESS_INFO pProcess = g_pProcessHead;

    while ( pProcess != NULL )
    {
        if ( pProcess->hProcess == hProcess )
        {
            return pProcess;
        }
    }

    return NULL;
}

SIZE_T
ReadMemoryDbg(
    HANDLE  hProcess,
    LPVOID  Address,
    LPVOID  Buffer,
    SIZE_T  Length
    )
{
    SIZE_T        cbRead;
    LPVOID        AddressBp;
    PPROCESS_INFO pProcess;

    if ( !ReadProcessMemory(hProcess,
                            Address,
                            Buffer,
                            Length,
                            &cbRead) )
    {
        return 0;
    }

    pProcess = GetProcessInfo(hProcess);

    if ( pProcess == NULL )
    {
        return 0;
    }
#if defined(BP_INSTR) && defined(BP_SIZE)
    for ( int i = 0; i < MAX_BREAKPOINTS; i++ )
    {

        AddressBp = pProcess->bp[i].Address;

        if ( (ULONG_PTR)AddressBp >= (ULONG_PTR)Address &&
             (ULONG_PTR)AddressBp <  (ULONG_PTR)Address + Length )
        {

            CopyMemory((LPVOID)((ULONG_PTR)Buffer + (ULONG_PTR)AddressBp - (ULONG_PTR)Address),
                       &pProcess->bp[i].OriginalInstr,
                       g_BpSize);
        }
    }
#endif

    return cbRead;
}

BOOL
WriteMemoryDbg(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    SIZE_T   Length
    )
{
    SIZE_T cb = 0;
    BOOL  bSuccess;

    bSuccess = WriteProcessMemory(hProcess, Address, Buffer, Length, &cb);

    if ( !bSuccess || cb != Length )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
GetImageName(
    HANDLE    hProcess,
    ULONG_PTR ImageBase,
    PVOID     ImageNamePtr,
    LPTSTR    ImageName,
    DWORD     ImageNameLength
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   BUGBUG: give details here
--*/
{
    DWORD_PTR              i;
    BYTE                   UnicodeBuf[256 * 2];
    IMAGE_DOS_HEADER       dh;
    IMAGE_NT_HEADERS       nh;
    IMAGE_EXPORT_DIRECTORY expdir;

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)ImageNamePtr,
                        &i,
                        sizeof(i)) )
    {

        goto GetFromExports;
    }

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)i,
                        (ULONG*)UnicodeBuf,
                        sizeof(UnicodeBuf)) )
    {

        goto GetFromExports;
    }

    ZeroMemory(ImageName, ImageNameLength);

#ifdef UNICODE
    lstrcpyW(ImageName, (LPCWSTR)UnicodeBuf);
#else    
    WideCharToMultiByte(CP_ACP,
                        0,
                        (LPWSTR)UnicodeBuf,
                        wcslen((LPWSTR)UnicodeBuf),
                        ImageName,
                        ImageNameLength,
                        NULL,
                        NULL);
#endif // UNICODE

    if ( lstrlen(ImageName) == 0 )
    {
        goto GetFromExports;
    }

    return TRUE;

    GetFromExports:

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)ImageBase,
                        (ULONG*)&dh,
                        sizeof(IMAGE_DOS_HEADER)) )
    {
        return FALSE;
    }

    if ( dh.e_magic != IMAGE_DOS_SIGNATURE )
    {
        return FALSE;
    }

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase + dh.e_lfanew),
                        (ULONG*)&nh,
                        sizeof(IMAGE_NT_HEADERS)) )
    {
        return FALSE;
    }

    if ( nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0 )
    {
        return FALSE;
    }

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase +
                                 nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
                        (ULONG*)&expdir,
                        sizeof(IMAGE_EXPORT_DIRECTORY)) )
    {
        return FALSE;
    }

    if ( !ReadMemoryDbg(hProcess,
                        (ULONG*)(ImageBase + expdir.Name),
#ifdef UNICODE
                        (ULONG*)UnicodeBuf,
#else
                        (ULONG*)ImageName,
#endif // UNICODE
                        ImageNameLength) )
    {
        return FALSE;
    }

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP,
                        0,
                        (LPCSTR)UnicodeBuf,
                        -1,
                        ImageName,
                        ImageNameLength);
#endif // UNICODE

    return TRUE;
}

void
AddDll(
    LPVOID  lpBaseOfDll,
    LPCTSTR pszDllName
    )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    PLOADEDDLL pDll;

    pDll = (PLOADEDDLL)HeapAlloc(GetProcessHeap(), 0, sizeof(LOADEDDLL));

    if ( pDll == NULL )
    {
        LogMessage(LOG_ERROR, _T("[AddDll] Failed to allocate %d bytes"), sizeof(LOADEDDLL));
        return;
    }

    pDll->pszName = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, (lstrlen(pszDllName) + 1) * sizeof(TCHAR));

    if ( pDll->pszName == NULL )
    {
        HeapFree(GetProcessHeap(), 0, pDll);
        LogMessage(LOG_ERROR,
                   _T("[AddDll] Failed to allocate %d bytes"),
                   (lstrlen(pszDllName) + 1) * sizeof(TCHAR));
        return;
    }

    lstrcpy(pDll->pszName, pszDllName);

    pDll->lpBaseOfDll = lpBaseOfDll;

    pDll->pNext = g_pFirstDll;
    g_pFirstDll = pDll;
}

LPTSTR GetDll( LPVOID lpBaseOfDll )
/*++
    Return: The name of the DLL with the specified base address.

    Desc:   BUGBUG
--*/
{
    PLOADEDDLL pDll = g_pFirstDll;

    while ( pDll != NULL )
    {
        if ( pDll->lpBaseOfDll == lpBaseOfDll )
        {
            return pDll->pszName;
        }
        pDll = pDll->pNext;
    }

    return NULL;
}

void RemoveDll( LPVOID lpBaseOfDll )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    PLOADEDDLL* ppDll = &g_pFirstDll;
    PLOADEDDLL  pDllFree;

    while ( *ppDll != NULL )
    {

        if ( (*ppDll)->lpBaseOfDll == lpBaseOfDll )
        {

            HeapFree(GetProcessHeap(), 0, (*ppDll)->pszName);
            pDllFree = *ppDll;

            *ppDll = (*ppDll)->pNext;

            HeapFree(GetProcessHeap(), 0, pDllFree);
            break;
        }
        ppDll = &((*ppDll)->pNext);
    }
}


BOOL ProcessModuleLoad( PPROCESS_INFO pProcess, DEBUG_EVENT* pde )

/*++
    Return: TRUE on success, FALSE otherwise

    Desc:   Process all module load debug events, create process & dll load.
            The purpose is to allocate a MODULEINFO structure, fill in the
            necessary values, and load the symbol table.
--*/

{
    HANDLE      hFile=NULL;
    DWORD_PTR   dwBaseOfImage;

    if ( pde->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT )
    {

        hFile         = pde->u.CreateProcessInfo.hFile;
        dwBaseOfImage = (DWORD_PTR)pde->u.CreateProcessInfo.lpBaseOfImage;

        SymInitialize(pProcess->hProcess, NULL, FALSE);

    }
    else if ( pde->dwDebugEventCode == LOAD_DLL_DEBUG_EVENT )
    {
        hFile         = pde->u.LoadDll.hFile;
        dwBaseOfImage = (DWORD_PTR)pde->u.LoadDll.lpBaseOfDll;
    }

    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    if ( dwBaseOfImage==(DWORD_PTR)NULL )
    {
        return FALSE;
    }

    if ( !SymLoadModule(pProcess->hProcess, hFile, NULL, NULL, dwBaseOfImage, 0) )
    {
        return FALSE;
    }

    return TRUE;
}

void DebuggerLoop( void )
/*++
    Return: void.

    Desc:   BUGBUG: give details here
--*/
{
    DEBUG_EVENT   DebugEv;                            // debugging event information 
    DWORD         dwContinueStatus = DBG_CONTINUE;    // exception continuation 
    PPROCESS_INFO pProcess = NULL;
    PTHREAD_INFO  pThread  = NULL;

    while ( TRUE )
    {

        //
        // Wait for a debugging event to occur. The second parameter indicates
        // that the function does not return until a debugging event occurs.
        //
        WaitForDebugEvent(&DebugEv, INFINITE);

        //
        // Update the processes and threads lists.
        //
        pProcess = g_pProcessHead;
        while ( pProcess != NULL )
        {
            if ( pProcess->dwProcessId == DebugEv.dwProcessId )
            {
                break;
            }
            pProcess = pProcess->pNext;
        }

        if ( pProcess == NULL )
        {
            //
            // New process.
            //
            pProcess = (PPROCESS_INFO)HeapAlloc(GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                sizeof(PROCESS_INFO));
            if ( pProcess == NULL )
            {
                LogMessage(LOG_ERROR,
                           _T("[DebuggerLoop] Failed to allocate memory for the new process. Fatal !"));
                break;
            }

            pProcess->dwProcessId = DebugEv.dwProcessId;
            pProcess->pNext = g_pProcessHead;
            g_pProcessHead = pProcess;
        }

        pThread = pProcess->pFirstThreadInfo;

        while ( pThread != NULL )
        {
            if ( pThread->dwThreadId == DebugEv.dwThreadId )
            {
                break;
            }
            pThread = pThread->pNext;
        }

        if ( pThread == NULL )
        {
            //
            // New thread.
            //
            pThread = (PTHREAD_INFO)HeapAlloc(GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              sizeof(THREAD_INFO));
            if ( pThread == NULL )
            {
                LogMessage(LOG_ERROR,
                           _T("[DebuggerLoop] Failed to allocate memory for the new thread. Fatal !"));
                break;
            }

            pThread->dwThreadId = DebugEv.dwThreadId;
            pThread->pNext = pProcess->pFirstThreadInfo;
            pProcess->pFirstThreadInfo = pThread;
        }

        dwContinueStatus = DBG_CONTINUE;

        if ( DebugEv.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT )
        {
            goto EndProcess;
        }

        switch ( DebugEv.dwDebugEventCode )
        {
        
        case EXCEPTION_DEBUG_EVENT: 

            switch ( DebugEv.u.Exception.ExceptionRecord.ExceptionCode )
            {
            case EXCEPTION_BREAKPOINT:

                //
                // Hit a breakpoint.
                //
                if ( !pProcess->bSeenLdrBp )
                {

                    pProcess->bSeenLdrBp = TRUE;

                    //
                    // When the initial breakpoint is hit all the
                    // staticly linked DLLs are already loaded so
                    // we can go ahead and set breakpoints.
                    //
                    LogMessage(LOG_INFO, _T("[DebuggerLoop] Hit initial breakpoint."));

                    //
                    // Now it would be a good time to initialize the debugger extensions.
                    //
                    break;
                }

                LogMessage(LOG_INFO, _T("[DebuggerLoop] Hit breakpoint."));

                LogAVStatus(AVS_PAGEHEAP_DOUBLEFREE);

                if ( MessageBox(NULL,
                                _T("An Access Violation occured. Do you want to create")
                                _T(" a crash dump file so you can later debug this problem ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) == IDYES )
                {

                    pProcess->DebugEvent = DebugEv;
                    GenerateUserModeDump(g_szCrashDumpFile,
                                         pProcess,
                                         &DebugEv.u.Exception);
                }

                if ( MessageBox(NULL,
                                _T("Do you want to continue running the program ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES )
                {
                    goto EndProcess;
                }

                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                break;

            case STATUS_SINGLE_STEP:
                LogMessage(LOG_INFO, _T("[DebuggerLoop] Hit single step breakpoint."));
                break;

            case EXCEPTION_ACCESS_VIOLATION:
                LogMessage(LOG_INFO,
                           _T("[DebuggerLoop] AV. Addr: 0x%08X, firstChance %d"),
                           DebugEv.u.Exception.ExceptionRecord.ExceptionAddress,
                           DebugEv.u.Exception.dwFirstChance);

                LogAVStatus(AVS_PAGEHEAP_DOUBLEFREE);

                if ( MessageBox(NULL,
                                _T("An Access Violation occured. Do you want to create")
                                _T(" a crash dump file so you can later debug this problem ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) == IDYES )
                {

                    pProcess->DebugEvent = DebugEv;
                    GenerateUserModeDump(g_szCrashDumpFile,
                                         pProcess,
                                         &DebugEv.u.Exception);
                }

                if ( MessageBox(NULL,
                                _T("Do you want to continue running the program ?"),
                                _T("Error"),
                                MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES )
                {
                    goto EndProcess;
                }

                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;

                break;

            default:
                LogMessage(LOG_INFO, _T("[DebuggerLoop] Unknown debugger exception."));

                dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                break;
            }
            break;

        case CREATE_THREAD_DEBUG_EVENT:
            pThread->hProcess = pProcess->hProcess;
            pThread->hThread  = DebugEv.u.CreateThread.hThread;

            LogMessage(LOG_INFO,
                       _T("[DebuggerLoop] new thread. StartAddress: 0x%x"),
                       DebugEv.u.CreateThread.lpStartAddress);
            break;

        case EXIT_THREAD_DEBUG_EVENT:
            LogMessage(LOG_INFO,
                       _T("[DebuggerLoop] exiting thread with code: 0x%x"),
                       DebugEv.u.ExitThread.dwExitCode);
            break;

        case CREATE_PROCESS_DEBUG_EVENT:

            pProcess->hProcess = DebugEv.u.CreateProcessInfo.hProcess;
            pThread->hProcess  = pProcess->hProcess;
            pThread->hThread   = DebugEv.u.CreateProcessInfo.hThread;

            if ( g_pFirstProcess == NULL )
            {
                g_pFirstProcess = pProcess;
            }

            pProcess->EntryPoint = DebugEv.u.CreateProcessInfo.lpStartAddress;

            ProcessModuleLoad(pProcess, &DebugEv);

            LogMessage(LOG_INFO,
                       _T("[DebuggerLoop] new process. BaseImage: 0x%x StartAddress: 0x%x"),
                       DebugEv.u.CreateProcessInfo.lpBaseOfImage,
                       DebugEv.u.CreateProcessInfo.lpStartAddress);
            break;

        case LOAD_DLL_DEBUG_EVENT:
            {
                TCHAR szAsciiBuf[256];
                TCHAR szDllName[128];
                TCHAR szExt[16];
                BOOL  bRet;

                bRet = GetImageName(pProcess->hProcess,
                                    (ULONG_PTR)DebugEv.u.LoadDll.lpBaseOfDll,
                                    DebugEv.u.LoadDll.lpImageName,
                                    szAsciiBuf,
                                    sizeof(szAsciiBuf));
                if (!bRet) {
                    LogMessage(LOG_INFO,
                               _T("[DebuggerLoop] DLL LOADED. BaseDll: 0x%X cannot get the name."),
                               DebugEv.u.LoadDll.lpBaseOfDll);
                    AddDll(DebugEv.u.LoadDll.lpBaseOfDll, NULL);
                } else {
                    _tsplitpath(szAsciiBuf, NULL, NULL, szDllName, szExt);
                    lstrcat(szDllName, szExt);
    
                    AddDll(DebugEv.u.LoadDll.lpBaseOfDll, szDllName);
    
                    LogMessage(LOG_INFO,
                               _T("[DebuggerLoop] DLL LOADED. BaseDll: 0x%X \"%s\"."),
                               DebugEv.u.LoadDll.lpBaseOfDll,
                               szDllName);
                }
                
                ProcessModuleLoad(pProcess, &DebugEv);

                CloseHandle(DebugEv.u.LoadDll.hFile);

                break;
            }

        case UNLOAD_DLL_DEBUG_EVENT:
            {
                LPTSTR pszName = GetDll(DebugEv.u.UnloadDll.lpBaseOfDll);

                if ( pszName == NULL )
                {
                    LogMessage(LOG_INFO,
                               _T("[DebuggerLoop] DLL UNLOADED. BaseDll: 0x%X unknown."),
                               DebugEv.u.UnloadDll.lpBaseOfDll);
                }
                else
                {
                    LogMessage(LOG_INFO,
                               _T("[DebuggerLoop] DLL UNLOADED. BaseDll: 0x%X \"%s\"."),
                               DebugEv.u.UnloadDll.lpBaseOfDll, pszName);
                }

                RemoveDll(DebugEv.u.UnloadDll.lpBaseOfDll);

                break;
            }

        case OUTPUT_DEBUG_STRING_EVENT:
            ReadMemoryDbg(pThread->hProcess,
                          DebugEv.u.DebugString.lpDebugStringData,
                          g_szDbgString,
                          DebugEv.u.DebugString.nDebugStringLength);

#ifdef UNICODE
            LogMessage(LOG_INFO, _T("DPF - %S"), g_szDbgString);
#else
            LogMessage(LOG_INFO, _T("DPF - %s"), g_szDbgString);
#endif // UNICODE
            break;

        default:
            LogMessage(LOG_ERROR,
                       _T("[DebuggerLoop] Unknown event 0x%X"),
                       DebugEv.dwDebugEventCode);
            break;
        }

        //
        // Resume executing the thread that reported the debugging event.
        //
        ContinueDebugEvent(DebugEv.dwProcessId,
                           DebugEv.dwThreadId,
                           dwContinueStatus); 
    }

EndProcess:
    LogMessage(LOG_INFO, _T("[DebuggerLoop] The debugged process has exited."));

    LogAVStatus(AVS_APP_TERMINATED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\log.cpp ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        Log.cpp

    Abstract:

        This module implements the code for manipulating the log file.

    Author:

        clupu     created     02/08/2001

    Revision History:

--*/

#include "stdafx.h"

#include "Log.h"

#include <stdio.h>
#include <stdarg.h>

BOOL    g_bFileLogEnabled;
TCHAR   g_szFileLog[MAX_PATH];



BOOL InitFileLogSupport( LPCTSTR lpszLogFileName )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hMap = NULL;
    PBYTE       pMap;
    PISSUEREC   pRecord;

    g_bFileLogEnabled = FALSE;

    //
    // The file log will be located on %windir%
    //
    GetSystemWindowsDirectory(g_szFileLog, MAX_PATH);

    lstrcat(g_szFileLog, _T("\\AppPatch\\"));
    lstrcat(g_szFileLog, lpszLogFileName);

    //
    // Try open the file. Create it if it doesn't exist.
    //
    hFile = CreateFile(g_szFileLog,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LogMessage(LOG_ERROR, _T("[InitFileLogSupport] Cannot create log file."));
        return FALSE;
    }

    hMap = CreateFileMapping(hFile,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             LOGFILESIZE,
                             NULL);

    if ( hMap == NULL )
    {
        LogMessage(LOG_ERROR,
                   _T("[LogAVStatus] CreateFileMapping failed. Status 0x%x"),
                   GetLastError());
        goto CleanupAndFail;
    }

    pMap = (PBYTE)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, LOGFILESIZE);

    if ( pMap == NULL )
    {
        LogMessage(LOG_ERROR, _T("[LogAVStatus] MapViewOfFile failed."));
        goto CleanupAndFail;
    }

    ZeroMemory(pMap, LOGFILESIZE);

    //
    // Write the log header.
    //

    LOGFILEHEADER LogHeader;
    char          szTemp[64];
    DWORD         cbSize;

    ZeroMemory(&LogHeader, sizeof(LOGFILEHEADER));

    lstrcpyA(LogHeader.szMagic, LOG_FILE_MAGIC);

    LogHeader.dwRecords = MAX_ISSUES_COUNT;

    LogHeader.OSVersion.dwOSVersionInfoSize = sizeof(LogHeader.OSVersion);

    GetVersionExA((OSVERSIONINFOA*)&LogHeader.OSVersion);
    GetLocalTime(&LogHeader.time);

    cbSize = 64;
    GetUserNameA(szTemp, &cbSize);
    CopyMemory(LogHeader.szUserName, szTemp, 63);
    LogHeader.szUserName[63] = 0;

    cbSize = 64;
    GetComputerNameA(szTemp, &cbSize);
    CopyMemory(LogHeader.szMachineName, szTemp, 63);
    LogHeader.szUserName[63] = 0;

    //
    // Log the app start event.
    //
    pRecord = (ISSUEREC*)(pMap + sizeof(LOGFILEHEADER));

    pRecord += EVENTIND(AVS_APP_STARTED);

    (pRecord->dwOccurenceCount)++;

    FlushViewOfFile(pMap, 0);

    //
    // Set the global that tells file logging is enabled.
    //
    g_bFileLogEnabled = TRUE;

    CleanupAndFail:

    if ( pMap != NULL )
    {
        UnmapViewOfFile(pMap);
    }

    if ( hMap != NULL )
    {
        CloseHandle(hMap);
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(hFile);
    }

    return g_bFileLogEnabled;
}

BOOL LogAVStatus( DWORD dwStatus )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hMap = NULL;
    PBYTE       pMap = NULL;
    BOOL        bReturn = FALSE;
    PISSUEREC   pRecord;

    if ( !g_bFileLogEnabled )
    {
        return FALSE;
    }

    hFile = CreateFile(g_szFileLog,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LogMessage(LOG_ERROR, _T("[LogAVStatus] Cannot open the log file."));
        goto CleanupAndFail;
    }

    hMap = CreateFileMapping(hFile,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             LOGFILESIZE,
                             NULL);

    if ( hMap == NULL )
    {
        LogMessage(LOG_ERROR, _T("[LogAVStatus] CreateFileMapping failed."));
        goto CleanupAndFail;
    }

    pMap = (PBYTE)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, LOGFILESIZE);

    if ( pMap == NULL )
    {
        LogMessage(LOG_ERROR, _T("[LogAVStatus] MapViewOfFile failed."));
        goto CleanupAndFail;
    }

    pRecord = (PISSUEREC)(pMap + sizeof(LOGFILEHEADER));

    pRecord += EVENTIND(dwStatus);

    (pRecord->dwOccurenceCount)++;

    FlushViewOfFile(pMap, 0);

    bReturn = TRUE;

    CleanupAndFail:

    if ( pMap != NULL )
    {
        UnmapViewOfFile(pMap);
    }

    if ( hMap != NULL )
    {
        CloseHandle(hMap);
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(hFile);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\log.h ===
#ifndef __APPVERIFIER_LOG_H_
#define __APPVERIFIER_LOG_H_

#include "LogEvents.h"

#define LOG_FILE_MAGIC  "APPVLOG"

typedef enum {
    LOG_ERROR,
    LOG_WARNING,
    LOG_INFO
} MSGLEVEL;

typedef struct tagLOGFILEHEADER {
    char             szMagic[8];
    char             szMachineName[64];
    char             szUserName[64];
    SYSTEMTIME       time;
    OSVERSIONINFOEXA OSVersion;
    DWORD            dwRecords;

} LOGFILEHEADER, *PLOGFILEHEADER;

typedef struct tagISSUEREC {
    DWORD   dwOccurenceCount;
    DWORD   dwUnused;

} ISSUEREC, *PISSUEREC;


#define LOGFILESIZE         (sizeof(LOGFILEHEADER) + MAX_ISSUES_COUNT * sizeof(ISSUEREC))

#define EVENTIND(ev)        ((ev - 1) / 3)

#define EVENT_FROM_IND(ind) (1 + (ind * 3))


extern TCHAR   g_szFileLog[MAX_PATH];

BOOL
InitFileLogSupport(
    LPCTSTR lpszLogFileName
    );

BOOL
LogAVStatus(
    DWORD   dwStatus
    );


void _cdecl LogMessage( MSGLEVEL mlevel, LPTSTR pszFmt, ... );

#endif // __APPVERIFIER_LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\logevents.h ===
#define MAX_ISSUES_COUNT                        64

#define AVS_APP_STARTED                         1
#define AVS_APP_STARTED_R                       2
#define AVS_APP_STARTED_URL                     3

#define AVS_HARDCODED_GETTEMPPATH               4
#define AVS_HARDCODED_GETTEMPPATH_R             5
#define AVS_HARDCODED_GETTEMPPATH_URL           6

#define AVS_PAGEHEAP_DOUBLEFREE                 7
#define AVS_PAGEHEAP_DOUBLEFREE_R               8
#define AVS_PAGEHEAP_DOUBLEFREE_URL             9


    
// ------------
// Reg warnings
// ------------

//
// Keys that apps shouldn't attemp to read the values of.
//
#define AVS_HKCU_AppEvents_READ                 10
#define AVS_HKCU_AppEvents_READ_R               11
#define AVS_HKCU_AppEvents_READ_URL             12

#define AVS_HKCU_Console_READ                   13
#define AVS_HKCU_Console_READ_R                 14
#define AVS_HKCU_Console_READ_URL               15

#define AVS_HKCU_ControlPanel_READ              16
#define AVS_HKCU_ControlPanel_READ_R            17
#define AVS_HKCU_ControlPanel_READ_URL          18

#define AVS_HKCU_Environment_READ               19
#define AVS_HKCU_Environment_READ_R             20
#define AVS_HKCU_Environment_READ_URL           21

#define AVS_HKCU_Identities_READ                22
#define AVS_HKCU_Identities_READ_R              23
#define AVS_HKCU_Identities_READ_URL            24

#define AVS_HKCU_KeyboardLayout_READ            25
#define AVS_HKCU_KeyboardLayout_READ_R          26
#define AVS_HKCU_KeyboardLayout_READ_URL        27

#define AVS_HKCU_Printers_READ                  28
#define AVS_HKCU_Printers_READ_R                29
#define AVS_HKCU_Printers_READ_URL              30

#define AVS_HKCU_RemoteAccess_READ           31
#define AVS_HKCU_RemoteAccess_READ_R         32
#define AVS_HKCU_RemoteAccess_READ_URL       33

#define AVS_HKCU_SessionInformation_READ        34
#define AVS_HKCU_SessionInformation_READ_R      35
#define AVS_HKCU_SessionInformation_READ_URL    36

#define AVS_HKCU_UNICODEProgramGroups_READ      37
#define AVS_HKCU_UNICODEProgramGroups_READ_R    38
#define AVS_HKCU_UNICODEProgramGroups_READ_URL  39

#define AVS_HKCU_VolatileEnvironment_READ       40
#define AVS_HKCU_VolatileEnvironment_READ_R     41
#define AVS_HKCU_VolatileEnvironment_READ_URL   42

#define AVS_HKCU_Windows31MigrationStatus_READ  43
#define AVS_HKCU_Windows31MigrationStatus_READ_R    44
#define AVS_HKCU_Windows31MigrationStatus_READ_URL  45

#define AVS_HKLM_HARDWARE_READ                  46
#define AVS_HKLM_HARDWARE_READ_R                47
#define AVS_HKLM_HARDWARE_READ_URL              48

#define AVS_HKLM_SAM_READ                       49
#define AVS_HKLM_SAM_READ_R                     50
#define AVS_HKLM_SAM_READ_URL                   51

#define AVS_HKLM_SECURITY_READ                  52
#define AVS_HKLM_SECURITY_READ_R                53
#define AVS_HKLM_SECURITY_READ_URL              54

#define AVS_HKLM_SYSTEM_READ                    55
#define AVS_HKLM_SYSTEM_READ_R                  56
#define AVS_HKLM_SYSTEM_READ_URL                57

// HKEY_CURRENT_CONFIG
#define AVS_HKCC_READ                           58
#define AVS_HKCC_READ_R                         59
#define AVS_HKCC_READ_URL                       60

// HKEY_USERS
#define AVS_HKUS_READ                           61
#define AVS_HKUS_READ_R                         62
#define AVS_HKUS_READ_URL                       63

//
// Apps shouldn't attempt to write to any keys except 
// the ones under HKCU when they are running.
//
#define AVS_NON_HKCU_WRITE                      64
#define AVS_NON_HKCU_WRITE_R                    65
#define AVS_NON_HKCU_WRITE_URL                  66


//
// path errors
//

#define AVS_HARDCODED_WINDOWSPATH               100
#define AVS_HARDCODED_WINDOWSPATH_R             101
#define AVS_HARDCODED_WINDOWSPATH_URL           102

#define AVS_HARDCODED_SYSWINDOWSPATH            103
#define AVS_HARDCODED_SYSWINDOWSPATH_R          104
#define AVS_HARDCODED_SYSWINDOWSPATH_URL        105

#define AVS_HARDCODED_SYSTEMPATH                106
#define AVS_HARDCODED_SYSTEMPATH_R              107
#define AVS_HARDCODED_SYSTEMPATH_URL            108

#define AVS_HARDCODED_PERSONALPATH              109
#define AVS_HARDCODED_PERSONALPATH_R            110
#define AVS_HARDCODED_PERSONALPATH_URL          111

#define AVS_HARDCODED_COMMONPROGRAMS            112
#define AVS_HARDCODED_COMMONPROGRAMS_R          113
#define AVS_HARDCODED_COMMONPROGRAMS_URL        114

#define AVS_HARDCODED_COMMONSTARTMENU           115
#define AVS_HARDCODED_COMMONSTARTMENU_R         116
#define AVS_HARDCODED_COMMONSTARTMENU_URL       117

#define AVS_HARDCODED_PROGRAMS                  118
#define AVS_HARDCODED_PROGRAMS_R                119
#define AVS_HARDCODED_PROGRAMS_URL              120

#define AVS_HARDCODED_STARTMENU                 121
#define AVS_HARDCODED_STARTMENU_R               122
#define AVS_HARDCODED_STARTMENU_URL             123


#define AVS_APP_TERMINATED              190
#define AVS_APP_TERMINATED_R            191
#define AVS_APP_TERMINATED_URL          192
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\selapp.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: SelApp.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "Select applications to be verified" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "SelApp.h"
#include "AVGlobal.h"
#include "Setting.h"
#include "AVUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CSelectAppPage property page

IMPLEMENT_DYNCREATE(CSelectAppPage, CAppverifPage)

CSelectAppPage::CSelectAppPage() : CAppverifPage(CSelectAppPage::IDD)
{
	//{{AFX_DATA_INIT(CSelectAppPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSelectAppPage::~CSelectAppPage()
{
}

void CSelectAppPage::DoDataExchange(CDataExchange* pDX)
{
	CAppverifPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectAppPage)
	DDX_Control(pDX, IDC_SELECTAPPS_LIST, m_AppList);
	DDX_Control(pDX, IDC_SELECTAPPS_NEXTDESCR_STATIC, m_NextDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectAppPage, CAppverifPage)
	//{{AFX_MSG_MAP(CSelectAppPage)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_SELECTAPPS_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_SELECTAPPS_REMOVE_BUTTON, OnRemoveButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CSelectAppPage::GetDialogId() const
{
    return IDD_APPLICATION_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
VOID CSelectAppPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;

    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_AppList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
                sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_FILE_NAME ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.17 );
    VERIFY( m_AppList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_FILE_VERSION ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.15 );
    VERIFY( m_AppList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 2
    //

    VERIFY( strTitle.LoadString( IDS_COMPANY ) );

    lvColumn.iSubItem = 2;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.30 );
    VERIFY( m_AppList.InsertColumn( 2, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 3
    //

    VERIFY( strTitle.LoadString( IDS_PRODUCT_NAME ) );

    lvColumn.iSubItem = 3;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.38 );
    VERIFY( m_AppList.InsertColumn( 3, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
VOID CSelectAppPage::SortTheList()
{
}

/////////////////////////////////////////////////////////////////////////////
INT CSelectAppPage::AddListItem( INT_PTR nIndexInDataArray,
                                 CApplicationData *pAppData )
{
    INT nActualIndex;
    LVITEM lvItem;

    ASSERT_VALID( pAppData );

    nActualIndex = -1;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - file name
    //

    lvItem.pszText = pAppData->m_strExeFileName.GetBuffer( 
        pAppData->m_strExeFileName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInDataArray;
    lvItem.iItem = m_AppList.GetItemCount();

    nActualIndex = m_AppList.InsertItem( &lvItem );

    pAppData->m_strExeFileName.ReleaseBuffer();

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - file version
    //

    lvItem.pszText = pAppData->m_strFileVersion.GetBuffer( 
        pAppData->m_strFileVersion.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_AppList.SetItem( &lvItem ) );

    pAppData->m_strFileVersion.ReleaseBuffer();

    //
    // Sub-item 2 - provider
    //

    lvItem.pszText = pAppData->m_strCompanyName.GetBuffer( 
        pAppData->m_strCompanyName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 2;

    VERIFY( m_AppList.SetItem( &lvItem ) );
    
    pAppData->m_strCompanyName.ReleaseBuffer();

    //
    // Sub-item 3 - product name
    //

    lvItem.pszText = pAppData->m_strProductName.GetBuffer( 
        pAppData->m_strProductName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 3;

    VERIFY( m_AppList.SetItem( &lvItem ) );
    
    pAppData->m_strProductName.ReleaseBuffer();

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////////////////////
VOID CSelectAppPage::FillTheList()
{
    INT_PTR nVerifiedApps;
    INT_PTR nCrtVerifiedApp;
    CApplicationData *pAppData;

    nVerifiedApps = g_NewSettings.m_aApplicationData.GetSize();

    for( nCrtVerifiedApp = 0; nCrtVerifiedApp < nVerifiedApps; nCrtVerifiedApp +=1 )
    {
        pAppData = g_NewSettings.m_aApplicationData.GetAt( nCrtVerifiedApp );

        ASSERT_VALID( pAppData );

        AddListItem( nCrtVerifiedApp,
                     pAppData );
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSelectAppPage message handlers

/////////////////////////////////////////////////////////////
LONG CSelectAppPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szAVHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CSelectAppPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szAVHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}


/////////////////////////////////////////////////////////////////////////////
BOOL CSelectAppPage::OnWizardFinish() 
{
    BOOL bExitTheApp;
    INT nResponse;

    ASSERT( AVSettingsTypeStandard == g_NewSettings.m_SettingsType );

    if( m_AppList.GetItemCount() > 0 )
    {
        //
        // Have at least one app selected to be verified
        //

        bExitTheApp = AVSaveNewSettings();
    }
    else
    {
        //
        // No apps in the list
        //

        nResponse = AVMesssageBoxFromResource( IDS_SELECT_AT_LEAST_ONE_APP,
                                               MB_YESNO | MB_ICONQUESTION );

        //
        // The user might choose to delete all settings here
        //

        bExitTheApp = ( nResponse == IDYES ) && AVSaveNewSettings();
    }

    return bExitTheApp;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectAppPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    ASSERT( AVSettingsTypeStandard == g_NewSettings.m_SettingsType );

    m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );

    //
    // Display the description of the next step
    //

    AVSetWindowText( m_NextDescription, IDS_SELAPP_FINISH_DESCR );

	return CAppverifPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectAppPage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    m_AppList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_AppList.GetExtendedStyle() );

    //
    // Setup our list and fill it out if we already have something in the app names array
    //

    SetupListHeader();
    FillTheList();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CSelectAppPage message handlers

#define VRF_MAX_CHARS_FOR_OPEN  4096

void CSelectAppPage::OnAddButton() 
{
    POSITION pos;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    INT nFileNameStartIndex;
    INT nNewListItemIndex;
    INT_PTR nResult;
    INT_PTR nNewAppDataIndex;
    CApplicationData *pNewAppData;
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "exe" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Executable Files (*.exe)|*.exe||" ) );  // only one filter

    //
    // Check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // Allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    fileDlg.m_ofn.lpstrTitle = (LPCTSTR) g_strAppName;

    //
    // Show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            AVErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            AVErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // Split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // This shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // Skip the backslash
            //

            nFileNameStartIndex += 1;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this app to our global list
        //

        if( g_NewSettings.m_aApplicationData.IsFileNameInList( strFileName ) )
        {
            AVErrorResourceFormat( IDS_APP_IS_ALREADY_IN_LIST,
                                   (LPCTSTR) strFileName );
        }
        else
        {
            nNewAppDataIndex = g_NewSettings.m_aApplicationData.AddNewAppData( strFileName, 
                                                                               strPathName,
                                                                               g_dwNewSettingBits );

            if( nNewAppDataIndex >= 0 )
            {
                //
                // Add a new item to our list corresponding to this app
                //

                pNewAppData = g_NewSettings.m_aApplicationData.GetAt( nNewAppDataIndex );
            
                ASSERT_VALID( pNewAppData );

                nNewListItemIndex = AddListItem( nNewAppDataIndex, 
                                                 pNewAppData );

                if( nNewListItemIndex >= 0 )
                {
                    m_AppList.EnsureVisible( nNewListItemIndex, TRUE );
                }
            }
        }
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete szFilesBuffer;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CSelectAppPage::OnRemoveButton() 
{
    int nItems;
    int nCrtItem;
    INT_PTR nIndexInDataArray;
    INT_PTR nElementsToRemove;
    INT_PTR nCrtElement;
    INT_PTR nCrtIndexToAdjust;
    CPtrArray aIndexesToRemove;

    //
    // Add the index of all the apps to remove from the
    // g_NewSettings.m_aApplicationData array in aIndexesToRemove.
    //

    nItems = m_AppList.GetItemCount();

    for( nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_AppList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            nIndexInDataArray = (UINT)m_AppList.GetItemData( nCrtItem );

            ASSERT( nIndexInDataArray >= 0 && 
                    nIndexInDataArray < g_NewSettings.m_aApplicationData.GetSize() );

            aIndexesToRemove.Add( (PVOID)nIndexInDataArray );
        }
    }

    //
    // Remove the app data structures from our array
    //

    nElementsToRemove = aIndexesToRemove.GetSize();

    while( nElementsToRemove > 0 )
    {
        nElementsToRemove -= 1;

        nIndexInDataArray = (INT_PTR)aIndexesToRemove.GetAt( nElementsToRemove );

        ASSERT( nIndexInDataArray >= 0 && 
                nIndexInDataArray < g_NewSettings.m_aApplicationData.GetSize() );

        g_NewSettings.m_aApplicationData.DeleteAt( nIndexInDataArray );

        for( nCrtElement = 0; nCrtElement < nElementsToRemove; nCrtElement += 1)
        {
            nCrtIndexToAdjust = (INT_PTR)aIndexesToRemove.GetAt( nCrtElement );
            
            if( nCrtIndexToAdjust > nIndexInDataArray )
            {
                aIndexesToRemove.SetAt( nCrtElement,
                                        (PVOID)( nCrtIndexToAdjust - 1 ) );
            }
        }
    }

    //
    // Fill out the list again
    //

    m_AppList.DeleteAllItems();
    FillTheList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\selapp.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: SelApp.h
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "Select applications to be verified" wizard page class.
//

#if !defined(AFX_SELAPP_H__53006A6E_5491_4629_B683_11535F0229A2__INCLUDED_)
#define AFX_SELAPP_H__53006A6E_5491_4629_B683_11535F0229A2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"
#include "Setting.h"

//
// Forward declarations
//

class CApplicationData;

/////////////////////////////////////////////////////////////////////////////
// CSelectAppPage dialog

class CSelectAppPage : public CAppverifPage
{
	DECLARE_DYNCREATE(CSelectAppPage)

public:
	CSelectAppPage();
	~CSelectAppPage();

protected:

    VOID SetupListHeader();
    VOID SortTheList();

    INT AddListItem( INT_PTR nIndexInArray,
                     CApplicationData *pAppData );


    VOID FillTheList();

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CSelectAppPage)
	public:
	virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
    //
    // Dialog Data
    //

    CApplicationDataArray m_aCurrentAppData;

	//{{AFX_DATA(CSelectAppPage)
	enum { IDD = IDD_APPLICATION_PAGE };
	CListCtrl	m_AppList;
	CStatic	m_NextDescription;
	//}}AFX_DATA

protected:
    //
	// Generated message map functions
    //

	//{{AFX_MSG(CSelectAppPage)
	virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELAPP_H__53006A6E_5491_4629_B683_11535F0229A2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\options.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.cpp
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Select individual tests" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "Options.h"
#include "AVUtil.h"
#include "AVGlobal.h"
#include "Setting.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD g_dwRegFlags;
TCHAR g_szCrashDumpFile[MAX_PATH];

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// COptionsPage property page

IMPLEMENT_DYNCREATE(COptionsPage, CAppverifPage)

COptionsPage::COptionsPage() : CAppverifPage(COptionsPage::IDD)
{
    //{{AFX_DATA_INIT(COptionsPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nIssues = 0;
}

COptionsPage::~COptionsPage()
{
}

void COptionsPage::DoDataExchange(CDataExchange* pDX)
{
    CAppverifPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COptionsPage)
    DDX_Control(pDX, IDC_ISSUES, m_IssuesList);
    DDX_Control(pDX, IDC_CRASHDUMP_FILE, m_CrashDumpFile);
    DDX_Control(pDX, IDC_CREATE_CRASHDUMP_FILE, m_CreateCrashDumpFile);
    DDX_Control(pDX, IDC_OPTIONS_NEXTDESCR_STATIC, m_NextDescription);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsPage, CAppverifPage)
    //{{AFX_MSG_MAP(COptionsPage)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_CREATE_CRASHDUMP_FILE, OnCheckCreateCrashDumpFile)
    ON_BN_CLICKED(IDC_BROWSE_CRASHDUMP, OnBrowseCrashDumpFile)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG COptionsPage::GetDialogId() const
{
    return IDD_OPTIONS_PAGE;
}

/////////////////////////////////////////////////////////////////////////////


void COptionsPage::InsertIssue( DWORD idResIssue )
{
    TCHAR szIssue[128];

    VERIFY( AVLoadString( idResIssue, szIssue, ARRAY_LENGTH( szIssue ) ) );
    
    m_IssuesList.InsertItem(m_nIssues, szIssue);
    m_IssuesList.SetCheck(m_nIssues, TRUE);
    
    g_dwRegFlags |= g_AllNamesAndBits[ m_nIssues ].m_dwBit;

    m_nIssues++;
    
    return;
}


/////////////////////////////////////////////////////////////////////////////
// COptionsPage message handlers

/////////////////////////////////////////////////////////////
LONG COptionsPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szAVHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void COptionsPage::OnBrowseCrashDumpFile() 
{
    TCHAR        szFilter[] = _T("Memory dump files (*.dmp)\0*.dmp\0");
    OPENFILENAME ofn;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = m_hWndTop;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szCrashDumpFile;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = _T("Choose the crash dump file");
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("DMP");

    if ( !GetOpenFileName(&ofn) )
    {
        return;
    }

    m_CrashDumpFile.SetWindowText(g_szCrashDumpFile);
}

/////////////////////////////////////////////////////////////////////////////
void COptionsPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szAVHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}


/////////////////////////////////////////////////////////////////////////////
LRESULT COptionsPage::OnWizardNext() 
{
    //
    // Create the dwRegFlags that needs to be passed arround.
    //

	g_dwRegFlags = 0;
    
    for( int uCrtBit = 0; uCrtBit < ARRAY_LENGTH( g_AllNamesAndBits ); uCrtBit++ )
	{
		m_IssuesList.GetCheck( uCrtBit );
        
        if( m_IssuesList.GetCheck( uCrtBit ) )
        {
            g_dwRegFlags |= g_AllNamesAndBits[ uCrtBit ].m_dwBit;
        }
	}
    
    GoingToNextPageNotify( IDD_STARTAPP_PAGE );

    return IDD_STARTAPP_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL COptionsPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    return CAppverifPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
void COptionsPage::OnCheckCreateCrashDumpFile() 
{
}

/////////////////////////////////////////////////////////////////////////////
BOOL COptionsPage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    g_dwRegFlags = 0;
    
    m_IssuesList.SetExtendedStyle(LVS_EX_CHECKBOXES);

    m_IssuesList.InsertColumn(0, _T("Issue Description"), LVCFMT_LEFT, 250);
    
	for( int uCrtBit = 0; uCrtBit < ARRAY_LENGTH( g_AllNamesAndBits ); uCrtBit++ )
	{
		InsertIssue( g_AllNamesAndBits[ uCrtBit ].m_uNameStringId );
	}

    ExpandEnvironmentStrings(_T("%windir%\\AppVerifier.dmp"), g_szCrashDumpFile, MAX_PATH);
    
    m_CrashDumpFile.SetWindowText(g_szCrashDumpFile);

    m_CreateCrashDumpFile.SetCheck(1);

    AVSetWindowText( m_NextDescription, IDS_OPTIONS_NEXTDESCR_STATIC );
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// COptionsPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\options.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.h
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Choose an executable to run" wizard page class.
//

#if !defined(AFX_OPTIONS_H_INCLUDED_)
#define AFX_OPTIONS_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"

/////////////////////////////////////////////////////////////////////////////
// COptionsPage dialog

class COptionsPage : public CAppverifPage
{
    DECLARE_DYNCREATE(COptionsPage)

// Construction
public:
    COptionsPage();
    ~COptionsPage();

protected:

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(COptionsPage)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    void InsertIssue( DWORD idResIssue );


protected:
    // Dialog Data
    //{{AFX_DATA(COptionsPage)
    enum { IDD = IDD_OPTIONS_PAGE };
    CListCtrl     m_IssuesList;
    CEdit         m_CrashDumpFile;
	CButton	      m_CreateCrashDumpFile;
	CStatic	      m_NextDescription;
    //}}AFX_DATA

    int m_nIssues;

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(COptionsPage)
    virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnCheckCreateCrashDumpFile();
    afx_msg void OnBrowseCrashDumpFile();
    //}}AFX_M