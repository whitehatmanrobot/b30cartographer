 this is the case we still need to free up the
    // channel resources
    //
    if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {

        for (i=0; i< USBCAMD_MAX_REQUEST; i++) {
            USBCAMD_FreeIsoTransfer(ChannelExtension,
                                    &ChannelExtension->TransferExtension[i]);
        }

        // kill the iso thread.
        USBCAMD_KillIsoThread(DeviceExtension);
    }
    else {
        //
        // free bulk buffers in channel transfer extensions.
        //
        for ( i =0; i < USBCAMD_MAX_REQUEST; i++) {
            if (ChannelExtension->TransferExtension[i].DataBuffer != NULL) {
                USBCAMD_FreeRawFrameBuffer(ChannelExtension->TransferExtension[i].DataBuffer);
                ChannelExtension->TransferExtension[i].DataBuffer = NULL;
            }

            if ( ChannelExtension->ImageCaptureStarted )
                USBCAMD_FreeBulkTransfer(&ChannelExtension->TransferExtension[i]);
        }
    }

USBCAMD_UnPrepareChannel_Done:
    //
    // channel is no longer prepared
    //

    ChannelExtension->ChannelPrepared = FALSE;


    USBCAMD_KdPrint (MIN_TRACE, ("'exit USBCAMD_UnPrepareChannel (%x)\n", ntStatus));

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}

VOID
USBCAMD_KillIsoThread(
    IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt)
{
    //
    // check if the thread was started..
    //
    if (!pDeviceExt->IsoThreadObject)
        return ;

    USBCAMD_KdPrint (MIN_TRACE,("Waiting for Iso Thread to Terminate\n"));
    pDeviceExt->StopIsoThread = TRUE; // Set the thread stop flag
    // Wake up the thread if asleep.
    
    if (!Win98) {
        KeReleaseSemaphore(&pDeviceExt->CompletedSrbListSemaphore,0,1,TRUE);
        // Wait for the iso thread to kill himself
        KeWaitForSingleObject(pDeviceExt->IsoThreadObject,Executive,KernelMode,FALSE,NULL);
    }
    else 
        KeReleaseSemaphore(&pDeviceExt->CompletedSrbListSemaphore,0,1,FALSE);

    USBCAMD_KdPrint (MAX_TRACE,("Iso Thread Terminated\n"));
    ObDereferenceObject(pDeviceExt->IsoThreadObject);
    pDeviceExt->IsoThreadObject = NULL;
}


//---------------------------------------------------------------------------
// USBCAMD_ReadChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ReadChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension
    )
/*++

Routine Description:

    Reads a video frame from a channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    Irp - Irp associated with this request.

    ChannelExtension - context data for this channel.

    Mdl - Mdl for this read request.

    Length - Number of bytes to read.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;
    PHW_STREAM_REQUEST_BLOCK Srb;

    USBCAMD_KdPrint (ULTRA_TRACE, ("'enter USBCAMD_ReadChannel\n"));
    //
    // make sure we don't get reads on a closed channel
    //
    StreamNumber = ChannelExtension->StreamNumber;

    ASSERT_READ(ReadExtension);
    ASSERT_CHANNEL(ChannelExtension);
    ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);
    ASSERT(ChannelExtension->ChannelPrepared == TRUE);

    Srb = ReadExtension->Srb;

    if (  ChannelExtension->RawFrameLength == 0) 
         return STATUS_INSUFFICIENT_RESOURCES;  
    //
    // for streaming on bulk pipes. we use the buffer allocated in
    // transfer extension.
    //
    if (ChannelExtension->DataPipeType == UsbdPipeTypeBulk ) {

        ReadExtension->RawFrameLength = ReadExtension->ActualRawFrameLen = 
                ChannelExtension->RawFrameLength;

        ReadExtension->RawFrameBuffer = NULL;
    }
    else { 
        if ( ChannelExtension->NoRawProcessingRequired) {
            // no buffer allocation needed. use DS allocated buffer.
            if ( ChannelExtension->RawFrameLength <=
                  ChannelExtension->VideoInfoHeader->bmiHeader.biSizeImage ){
                ReadExtension->RawFrameBuffer =
                    (PUCHAR) ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray->Data;
                ReadExtension->RawFrameLength =
                    ((PHW_STREAM_REQUEST_BLOCK) Srb)->CommandData.DataBufferArray->FrameExtent;
            }
            else 
                 return STATUS_INSUFFICIENT_RESOURCES;  
        }
        else {

            USBCAMD_KdPrint (ULTRA_TRACE, ("RawFrameLength %d\n",ChannelExtension->RawFrameLength));

            ReadExtension->RawFrameLength = ChannelExtension->RawFrameLength;

            ReadExtension->RawFrameBuffer =
                USBCAMD_AllocateRawFrameBuffer(ReadExtension->RawFrameLength);

            if (ReadExtension->RawFrameBuffer == NULL) {
                USBCAMD_KdPrint (MIN_TRACE, ("'Read alloc failed\n"));
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                return ntStatus;
            }
        }
    }
    
    USBCAMD_DbgLog(TL_SRB_TRACE, 'daeR',
        Srb,
        Srb->CommandData.DataBufferArray->Data,
        0
        );

    USBCAMD_KdPrint (MAX_TRACE, ("Que SRB (%x) S# %d.\n",
                    ReadExtension->Srb ,StreamNumber));

    ExInterlockedInsertTailList( &(ChannelExtension->PendingIoList),
                                     &(ReadExtension->ListEntry),
                                     &ChannelExtension->PendingIoListSpin);

    USBCAMD_KdPrint (ULTRA_TRACE, ("'exit USBCAMD_ReadChannel 0x%x\n", ntStatus));

    return STATUS_SUCCESS;
}

//---------------------------------------------------------------------------
// USBCAMD_StartChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION  ChannelExtension
    )
/*++

Routine Description:

    Starts the streaming process for a video channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_StartChannel\n"));

    ASSERT_CHANNEL(ChannelExtension);
    StreamNumber = ChannelExtension->StreamNumber;


    if (ChannelExtension->ImageCaptureStarted) {
        // fail the call if the channel is not in the
        // proper state.
        TRAP();
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBCAMD_StartChannel_Done;
    }

    USBCAMD_ClearIdleLock(&ChannelExtension->IdleLock);

#if DBG
    {
        ULONG i;

        ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);
        ASSERT(ChannelExtension->StreamError == FALSE);
        //ASSERT(ChannelExtension->Flags == 0);

        if ( ChannelExtension->VirtualStillPin == FALSE) {

            if (ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {
                for (i=0; i< USBCAMD_MAX_REQUEST; i++) {
                    ASSERT(ChannelExtension->TransferExtension[i].ChannelExtension != NULL);
                }
            }
        }
    }
#endif

    if ( ChannelExtension->VirtualStillPin == TRUE) {
        // check if the capture pin has started yet?
        if ( (DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
             (DeviceExtension->ChannelExtension[STREAM_Capture]->ImageCaptureStarted) ){
            ChannelExtension->ImageCaptureStarted = TRUE;
        }
        else{
            // We can't start a virtual still pin till after we start the capture pin.
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else {

        //
        // Perform a reset on the pipes
        //
        if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ){

            ntStatus = USBCAMD_ResetPipes(DeviceExtension,
                                          ChannelExtension,
                                          DeviceExtension->Interface,
                                          FALSE);
        }

        //
        // start the stream up, we don't check for errors here
        //

        if (NT_SUCCESS(ntStatus)) {

            if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ){
                ntStatus = USBCAMD_StartIsoStream(DeviceExtension, ChannelExtension);
            }
            else {
                ntStatus = USBCAMD_StartBulkStream(DeviceExtension, ChannelExtension);
            }
        }
    }

USBCAMD_StartChannel_Done:

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_StartChannel (%x)\n", ntStatus));

    USBCAMD_RELEASE(DeviceExtension);

    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_StopChannel
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StopChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    Stops the streaming process for a video channel.

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    ChannelExtension - context data for this channel.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG StreamNumber;

    USBCAMD_SERIALIZE(DeviceExtension);

    USBCAMD_KdPrint (MIN_TRACE, ("enter USBCAMD_StopChannel\n"));

    ASSERT_CHANNEL(ChannelExtension);
    StreamNumber = ChannelExtension->StreamNumber;
    ASSERT(ChannelExtension->ChannelPrepared == TRUE);
    ASSERT(DeviceExtension->ActualInstances[StreamNumber] > 0);

    if (!ChannelExtension->ImageCaptureStarted ) {
        //
        // we are not started so we just return success
        //
        USBCAMD_KdPrint (MIN_TRACE, ("stop before start -- return success\n"));
        ntStatus = STATUS_SUCCESS;
        goto USBCAMD_StopChannel_Done;
    }

    if ( ChannelExtension->DataPipeType == UsbdPipeTypeBulk ) {
        // for bulk pipes. Just make sure to cancel the current read request.
        // there is a pending IRP on this Pipe. Cancel it
        ntStatus = USBCAMD_CancelOutstandingIrp(DeviceExtension,
                                                ChannelExtension->DataPipe,
                                                FALSE);
        ChannelExtension->StreamError = FALSE;
        ChannelExtension->ImageCaptureStarted = FALSE;
        goto USBCAMD_StopChannel_Done;
    }

    //
    // first we set our stop flag
    //

    ChannelExtension->Flags |= USBCAMD_STOP_STREAM;

    //
    // now send an abort pipe for both our pipes, this should flush out any
    // transfers that are running
    //

    if ( ChannelExtension->VirtualStillPin == FALSE) {

        // we only need to abort for iso pipes.
        if ( ChannelExtension->DataPipeType == UsbdPipeTypeIsochronous ) {

            ntStatus = USBCAMD_AbortPipe(DeviceExtension,
                    DeviceExtension->Interface->Pipes[ChannelExtension->DataPipe].PipeHandle);
#if DBG
            if (NT_ERROR(ntStatus)) {
               USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_StopChannel: USBCAMD_AbortPipe(DataPipe)=0x%x\n",ntStatus));
               // TEST_TRAP(); // Can happen on surprise removal
            }
#endif
            if (ChannelExtension->SyncPipe != -1) {
                ntStatus = USBCAMD_AbortPipe(DeviceExtension,
                        DeviceExtension->Interface->Pipes[ChannelExtension->SyncPipe].PipeHandle);
                if (NT_ERROR(ntStatus)) {
                    USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_StopChannel: USBCAMD_AbortPipe(SyncPipe)=0x%x\n",ntStatus));
                    // TEST_TRAP(); // Can happen on surprise removal
                }
            }
        }
    }

    //
    // Block the stop for now, waiting for all iso irps to be completed
    //
    ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_STOP_STREAM);
    if (STATUS_TIMEOUT == ntStatus) {

        KIRQL oldIrql;
        int idx;

        // A timeout requires that we take harsher measures to stop the stream

        // Hold the spin lock while cancelling the IRPs
        KeAcquireSpinLock(&ChannelExtension->TransferSpinLock, &oldIrql);

        // Cancel the IRPs
        for (idx = 0; idx < USBCAMD_MAX_REQUEST; idx++) {

            PUSBCAMD_TRANSFER_EXTENSION TransferExtension = &ChannelExtension->TransferExtension[idx];

            if (TransferExtension->SyncIrp) {
                IoCancelIrp(TransferExtension->SyncIrp);
            }

            if (TransferExtension->DataIrp) {
                IoCancelIrp(TransferExtension->DataIrp);
            }
        }

        KeReleaseSpinLock(&ChannelExtension->TransferSpinLock, oldIrql);

        // Try waiting one more time
        ntStatus = USBCAMD_WaitForIdle(&ChannelExtension->IdleLock, USBCAMD_STOP_STREAM);
    }

    //
    // Cancel all queued read SRBs
    //
    USBCAMD_CancelQueuedSRBs(ChannelExtension);

    ChannelExtension->Flags &= ~USBCAMD_STOP_STREAM;

    //
    // clear the error state flag, we are now stopped
    //

    ChannelExtension->StreamError = FALSE;
    ChannelExtension->ImageCaptureStarted = FALSE;

USBCAMD_StopChannel_Done:


#if DBG
    USBCAMD_DebugStats(ChannelExtension);
#endif

    USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_StopChannel (%x)\n", ntStatus));
    USBCAMD_RELEASE(DeviceExtension);
    return ntStatus;
}




//---------------------------------------------------------------------------
// USBCAMD_AbortPipe
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_AbortPipe(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN USBD_PIPE_HANDLE PipeHandle
    )
/*++

Routine Description:

    Abort pending transfers for a given USB pipe.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    devcice.

    PipeHandle - usb pipe handle to abort trasnsfers for.


Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG currentUSBFrame = 0;

    USBCAMD_KdPrint (MIN_TRACE, ("enter Abort Pipe\n"));

    urb = USBCAMD_ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Status = 0;
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeHandle;

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

        USBCAMD_ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("exit Abort Pipe ntStatus(%x)\n",ntStatus));
    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_StartStream
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartIsoStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    This is the code that starts the streaming process.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    device.

Return Value:

    NT status code.

--*/
{
    ULONG i;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG CurrentUSBFrame;

#if DBG
    // initialize debug count variables
    ChannelExtension->IgnorePacketCount =
    ChannelExtension->ErrorDataPacketCount =
    ChannelExtension->ErrorSyncPacketCount =
    ChannelExtension->SyncNotAccessedCount =
    ChannelExtension->DataNotAccessedCount = 0;

    if (USBCAMD_StreamEnable == 0) {
        return ntStatus;
    }
#endif

    // ISSUE-2001/01/17-dgoll Figure out what the 10 (below) is, and give it a name
    CurrentUSBFrame =
        USBCAMD_GetCurrentFrame(DeviceExtension) + 10;

    for (i=0; i<USBCAMD_MAX_REQUEST; i++) {

        ntStatus = USBCAMD_SubmitIsoTransfer(DeviceExtension,
                                  &ChannelExtension->TransferExtension[i],
                                  CurrentUSBFrame,
                                  FALSE);

        CurrentUSBFrame +=
            USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;

    }
    if ( ntStatus == STATUS_SUCCESS) 
        ChannelExtension->ImageCaptureStarted = TRUE;
    return ntStatus;
}

//---------------------------------------------------------------------------
// USBCAMD_StartBulkStream
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_StartBulkStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    )
/*++

Routine Description:

    This is the code that starts the streaming process.

Arguments:

    DeviceExtension - Pointer to the device extension for this instance of the USB camera
                    device.

Return Value:

    NT status code.

--*/
{
  ULONG i;
  ULONG ntStatus = STATUS_SUCCESS;

#if DBG
    // initialize debug count variables
    ChannelExtension->IgnorePacketCount =
    ChannelExtension->ErrorDataPacketCount =
    ChannelExtension->ErrorSyncPacketCount =
    ChannelExtension->SyncNotAccessedCount =
    ChannelExtension->DataNotAccessedCount = 0;

#endif
    
    ChannelExtension->CurrentBulkTransferIndex = i = 0;
        
    ntStatus = USBCAMD_IntOrBulkTransfer(DeviceExtension,
                                ChannelExtension,
                                ChannelExtension->TransferExtension[i].DataBuffer,
                                ChannelExtension->TransferExtension[i].BufferLength,
                                ChannelExtension->DataPipe,
                                NULL,
                                NULL,
                                0,
                                BULK_TRANSFER);        

    if ( ntStatus == STATUS_SUCCESS) 
        ChannelExtension->ImageCaptureStarted = TRUE;

    return ntStatus;
}


//---------------------------------------------------------------------------
// USBCAMD_ControlVendorCommand
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ControlVendorCommandWorker(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData
    )
/*++

Routine Description:

    Send a vendor command to the camera to fetch data.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Request - Request code for setup packet.

    Value - Value for setup packet.

    Index - Index for setup packet.

    Buffer - Pointer to input buffer

    BufferLength - pointer size of input/output buffer (optional)

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    BOOLEAN allocated = FALSE;
    PUCHAR localBuffer;
    PUCHAR buffer;
    PURB urb;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    ULONG length = BufferLength ? *BufferLength : 0;

    USBCAMD_KdPrint (MAX_TRACE, ("'enter USBCAMD_ControlVendorCommand\n"));

    deviceExtension = USBCAMD_GET_DEVICE_EXTENSION(DeviceContext);

    buffer = USBCAMD_ExAllocatePool(NonPagedPool,
                            sizeof(struct
                            _URB_CONTROL_VENDOR_OR_CLASS_REQUEST) + length);


    if (buffer) {
        urb = (PURB) (buffer + length);

        USBCAMD_KdPrint (ULTRA_TRACE, ("'enter USBCAMD_ControlVendorCommand req %x val %x index %x\n",
            Request, Value, Index));

        if (BufferLength && *BufferLength != 0) {
            localBuffer = buffer;
            if (!GetData) {
                RtlCopyMemory(localBuffer, Buffer, *BufferLength);
            }
        } else {
            localBuffer = NULL;
        }

        UsbBuildVendorRequest(urb,
                              URB_FUNCTION_VENDOR_DEVICE,
                              sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                              GetData ? USBD_TRANSFER_DIRECTION_IN :
                                  0,
                              0,
                              Request,
                              Value,
                              Index,
                              localBuffer,
                              NULL,
                              length,
                              NULL);

        USBCAMD_KdPrint (ULTRA_TRACE, ("'BufferLength =  0x%x buffer = 0x%x\n",
            length, localBuffer));

        ntStatus = USBCAMD_CallUSBD(deviceExtension, urb,0,NULL);

        if (NT_SUCCESS(ntStatus)) {
            if (BufferLength) {
                *BufferLength =
                    urb->UrbControlVendorClassRequest.TransferBufferLength;

                USBCAMD_KdPrint (ULTRA_TRACE, ("'BufferLength =  0x%x buffer = 0x%x\n",
                    *BufferLength, localBuffer));
                if (localBuffer && GetData) {
                    RtlCopyMemory(Buffer, localBuffer, *BufferLength);
                }
            }
        }
        else {
            USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_ControlVendorCommand Error 0x%x\n", ntStatus));            

            // Only expected failure.
            // TEST_TRAP();        
        }

        USBCAMD_ExFreePool(buffer);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBCAMD_KdPrint (MIN_TRACE, ("'USBCAMD_ControlVendorCommand Error 0x%x\n", ntStatus));
    }

    return ntStatus;

}


//---------------------------------------------------------------------------
// USBCAMD_ControlVendorCommand
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_ControlVendorCommand(
    IN PVOID DeviceContext,
    IN UCHAR Request,
    IN USHORT Value,
    IN USHORT Index,
    IN PVOID Buffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN GetData,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    )
/*++

Routine Description:

    Send a vendor command to the camera to fetch data.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Request - Request code for setup packet.

    Value - Value for setup packet.

    Index - Index for setup packet.

    Buffer - Pointer to input buffer

    BufferLength - pointer size of input/output buffer (optional)

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PCOMMAND_WORK_ITEM workitem;

    USBCAMD_KdPrint (MAX_TRACE, ("'enter USBCAMD_ControlVendorCommand2\n"));

    USBCAMD_DbgLog(TL_PRF_TRACE|TL_VND_TRACE, '+dnV', Request, USBCAMD_StartClock(), 0);
    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        // we are at passive level, just do the command
        //
        ntStatus = USBCAMD_ControlVendorCommandWorker(DeviceContext,
                                                Request,
                                                Value,
                                                Index,
                                                Buffer,
                                                BufferLength,
                                                GetData);

        if (CommandComplete) {
            // call the completion handler
            (*CommandComplete)(DeviceContext, CommandContext, ntStatus);
        }

    } else {
//        TEST_TRAP();
        //
        // schedule a work item
        //
        ntStatus = STATUS_PENDING;

        workitem = USBCAMD_ExAllocatePool(NonPagedPool,
                                          sizeof(COMMAND_WORK_ITEM));
        if (workitem) {

            ExInitializeWorkItem(&workitem->WorkItem,
                                 USBCAMD_CommandWorkItem,
                                 workitem);

            workitem->DeviceContext = DeviceContext;
            workitem->Request = Request;
            workitem->Value = Value;
            workitem->Index = Index;
            workitem->Buffer = Buffer;
            workitem->BufferLength = BufferLength;
            workitem->GetData = GetData;
            workitem->CommandComplete = CommandComplete;
            workitem->CommandContext = CommandContext;

            ExQueueWorkItem(&workitem->WorkItem,
                            DelayedWorkQueue);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    USBCAMD_DbgLog(TL_PRF_TRACE|TL_VND_TRACE, '-dnV', Request, USBCAMD_StopClock(), ntStatus);

    return ntStatus;
}


VOID
USBCAMD_CommandWorkItem(
    PVOID Context
    )
/*++

Routine Description:

    Call the mini driver to convert a raw packet to the proper format.

Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus;
    PCOMMAND_WORK_ITEM workItem = Context;

    ntStatus = USBCAMD_ControlVendorCommandWorker(workItem->DeviceContext,
                                            workItem->Request,
                                            workItem->Value,
                                            workItem->Index,
                                            workItem->Buffer,
                                            workItem->BufferLength,
                                            workItem->GetData);


    if (workItem->CommandComplete) {
        // call the completion handler
        (*workItem->CommandComplete)(workItem->DeviceContext,
                                   workItem->CommandContext,
                                   ntStatus);
    }

    USBCAMD_ExFreePool(workItem);
}


NTSTATUS
USBCAMD_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_NO_MEMORY;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString(&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) +
            KeyNameStringLength + DataLength;

    fullInfo = USBCAMD_ExAllocatePool(PagedPool, length);
    USBCAMD_KdPrint(MAX_TRACE, ("' USBD_GetRegistryKeyValue buffer = 0x%p\n", (ULONG_PTR) fullInfo));

    if (fullInfo) {
        ntStatus = ZwQueryValueKey(Handle,
                        &keyName,
                        KeyValueFullInformation,
                        fullInfo,
                        length,
                        &length);

        if (NT_SUCCESS(ntStatus)){
            ASSERT(DataLength == fullInfo->DataLength);
            RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
        }

        USBCAMD_ExFreePool(fullInfo);
    }

    return ntStatus;
}

#if DBG

typedef struct _RAW_SIG {
    ULONG Sig;
    ULONG length;
} RAW_SIG, *PRAW_SIG;


PVOID
USBCAMD_AllocateRawFrameBuffer(
    ULONG RawFrameLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PRAW_SIG rawsig;
    PUCHAR pch;

    pch = USBCAMD_ExAllocatePool(NonPagedPool,
                         RawFrameLength + sizeof(*rawsig)*2);

    if (pch) {
        // begin sig
        rawsig = (PRAW_SIG) pch;
        rawsig->Sig = USBCAMD_RAW_FRAME_SIG;
        rawsig->length = RawFrameLength;


        // end sig
        rawsig = (PRAW_SIG) (pch+RawFrameLength+sizeof(*rawsig));
        rawsig->Sig = USBCAMD_RAW_FRAME_SIG;
        rawsig->length = RawFrameLength;

        pch += sizeof(*rawsig);
    }

    return pch;
}


VOID
USBCAMD_FreeRawFrameBuffer(
    PVOID RawFrameBuffer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR pch;

    USBCAMD_CheckRawFrameBuffer(RawFrameBuffer);

    pch = RawFrameBuffer;
    pch -= sizeof(RAW_SIG);

    USBCAMD_ExFreePool(pch);
}


VOID
USBCAMD_CheckRawFrameBuffer(
    PVOID RawFrameBuffer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

}

typedef struct _NODE_HEADER {
    ULONG Length;
    ULONG Sig;
} NODE_HEADER, *PNODE_HEADER;

PVOID
USBCAMD_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )
{
    PNODE_HEADER tmp;

    tmp = ExAllocatePoolWithTag(PoolType, NumberOfBytes+sizeof(*tmp), 'MACU');

    if (tmp) {
        USBCAMD_HeapCount += NumberOfBytes;
        tmp->Length = NumberOfBytes;
        tmp->Sig = 0xDEADBEEF;
        tmp++;
    }

    USBCAMD_KdPrint(MAX_TRACE, ("'USBCAMD_ExAllocatePool(%d, %d[%d])=0x%p[0x%p]\n", 
    PoolType, NumberOfBytes, NumberOfBytes+sizeof(*tmp), (void *)tmp, (void *)(tmp-1) ));

    return tmp;
}


VOID
USBCAMD_ExFreePool(
    IN PVOID p
    )
{
    PNODE_HEADER tmp = p;

    tmp--;
    ASSERT(tmp->Sig == 0xDEADBEEF);
    tmp->Sig = 0;

    USBCAMD_HeapCount-=tmp->Length;

    USBCAMD_KdPrint(MAX_TRACE, ("'USBCAMD_ExFreePool(0x%p[0x%p]) = %d[%d] Bytes\n", 
    (void *)(tmp+1), (void *)tmp, tmp->Length, tmp->Length + sizeof(*tmp) ) );

    ExFreePool(tmp);

}

#endif

//---------------------------------------------------------------------------
// USBCAMD_SetDevicePowerState
//---------------------------------------------------------------------------
NTSTATUS
USBCAMD_SetDevicePowerState(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

Arguments:

    DeviceExtension - points to the driver specific DeviceExtension

    DevicePowerState - Device power state to enter.

Return Value:

    NT status code

--*/
{
    PPOWERUP_WORKITEM workitem;
    DEVICE_POWER_STATE DevicePowerState;
    NTSTATUS ntStatus;
    
    ntStatus = STATUS_SUCCESS;
    DevicePowerState = Srb->CommandData.DeviceState;

    USBCAMD_KdPrint (MAX_TRACE, ("enter SetDevicePowerState\n"));

    if (DeviceExtension->CurrentPowerState == DevicePowerState) {
        return ntStatus;
    }

    USBCAMD_KdPrint (MIN_TRACE, ("Switching from %s to %s\n",
                                 PnPDevicePowerStateString(DeviceExtension->CurrentPowerState),
                                 PnPDevicePowerStateString(DevicePowerState)));                      

    switch (DevicePowerState ) {
    case PowerDeviceD0:
        //
        // we can't talk to usb stack till the Powerup IRP assocaited with this 
        // SRB is completed by everybody on the USB stack.
        // Schedule a delay work item to complete the powerup later.
        //
          
        USBCAMD_KdPrint (MAX_TRACE, ("Starting D0 powerup - part one.\n"));
        
        // start iso stream if any.
        if ((DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
            (DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipeType == UsbdPipeTypeIsochronous )){
    
            //
            // Queue a delayed work item
            //
            USBCAMD_KdPrint (MAX_TRACE,("Queuing delayed powerup workitem to restart iso stream \n"));
            workitem = USBCAMD_ExAllocatePool(NonPagedPool,sizeof(POWERUP_WORKITEM));

            if (workitem) {
                ExInitializeWorkItem(&workitem->WorkItem,USBCAMD_PowerUpWorkItem,workitem);
                workitem->DeviceExtension = DeviceExtension;
                DeviceExtension->InPowerTransition = TRUE;
                ExQueueWorkItem(&workitem->WorkItem,DelayedWorkQueue);
            } 
            else 
            {
                TEST_TRAP();
            }
        USBCAMD_KdPrint (MAX_TRACE, ("Ending D0 powerup - part one.\n"));
        }                   
        break;
        
    case PowerDeviceD1:
    case PowerDeviceD2:
        break;

    case PowerDeviceD3:

        USBCAMD_KdPrint (MAX_TRACE, ("Starting D3 powerdown.\n", 
            PnPDevicePowerStateString(DeviceExtension->CurrentPowerState)));

        if ( DeviceExtension->CurrentPowerState == PowerDeviceD0 )
        {   
            // stop iso stream if any.
            if ((DeviceExtension->ChannelExtension[STREAM_Capture] != NULL) &&
                (DeviceExtension->ChannelExtension[STREAM_Capture]->DataPipeType == UsbdPipeTypeIsochronous ) &&
                (DeviceExtension->ChannelExtension[STREAM_Capture]->KSState == KSSTATE_RUN ||
                 DeviceExtension->ChannelExtension[STREAM_Capture]->KSState == KSSTATE_PAUSE) ){
            
            USBCAMD_KdPrint (MIN_TRACE, ("Stopping ISO stream before powerdown.\n"));
            USBCAMD_ProcessSetIsoPipeState(DeviceExtension,
                                        DeviceExtension->ChannelExtension[STREAM_Capture],
                                        USBCAMD_STOP_STREAM);

            if (DeviceExtension->Usbcamd_version == USBCAMD_VERSION_200) 

                // send hardware stop
                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData2.CamStopCaptureEx)(
                            DeviceExtension->StackDeviceObject,
                            USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension),
                                    STREAM_Capture);
            else 
                // send hardware stop
                ntStatus = (*DeviceExtension->DeviceDataEx.DeviceData.CamStopCapture)(
                             DeviceExtension->StackDeviceObject,
                             USBCAMD_GET_DEVICE_CONTEXT(DeviceExtension));

            do {
                LARGE_INTEGER DelayTime = {(ULONG)(-8*SECONDS), -1};

                USBCAMD_KdPrint (MIN_TRACE, ("Waiting %d ms for pending USB I/O to timeout....\n", 
                                 (long)DelayTime.LowPart / MILLISECONDS ));
                KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
            }
            while ( KeReadStateSemaphore(&DeviceExtension->CallUSBSemaphore) == 0 );

            USBCAMD_KdPrint (MIN_TRACE, ("Done waiting for pending USB I/O to timeout.\n"));
            }
        USBCAMD_KdPrint (MAX_TRACE, ("Finished D3 powerdown.\n"));
        }   
        ntStatus = STATUS_SUCCESS;
        break;

    default:
        ntStatus = STATUS_NOT_SUPPORTED;
        break;
    }

    DeviceExtension->CurrentPowerState = DevicePowerState;
    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_SetDevicePowerState()=0x%x\n", ntStatus));
    return ntStatus;
}



VOID
USBCAMD_PowerUpWorkItem(
    PVOID Context
)
/*++

Routine Description:


Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus;
    LARGE_INTEGER DelayTime = {(ULONG)(-8 * SECONDS), -1};
    PPOWERUP_WORKITEM pWorkItem = Context;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension = pWorkItem->DeviceExtension;
    PUSBCAMD_CHANNEL_EXTENSION pChExt = DeviceExtension->ChannelExtension[STREAM_Capture];


    USBCAMD_KdPrint (MAX_TRACE, ("Starting D0 powerup - part two.\n"));
    USBCAMD_KdPrint (MIN_TRACE, ("Delaying for %d ms for USB stack to powerup.\n",
        (long)DelayTime.LowPart / MILLISECONDS ));

    KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);

    USBCAMD_KdPrint (MAX_TRACE, ("Continuing D0 powerup - part two.\n"));

    DeviceExtension->InPowerTransition = FALSE;

        // Make sure we don't try to startup the ISO stream if we have been shutdown while waiting (by WIA?)
    if ( ( pChExt != NULL) &&
         ( pChExt->DataPipeType == UsbdPipeTypeIsochronous ) &&
         ( ( pChExt->KSState == KSSTATE_PAUSE ) || ( pChExt->KSState == KSSTATE_RUN ) ) ) {
        USBCAMD_KdPrint (MIN_TRACE, ("Restarting ISO stream after powerup.\n"));
        USBCAMD_ProcessSetIsoPipeState( DeviceExtension, pChExt, USBCAMD_START_STREAM);
    }

    USBCAMD_ExFreePool(pWorkItem);
    USBCAMD_KdPrint (MAX_TRACE, ("Finished D0 powerup - part two.\n"));
}

VOID
USBCAMD_InitializeIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to initialize the idle lock on a channel.

--*/
{
    // Allow transfers
    Lock->IdleLock = FALSE;

    // Nobody waiting
    Lock->Waiting = 0;

    // No active transfers
    Lock->Busy = 0;

    // Initialize an event that only lets one thread through at a time
    KeInitializeEvent(&Lock->IdleEvent, SynchronizationEvent, FALSE);

    return;
}

NTSTATUS
USBCAMD_AcquireIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to acquire the idle lock for a channel.
    While the lock is held, clients can assume that there are outstanding
    transfer requests to be completed.

    The lock should be acquired immediately before sending a data or sync
    Irp down, and released each time an Irp completes.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    Returns whether or not the idle lock was obtained. If successful, the caller
    may continue with the transfer request.

    If not successful the lock was not obtained. The caller should abort the
    work, as the channel is being stopped

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    // Attempt to go into (or stay in) the busy state
    InterlockedIncrement(&Lock->Busy);

    // Check if waiting to go idle
    if (Lock->IdleLock) {

        USBCAMD_KdPrint (MIN_TRACE, ("Failing IdleLock acquire: waiting for idle\n"));

        // Reverse our attempt
        if (InterlockedDecrement(&Lock->Busy) == 0) {

            InterlockedIncrement(&Lock->Waiting);

            if (InterlockedDecrement(&Lock->Waiting) != 0) {

                KeSetEvent(&Lock->IdleEvent, 0, FALSE);
            }
        }

        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

VOID
USBCAMD_ReleaseIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called to release the idle lock on the channel. It must be
    called when a data or sync Irp completes on a channel.

    When the lock count reduces to zero, this routine will check the waiting
    count, and signal the event if the count was non-zero.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    none

--*/

{
    // Decrement the outstanding transfer requests, and check if this was the last one
    if (InterlockedDecrement(&Lock->Busy) == 0) {

        InterlockedIncrement(&Lock->Waiting);

        if (InterlockedDecrement(&Lock->Waiting) != 0) {

            KeSetEvent(&Lock->IdleEvent, 0, FALSE);
        }
    }

    return;
}

NTSTATUS
USBCAMD_WaitForIdle(
    IN OUT PUSBCAMD_IDLE_LOCK Lock,
    IN LONG Flag
    )
/*++

Routine Description:

    This routine is called when the client would like to stop all
    transfers on a channel, and wait for outstanding transfers to
    complete. When resetting the stream, the idle lock is blocked
    while waiting, then unblocked. When stopping the stream, the idle
    lock is blocked until explicitely unblocked with the
    USBCAMD_ClearIdleLock routine. The input Flag indicates whether
    stopping or resetting. Note that this routine could be active
    for both flag values. In that case, the USBCAMD_STOP_STREAM takes
    precedence.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.
    Flag - Either USBCAMD_STOP_STREAM or USBCAMD_RESET_STREAM

Return Value:

    none

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    InterlockedIncrement(&Lock->Waiting);
    InterlockedIncrement(&Lock->Busy);

    switch (Flag) {

    case USBCAMD_RESET_STREAM:
        // When resetting the stream, conditionally set the IdleLock
        InterlockedCompareExchange(&Lock->IdleLock, USBCAMD_RESET_STREAM, 0);
        break;

    case USBCAMD_STOP_STREAM:
        // When stopping the stream, always set the IdleLock
        InterlockedExchange(&Lock->IdleLock, USBCAMD_STOP_STREAM);
        break;
    }

    // See if there are any outstanding transfer requests
    if (InterlockedDecrement(&Lock->Busy) != 0) {
        LARGE_INTEGER Timeout = {(ULONG)(-4 * SECONDS), -1};

        USBCAMD_KdPrint (MIN_TRACE, ("Waiting for idle state\n"));
        USBCAMD_DbgLog(TL_IDL_WARNING, '+ 8W', Lock, Flag, 0);

        // Wait for them to finish
        ntStatus = KeWaitForSingleObject(
            &Lock->IdleEvent,
            Executive,
            KernelMode,
            FALSE,
            &Timeout
            );

        USBCAMD_DbgLog(TL_IDL_WARNING, '- 8W', Lock, Flag, ntStatus);
    }

    if (STATUS_SUCCESS == ntStatus) {

        switch (Flag) {

        case USBCAMD_RESET_STREAM:
            // When resetting the stream, conditionally clear the IdleLock
            Flag = InterlockedCompareExchange(&Lock->IdleLock, 0, USBCAMD_RESET_STREAM);
#if DBG
            switch (Flag) {
            case USBCAMD_RESET_STREAM:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream reset in progress\n"));
                break;

            case USBCAMD_STOP_STREAM:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream stop in progress\n"));
                break;

            default:
                USBCAMD_KdPrint (MIN_TRACE, ("Idle state, unexpected IdleLock value\n"));
            }
#endif
            break;

        case USBCAMD_STOP_STREAM:
            // When stopping the stream, never clear the IdleLock
            USBCAMD_KdPrint (MIN_TRACE, ("Idle state, stream stop in progress\n"));
            break;
        }

        // See if anyone else is waiting
        if (InterlockedDecrement(&Lock->Waiting) != 0) {

            // Let them go
            KeSetEvent(&Lock->IdleEvent, 0, FALSE);
        }
    }
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Timeout waiting for idle state, not going idle\n"));
        InterlockedDecrement(&Lock->Waiting);
    }

    return ntStatus;
}

VOID
USBCAMD_ClearIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    )
/*++

Routine Description:

    This routine is called when the client is completely finished
    with stopping transfers on a channel.

Arguments:

    Lock - A pointer to an initialized USBCAMD_IDLE_LOCK structure.

Return Value:

    none

--*/
{
    // Clear the IdleLock
    InterlockedExchange(&Lock->IdleLock, 0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\iso.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   iso.c

Abstract:

   Isochronous transfer code for usbcamd USB camera driver

Environment:

    kernel mode only

Author:

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:



--*/

#include "usbcamd.h"

#define COPY_Y 0
#define COPY_U 1
#define COPY_V 2



#if DBG
// some global debug variables
ULONG USBCAMD_VideoFrameStop = 0;
#endif

NTSTATUS
USBCAMD_InitializeIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG index
    )
/*++

Routine Description:

    Initializes an Iso transfer, an iso transfer consists of two parallel iso 
    requests, one on the sync pipe and one on the data pipe.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    ChannelExtension - extension specific to this video channel

    InterfaceInformation - pointer to USBD interface information structure 
        describing the currently active interface.

    TransferExtension - context information associated with this transfer set.        


Return Value:

    NT status code

--*/
{
    PUSBCAMD_TRANSFER_EXTENSION TransferExtension = &ChannelExtension->TransferExtension[index];
    PUSBD_INTERFACE_INFORMATION InterfaceInformation = DeviceExtension->Interface;
    ULONG workspace;
    ULONG packetSize;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG offset = 0;
    
    ASSERT_CHANNEL(ChannelExtension);
       
    USBCAMD_KdPrint (MAX_TRACE, ("enter USBCAMD_InitializeIsoTransfer\n"));

    if ( ChannelExtension->VirtualStillPin ) {
        PUSBCAMD_TRANSFER_EXTENSION VideoTransferExtension;
        PUSBCAMD_CHANNEL_EXTENSION  VideoChannelExtension;

        // for virtual still pin, transfer extension should point to the same 
        // data & synch buffers as the video transfer ext.
        VideoChannelExtension = DeviceExtension->ChannelExtension[STREAM_Capture];
        VideoTransferExtension = &VideoChannelExtension->TransferExtension[index];
        RtlCopyMemory(TransferExtension,
                      VideoTransferExtension,
                      sizeof(USBCAMD_TRANSFER_EXTENSION));
        TransferExtension->ChannelExtension = ChannelExtension;
        TransferExtension->SyncIrp = TransferExtension->DataIrp = NULL;
        return STATUS_SUCCESS;
    }

    //
    // allocate some contiguous memory for this request
    //

    TransferExtension->Sig = USBCAMD_TRANSFER_SIG;     
    TransferExtension->DeviceExtension = DeviceExtension;
    TransferExtension->ChannelExtension = ChannelExtension;

    packetSize = InterfaceInformation->Pipes[ChannelExtension->DataPipe].MaximumPacketSize;
    // chk if client driver still using alt. setting 0.
    if (packetSize == 0) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        return ntStatus;
    }
    
    TransferExtension->BufferLength = 
        (packetSize*USBCAMD_NUM_ISO_PACKETS_PER_REQUEST) + USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;

    TransferExtension->SyncBuffer =       
        TransferExtension->DataBuffer =  
            USBCAMD_ExAllocatePool(NonPagedPool, 
                                   TransferExtension->BufferLength);       

    if (TransferExtension->SyncBuffer == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBCAMD_InitializeIsoTransfer_Done;
    }

    //
    // allow for one byte packets on the sync stream
    //
    
    TransferExtension->DataBuffer += USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;   

    USBCAMD_KdPrint (ULTRA_TRACE, ("Data Buffer = 0x%x\n", TransferExtension->DataBuffer));
    USBCAMD_KdPrint (ULTRA_TRACE, ("Sync Buffer = 0x%x\n", TransferExtension->SyncBuffer));

    //
    // allocate working space
    //

    workspace = GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST)*2;

    TransferExtension->WorkBuffer = USBCAMD_ExAllocatePool(NonPagedPool, workspace);
       
    if (TransferExtension->WorkBuffer) {

        TransferExtension->SyncUrb = 
            (PURB) TransferExtension->WorkBuffer; 
    
        TransferExtension->DataUrb = 
            (PURB) (TransferExtension->WorkBuffer + 
            GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        //MmFreeContiguousMemory(TransferExtension->SyncBuffer);
        USBCAMD_ExFreePool(TransferExtension->SyncBuffer);
        TransferExtension->SyncBuffer = NULL;
    }

USBCAMD_InitializeIsoTransfer_Done:
#if DBG
    if (ntStatus != STATUS_SUCCESS)
        USBCAMD_KdPrint (MIN_TRACE, ("exit USBCAMD_InitializeIsoTransfer 0x%x\n", ntStatus));
#endif

    return ntStatus;
}


NTSTATUS
USBCAMD_FreeIsoTransfer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    )
/*++

Routine Description:

    Opposite of USBCAMD_InitializeIsoTransfer, frees resources allocated for an 
    iso transfer.

Arguments:

    ChannelExtension - extension specific to this video channel

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

Return Value:

    NT status code

--*/
{
    ASSERT_TRANSFER(TransferExtension);
    ASSERT_CHANNEL(ChannelExtension);
  
    USBCAMD_KdPrint (MAX_TRACE, ("Free Iso Transfer\n"));

    //
    // now free memory, SyncBuffer pointer holds the pool pointer for both sync and data buffers
    //

    if (TransferExtension->SyncBuffer) {
        USBCAMD_ExFreePool(TransferExtension->SyncBuffer);
        TransferExtension->SyncBuffer = NULL;
    }

    if (TransferExtension->WorkBuffer) {
        USBCAMD_ExFreePool(TransferExtension->WorkBuffer);
        TransferExtension->WorkBuffer = NULL;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
USBCAMD_SubmitIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG StartFrame,
    IN BOOLEAN Asap
    )
/*++

Routine Description:

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

    StartFrame - usb frame number to begin transmiting this pair of iso 
        requests.

    Asap - if false transfers are started on StartFrame otherwise they are 
        scheduled to start after the current transfer queued for the endpoint.            

Return Value:

    NT status code

--*/
{
    PUSBCAMD_CHANNEL_EXTENSION channelExtension = TransferExtension->ChannelExtension;
    KIRQL oldIrql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT_TRANSFER(TransferExtension);
    ASSERT_CHANNEL(channelExtension);

    if (!DeviceExtension->Initialized || !TransferExtension->SyncBuffer) {
        return STATUS_DEVICE_DATA_ERROR;
    }

    RtlZeroMemory(TransferExtension->SyncBuffer,
        USBCAMD_NUM_ISO_PACKETS_PER_REQUEST);

    // Hold the spin lock while creating the IRPs
    KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);
    ASSERT(!TransferExtension->SyncIrp && !TransferExtension->DataIrp);

    // Allocate the IRPs separately from the rest of the logic
    if (channelExtension->SyncPipe != -1) {

        TransferExtension->SyncIrp = USBCAMD_BuildIoRequest(
            DeviceExtension,
            TransferExtension,
            TransferExtension->SyncUrb,
            USBCAMD_IsoIrp_Complete
            );
        if (TransferExtension->SyncIrp) {
            ntStatus = USBCAMD_AcquireIdleLock(&channelExtension->IdleLock);
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }                                         

    if (STATUS_SUCCESS == ntStatus) {

        TransferExtension->DataIrp = USBCAMD_BuildIoRequest(
            DeviceExtension,
            TransferExtension,
            TransferExtension->DataUrb,
            USBCAMD_IsoIrp_Complete
            );
        if (TransferExtension->DataIrp) {
            ntStatus = USBCAMD_AcquireIdleLock(&channelExtension->IdleLock);
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
                              
    if (STATUS_SUCCESS == ntStatus) {

        if (TransferExtension->SyncIrp) {

            USBCAMD_InitializeIsoUrb(
                DeviceExtension, 
                TransferExtension->SyncUrb, 
                &DeviceExtension->Interface->Pipes[channelExtension->SyncPipe],
                TransferExtension->SyncBuffer
                );
            if (Asap) {
                // set the asap flag
                TransferExtension->SyncUrb->UrbIsochronousTransfer.TransferFlags |=
                    USBD_START_ISO_TRANSFER_ASAP;
            }
            else {
                // clear asap flag
                TransferExtension->SyncUrb->UrbIsochronousTransfer.TransferFlags &=
                    (~USBD_START_ISO_TRANSFER_ASAP);
                // set the start frame
                TransferExtension->SyncUrb->UrbIsochronousTransfer.StartFrame = StartFrame;
            }

            ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject, TransferExtension->SyncIrp);
        }

        // STATUS_PENDING (from SyncIrp if any) is considered successful
        if (NT_SUCCESS(ntStatus)) {

            USBCAMD_InitializeIsoUrb(
                DeviceExtension,
                TransferExtension->DataUrb,
                &DeviceExtension->Interface->Pipes[channelExtension->DataPipe],
                TransferExtension->DataBuffer
                );

            if (Asap) {
                // set the asap flag
                TransferExtension->DataUrb->UrbIsochronousTransfer.TransferFlags |=
                    USBD_START_ISO_TRANSFER_ASAP;
            }
            else {
                // clear asap flag
                TransferExtension->DataUrb->UrbIsochronousTransfer.TransferFlags &=
                    (~USBD_START_ISO_TRANSFER_ASAP);
                TransferExtension->DataUrb->UrbIsochronousTransfer.StartFrame = StartFrame;
            }

            ntStatus = IoCallDriver(DeviceExtension->StackDeviceObject, TransferExtension->DataIrp);
            if (STATUS_PENDING == ntStatus) {
                ntStatus = STATUS_SUCCESS;
            }
        }
        else {

            USBCAMD_KdPrint (MIN_TRACE, ("USBD failed the SyncIrp = 0x%x\n", ntStatus));

            KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

            // we haven't sent the DataIrp yet, so we can free it here
            IoFreeIrp(TransferExtension->DataIrp),
            TransferExtension->DataIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);

            KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
        }
    }
    else {

        KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

        if (TransferExtension->SyncIrp) {

            IoFreeIrp(TransferExtension->SyncIrp);
            TransferExtension->SyncIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
        }

        if (TransferExtension->DataIrp) {

            IoFreeIrp(TransferExtension->DataIrp);
            TransferExtension->DataIrp = NULL;

            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
        }

        KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
    }

    return ntStatus;
}


NTSTATUS
USBCAMD_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP, if this is
    the second irp of a transfer pair then the TransferComplete routine is 
    called to process the urbs associated with both irps in the transfer.  

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context, points to a transfer extension structure 
        for a pair of parallel iso requests.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBCAMD_TRANSFER_EXTENSION transferExtension;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;

    BOOLEAN TransferComplete;
    KIRQL oldIrql;
   
    USBCAMD_KdPrint (ULTRA_TRACE, ("enter USBCAMD_IsoIrp_Complete = 0x%x\n", Irp));
   
    transferExtension = Context;
    channelExtension = transferExtension->ChannelExtension;
    deviceExtension = transferExtension->DeviceExtension;
    
    ASSERT_TRANSFER(transferExtension);
    ASSERT_CHANNEL(channelExtension);

    // Hold the spin lock while checking and clearing the IRP pointers
    KeAcquireSpinLock(&channelExtension->TransferSpinLock, &oldIrql);

    if (Irp == transferExtension->SyncIrp) {
        transferExtension->SyncIrp = NULL;
    }
    else
    if (Irp == transferExtension->DataIrp) {
        transferExtension->DataIrp = NULL;
    }
#if DBG
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Unexpected IRP = 0x%x!\n", Irp));
    }
#endif

    // Save the transfer state before releasing the spin lock
    TransferComplete = (!transferExtension->SyncIrp && !transferExtension->DataIrp);

    KeReleaseSpinLock(&channelExtension->TransferSpinLock, oldIrql);
                              
    if (!(channelExtension->Flags & USBCAMD_STOP_STREAM) && !channelExtension->StreamError) {

        if (!Irp->Cancel) {

            if (STATUS_SUCCESS == Irp->IoStatus.Status) {

                if (TransferComplete) {

                    NTSTATUS ntStatus = STATUS_SUCCESS;

                    //
                    // all irps completed for transfer
                    //

                    USBCAMD_KdPrint (ULTRA_TRACE, ("pending Irps Completed for transfer\n"));

                    if (transferExtension->DataUrb->UrbIsochronousTransfer.Hdr.Status ) {
                         USBCAMD_KdPrint (MIN_TRACE, ("Isoch DataUrb Transfer Failed #1, status = 0x%X\n",
                                            transferExtension->DataUrb->UrbIsochronousTransfer.Hdr.Status ));
                         USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
                         ntStatus = STATUS_UNSUCCESSFUL;                                  
                    }
                    if (channelExtension->SyncPipe != -1) {
                        if (transferExtension->SyncUrb->UrbIsochronousTransfer.Hdr.Status ) {
                            USBCAMD_KdPrint (MIN_TRACE, ("Isoch SynchUrb Transfer Failed #2, status = 0x%X\n",
                                           transferExtension->SyncUrb->UrbIsochronousTransfer.Hdr.Status ));
                            USBCAMD_ProcessResetRequest(deviceExtension,channelExtension); 
                            ntStatus = STATUS_UNSUCCESSFUL;
                        }
                    }                

                    if (STATUS_SUCCESS == ntStatus) {

                        //
                        // Call the comnpletion handler for this transfer
                        //

                        USBCAMD_TransferComplete(transferExtension);
                    }
                }
            }
            else {

                USBCAMD_KdPrint(MIN_TRACE, ("Isoch Urb Transfer Failed, status = 0x%X\n",
                   Irp->IoStatus.Status ));

                USBCAMD_ProcessResetRequest(deviceExtension, channelExtension); 
            }
        }
        else {

            // Cancellation is not an error
            USBCAMD_KdPrint (MIN_TRACE, ("*** ISO IRP CANCELLED ***\n"));
        }
    }
#if DBG
    else {

        USBCAMD_KdPrint (MIN_TRACE, ("Iso IRP completed in stop or error state\n"));
    }
#endif

    // We're done with this IRP, so free it
    IoFreeIrp(Irp);

    // This must be released here, rather than at the beginning of the
    // completion routine, in order to avoid false idle indication
    USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);

    return STATUS_MORE_PROCESSING_REQUIRED;      
}                    


PIRP
USBCAMD_BuildIoRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    Allocate an Irp and attach a urb to it.
    
Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    TransferExtension - context information for this transfer (pair of iso 
        urbs or one interrupt/bulk urb).

    Urb - Urb to attach to this irp.

Return Value:

    Allocated irp or NULL.

--*/    
{
    CCHAR stackSize;
    PIRP irp;
    PIO_STACK_LOCATION nextStack;

    stackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize );

    irp = IoAllocateIrp(stackSize,
                        FALSE);
    if (irp == NULL) {
        USBCAMD_KdPrint(MIN_TRACE, ("USBCAMD_BuildIoRequest: Failed to create an IRP.\n"));
        return irp;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_INTERNAL_USB_SUBMIT_URB;                    
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(irp,
            CompletionRoutine,
            TransferExtension,
            TRUE,
            TRUE,
            TRUE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    return irp;
}


NTSTATUS
USBCAMD_InitializeIsoUrb(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN OUT PURB Urb,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    Packetizes a buffer and initializes an iso urb request based on 
        charateristics of the input USB pipe.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

    Urb - iso urb to initialize.

    PipeInformation - Usbd pipe information for the pipe this urb will be 
        submitted to.

    Buffer - Data buffer to packetize for this request

Return Value:

    NT status code.

--*/
{
    ULONG packetSize = PipeInformation->MaximumPacketSize;
    ULONG i;

    USBCAMD_KdPrint (MAX_TRACE, ("enter USBCAMD_InitializeIsoUrb = 0x%x packetSize = 0x%x\n",
        Urb, packetSize, PipeInformation->PipeHandle));

    USBCAMD_KdPrint (ULTRA_TRACE, ("handle = 0x%x\n", PipeInformation->PipeHandle));        
        
    RtlZeroMemory(Urb, GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST));
    
    Urb->UrbIsochronousTransfer.Hdr.Length = 
                GET_ISO_URB_SIZE(USBCAMD_NUM_ISO_PACKETS_PER_REQUEST);
    Urb->UrbIsochronousTransfer.Hdr.Function = 
                URB_FUNCTION_ISOCH_TRANSFER;
    Urb->UrbIsochronousTransfer.PipeHandle = 
                PipeInformation->PipeHandle;
    Urb->UrbIsochronousTransfer.TransferFlags = 
                USBD_START_ISO_TRANSFER_ASAP | USBD_TRANSFER_DIRECTION_IN;
                
    Urb->UrbIsochronousTransfer.NumberOfPackets = USBCAMD_NUM_ISO_PACKETS_PER_REQUEST;
    Urb->UrbIsochronousTransfer.UrbLink = NULL;

    for (i=0; i< Urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
        Urb->UrbIsochronousTransfer.IsoPacket[i].Offset
                    = i * packetSize;
    }

    Urb->UrbIsochronousTransfer.TransferBuffer = Buffer;
        
    Urb->UrbIsochronousTransfer.TransferBufferMDL = NULL;
    Urb->UrbIsochronousTransfer.TransferBufferLength = 
        Urb->UrbIsochronousTransfer.NumberOfPackets * packetSize;     

    USBCAMD_KdPrint (MAX_TRACE, ("Init Iso Urb Length = 0x%x buf = 0x%x start = 0x%x\n", 
        Urb->UrbIsochronousTransfer.TransferBufferLength,
        Urb->UrbIsochronousTransfer.TransferBuffer,
        Urb->UrbIsochronousTransfer.StartFrame));     

    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_InitializeIsoUrb\n"));        


    return STATUS_SUCCESS;        
}


ULONG
USBCAMD_GetCurrentFrame(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Get the current USB frame number.

Arguments:

    DeviceExtension - pointer to the device extension for this instance of the USB camera
                    devcice.

Return Value:

    Current Frame Number

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    ULONG currentUSBFrame = 0;

    urb = USBCAMD_ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER));
                         
    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_GET_CURRENT_FRAME_NUMBER);
        urb->UrbHeader.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;

        ntStatus = USBCAMD_CallUSBD(DeviceExtension, urb,0,NULL);

        USBCAMD_KdPrint (MAX_TRACE, ("Current Frame = 0x%x\n", 
            urb->UrbGetCurrentFrameNumber.FrameNumber));

        if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(URB_STATUS(urb))) {
            currentUSBFrame = urb->UrbGetCurrentFrameNumber.FrameNumber;
        }

        USBCAMD_ExFreePool(urb);
        
    } else {
        USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_GetCurrentFrame: USBCAMD_ExAllocatePool(%d) failed!\n", 
                         sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER) ) ); 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;       
    }       

    USBCAMD_KdPrint (MAX_TRACE, ("exit USBCAMD_GetCurrentFrame status = 0x%x current frame = 0x%x\n", 
        ntStatus, currentUSBFrame));    


    // TRAP_ERROR(ntStatus);
    
    return currentUSBFrame;         
}   


NTSTATUS
USBCAMD_TransferComplete(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    )
/*++

Routine Description:

    Called when the both the data and sync request are complete for a transfer
    this is the guts of the stream processing code.

Arguments:

    TransferExtension - context information for this transfer (pair of iso 
        urbs).

Return Value:

    NT status code.

--*/    
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    ULONG numPackets, i;
    PLIST_ENTRY listEntry;
    ULONG packetSize;
    BOOLEAN nextFrameIsStill;
    ULONG receiveLength = 0;
    PURB syncUrb, dataUrb;
    PVOID pCamSrbExt;

    ASSERT_TRANSFER(TransferExtension);
    deviceExtension = TransferExtension->DeviceExtension;
    

    packetSize = 
        deviceExtension->Interface->Pipes[TransferExtension->ChannelExtension->DataPipe].MaximumPacketSize;

    // 
    // walk through the buffer extracting video frames
    //
    numPackets = 
        TransferExtension->DataUrb->UrbIsochronousTransfer.NumberOfPackets;

#if DBG
    if (TransferExtension->SyncUrb && TransferExtension->ChannelExtension->SyncPipe != -1) {
        ASSERT(TransferExtension->SyncUrb->UrbIsochronousTransfer.NumberOfPackets ==
                TransferExtension->DataUrb->UrbIsochronousTransfer.NumberOfPackets);        
    }  
#endif    

    USBCAMD_KdPrint (ULTRA_TRACE, ("Transfer req. completed \n"));
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeAcquireSpinLockAtDpcLevel(&TransferExtension->ChannelExtension->CurrentRequestSpinLock);

    for (i=0; i<numPackets; i++) {               
        syncUrb = TransferExtension->SyncUrb;
        dataUrb = TransferExtension->DataUrb;

#if DBG   
        //
        // DEBUG stats
        //
        // keep a count of the number of packets processed for this
        // vid frame.
        //
        if (USBCAMD_VideoFrameStop &&
            TransferExtension->ChannelExtension->FrameCaptured == USBCAMD_VideoFrameStop) {
            //
            // This will cause us to stop when we begin processing 
            // video frame number x where x=USBCAMD_VideoFrameStop
            //
            
            TRAP();
        }           

        if (syncUrb && USBD_ERROR(syncUrb->UrbIsochronousTransfer.IsoPacket[i].Status)
            && TransferExtension->ChannelExtension->SyncPipe != -1) {
            TransferExtension->ChannelExtension->ErrorSyncPacketCount++;    
        }            

        if (USBD_ERROR(dataUrb->UrbIsochronousTransfer.IsoPacket[i].Status)) {
            TransferExtension->ChannelExtension->ErrorDataPacketCount++;    
        }            

        if (syncUrb && 
            (syncUrb->UrbIsochronousTransfer.IsoPacket[i].Status & 0x0FFFFFFF)
              == (USBD_STATUS_NOT_ACCESSED & 0x0FFFFFFF) && 
              TransferExtension->ChannelExtension->SyncPipe != -1) {   
            TransferExtension->ChannelExtension->SyncNotAccessedCount++;    
        }            

        if ((dataUrb->UrbIsochronousTransfer.IsoPacket[i].Status & 0x0FFFFFFF)
            == (USBD_STATUS_NOT_ACCESSED & 0x0FFFFFFF)) {   
            TransferExtension->ChannelExtension->DataNotAccessedCount++;    
        }       

#endif    

        // process the packet
        TransferExtension->newFrame = FALSE;
//        TransferExtension->nextFrameIsStill = FALSE;
        TransferExtension->ValidDataOffset= 0; // offset of which we will start copying from this pckt.
        TransferExtension->PacketFlags = 0;
        if ( deviceExtension->ChannelExtension[STREAM_Still] && 
             deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
            pCamSrbExt = USBCAMD_GET_FRAME_CONTEXT(deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest) ;
        }
        else if (TransferExtension->ChannelExtension->CurrentRequest ){
            pCamSrbExt = USBCAMD_GET_FRAME_CONTEXT(TransferExtension->ChannelExtension->CurrentRequest);
        }
        else {
            pCamSrbExt = NULL;
        }

        if ( deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
            receiveLength =  (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessUSBPacketEx)(
                deviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                pCamSrbExt,
                &syncUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->SyncBuffer+i,
                &dataUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->DataBuffer + 
                   TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset,
                &TransferExtension->newFrame,
                &TransferExtension->PacketFlags,
                &TransferExtension->ValidDataOffset);                    
        }
        else{
            receiveLength =  (*deviceExtension->DeviceDataEx.DeviceData.CamProcessUSBPacket)(
                deviceExtension->StackDeviceObject,
                USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                pCamSrbExt,
                &syncUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->SyncBuffer+i,
                &dataUrb->UrbIsochronousTransfer.IsoPacket[i],
                TransferExtension->DataBuffer + 
                   TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset,
                &TransferExtension->newFrame,
                &nextFrameIsStill);   
            // 
            // set validdataoffset to zero for compatibility.
            //
            TransferExtension->ValidDataOffset = 0;
        }
        
        // process pkt flags
        if ( TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_CurrentFrameIsStill) {
            TransferExtension->ChannelExtension->CurrentFrameIsStill = TRUE;
        }
        
        
        if ( TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_DropFrame) {
            if (deviceExtension->ChannelExtension[STREAM_Still] && 
                deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest->DropFrame = TRUE;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] &&  
                 deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) {
                deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest->DropFrame = TRUE;
            }                
        }
        
        
        if (TransferExtension->newFrame) {

            PUSBCAMD_READ_EXTENSION readExtension;
            PHW_STREAM_REQUEST_BLOCK srb;
            ULONG StreamNumber;
#if DBG            
            // we increment framecaptured cntr at every SOV.
            // this will happen regardless of SRBs availability.
            
            if (!(TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_NextFrameIsStill)) {

                TransferExtension->ChannelExtension->FrameCaptured++;  

            }   
#endif
            if ( deviceExtension->ChannelExtension[STREAM_Still] && 
                 deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] && 
                     deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) { 
                readExtension = deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ;
            }
            else {
                readExtension = NULL;
            }
                
            if (readExtension) {
                srb = readExtension->Srb;
                StreamNumber = srb->StreamObject->StreamNumber;
            
                ASSERT(STREAM_Capture == StreamNumber || STREAM_Still == StreamNumber);
                deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest = NULL; 

                //
                // if we have an Irp for the current video frame complete it.
                //

                if ( TransferExtension->ChannelExtension->CurrentFrameIsStill)  {

                    USBCAMD_KdPrint (MIN_TRACE, ("Current frame is Still. \n"));

                    // we need to replicate the same frame on the still pin.
                    USBCAMD_CompleteReadRequest( TransferExtension->ChannelExtension, 
                                                     readExtension,
                                                     TRUE);

                    TransferExtension->ChannelExtension->CurrentFrameIsStill = FALSE;
                }
                else{
                    if ( readExtension->DropFrame) {
                        readExtension->DropFrame = FALSE;

                        USBCAMD_KdPrint (MAX_TRACE, ("Dropping current frame on Stream # %d\n",
                                                StreamNumber));
                           
                        // recycle the read SRB
                        ExInterlockedInsertHeadList( &(deviceExtension->ChannelExtension[StreamNumber]->PendingIoList),
                                             &(readExtension->ListEntry),
                                             &deviceExtension->ChannelExtension[StreamNumber]->PendingIoListSpin);
                
                    } // end of drop frame
                    else {
                        if ( StreamNumber == STREAM_Capture ) {

                            USBCAMD_KdPrint (ULTRA_TRACE, ("current raw video frame is completed\n"));
                            USBCAMD_CompleteReadRequest( deviceExtension->ChannelExtension[STREAM_Capture], 
                                                             readExtension,
                                                             FALSE);
                        }
                        else {
                            USBCAMD_KdPrint (ULTRA_TRACE, ("current raw still frame is completed. \n"));
                            USBCAMD_CompleteReadRequest( deviceExtension->ChannelExtension[STREAM_Still], 
                                                         readExtension,
                                                         FALSE);
                        }                               
                    }
                }
                // end of complete current frame.
                
                USBCAMD_KdPrint (ULTRA_TRACE, ("Completed/Dropped Raw Frame SRB = 0x%x\n",srb));
                USBCAMD_KdPrint (ULTRA_TRACE,("Raw Frame Size = 0x%x \n",readExtension->RawFrameOffset));
                
            }   // end of current request

            //                       
            // start of new video or still frame
            //


            if (TransferExtension->PacketFlags & USBCAMD_PROCESSPACKETEX_NextFrameIsStill) {
                listEntry = 
                    ExInterlockedRemoveHeadList( &(deviceExtension->ChannelExtension[STREAM_Still]->PendingIoList),
                                                 &deviceExtension->ChannelExtension[STREAM_Still]->PendingIoListSpin);         
                StreamNumber = STREAM_Still;
                USBCAMD_KdPrint (MAX_TRACE, ("New frame is Still\n"));
            }
            else {
                listEntry = 
                    ExInterlockedRemoveHeadList( &(deviceExtension->ChannelExtension[STREAM_Capture]->PendingIoList),
                                                 &deviceExtension->ChannelExtension[STREAM_Capture]->PendingIoListSpin);         
                StreamNumber = STREAM_Capture;
            }
            
            if (listEntry != NULL) {
                PUCHAR dst, end;
          
                readExtension = 
                    (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                             USBCAMD_READ_EXTENSION, 
                                             ListEntry);                        

                ASSERT_READ(readExtension);                            
                srb = readExtension->Srb;
#if DBG
                if ( StreamNumber != srb->StreamObject->StreamNumber ) {
                    USBCAMD_KdPrint (MIN_TRACE, ("USBCAMD_TransferComplete: Srb does not match streamnumber!\n"));
                    TEST_TRAP();
                }
#endif
                StreamNumber = srb->StreamObject->StreamNumber;

                ASSERT(NULL == deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest);
                deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest = readExtension;
                USBCAMD_KdPrint (MAX_TRACE, ("Stream # %d New Frame SRB = 0x%x \n", 
                                    StreamNumber , srb));
                
                //
                // use the data in the packet
                //

                readExtension->RawFrameOffset = 0;
                readExtension->NumberOfPackets = 0;
                readExtension->ActualRawFrameLength = 0;
                readExtension->DropFrame = FALSE;
                

                if ( deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
#if DBG
                    if (StreamNumber == STREAM_Still) {
                        USBCAMD_KdPrint (MAX_TRACE, ("Call NewframeEx for this still frame (0x%x) \n",
                            readExtension->RawFrameLength));
                    }
#endif
                    readExtension->ActualRawFrameLen = readExtension->RawFrameLength;

                    (*deviceExtension->DeviceDataEx.DeviceData2.CamNewVideoFrameEx)
                        (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                         USBCAMD_GET_FRAME_CONTEXT(readExtension),
                         StreamNumber,
                         &readExtension->ActualRawFrameLen);
                }
                else {
                    (*deviceExtension->DeviceDataEx.DeviceData.CamNewVideoFrame)
                        (USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                         USBCAMD_GET_FRAME_CONTEXT(readExtension));
                }

                if (receiveLength)  {

                    if (readExtension->RawFrameBuffer)  {

                        readExtension->NumberOfPackets = 1;     
                        readExtension->ActualRawFrameLength = receiveLength;

                        dst = readExtension->RawFrameBuffer +
                                   readExtension->RawFrameOffset + receiveLength;
                        end = readExtension->RawFrameBuffer + 
                                   readExtension->RawFrameLength;

                  
                        USBCAMD_KdPrint (ULTRA_TRACE, ("Raw buff = 0x%x SRB = 0x%x\n", 
                            readExtension->RawFrameBuffer,srb));
                        USBCAMD_KdPrint (ULTRA_TRACE, ("Raw Offset = 0x%x rec length = 0x%x\n", 
                            readExtension->RawFrameOffset,
                            receiveLength));

                        if (dst <= end) {   
#if DBG
                            if (TransferExtension->ChannelExtension->NoRawProcessingRequired) {
                                if (0 == readExtension->RawFrameOffset) {
                                    USBCAMD_DbgLog(TL_SRB_TRACE, '1ypC',
                                        srb,
                                        readExtension->RawFrameBuffer,
                                        0
                                        );
                                }
                            }
#endif
                            RtlCopyMemory(readExtension->RawFrameBuffer +
                                            readExtension->RawFrameOffset,
                                          TransferExtension->DataBuffer + 
                                            TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset+
                                            TransferExtension->ValidDataOffset,receiveLength);
                                  
                            readExtension->RawFrameOffset += receiveLength;
                        }                            
                    }
                }
            }
#if DBG
            else {
                //
                // No irps are queued we'll have to miss
                // this frame
                //
                ASSERT(NULL == deviceExtension->ChannelExtension[StreamNumber]->CurrentRequest);

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // actual dropped frames

                TransferExtension->ChannelExtension->VideoFrameLostCount++;
            }
#endif
        } else {   

            PUCHAR dst, end;
            PUSBCAMD_READ_EXTENSION readExtension;
            PHW_STREAM_REQUEST_BLOCK srb;
            ULONG StreamNumber;

            //
            // video data is for current frame
            //
            if ( deviceExtension->ChannelExtension[STREAM_Still] && 
                 deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Still]->CurrentRequest;
            }
            else if (deviceExtension->ChannelExtension[STREAM_Capture] && 
                 deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest ) {
                readExtension = deviceExtension->ChannelExtension[STREAM_Capture]->CurrentRequest;
            }
            else {
                readExtension = NULL;
 //               TEST_TRAP();
            }

            
            if (receiveLength  && (readExtension != NULL )) {

                srb = readExtension->Srb;
                StreamNumber = srb->StreamObject->StreamNumber;

                //
                // No errors, if we have a video frame copy the data
                //

                if (readExtension->RawFrameBuffer) {
                
                    dst = readExtension->RawFrameBuffer + readExtension->RawFrameOffset + receiveLength;
                    end = readExtension->RawFrameBuffer + readExtension->RawFrameLength;
                           
                    USBCAMD_KdPrint (ULTRA_TRACE, ("Raw buff = 0x%x SRB = 0x%x\n",
                                     readExtension->RawFrameBuffer, srb));
                    USBCAMD_KdPrint (ULTRA_TRACE, ("Raw Offset = 0x%x rec length = 0x%x\n", 
                                     readExtension->RawFrameOffset,receiveLength));

                    //
                    // check for buffer overrun
                    // if the camera is using two pipes it is possible we
                    // will miss the sync info and keep on trying to 
                    // recieve data frame data into the raw buffer, if this
                    // happens we just throw the extra data away.
                    //
                    if (dst <= end) {   
                        readExtension->NumberOfPackets++;  
                        readExtension->ActualRawFrameLength += receiveLength;
#if DBG
                        if (TransferExtension->ChannelExtension->NoRawProcessingRequired) {
                            if (0 == readExtension->RawFrameOffset) {
                                USBCAMD_DbgLog(TL_SRB_TRACE, '2ypC',
                                    srb,
                                    readExtension->RawFrameBuffer,
                                    0
                                    );
                            }
                        }
#endif
                        RtlCopyMemory(readExtension->RawFrameBuffer + readExtension->RawFrameOffset,
                                      TransferExtension->DataBuffer + 
                                          TransferExtension->DataUrb->UrbIsochronousTransfer.IsoPacket[i].Offset+
                                            TransferExtension->ValidDataOffset,receiveLength);
                                  
                        readExtension->RawFrameOffset += receiveLength;
                    }
                }
            }
        }  /* process packet */
        
    } /* end for loop*/

    // release current request spinlock
    KeReleaseSpinLockFromDpcLevel(&TransferExtension->ChannelExtension->CurrentRequestSpinLock);

    //
    // re-submit this request
    //
    USBCAMD_SubmitIsoTransfer(deviceExtension,
                              TransferExtension,
                              0,
                              TRUE);

    return STATUS_SUCCESS;
}

#if DBG
VOID
USBCAMD_DebugStats(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension    
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    USBCAMD_KdPrint (MIN_TRACE, ("**ActualLostFrames %d\n", 
                        ChannelExtension->VideoFrameLostCount)); 
    USBCAMD_KdPrint (MIN_TRACE, ("**FrameCaptured %d\n", 
                        ChannelExtension->FrameCaptured));  
    USBCAMD_KdPrint (ULTRA_TRACE, ("**ErrorSyncPacketCount %d\n",
                        ChannelExtension->ErrorSyncPacketCount));                         
    USBCAMD_KdPrint (ULTRA_TRACE, ("**ErrorDataPacketCount %d\n", 
                        ChannelExtension->ErrorDataPacketCount));                         
    USBCAMD_KdPrint (ULTRA_TRACE, ("**IgnorePacketCount %d\n", 
                        ChannelExtension->IgnorePacketCount));                              
    USBCAMD_KdPrint (ULTRA_TRACE, ("**Sync Not Accessed Count %d\n", 
                        ChannelExtension->SyncNotAccessedCount));                                   
    USBCAMD_KdPrint (ULTRA_TRACE, ("**Data Not Accessed Count %d\n", 
                        ChannelExtension->DataNotAccessedCount));                                
}
#endif /* DBG */


VOID
USBCAMD_CompleteReadRequest(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN BOOLEAN CopyFrameToStillPin
    )
/*++

Routine Description:

    This routine completes the read for the camera

Arguments:

Return Value:

--*/    
{
    PUSBCAMD_DEVICE_EXTENSION deviceExtension = ChannelExtension->DeviceExtension;
    NTSTATUS Status;

#if DBG
    ReadExtension->CurrentLostFrames = ChannelExtension->VideoFrameLostCount;
#endif
    ReadExtension->ChannelExtension = ChannelExtension;
    ReadExtension->CopyFrameToStillPin = CopyFrameToStillPin;
    ReadExtension->StreamNumber = ChannelExtension->StreamNumber;

    // We need to synchronize the SRB completion with our stop and reset logic
    Status = USBCAMD_AcquireIdleLock(&ChannelExtension->IdleLock);
    if (STATUS_SUCCESS == Status) {

        // insert completed read SRB in the thread que.
        ExInterlockedInsertTailList( &deviceExtension->CompletedReadSrbList,
                                     &ReadExtension->ListEntry,
                                     &deviceExtension->DispatchSpinLock);
                                 
        // Increment the count of the que's semaphore.
        KeReleaseSemaphore(&deviceExtension->CompletedSrbListSemaphore,0,1,FALSE);
    }
    else {

        // The SRB is completed from this routine with STATUS_SUCCESS and a zero length buffer
        USBCAMD_CompleteRead(ChannelExtension, ReadExtension, STATUS_SUCCESS, 0);
    }
}

//
// code to handle packet processing outside the DPC routine
//

VOID
USBCAMD_ProcessIsoIrps(
    PVOID Context
    )
/*++

Routine Description:

    this thread Calls the mini driver to convert a raw packet to the proper format.
    and then completes the read SRB.

Arguments:

Return Value:

    None.

--*/
{
    ULONG maxLength;
    PVOID StillFrameBuffer;
    ULONG StillMaxLength;
    PUSBCAMD_CHANNEL_EXTENSION channelExtension,StillChannelExtension;    
    PVOID frameBuffer;
    ULONG bytesTransferred;
    NTSTATUS status;
    PHW_STREAM_REQUEST_BLOCK srb;
    PKSSTREAM_HEADER dataPacket;
    PLIST_ENTRY listEntry;
    PUSBCAMD_DEVICE_EXTENSION deviceExtension;
    PUSBCAMD_READ_EXTENSION readExtension,StillReadExtension;
    
    deviceExtension = (PUSBCAMD_DEVICE_EXTENSION) Context;

    // set the thread priority
    KeSetPriorityThread(KeGetCurrentThread(),LOW_REALTIME_PRIORITY);

    // start the infinite loop of processing completed read SRBs.

    while (TRUE) {

        // wait for ever till a read SRB is completed and inserted
        // in the que by the iso transfer completion routine.
        KeWaitForSingleObject(&deviceExtension->CompletedSrbListSemaphore,
                              Executive,KernelMode,FALSE,NULL);
        // 
        // We are ready to go. chk if the stop flag is on.
        //
        if ( deviceExtension->StopIsoThread ) {
            // we have been signaled to terminate. flush the thread queue first.
            while ( listEntry = ExInterlockedRemoveHeadList( &deviceExtension->CompletedReadSrbList,
                                                             &deviceExtension->DispatchSpinLock) ) {
                readExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                                                            USBCAMD_READ_EXTENSION, 
                                                                            ListEntry);                                             
                ASSERT_READ(readExtension);
                channelExtension = readExtension->ChannelExtension;
                USBCAMD_CompleteRead(channelExtension, readExtension, STATUS_CANCELLED,0);

                USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            }

            USBCAMD_KdPrint (MIN_TRACE, ("Iso thread is terminating.\n"));
            PsTerminateSystemThread(STATUS_SUCCESS);
        }

        // get the just completed read srb.
        listEntry = ExInterlockedRemoveHeadList( &deviceExtension->CompletedReadSrbList,
                                              &deviceExtension->DispatchSpinLock);
                                              
        if (listEntry == NULL ) {
            // something went wrong in here.
            USBCAMD_KdPrint (MIN_TRACE, ("No read SRB found!  Why were we triggered??\n"));
            TEST_TRAP();
            continue;
        }

        readExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry,
                                                                USBCAMD_READ_EXTENSION, 
                                                                ListEntry);                        
        ASSERT_READ(readExtension);
        channelExtension = readExtension->ChannelExtension;
        srb = readExtension->Srb;   

        // before we pass this raw frame to Cam driver, we will clear the stream header options flag
        // and let the Cam driver set it appropriately if it needs to indicate anything other than 
        // key frames in there in case it process compressed data (ex. h.263, etc..). Otherwise, we 
        // set the default flag (key frames only) in USBCAMD_CompleteRead.

        dataPacket = srb->CommandData.DataBufferArray;
        dataPacket->OptionsFlags =0;    
        status  = STATUS_SUCCESS;
   
        frameBuffer = USBCAMD_GetFrameBufferFromSrb(srb,&maxLength);
        //
        // if we need to drop this frame. Just complete the SRB with zero len buffer.
        //
        if (readExtension->DropFrame ) {
            readExtension->DropFrame = FALSE;
            USBCAMD_CompleteRead(channelExtension,readExtension,STATUS_SUCCESS, 0); 
            USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
            continue;
        }

        StillReadExtension = NULL;

        // DSHOW buffer len returned will be equal raw frame len unless we 
        // process raw frame buffer in ring 0.
        bytesTransferred = readExtension->ActualRawFrameLength;

        // Ensure that the buffer size appears to be exactly what was requested
        ASSERT(maxLength >= channelExtension->VideoInfoHeader->bmiHeader.biSizeImage);
        maxLength = channelExtension->VideoInfoHeader->bmiHeader.biSizeImage;

        if (deviceExtension->Usbcamd_version == USBCAMD_VERSION_200) {
        
            // only call if the cam driver indicated so during initialization.
            if ( !channelExtension->NoRawProcessingRequired) {

                USBCAMD_DbgLog(TL_SRB_TRACE, '3ypC',
                    srb,
                    frameBuffer,
                    0
                    );

                USBCAMD_KdPrint (ULTRA_TRACE, ("Call Cam ProcessFrameEX, len= x%X ,SRB=%X S#%d \n",
                    bytesTransferred,srb,readExtension->StreamNumber));

                *(PULONG)frameBuffer = 0L;  // Hack Alert (detect dup frames for some minidrivers)

                status = 
                    (*deviceExtension->DeviceDataEx.DeviceData2.CamProcessRawVideoFrameEx)(
                        deviceExtension->StackDeviceObject,
                        USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                        USBCAMD_GET_FRAME_CONTEXT(readExtension),
                        frameBuffer,
                        maxLength,
                        readExtension->RawFrameBuffer,
                        readExtension->RawFrameLength,
                        readExtension->NumberOfPackets,
                        &bytesTransferred,
                        readExtension->ActualRawFrameLength,
                        readExtension->StreamNumber);

                if (NT_SUCCESS(status) && !*(PULONG)frameBuffer) {
                    bytesTransferred = 0;   // Hack Alert (minidriver didn't really copy)
                }
            }
        }
        else {

            USBCAMD_DbgLog(TL_SRB_TRACE, '3ypC',
                srb,
                frameBuffer,
                0
                );

            *(PULONG)frameBuffer = 0L;  // Hack Alert (detect dup frames for some minidrivers)

            status = 
                (*deviceExtension->DeviceDataEx.DeviceData.CamProcessRawVideoFrame)(
                    deviceExtension->StackDeviceObject,
                    USBCAMD_GET_DEVICE_CONTEXT(deviceExtension),
                    USBCAMD_GET_FRAME_CONTEXT(readExtension),
                    frameBuffer,
                    maxLength,
                    readExtension->RawFrameBuffer,
                    readExtension->RawFrameLength,
                    readExtension->NumberOfPackets,             
                    &bytesTransferred);

            if (NT_SUCCESS(status) && !*(PULONG)frameBuffer) {
                bytesTransferred = 0;   // Hack Alert (minidriver didn't really copy)
            }
        }

        USBCAMD_KdPrint (ULTRA_TRACE, ("return from Cam ProcessRawframeEx : S# %d, len= x%X SRB=%X\n",
                                  srb->StreamObject->StreamNumber,bytesTransferred,
                                  srb));
    
        if (readExtension->CopyFrameToStillPin) {
        
            //
            // notify STI mon that a still button has been pressed.
            //
            if (deviceExtension->CamControlFlag & USBCAMD_CamControlFlag_EnableDeviceEvents) 
                USBCAMD_NotifyStiMonitor(deviceExtension);

            //
            // we need to copy the same frame to still pin buffer if any.
            //
        
            StillChannelExtension = deviceExtension->ChannelExtension[STREAM_Still];

            if ( StillChannelExtension && StillChannelExtension->ChannelPrepared && 
                StillChannelExtension->ImageCaptureStarted ) {

                listEntry = 
                    ExInterlockedRemoveHeadList( &(StillChannelExtension->PendingIoList),
                                             &StillChannelExtension->PendingIoListSpin);         
                if (listEntry != NULL) {
            
                    StillReadExtension = (PUSBCAMD_READ_EXTENSION) CONTAINING_RECORD(listEntry, 
                                                 USBCAMD_READ_EXTENSION, 
                                                 ListEntry); 
                    StillFrameBuffer = USBCAMD_GetFrameBufferFromSrb(StillReadExtension->Srb,
                                                                &StillMaxLength);
                    if ( StillMaxLength >= bytesTransferred ) {

                        USBCAMD_DbgLog(TL_SRB_TRACE, '4ypC',
                            StillReadExtension->Srb,
                            StillFrameBuffer,
                            0
                            );

                        // copy the video frame to still pin buffer.
                        RtlCopyMemory(StillFrameBuffer,frameBuffer,bytesTransferred);  
                    }
                    else {
                        USBCAMD_KdPrint (MIN_TRACE, ("Still Frame buffer is smaller than raw buffer.\n"));
                        // recycle read SRB.
                        ExInterlockedInsertHeadList( &(StillChannelExtension->PendingIoList),
                                                 &(StillReadExtension->ListEntry),
                                                 &StillChannelExtension->PendingIoListSpin);
                        StillReadExtension = NULL;                                                 
                    }
                } 
                else 
                    USBCAMD_KdPrint (MAX_TRACE, ("Still Frame Dropped \n"));
            }
        }

        // The number of bytes transfer of the read is set above just before
        // USBCAMD_CompleteReadRequest is called.

        USBCAMD_CompleteRead(channelExtension,readExtension,status,bytesTransferred); 
    
        if (StillReadExtension) {

            USBCAMD_KdPrint (MIN_TRACE, ("Still Frame Completed \n"));

            // we need to complete another read SRB on the still pin.
            USBCAMD_CompleteRead(StillChannelExtension,StillReadExtension, status, 
                                 bytesTransferred); 
        }

        USBCAMD_ReleaseIdleLock(&channelExtension->IdleLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\warn.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    warn.h

Abstract:



Environment:

    Kernel & user mode

Revision History:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

--*/

/*
4214
4201 nonstandard extension using nameless struct/union
4115
4200
4514 unreferenced inline function
**4100 unreferenced formal parameter
4057
*/

#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4220)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\usbcamd\usbcamd\usbcamd.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    usbcamd.h

Abstract:



Environment:

    Kernel & user mode

Revision History:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

    Original 3/96 John Dunn
    Updated  3/98 Husni Roukbi

--*/

#ifndef   __USBCAMD_H__
#define   __USBCAMD_H__

#include "warn.h"

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include <strmini.h>
#include <ksmedia.h>
#include "usbcamdi.h"

#define USBCAMD_NUM_ISO_PACKETS_PER_REQUEST  32

#define USBCAMD_MAX_REQUEST   2
#define MAX_STREAM_INSTANCES  1

#define CAMCONTROL_FLAG_MASK     1

#define INPUT_PIPE  1
#define OUTPUT_PIPE 0

//#define DEADMAN_TIMER

#define USBCAMD_EXTENSION_SIG 0x45564544    //"DEVE"
#define USBCAMD_CHANNEL_SIG 0x4348414e      //"CHAN"
#define USBCAMD_TRANSFER_SIG 0x5452414e     //"TRAN"
#define USBCAMD_READ_SIG 0x45425253         //"SRBE"

#define USBCAMD_RAW_FRAME_SIG 0x46574152    //"RAWF"

typedef struct _USBCAMD_pipe_pin_relations {
    UCHAR   PipeType;
    UCHAR   PipeDirection;
    USHORT  MaxPacketSize;
    USBCAMD_Pipe_Config_Descriptor  PipeConfig;
    // Int. or bulk outstanding irps.
    KSPIN_LOCK  OutstandingIrpSpinlock; // used to access the above IRPs.
    LIST_ENTRY	IrpPendingQueue;
	LIST_ENTRY  IrpRestoreQueue;
} USBCAMD_PIPE_PIN_RELATIONS, *PUSBCAMD_PIPE_PIN_RELATIONS;


typedef enum {
   STREAM_Capture,                  // we always assume vidoe stream is stream 0
   STREAM_Still
};

typedef enum {
   BULK_TRANSFER,                  // we always assume vidoe stream is stream 0
   INTERRUPT_TRANSFER
};


typedef enum {
   INTERNAL,                  // we use transferext[0] in ch ext for internal requests.
   EXETRNAL
};

typedef struct _USBCAMD_DEVICE_DATA_EX {
    union {
        USBCAMD_DEVICE_DATA  DeviceData;
        USBCAMD_DEVICE_DATA2 DeviceData2;
    };
} USBCAMD_DEVICE_DATA_EX, *PUSBCAMD_DEVICE_DATA_EX;


// we only support one video stream and one still stream.

#define MAX_STREAM_COUNT    2


#if DBG
#define STREAM_CAPTURE_TIMEOUT  15
#else
#define STREAM_CAPTURE_TIMEOUT  9
#endif
#if DBG
#define STREAM_STILL_TIMEOUT    4100
#else
#define STREAM_STILL_TIMEOUT    4100
#endif

// The follow constants are based on 10,000,000 / sec <OR> 100ns time units.
#define MICROSECONDS    (10)
#define MILLISECONDS    (1000*MICROSECONDS)
#define SECONDS         (1000*MILLISECONDS)

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _USBCAMD_DEVICE_EXTENSION {

    ULONG Sig;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension[MAX_STREAM_COUNT];

	// Control Queues for each data stream
    LIST_ENTRY               StreamControlSRBList[MAX_STREAM_COUNT];
    BOOL                     ProcessingControlSRB[MAX_STREAM_COUNT];
    KSPIN_LOCK               ControlSRBSpinLock;        // Multiprocessor safe access to AdapterSRBList

	// Completed Read SRB Queue mgmt.
    LIST_ENTRY 				CompletedReadSrbList;		
    KSPIN_LOCK              DispatchSpinLock;        // Multiprocessor safe access to AdapterSRBList
    KSEMAPHORE				CompletedSrbListSemaphore;
	BOOLEAN					StopIsoThread;
	PKTHREAD 				IsoThreadObject;

    
    LONG TimeoutCount[MAX_STREAM_COUNT];
    KSEMAPHORE Semaphore;
    KSEMAPHORE CallUSBSemaphore;
    ULONG StreamCount;
    ULONG Initialized;
    ULONG    ActualInstances[MAX_STREAM_COUNT];

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT StackDeviceObject;
    PDEVICE_OBJECT SCDeviceObject;
    PDEVICE_OBJECT RealPhysicalDeviceObject;

 
    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support one interface
    PUSBD_INTERFACE_INFORMATION Interface;
	ULONG currentMaxPkt;	// used for temp storage of current alt. int. max
							// pkt size between ISO pipe stop and start.


    LONG SyncPipe;
    LONG DataPipe;
    CHAR IsoPipeStreamType;  // if data pipe iso set, indicate stream association here.
                              // if both streams are set, then create a virtual still pin.
    LONG BulkDataPipe;
    CHAR BulkPipeStreamType;   // if bulkdatpipe is set, this will indicate stream association
    BOOLEAN VirtualStillPin;
    BOOLEAN CameraUnplugged;  // set to true if camera was unplugged.
    BOOLEAN InPowerTransition; // set when waiting for pwr workitem to finish.

    DEVICE_POWER_STATE CurrentPowerState;
    ULONG CamControlFlag;
#if DBG
    ULONG InitCount;
    ULONG TimeIncrement;
#endif
    USBCAMD_DEVICE_DATA_EX DeviceDataEx;
    ULONG    Usbcamd_version;
    PUSBCAMD_PIPE_PIN_RELATIONS PipePinRelations;
    ULONG EventCount;
    DEVICE_CAPABILITIES DeviceCapabilities;

    PUCHAR CameraDeviceContext[0];

} USBCAMD_DEVICE_EXTENSION, *PUSBCAMD_DEVICE_EXTENSION;

#define DEVICE_UNINITIALIZED  0x00000000
#define DEVICE_INIT_STARTED   0x00000001
#define DEVICE_INIT_COMPLETED 0x00000002

//
// this structure defines the per request extension.  It defines any storage
// space that the mini driver may need in each request packet.
//

typedef struct _USBCAMD_READ_EXTENSION {
    ULONG Sig;
    LIST_ENTRY ListEntry;
    PVOID Srb;
    ULONG StreamNumber;
    ULONG NumberOfPackets;
    PUCHAR RawFrameBuffer;
    ULONG RawFrameLength;
    ULONG ActualRawFrameLen;
    ULONG ActualRawFrameLength;
    ULONG RawFrameOffset;
#if DBG
	ULONG CurrentLostFrames;
#endif
    BOOLEAN DropFrame;      // when set, drop the current frame and recycle read SRB.
    BOOLEAN CopyFrameToStillPin;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
    PUCHAR MinDriverExtension[0];
} USBCAMD_READ_EXTENSION, *PUSBCAMD_READ_EXTENSION;

typedef struct _BULK_TRANSFER_CONTEXT {
    ULONG   RemainingTransferLength;
    ULONG   ChunkSize;
    ULONG   NBytesTransferred;
    PUCHAR  pTransferBuffer;
    PUCHAR  pOriginalTransferBuffer;
    ULONG   PipeIndex;
    BOOLEAN fDestinedForReadBuffer;
    KEVENT  CancelEvent;                // for cancelling bulk or INT IRPs.
    PCOMMAND_COMPLETE_FUNCTION CommandCompleteCallback;
    PVOID   CommandCompleteContext;
    BOOLEAN LoopBack;               // set if I need to resubmit an Int request after completion.
    UCHAR   TransferType;
} BULK_TRANSFER_CONTEXT, *PBULK_TRANSFER_CONTEXT;

typedef struct _USBCAMD_TRANSFER_EXTENSION {
    ULONG Sig;
    LIST_ENTRY ListEntry;
    ULONG PacketFlags;
    ULONG ValidDataOffset;
    BOOLEAN newFrame;
    ULONG BufferLength;
    PUCHAR DataBuffer;
    PUCHAR SyncBuffer;
    PURB SyncUrb;
    PURB DataUrb;
    PIRP SyncIrp;
    PIRP DataIrp;
    PUCHAR WorkBuffer;
    BULK_TRANSFER_CONTEXT BulkContext;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
} USBCAMD_TRANSFER_EXTENSION, *PUSBCAMD_TRANSFER_EXTENSION;

typedef struct _POWERUP_WORKITEM {
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    WORK_QUEUE_ITEM WorkItem;
} POWERUP_WORKITEM, *PPOWERUP_WORKITEM;

typedef struct _COMMAND_WORK_ITEM {
    PVOID DeviceContext;
    WORK_QUEUE_ITEM WorkItem;
    UCHAR Request;
    USHORT Value;
    USHORT Index;
    PVOID Buffer;
    OUT PULONG BufferLength;
    BOOLEAN GetData;
    PCOMMAND_COMPLETE_FUNCTION CommandComplete;
    PVOID CommandContext;
} COMMAND_WORK_ITEM, *PCOMMAND_WORK_ITEM;

typedef struct _EVENTWAIT_WORKITEM {
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;
    WORK_QUEUE_ITEM WorkItem;
    struct _USBCAMD_CHANNEL_EXTENSION *ChannelExtension;
    PVOID Buffer;
    ULONG PipeIndex;
    ULONG BufferLength;
    PCOMMAND_COMPLETE_FUNCTION EventComplete;
    PVOID EventContext;
    ULONG Flag;
    BOOLEAN LoopBack;
    UCHAR TransferType;
} EVENTWAIT_WORKITEM, *PEVENTWAIT_WORKITEM;

typedef struct _USBCAMD_IDLE_LOCK {
    
    // Either USBCAMD_STOP_STREAM or USBCAMD_RESET_STREAM (see below)
    // Set when waiting for channel to go idle.
    // Cleared when channel is idle, but only if set to USBCAMD_RESET_STREAM
    // When non-zero, fail all acquire attempts
    LONG IdleLock;
    
    // The number of waiting threads
    LONG Waiting;
    
    // The number of outstanding requests
    LONG Busy;
    
    // Threads block on this
    KEVENT IdleEvent;

} USBCAMD_IDLE_LOCK, *PUSBCAMD_IDLE_LOCK;

//
// value for channel extension Flags field and idle lock stop processing
//
#define USBCAMD_STOP_STREAM             0x00000001
//
// value for idle lock reset processing
//
#define USBCAMD_RESET_STREAM            0x00000002

typedef struct _USBCAMD_WORK_ITEM *PUSBCAMD_WORK_ITEM;

typedef struct _USBCAMD_CHANNEL_EXTENSION {
    ULONG Sig;
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension;

    ULONG Flags;
    BOOL StreamError;
    BOOL ImageCaptureStarted;
    BOOL ChannelPrepared;
    BOOL VirtualStillPin;      // this still pin is piggy back the video pin.
    BOOL CurrentFrameIsStill;  // set if current frame is for the virtual still pin

    USBCAMD_IDLE_LOCK IdleLock;
    KTIMER TimeoutTimer;
    PUSBCAMD_READ_EXTENSION CurrentRequest;
    KSPIN_LOCK  CurrentRequestSpinLock; // sync. access to CurrentRequest.
    USBCAMD_TRANSFER_EXTENSION TransferExtension[USBCAMD_MAX_REQUEST];
    KSPIN_LOCK  TransferSpinLock;   // sync. access to TransferExtensions.
    KDPC TimeoutDpc;

    // Read SRB Queue mgmt.
    LIST_ENTRY PendingIoList;		
    KSPIN_LOCK PendingIoListSpin;

    ULONG RawFrameLength;
    UCHAR StreamNumber;
    UCHAR DataPipeType;

    LONG SyncPipe;
    LONG DataPipe;

    HANDLE MasterClockHandle;
    KS_FRAME_INFO               FrameInfo;          // PictureNumber, etc.

    PKS_VIDEOINFOHEADER         VideoInfoHeader;    // format (variable size!)
    KSSTATE                     KSState;            // Run, Stop, Pause

    PSTREAM_RECEIVE_PACKET CamReceiveCtrlPacket;
    PSTREAM_RECEIVE_PACKET CamReceiveDataPacket;

    //
    // the format number of the currently active stream
    //
    PVOID CurrentFormat;

	BOOLEAN         FirstFrame;
	
    BOOLEAN NoRawProcessingRequired; //
    BOOLEAN IdleIsoStream;          // set if cam driver wants to stop ISO streaming.
	LONGLONG PreviousStreamTime;

#if DBG
    //
    // DEBUG perf variables, these are reset each time the
    // channel is started.
    //
    //
    // inc'ed each time we advance to a new video frame.
    //
	ULONGLONG       FrameCaptured;		// Number of actual frames cptured
    //
    // Frames we have seen but had to toss because
    // no client request was available.
    //
    ULONG VideoFrameLostCount;

    LARGE_INTEGER   StartTime;          // The time at which frame capture started

    // count of video data packets ignored due to error
    ULONG IgnorePacketCount;

    // inc'ed for each packet that completes with an error
    ULONG ErrorDataPacketCount;
    ULONG ErrorSyncPacketCount;

    // inc'ed for each packet not accessed by the HC
    ULONG SyncNotAccessedCount;
    ULONG DataNotAccessedCount;

    // DEBUG Flags
    BOOLEAN InCam;
    UCHAR Pad[3];

#endif
    // total packets received for the current video frame
    ULONG PacketCount;
    ULONG CurrentBulkTransferIndex; // indicates which transfer extension is being used.
} USBCAMD_CHANNEL_EXTENSION, *PUSBCAMD_CHANNEL_EXTENSION;


//#define USBCAMD_SYNC_PIPE    0
//#define USBCAMD_DATA_PIPE    1

typedef struct _USBCAMD_WORK_ITEM  {
    WORK_QUEUE_ITEM WorkItem;
    PUSBCAMD_CHANNEL_EXTENSION ChannelExtension;
    NTSTATUS status;
} USBCAMD_WORK_ITEM;

typedef struct _INTERRUPT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PUSBCAMD_DEVICE_EXTENSION pDeviceExt;
	PUSBCAMD_TRANSFER_EXTENSION pTransferExt;
	ULONG PipeIndex;
} INTERRUPT_WORK_ITEM, *PINTERRUPT_WORK_ITEM;

#define USBCAMD_TIMEOUT_INTERVAL    250
#define USBCAMD_STILL_TIMEOUT       290

#define USBCAMD_GET_FRAME_CONTEXT(se)      (&se->MinDriverExtension[0])
#define USBCAMD_GET_DEVICE_CONTEXT(de)     ((PVOID)(&(de)->CameraDeviceContext[0]))
#define USBCAMD_GET_DEVICE_EXTENSION(dc)    (PUSBCAMD_DEVICE_EXTENSION) (((PUCHAR)(dc)) - \
                                            sizeof(USBCAMD_DEVICE_EXTENSION))


#define ULTRA_TRACE 3
#define MAX_TRACE 2
#define MIN_TRACE 1
#define NON_TRACE 0

#if DBG
// The following masks are used with the USBCAMD_DbgLog macro, and will be AND-ed at
// runtime with USBCAMD_LogMask to determine what is logged into USBCAMD_LogBuffer.
#define TL_SRB_MASK         0x0000000F
#define TL_SRB_NOISE        0x00000001
#define TL_SRB_TRACE        0x00000002
#define TL_SRB_WARNING      0x00000004
#define TL_SRB_ERROR        0x00000008

#define TL_CHN_MASK         0x000000F0
#define TL_CHN_NOISE        0x00000010
#define TL_CHN_TRACE        0x00000020
#define TL_CHN_WARNING      0x00000040
#define TL_CHN_ERROR        0x00000080

#define TL_IDL_MASK         0x00000F00
#define TL_IDL_NOISE        0x00000100
#define TL_IDL_TRACE        0x00000200
#define TL_IDL_WARNING      0x00000400
#define TL_IDL_ERROR        0x00000800

#define TL_PRF_MASK         0x0000F000
#define TL_PRF_NOISE        0x00001000
#define TL_PRF_TRACE        0x00002000
#define TL_PRF_WARNING      0x00004000
#define TL_PRF_ERROR        0x00008000

#define TL_VND_MASK         0x000F0000
#define TL_VND_NOISE        0x00010000
#define TL_VND_TRACE        0x00020000
#define TL_VND_WARNING      0x00040000
#define TL_VND_ERROR        0x00080000

// This value is used to initialize USBCAMD_LogMask
#define DEFAULT_LOG_LEVEL   0x0000CCCC

// The DebugLevel, LogMask, and MaxLogEntries are stored in the registry at this location
#define USBCAMD_REG_DBG_STREAM L"\\Registry\\Machine\\system\\currentcontrolset\\services\\usbcamd"

// The format of a log entry in USBCAMD_LogBuffer
typedef struct _USBCAMD_LOG_ENTRY {
    union {
        ULONG       Tag;
        ULONG_PTR   reserved;
    } u;
    ULONG_PTR   Arg1;
    ULONG_PTR   Arg2;
    ULONG_PTR   Arg3;
} USBCAMD_LOG_ENTRY, *PUSBCAMD_LOG_ENTRY;

// Should keep the log buffer an even multiple of PAGE_SIZE for efficient use of memory
#define DEFAULT_MAX_LOG_ENTRIES (PAGE_SIZE/sizeof(USBCAMD_LOG_ENTRY))

extern ULONG USBCAMD_DebugTraceLevel;
extern PUSBCAMD_LOG_ENTRY USBCAMD_LogBuffer;
extern ULONG USBCAMD_LogRefCnt;
extern ULONG USBCAMD_LogMask;
extern LONG USBCAMD_MaxLogEntries;
extern LONG USBCAMD_LastLogEntry;

#define USBCAMD_KdPrint(_t_, _x_) \
    if (USBCAMD_DebugTraceLevel >= _t_) { \
        DbgPrint("'USBCAMD: "); \
        DbgPrint _x_ ;\
    }

NTSTATUS
USBCAMD_InitDbg(void);

NTSTATUS
USBCAMD_ExitDbg(void);

void
USBCAMD_DbgLogInternal(ULONG Tag, ULONG_PTR Arg1, ULONG_PTR Arg2, ULONG_PTR Arg3);

#define USBCAMD_DbgLog(_m_, _t_, _a1_, _a2_, _a3_) \
    if (USBCAMD_LogBuffer && ((_m_) & USBCAMD_LogMask)) { \
        USBCAMD_DbgLogInternal((ULONG)(_t_), (ULONG_PTR)(_a1_), (ULONG_PTR)(_a2_), (ULONG_PTR)(_a3_)); \
    }

NTSTATUS
USBCAMD_StartClock(void);

ULONG
USBCAMD_StopClock(void);

#define ENTER(func)			USBCAMD_KDPrint(ULTRA_TRACE,"--->" #func "()" )
#define EXIT(func)			USBCAMD_KDPrint(ULTRA_TRACE,"<---" #func "()" )


#ifdef NTKERN
#define TRAP()  _asm {int 3}
#define TEST_TRAP() _asm {int 3}
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { _asm {int 3} }
#else
#define TRAP()  DbgBreakPoint()
#define TEST_TRAP() DbgBreakPoint()
#define TRAP_ERROR(e) if (!NT_SUCCESS(e)) { DbgBreakPoint(); }
#endif

#define ASSERT_CHANNEL(c) ASSERT((c)->Sig == USBCAMD_CHANNEL_SIG)
#define ASSERT_TRANSFER(t) ASSERT((t)->Sig == USBCAMD_TRANSFER_SIG)
#define ASSERT_DEVICE(d) ASSERT((d)->Sig == USBCAMD_DEVICE_SIG)
#define ASSERT_READ(s) ASSERT((s)->Sig == USBCAMD_READ_SIG)

PVOID
USBCAMD_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
USBCAMD_ExFreePool(
    IN PVOID p
    );


extern ULONG USBCAMD_HeapCount;

#else

#define USBCAMD_KdPrint(_t_, _x_)
#define USBCAMD_DbgLog(_m_, _t_, _a1_, _a2_, _a3_)

#define TRAP()

#define TEST_TRAP()

#define TRAP_ERROR(e)

#define ASSERT_CHANNEL(c)
#define ASSERT_TRANSFER(t)
#define ASSERT_DEVICE(d)
#define ASSERT_READ(s)

#define USBCAMD_ExAllocatePool(x, y) ExAllocatePool(x, y)
#define USBCAMD_ExFreePool(x) ExFreePool(x)

#endif /* DBG */

#define USBCAMD_SERIALIZE(de)  { USBCAMD_KdPrint(ULTRA_TRACE, ("'***WAIT dev mutex %x\n", &(de)->Semaphore)); \
                                          KeWaitForSingleObject(&(de)->Semaphore, \
                                                                Executive,\
                                                                KernelMode, \
                                                                FALSE, \
                                                                NULL); \
                                            }

#define USBCAMD_RELEASE(de)   { USBCAMD_KdPrint(ULTRA_TRACE, ("'***RELEASE dev mutex %x\n", &(de)->Semaphore));\
                                          KeReleaseSemaphore(&(de)->Semaphore,\
                                                             LOW_REALTIME_PRIORITY,\
                                                             1,\
                                                             FALSE);\
                                            }


NTSTATUS DllUnload(void);


NTSTATUS
USBCAMD_StartDevice(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_RemoveDevice(
    IN PUSBCAMD_DEVICE_EXTENSION  DeviceExtension
    );

NTSTATUS
USBCAMD_StopDevice(
    IN PUSBCAMD_DEVICE_EXTENSION  DeviceExtension
    );

NTSTATUS
USBCAMD_CallUSBD(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PURB Urb,
    IN ULONG IoControlCode,
    IN PVOID pArgument1
    );

NTSTATUS
USBCAMD_ConfigureDevice(
    IN  PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_SelectConfiguration(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
USBCAMD_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
USBCAMD_GetCurrentFrame(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
USBCAMD_InitializeIsoUrb(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN OUT PURB Urb,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PUCHAR Buffer
    );

NTSTATUS
USBCAMD_StartIsoThread(
IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
);

VOID
USBCAMD_KillIsoThread(
	IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt);
    

NTSTATUS
USBCAMD_SubmitIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG StartFrame,
    IN BOOLEAN Asap
    );

 NTSTATUS
 USBCAMD_TransferComplete(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

PIRP
USBCAMD_BuildIoRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
USBCAMD_OpenChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID Format
    );

NTSTATUS
USBCAMD_PrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_ReadChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension
    );

NTSTATUS
USBCAMD_StartChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

VOID
USBCAMD_CopyPacketToFrameBuffer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG PacketSize,
    IN ULONG Index
    );

NTSTATUS
USBCAMD_StopChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_InitializeIsoTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG index
    );

NTSTATUS
USBCAMD_AbortPipe(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN USBD_PIPE_HANDLE PipeHandle
    );

VOID
USBCAMD_PowerUpWorkItem(
    PVOID Context
);

NTSTATUS
USBCAMD_UnPrepareChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_FreeIsoTransfer(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

NTSTATUS
USBCAMD_CloseChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

VOID
USBCAMD_RecycleIrp(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN PIRP Irp,
    IN PURB Urb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
USBCAMD_ResetPipes(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN BOOLEAN Abort
    );

NTSTATUS
USBCAMD_GetPortStatus(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    IN PULONG PortStatus
    );


NTSTATUS
USBCAMD_ResetChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG portUsbStatus,
    IN ULONG portNtStatus
    );

VOID
USBCAMD_CancelQueuedSRBs(
    PUSBCAMD_CHANNEL_EXTENSION channelExtension
    );


VOID
USBCAMD_CompleteReadRequest(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN BOOLEAN CopyFrameToStillPin
    );

NTSTATUS
USBCAMD_StartIsoStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_EnablePort(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
    );


VOID
USBCAMD_ProcessIsoIrps(
    PVOID Context
    );

NTSTATUS
USBCAMD_CleanupChannel(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN ULONG StreamNumber
    );

VOID
USBCAMD_ReadIrpCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBCAMD_ChangeMode(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PIRP Irp,
    IN OUT PULONG NewMode
    );

VOID
USBCAMD_CompleteRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBCAMD_READ_EXTENSION ReadExtension,
    IN NTSTATUS NtStatus,
    IN ULONG BytesTransferred
    );

PVOID
USBCAMD_GetFrameBufferFromSrb(
    IN PVOID Srb,
    OUT PULONG MaxLength
    );

VOID
USBCAMD_ResetWorkItem(
    PVOID Context
    );

BOOLEAN
USBCAMD_ProcessResetRequest(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_OpenStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID Format
    );


NTSTATUS
USBCAMD_CloseStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

NTSTATUS
USBCAMD_SetDevicePowerState(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
USBCAMD_CommandWorkItem(
    PVOID Context
    );

VOID VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoStreamGetDroppedFramesProperty(
	PHW_STREAM_REQUEST_BLOCK pSrb
	);


VOID
USBCAMD_SetIsoPipeWorkItem(
    PVOID Context
    );

VOID
USBCAMD_ProcessSetIsoPipeState(
    PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    PUSBCAMD_CHANNEL_EXTENSION channelExtension,
    ULONG Flag
    );

//
// prototypes for bulk transfer functions.
//

NTSTATUS
USBCAMD_CancelOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN BOOLEAN bSaveIrp
        );

VOID
USBCAMD_ProcessInterruptTransferWorkItem(
    PVOID Context
    );

VOID
USBCAMD_ResubmitInterruptTransfer(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
    );



NTSTATUS
USBCAMD_CancelOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN BOOLEAN bSaveIrp
        );

NTSTATUS
USBCAMD_RestoreOutstandingBulkIntIrps(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension
        );

NTSTATUS
USBCAMD_RestoreOutstandingIrp(
        IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
        IN ULONG PipeIndex,
        IN PUSBCAMD_TRANSFER_EXTENSION pTransferContext
        );


    
ULONGLONG 
GetSystemTime( IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension
);

BOOLEAN
USBCAMD_OutstandingIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex);

PUSBCAMD_TRANSFER_EXTENSION
USBCAMD_DequeueFirstIrp(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN ULONG    PipeIndex,
    IN PLIST_ENTRY pListHead);
    

NTSTATUS
USBCAMD_StartBulkStream(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );


NTSTATUS
USBCAMD_IntOrBulkTransfer(
    PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PVOID    pBuffer,
    IN ULONG    TransferSize,
    IN ULONG    PipeIndex,
    IN PCOMMAND_COMPLETE_FUNCTION commandComplete,
    IN PVOID    commandContext,
    IN BOOLEAN  LoopBack,
    IN UCHAR    TransferType
);

NTSTATUS
USBCAMD_BulkTransferComplete(
    IN PDEVICE_OBJECT       pDeviceObject,
	IN PIRP                 pIrp,
	IN PVOID Context
);

NTSTATUS
USBCAMD_InitializeBulkTransfer(
    IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension,
    IN ULONG PipeIndex
    );

NTSTATUS
USBCAMD_FreeBulkTransfer(
    IN PUSBCAMD_TRANSFER_EXTENSION TransferExtension
    );

VOID
USBCAMD_CompleteBulkRead(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension,
    IN NTSTATUS status
    );

VOID
USBCAMD_ProcessStillReadWorkItem(
    PVOID Context
    );

VOID
USBCAMD_PnPHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PIRP pIrp,
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension,
    IN PIO_STACK_LOCATION ioStackLocation);

NTSTATUS
USBCAMD_CallUsbdCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

//
// prototypes for general queue management using a busy flag
//
BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    );

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    );

ULONGLONG GetStreamTime(
	IN PHW_STREAM_REQUEST_BLOCK Srb,
	IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
	);

NTSTATUS
USBCAMD_SetIsoPipeState(
    IN PVOID DeviceContext,
    IN ULONG PipeStateFlags
    );


NTSTATUS
USBCAMD_SetVideoFormat(
    IN PVOID DeviceContext,
    IN  PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
USBCAMD_WaitOnDeviceEvent(
    IN PVOID DeviceContext,
    IN ULONG PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION   EventComplete,
    IN PVOID EventContext,
    IN BOOLEAN LoopBack
    );

NTSTATUS
USBCAMD_BulkReadWrite(
    IN PVOID DeviceContext,
    IN USHORT PipeIndex,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PCOMMAND_COMPLETE_FUNCTION CommandComplete,
    IN PVOID CommandContext
    );

NTSTATUS
USBCAMD_CancelBulkReadWrite(
    IN PVOID DeviceContext,
    IN ULONG PipeIndex
    );


NTSTATUS
USBCAMD_SetPipeState(
    IN PVOID DeviceContext,
    IN UCHAR PipeState,
    IN ULONG StreamNumber
    );

VOID
USBCAMD_EventWaitWorkItem(
    PVOID Context
    );

NTSTATUS
USBCAMD_Parse_PipeConfig(
     IN PUSBCAMD_DEVICE_EXTENSION DeviceExtension,
     IN ULONG numberOfPipes
     ) ;

NTSTATUS STREAMAPI USBCAMD_DeviceEventProc (
      PHW_EVENT_DESCRIPTOR pEvent);

VOID USBCAMD_NotifyStiMonitor(
      PUSBCAMD_DEVICE_EXTENSION deviceExtension);

NTSTATUS
USBCAMD_BulkOutComplete(
    PVOID DeviceContext,
    PVOID Context,
    NTSTATUS ntStatus
    );
    
NTSTATUS
USBCAMD_QueryCapabilities(
    IN PUSBCAMD_DEVICE_EXTENSION pDeviceExt
    );

VOID
USBCAMD_InitializeIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

NTSTATUS
USBCAMD_AcquireIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

VOID
USBCAMD_ReleaseIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

NTSTATUS
USBCAMD_WaitForIdle(
    IN OUT PUSBCAMD_IDLE_LOCK Lock,
    IN LONG Flag
    );

VOID
USBCAMD_ClearIdleLock(
    IN OUT PUSBCAMD_IDLE_LOCK Lock
    );

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR PnPSystemPowerStateString(
		ULONG SysPowerState
);

PCHAR
PnPPowerString (
    UCHAR MinorFunction
);

PCHAR PnPDevicePowerStateString(
		ULONG DevicePowerState
);


VOID
USBCAMD_DebugStats(
    IN PUSBCAMD_CHANNEL_EXTENSION ChannelExtension
    );

PVOID
USBCAMD_AllocateRawFrameBuffer(
    ULONG RawFrameLength
    );

VOID
USBCAMD_FreeRawFrameBuffer(
    PVOID RawFrameBuffer
    );

VOID
USBCAMD_CheckRawFrameBuffer(
    PVOID RawFrameBuffer
    );

VOID
USBCAMD_DumpReadQueues(
    IN PUSBCAMD_DEVICE_EXTENSION deviceExtension
    );

#else

#define USBCAMD_AllocateRawFrameBuffer(l)  USBCAMD_ExAllocatePool(NonPagedPool, l)

#define USBCAMD_FreeRawFrameBuffer(p) ExFreePool(p)

#define USBCAMD_CheckRawFrameBuffer(p)

#endif

#endif /*  __USBCAMD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\1394f.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    1394f.C

Abstract:

    

Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"  
#include "dbclass.h"        //private data strutures
#include "dbfilter.h"

#include "1394.h"

#if DBG

VOID 
DBCLASS_PrintTopologyMap(
    PTOPOLOGY_MAP TopologyMap
    )
 /* ++
  * 
  * Routine Description:
  * 
  * Passes a IRB to the 1394 stack, and waits for return.
  * 
  * Arguments:
  * 
  * DeviceObject - Device object of the to of the port driver
  *                 stack
  * 
  * Return Value:
  * 
  * STATUS_SUCCESS if successful
  * 
  * -- */
{
    USHORT  nodeCount, selfIdCount;
    ULONG   i;

    DBCLASS_KdPrint((2, "'***********************\n"));
    DBCLASS_KdPrint((2, "'TopologyMap = (%08X)\n", TopologyMap));
    DBCLASS_KdPrint((2, "'TOP_Length = (%08X)\n", TopologyMap->TOP_Length)); 
    DBCLASS_KdPrint((2, "'TOP_CRC = (%08X)\n", TopologyMap->TOP_CRC)); 
    DBCLASS_KdPrint((2, "'TOP_Generation = (%08X)\n", TopologyMap->TOP_Generation)); 
    DBCLASS_KdPrint((2, "'TOP_Node_Count = (%08X)\n", TopologyMap->TOP_Node_Count)); 
    DBCLASS_KdPrint((2, "'TOP_Self_ID_Count = (%08X)\n", TopologyMap->TOP_Self_ID_Count));     

    nodeCount = TopologyMap->TOP_Node_Count;  
    selfIdCount = TopologyMap->TOP_Self_ID_Count;
    
    DBCLASS_KdPrint((2, "'nodeCount = (%08X) selfIdCount = (%08X)\n",
        nodeCount, selfIdCount));     

    for (i=0; i< selfIdCount; i++) {

        SELF_ID selfId;
        SELF_ID_MORE selfIdMore;

        selfId = TopologyMap->TOP_Self_ID_Array[i];
         
        DBCLASS_KdPrint((2, "'TOP_Self_ID = (%08X)\n",  
            selfId));     
        DBCLASS_KdPrint((2, "'SID_Phys_ID = (%08X)\n", (ULONG) 
            selfId.SID_Phys_ID));             
        DBCLASS_KdPrint((2, "'SID_Port1 = (%08X)\n", (ULONG) 
            selfId.SID_Port1));                         
        DBCLASS_KdPrint((2, "'SID_Port2 = (%08X)\n", (ULONG) 
            selfId.SID_Port2));              
        DBCLASS_KdPrint((2, "'SID_Port3 = (%08X)\n", (ULONG) 
            selfId.SID_Port3));              
        DBCLASS_KdPrint((2, "'SID_More_Packets = (%08X)\n", (ULONG) 
            selfId.SID_More_Packets));                              

        if (selfId.SID_More_Packets) 
        {

            do 
            {
                i++;
                RtlCopyMemory(&selfIdMore, 
                          &TopologyMap->TOP_Self_ID_Array[i],
                          sizeof(ULONG));

                DBCLASS_KdPrint((2, "'SID_Phys_ID = (%08X)\n", (ULONG) 
                    selfIdMore.SID_Phys_ID)); 
                DBCLASS_KdPrint((2, "'SID_PortA = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortA));             
                DBCLASS_KdPrint((2, "'SID_PortB = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortB));              
                DBCLASS_KdPrint((2, "'SID_PortC = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortC));                            
                DBCLASS_KdPrint((2, "'SID_PortD = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortD));                            
                DBCLASS_KdPrint((2, "'SID_PortE = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortE));                            
                DBCLASS_KdPrint((2, "'SID_PortF = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortF));                            
                DBCLASS_KdPrint((2, "'SID_PortG = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortG));                            
                DBCLASS_KdPrint((2, "'SID_PortH = (%08X)\n", (ULONG) 
                    selfIdMore.SID_PortH));     
                    
            } while (selfIdMore.SID_More_Packets);                        
        }
    } /* for */
    
    DBCLASS_KdPrint((2, "'***********************\n"));
}
#else

#define DBCLASS_PrintTopologyMap(x) x

#endif /* DBG */


NTSTATUS 
DBCLASS_SyncSubmitIrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRB Irb
    )
 /* ++
  * 
  * Routine Description:
  * 
  * Passes a IRB to the 1394 stack, and waits for return.
  * 
  * Arguments:
  * 
  * DeviceObject - Device object of the to of the port driver
  *                 stack
  * 
  * Return Value:
  * 
  * STATUS_SUCCESS if successful
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
#ifdef DEADMAN_TIMER  
    BOOLEAN haveTimer = FALSE;
    KDPC timeoutDpc;
    KTIMER timeoutTimer;
#endif

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_1394_CLASS,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,  // INTERNAL
                                        &event,
                                        &ioStatus);

    if (NULL == irp) {
        DBCLASS_KdPrint((0, "'could not allocate an irp!\n"));
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Call the port driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the DRB 
    //
    nextStack->Parameters.Others.Argument1 = Irb;
    ntStatus = IoCallDriver(DeviceObject, irp);
    
    if (ntStatus == STATUS_PENDING) 
    {

#ifdef DEADMAN_TIMER
        LARGE_INTEGER dueTime;

        KeInitializeTimer(&timeoutTimer);
        KeInitializeDpc(&timeoutDpc,
                        UsbhTimeoutDPC,
                        irp);

        dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        KeSetTimer(&timeoutTimer,
                   dueTime,
                   &timeoutDpc);        

        haveTimer = TRUE;
#endif
    
        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

    } else {
        ioStatus.Status = ntStatus;
    }

#ifdef DEADMAN_TIMER
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) 
    {
        KeCancelTimer(&timeoutTimer);
    }                
#endif /* DEADMAN_TIMER */

    ntStatus = ioStatus.Status;

    DBCLASS_KdPrint((2,"'DBCLASS_SyncSubmitIrb (%x)\n", ntStatus));

    return ntStatus;
}

#define DBCLASS_COUNT_PORT(s, d) (d)->NumberOf1394Ports++;


USHORT
DBCLASS_GetNodeId(
    PTOPOLOGY_MAP TopologyMap,
    USHORT Index,
    USHORT Connect
    )
/*++

Routine Description:

    Given an index walk the map and return the NodeId

Arguments:

Return Value:

    zero if not a device bay PDO.

--*/
{
    USHORT i;
    USHORT nodeCount;
    USHORT nodeId = 0xffff;
    USHORT idCount = 0;
    USHORT selfIdCount; 

    nodeCount = TopologyMap->TOP_Node_Count;
    selfIdCount = TopologyMap->TOP_Self_ID_Count;
    
    DBCLASS_KdPrint((2, "'>GetNodeId Index = %d\n", Index)); 

    for (i=0; i< selfIdCount; i++) 
    {

        SELF_ID selfId;
        SELF_ID_MORE selfIdMore;

        selfId = TopologyMap->TOP_Self_ID_Array[i];
        
        if (idCount == Index && 
            ((USHORT)selfId.SID_Port1 == Connect ||
             (USHORT)selfId.SID_Port2 == Connect ||
             (USHORT)selfId.SID_Port3 == Connect)) 
        {
                
                nodeId = (USHORT) selfId.SID_Phys_ID;   
                break;
        }            

        if (selfId.SID_More_Packets) 
        {

            do 
            {
                i++;
                RtlCopyMemory(&selfIdMore, 
                              &TopologyMap->TOP_Self_ID_Array[i],
                              sizeof(ULONG));
        
                if (idCount == Index && 
                    ((USHORT)selfIdMore.SID_PortA == Connect ||
                     (USHORT)selfIdMore.SID_PortB == Connect ||
                     (USHORT)selfIdMore.SID_PortC == Connect ||
                     (USHORT)selfIdMore.SID_PortD == Connect ||
                     (USHORT)selfIdMore.SID_PortE == Connect ||
                     (USHORT)selfIdMore.SID_PortF == Connect ||
                     (USHORT)selfIdMore.SID_PortG == Connect ||
                     (USHORT)selfIdMore.SID_PortH == Connect)) {                
                    nodeId = (USHORT) selfId.SID_Phys_ID;   
                    goto DBCLASS_GetNodeId_Done;
                }                                

            } while (selfIdMore.SID_More_Packets);                        
        }

        idCount++;
    }
    
    DBCLASS_KdPrint((2, "'>nodeId = (%08X)\n", nodeId)); 

DBCLASS_GetNodeId_Done:

    return nodeId;
}    

PBUS1394_PORT_INFO
DBCLASS_SetNodeId(
    PTOPOLOGY_MAP TopologyMap,
    SELF_ID HcSelfId,
    USHORT SelfIdPortX,
    PUSHORT ChildIdx,
    PUSHORT ParentIdx,
    PBUS1394_PORT_INFO Bus1394PortInfo    
    )
/*++

Routine Description:

Arguments:

Return Value:

    zero if not a device bay PDO.

--*/
{
    ULONG   flags = 0;
    USHORT  nodeId = 0xffff, idCount;

    idCount = TopologyMap->TOP_Self_ID_Count;
    
    DBCLASS_KdPrint((2, "'ParentIdx = %d ChildIdx = %d count = %d\n", 
        *ParentIdx, *ChildIdx, idCount));

    //Scan forward through the map looking for potential children
    
    if (SelfIdPortX == SELF_ID_CONNECTED_TO_CHILD) 
    {
    
        DBCLASS_KdPrint((2, "'find child\n"));        

        do 
        {
            (*ChildIdx)++;

            // are we out of children?
            if (*ChildIdx > idCount) 
            {
                // yes, check the root
                *ChildIdx = 0;
            } 
        
            flags = DBCLASS_PORTFLAG_DEVICE_CONNECTED;

            // find the child node id
            nodeId = DBCLASS_GetNodeId(TopologyMap, *ChildIdx, SELF_ID_CONNECTED_TO_PARENT);
            
        } while (nodeId == 0xffff);            
        
        DBCLASS_KdPrint((2, "'Found ChildIdx = %d nodeId = %d\n", *ChildIdx, nodeId));        

        
    } 
    else if (SelfIdPortX == SELF_ID_CONNECTED_TO_PARENT) 
    {
        do 
        {
            (*ParentIdx)++;

            // are we out of parents?
            if (*ParentIdx > idCount) 
            {
                // yes, check the root
                *ParentIdx = 0;
            }
            
            flags = DBCLASS_PORTFLAG_DEVICE_CONNECTED;

            nodeId = DBCLASS_GetNodeId(TopologyMap, *ParentIdx, SELF_ID_CONNECTED_TO_CHILD);
            
        } while (nodeId == 0xffff);  

        DBCLASS_KdPrint((2, "'Found ParentIdx = %d nodeId = %d\n", *ParentIdx, nodeId));   
    }

    Bus1394PortInfo->Flags = flags;
    Bus1394PortInfo->NodeId = nodeId;
    Bus1394PortInfo->BayNumber = 0; 
    Bus1394PortInfo++;

    return Bus1394PortInfo;
}


#if DBG
VOID
DBCLASS_KdPrintGuid(
    ULONG Level,
    PUCHAR P
    )
{    
     DBCLASS_KdPrint((Level, "'>>>>GUID1 = [%02.2x] [%02.2x] [%02.2x] [%02.2x]\n",
                        *P, *(P+1), *(P+2), *(P+3)));
     DBCLASS_KdPrint((Level, "'>>>>GUID2 = [%02.2x] [%02.2x] [%02.2x] [%02.2x]\n",
                        *(P+4), *(P+5), *(P+6), *(P+7)));        
}
#endif

BOOLEAN
DBCLASS_IsLinkDeviceObject(
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT Pdo1394
    )
/*++

Routine Description:

    check the link guid in dbcContext against the link guid for a
    1394 device, 

Arguments:

Return Value:

    true if link guid matches 

--*/
{
    PNODE_DEVICE_EXTENSION nodeExtension;



    nodeExtension = Pdo1394->DeviceExtension;

    
    DBCLASS_KdPrint((2, "'>NodeExt (%08X) ConfigRom (%08X)\n", nodeExtension, nodeExtension->ConfigRom)); 

    DBCLASS_KdPrint((2, "'>1394 PDO GUID\n"));

    if(nodeExtension->ConfigRom)
    {

#if DBG    
    	DBCLASS_KdPrintGuid(2, (PUCHAR)&nodeExtension->ConfigRom->CR_Node_UniqueID[0]); 
#endif

    	DBCLASS_KdPrint((2, "'>DBC Link GUID\n")); 

#if DBG    
    	DBCLASS_KdPrintGuid(2, &DbcContext->SubsystemDescriptor.guid1394Link[0]); 
#endif

    	return RtlCompareMemory(&DbcContext->SubsystemDescriptor.guid1394Link[0],
                            	&nodeExtension->ConfigRom->CR_Node_UniqueID[0],
                            	8) == 8;
    }
    else
        return FALSE;
}  


NTSTATUS 
DBCLASS_GetSpeedAndTopologyMaps(
    PTOPOLOGY_MAP *TopologyMap,
    PDEVICE_OBJECT BusFilterMdo
    )
/*++

Routine Description:

Arguments:

Return Value:

    topology map or NULL

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    IRB                     irb;
    PDEVICE_EXTENSION       deviceExtension;
    GET_LOCAL_HOST_INFO6    info6;
    PUCHAR                  buffer = NULL;

    if(BusFilterMdo == NULL)
    	return STATUS_UNSUCCESSFUL;
 
    deviceExtension = BusFilterMdo->DeviceExtension;
    DBCLASS_KdPrint((2, "'>Get 1394 Speed & Topology Maps MDO (%08X)\n", BusFilterMdo));  
    
    BRK_ON_TRAP();
    
    irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    irb.u.GetLocalHostInformation.nLevel = GET_HOST_CSR_CONTENTS;
    info6.CsrBaseAddress.Off_High = 0xffff;
    info6.CsrBaseAddress.Off_Low = TOPOLOGY_MAP_LOCATION;
    info6.CsrDataLength = 0;
    info6.CsrDataBuffer = buffer;

    irb.u.GetLocalHostInformation.Information = &info6;
    
    ntStatus = DBCLASS_SyncSubmitIrb(
            deviceExtension->TopOfStackDeviceObject,
            &irb);

    DBCLASS_KdPrint((2, "'GetLocalHostInfo(), first call = (%08X)\n", ntStatus));               

    if (ntStatus == STATUS_INVALID_BUFFER_SIZE) 
    {
        // try again with correct size
        buffer =  DbcExAllocatePool(NonPagedPool, 
                                    info6.CsrDataLength); 
        if (buffer) 
        {
            info6.CsrDataBuffer = buffer;        
                
            ntStatus = DBCLASS_SyncSubmitIrb(
                deviceExtension->TopOfStackDeviceObject,
                &irb);    
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        DBCLASS_KdPrint((2, "'GetLocalHostInfo(), second call = (%08X) buffer = %x\n",
            ntStatus, buffer));               
    }

    if (NT_SUCCESS(ntStatus)) 
    {
        *TopologyMap = (PTOPOLOGY_MAP) buffer;

        DBCLASS_PrintTopologyMap(*TopologyMap);
    }

    return ntStatus;
}


NTSTATUS
DBCLASS_Get1394BayPortMapping(
    PDEVICE_OBJECT BusFilterMdo,
    PDBC_CONTEXT DbcContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    zero if not a device bay PDO.

--*/
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    IRB                 irb;
    PDEVICE_EXTENSION   deviceExtension;
    PTOPOLOGY_MAP       topologyMap = NULL;
    USHORT              i, nodeCount, selfIdCount, linkNodeId;
    USHORT              linkSelfId_Index = 0;
    PDEVICE_OBJECT      linkDeviceObject;

    DBCLASS_KdPrint((1, "'>Get 1394 Port Mapping\n"));  
    DBCLASS_ASSERT(DbcContext);
    
    BRK_ON_TRAP();

    //
    // get the topology map & local node id from the 1394 port driver
    //

    // our mission her is to find the parent nodeid 
    //
    // if the DBC controller is ACPI then this will be the 1394 host controller
    // if it is USB based it will be the PHY for DBC

    if (DbcContext->ControllerSig == DBC_ACPI_CONTROLLER_SIG) 
    {

        //
        // link device object is the PDO for the 1394 HC
        //
        DBCLASS_KdPrint((2, "'DBC is ACPI \n")); 
    	deviceExtension = DbcContext->BusFilterMdo1394->DeviceExtension;
        DBCLASS_ASSERT(DbcContext->BusFilterMdo1394 == BusFilterMdo);
        DBCLASS_ASSERT(DbcContext->LinkDeviceObject == NULL);
        linkDeviceObject = deviceExtension->TopOfStackDeviceObject;
        
    } 
    else 
    {        

        // 
        // for USBDBC the link is stored in the dbcContext
        //
        DBCLASS_KdPrint((2, "'DBC is USB \n")); 
        linkDeviceObject = DbcContext->LinkDeviceObject;

        
        BRK_ON_TRAP();
    }

    DBCLASS_KdPrint((2, "'DbcContext (%08X) LinkDeviceObject (%08X)\n", DbcContext, linkDeviceObject));    

	// check for invalid device object
    if(((linkDeviceObject) == (PDEVICE_OBJECT)(-1)) || (linkDeviceObject == NULL))
    {
    	ntStatus = STATUS_UNSUCCESSFUL;
       	goto BayPort_End;
    }

    // should only get here if the db controller
    // has been found 
    DBCLASS_ASSERT(linkDeviceObject != NULL);

    irb.u.Get1394AddressFromDeviceObject.fulFlags = 0;
    irb.FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    ntStatus = DBCLASS_SyncSubmitIrb(linkDeviceObject,
                                     &irb);

    DBCLASS_KdPrint((2, "'GetLocalNodeId() = (%08X)\n", ntStatus));    

    
    if (NT_SUCCESS(ntStatus)) 
    {

        linkNodeId = irb.u.Get1394AddressFromDeviceObject.NodeAddress.NA_Node_Number;
        DBCLASS_KdPrint((2, "'link node id (%08X)\n", linkNodeId));                 
        
        ntStatus = DBCLASS_GetSpeedAndTopologyMaps(
                            &topologyMap,
                            DbcContext->BusFilterMdo1394);

        DBCLASS_KdPrint((2, "'GetTopologyMap() = (%08X)\n", ntStatus));        
    }        


    if(NT_SUCCESS(ntStatus)) 
    {
        DBCLASS_ASSERT(topologyMap != NULL);
         
        DbcContext->NumberOf1394Ports = 0;
        // free the old information
        if (DbcContext->Bus1394PortInfo) 
        {
            DbcExFreePool(DbcContext->Bus1394PortInfo);
            DbcContext->Bus1394PortInfo = NULL;
        }

        //
        // parse the map
        //

        if(topologyMap)
        {
            nodeCount = topologyMap->TOP_Node_Count;  
            selfIdCount = topologyMap->TOP_Self_ID_Count;
        
            // walk the topology map and find the node for the 
            // for the link
            //
            // first pass we just count up the ports
            // we count all SID entries for ports if if 
            // not present.
            //
        
            for (i=0; i< selfIdCount; i++) 
            {

                SELF_ID selfId;
                SELF_ID_MORE selfIdMore;

                selfId = topologyMap->TOP_Self_ID_Array[i];
            
                if (selfId.SID_Phys_ID == linkNodeId) 
                {
                    // this is the host, count the ports
                    linkSelfId_Index = i;

                    DBCLASS_COUNT_PORT(selfId.SID_Port1, DbcContext);                    
                    DBCLASS_COUNT_PORT(selfId.SID_Port2, DbcContext);
                    DBCLASS_COUNT_PORT(selfId.SID_Port3, DbcContext);
                }

                if (selfId.SID_More_Packets) 
                {

                    do 
                    {
                        i++;
                        RtlCopyMemory(&selfIdMore, 
                                      &topologyMap->TOP_Self_ID_Array[i],
                                      sizeof(ULONG));

                        if (selfIdMore.SID_Phys_ID == linkNodeId) 
                        {
                        
                            // this is the link, count the ports
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortA, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortB, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortC, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortD, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortE, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortF, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortG, DbcContext);
                            DBCLASS_COUNT_PORT(selfIdMore.SID_PortH, DbcContext);
                        }                              

                    } while(selfIdMore.SID_More_Packets);                        
                }
            }
        }

        // now set up the port map 

        DbcContext->Bus1394PortInfo = 
            DbcExAllocatePool(NonPagedPool, sizeof(BUS1394_PORT_INFO) * 
                              DbcContext->NumberOf1394Ports); 

        DBCLASS_KdPrint((2, "'link index = %d\n", linkSelfId_Index));                              
        DBCLASS_KdPrint((2, "'link id = %d\n", linkNodeId));                    
                           
        if(DbcContext->Bus1394PortInfo && topologyMap) 
        {
            SELF_ID selfId;
            SELF_ID_MORE selfIdMore;
            USHORT parentIdx, childIdx;
            PBUS1394_PORT_INFO bus1394PortInfo = DbcContext->Bus1394PortInfo;

            // scan children and parents                
            // now parse the self id for the link and fill in the port map
            // fill in the phys ids for all child devices

            selfId = topologyMap->TOP_Self_ID_Array[linkSelfId_Index];
            parentIdx = childIdx = linkNodeId;

            DBCLASS_ASSERT(selfId.SID_Phys_ID == linkNodeId);

            bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfId.SID_Port1, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
            bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfId.SID_Port2, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
            bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfId.SID_Port3, 
                                           &parentIdx, &childIdx, bus1394PortInfo);                                           

            if (selfId.SID_More_Packets) 
            {

                do 
                {
                
                    linkSelfId_Index++;
                    RtlCopyMemory(&selfIdMore, 
                              &topologyMap->TOP_Self_ID_Array[linkSelfId_Index],
                              sizeof(ULONG));

                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortA, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortB, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortC, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortD, 
                                           &parentIdx, &childIdx, bus1394PortInfo);
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortE, 
                                           &parentIdx, &childIdx, bus1394PortInfo);                                                                           
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortF, 
                                           &parentIdx, &childIdx, bus1394PortInfo);                                           
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortG, 
                                           &parentIdx, &childIdx, bus1394PortInfo);             
                    bus1394PortInfo = 
                        DBCLASS_SetNodeId(topologyMap, selfId, (USHORT)selfIdMore.SID_PortH, 
                                           &parentIdx, &childIdx, bus1394PortInfo);                                                
                     
                } while (selfIdMore.SID_More_Packets); 
            }        

            // now update the bay/port map

            for (i=0; i< DbcContext->NumberOf1394Ports; i++) 
            {
            
                USHORT bay;
                
                // find the bay for this port
                // note: phy port index start at 1
                for (bay=1; bay <=NUMBER_OF_BAYS(DbcContext); bay++) 
                {
                    if (DbcContext->BayInformation[bay].BayDescriptor.bPHYPortNumber 
                        == i+1) 
                    {      
                        DbcContext->Bus1394PortInfo[i].BayNumber = bay;
                        break;
                    }
                }                    
            }
            
#if DBG
            for (i=0; i<DbcContext->NumberOf1394Ports; i++) 
            {
                DBCLASS_KdPrint((2, "'Port [%d] = nodeId (%08X)  bay (%08X) flg = (%08X)\n", 
                    i+1,
                    DbcContext->Bus1394PortInfo[i].NodeId, 
                    DbcContext->Bus1394PortInfo[i].BayNumber,
                    DbcContext->Bus1394PortInfo[i].Flags));
            }

            for (i=1; i<= NUMBER_OF_BAYS(DbcContext); i++) 
            {
                DBCLASS_KdPrint((2, "'Port [%d] = bay (%08X)\n", 
					DbcContext->BayInformation[i].BayDescriptor.bPHYPortNumber,
					DbcContext->BayInformation[i].BayDescriptor.bBayNumber
					));
			}
#endif        

        } 
        else 
        { 
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBCLASS_KdPrint((0, "No memory for Port Info'\n"));
            TRAP();
        }

    }        

    if (topologyMap) 
    {
        DbcExFreePool(topologyMap);
    }

BayPort_End:

    return ntStatus;
}


USHORT
DBCLASS_GetBayFor1394Pdo(
    PDEVICE_OBJECT BusFilterMdo,
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT Pdo1394
    )
/*++

Routine Description:

    given a 1394 PDO figure out wich bay it is associated with
    
Arguments:

Return Value:

    zero if not a device bay PDO.

--*/
{
    PNODE_DEVICE_EXTENSION  nodeExtension;
    USHORT nodeId;
    ULONG i;
    NTSTATUS ntStatus;
    PBUS1394_PORT_INFO bus1394PortInfo;

    PAGED_CODE();
    
    ntStatus = DBCLASS_Get1394BayPortMapping(BusFilterMdo,
                                             DbcContext);

    if (NT_SUCCESS(ntStatus)) 
    {
        nodeExtension = Pdo1394->DeviceExtension;

        // check the node id against the bay port mapping

        nodeId = nodeExtension->NodeAddress.NA_Node_Number;
        DBCLASS_KdPrint((1, "'>1394 PDO (%08X) has NodeID = (%08X)\n", 
                Pdo1394, nodeId));            

        bus1394PortInfo = DbcContext->Bus1394PortInfo;
        
        for (i=0; i< DbcContext->NumberOf1394Ports; i++) 
        {
            if (bus1394PortInfo->NodeId == nodeId) 
            {
                DBCLASS_KdPrint((1, "'>1394 PDO is in bay = %d\n", 
                    bus1394PortInfo->BayNumber));            
                return bus1394PortInfo->BayNumber;
            }
            bus1394PortInfo++;
        }
    } 
#if DBG    
    else 
    {
        DBCLASS_KdPrint((1, "'failed to get 1394 bay->port mapping!\n"));              
    }
#endif

    return 0;
}


NTSTATUS
DBCLASS_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    DBCLASS_KdPrint((2, "'defer irp %x\n", Irp));
    
    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
DBCLASS_CreateDeviceFilterObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject,
    IN PDEVICE_OBJECT DevicePdo,
    IN PDBC_CONTEXT DbcContext,
    IN ULONG BusTypeSig
    )
/*++

Routine Description:

    This routine is called to create a new instance of the DBC
    bus filter.

Arguments:

    DriverObject - pointer to the driver object for USBD.

    *DeviceObject - ptr to DeviceObject ptr to be filled
                    in with the device object we create.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    ntStatus = IoCreateDevice(DriverObject,
                              sizeof (DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE, //NOT Exclusive
                              DeviceObject);

    if (!NT_SUCCESS(ntStatus) && *DeviceObject) 
    {
        IoDeleteDevice(*DeviceObject);
    } 

    if (NT_SUCCESS(ntStatus)) 
    {

        PDEVICE_OBJECT      deviceObject = *DeviceObject, stackTopDO;
        PDEVICE_EXTENSION   deviceExtension;

        // initialize the FDO 
        // and attach it to the PDO

        //
        // clone some charateristics of the PDO.
        //
        
        deviceExtension = deviceObject->DeviceExtension;
        deviceExtension->PhysicalDeviceObject = DevicePdo;

        stackTopDO = 
        deviceExtension->TopOfStackDeviceObject = 
            IoAttachDeviceToDeviceStack(deviceObject, DevicePdo);
            
        //
        // Preserve flags in lower device object
        //
        
        deviceObject->Flags |= (DevicePdo->Flags &
                                (DO_POWER_INRUSH | DO_POWER_PAGABLE));

        deviceObject->Flags |= (DevicePdo->Flags &
                                (DO_BUFFERED_IO | DO_DIRECT_IO));

            
        deviceExtension->DbcContext = DbcContext;    

        deviceExtension->FdoType = BusTypeSig;

        // object is ready            
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    return ntStatus;
}


NTSTATUS
DBCLASS_1394QBusRelationsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PDEVICE_RELATIONS deviceRelations;
    ULONG i;
    PDEVICE_OBJECT busFilterMdo = Context;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT mdo1394;
    
    deviceExtension = busFilterMdo->DeviceExtension;
    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    LOGENTRY(LOG_MISC, '3QBR', busFilterMdo, 0, deviceRelations);

    if ((!NT_SUCCESS(Irp->IoStatus.Status)) || deviceRelations == NULL) 
    {
         LOGENTRY(LOG_MISC, '3QBn', busFilterMdo, 0, deviceRelations);

         DBCLASS_KdPrint((0, "'>QBR 1394 Failed\n"));

         deviceExtension->QBusRelations1394Success = FALSE;

         goto DBCLASS_1394QBR_Done;
    }
    else 
    {
         DBCLASS_KdPrint((0, "'>QBR 1394 Passed\n"));

         deviceExtension->QBusRelations1394Success = TRUE;
    }

    for (i=0; i< deviceRelations->Count; i++) 
    {

        DBCLASS_KdPrint((1, "'>QBR 1394 PDO[%d] %x \n", i, 
            deviceRelations->Objects[i]));
        
        LOGENTRY(LOG_MISC, 'QBRd', deviceRelations->Objects[i], i, 0);

        // 1394 is returning a PDO, see if we know 
        // about it

        // if this is the PHY/LINK for a DBC link it to the 
        // DBC context
        DBCLASS_CheckPhyLink(deviceRelations->Objects[i]);
    
        mdo1394 = DBCLASS_FindDevicePdo(deviceRelations->Objects[i]);

        if (mdo1394) 
        {
            // we know about this one,
            PDEVICE_EXTENSION   mdo1394DeviceExtension;
            PDBC_CONTEXT        dbcContext;
         
            mdo1394DeviceExtension  = mdo1394->DeviceExtension;
            dbcContext              = mdo1394DeviceExtension->DbcContext;

        
        } 
        else 
        {
            PDEVICE_OBJECT          deviceFilterObject;
            NTSTATUS                ntStatus;
            PDBC_CONTEXT            dbcContext;
            PDEVICE_OBJECT          devObj;
    		PNODE_DEVICE_EXTENSION  nodeExtension;

            devObj = deviceRelations->Objects[i];
    		nodeExtension = devObj->DeviceExtension;

		    // if this is a "virtual" device, just skip it
    		if(nodeExtension->Tag == VIRTUAL_DEVICE_EXTENSION_TAG)
    		{
                DBCLASS_KdPrint((1, "'****> Virtual 1394 Device\n"));                                    
    			continue;
		    }

            // don't know about it,
            // create an MDO for this device

            dbcContext = NULL;

            ntStatus = DBCLASS_CreateDeviceFilterObject(
                deviceExtension->DriverObject,
                &deviceFilterObject,
                devObj,
                dbcContext,
                DB_FDO_1394_DEVICE);

            if (NT_SUCCESS(ntStatus)) 
            {
                DBCLASS_AddDevicePDOToList(deviceFilterObject,
                                         deviceRelations->Objects[i]);
            }                                     

            DBCLASS_KdPrint((1, 
                "'(dbfilter)(bus)(1394) Create DO %x for 1394 PDO\n", 
                    deviceFilterObject));   

        }
    }

DBCLASS_1394QBR_Done:

    KeSetEvent(&deviceExtension->QBusRelations1394Event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


ULONG
DBCLASS_CountConnectedPorts(
    PTOPOLOGY_MAP TopologyMap,
    ULONG Index,
    ULONG Connection
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    SELF_ID         selfId;
    SELF_ID_MORE    selfIdMore;
    ULONG           count = 0;

    selfId = TopologyMap->TOP_Self_ID_Array[Index];

    DBCLASS_KdPrint((2, "'TOP_Self_ID = (%08X)\n",  
        selfId));     
    DBCLASS_KdPrint((2, "'SID_Phys_ID = (%08X)\n", (ULONG) 
        selfId.SID_Phys_ID));             
    DBCLASS_KdPrint((2, "'SID_Port1 = (%08X)\n", (ULONG) 
        selfId.SID_Port1));                         
    DBCLASS_KdPrint((2, "'SID_Port2 = (%08X)\n", (ULONG) 
        selfId.SID_Port2));              
    DBCLASS_KdPrint((2, "'SID_Port3 = (%08X)\n", (ULONG) 
        selfId.SID_Port3));              
    DBCLASS_KdPrint((2, "'SID_More_Packets = (%08X)\n", (ULONG) 
        selfId.SID_More_Packets));                              

#define COUNT_PORT(s) if ((s) == Connection) { count++;}

    COUNT_PORT(selfId.SID_Port1);        
    COUNT_PORT(selfId.SID_Port2);   
    COUNT_PORT(selfId.SID_Port3);   
    
    if (selfId.SID_More_Packets) 
    {

        do 
        {
            Index++;
            RtlCopyMemory(&selfIdMore, 
                          &TopologyMap->TOP_Self_ID_Array[Index],
                          sizeof(ULONG));

            DBCLASS_KdPrint((2, "'SID_Phys_ID = (%08X)\n", (ULONG) 
                selfIdMore.SID_Phys_ID)); 
            DBCLASS_KdPrint((2, "'SID_PortA = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortA));             
            DBCLASS_KdPrint((2, "'SID_PortB = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortB));              
            DBCLASS_KdPrint((2, "'SID_PortC = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortC));                            
            DBCLASS_KdPrint((2, "'SID_PortD = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortD));                            
            DBCLASS_KdPrint((2, "'SID_PortE = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortE));                            
            DBCLASS_KdPrint((2, "'SID_PortF = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortF));                            
            DBCLASS_KdPrint((2, "'SID_PortG = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortG));                            
            DBCLASS_KdPrint((2, "'SID_PortH = (%08X)\n", (ULONG) 
                selfIdMore.SID_PortH));     


            COUNT_PORT(selfIdMore.SID_PortA);        
            COUNT_PORT(selfIdMore.SID_PortB);   
            COUNT_PORT(selfIdMore.SID_PortC);                   
            COUNT_PORT(selfIdMore.SID_PortD);        
            COUNT_PORT(selfIdMore.SID_PortE);   
            COUNT_PORT(selfIdMore.SID_PortF);      
            COUNT_PORT(selfIdMore.SID_PortG);   
            COUNT_PORT(selfIdMore.SID_PortH);                   
                
        } while (selfIdMore.SID_More_Packets);                        
    }

#undef COUNT_PORT

    return count;
}


BOOLEAN
DBCLASS_IsParent(
    PTOPOLOGY_MAP TopologyMap,
    ULONG SelfIdIndex
    )
/*++

Routine Description:

    returns true if the node is 'connetected to parent' (2)

Arguments:

Return Value:

    NTSTATUS

--*/
{
    return TRUE;
}


BOOLEAN
DBCLASS_IsChild(
    PTOPOLOGY_MAP TopologyMap,
    ULONG SelfIdIndex
    )
/*++

Routine Description:

    returns true if the node is 'connetected to child' (3)

Arguments:

Return Value:

    NTSTATUS

--*/
{
    ULONG           i = SelfIdIndex;
    BOOLEAN         isChild = FALSE;
    SELF_ID         selfId;
    SELF_ID_MORE    selfIdMore;
    
    selfId = TopologyMap->TOP_Self_ID_Array[i];

    if (selfId.SID_Port1 == SELF_ID_CONNECTED_TO_CHILD) 
    {
        isChild = TRUE;
    }
    if (selfId.SID_Port2 == SELF_ID_CONNECTED_TO_CHILD) 
    {
        isChild = TRUE;
    }
    if (selfId.SID_Port3 == SELF_ID_CONNECTED_TO_CHILD) 
    {
        isChild = TRUE;
    }
    
    if (selfId.SID_More_Packets) 
    {
        
        do 
        {
            i++;
            RtlCopyMemory(&selfIdMore, 
                          &TopologyMap->TOP_Self_ID_Array[i],
                          sizeof(ULONG));

            if (selfIdMore.SID_PortA == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortB == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortC == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortD == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortE == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortF == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortG == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
            if (selfIdMore.SID_PortH == SELF_ID_CONNECTED_TO_CHILD) 
            {
               isChild = TRUE;
            }
        
        } while (selfIdMore.SID_More_Packets);     
    }
    
    DBCLASS_KdPrint((2, "'IsChild %d\n", isChild));     
        
    return isChild;
}


BOOLEAN
DBCLASS_IsNodeConnectedToLink(
    PDBC_CONTEXT DbcContext,
    PTOPOLOGY_MAP TopologyMap,
    USHORT CurrentNodeId,
    USHORT LinkNodeId
    )
/*++

Routine Description:

        Given the nodeId for a Device and the node Id for the link
        figure out if the node is connected to the link

        return true if it is

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    USHORT      nodeCount, selfIdCount;
    BOOLEAN     connected = FALSE;
    LONG        device_Index = -1;
    ULONG       connectCount, i, childCount, parentCount;
    
    DBCLASS_KdPrint((2, "'TopologyMap = (%08X)\n", TopologyMap));
    DBCLASS_KdPrint((2, "'TOP_Length = (%08X)\n", TopologyMap->TOP_Length)); 
    DBCLASS_KdPrint((2, "'TOP_CRC = (%08X)\n", TopologyMap->TOP_CRC)); 
    DBCLASS_KdPrint((2, "'TOP_Generation = (%08X)\n", TopologyMap->TOP_Generation)); 
    DBCLASS_KdPrint((2, "'TOP_Node_Count = (%08X)\n", TopologyMap->TOP_Node_Count)); 
    DBCLASS_KdPrint((2, "'TOP_Self_ID_Count = (%08X)\n", TopologyMap->TOP_Self_ID_Count));     

    nodeCount = TopologyMap->TOP_Node_Count;  
    selfIdCount = TopologyMap->TOP_Self_ID_Count;
    
    DBCLASS_KdPrint((2, "'nodeCount = (%08X) selfIdCount = (%08X)\n",
        nodeCount, selfIdCount));     

    //
    // walk the topology map and find the index of the node for the 
    // device
    //

    DBCLASS_KdPrint((2, "'Find Node Index\n"));     

    for (i=0; i< nodeCount; i++) 
    {

        SELF_ID selfId;
        SELF_ID_MORE selfIdMore;

        selfId = TopologyMap->TOP_Self_ID_Array[i];
        
        DBCLASS_KdPrint((2, "'[%d] SID_Phys_ID = (%08X)\n", i, (ULONG) 
            selfId.SID_Phys_ID));             

        if (selfId.SID_Phys_ID == CurrentNodeId) 
        {
            // this is the host, count the ports
            device_Index = i;
        }

        if (selfId.SID_More_Packets) 
        {

            do 
            {
                i++;
                RtlCopyMemory(&selfIdMore, 
                              &TopologyMap->TOP_Self_ID_Array[i],
                              sizeof(ULONG));

                DBCLASS_KdPrint((2, "'[%d].more SID_Phys_ID = (%08X)\n", i, (ULONG) 
                    selfIdMore.SID_Phys_ID)); 
                    
            } while (selfIdMore.SID_More_Packets);                        
        }
    } /* for */

    // did we find the device?

    if (device_Index != -1) 
    {

        // yes 
        
        DBCLASS_KdPrint((2, "'-->device_Index found = (%08X)\n",  
            device_Index));                

        // OK if this is a device bay device then it can 
        // have only one connected port
            
        childCount = DBCLASS_CountConnectedPorts(
                            TopologyMap,            
                            device_Index, 
                            SELF_ID_CONNECTED_TO_CHILD);  
                            
        parentCount = DBCLASS_CountConnectedPorts(
                            TopologyMap,            
                            device_Index, 
                            SELF_ID_CONNECTED_TO_PARENT);

        connectCount = childCount + parentCount;

        DBCLASS_KdPrint((2, "'parent = %d child %d\n",  
            parentCount, childCount));                    
            
        DBCLASS_KdPrint((2, "'connectCount = %d \n",  
            connectCount));             

        if (parentCount == 1) 
        {
            // OK possible device bay device
            SELF_ID selfId;
            SELF_ID_MORE selfIdMore;

            i = device_Index;
            
            // port is 'connected to parent' see if it is 
            // the link
            // if it is not the link then this cannot be a DB 
            // device
            i++;
            if (i == selfIdCount) 
            {
                DBCLASS_KdPrint((2, "'NXT ENTRY wraps\n")); 
                i=0;
            }

            while (!DBCLASS_IsChild(TopologyMap, i)) 
            {

                // advance to the next selfId until we find one 
                // that is connected to child(3)
                selfId = TopologyMap->TOP_Self_ID_Array[i];

                // skip 'more packets'
                if (selfId.SID_More_Packets) 
                {
                    do 
                    {
                        i++;
                        RtlCopyMemory(&selfIdMore, 
                                      &TopologyMap->TOP_Self_ID_Array[i],
                                      sizeof(ULONG));

                        DBCLASS_KdPrint((2, "'SID_Phys_ID = (%08X)\n", (ULONG) 
                            selfIdMore.SID_Phys_ID)); 
                    
                    } while (selfIdMore.SID_More_Packets);     
                }

                i++;
                if (i == selfIdCount) 
                {
                    DBCLASS_KdPrint((2, "'NXT ENTRY wraps\n")); 
                    i=0;
                }
            } 
            
            // now check the next entry
            selfId = TopologyMap->TOP_Self_ID_Array[i];
            DBCLASS_KdPrint((2, "'NXT ENTRY - SID_Phys_ID = (%08X)\n", (ULONG) 
                selfId.SID_Phys_ID));             

            if (selfId.SID_Phys_ID == LinkNodeId) 
            {
                connected = TRUE;
            }
        } 
        else if (childCount == 1) 
        {
            // possible DB device
            SELF_ID selfId;
            ULONG physIdPrev, top;
        
            i = device_Index;

            do 
            {
                if (i==0) 
                {
                    i = nodeCount-1;
                } 
                else 
                {
                    i--;
                }
                
                selfId = TopologyMap->TOP_Self_ID_Array[i];
                physIdPrev = selfId.SID_Phys_ID;

                do 
                {
                    top = i;
                    if (i==0) 
                    {
                        i = nodeCount-1;
                    } 
                    else 
                    {
                        i--;
                    }
                    selfId = TopologyMap->TOP_Self_ID_Array[i];
                
                } while (physIdPrev == selfId.SID_Phys_ID);

                i = top;

                DBCLASS_KdPrint((2, "'PREV - idx = %d\n", i));             

                // stop when we find a parent
            } while (!DBCLASS_IsParent(TopologyMap, i)); // entry !=2
              
            // port is 'connected to parent' see if it is 
            // the link

            // advance to the next selfId
            selfId = TopologyMap->TOP_Self_ID_Array[i];
            
            // note that PhysID is the same even if this is a 'more packets'
            // SID
            DBCLASS_KdPrint((2, "'NXT ENTRY - SID_Phys_ID = (%08X)\n", (ULONG) 
                selfId.SID_Phys_ID));             

            if (selfId.SID_Phys_ID == LinkNodeId) 
            {
                connected = TRUE;
            }
        }
    }

    DBCLASS_KdPrint((2, "'>CurrentNodeId %d, LinkNodeId = %d CONNECTED(%d)\n", 
        CurrentNodeId, LinkNodeId, connected));
    BRK_ON_TRAP();
    
    return connected;
}


NTSTATUS
DBCLASS_Check1394DevicePDO(
    PDEVICE_OBJECT FilterDeviceObject,
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT DevicePDO
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                ntStatus;
    PTOPOLOGY_MAP           topologyMap = NULL;
    PNODE_DEVICE_EXTENSION  nodeExtension;
    PDEVICE_EXTENSION       deviceExtension;
    USHORT nodeId,          linkNodeId;
    IRB                     irb;
    
    // get the node id for the device
    deviceExtension = FilterDeviceObject->DeviceExtension;
    nodeExtension = DevicePDO->DeviceExtension;
    nodeId = nodeExtension->NodeAddress.NA_Node_Number;
    DBCLASS_KdPrint((2, "'1394 PDO (%08X) has NodeID = (%08X)\n", 
                DevicePDO, nodeId));            

    // get the topology map from the local host

    ntStatus = DBCLASS_GetSpeedAndTopologyMaps(&topologyMap,
                                               FilterDeviceObject);

    if (DbcContext->ControllerSig == DBC_ACPI_CONTROLLER_SIG && topologyMap) 
    {
        // ACPI dbc 
        // PDO must be a child or parent of the controller

        irb.u.Get1394AddressFromDeviceObject.fulFlags = 0;
        irb.FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
        ntStatus = DBCLASS_SyncSubmitIrb(deviceExtension->TopOfStackDeviceObject,
                                         &irb);

        DBCLASS_KdPrint((2, "'GetLocalNodeId() = (%08X)\n", ntStatus));    
        
        linkNodeId = 
            irb.u.Get1394AddressFromDeviceObject.NodeAddress.NA_Node_Number;
        
        
        
        if (DBCLASS_IsNodeConnectedToLink(DbcContext,
                                          topologyMap,
                                          nodeId,          
                                          linkNodeId)) 
        {            
            ntStatus = STATUS_SUCCESS;
        } 
        else 
        {
            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
        }
                                      
                                      
    } 
    else 
    {
        // USB dbc
        PNODE_DEVICE_EXTENSION  linkExtension;    
        
        // USB dbc 
        // PDO must be a child or parent of the link

        DBCLASS_ASSERT(DbcContext->LinkDeviceObject);
        linkExtension = DbcContext->LinkDeviceObject->DeviceExtension;  
        
        linkNodeId = linkExtension->NodeAddress.NA_Node_Number;
                   
        DBCLASS_ASSERT(RtlCompareMemory(&DbcContext->SubsystemDescriptor.guid1394Link[0],
                                        &linkExtension->ConfigRom->CR_Node_UniqueID[0],
                                        8) == 8);            

        if(topologyMap)
        {
            if (DBCLASS_IsNodeConnectedToLink(DbcContext,
                                              topologyMap,
                                              nodeId,          
                                              linkNodeId)) 
            {
                ntStatus = STATUS_SUCCESS;
            } 
            else 
            {
                ntStatus = STATUS_DEVICE_NOT_CONNECTED;
            }
        }
                         
    }
    
            

    return ntStatus;        
}    


NTSTATUS
DBCLASS_1394GetBusGuid(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR BusGuid
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    ntStatus;
    BOOLEAN     waitForIt = FALSE;
    IRB         irb;
    

    irb.u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
    irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    irb.u.GetLocalHostInformation.Information = BusGuid;
    
    ntStatus = DBCLASS_SyncSubmitIrb(DeviceObject,
                                     &irb);

    DBCLASS_KdPrint((2, "'GetBusGuid() = (%08X)\n", ntStatus));    
    
#if DBG    
    DBCLASS_KdPrint((1, "'>Local Host GUID\n")); 
    DBCLASS_KdPrintGuid(1, BusGuid); 
#endif

    return ntStatus;
}


NTSTATUS
DBCLASS_1394BusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    BOOLEAN             waitForIt = FALSE;
    UCHAR               busGuid1394[8];
    
    deviceExtension = DeviceObject->DeviceExtension;
    ntStatus = Irp->IoStatus.Status;
    *Handled = FALSE;

    LOGENTRY(LOG_MISC, '13b>', 0, DeviceObject, Irp);
    
    ntStatus = Irp->IoStatus.Status;        
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    DBCLASS_KdPrint((1, "'(dbfilter)(bus)(1394)IRP_MJ_ (%08X)  IRP_MN_ (%08X)\n",
        irpStack->MajorFunction, irpStack->MinorFunction));  

    switch (irpStack->MajorFunction) 
    {

    case IRP_MJ_PNP:
        switch (irpStack->MinorFunction) 
        {    
        case IRP_MN_START_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(1394)IRP_MN_START_DEVICE\n"));    
            break;
            
        case IRP_MN_STOP_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(1394)IRP_MN_STOP_DEVICE\n"));  
            break; 
            
        case IRP_MN_REMOVE_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(1394)IRP_MN_REMOVE_DEVICE\n"));    

            DBCLASS_RemoveBusFilterMDOFromList(DeviceObject);

            IoDetachDevice(deviceExtension->TopOfStackDeviceObject);

            IoDeleteDevice (DeviceObject);           
            DBCLASS_KdPrint((1, "'REMOVE DB Filter on 1394 BUS\n"));    
            
            break; 
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:            
        
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(1394)IRP_MN_QUERY_DEVICE_RELATIONS\n"));    

            *Handled = TRUE;
            
            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) 
            {

                DBCLASS_KdPrint((1,"'>>QBR 1394 BUS\n"));
                IoCopyCurrentIrpStackLocationToNext(Irp);

                KeInitializeEvent(&deviceExtension->QBusRelations1394Event, 
                                  NotificationEvent, 
                                  FALSE);

                // Set up a completion routine to handle marking the IRP.
                IoSetCompletionRoutine(Irp,
                                       DBCLASS_1394QBusRelationsComplete,
                                       DeviceObject,
                                       TRUE,
                                       TRUE,
                                       TRUE);
                waitForIt = TRUE;
                
            } 
            else 
            {
                IoSkipCurrentIrpStackLocation(Irp);
            }

            // Now Pass down the IRP

            deviceExtension->QBusRelations1394Success = FALSE;

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);


            if (waitForIt) 
            {
                NTSTATUS status;

                status = KeWaitForSingleObject(&deviceExtension->QBusRelations1394Event,
                                               Suspended,
                                               KernelMode,
                                               FALSE,
                                               NULL);

                // let's see if the call down the stack failed
                if(!deviceExtension->QBusRelations1394Success)
                {
                	IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    break;
                }

                DBCLASS_KdPrint((1, "'**** Searching for Device Bay PDOs \n"));    

                //
                // get the bus guid
                //
                if (NT_SUCCESS(DBCLASS_1394GetBusGuid(
                                deviceExtension->TopOfStackDeviceObject,
                                &busGuid1394[0]))) 
                {

                    PDEVICE_RELATIONS   deviceRelations;
                    ULONG               i;
                    
                    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;


                    // loop thru DOs finding a DBC links
                    
                    for (i=0; i< deviceRelations->Count; i++) 
                    {
                        PDEVICE_EXTENSION   mdo1394DeviceExtension;
                        PDEVICE_OBJECT      mdo1394;

                        // should always be found
                        mdo1394 = DBCLASS_FindDevicePdo(deviceRelations->Objects[i]);                         

						if(!mdo1394)
							continue;
                        
                        mdo1394DeviceExtension = mdo1394->DeviceExtension;

                        DBCLASS_Find1394DbcLinks(
                            mdo1394DeviceExtension->PhysicalDeviceObject);

                    }
                    
                    // loop through PDO list
                    // and try to find the controllers
                    
                    DBCLASS_KdPrint((1, "'**>> DevRel Count (%08X)\n", deviceRelations->Count));                                    

                    for (i=0; i< deviceRelations->Count; i++) 
                    {
                    
                        PDEVICE_EXTENSION mdo1394DeviceExtension;
                        PDEVICE_OBJECT mdo1394;
                        PDEVICE_OBJECT DevicePDO;
    					PNODE_DEVICE_EXTENSION  nodeExtension;
                         
                        LOGENTRY(LOG_MISC, 'FCQB', deviceRelations->Objects[i], i, 0);

                        // should always be found
                        mdo1394 = DBCLASS_FindDevicePdo(deviceRelations->Objects[i]);                         

						if(!mdo1394)
							continue;

                        mdo1394DeviceExtension = mdo1394->DeviceExtension;

						DevicePDO = mdo1394DeviceExtension->PhysicalDeviceObject;

    					nodeExtension = DevicePDO->DeviceExtension;

						DBCLASS_KdPrint((1, "'****>> MDO (%08X)  DbcContext (%08X)  DrvObj (%08X)  DevObj (%08X)  PhysDevObj (%08X)\n",
							mdo1394, mdo1394DeviceExtension->DbcContext,
							deviceExtension->DriverObject, DeviceObject, mdo1394DeviceExtension->PhysicalDeviceObject));


						// if this is a "virtual" device, just skip it
    					if(nodeExtension->Tag == VIRTUAL_DEVICE_EXTENSION_TAG)
    					{
                        	DBCLASS_KdPrint((1, "'****> Virtual 1394 Device\n"));                                    
    						continue;
						}

						DBCLASS_KdPrint((1, "'****>> NodeNumber (%08X) BusNumber (%08X) DevObj (%08X) PortDevObj (%08X)\n",
								nodeExtension->NodeAddress.NA_Node_Number,
								nodeExtension->NodeAddress.NA_Bus_Number,
								nodeExtension->DeviceObject,
								nodeExtension->PortDeviceObject));

		                if (mdo1394DeviceExtension->DbcContext == NULL) 
		                {
                            mdo1394DeviceExtension->DbcContext = 
                                    DBCLASS_FindController1394DevicePdo(
                                            deviceExtension->DriverObject,
                                            DeviceObject,
                                            mdo1394DeviceExtension->PhysicalDeviceObject,
                                            &busGuid1394[0]);
                        }  

                        // this PDO is associated with a controller
                        // see if is really a device bay device

                        DBCLASS_KdPrint((1, "'****> Check 1394 Device\n"));                                    
                        
                        if (mdo1394DeviceExtension->DbcContext) 
                        {
                            PDBC_CONTEXT dbcContext;
                            USHORT bay = 0;

                            DBCLASS_KdPrint((1, "'****>> DBC detected on bus\n"));                                    

                            DBCLASS_KdPrint((2, "'DbcContext (%08X)  PhyDevObj (%08X)\n", mdo1394DeviceExtension->DbcContext,
                                                mdo1394DeviceExtension->PhysicalDeviceObject));                                    

                            dbcContext = mdo1394DeviceExtension->DbcContext;
                            
                            bay = DBCLASS_GetBayFor1394Pdo(
                                            DeviceObject,                                            
                                            mdo1394DeviceExtension->DbcContext,
                                            mdo1394DeviceExtension->PhysicalDeviceObject);        


                            if (bay) 
                            {
                            
                                // This is device bay device
                                dbcContext->BayInformation[bay].DeviceFilterObject = 
                                    mdo1394;    

                                mdo1394DeviceExtension->Bay = bay; 
                                
                                DBCLASS_KdPrint((1, 
                                    "'****>>> 1394 PDO(%x) is in BAY[%d]\n",
                                        mdo1394DeviceExtension->PhysicalDeviceObject,
                                        bay));                                       

                                // Notify PNP that this Device object 
                                // is tied to the controller PDO
                                //TEST_TRAP();
                                IoInvalidateDeviceRelations(dbcContext->ControllerPdo,
                                                            RemovalRelations);                                        
                            } 
                            else 
                            {
                            
                                // not a device bay device
                                mdo1394DeviceExtension->Bay = 0;
                                DBCLASS_KdPrint((1, 
                                    "'****>>> 1394 PDO(%x) is not a DB device\n",
                                        mdo1394DeviceExtension->PhysicalDeviceObject));     
                                        
                            }
                            
                        } 
                        else 
                        {
                            // no DBC phy link on this bus therefore this is 
                            // not a device bay device
                            DBCLASS_KdPrint(
                                (1, "'****>> No DBC detected on bus\n"));                                   
                            mdo1394DeviceExtension->Bay = 0;
                            DBCLASS_KdPrint((1, 
                                "'****>>> 1394 PDO(%x) is not a DB device\n",
                                    mdo1394DeviceExtension->PhysicalDeviceObject));     
                        }
#if DBG   
                        // dump the guid for this PDO
                        {
                            PNODE_DEVICE_EXTENSION nodeExtension;
                        
                            nodeExtension = 
                                mdo1394DeviceExtension->PhysicalDeviceObject->DeviceExtension;
                        
                            DBCLASS_KdPrint((2, "'****>>>> 1394 PDO GUID\n")); 
                            DBCLASS_KdPrintGuid(2, (PUCHAR)&nodeExtension->ConfigRom->CR_Node_UniqueID[0]); 
                        }
#endif
                        
                        DBCLASS_KdPrint((2, "'****>>>>> FC-QBR 1394 PDO[%d] %x DbcContext %x\n", i, 
                                deviceRelations->Objects[i], mdo1394DeviceExtension->DbcContext));     
                    }
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                
            }

            break;            
        } /* irpStack->MinorFunction */
        break;
    } /* irpStack->MajorFunction */      

    LOGENTRY(LOG_MISC, '13b<', 0, DeviceObject, 0);
    
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\devicef.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    devicef.C

Abstract:

    

Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    1394f.C

Abstract:

    

Environment:

    kernel mode only

Notes:


Revision History:

    

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\dbfilter.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBFILTER.C

Abstract:

    This module implements the code to act as a filter 
    driver.

    The DB filter driver functions as several types of 
    filters.

    It is a upper filter sittiing above the FDO for the 
    USB hub and 1394 controller associated with a device
    bay subsystem.

        DB FDO - fdo owned by dbclass.sys
            |
        HUB FDO - fdo owned by usbhub.sys
            |
        HUB PDO - pdo enumerated by hub the device bay is part of

    It is also a filter sitting above the PDOs for devices of USB
    or 1394 that are in the bays

        
        USB/1394 DEVICE FDO - fdo owned USB/1394 device driver
            |
        DB FILTER FDO  - fdo owned by dbclass.sys
            |
        USB/1394 PDO - Pdo enumerated by the native bus 
                        owned by usbhub.sys or 1394bus.sys

    
Environment:

    kernel mode only

Notes:


Revision History:

    

--*/

#include <wdm.h>
#include <initguid.h>  
#include <wdmguid.h>  
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"  
#include "dbclib.h"  
#include "dbf.h"     

#define PDBC_CONTEXT PVOID

#include "dbfilter.h"       


VOID
DBF_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
}


NTSTATUS
DBF_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
DBF_SyncGetFdoType(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PULONG FdoType
    )

/*++
Routine Description:

    This gets the bus type for this PDO (1394 or USB).

Arguments:

    DeviceObject - Physical DeviceObject for the bus.

    FdoType - set to DB_FDO_USBHUB_FILTER or 
                     DB_FDO_1394_FILTER  or 
                     0 if bus type is neither

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KEVENT event;
    PPNP_BUS_INFORMATION busInfo;

    PAGED_CODE();
    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        TRAP(); //"failed to allocate Irp
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_BUS_INFORMATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           DBF_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    busInfo = (PPNP_BUS_INFORMATION) irp->IoStatus.Information;    

#if 0
    if (busInfo) {
        DBF_KdPrint((2, "'busguid %x , guid %x\n",
            &busInfo->BusTypeGuid, 
            &GUID_BUS_TYPE_USB));
*FdoType = DB_FDO_1394_PDO_FILTER  
//*FdoType = DB_FDO_USBHUB_FILTER;                 

        if (RtlCompareMemory(&busInfo->BusTypeGuid, 
                             &GUID_BUS_TYPE_USB, 
                             sizeof(GUID)) == 0) {
            *FdoType = DB_FDO_USBHUB_FILTER;        
        }/* else if (busInfo->BusTypeGuid == GUID_BUS_TYPE_1394) {
            *FdoType = DB_FDO_1394_FILTER            
        } */ else {
            DBF_KdPrint((0, "'unknown BusTypeGuid!\n"));
            TRAP();
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        ExFreePool(busInfo);
    } else {
        DBF_KdPrint((0, "'no busInfo returned!\n"));
        TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
    }
#endif
    // hard code for 1394
    *FdoType = DB_FDO_1394_BUS;  
    ntStatus = STATUS_SUCCESS;
    
    IoFreeIrp(irp);

    return ntStatus;
}


NTSTATUS
DBF_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called when we are loaded as a filter for a USB 
    hub associated with a DBC or the as a global filter for the 1394
    bus.
    
Arguments:

    DriverObject - pointer to the driver object for this instance of UHCD

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_EXTENSION deviceExtension;
    ULONG fdoType;

    MD_TEST_TRAP();

    ntStatus = DBF_SyncGetFdoType(PhysicalDeviceObject,
                                  &fdoType);  
    

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = DBF_CreateDeviceObject(DriverObject,
                                          &deviceObject);
    }                                          

    if (NT_SUCCESS(ntStatus)) {

        deviceExtension = deviceObject->DeviceExtension;

        deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;


        // attach to the FDO for the HUB, ie we are an upper filter
        
        deviceExtension->TopOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        DBCLASS_KdPrint((0, "'Add Device DeviceObject (%08X)  PhysicalDeviceObject (%08X) TopOfStackDevObj (%08X)\n",
                        deviceObject, PhysicalDeviceObject,  deviceExtension->TopOfStackDeviceObject));

        // now that we have a device object we need to figure
        // out what bus we are on, query the bus ID to figure 
        // this out

        deviceExtension->FdoType = fdoType;

        //
        // Preserve flags in lower device object
        //
        
        deviceObject->Flags |= (PhysicalDeviceObject->Flags &
                                (DO_POWER_INRUSH | DO_POWER_PAGABLE));

        deviceObject->Flags |= (PhysicalDeviceObject->Flags &
                                (DO_BUFFERED_IO | DO_DIRECT_IO));

        //
        // Indicate that the device object is ready for requests.
        //
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        // register this filter with the correct DBC
        DBCLASS_RegisterBusFilter(DriverObject, deviceObject);        
    }

    return ntStatus;
}


NTSTATUS
DBF_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the DBC
    bus filter.

Arguments:

    DriverObject - pointer to the driver object for USBD.

    *DeviceObject - ptr to DeviceObject ptr to be filled
                    in with the device object we create.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    ntStatus = IoCreateDevice(DriverObject,
                              sizeof (DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE, //NOT Exclusive
                              DeviceObject);

    if (!NT_SUCCESS(ntStatus) && *DeviceObject) {
        IoDeleteDevice(*DeviceObject);
    }

    return ntStatus;
}

/* 
    We just call in to DBCLASS which has the code to hadnle 
    filtering the various types for Device Objects
*/   

NTSTATUS
DBF_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    return DBCLASS_FilterDispatch(DeviceObject, Irp);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBF_KdPrint((2, "'DriverEntry\n"));

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = 
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = 
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 
    DriverObject->MajorFunction[IRP_MJ_PNP] = 
    DriverObject->MajorFunction[IRP_MJ_POWER] = DBF_Dispatch;
    
    DriverObject->DriverExtension->AddDevice = DBF_AddDevice;

    DriverObject->DriverUnload = DBF_Unload;

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\dbpower.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBPOWER.C

Abstract:

    class driver for device bay controllers

    This module has all the code to deal with 
    the ever changing and confusing WDM power
    management model.


    Some notes on power management:

    1. We currently just put ow device in D3 (OFF) when we 
        receive a system poer state message and restore 
        it D0 when we receive a systemWorking state message.

    2. Waking the system by a device bay controller does not
        really fit the Microsoft ideal system ie there is 
        some debate as to if inserting a device or pressing 
        the buttons should wake the system.

    3. This code should only support WAKEUP on WDM10 ie Windows
        2k.  The ACPI power support in win9x is unreliable an
        support for it should not be attempted.
    
Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"  
#include "dbclass.h"        //private data strutures
#include "dbfilter.h"
#include "usbioctl.h"


NTSTATUS
DBCLASS_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDBC_CONTEXT dbcContext = Context;
    NTSTATUS ntStatus;
    
    irp = dbcContext->PowerIrp;
    
    ntStatus = IoStatus->Status;

    DBCLASS_KdPrint((1, "'>>DBC PoRequestComplete\n"));
    LOGENTRY(LOG_MISC, 'wPWe', dbcContext, 0, 0);
    KeSetEvent(&dbcContext->PowerEvent,
               1,
               FALSE);

    dbcContext->LastSetDXntStatus = ntStatus;

    return ntStatus;
}


NTSTATUS
DBCLASS_ClassPower(
    IN PDEVICE_OBJECT ControllerFdo,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    )    
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDBC_CONTEXT dbcContext;
    DEVICE_POWER_STATE deviceState;

    *HandledByClass = FALSE;
    dbcContext = DBCLASS_GetDbcContext(ControllerFdo);

    ntStatus = Irp->IoStatus.Status;        
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    DBCLASS_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        //
        // someone is enabling us for wakeup
        //
        *HandledByClass = TRUE;
        
        TEST_TRAP();

        // no wakeup support
        // failt the request
        Irp->IoStatus.Status = ntStatus = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT);

        break;

    case IRP_MN_SET_POWER:
    
        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
        
            //
            // find the appropriate power state for this system
            // state
            //
        
            {
            POWER_STATE powerState;

            DBCLASS_KdPrint((1, "'>DBC System Power State: current state %d\n",
                                dbcContext->CurrentDevicePowerState));
            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
                // just go off
                powerState.DeviceState = PowerDeviceD3;
                break;
                
            case PowerSystemWorking:
                powerState.DeviceState = PowerDeviceD0;
                break;
                
            case PowerSystemShutdown:
                DBCLASS_KdPrint((1, "'>>DBC Shutdown detected\n"));
                powerState.DeviceState = PowerDeviceD3;

                // disable bay locks here
                if (dbcContext->Flags |= DBCLASS_FLAG_RELEASE_ON_SHUTDOWN) {
                    USHORT bay;
                    
                    for (bay = 1; bay <= NUMBER_OF_BAYS(dbcContext); bay++) 
                    {
                	PDRB drb;

                	//
                	// notify filter of a stop
                	// note that the filter may not veto the stop
                	//
                	drb = DbcExAllocatePool(NonPagedPool, 
                        	sizeof(struct _DRB_START_DEVICE_IN_BAY));

                	if (drb) 
                	{ 
                
                    	drb->DrbHeader.Length = sizeof(struct _DRB_STOP_DEVICE_IN_BAY);
                    	drb->DrbHeader.Function = DRB_FUNCTION_STOP_DEVICE_IN_BAY;
                    	drb->DrbHeader.Flags = 0;

                    	drb->DrbStartDeviceInBay.BayNumber = bay;
                    
                    	// make the request
                    	ntStatus = DBCLASS_SyncSubmitDrb(dbcContext,
                                                     	 dbcContext->TopOfStack, 
                                                     	 drb);
        				DbcExFreePool(drb);
                	}

                	// just pop out the device --
                	// surprise remove is OK at this point
                	DBCLASS_EjectBay(dbcContext, bay); 

//    				DBCLASS_PostChangeRequest(dbcContext);        
                
#if 0
                        DBCLASS_KdPrint((1, "'>>>disengage interlock bay[%d]\n", bay));
                        DBCLASS_SyncBayFeatureRequest(dbcContext,
                                                      DRB_FUNCTION_CLEAR_BAY_FEATURE,
                                                      bay,
                                                      LOCK_CTL);
#endif

                    }   
                }                    
                
                break;
                
            case PowerSystemUnspecified:
            case PowerSystemHibernate:     
            default:
                powerState.DeviceState = PowerDeviceD3;
                break;
                
            }

            *HandledByClass = TRUE;
            
            //
            // are we already in this state?
            //
            //
            
            if (powerState.DeviceState != 
                dbcContext->CurrentDevicePowerState) {
                
                // No,
                // request that we be put into this state

                // save the system state irp so we can pass it on 
                // when our D-STATE request completes
                dbcContext->PowerIrp = Irp;
                KeInitializeEvent(&dbcContext->PowerEvent, 
                    NotificationEvent, FALSE);
                
                ntStatus = PoRequestPowerIrp(dbcContext->ControllerPdo,
                                             IRP_MN_SET_POWER,
                                             powerState,
                                             DBCLASS_PoRequestCompletion,
                                             dbcContext,
                                             NULL);

                KeWaitForSingleObject(
                    &dbcContext->PowerEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);

                // check the status of the power on request
                if (NT_SUCCESS(dbcContext->LastSetDXntStatus) && 
                    powerState.DeviceState == PowerDeviceD0) {

                    // we are back 'ON'
                    // re-start the controller
                    ntStatus = DBCLASS_StartController(dbcContext,
                                                  Irp,
                                                  HandledByClass);       
                }

                IoCopyCurrentIrpStackLocationToNext(Irp);

                // call down the original system state request
                PoStartNextPowerIrp(Irp);
                PoCallDriver(dbcContext->TopOfPdoStack,
                             Irp);   

//                dbcContext->PowerIrp = NULL;

                                
                
            } else {
            
                // Yes,
                // just pass it on
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(dbcContext->TopOfPdoStack,
                                        Irp);

            }

            } /* SystemPowerState */
            break;

        case DevicePowerState:

            // this is a D state message sent to ourselves
            deviceState = irpStack->Parameters.Power.State.DeviceState;
            
            switch (deviceState) {
            case PowerDeviceD3:

                //
                // device will be going OFF, save any state now.
                //

                DBCLASS_KdPrint((0, "'Set DevicePowerState = D3\n"));
                dbcContext->CurrentDevicePowerState = deviceState;

                 //cancel our outstanding notication
                ntStatus = DBCLASS_StopController(dbcContext,
                                                  Irp,
                                                  HandledByClass);                                            
           
                break;

            case PowerDeviceD1:
            case PowerDeviceD2:
            
                //
                // device will be going in to a low power state
                //
                
                DBCLASS_KdPrint((0, "'Set DevicePowerState = D%d\n",
                    deviceState-1));
                dbcContext->CurrentDevicePowerState = deviceState;

                //cancel our outstanding notication
                ntStatus = DBCLASS_StopController(dbcContext,
                                                  Irp,
                                                  HandledByClass);

                break;

            case PowerDeviceD0:

                //
                // OS will call us when the SET_Dx state  
                // request is complete.
                //

                break;

            default:
                DBCLASS_KdPrint((0, "'Invalid D-state passed in\n"));
                TRAP();
                        
                break;
            } /* case deviceState */

            break;
        } /* case irpStack->Parameters.Power.Type */

        break; 
        
    case IRP_MN_QUERY_POWER:

        *HandledByClass = TRUE;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(dbcContext->TopOfPdoStack,
                                Irp);

        break; /* IRP_MN_QUERY_POWER */            
    
    default:

        *HandledByClass = TRUE;
        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // All PNP_POWER POWER messages get passed to
        // TopOfStackDeviceObject
        //

        // pass on to our PDO
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(dbcContext->TopOfPdoStack,
                                Irp);

    } /* irpStack->MinorFunction */


    return ntStatus;
    
}        




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\dbclass.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBCLASS.H

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the DeviceBay Filter Driver
    
Environment:

    Kernel & user mode

Revision History:

    

--*/

//
// Instance specific Data for the controller
//

#define DBCLASS_EJECT_TIMEOUT     10000     //timeout in ms
                                            //use a 10 second timeout
                                     
#define DBC_CONTEXT_SIG     0x4c434244      //'DBCL'
#define DBC_WORKITEM_SIG    0x4b574244      //'DBWK'

// HW branch registry Keys
#define IS_DEVICE_BAY_KEY               L"IsDeviceBay"
#define DBC_GUID_KEY                    L"DBCGuid"
#define INSTALLED_KEY                   L"installed"
#define ACPI_HUB_KEY                    L"acpiHubParentPort"

// SW branch registry keys
#define RELEASE_ON_SHUTDOWN              L"releaseshutdown"


// class global registry keys
// these are found in HKLM\CCS\Services\Class\dbc
#define DEBUG_LEVEL_KEY                 L"debuglevel"
#define DEBUG_WIN9X_KEY                 L"debugWin9x"
#define DEBUG_BREAK_ON                  L"breakon"


#ifdef DEBUG3
#define MAX_DEBUG
#endif /* DEBUG3 */


#ifndef ANY_SIZE_ARRAY
#define ANY_SIZE_ARRAY  1
#endif

typedef struct _DBC_BAY_INFORMATION {

    ULONG Sig;
    DBC_BAY_DESCRIPTOR BayDescriptor;
    BAY_STATUS LastBayStatus;
    PDEVICE_OBJECT DeviceFilterObject;

    PDEVICE_OBJECT UsbHubPdo;
    ULONG   UsbHubPort;

} DBC_BAY_INFORMATION, *PDBC_BAY_INFORMATION;

#define MAX_DBC_1394_PORTS     16

//
// values for Flags in BUS1394_PORT_INFO
//

#define DBCLASS_PORTFLAG_DEVICE_CONNECTED   0x0000001

typedef struct _BUS1394_PORT_INFO {

    USHORT NodeId;      // 1394 nodeID for device on this port
    USHORT BayNumber;   // Bay number tied to this port
    ULONG Flags;
    
} BUS1394_PORT_INFO , *PBUS1394_PORT_INFO;


typedef struct _DBC_CONTEXT {

    ULONG Sig;
    ULONG Flags;
    ULONG ControllerSig;
    
    // Top of the DB controller stack
    // this is who we call when talking to 
    // the db controller. 
    // This will be the controller FDO or
    // an OEM filter FDO
    PDEVICE_OBJECT TopOfStack;      

    // the controllers FDO
    PDEVICE_OBJECT ControllerFdo;

    // Physical Device Object passed 
    // to controllers AddDevice
    PDEVICE_OBJECT ControllerPdo;

    // Top of PDO stack ie top of stack 
    // returned when controller attaches 
    // to the PDO passed to AddDevice
    PDEVICE_OBJECT TopOfPdoStack;
    
    struct _DBC_CONTEXT *Next;
    PIRP ChangeIrp;
    ULONG PendingIoCount;
    DEVICE_POWER_STATE CurrentDevicePowerState;

    // device object that sits on the PDO for the bus
    // extender
    PDEVICE_OBJECT BusFilterMdo1394;
    PDEVICE_OBJECT BusFilterMdoUSB;
    
    PDRIVER_OBJECT BusFilterDriverObject;

    PDEVICE_OBJECT LinkDeviceObject;
    
    KSEMAPHORE DrbSemaphore;
    KEVENT RemoveEvent;
    KEVENT PowerEvent;
    NTSTATUS LastSetDXntStatus;
    
    DBC_SUBSYSTEM_DESCRIPTOR SubsystemDescriptor;
    DBC_BAY_INFORMATION BayInformation[MAX_BAY_NUMBER+1];

    ULONG NumberOf1394Ports;
    PBUS1394_PORT_INFO Bus1394PortInfo;
    
    PIRP PowerIrp;
    
    struct _DRB_CHANGE_REQUEST ChangeDrb;

    // guid for the 1394c bus this controller is on
    UCHAR Guid1394Bus[8];

    KSPIN_LOCK FlagsSpin;

    BOOLEAN Stopped;

    BOOLEAN EjectRequested;

} DBC_CONTEXT, *PDBC_CONTEXT;

typedef struct _EJECT_CONTEXT {
    PDBC_CONTEXT DbcContext; 
    USHORT Bay;
} EJECT_CONTEXT, *PEJECT_CONTEXT;

typedef struct _DBCLASS_WORKITEM {

    ULONG Sig;
    WORK_QUEUE_ITEM WorkQueueItem;
    PDBC_CONTEXT DbcContext;
    NTSTATUS IrpStatus;
    struct _DBC_EJECT_TIMEOUT_CONTEXT *TimeoutContext;
    
} DBCLASS_WORKITEM, *PDBCLASS_WORKITEM;

typedef struct _DBCLASS_PDO_LIST {
    LIST_ENTRY      ListEntry;
    PDEVICE_OBJECT  PdoDeviceObject;
    PDEVICE_OBJECT  FilterDeviceObject;
} DBCLASS_PDO_LIST, *PDBCLASS_PDO_LIST;



// DBC_CONTEXT Flags values

#define DBCLASS_FLAG_STOPPING                   0x00000001
#define DBCLASS_FLAG_REQ_PENDING                0x00000002
#define DBCLASS_FLAG_RELEASE_ON_SHUTDOWN        0x00000004


#define INITIALIZE_DRB_SERIALIZATION(dc)  KeInitializeSemaphore(&(dc)->DrbSemaphore, 1, 1);

#define DBCLASS_BEGIN_SERIALIZED_DRB(dc)  { DBCLASS_KdPrint((3, "'***WAIT DRB SEM%x\n", &(dc)->DrbSemaphore)); \
                                          KeWaitForSingleObject(&(dc)->DrbSemaphore, \
                                                                Executive,\
                                                                KernelMode, \
                                                                FALSE, \
                                                                NULL); \
                                          }                                                                 

#define DBCLASS_END_SERIALIZED_DRB(dc)  { DBCLASS_KdPrint((3, "'***RELEASE DRB SEM %x\n", &(dc)->DrbSemaphore));\
                                          KeReleaseSemaphore(&(dc)->DrbSemaphore,\
                                                             LOW_REALTIME_PRIORITY,\
                                                             1,\
                                                             FALSE);\
                                        }
                                        
#define NUMBER_OF_BAYS(dbc) ((dbc)->SubsystemDescriptor.bmAttributes.BayCount)

#define DBC_TAG ' cbD'   

/* 
Debug Macros
*/
#if DBG

#ifndef DEBUG_LOG
#define DEBUG_LOG
#endif

VOID
DBCLASS_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

#define DBCLASS_ASSERT(exp) \
    if (!(exp)) { \
        DBCLASS_Assert( #exp, __FILE__, __LINE__, NULL );\
    }            


#define LOGENTRY(mask, sig, info1, info2, info3)
//    DBCLASS_Debug_LogEntry(mask, sig, (ULONG)info1, (ULONG)info2, (ULONG)info3)
    

ULONG
_cdecl
DBCLASS_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

VOID
DBCLASS_LogInit(
    );
    
VOID
DBCLASS_Debug_LogEntry(
    IN ULONG Mask,
    IN ULONG Sig, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    );

#define LOG_MISC          0x00000001        //debug log entries    
    
#define DBCLASS_KdPrint(_x_) DBCLASS_KdPrintX _x_ 
#define TEST_TRAP() { DbgPrint( "DBCLASS: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                      TRAP();}

extern ULONG DBCLASS_BreakOn;                      
#define BRK_ON_TRAP() \
              {\
              if (DBCLASS_BreakOn) {\
                  DbgPrint( "DBCLASS: DEBUG TEST BREAK %s line: %d\n", __FILE__, __LINE__ );\
                  DbgBreakPoint();\
              }\
              }

#define TRAP() DbgBreakPoint()

#define DEBUG_HEAP

extern ULONG DBCLASS_TotalHeapSace;
#define DBCLASS_HEAP_SIG    0x12344321
#define DBCLASS_FREE_TAG    0x11111111

#define DbcExAllocatePool(p, l)  DBCLASS_GetHeap((p), (l), DBCLASS_HEAP_SIG,  \
                &DBCLASS_TotalHeapSace)
#define DbcExFreePool(l) DBCLASS_RetHeap((l), DBCLASS_HEAP_SIG, \
                &DBCLASS_TotalHeapSace)

VOID
DBCLASS_Warning(
    PVOID Context,
    PUCHAR Message,
    BOOLEAN DebugBreak
    );

#else
// NOT DEBUG

#define LOGENTRY(mask, sig, info1, info2, info3) 
#define DBCLASS_ASSERT(exp)
#define DBCLASS_KdPrint(_x_)
#define DBCLASS_KdPrintGuid(_x_, _y_)

#define TRAP()
#define TEST_TRAP() 
#define BRK_ON_TRAP()

#define DbcExAllocatePool(p, l) ExAllocatePoolWithTag((p), (l), DBC_TAG)
#define DbcExFreePool(l) ExFreePool((l))

#define DBCLASS_Warning(x, y, z)

#endif


VOID
DBCLASS_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

PDBC_CONTEXT
DBCLASS_GetDbcContext(
    IN PDEVICE_OBJECT ControllerFdo
    );    

NTSTATUS
DBCLASS_StopController(
    IN PDBC_CONTEXT DbcContext,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    );    

NTSTATUS
DBCLASS_StartController(
    IN PDBC_CONTEXT DbcContext,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    );    

NTSTATUS
DBCLASS_UsbhubBusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    );

NTSTATUS 
DBCLASS_SyncSubmitDrb(
    IN PDBC_CONTEXT DbcContext, 
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRB Drb
    );    

NTSTATUS
DBCLASS_CleanupController(
    IN PDBC_CONTEXT DbcContext
    );    

NTSTATUS 
DBCLASS_SyncGetSubsystemDescriptor(
    IN PDBC_CONTEXT DbcContext
    );

NTSTATUS
DBCLASS_CreateDeviceFilterObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject,
    IN PDEVICE_OBJECT DevicePdo,
    IN PDBC_CONTEXT DbcContext,
    IN ULONG BusTypeSig
    );    

NTSTATUS 
DBCLASS_SyncGetBayDescriptor(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT BayNumber,
    IN PDBC_BAY_DESCRIPTOR BayDescriptor
    );   

NTSTATUS 
DBCLASS_SyncGetAllBayDescriptors(
    IN PDBC_CONTEXT DbcContext
    );

VOID
DBCLASS_ChangeIndicationWorker(
    IN PVOID Context
    );

NTSTATUS 
DBCLASS_SyncGetBayStatus(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT BayNumber,
    IN PBAY_STATUS BayStatus
    );

NTSTATUS 
DBCLASS_SyncBayFeatureRequest(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT Op,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    );    

NTSTATUS
DBCLASS_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    );    

VOID
DBCLASS_PostChangeRequest(
    IN PDBC_CONTEXT DbcContext
    );    

NTSTATUS
DBCLASS_ProcessCurrentBayState(
    IN PDBC_CONTEXT DbcContext,
    IN BAY_STATUS BayStatus,
    IN USHORT Bay,
    IN PBOOLEAN PostChgangeRequest
    );    

NTSTATUS
DBCLASS_1394BusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    );    

NTSTATUS
DBCLASS_PdoFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    ); 

NTSTATUS
DBCLASS_EjectPdo(
    IN PDEVICE_OBJECT DeviceFilterObject
    );    

NTSTATUS
DBCLASS_EnableDevice(
    IN PDEVICE_OBJECT DeviceFilterObject
    );

USHORT
DBCLASS_GetBayNumber(
    IN PDEVICE_OBJECT DeviceFilterObject
    );    

NTSTATUS
DBCLASS_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );    

USHORT
DBCLASS_GetBayFor1394Pdo(
    PDEVICE_OBJECT BusFilterMdo,
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT Pdo1394
    );    

NTSTATUS
DBCLASS_DevicePdoQCapsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PDEVICE_OBJECT
DBCLASS_FindDevicePdo(
    PDEVICE_OBJECT PdoDeviceObject
    );

NTSTATUS
DBCLASS_BusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    );    

NTSTATUS 
DBCLASS_GetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    );

PDBC_CONTEXT
DBCLASS_FindController1394DevicePdo(
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo,
    PDEVICE_OBJECT DevicePdo1394,
    PUCHAR BusGuid
    );

NTSTATUS
DBCLASS_Check1394DevicePDO(
    PDEVICE_OBJECT FilterDeviceObject,
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT DevicePDO
    );    

BOOLEAN
DBCLASS_IsHubPartOfACPI_DBC(
    PDEVICE_OBJECT DeviceObject
    );    

USHORT
DBCLASS_GetBayForUSBPdo(
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT PdoUSB
    );


#if DBG
VOID 
DBCLASS_AssertBaysEmpty(
    PDBC_CONTEXT DbcContext
    );    
#else
#define DBCLASS_AssertBaysEmpty(d)    
#endif

PVOID
DBCLASS_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

VOID
DBCLASS_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

#if DBG
VOID
DBCLASS_KdPrintGuid(
    ULONG Level,
    PUCHAR P
    );
#endif    

NTSTATUS
DBCLASS_1394GetBusGuid(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR BusGuid
    );

NTSTATUS
DBCLASS_Find1394DbcLinks(
    PDEVICE_OBJECT DevicePdo1394
    );    

NTSTATUS
DBCLASS_EjectBay(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT Bay
    );

NTSTATUS
DBCLASS_SetEjectTimeout(
    PDEVICE_OBJECT DeviceFilterMDO
    );

NTSTATUS
DBCLASS_CancelEjectTimeout(
    PDEVICE_OBJECT DeviceFilterMDO
    );    

NTSTATUS 
DBCLASS_SetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN ULONG Type,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    );    

NTSTATUS
DBCLASS_SetupUSB_DBC(
    PDBC_CONTEXT DbcContext
    );

NTSTATUS
DBCLASS_GetHubDBCGuid(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR DbcGuid
    );

PDBC_CONTEXT
DBCLASS_FindControllerUSB(
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo,
    PDEVICE_OBJECT UsbHubPdo
    );

BOOLEAN
DBCLASS_IsHubPartOfUSB_DBC(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCLASS_CheckPhyLink(
    PDEVICE_OBJECT DevicePdo1394
    );

BOOLEAN
DBCLASS_IsLinkDeviceObject(
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT Pdo1394
    );    

NTSTATUS
DBCLASS_AddDevicePDOToList(
    IN PDEVICE_OBJECT FilterDeviceObject,
    IN PDEVICE_OBJECT PdoDeviceObject
    );

VOID
DBCLASS_RemoveDevicePDOFromList(
    IN PDEVICE_OBJECT PdoDeviceObject
    );    

VOID
DBCLASS_Refresh1394(
    VOID
    );    

NTSTATUS
DBCLASS_AddBusFilterMDOToList(
    PDEVICE_OBJECT BusFilterMdo
    );    

VOID
DBCLASS_RemoveBusFilterMDOFromList(
    PDEVICE_OBJECT BusFilterMdo
    );    

NTSTATUS
DBCLASS_ClassPower(
    IN PDEVICE_OBJECT ControllerFdo,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    );    

NTSTATUS
DBCLASS_CheckForAcpiDeviceBayHubs(
    PDEVICE_OBJECT HubPdo,
    ULONG AcpiDBCHubParentPort
    );

NTSTATUS
DBCLASS_GetClassGlobalDebugRegistryParameters(
    );    

NTSTATUS
DBCLASS_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );    

NTSTATUS
DBCLASS_GetClassGlobalRegistryParameters(
    );  

NTSTATUS
DBCLASS_EjectBayComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );    

VOID
DBCLASS_RemoveControllerFromMdo(PDBC_CONTEXT DbcContext);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\dbg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for DBCLASS driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    11-5-96 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbci.h"
#include "dbclass.h"
#include "dbfilter.h"


#ifdef MAX_DEBUG
#define DEBUG_HEAP
#endif

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


#if DBG 

extern ULONG DBCLASS_Debug_Trace_Level;

#ifdef NTKERN_TRACE
ULONG DBCLASS_W98_Debug_Trace = 1;    
#else
ULONG DBCLASS_W98_Debug_Trace = 0;
#endif


NTSTATUS
DBCLASS_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[4];
    PWCHAR usb = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBCLASS_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL_KEY;
    QueryTable[0].EntryContext = &DBCLASS_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBCLASS_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(DBCLASS_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = DBCLASS_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X_KEY;
    QueryTable[1].EntryContext = &DBCLASS_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &DBCLASS_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(DBCLASS_W98_Debug_Trace);

    // break on start
    QueryTable[2].QueryRoutine = DBCLASS_GetConfigValue;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = DEBUG_BREAK_ON;
    QueryTable[2].EntryContext = &DBCLASS_BreakOn;
    QueryTable[2].DefaultType = REG_DWORD;
    QueryTable[2].DefaultData = &DBCLASS_BreakOn;
    QueryTable[2].DefaultLength = sizeof(DBCLASS_BreakOn);
    
    //
    // Stop
    //
    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         DBCLASS_KdPrint((1, "'Debug Trace Level Set: (%d)\n", DBCLASS_Debug_Trace_Level));
  
        if (DBCLASS_W98_Debug_Trace) {
            DBCLASS_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            DBCLASS_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (DBCLASS_BreakOn) {
            DBCLASS_KdPrint((1, "'DEBUG BREAK is ON\n"));
        } 
          
    
    
        if (DBCLASS_Debug_Trace_Level > 0) {
            ULONG DBCLASS_Debug_Asserts = 1;
        }
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}


VOID 
DBCLASS_AssertBaysEmpty(
    PDBC_CONTEXT DbcContext
    )
{
    USHORT bay;        

    for (bay=1; bay <=NUMBER_OF_BAYS(DbcContext); bay++) {
        DBCLASS_ASSERT(
            DbcContext->BayInformation[bay].DeviceFilterObject == NULL); 
    }
}
    
VOID
DBCLASS_Warning(
    PVOID Context,
    PUCHAR Message,
    BOOLEAN DebugBreak
    )
{                                                                                               
    DbgPrint("DBCLASS: Warning *************************************************************\n");
    DbgPrint("%s", Message);
    DbgPrint("******************************************************************************\n");

    if (DebugBreak) {
        TRAP();
    }
}


VOID
DBCLASS_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:

    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
   
    TRAP();
    if (stop) {
        goto assert_loop;
    }        

    return;
}


ULONG
_cdecl
DBCLASS_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (DBCLASS_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            // dump line to debugger
            if (DBCLASS_W98_Debug_Trace) {
                DbgPrint("DBCLASS.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'DBCLASS.SYS: ");
            }
        } else {
            // dump line to NTKERN buffer
            DbgPrint("'DBCLASS.SYS: ");
            if (DBCLASS_W98_Debug_Trace) {            
                *Format = 0x27;
            }              
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


PVOID
DBCLASS_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    PoolType - pool type passed to ExAllocatePool
    
    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    
    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER)*2,
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;        
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;

        tagBuffer = (PHEAP_TAG_BUFFER) (p + NumberOfBytes);
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;     
    }                                            

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, 'GetH', p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else    
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */                
    return p;
}

VOID
DBCLASS_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER endTagBuffer;    
    PHEAP_TAG_BUFFER beginTagBuffer;

    DBCLASS_ASSERT(P != 0);
    
    beginTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));
    endTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P + beginTagBuffer->Length);

    *TotalAllocatedHeapSpace -= beginTagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);    
//    LOGENTRY(LOG_MISC, 'RetH', P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    DBCLASS_ASSERT(*TotalAllocatedHeapSpace >= 0);
    DBCLASS_ASSERT(beginTagBuffer->Sig == Signature);
    DBCLASS_ASSERT(endTagBuffer->Sig == Signature);
    DBCLASS_ASSERT(endTagBuffer->Length == beginTagBuffer->Length);
    
    // fill the buffer with bad data
    RtlFillMemory(P, beginTagBuffer->Length, 0xff);
    beginTagBuffer->Sig = DBCLASS_FREE_TAG;

    // free the original block
    ExFreePool(beginTagBuffer);    
#else
    ExFreePool(P);        
#endif /* DEBUG_HEAP */
}

#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct LOG_ENTRY {
    ULONG    le_sig;        // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct LOG_ENTRY *DbclassLStart = 0;    // No log yet
struct LOG_ENTRY *DbclassLPtr;
struct LOG_ENTRY *DbclassLEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else 
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
DBCLASS_Debug_LogEntry(
    IN ULONG Mask,
    IN ULONG Sig, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    )
/*++

Routine Description:

    Adds an Entry to USBH log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

typedef union _SIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} SIG, *PSIG;

    SIG sig, rsig;

    if (DbclassLStart == 0) {
        return;
    }        

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }        
    
    if (DbclassLPtr > DbclassLStart) {
        DbclassLPtr -= 1;    // Decrement to next entry
    } else {
        DbclassLPtr = DbclassLEnd;
    }        

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }        

    DBCLASS_ASSERT(DbclassLPtr >= DbclassLStart);

    sig.l = Sig;
    rsig.b.Byte0 = sig.b.Byte3;
    rsig.b.Byte1 = sig.b.Byte2;
    rsig.b.Byte2 = sig.b.Byte1;
    rsig.b.Byte3 = sig.b.Byte0;
    
    DbclassLPtr->le_sig = rsig.l;        
    DbclassLPtr->le_info1 = Info1;
    DbclassLPtr->le_info2 = Info2;
    DbclassLPtr->le_info3 = Info3;

    return;
}


VOID
DBCLASS_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;    
#else
    ULONG logSize = 4096*3;    
#endif

    
    KeInitializeSpinLock(&LogSpinLock);

    DbclassLStart = ExAllocatePoolWithTag(NonPagedPool, 
                                          logSize,
                                          DBC_TAG); 

    if (DbclassLStart) {
        DbclassLPtr = DbclassLStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        DbclassLEnd = DbclassLStart + (logSize / sizeof(struct LOG_ENTRY)) - 1;
    } else {
        TRAP(); //no mem for log!
    }

    return;
}

VOID
DBCLASS_LogFree(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (DbclassLStart) {
        ExFreePool(DbclassLStart);
    }
}

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\dbclass.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBCLASS.C

Abstract:

    class driver for device bay controllers

    This module implements the code to function as 
    the Device Bay controller class driver
    
Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"  
#include "dbclass.h"        //private data strutures
#include "dbfilter.h"
#include "usbioctl.h"

#include "1394.h"

#include <initguid.h>  
#include <wdmguid.h> 

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DBCLASS_SyncSubmitDrb)
#pragma alloc_text(PAGE, DBCLASS_SyncGetSubsystemDescriptor)
#pragma alloc_text(PAGE, DBCLASS_SyncGetBayDescriptor)
#pragma alloc_text(PAGE, DBCLASS_SyncGetAllBayDescriptors)
#pragma alloc_text(PAGE, DBCLASS_SyncBayFeatureRequest)
#pragma alloc_text(PAGE, DBCLASS_SyncGetBayStatus)
#endif


/*
    Global Data Structures
*/

PDBC_CONTEXT DBCLASS_ControllerList;
KSPIN_LOCK DBCLASS_ControllerListSpin;

// Internal list of Device PDOs 
LIST_ENTRY DBCLASS_DevicePdoList;

//Internal list of Bus filter MDOs
LIST_ENTRY DBCLASS_BusFilterMdoList;

//
// We currently only allow one USB hub to be associated with 
// an ACPI Device Bay Controller.
// This hub may be the root hub or a real hub connected to one of 
// the root hub ports (ie Tier 1 only)
//
// We use the following global variable (since we only support
// one ACPI DBC) to indicate the upstream port for the hub 
// 0 indicates the hub is the root hub
// -1 indicates no ACPI DBC present
//

LONG DBCLASS_AcpiDBCHubParentPort = -1;

// set up the debug variables

#if DBG
ULONG DBCLASS_TotalHeapSace = 0;
ULONG DBCLASS_BreakOn = 0;

// #define DEBUG3

#ifdef DEBUG1
ULONG DBCLASS_Debug_Trace_Level = 1;
#else
    #ifdef DEBUG2
    ULONG DBCLASS_Debug_Trace_Level = 2;    
    #else 
        #ifdef DEBUG3
        ULONG DBCLASS_Debug_Trace_Level = 3;        
        #else
        ULONG DBCLASS_Debug_Trace_Level = 0;
        #endif /* DEBUG 3 */
    #endif /* DEBUG2 */
#endif /* DEBUG1 */

#endif /* DBG */


VOID 
DBCLASS_Wait(
    IN ULONG MilliSeconds
    )
 /* ++
  * 
  * Descriptor:
  * 
  * This causes the thread execution delayed for MiliSeconds.
  * 
  * Argument:
  * 
  * Mili-seconds to delay.
  * 
  * Return:
  * 
  * VOID
  * 
  * -- */
{
    LARGE_INTEGER time;
    ULONG timerIncerent;

    DBCLASS_KdPrint((2,"'Wait for %d ms\n", MilliSeconds));

    //
    // work only when LowPart is not overflown.
    //
    DBCLASS_ASSERT(21474 > MilliSeconds);

    //
    // wait ulMiliSeconds( 10000 100ns unit)
    //
    timerIncerent = KeQueryTimeIncrement() - 1;
    
    time.HighPart = -1;
    // round up to the next highest timer increment
    time.LowPart = -1 * (10000 * MilliSeconds + timerIncerent);
    KeDelayExecutionThread(KernelMode, FALSE, &time);

    return;
}

BOOLEAN
IsBitSet(
    PVOID Bitmap,
    ULONG BitNumber
    )
 /* ++
  *
  * Description:
  *
  * Check if a bit is set given a string of bytes.
  *
  * Arguments:
  *
  * 
  *
  * Return:
  *
  * TRUE - if the corresponding bit is set. FALSE - otherwise
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PULONG l = (PULONG) Bitmap;


    dwordOffset = BitNumber / 32;
    bitOffset = BitNumber % 32;

    return ((l[dwordOffset] & (1 << bitOffset)) ? TRUE : FALSE);
}


LONG
DBCLASS_DecrementIoCount(
    IN PDBC_CONTEXT DbcContext
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    LONG ioCount;

    ioCount = InterlockedDecrement(&DbcContext->PendingIoCount);
    LOGENTRY(LOG_MISC, 'ioc-', DbcContext->PendingIoCount, ioCount, 0);
    
    DBCLASS_KdPrint ((2, "'Dec Pending io count = %x\n", ioCount));

    if (ioCount==0) {
        LOGENTRY(LOG_MISC, 'wRMe', DbcContext, 0, 0);
        KeSetEvent(&DbcContext->RemoveEvent,
                   1,
                   FALSE);
    }

    return ioCount;
}


VOID
DBCLASS_IncrementIoCount(
    IN PDBC_CONTEXT DbcContext
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    InterlockedIncrement(&DbcContext->PendingIoCount);
    LOGENTRY(LOG_MISC, 'ioc+', DbcContext->PendingIoCount, 0, 0);
}

#if 0
VOID
SetBit(
    PVOID Bitmap,
    ULONG BitNumber
    )
 /* ++
  *
  * Description:
  *
  * Set a bit in a given a string of bytes.
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PULONG l = (PULONG) Bitmap;


    dwordOffset = BitNumber / 32;
    bitOffset = BitNumber % 32;

    l[dwordOffset] | =(1 << bitOffset);
}
#endif


NTSTATUS 
DBCLASS_SyncSubmitDrb(
    IN PDBC_CONTEXT DbcContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRB Drb
    )
 /* ++
  * 
  * Routine Description:
  * 
  * Passes a DRB to the DB Port Driver, and waits for return.
  * 
  * Arguments:
  * 
  * DeviceObject - Device object of the to of the port driver
  *                 stack
  * 
  * Return Value:
  * 
  * STATUS_SUCCESS if successful
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
#ifdef DEADMAN_TIMER  
    BOOLEAN haveTimer = FALSE;
    KDPC timeoutDpc;
    KTIMER timeoutTimer;
#endif

    PAGED_CODE();

    DBCLASS_BEGIN_SERIALIZED_DRB(DbcContext);
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_DBC_SUBMIT_DRB,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,  // INTERNAL
                                        &event,
                                        &ioStatus);

    if (NULL == irp) {
        DBCLASS_KdPrint((0, "'could not allocate an irp!\n"));
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Call the port driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the DRB 
    //
    nextStack->Parameters.Others.Argument1 = Drb;
    ntStatus = IoCallDriver(DeviceObject, irp);
    
    if (ntStatus == STATUS_PENDING) {

#ifdef DEADMAN_TIMER
        LARGE_INTEGER dueTime;

        KeInitializeTimer(&timeoutTimer);
        KeInitializeDpc(&timeoutDpc,
                        UsbhTimeoutDPC,
                        irp);

        dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        KeSetTimer(&timeoutTimer,
                   dueTime,
                   &timeoutDpc);        

        haveTimer = TRUE;
#endif
    
        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

    } else {
        ioStatus.Status = ntStatus;
    }

#ifdef DEADMAN_TIMER
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) {
        KeCancelTimer(&timeoutTimer);
    }                
#endif /* DEADMAN_TIMER */

    DBCLASS_END_SERIALIZED_DRB(DbcContext);
    
    ntStatus = ioStatus.Status;

    DBCLASS_KdPrint((2,"'DBCLASS_SyncSubmitDrb (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
DBCLASS_StartController(
    IN PDBC_CONTEXT DbcContext,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    )
/*++

Routine Description:

    This routine starts the DBC note that we should never set
    HandledByClass to TRUE because the port driver always completes
    this request (if we get an error we just need to set the 
    ntStatus code) 
    
Arguments:

    DbcContext - context for controller

    Irp - 

    HandledByClass - not used

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT bay;
    CHAR stackSize;
    BOOLEAN Device1394IsPresent = FALSE;

    DBCLASS_KdPrint((1, "'Starting DBC\n"));
    BRK_ON_TRAP();

    LOGENTRY(LOG_MISC, 'STRd', DbcContext, 0, 0);

    INITIALIZE_DRB_SERIALIZATION(DbcContext);
    KeInitializeSpinLock(&DbcContext->FlagsSpin);
    KeInitializeEvent(&DbcContext->RemoveEvent, NotificationEvent, FALSE);
    DbcContext->PendingIoCount = 0;
    DbcContext->Flags = 0;
    // this will be set when the filter registers
    DbcContext->BusFilterMdo1394 = NULL;
    DbcContext->BusFilterMdoUSB = NULL;
    
    stackSize = DbcContext->TopOfStack->StackSize;
    DbcContext->ChangeIrp = IoAllocateIrp(stackSize, FALSE);
    DbcContext->Bus1394PortInfo = NULL;
    DbcContext->LinkDeviceObject = NULL;
    
    if (NULL == DbcContext->ChangeIrp ) {
        DBCLASS_KdPrint((0, "'could not allocate an irp!\n"));
        TRAP();
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {
        // get the susbsystem descriptor
        ntStatus = DBCLASS_SyncGetSubsystemDescriptor(DbcContext);
    }        

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = DBCLASS_SyncGetAllBayDescriptors(DbcContext);
    }

    //
    // if this is a USBDBC then write the approptiate info
    // to the registry
    //
    if (NT_SUCCESS(ntStatus)) {
        if (DbcContext->ControllerSig == DBC_USB_CONTROLLER_SIG) {
            // this will set the registry keys for the hub
            // the USBDBC is attached to -- marking it as a 
            // DBC associated hub
            ntStatus = DBCLASS_SetupUSB_DBC(DbcContext);
            
        } else {

            // controller is ACPI therefore the 1394 bus guid is the 
            // same as the 1394 guid reported by the DBC -- ie there 
            // is no extra Link Phy for an ACPI DBC.
            
            // get the ACPIDBC Hub register now from the 
            // registry
            
            DBCLASS_GetRegistryKeyValueForPdo(DbcContext->ControllerPdo,
                                      FALSE,
                                      ACPI_HUB_KEY,
                                      sizeof(ACPI_HUB_KEY),
                                      &DBCLASS_AcpiDBCHubParentPort,
                                      sizeof(DBCLASS_AcpiDBCHubParentPort));
                                      
            DBCLASS_KdPrint((1, "'ACPI USB Parent Port: %d\n", 
                    DBCLASS_AcpiDBCHubParentPort));

#if DBG
            if (DBCLASS_AcpiDBCHubParentPort == -1) {
                DBCLASS_KdPrint((0, "'ACPI USB Parent Port not set!\n"));
                TEST_TRAP();
            }
#endif
            
            RtlCopyMemory(&DbcContext->Guid1394Bus[0], 
                          &DbcContext->SubsystemDescriptor.guid1394Link[0],
                          8);

        }
    }
    
    //
    // initialize per bay structures
    //

    DbcContext->BayInformation[0].DeviceFilterObject = (PVOID) -1;
    for (bay=1; bay <=NUMBER_OF_BAYS(DbcContext); bay++) {
    
        PDBC_BAY_DESCRIPTOR bayDescriptor;

        bayDescriptor = 
            &DbcContext->BayInformation[bay].BayDescriptor;
        
        // initilaize current status to 'empty'
        
        DbcContext->BayInformation[bay].LastBayStatus.us = 0;
        DbcContext->BayInformation[bay].DeviceFilterObject = NULL;

        // set the hub port number based on what the 
        // controller reported
        DbcContext->BayInformation[bay].UsbHubPort = 
             bayDescriptor->bHubPortNumber;
        

#if DBG
        DBCLASS_KdPrint((1,"'>BAY[%d].BayDescriptor.bBayNumber %d\n", 
                            bay, bayDescriptor->bBayNumber));                                     
        DBCLASS_KdPrint((1,"'>BAY[%d].BayDescriptor.bHubPortNumber %d\n", 
                            bay, bayDescriptor->bHubPortNumber));                                     
        DBCLASS_KdPrint((1,"'>BAY[%d].BayDescriptor.bPHYPortNumber %d\n", 
                            bay, bayDescriptor->bPHYPortNumber));                                     
        DBCLASS_KdPrint((1,"'>BAY[%d].BayDescriptor.bFormFactor %d\n", 
                            bay, bayDescriptor->bFormFactor));                                     
#endif        
    }
    
    // now post a notification
    if (NT_SUCCESS(ntStatus)) {
        
        DBCLASS_PostChangeRequest(DbcContext);
    } 

    if (NT_SUCCESS(ntStatus)) {
        // Bays initialized:
        //
        // Enable change indications for all bays, we post a change irp 
        // in case we start getting notifications right away
        //

        for (bay=1; bay <= NUMBER_OF_BAYS(DbcContext); bay++) {
            DBCLASS_SyncBayFeatureRequest(DbcContext,
                                      DRB_FUNCTION_SET_BAY_FEATURE, 
                                      bay, 
                                      DEVICE_STATUS_CHANGE_ENABLE); 
                                      
            DBCLASS_SyncBayFeatureRequest(DbcContext, 
                                      DRB_FUNCTION_SET_BAY_FEATURE, 
                                      bay, 
                                      REMOVAL_REQUEST_ENABLE);            
        }     

        //
        // check the initial state of the bays
        //
        // see if any devices are present 
        // 

        DBCLASS_KdPrint((1,"'STARTCONTROLLER: Checking Bays\n")); 
        
        for (bay=1; bay <= NUMBER_OF_BAYS(DbcContext); bay++) {

            NTSTATUS status;
            BAY_STATUS bayStatus;        

            status = DBCLASS_SyncGetBayStatus(DbcContext,
                                              bay,
                                              &bayStatus);

            if (NT_SUCCESS(status)) {
                DBCLASS_KdPrint((1,"'STARTCONTROLLER: init state - bay[%d] %x\n",
                    bay, bayStatus.us));                                     

                // 
                
                if (bayStatus.DeviceUsbIsPresent || 
                    bayStatus.Device1394IsPresent) {

                    if(bayStatus.Device1394IsPresent)
                        Device1394IsPresent = TRUE;
                        
                    // we have a device in the bay
                    DBCLASS_KdPrint((1,"'STARTCONTROLLER: detected device in bay[%d] %x\n",                    
                                    bay));
                                    
                    switch(bayStatus.CurrentBayState) {
                    
                    case BAY_STATE_EMPTY:
                    case BAY_STATE_DEVICE_ENABLED:  
                        // note:
                        // on the TI dbc if the bay state is enabled the device does
                        // not appear on the native bus
                    case BAY_STATE_DEVICE_INSERTED:
                        // note:
                        // on the TI dbc if the bay state is inserted the device does
                        // not appear on the native bus
                    
                        DBCLASS_KdPrint((1,"'STARTCONTROLLER: setting bay %d to inserted state\n", bay));                                     

                        DBCLASS_SyncBayFeatureRequest(DbcContext,
                                                      DRB_FUNCTION_SET_BAY_FEATURE,
                                                      bay,
                                                      REQUEST_DEVICE_INSERTED_STATE);

                        // get the new status and process it                                           
                        status = DBCLASS_SyncGetBayStatus(DbcContext,
                                                          bay,
                                                          &bayStatus);
                                                      
                        if (NT_SUCCESS(status)) {
                            DBCLASS_ProcessCurrentBayState(DbcContext,
                                                           bayStatus,
                                                           bay,
                                                           NULL);                                              
                        }                                                   
                        break;
                        
                    default:
                        break;
                        
                    } /* switch  bayStatus.CurrentBayState */
                }                
            }            
        }
    } /* nt_success */

    if (NT_SUCCESS(ntStatus)) {

        // get registry controled features
        {
        NTSTATUS status;
        ULONG release_on_shutdown = 0;

        // check unlock on shutdown, the default is on            
        status = DBCLASS_GetRegistryKeyValueForPdo(
                                           DbcContext->ControllerPdo,
                                           TRUE,
                                           RELEASE_ON_SHUTDOWN,
                                           sizeof(RELEASE_ON_SHUTDOWN),
                                           &release_on_shutdown,
                                           sizeof(release_on_shutdown));
                                           
        DBCLASS_KdPrint((1,"'STARTCONTROLLER: release_on_shutdown = %d\n", 
            release_on_shutdown));                                               
        if (release_on_shutdown) {
            DbcContext->Flags |= DBCLASS_FLAG_RELEASE_ON_SHUTDOWN;                                             
        }
        }
        
        //
        // consider ourselves started
        // note: if we return an error stopcontroller
        // will not be called
        //
        
        DbcContext->Stopped = FALSE;

        // set our current power state to 'D0' ie ON
        DbcContext->CurrentDevicePowerState = PowerDeviceD0;

        // in order for the DBC to be linked to a 1394 bus
        // we need to do an IoInvalidateDeviceRelations on 
        // all 1394 busses

        if(Device1394IsPresent)
            DBCLASS_Refresh1394();
   
    }

    // transition to zero signals stop/remove
    //
    // since we will get a stop even if we return
    // an error we alaways increment
    DBCLASS_IncrementIoCount(DbcContext);

    DBCLASS_KdPrint((1,"'STARTCONTROLLER: ntStatus = %x\n", ntStatus));  
    LOGENTRY(LOG_MISC, 'STRT', DbcContext, 0, ntStatus);
    return ntStatus;
}    


NTSTATUS
DBCLASS_CleanupController(
    IN PDBC_CONTEXT DbcContext
    )
/*++

Routine Description:

    cleans up the DBC on stop or remove
    
Arguments:

    DbcContext - context for controller

Return Value:

    STATUS_SUCCESS if successful

--*/
{

    NTSTATUS ntStatus;

    LOGENTRY(LOG_MISC, 'clUP', DbcContext, 0, 0);

    ntStatus = STATUS_SUCCESS;

    return ntStatus;

}


NTSTATUS
DBCLASS_StopController(
    IN PDBC_CONTEXT DbcContext,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    )
/*++

Routine Description:

    Stops the DBC
    
Arguments:

    DbcContext - context for controller

    Irp - 

    HandledByClass - set to true if we need to complete the Irp


Return Value:

    STATUS_SUCCESS if successful

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;
    BOOLEAN needCancel;

    DBCLASS_KdPrint((1, "'Stopping DBC\n"));
    LOGENTRY(LOG_MISC, 'STP>', DbcContext, 0, 0);

    // disable bay locks here
    if (DbcContext->Flags |= DBCLASS_FLAG_RELEASE_ON_SHUTDOWN) 
    {
        USHORT bay;
                    
        for (bay = 1; bay <= NUMBER_OF_BAYS(DbcContext); bay++) 
        {
          	PDRB drb;

           	//
           	// notify filter of a stop
           	// note that the filter may not veto the stop
           	//
           	drb = DbcExAllocatePool(NonPagedPool, 
                   	sizeof(struct _DRB_START_DEVICE_IN_BAY));

           	if (drb) 
           	{ 
           
               	drb->DrbHeader.Length = sizeof(struct _DRB_STOP_DEVICE_IN_BAY);
               	drb->DrbHeader.Function = DRB_FUNCTION_STOP_DEVICE_IN_BAY;
               	drb->DrbHeader.Flags = 0;

               	drb->DrbStartDeviceInBay.BayNumber = bay;
                    
               	// make the request
               	ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                               	 DbcContext->TopOfStack, 
                                               	 drb);
    			DbcExFreePool(drb);
           	}

        }
    }


    // cancel any pending notification Irps
    KeAcquireSpinLock(&DbcContext->FlagsSpin, &irql);            
    
    DbcContext->Flags |= DBCLASS_FLAG_STOPPING;
    needCancel = (BOOLEAN) (DbcContext->Flags & DBCLASS_FLAG_REQ_PENDING);
    
    KeReleaseSpinLock(&DbcContext->FlagsSpin, irql);
    DBCLASS_DecrementIoCount(DbcContext);

    if (needCancel) {
        LOGENTRY(LOG_MISC, 'kIRP', DbcContext, DbcContext->ChangeIrp, 0);
        IoCancelIrp(DbcContext->ChangeIrp);
    }

    {
        NTSTATUS status;

        // wait for any io request pending in our driver to
        // complete for finishing the remove

        LOGENTRY(LOG_MISC, 'STwt', DbcContext, 0, 0);
        status = KeWaitForSingleObject(
                    &DbcContext->RemoveEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);
        LOGENTRY(LOG_MISC, 'STwd', DbcContext, 0, 0);
    }
            
    
    LOGENTRY(LOG_MISC, 'STP<', DbcContext, 0, ntStatus);
    
    return ntStatus;

}


PDBC_CONTEXT
DBCLASS_GetDbcContext(
    IN PDEVICE_OBJECT ControllerFdo
    )
/*++

Routine Description:

    Stops the DBC
    
Arguments:


Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PDBC_CONTEXT dbcContext;
    KIRQL irql;
    
    // search our list if we find the TopOfStack device
    // object then this must be a filter driver, otherwise
    // allocate a new context structure for this controller

    KeAcquireSpinLock(&DBCLASS_ControllerListSpin, &irql);

    dbcContext = DBCLASS_ControllerList;

    while (dbcContext) {

        if (dbcContext->ControllerFdo == ControllerFdo) {
            break;
        }

        dbcContext = dbcContext->Next;
    
    } 

    KeReleaseSpinLock(&DBCLASS_ControllerListSpin, irql);

    return dbcContext;

}


NTSTATUS 
DBCLASS_SyncGetSubsystemDescriptor(
    IN PDBC_CONTEXT DbcContext
    )
 /* ++
  * 
  * Description:
  *
  * fetch the susbsystem descriptor from the port driver, and allocate 
  * a structure for the bay information
  * 
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDRB drb;
    
    PAGED_CODE();

    //
    // Allocate Drb from the non-paged pool
    //
    
    drb = DbcExAllocatePool(NonPagedPool, 
                            sizeof(struct _DRB_GET_SUBSYSTEM_DESCRIPTOR));

    if (drb) {

        drb->DrbHeader.Length = sizeof(struct _DRB_GET_SUBSYSTEM_DESCRIPTOR);
        drb->DrbHeader.Function = DRB_FUNCTION_GET_SUBSYSTEM_DESCRIPTOR;
        drb->DrbHeader.Flags = 0;

        // make the request
        ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                         DbcContext->TopOfStack, 
                                         drb);

        if (NT_SUCCESS(ntStatus)) {
            RtlCopyMemory(&DbcContext->SubsystemDescriptor,
                          &drb->DrbGetSubsystemDescriptor.SubsystemDescriptor,
                          sizeof(DbcContext->SubsystemDescriptor));
                          
            // dump susbsystem descriptor to debugger
            DBCLASS_KdPrint((1, "'DBC Susbsystem Descriptor:\n"));
            DBCLASS_KdPrint((1, "'>bLength = (%08X)\n", 
                DbcContext->SubsystemDescriptor.bLength));
            DBCLASS_KdPrint((1, "'>bDescriptorType = (%08X)\n", 
                DbcContext->SubsystemDescriptor.bDescriptorType));            
            DBCLASS_KdPrint((1, "'>SUBSYSTEM_DESCR = (%08X)\n", 
                DbcContext->SubsystemDescriptor.bmAttributes));            
            DBCLASS_KdPrint((1, "'>>SUBSYSTEM_DESCR.BayCount = (%08X)\n", 
                DbcContext->SubsystemDescriptor.bmAttributes.BayCount));            
            DBCLASS_KdPrint((1, "'>>SUBSYSTEM_DESCR.HasSecurityLock = (%08X)\n", 
                DbcContext->SubsystemDescriptor.bmAttributes.HasSecurityLock)); 
            DBCLASS_KdPrint((1, "'>>SUBSYSTEM_DESCR.LinkGuid\n"));
#if DBG
            DBCLASS_KdPrintGuid(1, 
                                &DbcContext->SubsystemDescriptor.guid1394Link[0]);
#endif                                
        }
        
        DbcExFreePool(drb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncGetBayDescriptor(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT BayNumber,
    IN PDBC_BAY_DESCRIPTOR BayDescriptor
    )
 /* ++
  * 
  * Description:
  *
  * fetch the bay descriptor from the port driver,
  * 
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDRB drb;

    PAGED_CODE();

    //
    // Allocate Drb from the non-paged pool
    //
    
    drb = DbcExAllocatePool(NonPagedPool, 
                           sizeof(struct _DRB_GET_BAY_DESCRIPTOR));

    if (drb) {

        drb->DrbHeader.Length = sizeof(struct _DRB_GET_BAY_DESCRIPTOR);
        drb->DrbHeader.Function = DRB_FUNCTION_GET_BAY_DESCRIPTOR;
        drb->DrbHeader.Flags = 0;
        drb->DrbGetBayDescriptor.BayNumber = BayNumber;
        
        // make the request
        ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                         DbcContext->TopOfStack, 
                                         drb);

        if (NT_SUCCESS(ntStatus)) {
            RtlCopyMemory(BayDescriptor,
                          &drb->DrbGetBayDescriptor.BayDescriptor,
                          sizeof(*BayDescriptor));
        }
        
        DbcExFreePool(drb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncGetControllerStatus(
    IN PDBC_CONTEXT DbcContext
    )
 /* ++
  * 
  * Description:
  *
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDRB drb;

    PAGED_CODE();

    //
    // Allocate Drb from the non-paged pool
    //
    
    drb = DbcExAllocatePool(NonPagedPool, 
                            sizeof(struct _DRB_GET_CONTROLLER_STATUS));

    if (drb) {

        drb->DrbHeader.Length = sizeof(struct _DRB_GET_CONTROLLER_STATUS);
        drb->DrbHeader.Function = DRB_FUNCTION_GET_CONTROLLER_STATUS;
        
        // make the request
        ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                         DbcContext->TopOfStack, 
                                         drb);

        DbcExFreePool(drb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncGetAllBayDescriptors(
    IN PDBC_CONTEXT DbcContext
    )
 /* ++
  * 
  * Description:
  *
  * fetch the susbsystem descriptor from the port driver, and allocate 
  * a structure for the bay information
  * 
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT bay;
    
    PAGED_CODE();

    for (bay=1; bay <= NUMBER_OF_BAYS(DbcContext); bay++) {
        ntStatus = DBCLASS_SyncGetBayDescriptor(DbcContext,
                                                bay,
                                                &DbcContext->BayInformation[bay].BayDescriptor);
    }                                                     

    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncBayFeatureRequest(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT Op,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    )
 /* ++
  * 
  * Description:
  *
  * fetch the susbsystem descriptor from the port driver, and allocate 
  * a structure for the bay information
  * 
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDRB drb;

    PAGED_CODE();

    //
    // Allocate Drb from the non-paged pool
    //

    DBCLASS_ASSERT(BayNumber != 0);
    DBCLASS_ASSERT(BayNumber <= MAX_BAY_NUMBER);
    
    drb = DbcExAllocatePool(NonPagedPool, 
                           sizeof(struct _DRB_BAY_FEATURE_REQUEST));

    if (drb) {

        drb->DrbHeader.Length = sizeof(struct _DRB_BAY_FEATURE_REQUEST);
        drb->DrbHeader.Function = Op;
        drb->DrbHeader.Flags = 0;
        drb->DrbBayFeatureRequest.BayNumber = BayNumber;
        drb->DrbBayFeatureRequest.FeatureSelector = FeatureSelector;
        // make the request
        ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                         DbcContext->TopOfStack, 
                                         drb);

        DbcExFreePool(drb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncGetBayStatus(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT BayNumber,
    IN PBAY_STATUS BayStatus
    )
 /* ++
  * 
  * Description:
  *
  * fetch the susbsystem descriptor from the port driver, and allocate 
  * a structure for the bay information
  * 
  * Arguments:
  * 
  * Return:
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDRB drb;

    PAGED_CODE();

    //
    // Allocate Drb from the non-paged pool
    //

    DBCLASS_ASSERT(BayNumber != 0);
    DBCLASS_ASSERT(BayNumber <= MAX_BAY_NUMBER);
    
    drb = DbcExAllocatePool(NonPagedPool, 
                           sizeof(struct _DRB_GET_BAY_STATUS));

    if (drb) {

        drb->DrbHeader.Length = sizeof(struct _DRB_GET_BAY_STATUS);
        drb->DrbHeader.Function = DRB_FUNCTION_GET_BAY_STATUS;
        drb->DrbHeader.Flags = 0;
        drb->DrbGetBayStatus.BayNumber = BayNumber;
        
        // make the request
        ntStatus = DBCLASS_SyncSubmitDrb(DbcContext,
                                         DbcContext->TopOfStack, 
                                         drb);

        if (NT_SUCCESS(ntStatus)) {
            BayStatus->us = drb->DrbGetBayStatus.BayStatus.us;    
            // dump status to debugger
            DBCLASS_KdPrint((2, "'status for bay (%d) 0x%0x:\n", BayNumber,
                drb->DrbGetBayStatus.BayStatus.us));
            DBCLASS_KdPrint((2, "'>VidEnabled = (%08X)\n", 
                 BayStatus->VidEnabled));
            DBCLASS_KdPrint((2, "'>RemovalWakeupEnabled = (%08X)\n", 
                BayStatus->RemovalWakeupEnabled));                
            DBCLASS_KdPrint((2, "'>DeviceStatusChangeEnabled = (%08X)\n", 
                BayStatus->DeviceStatusChangeEnabled));                
            DBCLASS_KdPrint((2, "'>RemovalRequestEnabled = (%08X)\n", 
                BayStatus->RemovalRequestEnabled));                
            DBCLASS_KdPrint((2, "'>LastBayStateRequested = (%08X)\n", 
                BayStatus->LastBayStateRequested));                
            DBCLASS_KdPrint((2, "'>InterlockEngaged = (%08X)\n", 
                BayStatus->InterlockEngaged));                
            DBCLASS_KdPrint((2, "'>DeviceUsbIsPresent = (%08X)\n", 
                BayStatus->DeviceUsbIsPresent)); 
            DBCLASS_KdPrint((2, "'>Device1394IsPresent = (%08X)\n", 
                 BayStatus->Device1394IsPresent));                
            DBCLASS_KdPrint((2, "'>DeviceStatusChange = (%08X)\n", 
                 BayStatus->DeviceStatusChange));                 
            DBCLASS_KdPrint((2, "'>RemovalRequestChange = (%08X)\n", 
                 BayStatus->RemovalRequestChange));     
            DBCLASS_KdPrint((2, "'>CurrentBayState = (%08X)\n", 
                 BayStatus->CurrentBayState));     
            DBCLASS_KdPrint((2, "'>SecurityLockEngaged = (%08X)\n", 
                 BayStatus->SecurityLockEngaged));     
        }
        
        DbcExFreePool(drb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return ntStatus;
}


NTSTATUS
DBCLASS_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PDBC_CONTEXT dbcContext = Context;
    KIRQL irql;
    BOOLEAN stopping;
    PDBCLASS_WORKITEM workItem;
    
    // status change
    //
    // we should not get here unless something really has
    // changed
    
    KeAcquireSpinLock(&dbcContext->FlagsSpin, &irql);     
    dbcContext->Flags &= ~DBCLASS_FLAG_REQ_PENDING;
    stopping = (BOOLEAN) (dbcContext->Flags & DBCLASS_FLAG_STOPPING);
    KeReleaseSpinLock(&dbcContext->FlagsSpin, irql);

    LOGENTRY(LOG_MISC, 'CHid', dbcContext, 0, Irp->IoStatus.Status);
    BRK_ON_TRAP();

    if (!stopping) {

        //
        // we have a legitimate change
        //

        // schedule a workitem to process the change
        LOGENTRY(LOG_MISC, 'QCH>', dbcContext, 0, 0);

        workItem = DbcExAllocatePool(NonPagedPool, sizeof(DBCLASS_WORKITEM));

        if (workItem) {
            DBCLASS_KdPrint((1, "'Schedule Workitem for Change Request\n"));

            LOGENTRY(LOG_MISC, 'qITM', dbcContext,
                workItem, 0);

            workItem->Sig = DBC_WORKITEM_SIG;
            workItem->DbcContext = dbcContext;
            workItem->IrpStatus = Irp->IoStatus.Status;
            
            ExInitializeWorkItem(&workItem->WorkQueueItem,
                                 DBCLASS_ChangeIndicationWorker,
                                 workItem);

            ExQueueWorkItem(&workItem->WorkQueueItem,
                            DelayedWorkQueue);

        } else {
            
            DBCLASS_DecrementIoCount(dbcContext);
            DBCLASS_KdPrint((0, "'No Memory for workitem!\n"));
            TRAP();
            
        }            
        
    } else {
        DBCLASS_DecrementIoCount(dbcContext);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
DBCLASS_ProcessCurrentBayState(
    IN PDBC_CONTEXT DbcContext,
    IN BAY_STATUS BayStatus,
    IN USHORT Bay,
    IN PBOOLEAN PostChangeRequest
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG last,current;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    current = BayStatus.CurrentBayState;
    last = DbcContext->BayInformation[Bay].LastBayStatus.CurrentBayState;
    
    DBCLASS_KdPrint((0, "'>PBS - current bay state: %x\n", current));
    DBCLASS_KdPrint((0, "'>last bay state: %x\n", last));
    
    // figure out what current state of the bay is and deal with it
    
    if (current == last) {
        DBCLASS_KdPrint((0, "'>>no changes detected %x\n", current));     
    } else {
        switch (current) {
        
        case BAY_STATE_DEVICE_INSERTED:

            LOGENTRY(LOG_MISC, 'byIN', DbcContext, ntStatus, Bay);
            
            // engage the interlock, lock that baby in to the bay
            ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                                     DRB_FUNCTION_SET_BAY_FEATURE,
                                                     Bay,
                                                     LOCK_CTL);
            DBCLASS_Wait(1000);                                                         


            // enable Vid so the device will appear on the native bus
            ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                                     DRB_FUNCTION_SET_BAY_FEATURE,
                                                     Bay,
                                                     ENABLE_VID_POWER);

            DBCLASS_Wait(1000);

            //
            // The device will now appear on the native bus 
            // allowing the OS to load appropriate drivers
            //
            DBCLASS_KdPrint((0, "'>>Bay Vid Power Enabled\n"));

//            *PostChangeRequest = FALSE;

/* remove when filter is ready */
   ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                             DRB_FUNCTION_SET_BAY_FEATURE,
                                             Bay,
                                             REQUEST_DEVICE_ENABLED_STATE);    


    DBCLASS_SyncGetBayStatus(DbcContext, Bay, &BayStatus);                
    
    DbcContext->BayInformation[Bay].LastBayStatus = BayStatus;       
/**/    
                         
            break;
            
        case BAY_STATE_DEVICE_REMOVAL_REQUESTED:                        
            {

            PIO_STACK_LOCATION nextStack;
            PDRB drb;
            CHAR stackSize;
            PIRP irp;
            PEJECT_CONTEXT ejectContext;
            PUCHAR pch;
            
            DBCLASS_KdPrint((0, "'>>Request Device Eject BAY[%d]\n", Bay));

            // need to OK the eject                    
            
            pch = DbcExAllocatePool(NonPagedPool, 
                    sizeof(struct _DRB_START_DEVICE_IN_BAY) + sizeof(EJECT_CONTEXT));

            ejectContext = (PEJECT_CONTEXT) pch;
            drb = (PDRB) (pch + sizeof(EJECT_CONTEXT));

            if (pch) { 

                ejectContext->Bay = Bay;
                ejectContext->DbcContext = DbcContext;
            
                drb->DrbHeader.Length = sizeof(struct _DRB_EJECT_DEVICE_IN_BAY);
                drb->DrbHeader.Function = DRB_FUNCTION_EJECT_DEVICE_IN_BAY;
                drb->DrbHeader.Flags = 0;

                drb->DrbEjectDeviceInBay.BayNumber = Bay;

//                deviceExtensionPdoFilter = 
//                    DbcContext->BayInformation[Bay].DeviceFilterObject->DeviceExtension;
                                   
                // make the request asynchronously
                //
                // normally this request is just completed by the port 
                // driver but we make the request so that the oem filter 
                // may intervene in the removal process

                stackSize = DbcContext->TopOfStack->StackSize;
                irp = IoAllocateIrp(stackSize, FALSE);

                if (NULL == irp) {
                
                    DBCLASS_KdPrint((0, "'could not allocate an irp!\n"));
                    if (PostChangeRequest) {
                        *PostChangeRequest = TRUE;                
                    } 
                    TRAP();
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    
                } else {
    
                    //
                    // Call the port driver to perform the operation.  If the returned
                    //
                    nextStack = IoGetNextIrpStackLocation(irp);
                    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_DBC_SUBMIT_DRB;
                    nextStack->Parameters.Others.Argument1 = drb;
                    
                    //
                    // pass the DRB 
                    //
                    IoSetCompletionRoutine(irp,
                                   DBCLASS_EjectBayComplete,
                                   ejectContext,
                                   TRUE,
                                   TRUE,
                                   TRUE);

                    ntStatus = IoCallDriver(DbcContext->TopOfStack, irp);
                                                
                    if (PostChangeRequest) {
                        *PostChangeRequest = FALSE;                
                    }                               
                }    
            } else {
            
                // no memory for drb, re-post the change request and
                // try again
                
                DBCLASS_KdPrint((0, "'could not allocate an drb!\n"));
                if (PostChangeRequest) {
                    *PostChangeRequest = TRUE;                
                }                   
                TRAP();
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            
            }
            break;

        case BAY_STATE_EMPTY:                      
        
            //
            // we should have no PDO if the bay is empty
            //
            
//            DBCLASS_ASSERT(
//                DbcContext->BayInformation[Bay].DeviceFilterObject == NULL);

            DBCLASS_KdPrint((0, "'>>Found Bay empty\n"));
            break;            

        case BAY_STATE_DEVICE_ENABLED:                      
            //
            // we may get here because the bay was enabled at boot
            // in this case we have nothing to do
            //
            
            DBCLASS_KdPrint((0, "'>>Found Bay enabled\n"));
            
            break;
            
        default:
            DBCLASS_KdPrint((0, "'>>Bay State not handled\n"));
            TRAP();
            break;

        } /* switch */
    }

    return ntStatus;
}   


VOID
DBCLASS_ChangeIndicationWorker(
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDBCLASS_WORKITEM workItem = Context;
    PDBC_CONTEXT dbcContext = workItem->DbcContext;
    BAY_STATUS bayStatus;
    USHORT bay;
    NTSTATUS ntStatus, irpStatus;
    BOOLEAN found = FALSE;
    BOOLEAN postChangeRequest = TRUE;

    LOGENTRY(LOG_MISC, 'cWK+', 0, Context, 0);

    irpStatus = workItem->IrpStatus; 

    DbcExFreePool(workItem);

    if (!NT_SUCCESS(irpStatus)) {
        // we got an error
        // get the controller status
        NTSTATUS status;
        
        status = DBCLASS_SyncGetControllerStatus(dbcContext);
        
        LOGENTRY(LOG_MISC, 'cERR', dbcContext, status, irpStatus);

        if (status == STATUS_DEVICE_NOT_CONNECTED) {
            // controller was removed, don't
            // re-post the request
            postChangeRequest = FALSE;
        } 
        
        // problem may be temporary
        goto DBCLASS_ChangeIndicationWorker_Done;        
    }

    // find out which bay changed
    // find out what changed
    // clear the change, note that we only 
    // clear the change that we process

    for (bay = 0; bay <= MAX_BAY_NUMBER; bay++) {
        if (IsBitSet(&dbcContext->ChangeDrb.BayChange, bay)) {
            found = TRUE;
            break;
        }
    }
    
    // no change?
    if (!found) {
        DBCLASS_KdPrint((0, "'no bay indicated! -- bug in port driver\n", bay));
        bay = 0;
        TRAP();
    }        
    
    DBCLASS_KdPrint((0, "'Process status change, bay = (%d)\n", bay));

    if (bay > 0) {
        
        ntStatus = DBCLASS_SyncGetBayStatus(dbcContext, bay, &bayStatus);

        if (NT_SUCCESS(ntStatus)) {

            // acknowlege any status change bits now
            //
            // NOTE that the status change bits are redundent 
            // we process the change base on the current state 
            // of the bay compared to the last known state 
            // 

            if (bayStatus.DeviceStatusChange) {

                DBCLASS_KdPrint((0, "'>>device status change bit set\n"));

                DBCLASS_SyncBayFeatureRequest(dbcContext,
                                              DRB_FUNCTION_CLEAR_BAY_FEATURE,
                                              bay,
                                              C_DEVICE_STATUS_CHANGE);
                                              
                DBCLASS_KdPrint((0, "'>>>cleared\n"));                                              
                
            } 

            if (bayStatus.RemovalRequestChange) {

                DBCLASS_KdPrint((0, "'>>remove request change bit set\n"));

                DBCLASS_SyncBayFeatureRequest(dbcContext,
                                              DRB_FUNCTION_CLEAR_BAY_FEATURE,
                                              bay,
                                              C_REMOVE_REQUEST);
                DBCLASS_KdPrint((0, "'>>>cleared\n"));                                                 
            }                

            ntStatus = DBCLASS_ProcessCurrentBayState(dbcContext,
                                                      bayStatus,
                                                      bay,
                                                      &postChangeRequest);
                                                      
        }                        
    } else {
        DBCLASS_KdPrint((0, "'Global status change on DB subsystem\n"));
        TEST_TRAP();
    }

DBCLASS_ChangeIndicationWorker_Done:

    LOGENTRY(LOG_MISC, 'chDN', dbcContext, ntStatus, bay);

    // finished with this request, dec the count
    DBCLASS_DecrementIoCount(dbcContext);           
    
    if (postChangeRequest) {

        LOGENTRY(LOG_MISC, 'chPS', dbcContext, ntStatus, bay);
        DBCLASS_PostChangeRequest(dbcContext);
    }                

    return;
}


VOID
DBCLASS_PostChangeRequest(
    IN PDBC_CONTEXT DbcContext
    )
 /* ++
  * 
  * Description:
  *
  * fetch the bay descriptor from the port driver,
  * 
  * Arguments:
  * 
  * Return:
  *     This routine never fails
  * 
  * -- */
{
    PDRB drb;
    PIRP irp;
    KIRQL irql;
    CHAR stackSize;
    PIO_STACK_LOCATION nextStack;        

    PAGED_CODE();
    
    // Drb and irp are pre-allocated
    
    drb = (PDRB) &DbcContext->ChangeDrb;
    irp = DbcContext->ChangeIrp;
    
    stackSize = DbcContext->TopOfStack->StackSize;

    drb->DrbHeader.Length = sizeof(struct _DRB_CHANGE_REQUEST);
    drb->DrbHeader.Function = DRB_FUNCTION_CHANGE_REQUEST ;
    drb->DrbHeader.Flags = 0;
    drb->DrbChangeRequest.BayChange = 0;

    
    IoInitializeIrp(irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = drb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_DBC_SUBMIT_DRB;

    IoSetCompletionRoutine(irp,    // Irp
                           DBCLASS_ChangeIndication,
                           DbcContext, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    //
    // Call the port driver 
    //

    KeAcquireSpinLock(&DbcContext->FlagsSpin, &irql);            
    if (DbcContext->Flags & DBCLASS_FLAG_STOPPING) {
        LOGENTRY(LOG_MISC, 'stpX', DbcContext, 0, 0);
        KeReleaseSpinLock(&DbcContext->FlagsSpin, irql);   
    } else {

        DbcContext->Flags |= DBCLASS_FLAG_REQ_PENDING;
        KeReleaseSpinLock(&DbcContext->FlagsSpin, irql);
        DBCLASS_IncrementIoCount(DbcContext);

        DBCLASS_BEGIN_SERIALIZED_DRB(DbcContext);

        DBCLASS_KdPrint((1, "'Post Change Request\n"));                             

        LOGENTRY(LOG_MISC, 'post', DbcContext, 0, irp);
        // let the completion routine handle any errors
        IoCallDriver(DbcContext->TopOfStack, irp);    

        DBCLASS_END_SERIALIZED_DRB(DbcContext);
    }
    
    return;
}

#if 0
USHORT
DBCLASS_GetBayNumber(
    IN PDEVICE_OBJECT DeviceFilterObject
    )
 /* ++
  * 
  * Description:
  *
  * given a device filter object, find the bay with this device
  * 
  * Arguments:
  * 
  * Return:
  *     This routine never fails
  * 
  * -- */
{
    PDBC_CONTEXT dbcContext;
    USHORT bay;        
    PDEVICE_EXTENSION deviceExtension;

    DBCLASS_ASSERT(DeviceFilterObject);

    deviceExtension = 
        DeviceFilterObject->DeviceExtension;

    if(deviceExtension)
    {
        dbcContext = deviceExtension->DbcContext;  

        LOGENTRY(LOG_MISC, 'GBNn', dbcContext, DeviceFilterObject, 0);


        if(dbcContext)
        {
            for (bay=1; bay <=NUMBER_OF_BAYS(dbcContext); bay++) 
            {

                if (dbcContext->BayInformation[bay].DeviceFilterObject == DeviceFilterObject) {
                    LOGENTRY(LOG_MISC, 'GBNr', dbcContext, DeviceFilterObject, bay);
                    return bay;
                }
            }
        }
    }

    return 0;
}    
#endif

#if 0
NTSTATUS
DBCLASS_EnableDevice(
    IN PDEVICE_OBJECT DeviceFilterObject
    )
 /* ++
  * 
  * Description:
  *
  * given a device filter object, eject the device in the bay
  * 
  * Arguments:
  * 
  * Return:
  *     This routine never fails
  * 
  * -- */
{
    PDBC_CONTEXT dbcContext;
    PDEVICE_EXTENSION deviceExtension;
    USHORT bay;        
    BAY_STATUS bayStatus;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBCLASS_ASSERT(DeviceFilterObject);
    
    deviceExtension = 
        DeviceFilterObject->DeviceExtension;
    dbcContext = deviceExtension->DbcContext;          
    bay = DBCLASS_GetBayNumber(DeviceFilterObject);
    
    DBCLASS_KdPrint((0, "'>>Bay to Enabled state\n"));

    ntStatus = DBCLASS_SyncBayFeatureRequest(dbcContext,
                                             DRB_FUNCTION_SET_BAY_FEATURE,
                                             bay,
                                             REQUEST_DEVICE_ENABLED_STATE);    


    DBCLASS_SyncGetBayStatus(dbcContext, bay, &bayStatus);                
    
    dbcContext->BayInformation[bay].LastBayStatus = bayStatus;       

    DBCLASS_DecrementIoCount(dbcContext);
    
    DBCLASS_PostChangeRequest(dbcContext);        
             
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
DBCLASS_EjectPdo(
    IN PDEVICE_OBJECT DeviceFilterObject
    )
 /* ++
  * 
  * Description:
  *
  * given a device filter object, eject the device in the bay by Pdo
  * 
  * Arguments:
  * 
  * Return:
  *     This routine never fails
  * 
  * -- */
{
    PDBC_CONTEXT dbcContext;
    PDEVICE_EXTENSION deviceExtension = 
        DeviceFilterObject->DeviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    dbcContext = deviceExtension->DbcContext;          

    ntStatus = DBCLASS_EjectBay(dbcContext, 
                                deviceExtension->Bay);

    DBCLASS_DecrementIoCount(dbcContext);
    
    DBCLASS_PostChangeRequest(dbcContext);             
    
    return ntStatus;
}


NTSTATUS
DBCLASS_EjectBay(
    IN PDBC_CONTEXT DbcContext,
    IN USHORT Bay
    )
 /* ++
  * 
  * Description:
  *
  * given a bay, eject the device in it
  * 
  * Arguments:
  * 
  * Return:
  *     This routine never fails
  * 
  * -- */
{
    BAY_STATUS bayStatus;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBCLASS_KdPrint((0, "'>EJECT Bay[%d]\n", Bay));
    
    // disengage the interlock
    DBCLASS_KdPrint((0, "'>>disable VID\n"));

    ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                             DRB_FUNCTION_CLEAR_BAY_FEATURE,
                                             Bay,
                                             ENABLE_VID_POWER);

    DBCLASS_KdPrint((0, "'>>disengage interlock\n"));
    
    ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                             DRB_FUNCTION_CLEAR_BAY_FEATURE,
                                             Bay,
                                             LOCK_CTL);
    
    DBCLASS_KdPrint((0, "'>>Bay to Removal allowed state\n"));

    ntStatus = DBCLASS_SyncBayFeatureRequest(DbcContext,
                                             DRB_FUNCTION_SET_BAY_FEATURE,
                                             Bay,
                                             REQUEST_REMOVAL_ALLOWED_STATE);    


    
    DBCLASS_SyncGetBayStatus(DbcContext, Bay, &bayStatus);                
    
    DbcContext->BayInformation[Bay].LastBayStatus = bayStatus;                            

    return ntStatus;
}


NTSTATUS
DBCLASS_AddDevicePDOToList(
    IN PDEVICE_OBJECT FilterDeviceObject,
    IN PDEVICE_OBJECT PdoDeviceObject
    )

/*++

Routine Description:

    Adds a bus emumerated PDO to our list of PDOs

    Currently we only track 1394 PDOs

Arguments:

    FilterDeviceObject - filter MDO for the 1394 bus this device is on
    PdoDeviceObject - 1394 Enumerated PDO

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if a buffer could not be allocated
    STATUS_SUCCESS otherwise

--*/

{
    PDBCLASS_PDO_LIST newEntry;

    newEntry = ExAllocatePool(NonPagedPool, sizeof(DBCLASS_PDO_LIST));

    if (newEntry == NULL) {
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Fill in fields in new entry

     newEntry->FilterDeviceObject = FilterDeviceObject;
     newEntry->PdoDeviceObject = PdoDeviceObject;

    // Add new entry to end of list
    InsertTailList(&DBCLASS_DevicePdoList, &newEntry->ListEntry);

    return STATUS_SUCCESS;
}


VOID
DBCLASS_RemoveDevicePDOFromList(
    IN PDEVICE_OBJECT PdoDeviceObject
    )

/*++

Routine Description:

    Removes a 1394 emumerated PDO to our list of 1394 PDOs

Arguments:

    PdoDeviceObject - 1394 Enumerated PDO to remove from list

Return Value:

    VOID

--*/

{
    PDBCLASS_PDO_LIST entry;
    PLIST_ENTRY listEntry;

    listEntry = &DBCLASS_DevicePdoList;
    if (!IsListEmpty(listEntry)) {
       listEntry = DBCLASS_DevicePdoList.Flink;
    }
     
    while (listEntry != &DBCLASS_DevicePdoList) {
    
        entry = CONTAINING_RECORD(listEntry, 
                                  DBCLASS_PDO_LIST, 
                                  ListEntry);
                                  
        DBCLASS_ASSERT(entry);
        if (entry->PdoDeviceObject == PdoDeviceObject) {
            break;
        }

        listEntry = entry->ListEntry.Flink;

    }            

    // we should always find it
    DBCLASS_ASSERT(listEntry != &DBCLASS_DevicePdoList);

    RemoveEntryList(listEntry);
    ExFreePool(entry);
    
}


PDEVICE_OBJECT
DBCLASS_FindDevicePdo(
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    find a device PDO -- return tru if we know about it 
    
Arguments:

     

Return Value:

    NTSTATUS
    
--*/
{
    PDBCLASS_PDO_LIST entry;
    PLIST_ENTRY listEntry;
    // we keep a global list of PDOs we know about

    listEntry = &DBCLASS_DevicePdoList;
    
    if (!IsListEmpty(listEntry)) {
       listEntry = DBCLASS_DevicePdoList.Flink;
    }
        
    while (listEntry != &DBCLASS_DevicePdoList) {
    
        entry = CONTAINING_RECORD(listEntry, 
                                  DBCLASS_PDO_LIST, 
                                  ListEntry);
                                  
        DBCLASS_ASSERT(entry);
        if (entry->PdoDeviceObject == PdoDeviceObject) {
            return entry->FilterDeviceObject;    
        }

        listEntry = entry->ListEntry.Flink;

    }            

    return NULL;
}


PDBC_CONTEXT
DBCLASS_FindControllerACPI(
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo
    )
/*++

Routine Description:

    find the DBC controller in our list for a given Filter MDO
    if found the filter MDO is linked to the controller 

    This routine searches the list for an ACPI DBC
    currently we support only one.
    
Arguments:

Return Value:

    Controller Context
    
--*/
{
    PDBC_CONTEXT dbcContext = NULL;    
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = FilterMdo->DeviceExtension;            
    dbcContext = DBCLASS_ControllerList;

    //
    // NOTE: We support only one ACPI DBC controller
    //
    
    while (dbcContext) {
        if (dbcContext->ControllerSig == DBC_ACPI_CONTROLLER_SIG) {
            if (deviceExtension->FdoType == DB_FDO_USBHUB_BUS) {
                dbcContext->BusFilterMdoUSB = FilterMdo;
            } else if (deviceExtension->FdoType == DB_FDO_1394_BUS) {
                dbcContext->BusFilterMdo1394 = FilterMdo;
            } else {
                TRAP();
            }
            dbcContext->BusFilterDriverObject = FilterDriverObject;
            
            break;
        }
        dbcContext = dbcContext->Next;
    }
    
    LOGENTRY(LOG_MISC, 'FIN1', dbcContext, 0, 0);
    
#if DBG
    if (dbcContext == NULL) {
        DBCLASS_KdPrint((0, "'ACPI Controller not Found\n"));
    }
#endif

    return dbcContext;
}


PDBC_CONTEXT
DBCLASS_FindControllerUSB(
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo,
    PDEVICE_OBJECT UsbHubPdo
    )
/*++

Routine Description:

    find the DBC controller in our list for a given Filter MDO
    if found the filter MDO is linked to the controller 

    This routine will query the hub to see if an DBC controller
    is attached.
    
Arguments:

Return Value:

    Controller Context
    
--*/
{
    UCHAR dbcGuid[8];
    NTSTATUS ntStatus;
    PDBC_CONTEXT dbcContext = NULL;   
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = FilterMdo->DeviceExtension;      

    // first get the guid for this hub
    ntStatus = DBCLASS_GetHubDBCGuid(FilterMdo, 
                                     dbcGuid);

    dbcContext = DBCLASS_ControllerList;

    while (dbcContext) {
        if (RtlCompareMemory(&dbcContext->SubsystemDescriptor.guid1394Link[0],
                             &dbcGuid[0], 8) == 8) {
            if (deviceExtension->FdoType == DB_FDO_USBHUB_BUS) {
                dbcContext->BusFilterMdoUSB = FilterMdo;
            } else if (deviceExtension->FdoType == DB_FDO_1394_BUS) {
                dbcContext->BusFilterMdo1394 = FilterMdo;
            } else {
                TRAP();
            }
            dbcContext->BusFilterDriverObject = FilterDriverObject;
            break;
        }
        dbcContext = dbcContext->Next;
    }

    return dbcContext;
}


NTSTATUS
DBCLASS_Find1394DbcLinks(
    PDEVICE_OBJECT DevicePdo1394
    )
/*++

Routine Description:

    find the DBC controller in our list for a given Filter MDO
    if found the filter MDO is linked to the controller 

    Given the 1394 device PDO and the bus guid we try to find the
    appropriate controller
    
Arguments:

Return Value:

    Controller Context
    
--*/
{
    PDBC_CONTEXT dbcContext;

    DBCLASS_KdPrint((1, "'Find DBC Links\n")); 
    dbcContext = DBCLASS_ControllerList;
    
    while (dbcContext) {
    
        if (DBCLASS_IsLinkDeviceObject(dbcContext,
                                       DevicePdo1394)) {
                                                   
            DBCLASS_KdPrint((1, "'1394 PDO is DBC Link\n"));                             
            // set the bus guid for the context
            DBCLASS_1394GetBusGuid(DevicePdo1394,
                                   &dbcContext->Guid1394Bus[0]); 
        }                             

        dbcContext = dbcContext->Next;
    }

    return STATUS_SUCCESS; 
}




PDBC_CONTEXT
DBCLASS_FindController1394DevicePdo(
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo,
    PDEVICE_OBJECT DevicePdo1394,
    PUCHAR BusGuid
    )
/*++

Routine Description:

    find the DBC controller in our list for a given Filter MDO
    if found the filter MDO is linked to the controller 

    Given the 1394 device PDO and the bus guid we try to find the
    appropriate DB controller

    busguid is the 1394 controller guid for the bus this device is on

Arguments:

Return Value:

    Controller Context
    
--*/
{
    PDBC_CONTEXT dbcContext = NULL;   
    PDBC_CONTEXT foundDbcContext = NULL;     
    // if a DBC reports the magic guid then we match on that
    
    UCHAR magicGuid[8] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07};
    
    DBCLASS_KdPrint((1, "'>Find Controller -> 1394 DEV PDO (%x)\n", DevicePdo1394));
    DBCLASS_KdPrint((1, "'>>1394 CONTROLLER (BUS) GUID\n"));
    DBCLASS_KdPrintGuid(1, 
                        BusGuid);
   
    BRK_ON_TRAP();

    //
    // first loop through controllers
    // checking to see if this is a PDO
    // for a link, if so we mark the context as NULL
    // ie not a DB device
    //
    
    dbcContext = DBCLASS_ControllerList;
    
    while (dbcContext) {
    
        if (DBCLASS_IsLinkDeviceObject(dbcContext,
                                       DevicePdo1394)) {
                                       
            DBCLASS_KdPrint((1, "'>>>1394 PDO is DBC Link\n"));                             
            return NULL;                                       
        }                             

        dbcContext = dbcContext->Next;
    }

    //
    // loop through the controllers, checking each one
    // until we have a match
    
    dbcContext = DBCLASS_ControllerList;

    while (dbcContext && foundDbcContext == NULL) {
        NTSTATUS status;
        
        DBCLASS_KdPrint((2, "'Checking DBC (%x)\n", dbcContext));
        DBCLASS_KdPrint((2, "'BUS GUID (%x)\n", dbcContext));
        DBCLASS_KdPrintGuid(2, 
                            &dbcContext->Guid1394Bus[0]);    
                            
        // only look at controllers on the same bus                            
        if (
            (RtlCompareMemory(&dbcContext->Guid1394Bus[0],
                             BusGuid, 8) == 8) ||
            (RtlCompareMemory(&dbcContext->Guid1394Bus[0],
                             &magicGuid[0], 8) == 8)                 
                             ) {

            // OK we found a match, now see if this PDO is part of 
            // this controller
            status = DBCLASS_Check1394DevicePDO(FilterMdo,
                                                dbcContext,
                                                DevicePdo1394);
                                                
            if (NT_SUCCESS(status)) {
                foundDbcContext = dbcContext;
                dbcContext->BusFilterMdo1394 = FilterMdo;
                dbcContext->BusFilterDriverObject = FilterDriverObject;
            }
                    
        }
        dbcContext = dbcContext->Next;
    }    

#if DBG
    if (foundDbcContext) {
        DBCLASS_KdPrint((1, "'>>>>Found DBC (%x)\n", foundDbcContext));   
    } else {
        DBCLASS_KdPrint((1, "'>>>>DBC not found\n"));   
    }
#endif

    return foundDbcContext;
}


NTSTATUS
DBCLASS_PdoSetLockComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    Irp->IoStatus.Status = STATUS_SUCCESS;

    LOGENTRY(LOG_MISC, 'LOKc', 0, 0, 0);
    
    return STATUS_SUCCESS;
}


#define IS_1394_DEVICE(de) ((de)->FdoType == DB_FDO_1394_DEVICE)

NTSTATUS
DBCLASS_PdoFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    )
/*++

Routine Description:

    Common filter function for both 1394 and USB PDOs

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtensionPdoFilter;

    deviceExtensionPdoFilter = DeviceObject->DeviceExtension;
    ntStatus = Irp->IoStatus.Status;
    *Handled = FALSE;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    LOGENTRY(LOG_MISC, 'pdo>', 0, DeviceObject, Irp);
    
    DBCLASS_KdPrint((1, "'(dbfilter)(device)(%x)IRP_MJ_ (%08X)  IRP_MN_ (%08X)\n",
         DeviceObject, irpStack->MajorFunction, irpStack->MinorFunction));  

    switch (irpStack->MajorFunction) 
    {

    case IRP_MJ_PNP:
        switch (irpStack->MinorFunction) 
        {    
        case IRP_MN_START_DEVICE:            
            {
            PDBC_CONTEXT dbcContext;
            USHORT bay = 0;
            KEVENT event;
            
            DBCLASS_KdPrint((1, "'(dbfilter)(device)(%x)IRP_MN_START_DEVICE\n",
                deviceExtensionPdoFilter->PhysicalDeviceObject));    

            *Handled = TRUE;

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);  
            IoSetCompletionRoutine(Irp,
                                   DBCLASS_DeferIrpCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);


            //
            // send the request down the stack before we eject
            //

            ntStatus = IoCallDriver(deviceExtensionPdoFilter->TopOfStackDeviceObject, 
                                    Irp);
            
            if (ntStatus == STATUS_PENDING) 
            {
                 // wait for irp to complete
        
                KeWaitForSingleObject(
                    &event,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);
            }

            // started a 1394 device, figure out what bay it is in

            if (IS_1394_DEVICE(deviceExtensionPdoFilter)) 
            {
            
                DBCLASS_KdPrint((1, "'**> Starting 1394 PDO (%x)\n", 
                    deviceExtensionPdoFilter->PhysicalDeviceObject)); 
                    
                bay = deviceExtensionPdoFilter->Bay; 
                dbcContext = deviceExtensionPdoFilter->DbcContext;
                
            } 

            // we have no USB device bay devices
#if 0
            else 
            {

                dbcContext = deviceExtensionPdoFilter->DbcContext;

                DBCLASS_KdPrint((0, "'**> Starting USB PDO (%08X)  Filter DevObj (%08X)  DbcContext (%08X)\n",
                    deviceExtensionPdoFilter->PhysicalDeviceObject, DeviceObject, dbcContext));


                if (dbcContext != NULL) 
                {            
                    bay = DBCLASS_GetBayForUSBPdo(
                                dbcContext,
                                deviceExtensionPdoFilter->PhysicalDeviceObject);        

                    if (bay == 0) 
                    {
                        // ignore this PDO from now on
                        deviceExtensionPdoFilter->FdoType = DB_FDO_BUS_IGNORE;
                        DBCLASS_KdPrint((1, 
                                "'>>>> USB PDO(%x) is not a DB device  <<<<\n",
                                    deviceExtensionPdoFilter->PhysicalDeviceObject));
                    } 
                    else 
                    {
                        DBCLASS_KdPrint((1, 
                        "'>>>> USB PDO(%x) is in BAY[%d] <<<<\n",
                            deviceExtensionPdoFilter->PhysicalDeviceObject,
                            bay));   
                    }
                                                
                } 
                else 
                {
                    // no controller yet -- can't be a device bay device
                    bay = 0;
                    DBCLASS_KdPrint((1, "'No Controller Available\n")); 
                }
                
                //TEST_TRAP();
            }
#endif

            // keep track of the bay we are in in case
            // we get an eject irp
            deviceExtensionPdoFilter->Bay = bay;

            if (bay) 
            {

                DBCLASS_KdPrint((1, 
                    "'**>> PDO is in Bay %d\n", bay));  

                DBCLASS_ASSERT(dbcContext != NULL);
                if(dbcContext)
                {
                dbcContext->BayInformation[bay].DeviceFilterObject = 
                        DeviceObject;    
                if (DeviceObject) {
                     // need to OK the start                    
                    PDRB drb;
                    
                    drb = DbcExAllocatePool(NonPagedPool, 
                            sizeof(struct _DRB_START_DEVICE_IN_BAY));

                    if (drb) { 
                    
                        drb->DrbHeader.Length = sizeof(struct _DRB_START_DEVICE_IN_BAY);
                        drb->DrbHeader.Function = DRB_FUNCTION_START_DEVICE_IN_BAY;
                        drb->DrbHeader.Flags = 0;

                        drb->DrbStartDeviceInBay.BayNumber = bay;

                        drb->DrbStartDeviceInBay.PdoDeviceObject1394 =
                            drb->DrbStartDeviceInBay.PdoDeviceObjectUsb = NULL;
                            
                        if (IS_1394_DEVICE(deviceExtensionPdoFilter)) {        
                            drb->DrbStartDeviceInBay.PdoDeviceObject1394 =                         
                                DeviceObject;
                        } else {
                            drb->DrbStartDeviceInBay.PdoDeviceObjectUsb = 
                                DeviceObject;
                        }
                            
                        // make the request
                        ntStatus = DBCLASS_SyncSubmitDrb(dbcContext,
                                                         dbcContext->TopOfStack, 
                                                         drb);
                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                }

                // report that this PDO must be removed it the 
                // db controller is removed.

                // note: we invalidate on the DBC PDO 
                // this should trigger a QBR for the device bay controller

                                       
            } else {
                DBCLASS_KdPrint((1, 
                    "'**>> PDO is not for a device bay device\n"));    

                // detach and delete our MDO here if possible
                // otherwise mark as ignore

                BRK_ON_TRAP();
            }

            Irp->IoStatus.Status = ntStatus;

            //
            // detach and delete ourselves now
            //
            
            IoCompleteRequest(Irp,
                              IO_NO_INCREMENT);

            }
            break;

        case IRP_MN_STOP_DEVICE:            
        case IRP_MN_REMOVE_DEVICE:   
            if (irpStack->MinorFunction == IRP_MN_STOP_DEVICE) {
                DBCLASS_KdPrint((1, 
                "'(dbfilter)(device)(%x)IRP_MN_STOP_DEVICE\n",
                    deviceExtensionPdoFilter->PhysicalDeviceObject));  
            } else {                
                DBCLASS_KdPrint((1, 
                    "'(dbfilter)(device)(%x)IRP_MN_REMOVE_DEVICE\n",    
                        deviceExtensionPdoFilter->PhysicalDeviceObject));  
            }                
            // set the device filter object to NULL
            // this will allow the dbc to eject the device if requested
            {
            USHORT bay = 0;
            PDBC_CONTEXT dbcContext;

            dbcContext = deviceExtensionPdoFilter->DbcContext;
//            bay = DBCLASS_GetBayNumber(DeviceObject);

            if (bay) { 
                PDRB drb;
                
                DBCLASS_KdPrint((1, 
                    "'(dbfilter)(device)REMOVE/STOP, Bay[%d]\n", bay)); 

                //
                // notify filter of a stop
                // note that the filter may not veto the stop
                //
                drb = DbcExAllocatePool(NonPagedPool, 
                        sizeof(struct _DRB_START_DEVICE_IN_BAY));

                if (drb) { 
                
                    drb->DrbHeader.Length = sizeof(struct _DRB_STOP_DEVICE_IN_BAY);
                    drb->DrbHeader.Function = DRB_FUNCTION_STOP_DEVICE_IN_BAY;
                    drb->DrbHeader.Flags = 0;

                    drb->DrbStartDeviceInBay.BayNumber = bay;
                    
                    // make the request
                    ntStatus = DBCLASS_SyncSubmitDrb(dbcContext,
                                                     dbcContext->TopOfStack, 
                                                     drb);
                                                     
                    DBCLASS_KdPrint((1, 
                        "'OK to stop <%x>\n", ntStatus)); 

        			DbcExFreePool(drb);
                                                     
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                    
                dbcContext->BayInformation[bay].DeviceFilterObject = NULL;
            }                

			deviceExtensionPdoFilter->DbcContext = NULL;
            
            }
            break;       
#if 0                     
        case IRP_MN_QUERY_REMOVE_DEVICE:            
        case IRP_MN_QUERY_STOP_DEVICE:  
            {
            USHORT bay;
            
            bay = DBCLASS_GetBayNumber(DeviceObject);
            DBCLASS_KdPrint((1, 
                    "'(dbfilter)(device)(%x)Q_REMOVE/STOP, Bay[%d]\n", 
                       deviceExtensionPdoFilter->PhysicalDeviceObject, bay));        
            }                    
            break;
#endif            
        case IRP_MN_EJECT:

            {
            KEVENT event;
            USHORT bay;
            PDBC_CONTEXT dbcContext;
            
            dbcContext = deviceExtensionPdoFilter->DbcContext;

            DBCLASS_KdPrint((1, "'(dbfilter)(device)(%x)IRP_MN_EJECT, Bay[%d]\n",
                deviceExtensionPdoFilter->PhysicalDeviceObject,  
                deviceExtensionPdoFilter->Bay));    
            
            *Handled = TRUE;

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);  
            IoSetCompletionRoutine(Irp,
                                   DBCLASS_DeferIrpCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            //
            // send the request down the stack before we eject
            //

            ntStatus = IoCallDriver(deviceExtensionPdoFilter->TopOfStackDeviceObject, 
                                    Irp);
            
            if (ntStatus == STATUS_PENDING) {
                 // wait for irp to complete
        
                // TEST_TRAP(); // first time we hit this
                   
                KeWaitForSingleObject(
                    &event,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);
            }

            IoDetachDevice(deviceExtensionPdoFilter->TopOfStackDeviceObject);

            //
            // ounce we eject the device will disappear from the 
            // native bus.
            //

            ntStatus = Irp->IoStatus.Status;

//            TEST_TRAP();
//            if (NT_SUCCESS(ntStatus)) {
                bay = deviceExtensionPdoFilter->Bay;
            
                if (bay) {
                    ntStatus = DBCLASS_EjectPdo(DeviceObject);
                
                    DBCLASS_ASSERT(dbcContext->BayInformation[bay].DeviceFilterObject 
                        == NULL);
                }                     
#if DBG            
                  else {
                     DBCLASS_KdPrint((1, "'No Bay to EJECT (%x)\n", ntStatus));  
                     // TEST_TRAP();
                     ntStatus = STATUS_SUCCESS;
                }              
#endif
//            }
            
            Irp->IoStatus.Status = STATUS_SUCCESS;
            
            //
            // delete ourselves now
            //
            
            IoCompleteRequest(Irp,
                              IO_NO_INCREMENT);

			deviceExtensionPdoFilter->DbcContext = NULL;

            // remove PDO from our internal list
            DBCLASS_RemoveDevicePDOFromList(
                deviceExtensionPdoFilter->PhysicalDeviceObject);
            
            // free our device object
            IoDeleteDevice (DeviceObject);
            }
            
            break;       
            
        case IRP_MN_SET_LOCK: 
        
            DBCLASS_KdPrint((1, "'(dbfilter)(device)IRP_MN_SET_LOCK, Bay[%x]\n",
                deviceExtensionPdoFilter->Bay));    
            
            if (irpStack->Parameters.SetLock.Lock) { 
                DBCLASS_KdPrint((1, "'Request to LOCK device\n"));    
                DBCLASS_KdPrint((1, "'NOT ENABLING BAY ON LOCK!\n"));
                LOGENTRY(LOG_MISC, 'LOCK', 0, 0, 0);
                //ntStatus = DBCLASS_EnableDevice(DeviceObject);
            } else {
            
                //
                // cancel the eject timeout
                // if we get here no one vetoed the remove
                //

                DBCLASS_CancelEjectTimeout(DeviceObject);

                DBCLASS_KdPrint((1, "' Request to UNLOCK device\n"));    
                LOGENTRY(LOG_MISC, 'ULOC', 0, 0, 0);
            }
            
            *Handled = TRUE;

            IoCopyCurrentIrpStackLocationToNext(Irp);

            // Set up a completion routine to handle marking the IRP.
            IoSetCompletionRoutine(Irp,
                                   DBCLASS_PdoSetLockComplete,
                                   DeviceObject,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            // Now Pass down the IRP

            ntStatus = IoCallDriver(deviceExtensionPdoFilter->TopOfStackDeviceObject, Irp);
            LOGENTRY(LOG_MISC, 'sLOC', ntStatus, 0, 0);
                              
            break;    

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            DBCLASS_KdPrint((1, "'(dbfilter)(device)IRP_MN_CANCEL_REMOVE_DEVICE\n"));
            // TEST_TRAP();
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:            
            DBCLASS_KdPrint((1, 
                "'(dbfilter)(device)(%x)IRP_MN_QUERY_CAPABILITIES\n",    
                    deviceExtensionPdoFilter->PhysicalDeviceObject));
//
// Do this for all 1394 PDOs regardless of if they are device bay
// PDOs
//            if (deviceExtensionPdoFilter->DbcContext &&
//                deviceExtensionPdoFilter->Bay) {
                *Handled = TRUE;

                DBCLASS_KdPrint((1,"'>>QCAPS 1394/USB Device Bay PDO\n"));
                IoCopyCurrentIrpStackLocationToNext(Irp);

                // Set up a completion routine to handle marking the IRP.
                IoSetCompletionRoutine(Irp,
                                       DBCLASS_DevicePdoQCapsComplete,
                                       DeviceObject,
                                       TRUE,
                                       TRUE,
                                       TRUE);
                                       
                // Now Pass down the IRP

                ntStatus = IoCallDriver(deviceExtensionPdoFilter->TopOfStackDeviceObject, Irp);
//            }                
            break;                
        } /* irpStack->MinorFunction */
        break;
    } /* irpStack->MajorFunction */      

    LOGENTRY(LOG_MISC, 'pdo<', 0, DeviceObject, ntStatus);
    
    return ntStatus;
}


NTSTATUS
DBCLASS_SyncGetFdoType(
    IN PDEVICE_OBJECT FilterDeviceObject,
    IN PULONG FdoType
    )

/*++
Routine Description:

    This gets the bus type for this PDO (1394 or USB) 

    The goal of this function is to identify the stack the 
    filter is sitting on. 

    It is either:
    1. The USB root bus
    2. The 1394 HC 
    3. A USB hub (bus)
    4. A USB Device
    5. A 1394 Device

    The filter sits above the FDO (upperfilter) for the 
    respective PDO -- it is loaded as a class filter for
    USB and 1394.

    We do not need to identify USB devices and 1394 devices (4,5)
    since we attach sapartely to these when we hook QBRelations.


Arguments:

    DeviceObject - Physical DeviceObject for the bus.

    FdoType - set to DB_FDO_USBHUB_FILTER or 
                     DB_FDO_1394_FILTER  or 
                     0 if bus type is neither

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KEVENT event;
    PPNP_BUS_INFORMATION busInfo;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT pdoDeviceObject;
    PDEVICE_OBJECT topDeviceObject;
    PULONG         Tag;

    PAGED_CODE();
    
    deviceExtension = FilterDeviceObject->DeviceExtension;

    pdoDeviceObject = deviceExtension->PhysicalDeviceObject;
    topDeviceObject = deviceExtension->TopOfStackDeviceObject;
    
    DBCLASS_KdPrint((1, "'*>Filter -> QUERY BUS TYPE filter do %x\n", 
        FilterDeviceObject));
    DBCLASS_KdPrint((1, "'*>Filter -> QUERY BUS TYPE pdo %x\n", 
        pdoDeviceObject));        
    DBCLASS_KdPrint((1, "'*>Filter -> QUERY BUS TYPE top %x\n", 
        topDeviceObject));           
        
    irp = IoAllocateIrp(FilterDeviceObject->StackSize, FALSE);

    if (!irp) {
        TRAP(); //"failed to allocate Irp
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_BUS_INFORMATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           DBCLASS_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    ntStatus = IoCallDriver(FilterDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    busInfo = (PPNP_BUS_INFORMATION) irp->IoStatus.Information;    

    *FdoType = DB_FDO_BUS_UNKNOWN;  

    Tag = (PULONG) topDeviceObject->DeviceExtension;

    // see if this is a 1394 bus
    if(*Tag == PORT_EXTENSION_TAG)
    {
        DBCLASS_KdPrint((1, "'1394 Device\n")); 
        *FdoType = DB_FDO_1394_BUS;
        return STATUS_SUCCESS;
    }

    DBCLASS_KdPrint((1, "'Tag (%08X) DevExt (%08X) DevObj(%08X)\n", *Tag, Tag, topDeviceObject)); 
    DBCLASS_KdPrint((1, "'Status (%08X) Information (%08X)\n", irp->IoStatus.Status, irp->IoStatus.Information)); 
            

    if (busInfo) {
#if DBG    
        DBCLASS_KdPrint((1, "'USB GUID\n"));
        DBCLASS_KdPrintGuid(1, (PUCHAR) &GUID_BUS_TYPE_USB);

        DBCLASS_KdPrint((1, "'RETURNED GUID\n"));            
        DBCLASS_KdPrintGuid(1, (PUCHAR) &busInfo->BusTypeGuid);
#endif
        if (RtlCompareMemory(&busInfo->BusTypeGuid, 
                             &GUID_BUS_TYPE_USB, 
                             sizeof(GUID)) == sizeof(GUID)) {
                             
            *FdoType = DB_FDO_USBHUB_BUS;        

            DBCLASS_KdPrint((1, "'*>>Filter is for USB HUB\n"));    
        }
        
        ExFreePool(busInfo);
    } else {
        DBCLASS_KdPrint((2, "'no busInfo returned\n"));

        // this is either the 1394 or USB root bus
        // send down an private IOCTL to see if it is USB
        
        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack != NULL);
        
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.DeviceIoControl.IoControlCode = 
            IOCTL_INTERNAL_USB_GET_BUSGUID_INFO;
        
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        irp->IoStatus.Information = 0;
    
        KeInitializeEvent(&event, NotificationEvent, FALSE);
    
        IoSetCompletionRoutine(irp,
                               DBCLASS_DeferIrpCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(FilterDeviceObject,
                                irp);

        if (ntStatus == STATUS_PENDING) {
           // wait for irp to complete
       
           KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);
        }

        busInfo = (PPNP_BUS_INFORMATION) irp->IoStatus.Information;    

    	DBCLASS_KdPrint((1, "'Status (%08X) Information (%08X)\n", irp->IoStatus.Status, irp->IoStatus.Information)); 

        if (busInfo) {
#if DBG        
            DBCLASS_KdPrint((1, "'USB GUID\n"));
        	DBCLASS_KdPrintGuid(1, (PUCHAR) &GUID_BUS_TYPE_USB);

            DBCLASS_KdPrint((1, "'RETURNED GUID\n"));            
            DBCLASS_KdPrintGuid(1, (PUCHAR) &busInfo->BusTypeGuid);
#endif
            if (RtlCompareMemory(&busInfo->BusTypeGuid, 
                                 &GUID_BUS_TYPE_USB, 
                                 sizeof(GUID)) == sizeof(GUID)) {
                                 
                *FdoType = DB_FDO_BUS_IGNORE;        
                DBCLASS_KdPrint((1, "'*>>Filter is for USB HC\n"));    
            }
            
            ExFreePool(busInfo);
        }            
        else{
            // see if this is a 1394 bus
            if(*Tag == PORT_EXTENSION_TAG){
                DBCLASS_KdPrint((1, "'1394 Device\n")); 
                *FdoType = DB_FDO_1394_BUS;
            }
        }
    }
    
    ntStatus = STATUS_SUCCESS;

    IoFreeIrp(irp);

#if DBG 
    switch(*FdoType) {
    case DB_FDO_BUS_IGNORE:
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_BUS_IGNORE\n")); 
        break;
    case DB_FDO_BUS_UNKNOWN:   
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_BUS_UNKNOWN\n")); 
        break;
    case DB_FDO_USB_DEVICE: 
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_USB_DEVICE\n")); 
        break;
    case DB_FDO_USBHUB_BUS: 
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_USBHUB_BUS\n")); 
        break;
    case DB_FDO_1394_BUS: 
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_1394_BUS\n")); 
        break;
    case DB_FDO_1394_DEVICE:
        DBCLASS_KdPrint((1, "'*>>>FdoType: DB_FDO_1394_DEVICE\n")); 
        break;
    }
#endif

    BRK_ON_TRAP();
    return ntStatus;
}


NTSTATUS
DBCLASS_BusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    ntStatus = Irp->IoStatus.Status;
    *Handled = FALSE;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    LOGENTRY(LOG_MISC, 'dbf>', 0, DeviceObject, Irp);
    
    DBCLASS_KdPrint((1, "'(dbfilter)(bus)(%08X)IRP_MJ_ (%08X)  IRP_MN_ (%08X)\n",
        DeviceObject, irpStack->MajorFunction, irpStack->MinorFunction));  

    switch (irpStack->MajorFunction) {

    case IRP_MJ_PNP:
        switch (irpStack->MinorFunction) {    
        case IRP_MN_START_DEVICE:            
            // see if we can id the bus we are on

            ntStatus = 
            DBCLASS_SyncGetFdoType(DeviceObject,
                                   &deviceExtension->FdoType);

            if (deviceExtension->FdoType == DB_FDO_USBHUB_BUS) {
                // filter is sitting on a USB HUB 
            
                // null context indicates that this hub is not
                // part of a DBC
                deviceExtension->DbcContext = NULL;

                if (DBCLASS_IsHubPartOfACPI_DBC(DeviceObject)) {
                    
                    deviceExtension->DbcContext = 
                        DBCLASS_FindControllerACPI(deviceExtension->DriverObject,
                                                   DeviceObject);                                        
                                    
                    if (deviceExtension->DbcContext) {
                        USHORT bay;
                        // set the dbContext to point at this
                        // hub

                        // may need to handle multiple hubs
                        // currently we do not

                        DBCLASS_KdPrint(
                            (1, "'** Found ACPI DBC controller, linked to USBHUB\n"));
                            
                        for (bay=1; bay <=NUMBER_OF_BAYS(deviceExtension->DbcContext); bay++) {
                            deviceExtension->DbcContext->BayInformation[bay].UsbHubPdo = 
                                deviceExtension->PhysicalDeviceObject;                                                           
                        }
                    } 
#if DBG
                      else {
                         DBCLASS_KdPrint(
                            (0, "'** Could not find an ACPI DBC controller\n"));
                    }
#endif
                    
                } else {
                    // hub is not part of DBC (for now)
                    // if is part of USB dbc we will need to 
                    // wait for Q_BUS_RELATIONS
                    deviceExtension->DbcContext = NULL;
                }
                                                
            }            
            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(%08X)IRP_MN_START_DEVICE\n", DeviceObject));    
            break;

        case IRP_MN_STOP_DEVICE:            

            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(%08X)IRP_MN_STOP_DEVICE\n", DeviceObject));    
            break;

        case IRP_MN_REMOVE_DEVICE:            

            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(%08X)IRP_MN_REMOVE_DEVICE\n", DeviceObject));    

            DBCLASS_RemoveBusFilterMDOFromList(DeviceObject);

            IoDetachDevice(deviceExtension->TopOfStackDeviceObject);

            IoDeleteDevice(DeviceObject);
            break;
            
        break;
        } /* irpStack->MinorFunction */
    } /* irpStack->MajorFunction */      

    LOGENTRY(LOG_MISC, 'dbf<', 0, DeviceObject, 0);
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_GetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;
    HANDLE handle;
    
    PAGED_CODE();

    if (SoftwareBranch) {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);
    } else {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    }
    
    if (NT_SUCCESS(ntStatus)) {
    
        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);
        
        length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                KeyNameStringLength + DataLength;
                
        fullInfo = ExAllocatePoolWithTag(PagedPool, length, DBC_TAG); 
        
        DBCLASS_KdPrint((2,"' DBCLASS_GetRegistryKeyValueForPdo buffer = (%08X)\n", fullInfo));  
        
        if (fullInfo) {        
            ntStatus = ZwQueryValueKey(handle,
                            &keyNameUnicodeString,
                            KeyValueFullInformation,
                            fullInfo,
                            length,
                            &length);
                            
            if (NT_SUCCESS(ntStatus)){
                DBCLASS_ASSERT(DataLength == fullInfo->DataLength);                       
                RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
            }            

            ExFreePool(fullInfo);
        }        
    }
    
    return ntStatus;
}


NTSTATUS 
DBCLASS_SetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN ULONG Type,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    HANDLE handle;
    
    PAGED_CODE();

    if (SoftwareBranch) {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    } else {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    }

    if (NT_SUCCESS(ntStatus)) {
    
        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);
        
        ntStatus = ZwSetValueKey(handle,
                        &keyNameUnicodeString,
                        0,
                        Type,
                        Data,
                        DataLength);
                            
    }
    
    return ntStatus;
}



NTSTATUS
DBCLASS_DevicePdoQCapsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PDEVICE_OBJECT deviceFilterObject = Context;
    PDEVICE_EXTENSION deviceExtension;
    PDBC_CONTEXT dbcContext;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;
    BOOLEAN				linkDeviceObject = FALSE;

    deviceExtension = deviceFilterObject->DeviceExtension;
    dbcContext = deviceExtension->DbcContext;
    ioStack = IoGetCurrentIrpStackLocation(Irp);


#if DBG
    if (deviceExtension->Bay) 
    {
        DBCLASS_KdPrint((1, "'>QCAPS cmplt 1394/USB PDO %x -- Bay[%d]\n", 
                deviceExtension->PhysicalDeviceObject,
                deviceExtension->Bay));
    } 
    else 
    {
        DBCLASS_KdPrint((1, "'>QCAPS cmplt 1394/USB PDO %x -- No Bay\n", 
                deviceExtension->PhysicalDeviceObject));
    }
#endif            

    deviceCapabilities = ioStack->
            Parameters.DeviceCapabilities.Capabilities;


    dbcContext = DBCLASS_ControllerList;
    
    while(dbcContext) 
    {
    
        if (DBCLASS_IsLinkDeviceObject(dbcContext,
                                       deviceExtension->PhysicalDeviceObject)) 
        {
                                       
            DBCLASS_KdPrint((1, "'>>>1394 PDO is DBC Link, set suprise remove\n"));                             
            linkDeviceObject = TRUE; 
            break;
        }                             

        dbcContext = dbcContext->Next;
    }


    if(linkDeviceObject)
    {
    	// set surprise remove O.K. for device bay phy/link
        deviceCapabilities->SurpriseRemovalOK = TRUE;                   
	}
	else
	{
    	// indicate eject is supported for regular devices
    	deviceCapabilities->EjectSupported = 1;
    	deviceCapabilities->LockSupported = 1;
    }

#if DBG
    {
    ULONG i;
    
    DBCLASS_KdPrint((1, "'DEVICE PDO: Device Caps\n"));                          
    DBCLASS_KdPrint(
        (1, "'>>\n LockSupported = %d\n EjectSupported = %d \n Removable = %d \n DockDevice = %x\n",
        deviceCapabilities->LockSupported,  
        deviceCapabilities->EjectSupported,
        deviceCapabilities->Removable,
        deviceCapabilities->DockDevice));            
        
    DBCLASS_KdPrint(
        (1, "'>>\n UniqueId = %d\n SilentInstall = %d \n RawDeviceOK = %d \n SurpriseRemovalOK = %x\n",
        deviceCapabilities->UniqueID,  
        deviceCapabilities->SilentInstall,
        deviceCapabilities->RawDeviceOK,
        deviceCapabilities->SurpriseRemovalOK));                   
        
    DBCLASS_KdPrint((1, "'Device State Map:\n"));
        
    for (i=0; i< PowerSystemHibernate; i++) {
        DBCLASS_KdPrint((1, "'-->S%d = D%d\n", i-1, 
             deviceCapabilities->DeviceState[i]-1));       
    }
    }
#endif    

    
    
    return STATUS_SUCCESS;
}


VOID
DBCLASS_EjectCancelWorker(
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDBCLASS_WORKITEM workItem = Context;
    PDBC_CONTEXT dbcContext = workItem->DbcContext;
    PDBC_EJECT_TIMEOUT_CONTEXT timeoutContext =
        workItem->TimeoutContext;
    PDEVICE_EXTENSION deviceExtension;        

    LOGENTRY(LOG_MISC, 'eWK+', dbcContext, Context, timeoutContext);

    DbcExFreePool(workItem);

	// make sure the bay was mapped correctly before setting time out context
	if(dbcContext->BayInformation[timeoutContext->BayNumber].DeviceFilterObject)
	{

	    deviceExtension = 
	        dbcContext->BayInformation[
	            timeoutContext->BayNumber].DeviceFilterObject->DeviceExtension;

    	deviceExtension->TimeoutContext = NULL;            

    }

    DBCLASS_SyncBayFeatureRequest(dbcContext,
                                  DRB_FUNCTION_SET_BAY_FEATURE,
                                  timeoutContext->BayNumber,
                                  REQUEST_DEVICE_ENABLED_STATE);    

    DBCLASS_DecrementIoCount(dbcContext);            
    DBCLASS_PostChangeRequest(dbcContext);        

    DbcExFreePool(timeoutContext);
    LOGENTRY(LOG_MISC, 'eWK-', 0, Context, 0);

    return;
}


VOID
DBCLASS_EjectTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    
    
Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - 

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDBC_EJECT_TIMEOUT_CONTEXT
        timeoutContext = DeferredContext;
    PDBCLASS_WORKITEM workItem;        

    LOGENTRY(LOG_MISC, 'EJCo', 0, 0,  timeoutContext);    
        
    DBCLASS_KdPrint((1, "'**>Eject Timeout for Bay[%d]\n",
            timeoutContext->BayNumber));      

    workItem = DbcExAllocatePool(NonPagedPool, sizeof(DBCLASS_WORKITEM));

    if (workItem) {
        LOGENTRY(LOG_MISC, 'qETM', 0,
            workItem, 0);

        workItem->Sig = DBC_WORKITEM_SIG;
        workItem->DbcContext = timeoutContext->DbcContext;
        workItem->TimeoutContext = timeoutContext;
        //workItem->IrpStatus = Irp->IoStatus.Status;
        
        ExInitializeWorkItem(&workItem->WorkQueueItem,
                             DBCLASS_EjectCancelWorker,
                             workItem);

        DBCLASS_IncrementIoCount(timeoutContext->DbcContext); 
        ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);

    } else {
        TRAP();
        DbcExFreePool(timeoutContext);
    }                        
}


NTSTATUS
DBCLASS_SetEjectTimeout(
    PDEVICE_OBJECT DeviceFilterMDO
    )
/*++

Routine Description:

    for a given device PDO set the eject timeout for it

Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDBC_EJECT_TIMEOUT_CONTEXT timeoutContext;
    PDEVICE_EXTENSION deviceExtension;
    
    timeoutContext = DbcExAllocatePool(NonPagedPool, 
                                       sizeof(DBC_EJECT_TIMEOUT_CONTEXT));

    // extension for the device filter PDO
    deviceExtension = DeviceFilterMDO->DeviceExtension;
    
    if (timeoutContext) {
        LARGE_INTEGER dueTime;

        LOGENTRY(LOG_MISC, 'EJCs', deviceExtension->Bay, 0,  timeoutContext);    
        
        timeoutContext->BayNumber = 
            deviceExtension->Bay;
        timeoutContext->DbcContext = 
            deviceExtension->DbcContext;            
        DBCLASS_KdPrint((1, "'**>Set Eject Timeout for Bay[%d]\n",
            timeoutContext->BayNumber));      

//        DBCLASS_ASSERT(deviceExtension->TimeoutContext == NULL);
        deviceExtension->TimeoutContext = 
            timeoutContext;    

        KeInitializeTimer(&timeoutContext->TimeoutTimer);
        KeInitializeDpc(&timeoutContext->TimeoutDpc,
                        DBCLASS_EjectTimeoutDPC,
                        timeoutContext);

        dueTime.QuadPart = -10000 * DBCLASS_EJECT_TIMEOUT;

        KeSetTimer(&timeoutContext->TimeoutTimer,
                   dueTime,
                   &timeoutContext->TimeoutDpc);        

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
DBCLASS_CancelEjectTimeout(
    PDEVICE_OBJECT DeviceFilterMDO
    )
/*++

Routine Description:

    for a given device PDO set the eject timeout for it

Arguments:

Return Value:

    None.

--*/
{    
    PDBC_EJECT_TIMEOUT_CONTEXT timeoutContext;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceFilterMDO->DeviceExtension;
    timeoutContext = deviceExtension->TimeoutContext;
    deviceExtension->TimeoutContext = NULL;
    
    LOGENTRY(LOG_MISC, 'EJCc', 0, 0,  timeoutContext);

    if (timeoutContext) {
        if (KeCancelTimer(&timeoutContext->TimeoutTimer)) {
        // timer was pulled out of the queue

            DBCLASS_KdPrint((1, "'**>Canceled Eject Timeout for Bay[%d]\n",
                timeoutContext->BayNumber));    
            LOGENTRY(LOG_MISC, 'EJCk', 0, 0,  timeoutContext);    
            DbcExFreePool(timeoutContext);
        }                        
    } else {
        DBCLASS_KdPrint((1, "'**>Cancel Eject Timeout, No Timeout\n"));    
        
    }
    
    ntStatus = STATUS_SUCCESS;

    return ntStatus;
}


NTSTATUS
DBCLASS_CheckPhyLink(
    PDEVICE_OBJECT DevicePdo1394
    )
/*++

Routine Description:

    Given a 1394 PDO see if it is the phy/link for any of our DBC 
    controllers

Arguments:

Return Value:

    STATUS_SUCCESS 
    
--*/
{
    PDBC_CONTEXT dbcContext;
    
    dbcContext = DBCLASS_ControllerList;

    while (dbcContext) {

        LOGENTRY(LOG_MISC, 'FINl', dbcContext, 0, DevicePdo1394);
    
        if (DBCLASS_IsLinkDeviceObject(dbcContext, DevicePdo1394)) 
        {
            dbcContext->LinkDeviceObject = DevicePdo1394;                                                   
            DBCLASS_KdPrint((1, "'>PDO is DBC Link \n"));
            DBCLASS_KdPrint((1, "'>LinkDevObj (%08x) \n", dbcContext->LinkDeviceObject));
        
        }                                       

        dbcContext = dbcContext->Next;                                            
    }    

    return STATUS_SUCCESS;
}
   

NTSTATUS
DBCLASS_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBCLASS_KdPrint((2, "'Type (%08X), Length (%08X)\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        // we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}

#if 0

NTSTATUS
DBCLASS_GetClassGlobalRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBCLASS_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = ACPI_HUB_KEY;
    QueryTable[0].EntryContext = &DBCLASS_AcpiDBCHubParentPort;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBCLASS_AcpiDBCHubParentPort;
    QueryTable[0].DefaultLength = sizeof(DBCLASS_AcpiDBCHubParentPort);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
    
         DBCLASS_KdPrint((1, "'AcpiDBCHubParentPort Set: (%d)\n", 
            DBCLASS_AcpiDBCHubParentPort));
  
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#endif


NTSTATUS
DBCLASS_EjectBayComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PEJECT_CONTEXT ejectContext = Context;
    PDEVICE_EXTENSION deviceExtension;
    PDBC_CONTEXT dbcContext;
    USHORT bay;
    NTSTATUS ntStatus;

    bay = ejectContext->Bay;
    dbcContext = ejectContext->DbcContext;
    DbcExFreePool(ejectContext);

    ntStatus = Irp->IoStatus.Status;
    
    DBCLASS_KdPrint((0, "'>>Request Device Eject BAY[%d] complete  Status (%08X)\n", 
    				bay, ntStatus));

    // set a timeout for the eject
    // if the request failed the timeout will kick in and
    // re-post the chage request for us
    
    if (NT_SUCCESS(ntStatus)) {

	    // check and see if the bay is locked

   		if((!dbcContext->SubsystemDescriptor.bmAttributes.HasSecurityLock) ||
   			(dbcContext->SubsystemDescriptor.bmAttributes.HasSecurityLock &&
   			!dbcContext->BayInformation[bay].LastBayStatus.SecurityLockEngaged))
		{
#if 0
        	if (dbcContext->BayInformation[bay].DeviceFilterObject) {

            	DBCLASS_ASSERT(dbcContext->BayInformation[bay].DeviceFilterObject);    

            	DBCLASS_SetEjectTimeout(dbcContext->BayInformation[bay].DeviceFilterObject);
            
            	deviceExtension = 
                	dbcContext->BayInformation[bay].DeviceFilterObject->DeviceExtension;
                
            	DBCLASS_KdPrint((0, "'>>>Ejecting Filter %x PDO %x\n",
                	dbcContext->BayInformation[bay].DeviceFilterObject,
                	deviceExtension->PhysicalDeviceObject));
            	LOGENTRY(LOG_MISC, 'EJE+', 0, 0, deviceExtension->PhysicalDeviceObject);                       

            	IoRequestDeviceEject(deviceExtension->PhysicalDeviceObject);

        	} else {
    
#endif
            	DBCLASS_KdPrint((0, "'>>>No PDO for this bay\n"));
#if 0

            	if (dbcContext->BusFilterMdo1394 != NULL ||
                	dbcContext->BusFilterMdoUSB != NULL) 
#endif
            	{
                	PDRB drb;

                	//
                	// notify filter of a stop
                	// note that the filter may not veto the stop
                	//
                	drb = DbcExAllocatePool(NonPagedPool, 
                        	sizeof(struct _DRB_START_DEVICE_IN_BAY));

                	if (drb) 
                	{ 
                
                    	drb->DrbHeader.Length = sizeof(struct _DRB_STOP_DEVICE_IN_BAY);
                    	drb->DrbHeader.Function = DRB_FUNCTION_STOP_DEVICE_IN_BAY;
                    	drb->DrbHeader.Flags = 0;

                    	drb->DrbStartDeviceInBay.BayNumber = bay;
                    
                    	// make the request
                    	ntStatus = DBCLASS_SyncSubmitDrb(dbcContext,
                                                     	 dbcContext->TopOfStack, 
                                                     	 drb);
        				DbcExFreePool(drb);
                	}

                	// just pop out the device --
                	// surprise remove is OK at this point
                	DBCLASS_EjectBay(dbcContext, bay); 

    				DBCLASS_PostChangeRequest(dbcContext);        
                
            	}
#if 0
#if DBG                
              	else {
                	DBCLASS_KdPrint((0, "'>>Filter has not registered\n"));
                	TRAP();
            	}                  
#endif        
#endif
#if 0
        	}
#endif
     	} 
	}

     IoFreeIrp(Irp);

     return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\service.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    SERVICE.C

Abstract:

    Services provided to the DBC port driver

Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"   
#include "dbclass.h"   
#include "dbfilter.h"   

#define DBCLASS
#include "dbclib.h"
#undef DBCLASS

extern PDBC_CONTEXT DBCLASS_ControllerList;
extern KSPIN_LOCK DBCLASS_ControllerListSpin;
extern LIST_ENTRY DBCLASS_DevicePdoList;
extern LIST_ENTRY DBCLASS_BusFilterMdoList;

NTSTATUS
DBCLASS_Initialize(
    )
{
    // temp init code.
    static init = 0;

    if (init) 
    {
        return STATUS_SUCCESS;
    }

#if DBG
    DBCLASS_GetClassGlobalDebugRegistryParameters();
    BRK_ON_TRAP();
#endif    

    DBCLASS_KdPrint((1, "'Initailize DBC Class Driver\n"));
#ifdef DEBUG_LOG
    //
    // Initialize our debug trace log
    //
    DBCLASS_LogInit();
#endif

    DBCLASS_ControllerList = NULL;
    KeInitializeSpinLock(&DBCLASS_ControllerListSpin);
    InitializeListHead(&DBCLASS_DevicePdoList);
    InitializeListHead(&DBCLASS_BusFilterMdoList);
    init = 1;

    return STATUS_SUCCESS;
}

#if 0
__declspec(dllexport)
NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
{
    TEST_TRAP();
    
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{
    TEST_TRAP();

    return STATUS_SUCCESS;
}


NTSTATUS
DBCLASS_RegisterController(
    IN ULONG DbclassVersion,
    IN PDEVICE_OBJECT ControllerFdo, 
    IN PDEVICE_OBJECT TopOfPdoStack,
    IN PDEVICE_OBJECT ControllerPdo,
    IN ULONG ControllerSig
    )
/*++

Routine Description:

    This function registers a DBC with the class driver, the 
    FDO of the DBC is passed in along with the PDO for the DBC.

    The class driver uses this information to locate the 
    correct instances of the DB Class Driver FDOs.

Arguments:

Return Value:

    None

--*/
{
    PDBC_CONTEXT    dbcContext;
    KIRQL           irql;
    NTSTATUS        ntStatus;

#if DBG
    DBCLASS_GetClassGlobalDebugRegistryParameters();
#endif    

    DBCLASS_KdPrint((0, "'Class Registration\n"));
    LOGENTRY(LOG_MISC, 'REGc', ControllerFdo, 0, 0);

    // initialize here
    DBCLASS_Initialize();

    // search our list if we find the TopOfStack device
    // object then this must be a filter driver, otherwise
    // allocate a new context structure for this controller

    if (ControllerSig == DBC_OEM_FILTER_SIG) 
    {

        KeAcquireSpinLock(&DBCLASS_ControllerListSpin, &irql);

        dbcContext = DBCLASS_ControllerList;

        while (dbcContext) 
        {
        
            if (dbcContext->TopOfStack == TopOfPdoStack) 
            {

                // we have a DBC filter, update our 
                // TopOfStack DeviceObject so that
                // the filter gets called first
                
                DBCLASS_KdPrint((0, "'>Registering Filter\n"));

                dbcContext->TopOfStack = ControllerFdo;
                
                KeReleaseSpinLock(&DBCLASS_ControllerListSpin, irql);
                return STATUS_SUCCESS;
            }

            dbcContext = dbcContext->Next;
        
        } 

        KeReleaseSpinLock(&DBCLASS_ControllerListSpin, irql);

        DBCLASS_KdPrint((0, "'>Register Filter, could not find controller?\n"));

    } 
    else 
    {        
        // create a context structure for this controller
        DBCLASS_KdPrint((0, "'>Registering Controller\n"));

        KeAcquireSpinLock(&DBCLASS_ControllerListSpin, &irql);
        
        dbcContext = DbcExAllocatePool(NonPagedPool, sizeof(*dbcContext));
        if (dbcContext) 
        {
            RtlZeroMemory(dbcContext, sizeof(*dbcContext));

            dbcContext->Sig = DBC_CONTEXT_SIG;
            dbcContext->Next = DBCLASS_ControllerList;
            DBCLASS_ControllerList = dbcContext;
            dbcContext->TopOfStack = ControllerFdo;
            dbcContext->ControllerFdo = ControllerFdo;
            // consider ourselves initially stopped
            dbcContext->Stopped = TRUE;
            dbcContext->ControllerSig = ControllerSig;
            dbcContext->ControllerPdo = ControllerPdo;
            dbcContext->TopOfPdoStack = TopOfPdoStack;

            DBCLASS_KdPrint((0, "'ControllerFdo (%08X)  ControllerPdo (%08X) TopOfPdoStack (%08X) TopOfStack (%08X) DbcContext (%08X)\n",
                dbcContext->ControllerFdo, dbcContext->ControllerPdo, dbcContext->TopOfPdoStack, dbcContext->TopOfStack, dbcContext));

        
            ntStatus = STATUS_SUCCESS;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        KeReleaseSpinLock(&DBCLASS_ControllerListSpin, irql);

    }

    LOGENTRY(LOG_MISC, 'rEGc', ControllerFdo, ntStatus, 0);
    
    return ntStatus;
} 


NTSTATUS
DBCLASS_PortQDeviceRelationsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PDBC_CONTEXT        dbcContext = Context;
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_RELATIONS   oldList, newList;
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               pdoCount, i;
    
    // we are interested in REMOVAL_RELATIONS

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    DBCLASS_ASSERT(IRP_MJ_PNP == irpStack->MajorFunction);
    DBCLASS_ASSERT(IRP_MN_QUERY_DEVICE_RELATIONS == irpStack->MinorFunction);
    
    switch (irpStack->Parameters.QueryDeviceRelations.Type) 
    {
    case RemovalRelations:

        //
        // Add the PDOs for the device bay devices to the list
        //
        
        oldList = (PDEVICE_RELATIONS) Irp->IoStatus.Information; 
        newList = NULL;

        if (oldList) 
        {
            pdoCount = oldList->Count;
        } 
        else 
        {
            // empty list
            pdoCount = 0;   
        }

        //
        // count our PDOs
        //
        
        for (i=1; i<=NUMBER_OF_BAYS(dbcContext); i++) 
        {  
            if (dbcContext->BayInformation[i].DeviceFilterObject) 
            {
                pdoCount++;
            }
        }

        if (pdoCount) 
        {
            newList = ExAllocatePoolWithTag(PagedPool, sizeof(*newList) +
                (pdoCount - 1) * sizeof(PDEVICE_OBJECT), DBC_TAG);
        }
        
        if (newList) 
        {
            newList->Count = pdoCount = 0;

            // add the old list to the new list
            
            if (oldList) 
            {
                for (i=0; i< oldList->Count; i++) 
                {
                    newList->Objects[pdoCount] = oldList->Objects[i];
                    newList->Count++;
                    pdoCount++; 
                }
            }
            
            // free the old list
            
            ExFreePool(oldList);
            
            // add our PDOs to the list;
            
            for (i=1; i<=NUMBER_OF_BAYS(dbcContext); i++) 
            { 
            
                if (dbcContext->BayInformation[i].DeviceFilterObject) 
                {
                
                    deviceExtension = 
                        dbcContext->BayInformation[i].DeviceFilterObject->DeviceExtension;
                    
                    newList->Objects[pdoCount] = 
                        deviceExtension->PhysicalDeviceObject;                                    
                        
                    pdoCount++;                            
                    newList->Count++;
                }
            } 

            Irp->IoStatus.Information = PtrToUlong(newList);
        }
        break;
        
    default:
        break;
    }
    
    return STATUS_SUCCESS;
}



NTSTATUS
DBCLASS_UnRegisterController(
    IN PDEVICE_OBJECT ControllerFdo, 
    IN PDEVICE_OBJECT TopOfStack 
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{

    // locate which instance of the class driver is associated 
    // with this DBC.

    PDBC_CONTEXT        dbcContext  = NULL;    
    PDBC_CONTEXT        prev        = NULL; 

    prev = dbcContext = DBCLASS_ControllerList;

    while (dbcContext) 
    {

        if (dbcContext->ControllerFdo == ControllerFdo) 
        {
            // remove controller

            DBCLASS_KdPrint((0, "'>UnRegister Controller\n"));
            
            DBCLASS_KdPrint((0, "'ControllerFdo (%08X)  ControllerPdo (%08X) TopOfPdoStack (%08X) TopOfStack (%08X) FilterMDOUSB (%08X) DbcContext (%08X)\n",
                dbcContext->ControllerFdo, dbcContext->ControllerPdo, dbcContext->TopOfPdoStack, dbcContext->TopOfStack, dbcContext->BusFilterMdoUSB, dbcContext));


            // unlink
            if (DBCLASS_ControllerList == dbcContext) 
            {
                DBCLASS_ControllerList = dbcContext->Next;
            } 
            else 
            {
                DBCLASS_ASSERT(prev->Next == dbcContext);
                prev->Next = dbcContext->Next;
            }

            DBCLASS_RemoveControllerFromMdo(dbcContext);

            DbcExFreePool(dbcContext);
            break;
        }

        prev = dbcContext;
        dbcContext = dbcContext->Next;
    }
    
    LOGENTRY(LOG_MISC, 'UNRc', dbcContext, 0, 0);
    
#if DBG
    if (dbcContext == NULL) 
    {
        DBCLASS_KdPrint((0, "'Controller not Found\n"));
        TRAP();
    }
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
DBCLASS_ClassDispatch(
    IN PDEVICE_OBJECT ControllerFdo,
    IN PIRP Irp,
    IN PBOOLEAN HandledByClass
    )    
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDBC_CONTEXT dbcContext;

    *HandledByClass = FALSE;
    dbcContext = DBCLASS_GetDbcContext(ControllerFdo);

    LOGENTRY(LOG_MISC, 'dIRP', ControllerFdo, 0, Irp);

    if (dbcContext == NULL) 
    {
        DBCLASS_KdPrint((0, "'Invalid ControllerFdo passed in\n"));
        TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
        *HandledByClass = TRUE;    
        goto DBCLASS_Dispatch_Done;
    }

    ntStatus = Irp->IoStatus.Status;        
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) 
    {

    case IRP_MJ_POWER:    

        ntStatus = DBCLASS_ClassPower(ControllerFdo,
                                      Irp,
                                      HandledByClass);
        goto DBCLASS_Dispatch_Exit;                                      
        break; /* IRP_MJ_POWER */
        
    case IRP_MJ_PNP:
        switch (irpStack->MinorFunction) 
        {    
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            // handle Q_BUS_RELATIONS for the port driver
        
            *HandledByClass = TRUE;
            // hook the completion and pass on
            
            IoCopyCurrentIrpStackLocationToNext(Irp);    
            IoSetCompletionRoutine(Irp,
                                   DBCLASS_PortQDeviceRelationsComplete,
                                   dbcContext,
                                   TRUE,
                                   TRUE,
                                   TRUE);   
                                   
            ntStatus = IoCallDriver(dbcContext->TopOfStack, Irp);
            // we did the calldown for the port driver so 
            // all we do now is exit
            goto DBCLASS_Dispatch_Exit;
            
            break;
        
        case IRP_MN_START_DEVICE:
        
            DBCLASS_KdPrint((1, "'IRP_MN_START_DEVICE\n"));
            ntStatus = DBCLASS_StartController(dbcContext,
                                               Irp,
                                               HandledByClass);
            break;

#if 0            
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
#if DBG        
            if (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                DBCLASS_KdPrint((1, "'IRP_MN_QUERY_REMOVE_DEVICE\n"));
            } else {                
                DBCLASS_KdPrint((1, "'IRP_MN_QUERY_STOP_DEVICE\n"));
            }                
#endif           
            // would like to eject the devices at this 
            // point -- instead I will fail if we have devices in
            // the bays!
            
            {
                BOOLEAN empty = TRUE;
                USHORT  bay;
                
                for (bay=1; bay <=NUMBER_OF_BAYS(dbcContext); bay++) 
                {
                    if (dbcContext->BayInformation[bay].DeviceFilterObject != 
                            NULL) 
                    {
                        empty = FALSE;
                        break;
                    }
                }             

                if (!empty) 
                {
                    *HandledByClass = TRUE;
                    ntStatus = STATUS_UNSUCCESSFUL;
                    DBCLASS_KdPrint((1, "'Bays not Empty!"));
                    goto DBCLASS_Dispatch_Done;
                }
            }
            break;
#endif            
        case IRP_MN_STOP_DEVICE:
            DBCLASS_KdPrint((1, "'IRP_MN_STOP_DEVICE\n"));
            ntStatus = DBCLASS_StopController(dbcContext,
                                              Irp,
                                              HandledByClass);
            if (NT_SUCCESS(ntStatus)) 
            {                                              
                // free allocated resources
                ntStatus = DBCLASS_CleanupController(dbcContext);                                              
            }
            
            dbcContext->Stopped = TRUE;                                              
            LOGENTRY(LOG_MISC, 'STPd', dbcContext, 0, ntStatus);
            break;                                              
            
        case IRP_MN_REMOVE_DEVICE:
            DBCLASS_KdPrint((1, "'IRP_MN_REMOVE_DEVICE\n"));
            DBCLASS_KdPrint((1, "'FDO (%08X)\n", ControllerFdo));
            
            if (!dbcContext->Stopped) 
            {
                ntStatus = DBCLASS_StopController(dbcContext,
                                                  Irp,
                                                  HandledByClass);
                if (NT_SUCCESS(ntStatus)) 
                {                                              
                    // free allocated resources
                    ntStatus = DBCLASS_CleanupController(dbcContext);                                              
                }                                                     
            } 
            else 
            {
                ntStatus = STATUS_SUCCESS;
            }

            LOGENTRY(LOG_MISC, 'RMVd', dbcContext, 0, ntStatus);                                               
            break;
        }            
        break;
        
    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:
        ntStatus = STATUS_SUCCESS;
        break;
        
    default:
        //
        // Irp is not interesting to us
        LOGENTRY(LOG_MISC, 'pIRP', ControllerFdo, 0, Irp);
        break;    
    }; /* case MJ_FUNCTION */


DBCLASS_Dispatch_Done:

    if (*HandledByClass) 
    {
        DBCLASS_KdPrint((2, "'Completing Irp\n"));
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);   
    }

DBCLASS_Dispatch_Exit:

    return ntStatus;
}


NTSTATUS
DBCLASS_FilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    figure out what type of FDO we are and dispatch to 
    the appropriate handler
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    BOOLEAN             handled = FALSE;
    PDEVICE_OBJECT      topOfStackDeviceObject;
    ULONG               MinFunc, MajFunc;

    deviceExtension         = DeviceObject->DeviceExtension;
    topOfStackDeviceObject  = deviceExtension->TopOfStackDeviceObject;

    LOGENTRY(LOG_MISC, 'FLT>', 0, DeviceObject, Irp);
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);

	MinFunc = irpStack->MinorFunction;
	MajFunc = irpStack->MajorFunction;
	
    // figure out what kind of PDO this call is bound for

    switch(deviceExtension->FdoType) 
    {
    case DB_FDO_BUS_IGNORE:
        break;
    
    case DB_FDO_BUS_UNKNOWN:
    
        ntStatus = DBCLASS_BusFilterDispatch(
                            DeviceObject,
                            Irp,
                            &handled);
        break;
    
    case DB_FDO_USBHUB_BUS:
        
        ntStatus = DBCLASS_UsbhubBusFilterDispatch(
                            DeviceObject,
                            Irp,
                            &handled);
        break;
    case DB_FDO_USB_DEVICE:          
    case DB_FDO_1394_DEVICE:        
    
        ntStatus = DBCLASS_PdoFilterDispatch(
                            DeviceObject,
                            Irp,
                            &handled);
        break;
    case DB_FDO_1394_BUS:
        
        ntStatus = DBCLASS_1394BusFilterDispatch(
                            DeviceObject,
                            Irp,
                            &handled);
        break;
    default:
        DBCLASS_KdPrint((0, "'Invalid Extension Signature"));
        TRAP();
    }

    if (!handled) 
    {

        if(MajFunc == IRP_MJ_POWER)
        {
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);    
            ntStatus = PoCallDriver(topOfStackDeviceObject, Irp);

		    if(ntStatus)
		    {
        	    DBCLASS_KdPrint((2, "'Filter Power Dispatch Status (%08X)\n", ntStatus));
		    }

        }
        else
        {   
            // all filters behave pretty much the same 
            // if the routine we called did not want to 
            // handle the IRP we take the default action 
            // here.

            IoSkipCurrentIrpStackLocation(Irp);    
            ntStatus = IoCallDriver(topOfStackDeviceObject, Irp);

		    if(ntStatus)
		    {
        	    DBCLASS_KdPrint((2, "'Filter Dispatch Status (%08X)\n", ntStatus));
		    }
        }

    }

    LOGENTRY(LOG_MISC, 'PNP<', ntStatus, DeviceObject, 0);
    
    return ntStatus;
}


#if 0
NTSTATUS
DBCLASS_SetD0_Complete(
    PDEVICE_OBJECT ControllerFdo,
    PIRP Irp
    )
/*++

Routine Description:

    Called by port driver when the port driver 
    enters D0.
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDBC_CONTEXT dbcContext;    
    
    LOGENTRY(LOG_MISC, 'D0cp', 0, ControllerFdo, Irp);
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    dbcContext = DBCLASS_GetDbcContext(ControllerFdo);
    
    DBCLASS_KdPrint((0, "'Set DevicePowerState = D0\n"));
    dbcContext->CurrentDevicePowerState = PowerDeviceD0;
    
    return ntStatus;
}
#endif


NTSTATUS
DBCLASS_RegisterBusFilter(
    ULONG DbclassVersion,
    PDRIVER_OBJECT FilterDriverObject,
    PDEVICE_OBJECT FilterMdo
    )
/*++

Routine Description:

    find the controller for this PDO and associate the
    PDO with the correct bay
    
Arguments:

     

Return Value:

    NTSTATUS
    
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    deviceExtension = FilterMdo->DeviceExtension;

    // initialize here
    DBCLASS_Initialize();
    
    LOGENTRY(LOG_MISC, 'rPDO', 0, FilterMdo, 0);
    DBCLASS_KdPrint((0, "'Register Bus Filter FDO(%x)\n", FilterMdo));

    // The bus filter handle one instance of the 1394 bus --
    // which may have multiple DBCs associated with it.
    // therefore we don't use the Context field in the bus filter
    // extension
    
    deviceExtension->DbcContext = (PDBC_CONTEXT) -1;

    // Put the filter MDO on our list of bus filters
    
    DBCLASS_AddBusFilterMDOToList(FilterMdo);
    
    return ntStatus;
}


NTSTATUS
DBCLASS_AddBusFilterMDOToList(
    PDEVICE_OBJECT BusFilterMdo
    )

/*++

Routine Description:

    Adds a bus filter to our internal list

Arguments:

Return Value:

    NTSTATUS
    
--*/

{
    PDBCLASS_PDO_LIST newEntry;

    newEntry = ExAllocatePool(NonPagedPool, sizeof(DBCLASS_PDO_LIST));

    DBCLASS_ASSERT(newEntry);

    if (newEntry == NULL) 
    {
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Fill in fields in new entry

    newEntry->FilterDeviceObject = BusFilterMdo;

    // Add new entry to end of list
    InsertTailList(&DBCLASS_BusFilterMdoList, &newEntry->ListEntry);

    DBCLASS_KdPrint((2, "'AddBusFilterMdo (%08X)\n", BusFilterMdo));

    return STATUS_SUCCESS;
}


VOID
DBCLASS_RemoveBusFilterMDOFromList(
    IN PDEVICE_OBJECT BusFilterMdo
    )

/*++

Routine Description:

    Removes a bus filter from the internal list 
    
Arguments:

    BusFilterMdo - a pointer to the device object to remove.

Return Value:

    VOID

--*/

{
    PDBCLASS_PDO_LIST entry;
    PLIST_ENTRY listEntry;

    listEntry = &DBCLASS_BusFilterMdoList;

    if (!IsListEmpty(listEntry)) 
    {
       listEntry = DBCLASS_BusFilterMdoList.Flink;
    }
     
    while (listEntry != &DBCLASS_BusFilterMdoList) 
    {
    
        entry = CONTAINING_RECORD(listEntry, 
                                  DBCLASS_PDO_LIST, 
                                  ListEntry);
                                  
        DBCLASS_ASSERT(entry);

        if (entry->FilterDeviceObject == BusFilterMdo) 
            break;

        listEntry = entry->ListEntry.Flink;

    }            

    // we should always find it
    DBCLASS_ASSERT(listEntry != &DBCLASS_BusFilterMdoList);

    DBCLASS_KdPrint((2, "'RemoveBusFilterMdo (%08X)\n", BusFilterMdo));
    
    RemoveEntryList(listEntry);
    ExFreePool(entry);
}


VOID
DBCLASS_Refresh1394(
    )

/*++

Routine Description:

    Removes a bus filter from the internal list 
    
Arguments:

    DeviceObject - a pointer to the device object to remove.

Return Value:

    VOID

--*/

{
    PDBCLASS_PDO_LIST entry;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION busFilterDeviceExtension;
    PDEVICE_OBJECT  FilterDevObj;

    listEntry = &DBCLASS_BusFilterMdoList;

    if (!IsListEmpty(listEntry)) {
       listEntry = DBCLASS_BusFilterMdoList.Flink;
    }
     
    while (listEntry != &DBCLASS_BusFilterMdoList) 
    {

        entry = CONTAINING_RECORD(listEntry, 
                                  DBCLASS_PDO_LIST, 
                                  ListEntry);
                                  
        DBCLASS_ASSERT(entry);

        FilterDevObj = entry->FilterDeviceObject;

        DBCLASS_KdPrint((2, "'Refresh1394 Entry (%08X)  FilterDevObj (%08X)\n", entry, FilterDevObj));

        if(FilterDevObj)
        {
            busFilterDeviceExtension = 
                FilterDevObj->DeviceExtension;

            if(busFilterDeviceExtension)
            {
                if (busFilterDeviceExtension->FdoType == DB_FDO_1394_BUS) 
                {
                    DBCLASS_KdPrint((0, "'IoInvalidate 1394\n"));
                    IoInvalidateDeviceRelations(busFilterDeviceExtension->PhysicalDeviceObject,
                                                BusRelations);  
                }
            }
        }

        listEntry = entry->ListEntry.Flink;

    }            

}



VOID
DBCLASS_RemoveControllerFromMdo(PDBC_CONTEXT DbcContext)

/*++

Routine Description:

    Removes reference to USB controller from a filter
    
Return Value:

    VOID

--*/

{
    PDBCLASS_PDO_LIST entry;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION busFilterDeviceExtension;
    PDEVICE_OBJECT  FilterDevObj;

    listEntry = &DBCLASS_DevicePdoList;

    if (!IsListEmpty(listEntry)) 
    {
       listEntry = DBCLASS_DevicePdoList.Flink;
    }
     
    while (listEntry != &DBCLASS_DevicePdoList) 
    {

        entry = CONTAINING_RECORD(listEntry, 
                                  DBCLASS_PDO_LIST, 
                                  ListEntry);
                                  
        DBCLASS_ASSERT(entry);

        FilterDevObj = entry->FilterDeviceObject;

        if(FilterDevObj)
        {
            busFilterDeviceExtension = 
                FilterDevObj->DeviceExtension;

            if(busFilterDeviceExtension)
            {
                if (busFilterDeviceExtension->DbcContext == DbcContext) 
                {
                    DBCLASS_KdPrint((2, "'Remove Controller From FilterDevObj (%08X)\n", FilterDevObj));

                    busFilterDeviceExtension->DbcContext = NULL;
                }
            }
        }

        listEntry = entry->ListEntry.Flink;

    }            

}











=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbfilter\dbf.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBF.H

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the DeviceBay Filter Driver
    
Environment:

    Kernel & user mode

Revision History:

    

--*/

//
// registry keys
//

#define DEBUG_LEVEL_KEY                 L"debuglevel"
#define DEBUG_WIN9X_KEY                 L"debugWin9x"


/* 
Debug Macros
*/
#if DBG

VOID
DBF_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

#define DBF_ASSERT(exp) \
    if (!(exp)) { \
        DBF_Assert( #exp, __FILE__, __LINE__, NULL );\
    }            

ULONG
_cdecl
DBF_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define DBF_KdPrint(_x_) DBF_KdPrintX _x_ 
#define TEST_TRAP() { DbgPrint( "DBFILTER: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                      TRAP();}
#ifdef MAX_DEBUG
#define MD_TEST_TRAP() { DbgPrint( "DBFILTER: MAX_DEBUG trap %s line: %d\n", __FILE__, __LINE__);\
                      TRAP();}    
#else
#define MD_TEST_TRAP()
#endif

#ifdef NTKERN
#define TRAP() _asm {int 3}
#else
#define TRAP() DbgBreakPoint()
#endif

#else

#define DBF_ASSERT(exp)
#define DBF_KdPrint(_x_)

#define TRAP()
#define TEST_TRAP() 
#define MD_TEST_TRAP()

#endif


NTSTATUS
DBF_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
DBF_GetClassGlobalDebugRegistryParameters(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcacpi\acpi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ACPI.C

Abstract:

    This module contains code to execute ACPI
    control methods

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    05-13-98 : created

--*/
#include <wdm.h>
#include <initguid.h>
#include <wdmguid.h>
#include <acpiioct.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbci.h"
#include "dbcacpi.h"


ACPI_INTERFACE_STANDARD     AcpiInterfaces;

#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, DBCACPI_SyncAcpiCall)
#pragma alloc_text(PAGE, DBCACPI_ReadWriteDBCRegister)
#endif


NTSTATUS
DBCACPI_SyncAcpiCall(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            OutputSize
)
/*++

Routine Description:

    Called to send a request to the Pdo

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioBlock;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;

    PAGED_CODE();

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
        Ioctl,
        Pdo,
        InputBuffer,
        InputSize,
        OutputBuffer,
        OutputSize,
        FALSE,
        &event,
        &ioBlock
        );
        
    if (!irp) {
        DBCACPI_KdPrint ((0, "'failed to allocate Irp\n"));
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to Pdo, always wait for completion routine
    //

   
    LOGENTRY(LOG_MISC, "ACP>", 0,irp, 0);

    status = IoCallDriver(Pdo, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        LOGENTRY(LOG_MISC, "ACPw", 0,irp, 0);
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
            
        status = ioBlock.Status;
        LOGENTRY(LOG_MISC, "ACPk", 0, 0, status);
    }
    
    LOGENTRY(LOG_MISC, "ACP<", 0, 0, status);
    //
    // Done
    //
    DBCACPI_KdPrint((2, "'DBCACPI_SyncAcpiCall(%x)\n", status)); 

    return status;
}


NTSTATUS
DBCACPI_BIOSControl(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Enable
)
/*++

Routine Description:

    Called to read or write a DBC register

Arguments:

    DeviceObject - Device Object of DBC controller (FDO)
        

Return Value:

    NT Status of the operation

--*/
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX  inputBuffer = NULL;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer = NULL;
    NTSTATUS                ntStatus;
    PACPI_METHOD_ARGUMENT   readFlag;
    ULONG inputSize, outputSize;
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR outUChar;
    PUSHORT outUShort;
    PULONG outULong;
    
    PAGED_CODE();

    DBCACPI_KdPrint((2, "'DBCACPI_ControlBIOS\n"));
    
    DBCACPI_IncrementIoCount(DeviceObject);
    //
    // Fill in the input data
    //

    // allow for one arg

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    inputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_METHOD_ARGUMENT) * 1 ;
                
    outputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_EVAL_OUTPUT_BUFFER) * 1 ; 
        
    inputBuffer = ExAllocatePool(NonPagedPool, inputSize);
    outputBuffer = ExAllocatePool(NonPagedPool, outputSize);

    //
    // Send the request 
    //

    if ( inputBuffer && outputBuffer) {

        // set up the input buffer
        inputBuffer->MethodNameAsUlong = DBACPI_BCTR_METHOD;
        
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->ArgumentCount = 1;
        inputBuffer->Size = inputSize; //??

        // pack up the args
        
        readFlag = &inputBuffer->Argument[0];
        readFlag->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        readFlag->DataLength = sizeof(ULONG);
        readFlag->Argument = (ULONG) Enable ? 1 : 0;

        RtlZeroMemory(outputBuffer, outputSize);

#if DBG
#endif  

        ntStatus = DBCACPI_SyncAcpiCall(
           deviceExtension->TopOfStackDeviceObject,
           IOCTL_ACPI_EVAL_METHOD,
           inputBuffer,
           inputSize,
           outputBuffer,
           outputSize
           );

        if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {
            DBCACPI_KdPrint((0, "'method failed\n"));        
            TRAP();
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
        
            DBCACPI_KdPrint((2, "'Status = %x Output Buffer: %x\n", ntStatus, outputBuffer));        
            DBCACPI_KdPrint((2, "'>Signature %x\n", outputBuffer->Signature)); 
            DBCACPI_KdPrint((2, "'>Length %x\n", outputBuffer->Length)); 
            DBCACPI_KdPrint((2, "'>Count %x\n", outputBuffer->Count)); 

            DBCACPI_ASSERT(outputBuffer->Count == 1);
            
        }
    } else { 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCACPI_DecrementIoCount(DeviceObject);
    DBCACPI_KdPrint((2, "'DBCACPI_ControlBIOS(%x)\n", ntStatus)); 

    return ntStatus;
}    


NTSTATUS
DBCACPI_ReadGuidRegister(
    PDEVICE_OBJECT DeviceObject,
    PVOID GuidData,
    USHORT GuidDataLength,
    ULONG Arg0
)
/*++

Routine Description:

    Called to read DBC 1394 GUID register

Arguments:

    DeviceObject - Device Object of DBC controller (FDO)
        

Return Value:

    NT Status of the operation

--*/
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX  inputBuffer = NULL;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer = NULL;
    NTSTATUS                ntStatus;
    PACPI_METHOD_ARGUMENT   readFlag;
    ULONG inputSize, outputSize;
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR outUChar;
    PUSHORT outUShort;
    PULONG outULong;
    
    PAGED_CODE();

    DBCACPI_KdPrint((2, "'DBCACPI_ReadGUIDRegister\n")); 
    
    DBCACPI_IncrementIoCount(DeviceObject);
    //
    // Fill in the input data
    //

    RtlZeroMemory(GuidData, GuidDataLength);

    // allow for one arg

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    inputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_METHOD_ARGUMENT) * 1 + GuidDataLength;
                
    outputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_EVAL_OUTPUT_BUFFER) * 1 + GuidDataLength; 
        
    inputBuffer = ExAllocatePool(NonPagedPool, inputSize);
    outputBuffer = ExAllocatePool(NonPagedPool, outputSize);

    outULong = GuidData;
    
    //
    // Send the request 
    //

    if ( inputBuffer && outputBuffer) {

        // set up the input buffer
        inputBuffer->MethodNameAsUlong = DBACPI_GUID_METHOD;
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->ArgumentCount = 1;
        inputBuffer->Size = inputSize; //??

        // pack up the args
        
        readFlag = &inputBuffer->Argument[0];
        readFlag->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        readFlag->DataLength = sizeof(ULONG);
        readFlag->Argument = (ULONG) Arg0;

        RtlZeroMemory(outputBuffer, outputSize);

#if DBG
#endif  

        ntStatus = DBCACPI_SyncAcpiCall(
           deviceExtension->TopOfStackDeviceObject,
           IOCTL_ACPI_EVAL_METHOD,
           inputBuffer,
           inputSize,
           outputBuffer,
           outputSize
           );

        if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {
            DBCACPI_KdPrint((0, "'method failed\n"));        
            TRAP();
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
        
            DBCACPI_KdPrint((2, "'Status = %x Output Buffer: %x\n", ntStatus, outputBuffer));        
            DBCACPI_KdPrint((2, "'>Signature %x\n", outputBuffer->Signature)); 
            DBCACPI_KdPrint((2, "'>Length %x\n", outputBuffer->Length)); 
            DBCACPI_KdPrint((2, "'>Count %x\n", outputBuffer->Count)); 

            DBCACPI_ASSERT(outputBuffer->Count == 1);
            
            DBCACPI_ASSERT(GuidDataLength == 4);
            
            *outULong = outputBuffer->Argument[0].Argument;

            DBCACPI_KdPrint((1, "'Guid Register (arg0 %d) - [%x]\n", 
                Arg0, *outULong)); 

        }
    } else { 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCACPI_DecrementIoCount(DeviceObject);
    DBCACPI_KdPrint((2, "'DBCACPI_ReadGUIDRegister(%x)\n", ntStatus)); 


    return ntStatus;
}    


NTSTATUS
DBCACPI_ReadBayMapRegister(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Usb,
    PVOID BayData,
    USHORT BayDataLength,
    ULONG BayNumber
)
/*++

Routine Description:

    Called to read or write a DBC register

Arguments:

    DeviceObject - Device Object of DBC controller (FDO)
        

Return Value:

    NT Status of the operation

--*/
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX  inputBuffer = NULL;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer = NULL;
    NTSTATUS                ntStatus;
    PACPI_METHOD_ARGUMENT   readFlag;
    ULONG inputSize, outputSize;
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR outUChar;
    PUSHORT outUShort;
    PULONG outULong;
    
    PAGED_CODE();

    DBCACPI_KdPrint((2, "'DBCACPI_ReadBayMapRegister\n"));
    
    DBCACPI_IncrementIoCount(DeviceObject);
    //
    // Fill in the input data
    //

    RtlZeroMemory(BayData, BayDataLength);

    // allow for one arg

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    inputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_METHOD_ARGUMENT) * 1 + BayDataLength;
                
    outputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_EVAL_OUTPUT_BUFFER) * 1 + BayDataLength; 
        
    inputBuffer = ExAllocatePool(NonPagedPool, inputSize);
    outputBuffer = ExAllocatePool(NonPagedPool, outputSize);

    outULong = BayData;
    
    //
    // Send the request 
    //

    if ( inputBuffer && outputBuffer) {

        // set up the input buffer
        if (Usb) {
            inputBuffer->MethodNameAsUlong = DBACPI_BPMU_METHOD;
        } else {
            inputBuffer->MethodNameAsUlong = DBACPI_BPM3_METHOD;
        }
        
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->ArgumentCount = 1;
        inputBuffer->Size = inputSize; //??

        // pack up the args
        
        readFlag = &inputBuffer->Argument[0];
        readFlag->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        readFlag->DataLength = sizeof(ULONG);
        readFlag->Argument = (ULONG) BayNumber;

        RtlZeroMemory(outputBuffer, outputSize);

#if DBG
#endif  

        ntStatus = DBCACPI_SyncAcpiCall(
           deviceExtension->TopOfStackDeviceObject,
           IOCTL_ACPI_EVAL_METHOD,
           inputBuffer,
           inputSize,
           outputBuffer,
           outputSize
           );

        if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {
            DBCACPI_KdPrint((0, "'method failed\n"));        
            TRAP();
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
        
            DBCACPI_KdPrint((2, "'Status = %x Output Buffer: %x\n", ntStatus, outputBuffer));        
            DBCACPI_KdPrint((2, "'>Signature %x\n", outputBuffer->Signature)); 
            DBCACPI_KdPrint((2, "'>Length %x\n", outputBuffer->Length)); 
            DBCACPI_KdPrint((2, "'>Count %x\n", outputBuffer->Count)); 

            DBCACPI_ASSERT(outputBuffer->Count == 1);
            
            DBCACPI_ASSERT(BayDataLength == 4);
            
            *outULong = outputBuffer->Argument[0].Argument;

            if (Usb) {
                DBCACPI_KdPrint((1, "'USB  Bay Map Register (bay %d) - port[%x]\n", 
                    BayNumber, *outULong)); 
            } else {
                DBCACPI_KdPrint((1, "'1394 Bay Map Register (bay %d) - port[%x]\n", 
                    BayNumber, *outULong)); 
            }

        }
    } else { 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCACPI_DecrementIoCount(DeviceObject);
    DBCACPI_KdPrint((2, "'DBCACPI_ReadBayRegister(%x)\n", ntStatus)); 


    return ntStatus;
}    


NTSTATUS
DBCACPI_ReadBayReleaseRegister(
    PDEVICE_OBJECT DeviceObject,
    PULONG ReleaseOnShutdown
)
/*++

Routine Description:

    Called to read or write a DBC register

Arguments:

    DeviceObject - Device Object of DBC controller (FDO)
        

Return Value:

    NT Status of the operation

--*/
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX  inputBuffer = NULL;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer = NULL;
    NTSTATUS                ntStatus;
    PACPI_METHOD_ARGUMENT   readFlag;
    ULONG inputSize, outputSize;
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR outUChar;
    PUSHORT outUShort;
    PULONG outULong;
    
    PAGED_CODE();

    DBCACPI_KdPrint((2, "'DBCACPI_ReadBayReleaseRegister\n"));
    
    DBCACPI_IncrementIoCount(DeviceObject);
    //
    // Fill in the input data
    //

    // allow for one arg

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    inputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_METHOD_ARGUMENT) * 0;
                
    outputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_EVAL_OUTPUT_BUFFER) * 0; 
        
    inputBuffer = ExAllocatePool(NonPagedPool, inputSize);
    outputBuffer = ExAllocatePool(NonPagedPool, outputSize);

    outULong = ReleaseOnShutdown;
    
    //
    // Send the request 
    //

    if ( inputBuffer && outputBuffer) {

        // set up the input buffer
        inputBuffer->MethodNameAsUlong = DBACPI_BREL_METHOD;
        
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->ArgumentCount = 0;
        inputBuffer->Size = inputSize; //??

        // pack up the args
        
//        readFlag = &inputBuffer->Argument[0];
//        readFlag->Type = ACPI_METHOD_ARGUMENT_INTEGER;
//        readFlag->DataLength = sizeof(ULONG);
//        readFlag->Argument = (ULONG) BayNumber;

        RtlZeroMemory(outputBuffer, outputSize);

#if DBG
#endif  

        ntStatus = DBCACPI_SyncAcpiCall(
           deviceExtension->TopOfStackDeviceObject,
           IOCTL_ACPI_EVAL_METHOD,
           inputBuffer,
           inputSize,
           outputBuffer,
           outputSize
           );

        if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {
            DBCACPI_KdPrint((0, "'method failed %x\n"));        
            TRAP();
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
        
            DBCACPI_KdPrint((2, "'Status = %x Output Buffer: %x\n", ntStatus, outputBuffer));        
            DBCACPI_KdPrint((2, "'>Signature %x\n", outputBuffer->Signature)); 
            DBCACPI_KdPrint((2, "'>Length %x\n", outputBuffer->Length)); 
            DBCACPI_KdPrint((2, "'>Count %x\n", outputBuffer->Count)); 

            DBCACPI_ASSERT(outputBuffer->Count == 1);
            
            *outULong = outputBuffer->Argument[0].Argument;

            DBCACPI_KdPrint((1, "'BREL = %d\n", outULong));

        }
    } else { 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCACPI_DecrementIoCount(DeviceObject);
    DBCACPI_KdPrint((2, "'DBCACPI_ReadBayRegister(%x)\n", ntStatus)); 


    return ntStatus;
}    


NTSTATUS
DBCACPI_ReadWriteDBCRegister(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegisterOffset,
    PVOID RegisterData,
    USHORT RegisterDataLength,
    BOOLEAN ReadRegister    
)
/*++

Routine Description:

    Called to read or write a DBC register

Arguments:

    DeviceObject - Device Object of DBC controller (FDO)
    RegisterOffset - offset of the register to read/write
    RegisterData - ptr to register data to read or write
    

Return Value:

    NT Status of the operation

--*/
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX  inputBuffer = NULL;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer = NULL;
    NTSTATUS                ntStatus;
    PACPI_METHOD_ARGUMENT   readFlag;
    PACPI_METHOD_ARGUMENT   offset;
    PACPI_METHOD_ARGUMENT   reg;
    ULONG inputSize, outputSize;
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR outUChar;
    PUSHORT outUShort;
    PULONG outULong;
    
    PAGED_CODE();

    DBCACPI_IncrementIoCount(DeviceObject);
    //
    // Fill in the input data
    //

    if (ReadRegister) {
        RtlZeroMemory(RegisterData, RegisterDataLength);
    }        

    // allow for three args

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    inputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_METHOD_ARGUMENT) * 2 + RegisterDataLength;
                
    outputSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) + 
            sizeof(ACPI_EVAL_OUTPUT_BUFFER) * 2 + RegisterDataLength; 
        
    inputBuffer = ExAllocatePool(NonPagedPool, inputSize);
    outputBuffer = ExAllocatePool(NonPagedPool, outputSize);

    outUChar = RegisterData;
    outUShort = RegisterData;
    outULong = RegisterData;
    
    //
    // Send the request 
    //

    if ( inputBuffer && outputBuffer) {

        // set up the input buffer
        inputBuffer->MethodNameAsUlong = DBACPI_DBCC_METHOD;
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->ArgumentCount = 3;
        inputBuffer->Size = inputSize; //??

        // pack up the args
        
        readFlag = &inputBuffer->Argument[0];
        readFlag->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        readFlag->DataLength = sizeof(ULONG);
        readFlag->Argument = (ULONG) ReadRegister;

        offset = &inputBuffer->Argument[1];
        offset->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        offset->DataLength = sizeof(ULONG);
        offset->Argument = (ULONG) RegisterOffset;

//        reg = &inputBuffer->Argument[2];     
//        reg->Type = ACPI_METHOD_ARGUMENT_BUFFER;
//        reg->DataLength = RegisterDataLength;
//        RtlCopyMemory(&reg->Data[0], RegisterData, RegisterDataLength);

        // Compaq BIOS expects a ulong 
        reg = &inputBuffer->Argument[2];     
        reg->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        reg->DataLength = sizeof(ULONG);
        switch (RegisterDataLength) {
        case sizeof(UCHAR):
            reg->Argument = (ULONG) *((UCHAR *) RegisterData);
            break;            
        case sizeof(USHORT):
            reg->Argument = (ULONG) *((USHORT *) RegisterData);
            break;
        case sizeof(ULONG):
            reg->Argument = (ULONG) *((ULONG *) RegisterData);
            break;
        default:
            TRAP();
        }            
            
        RtlZeroMemory(outputBuffer, outputSize);

#if DBG
        if (ReadRegister) {
            DBCACPI_KdPrint((2, "'Read reg off %x\n", RegisterOffset));        
        } else {
            DBCACPI_KdPrint((2, "'Write reg off 0x%0x val 0x%0x\n", 
                RegisterOffset, (ULONG) *((ULONG *) RegisterData)));  
        }
#endif    
        ntStatus = DBCACPI_SyncAcpiCall(
           deviceExtension->TopOfStackDeviceObject,
           IOCTL_ACPI_EVAL_METHOD,
           inputBuffer,
           inputSize,
           outputBuffer,
           outputSize
           );

        if (outputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {
            DBCACPI_KdPrint((0, "'method failed\n"));        
            TRAP();
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
        
            DBCACPI_KdPrint((2, "'Status = %x Output Buffer: %x\n", ntStatus, outputBuffer));        
            DBCACPI_KdPrint((2, "'>Signature %x\n", outputBuffer->Signature)); 
            DBCACPI_KdPrint((2, "'>Length %x\n", outputBuffer->Length)); 
            DBCACPI_KdPrint((2, "'>Count %x\n", outputBuffer->Count)); 

            DBCACPI_ASSERT(outputBuffer->Count == 1);
            
            //convert output
            switch (RegisterDataLength) {
            case sizeof(UCHAR):
                *outUChar = (UCHAR) outputBuffer->Argument[0].Argument;
                break;            
            case sizeof(USHORT):
                *outUShort = (USHORT) outputBuffer->Argument[0].Argument;
                break;
            case sizeof(ULONG):
                *outULong = outputBuffer->Argument[0].Argument;
                break;
            default:
                TRAP();
            }            

        }
    } else { 
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCACPI_DecrementIoCount(DeviceObject);
    DBCACPI_KdPrint((2, "'DBCACPI_ReadWriteDBCRegister(%x)\n", ntStatus)); 


    return ntStatus;
}    


NTSTATUS
DBCACPI_GetAcpiInterfaces(
    IN PDEVICE_OBJECT   Pdo
    )

/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.  It does
    this the first time it is called, no more.

Arguments:

    None.

Return Value:

    Status

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT LowerPdo;
    KEVENT event;

    LowerPdo = IoGetAttachedDeviceReference(Pdo);
        
    if (LowerPdo) {
        //
        // Allocate an IRP for below
        //
        irp = IoAllocateIrp (LowerPdo->StackSize, FALSE);      // Get stack size from PDO

        if (!irp) {
            DBCACPI_KdPrint((0, "'Could not allocate Irp!\n")); 

			// decrement reference count
			ObDereferenceObject(LowerPdo);

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
        //
        irpStack->MajorFunction = IRP_MJ_PNP;
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

        irpStack->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
        irpStack->Parameters.QueryInterface.Version                = 1;
        irpStack->Parameters.QueryInterface.Size                   = sizeof (AcpiInterfaces);
        irpStack->Parameters.QueryInterface.Interface              = (PINTERFACE) &AcpiInterfaces;
        irpStack->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp,
                           DBCACPI_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);
                           
        ntStatus = IoCallDriver (LowerPdo, irp);
        
        if (ntStatus == STATUS_PENDING) {
           // wait for irp to complete
       
           TEST_TRAP(); // first time we hit this
       
           KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);

            ntStatus = irp->IoStatus.Status;                
        }

        IoFreeIrp (irp);

        if (!NT_SUCCESS(ntStatus)) {
            DBCACPI_KdPrint((0, "'Could not get ACPI interfaces!\n")); 
            TRAP();                
        }
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


VOID 
DBCACPI_NotifyHandler (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    )
/*++

Routine Description:

    This routine fields device notifications from the ACPI driver.

Arguments:

 
Return Value:

    None

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = Context;
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;
    PDBCACPI_WORKITEM workItem;
    
    DBCACPI_KdPrint((0, "'DBC Notification (%x)\n", NotifyValue)); 
    LOGENTRY(LOG_MISC, "Not+", 0, Context, 0);

    // do we have a workitem scheduled?

    deviceExtension = fdoDeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    
    KeAcquireSpinLock(&deviceExtension->FlagsSpin, &oldIrql);
    
    if (deviceExtension->Flags & DBCACPI_FLAG_WORKITEM_PENDING) {
        // yes, bail
        KeReleaseSpinLock(&deviceExtension->FlagsSpin, oldIrql);
    } else {
        // no, schedule one
        DBCACPI_IncrementIoCount(fdoDeviceObject);
        
        workItem = &deviceExtension->WorkItem;
        deviceExtension->Flags |= DBCACPI_FLAG_WORKITEM_PENDING; 
        KeReleaseSpinLock(&deviceExtension->FlagsSpin, oldIrql);
        
        workItem->Sig = DBC_WORKITEM_SIG;
            
        ExInitializeWorkItem(&workItem->WorkQueueItem,
                             DBCACPI_NotifyWorker,
                             fdoDeviceObject);

        ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);
    }

    LOGENTRY(LOG_MISC, "Not-", 0, Context, 0);
}


NTSTATUS 
DBCACPI_RegisterWithACPI(
    IN PDEVICE_OBJECT FdoDeviceObject,
    IN BOOLEAN Register
    )
/*++

Routine Description:

Arguments:

 
Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    deviceExtension = FdoDeviceObject->DeviceExtension;

    if (Register) {
        ntStatus = AcpiInterfaces.RegisterForDeviceNotifications (

                    deviceExtension->PhysicalDeviceObject,
#if 0
// this is needed on NT5
                    AcpiInterfaces.Context,
#endif                    
                    DBCACPI_NotifyHandler,
                    FdoDeviceObject);
    } else {
        AcpiInterfaces.UnregisterForDeviceNotifications (
                    deviceExtension->PhysicalDeviceObject,
                    
#if 0       
// this is needed on NT5
                    AcpiInterfaces.Context,
#endif                    
                    DBCACPI_NotifyHandler);
    }

    LOGENTRY(LOG_MISC, "rACP", Register, 0, ntStatus);  

    return ntStatus;
}                   


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbfilter\dbg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for DBC driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:



Revision History:

    11-5-96 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbf.h"

#if DBG 

ULONG DBF_Debug_Trace_Level = 3;
ULONG DBF_W98_Debug_Trace;

NTSTATUS
DBF_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBF_KdPrint((2, "'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        // we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


NTSTATUS
DBF_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBF_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL_KEY;
    QueryTable[0].EntryContext = &DBF_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBF_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(DBF_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = DBF_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X_KEY;
    QueryTable[1].EntryContext = &DBF_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &DBF_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(DBF_W98_Debug_Trace);
    
    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         DBF_KdPrint((1, "'Debug Trace Level Set: (%d)\n", DBF_Debug_Trace_Level));
  
        if (DBF_W98_Debug_Trace) {
            DBF_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            DBF_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }
    
//        if (DBF_Debug_Trace_Level > 0) {
//            ULONG DBF_Debug_Asserts = 1;
//        }
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}



VOID
DBF_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    TRAP();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
DBF_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (DBF_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            if (DBF_W98_Debug_Trace) {
                DbgPrint("DBFILTER.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'DBFILTER.SYS: ");
            }
        } else {
            DbgPrint("'DBFILTER.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


#endif /* DBG */




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcacpi\dbcacpi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBCACPI.C

Abstract:

    Driver for ACPI based device bay contoller

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-98 : created, jdunn

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"
#include "dbclib.h"
#include "dbcacpi.h"

#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, DBCACPI_QueryCapabilities)
#pragma alloc_text(PAGE, DBCACPI_Power)
#pragma alloc_text(PAGE, DBCACPI_Pnp)
#pragma alloc_text(PAGE, DBCACPI_StartDevice)
#pragma alloc_text(PAGE, DBCACPI_StopDevice)


#endif

//
// Globals
//

PDRIVER_OBJECT DBCACPI_DriverObject;
ULONG TotalHeapSace = 0;

ULONG DBCACPI_BIOS = 1;
ULONG DBCACPI_PollMode = 0;

#ifndef DEBUG0
 #ifndef DEBUG1
  #ifndef DEBUG2
   #ifndef DEBUG3
    #if DBG
    #define DEBUG0
    #endif
   #endif 
  #endif  
 #endif    
#endif

ULONG DBCACPI_W98_Debug_Trace = 0;

#ifdef DEBUG0
ULONG DBCACPI_Debug_Trace_Level = 0;
#endif /* DEBUG0 */

#ifdef DEBUG1
ULONG DBCACPI_Debug_Trace_Level = 1;
#endif /* DEBUG1 */

#ifdef DEBUG2
ULONG DBCACPI_Debug_Trace_Level = 2;
#endif /* DEBUG2 */

#ifdef DEBUG3
ULONG DBCACPI_Debug_Trace_Level = 3;
#endif /* DEBUG3 */


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;

    DBCACPI_DriverObject = DriverObject;

    //
    // Create dispatch points for device control.
    //

    DriverObject->DriverUnload = DBCACPI_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DBCACPI_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DBCACPI_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DBCACPI_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = DBCACPI_Pnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = DBCACPI_Power;
    DriverObject->DriverExtension->AddDevice = DBCACPI_AddDevice;

    return ntStatus;
}


NTSTATUS
DBCACPI_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject = Context;
    NTSTATUS ntStatus;

    deviceExtension = deviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    irp = deviceExtension->PowerIrp;
    
    ntStatus = IoStatus->Status;

    IoCopyCurrentIrpStackLocationToNext(irp);      
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 irp);   

    DBCACPI_DecrementIoCount(deviceObject);                 

    return ntStatus;
}


NTSTATUS
DBCACPI_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
DBCACPI_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    
    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           DBCACPI_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);
                           
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    // PnP rule: 
    // init all pnp irps we initiate with status_not_supported
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    
    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       TEST_TRAP(); // first time we hit this
       
       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;                 
    }

#if DBG                    
    if (!NT_SUCCESS(ntStatus)) {
        // failed? this is probably a bug
        DBCACPI_KdPrint((0, "'QueryCapabilities failed, why?\n"));
        TRAP();
    }
#endif

    IoFreeIrp(irp);

    return STATUS_SUCCESS;
}


NTSTATUS
DBCACPI_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

    

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN handledByClass;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    DBCACPI_IncrementIoCount(DeviceObject);

    // let the class driver have a peek at the 
    // power Irp
    ntStatus = DBCLASS_ClassDispatch(
            DeviceObject,
            Irp,
            &handledByClass);          

    if (handledByClass) {  
        DBCACPI_DecrementIoCount(DeviceObject);           
        return ntStatus;
    }
     
    //
    // We must handle the D state messages, the class driver
    // makes sure we only see changes from the current state
    // it also inteprets all the nasty wake rules so that the 
    // code remains as simple as possible
    //
    
    //
    // these asserts mean we have a bug in the class driver
    // please 'fix' the class driver not this driver
    //
    DBCACPI_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    DBCACPI_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
    DBCACPI_ASSERT(deviceExtension->CurrentDevicePowerState != 
                  irpStack->Parameters.Power.State.DeviceState);
    
    deviceExtension->CurrentDevicePowerState = 
        irpStack->Parameters.Power.State.DeviceState;
    
    IoCopyCurrentIrpStackLocationToNext(Irp);
    
    PoStartNextPowerIrp(Irp);
    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    DBCACPI_DecrementIoCount(DeviceObject);

    return ntStatus;
}


NTSTATUS
DBCACPI_Pnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT stackDeviceObject;
    BOOLEAN handledByClass;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    DBCACPI_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

    DBCACPI_IncrementIoCount(DeviceObject);

    DBCACPI_KdPrint((2, "'IRP_MJ_PNP\n"));        

    ntStatus = Irp->IoStatus.Status;
    
    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        {
        KEVENT event;

        DBCACPI_KdPrint((1, "'IRP_MN_START_DEVICE\n"));
        LOGENTRY(LOG_MISC, "Strt", 0, 0, 0);
        
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);  
        IoSetCompletionRoutine(Irp,
                               DBCACPI_DeferIrpCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);


        ntStatus = IoCallDriver(stackDeviceObject,
                                Irp);
            
        if (ntStatus == STATUS_PENDING) {
             // wait for irp to complete
       
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);

            ntStatus =  Irp->IoStatus.Status;                
        }

        if (NT_SUCCESS(ntStatus)) {
        
            ntStatus = DBCACPI_StartDevice(DeviceObject);

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = DBCLASS_ClassDispatch(
                        DeviceObject,
                        Irp,
                        &handledByClass);                               

                DBCACPI_ASSERT(handledByClass == FALSE);                       

                if (NT_SUCCESS(ntStatus) && DBCACPI_PollMode) {
                    DBCACPI_StartPolling(DeviceObject);
                }                    
            }  

            // update irp with status of start
            Irp->IoStatus.Status = ntStatus;
        }
#ifdef DBG        
          else {
            DBCACPI_KdPrint((0, "'Lower driver failed the START! (0x%x)\n", 
                    ntStatus));            
            TRAP();                    
        } 
#endif
        goto DBCACPI_Dispatch_CompleteRequest;
        }
        break;

    case IRP_MN_STOP_DEVICE:
        
        DBCACPI_KdPrint((1, "'IRP_MN_STOP_DEVICE\n"));
        LOGENTRY(LOG_MISC, "Stop", 0, 0, deviceExtension->Flags);

        if (deviceExtension->Flags & DBCACPI_FLAG_STARTED) {
            deviceExtension->Flags &= ~DBCACPI_FLAG_STARTED;

            ntStatus = DBCLASS_ClassDispatch(
                DeviceObject,
                Irp,
                &handledByClass);          
                
            DBCACPI_ASSERT(handledByClass == FALSE);  

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = DBCACPI_StopDevice(DeviceObject);
            }
        }            
        
        LOGENTRY(LOG_MISC, "StpD", 0, 0, ntStatus);
        break;

    case IRP_MN_REMOVE_DEVICE:

        DBCACPI_KdPrint((1, "'IRP_MN_REMOVE_DEVICE\n"));
        LOGENTRY(LOG_MISC, "REMv", 0, 0, 0);

        // let the class driver do some cleanup
        ntStatus = DBCLASS_ClassDispatch(
            DeviceObject,
            Irp,
            &handledByClass);          
            
        DBCACPI_ASSERT(handledByClass == FALSE);  

        if (!(deviceExtension->Flags & DBCACPI_FLAG_STOPPED)) {
           DBCACPI_StopDevice(DeviceObject);
        }            

        // match the inc at the begining of the dispatch
        // routine
        DBCACPI_DecrementIoCount(DeviceObject);

        if (deviceExtension->WakeIrp) {
            IoCancelIrp(deviceExtension->WakeIrp);
            deviceExtension->WakeIrp = NULL;
        }
        
        //
        // ounce this flag is set no irps will be pased 
        // down the stack to lower drivers
        //
        deviceExtension->AcceptingRequests = FALSE;

        if (NT_SUCCESS(ntStatus)) {
            LONG pendingIoCount;

            IoCopyCurrentIrpStackLocationToNext(Irp);  

            ntStatus = IoCallDriver(stackDeviceObject,
                                    Irp);

            //
            // final decrement will trigger the remove
            //
            pendingIoCount = DBCACPI_DecrementIoCount(DeviceObject);

            {
                NTSTATUS status;

                // wait for any io request pending in our driver to
                // complete for finishing the remove

                LOGENTRY(LOG_MISC, "ReWT", 0, 0, ntStatus);

                status = KeWaitForSingleObject(
                            &deviceExtension->RemoveEvent,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);

                LOGENTRY(LOG_MISC, "ReWD", 0, 0, ntStatus);                            

            }
            
            //
            // Delete the link and FDO we created
            //

            IoDetachDevice(deviceExtension->TopOfStackDeviceObject);

            IoDeleteDevice (DeviceObject);
            DBCACPI_KdPrint((1, "'>REMOVE DONE\n"));
            LOGENTRY(LOG_MISC, "RemD", 0, 0, ntStatus);

            goto DBCACPI_Dispatch_Done;
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        DBCACPI_KdPrint((1, "'IRP_MN_QUERY_STOP_DEVICE\n"));
        break;
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DBCACPI_KdPrint((1, "'IRP_MN_QUERY_REMOVE_DEVICE\n"));
        break;
    case IRP_MN_CANCEL_STOP_DEVICE:
        DBCACPI_KdPrint((1, "'IRP_MN_CANCEL_STOP_DEVICE\n"));
        break;
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        DBCACPI_KdPrint((1, "'IRP_MN_CANCEL_REMOVE_DEVICE\n"));
        break;
    default:
        DBCACPI_KdPrint((1,"'PnP IOCTL not handled\n"));
    } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */


    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // All PNP_POWER messages get passed to the TopOfStackDeviceObject
    // we were given in PnPAddDevice
    //

    ntStatus = IoCallDriver(stackDeviceObject,
                            Irp);

    DBCACPI_DecrementIoCount(DeviceObject);

    goto DBCACPI_Dispatch_Done;

DBCACPI_Dispatch_CompleteRequest:

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT);

    DBCACPI_DecrementIoCount(DeviceObject);

DBCACPI_Dispatch_Done:

    DBCACPI_KdPrint((3, "'DBCACPI_Pnp() = %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
DBCACPI_Ioctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    BOOLEAN handledByClass;
    PIO_STACK_LOCATION ioStackLocation; 
    
    DBCACPI_IncrementIoCount(DeviceObject);

    ntStatus = DBCLASS_ClassDispatch(
                DeviceObject,
                Irp,
                &handledByClass);   

    if (!handledByClass) {

        // we need to handle this IRP
        
        ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

        switch (ioStackLocation->MajorFunction) {
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            {
            ULONG ioControlCode;

            ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
            switch (ioControlCode) {
            
            case IOCTL_INTERNAL_DBC_SUBMIT_DRB:
                DBCACPI_KdPrint((2,"'Handle DRB\n"));
                ntStatus = DBCACPI_ProcessDrb(DeviceObject,
                                              Irp);

                if (ntStatus == STATUS_PENDING) {
                    // we queued the irp, don't complete 
                    // it here
                    return ntStatus;                                    
                }                    
                break;
            default:            
                ntStatus = STATUS_NOT_SUPPORTED;                                      
            } /* ioControlCode */           
            }
            break;
        default:
            ntStatus = STATUS_NOT_SUPPORTED;    
            break;
        } /* ioStackLocation->MajorFunction */

        DBCACPI_DecrementIoCount(DeviceObject);
        
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp,
                           IO_NO_INCREMENT);
    } else {
        DBCACPI_DecrementIoCount(DeviceObject);
    }
                                          
    return ntStatus;
}


NTSTATUS
DBCACPI_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    NTSTATUS ntStatus;
    BOOLEAN handledByClass;
    
    TEST_TRAP();

    DBCACPI_IncrementIoCount(DeviceObject);
        
    ntStatus = DBCLASS_ClassDispatch(
                DeviceObject,
                Irp,
                &handledByClass);   

    // class driver should handle all system control
    DBCACPI_ASSERT(handledByClass == TRUE);
    
    DBCACPI_DecrementIoCount(DeviceObject);
    
    return ntStatus;
}




VOID
DBCACPI_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
}


NTSTATUS
DBCACPI_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    return ntStatus;
}


NTSTATUS
DBCACPI_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device

Arguments:

    DriverObject - pointer to the driver object for this instance of DBCACPI

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;

    //
    // create our funtional device object (FDO)
    //

    DBCACPI_KdPrint((0,"'Device Bay ACPI Controller Driver (ADD)\n"));
    DBCACPI_LogInit();

#if DBG
    DBCACPI_GetClassGlobalDebugRegistryParameters();
#endif    
    DBCACPI_GetClassGlobalRegistryParameters();
    
    ntStatus = DBCACPI_GetAcpiInterfaces(PhysicalDeviceObject);

    if (NT_SUCCESS(ntStatus)) {
        ntStatus =
            DBCACPI_CreateDeviceObject(DriverObject, &deviceObject);
    }                    

    if (NT_SUCCESS(ntStatus)) {
        deviceExtension = deviceObject->DeviceExtension;

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // we support direct io for read/write
        //
        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        //** initialize our device extension
        deviceExtension->Sig = DBCACPI_EXT_SIG;
        //
        // remember the Physical device Object
        //
        deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;
        KeInitializeSpinLock(&deviceExtension->FlagsSpin);
        KeInitializeSpinLock(&deviceExtension->ChangeRequestSpin);

        //
        // Attach to the PDO
        //

        deviceExtension->TopOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        DBCACPI_QueryCapabilities(PhysicalDeviceObject,
                                 &deviceExtension->DeviceCapabilities);            

        //
        // display the device  caps
        //
#if DBG
        {
        ULONG i;
        
        DBCACPI_KdPrint((1, "'>>>>>> DeviceCaps\n"));  
        DBCACPI_KdPrint((1, "'SystemWake = (%d)\n", 
            deviceExtension->DeviceCapabilities.SystemWake));    
        DBCACPI_KdPrint((1, "'DeviceWake = (D%d)\n",
                deviceExtension->DeviceCapabilities.DeviceWake-1));

        for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++) {
            
            DBCACPI_KdPrint((1, "'Device State Map: sysstate %d = devstate 0x%x\n", i, 
                 deviceExtension->DeviceCapabilities.DeviceState[i]));       
        }
        DBCACPI_KdPrint((1, "'<<<<<<<<DeviceCaps\n"));
        }
#endif

        // kill the ACPI BIOS
        if (DBCACPI_BIOS ) {
            DBCACPI_KdPrint((0,"'Disable BIOS Control\n"));
            DBCACPI_BIOSControl(deviceObject,
                                FALSE);            
        }                                

        // Register with the Class Driver
        DBCLASS_RegisterController(
            DBCLASS_VERSION,
            deviceObject, 
            deviceExtension->TopOfStackDeviceObject,
            deviceExtension->PhysicalDeviceObject,
            DBC_ACPI_CONTROLLER_SIG);                                

        //
        // transition to zero signals the event
        //
        DBCACPI_IncrementIoCount(deviceObject);                                 
    }

    return ntStatus;
}


NTSTATUS
DBCACPI_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
                    created device object.

    Instance - instnace of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    WCHAR deviceNameBuffer[]  = L"\\Device\\DBCACPI-0";
    UNICODE_STRING deviceNameUnicodeString;
    ULONG i = 0;

    // do we need a name?
    do {

        deviceNameBuffer[15] = (USHORT) ('0' + i);

        RtlInitUnicodeString (&deviceNameUnicodeString,
                              deviceNameBuffer);

        ntStatus = IoCreateDevice (DriverObject,
                                   sizeof (DEVICE_EXTENSION),
                                   &deviceNameUnicodeString,
                                   FILE_DEVICE_UNKNOWN,
                                   0,
                                   FALSE,
                                   DeviceObject);

        i++;
        
    } while (!NT_SUCCESS(ntStatus));

    return ntStatus;
}


LONG
DBCACPI_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    LONG ioCount;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    ioCount = InterlockedDecrement(&deviceExtension->PendingIoCount);

    DBCACPI_KdPrint ((2, "'Dec Pending io count = %x\n", ioCount));

    if (ioCount==0) {
        LOGENTRY(LOG_MISC, "ReWK", 0, 0, 0);           
        KeSetEvent(&deviceExtension->RemoveEvent,
                   1,
                   FALSE);
    }

    return ioCount;
}


VOID
DBCACPI_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    InterlockedIncrement(&deviceExtension->PendingIoCount);
}


NTSTATUS
DBCACPI_WaitWakeIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    
Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    DBCACPI_DecrementIoCount(DeviceObject);     
    
    return IoStatus->Status;
}    


NTSTATUS 
DBCACPI_GetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;
    HANDLE handle;
    
    PAGED_CODE();

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     //PLUGPLAY_REGKEY_DRIVER,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {
    
        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);
        
        length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                KeyNameStringLength + DataLength;
                
        fullInfo = ExAllocatePoolWithTag(PagedPool, length, 'dbca'); 
        
        DBCACPI_KdPrint((2,"' DBCAPI_GetRegistryKeyValueForPdo buffer = 0x%x\n", fullInfo));  
        
        if (fullInfo) {        
            ntStatus = ZwQueryValueKey(handle,
                            &keyNameUnicodeString,
                            KeyValueFullInformation,
                            fullInfo,
                            length,
                            &length);
                            
            if (NT_SUCCESS(ntStatus)){
                DBCACPI_ASSERT(DataLength == fullInfo->DataLength);                       
                RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
            }            

            ExFreePool(fullInfo);
        }        
    }
    
    return ntStatus;
}


NTSTATUS 
DBCACPI_SetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN ULONG Type,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    HANDLE handle;
    
    PAGED_CODE();

    if (SoftwareBranch) {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    } else {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    }

    if (NT_SUCCESS(ntStatus)) {
    
        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);
        
        ntStatus = ZwSetValueKey(handle,
                        &keyNameUnicodeString,
                        0,
                        Type,
                        Data,
                        DataLength);
                            
    }
    
    return ntStatus;
}


NTSTATUS 
DBCACPI_GetRegistryParameters(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS, keyStatus;
    PDBC_SUBSYSTEM_DESCRIPTOR subsystemDescriptor;
    WCHAR guidFor1394Key[] = L"GuidFor1394";
    WCHAR bayCountKey[] = L"BayCount";
    ULONG bayCount = 0;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    subsystemDescriptor = 
        &deviceExtension->SubsystemDescriptor;
        
    //
    // see if we have a guid
    //
    keyStatus = DBCACPI_GetRegistryKeyValueForPdo(
            deviceExtension->PhysicalDeviceObject,
            guidFor1394Key,
            sizeof(guidFor1394Key),
            &subsystemDescriptor->guid1394Link[0],        
            8);

    if (NT_SUCCESS(keyStatus)){
        DBCACPI_KdPrint((0,"'**** Reading Reg Key for busted DBC BIOS\n"));  
        DBCACPI_KdPrint((0,"'**** key - 1394 Link GUID\n"));  
    }            

    keyStatus = DBCACPI_GetRegistryKeyValueForPdo(
            deviceExtension->PhysicalDeviceObject,
            bayCountKey,
            sizeof(bayCountKey),
            &bayCount,        
            sizeof(bayCount));

    if (NT_SUCCESS(keyStatus)) {
        subsystemDescriptor->bmAttributes.BayCount = bayCount;
        DBCACPI_KdPrint((0,"'**** Reading Reg Key for busted DBC BIOS\n"));  
        DBCACPI_KdPrint((0,"'**** key - Bay Count\n"));
    }
            
    
    return ntStatus;
}    


NTSTATUS 
DBCACPI_GetBayRegistryParameters(
    PDEVICE_OBJECT DeviceObject,
    USHORT BayNumber,
    PULONG PortUSBMap,
    PULONG Port1394Map
    )
/*++

Routine Description:

//#ifdef COMPAQ_TYPE4
        if (bayDescriptor->bBayNumber == 1) {
            bayDescriptor->bPHYPortNumber = 2;
            bayDescriptor->bHubPortNumber = 1;
        } else if (bayDescriptor->bBayNumber == 2) {
            bayDescriptor->bPHYPortNumber = 4;
            bayDescriptor->bHubPortNumber = 2;
        }
//#endif 
    
Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS, keyStatus;
    WCHAR portUSBMapKey[] = L"PORTUSBMAP00";
    WCHAR port1394MapKey[] = L"PORT1394MAP00";

    PAGED_CODE();

    portUSBMapKey[11] = '0' + BayNumber;
    port1394MapKey[12] = '0' + BayNumber;
    
    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    //
    // see if we have a guid
    //
    keyStatus = DBCACPI_GetRegistryKeyValueForPdo(
            deviceExtension->PhysicalDeviceObject,
            portUSBMapKey,
            sizeof(portUSBMapKey),
            PortUSBMap,        
            sizeof(*PortUSBMap));

    if (NT_SUCCESS(keyStatus)){
        DBCACPI_KdPrint((0,"'**** Reading Reg Key for busted DBC BIOS\n"));  
        DBCACPI_KdPrint((0,"'**** key - USB port map\n"));  
    }

    keyStatus = DBCACPI_GetRegistryKeyValueForPdo(
            deviceExtension->PhysicalDeviceObject,
            port1394MapKey,
            sizeof(port1394MapKey),
            Port1394Map,        
            sizeof(*Port1394Map));

    if (NT_SUCCESS(keyStatus)){
        DBCACPI_KdPrint((0,"'**** Reading Reg Key for busted DBC BIOS\n"));  
        DBCACPI_KdPrint((0,"'**** key - 1394 port map\n"));  
    }
    
    return ntStatus;
}    


VOID
DBCACPI_PollDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the device object.

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext; 
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;
    PDBCACPI_WORKITEM workItem;

    DBCACPI_KdPrint((1, "'DBC Notification Poll\n")); 

    // do we have a workitem scheduled?

    deviceExtension = fdoDeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    
    KeAcquireSpinLock(&deviceExtension->FlagsSpin, &oldIrql);
    
    if (deviceExtension->Flags & DBCACPI_FLAG_WORKITEM_PENDING) {
        // yes, bail
        KeReleaseSpinLock(&deviceExtension->FlagsSpin, oldIrql);
    } else {
        // no, schedule one
        DBCACPI_IncrementIoCount(fdoDeviceObject);
        
        workItem = &deviceExtension->WorkItem;
        deviceExtension->Flags |= DBCACPI_FLAG_WORKITEM_PENDING; 
        KeReleaseSpinLock(&deviceExtension->FlagsSpin, oldIrql);
        
        workItem->Sig = DBC_WORKITEM_SIG;
            
        ExInitializeWorkItem(&workItem->WorkQueueItem,
                             DBCACPI_NotifyWorker,
                             fdoDeviceObject);

        ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);
    }

    LOGENTRY(LOG_MISC, "Nop-", 0, 0, 0);
}


NTSTATUS 
DBCACPI_StartPolling(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{   
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;    
    LARGE_INTEGER dueTime;
    LONG period;

    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeTimer(&deviceExtension->PollTimer);
    KeInitializeDpc(&deviceExtension->PollDpc,
                    DBCACPI_PollDpc,
                    DeviceObject);

    dueTime.QuadPart =  -10000 * 32;
    period = 1000; //every 1000 ms

//    UHCD_KdPrint((2, "'UHCD Poll Interval = (0x%x) %x %x\n", 
//        endpoint->Interval, dueTime.LowPart, dueTime.HighPart));
       
    KeSetTimerEx(&deviceExtension->PollTimer,
                 dueTime,
                 period,
                 &deviceExtension->PollDpc);  

    return ntStatus;
}                     


NTSTATUS
DBCACPI_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBCACPI_KdPrint((2, "'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        // we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


NTSTATUS
DBCACPI_GetClassGlobalRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR dbc = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBCACPI_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = POLL_MODE_KEY;
    QueryTable[0].EntryContext = &DBCACPI_PollMode;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBCACPI_PollMode;
    QueryTable[0].DefaultLength = sizeof(DBCACPI_PollMode);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                dbc,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
    
        if (DBCACPI_PollMode) {
            DBCACPI_KdPrint((0, "'DBC Poll mode is ON\n"));
        } 
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbclass\usbhubf.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    USBHUBF.C

Abstract:

Environment:

    kernel mode only

Notes:


Revision History:

    

--*/


#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"   
#include "dbclass.h"
#include "dbfilter.h"   

#include "usbioctl.h"

//
// Registry keys
//

#define DBCLASS_HUB_IS_ACPI_DBC     0x00000001
#define DBCLASS_HUB_IS_USB_DBC      0x00000002

extern LONG DBCLASS_AcpiDBCHubParentPort;


NTSTATUS
DBCLASS_UsbhubQBusRelationsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PDEVICE_RELATIONS deviceRelations;
    ULONG i;
    PDEVICE_OBJECT busFilterMdo = Context;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT mdoUSB;
    PDBC_CONTEXT dbcContext;
    
    deviceExtension = busFilterMdo->DeviceExtension;
    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    LOGENTRY(LOG_MISC, 'UQBR', busFilterMdo, 0, deviceRelations);

    if (deviceRelations == NULL) {
         LOGENTRY(LOG_MISC, 'UQBn', busFilterMdo, 0, deviceRelations);
         return STATUS_SUCCESS;
    }

    // try to find the DBC controller associated with this hub
    // 
    // Since the filter is loaded for every hub we need to see 
    // if this hub is part of a DBC subsystem

    
    dbcContext = deviceExtension->DbcContext;

    if (dbcContext == NULL) {
        DBCLASS_KdPrint((1, "'>QBR USB,  HUB NOT DBC\n"));
        // no context means the hub is not part of DBC
        LOGENTRY(LOG_MISC, 'hQBi', 0, 0, 0);    
        return STATUS_SUCCESS;
    }

    for (i=0; i< deviceRelations->Count; i++) {

        DBCLASS_KdPrint((1, "'>QBR USB PDO[%d] %x\n", i, 
            deviceRelations->Objects[i]));
            
        LOGENTRY(LOG_MISC, 'QBRd', deviceRelations->Objects[i], i, 0);

        // hub is returning a PDO, see if we know 
        // about it
        
        mdoUSB = DBCLASS_FindDevicePdo(deviceRelations->Objects[i]);

        if (mdoUSB) {
            // we know about this one,
            // see if we can link it to a controller
            PDEVICE_EXTENSION mdoUSBDeviceExtension;
             
            mdoUSBDeviceExtension = mdoUSB->DeviceExtension;
            mdoUSBDeviceExtension->DbcContext = dbcContext;                                           
            
        } else {
            PDEVICE_OBJECT deviceFilterObject;
            NTSTATUS ntStatus;

            // don't know about it,
            // create an MDO for this device

            ntStatus = DBCLASS_CreateDeviceFilterObject(
                deviceExtension->DriverObject,
                &deviceFilterObject,
                deviceRelations->Objects[i],
                dbcContext,
                DB_FDO_USB_DEVICE);

            DBCLASS_KdPrint((1, "'>>QBR attaching to USB PDO[%d] %x\n", i, 
                deviceRelations->Objects[i]));                    
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(USB) Create DO %x for USB PDO\n", deviceFilterObject));   

        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DBCLASS_UsbhubBusFilterDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN Handled
    )
/*++

Routine Description:

   This is a call to the root hub PDO
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    ntStatus = Irp->IoStatus.Status;
    *Handled = FALSE;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    LOGENTRY(LOG_MISC, 'HBf>', 0, DeviceObject, Irp);
    DBCLASS_ASSERT(deviceExtension->FdoType == DB_FDO_USBHUB_BUS);
    
    DBCLASS_KdPrint((2, "'(dbfilter)(bus)(USB)IRP_MJ_ (%08X)  IRP_MN_ (%08X)\n",
        irpStack->MajorFunction, irpStack->MinorFunction));  

    switch (irpStack->MajorFunction) {

    case IRP_MJ_PNP:
        switch (irpStack->MinorFunction) {    
        case IRP_MN_START_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(USB)IRP_MN_START_DEVICE\n"));    
            break;
            
        case IRP_MN_STOP_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(USB)IRP_MN_STOP_DEVICE\n"));  
            break; 
            
        case IRP_MN_REMOVE_DEVICE:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(USB)IRP_MN_REMOVE_DEVICE\n"));    

            // detach from the usbhub FDO and delete our
            // MDO

            DBCLASS_RemoveBusFilterMDOFromList(DeviceObject);

            IoDetachDevice(deviceExtension->TopOfStackDeviceObject);

            IoDeleteDevice (DeviceObject);           
            DBCLASS_KdPrint((1, "'REMOVE DB Filter on USB HUB\n"));    
            
            break; 
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:            
            DBCLASS_KdPrint((1, "'(dbfilter)(bus)(USB)IRP_MN_QUERY_DEVICE_RELATIONS\n"));    

//#if DBG
//            DBCLASS_Get1394BayPortMapping(deviceExtension->DbcContext);
//#endif

            //
            // do the check for USB hubs that are part of a DBC
            // 

            //
            // Ask the hub if it has a DBC hanging on it
            //
            if (deviceExtension->DbcContext == NULL &&
                DBCLASS_IsHubPartOfUSB_DBC(DeviceObject)) {
                
                deviceExtension->DbcContext = 
                    DBCLASS_FindControllerUSB(deviceExtension->DriverObject,
                                              DeviceObject,
                                              deviceExtension->PhysicalDeviceObject);
            } 

            *Handled = TRUE;
            
            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

                DBCLASS_KdPrint((1,"'>>QBR USB BUS\n"));
                IoCopyCurrentIrpStackLocationToNext(Irp);

                // Set up a completion routine to handle marking the IRP.
                IoSetCompletionRoutine(Irp,
                                       DBCLASS_UsbhubQBusRelationsComplete,
                                       DeviceObject,
                                       TRUE,
                                       TRUE,
                                       TRUE);
            } else {
                IoSkipCurrentIrpStackLocation(Irp)
            }

            // Now Pass down the IRP

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

            break;            
        } /* irpStack->MinorFunction */
        break;
    } /* irpStack->MajorFunction */      

    LOGENTRY(LOG_MISC, 'HBf<', 0, DeviceObject, 0);
    
    return ntStatus;
}


ULONG
DBCLASS_IsHubPartOf_DBC(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This call reads a registry key that tells us if this usb hub is part 
    of a device bay controller
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    ULONG flags = 0;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();
    
    deviceExtension = DeviceObject->DeviceExtension;

    ntStatus = DBCLASS_GetRegistryKeyValueForPdo(
                                           deviceExtension->PhysicalDeviceObject,
                                           FALSE,
                                           IS_DEVICE_BAY_KEY,
                                           sizeof(IS_DEVICE_BAY_KEY),
                                           &flags,
                                           sizeof(flags));

    DBCLASS_KdPrint((2, "'GetRegistryKeyValueForPdo ntStatus = %x flags = %x\n",
        ntStatus, flags));
    
    return flags;
}


BOOLEAN
DBCLASS_IsHubPartOfACPI_DBC(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is a call to a usb hub PDO 
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN isDB;
    ULONG flags;

    // see if it is an acpiDBC, if so mark it in 
    // the registry
    if (DBCLASS_AcpiDBCHubParentPort != -1) {
        PDEVICE_EXTENSION deviceExtension;

        deviceExtension = DeviceObject->DeviceExtension;                
        
        DBCLASS_CheckForAcpiDeviceBayHubs(
                            deviceExtension->PhysicalDeviceObject,
                            (ULONG) DBCLASS_AcpiDBCHubParentPort);
    }      

    flags = DBCLASS_IsHubPartOf_DBC(DeviceObject);

    isDB = (BOOLEAN) flags & DBCLASS_HUB_IS_ACPI_DBC; 

#ifdef DBG
    if (isDB) {
        DBCLASS_KdPrint((1, "'*** USBHUB for ACPI DBC Found\n"));
        BRK_ON_TRAP();
    }     
#endif    

    return isDB;
}


BOOLEAN
DBCLASS_IsHubPartOfUSB_DBC(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is a call to a usb hub PDO 
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN isDB;
    ULONG flags;

    flags = DBCLASS_IsHubPartOf_DBC(DeviceObject);

    isDB = (BOOLEAN) flags & DBCLASS_HUB_IS_USB_DBC; 

#ifdef DBG
    if (isDB) {
        DBCLASS_KdPrint((1, "'USBHUB for USB DBC Found!\n"));
        BRK_ON_TRAP();
    }     
#endif    

    return isDB;
}


NTSTATUS
DBCLASS_GetHubDBCGuid(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR DbcGuid
    )
/*++

Routine Description:

   This is a call to the root hub PDO
    
Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();
    deviceExtension = DeviceObject->DeviceExtension;

    ntStatus = DBCLASS_GetRegistryKeyValueForPdo(
                                           deviceExtension->PhysicalDeviceObject,
                                           FALSE,
                                           DBC_GUID_KEY,
                                           sizeof(DBC_GUID_KEY),
                                           DbcGuid,
                                           8);

    DBCLASS_KdPrint((2, "'GetRegistryKeyValueForPdo ntStatus = %x \n",
        ntStatus));

#if DBG    
    DBCLASS_KdPrint((1, "'DBC GUID FOR HUB\n"));
    DBCLASS_KdPrintGuid(1, DbcGuid);
#endif    

    return ntStatus;
}


NTSTATUS 
DBCLASS_SyncGetUsbInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT *ParentDeviceObject,
    IN PDEVICE_OBJECT *RootHubPdo,
    IN PULONG PortNumber
    )
 /* ++
  * 
  * Routine Description:
  *
  * Arguments:
  * 
  * Return Value:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();

    //
    // issue a synchronous request to the Hub Pdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = ParentDeviceObject;
    nextStack->Parameters.Others.Argument2 = PortNumber;
    nextStack->Parameters.Others.Argument4 = RootHubPdo;
     
    ntStatus = IoCallDriver(DeviceObject, irp);

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    DBCLASS_KdPrint((0, "'>>USB-PDO-INFO((%08X))   Parent = (%08X) Port = %d status = %x\n",
        DeviceObject, *ParentDeviceObject, *PortNumber, ntStatus)); 

    return ntStatus;
}


USHORT
DBCLASS_GetBayForUSBPdo(
    PDBC_CONTEXT DbcContext,
    PDEVICE_OBJECT PdoUSB
    )
/*++

Routine Description:

    given a USB PDO figure out wich bay it is associated with
    
Arguments:

Return Value:

    zero if not a device bay PDO.

--*/
{
    USHORT bay = 0;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT parent = NULL, rootHubPdo = NULL;
    ULONG portNumber = 0xFFFFFFFF;

    PAGED_CODE();

    // find out what port this PDO is in
    ntStatus = DBCLASS_SyncGetUsbInfo(PdoUSB, 
                                      &parent, 
                                      &rootHubPdo,
                                      &portNumber);

    if (NT_SUCCESS(ntStatus)) {
    
        for (bay=1; bay <=NUMBER_OF_BAYS(DbcContext); bay++) {
            DBCLASS_KdPrint((2, "'bay[%d]-> port %d, hub (%08X)\n", 
                bay, 
                DbcContext->BayInformation[bay].UsbHubPort,
                DbcContext->BayInformation[bay].UsbHubPdo));    
            
            if (DbcContext->BayInformation[bay].UsbHubPort == portNumber 
                /*&&
                DbcContext->BayInformation[bay].UsbHubPdo == parent */) {

                break;
            }
        }

    }        
        
    if (!bay || bay > NUMBER_OF_BAYS(DbcContext)) {
        bay = 0;
        
        DBCLASS_KdPrint((2, "'No bay->port mapping for USB PDO\n"));              
    } 


    return bay;
}


NTSTATUS
DBCLASS_SetupUSB_DBC(
    PDBC_CONTEXT DbcContext
    )
/*++

Routine Description:

    given a USB DbcContext, write the appropriate keys
    to the registry
    
Arguments:

Return Value:

    NTSTATUS
    
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG flags = DBCLASS_HUB_IS_USB_DBC;
    PDEVICE_OBJECT parentHubPdo = NULL, rootHubPdo = NULL;
    ULONG portNumber;

    
    
    // get the parent hub info
    
    ntStatus = DBCLASS_SyncGetUsbInfo(
        DbcContext->ControllerPdo, 
        &parentHubPdo, 
        &rootHubPdo,
        &portNumber);
        

    // set the keys
    
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = DBCLASS_SetRegistryKeyValueForPdo(
                        parentHubPdo,
                        FALSE,
                        REG_DWORD,
                        IS_DEVICE_BAY_KEY,
                        sizeof(IS_DEVICE_BAY_KEY),
                        &flags,
                        sizeof(flags));    
    }                        
                    
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = DBCLASS_SetRegistryKeyValueForPdo(
                        parentHubPdo,
                        FALSE,
                        REG_BINARY,
                        DBC_GUID_KEY,
                        sizeof(DBC_GUID_KEY),
                        &DbcContext->SubsystemDescriptor.guid1394Link[0],
                        8);                      
    }                        
    
    return ntStatus;        
}


NTSTATUS
DBCLASS_CheckForAcpiDeviceBayHubs(
    PDEVICE_OBJECT HubPdo,
    ULONG AcpiDBCHubParentPort
    )
/*++

Routine Description:

    Check to see if this device object
    is for a hub that is part of an ACPI DBC
    
Arguments:

    AcpiDBCHubParentPort 
        0 = acpi hub is root otherwise upstream port on root 
            hub the ACPI hub is connected to


Return Value:

    NTSTATUS
    
--*/
{
    PDEVICE_OBJECT parentHubPdo = NULL, rootHubPdo = NULL;
    ULONG portNumber = 0;
    BOOLEAN writeKeys = FALSE;
    NTSTATUS ntStatus;

    // get the root hub PDO
    ntStatus = DBCLASS_SyncGetUsbInfo(
                HubPdo, 
                &parentHubPdo, 
                &rootHubPdo,
                &portNumber);

    // failure indicates this is root                
    if (!NT_SUCCESS(ntStatus)) {
        ntStatus = STATUS_SUCCESS;
        rootHubPdo = HubPdo;
    }

    if (NT_SUCCESS(ntStatus)) {
    
        DBCLASS_KdPrint((1, "'>**Check Hub:  RHPDO = %x, parentPDO %x, port %d\n",
            rootHubPdo,
            parentHubPdo, 
            portNumber));  
            
        // is this the root hub?
        if (HubPdo == rootHubPdo) {
            // Yes
            if (AcpiDBCHubParentPort == 0) {
                // root hub is acpi hub
                writeKeys = TRUE;
            }
            
        } else {        
            // is the parent the root hub?
            if (parentHubPdo == rootHubPdo) {
                // Yes 
                if (AcpiDBCHubParentPort == portNumber) {
                    // root hub ius acpi hub
                    writeKeys = TRUE;
                }    
            }
        }
    }
    
    if (writeKeys) {
        ULONG flags;

        flags = DBCLASS_HUB_IS_ACPI_DBC;
        
        DBCLASS_SetRegistryKeyValueForPdo(
                        HubPdo,
                        FALSE,
                        REG_DWORD,
                        IS_DEVICE_BAY_KEY,
                        sizeof(IS_DEVICE_BAY_KEY),
                        &flags,
                        sizeof(flags));    
                    
    
//        DBCLASS_SetRegistryKeyValueForPdo(
//                        HubPdo,
//                        FALSE,
//                        REG_BINARY,
//                        DBC_GUID_KEY,
//                        sizeof(DBC_GUID_KEY),
//                        &DbcContext->SubsystemDescriptor.guid1394Link[0],
//                        8);                      
    }        

    return ntStatus;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcacpi\core.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    CORE.C

Abstract:

    This module contains core code for the ACPI
    Device Bay Controller 

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    05-13-98 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbci.h"
#include "dbcacpi.h"

#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, )
#endif


VOID
SetBit(
    PVOID Bitmap,
    ULONG BitNumber
    )
 /* ++
  *
  * Description:
  *
  * Set a bit in a given a string of bytes.
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PULONG l = (PULONG) Bitmap;


    dwordOffset = BitNumber / 32;
    bitOffset = BitNumber % 32;

    l[dwordOffset] |= (1 << bitOffset);
}


NTSTATUS
DBCACPI_GetBayStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BayNumber
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BSTR_REGISTER baystr;
    
    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
     
    ntStatus = 
        DBCACPI_READ_REG_ULONG(DeviceObject,
                               // skip BSTR & BCER
                               ACPI_DBC_BSTR0+(BayNumber)*8,
                               &baystr);                       

    // dump info about this bay
    DBCACPI_KdPrint((2,"'BAYSTR[%d] 0x%x\n", BayNumber, baystr.ul));
    DBCACPI_KdPrint((2,"'>BAY_FF 0x%x\n", baystr.BayFormFactor));
    DBCACPI_KdPrint((2,"'>SL_STS 0x%x\n", baystr.SecurityLockEngaged));
    DBCACPI_KdPrint((2,"'>BAY_ST 0x%x\n", baystr.CurrentBayState));
    DBCACPI_KdPrint((2,"'>REMREQ_STS 0x%x\n", baystr.RemovalRequested));
    DBCACPI_KdPrint((2,"'>DEVSTCHG 0x%x\n", baystr.DeviceStateChange));
    DBCACPI_KdPrint((2,"'>1394PRSN_STS 0x%x\n", baystr.Device1394IsPresent));
    DBCACPI_KdPrint((2,"'>USBPRSN_STS 0x%x\n", baystr.DeviceUsbIsPresent));
    
    return ntStatus;
}


NTSTATUS
DBCACPI_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a driver.

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();
    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    // Un-Register with ACPI
    if (deviceExtension->Flags & DBCACPI_FLAG_ACPIREG) {
        ntStatus = DBCACPI_RegisterWithACPI(DeviceObject, FALSE);
        deviceExtension->Flags |= ~DBCACPI_FLAG_ACPIREG;
    }        

    deviceExtension->Flags |= DBCACPI_FLAG_STOPPED;

    return ntStatus;
}


NTSTATUS
DBCACPI_StartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT vendorId;
    UCHAR revisionId;
    ULONG i;
    PDBC_SUBSYSTEM_DESCRIPTOR subsystemDescriptor;

    PAGED_CODE();


    DBCACPI_KdPrint((1,"'Starting DBC driver\n"));
    LOGENTRY(LOG_MISC, "Ihw>", 0, 0, DeviceObject);  
    
    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    subsystemDescriptor = &deviceExtension->SubsystemDescriptor;
    RtlZeroMemory(subsystemDescriptor, sizeof(*subsystemDescriptor));  
     
    KeInitializeEvent(&deviceExtension->RemoveEvent, NotificationEvent, FALSE);
    
    // Register with ACPI
    ntStatus = DBCACPI_RegisterWithACPI(DeviceObject, TRUE);

    if (NT_SUCCESS(ntStatus)) {
        ULONG release_on_shutdown;
    
        deviceExtension->Flags |= DBCACPI_FLAG_ACPIREG;
         
        ntStatus = 
            DBCACPI_READ_REG_USHORT(DeviceObject,
                                    ACPI_DBC_VENDOR_ID,
                                    &vendorId);

        ntStatus = 
            DBCACPI_READ_REG_UCHAR(DeviceObject,
                                   ACPI_DBC_REVISION_ID,
                                   &revisionId);                                

        // subsystem attributes map directly to the DBCCR register
        ntStatus = 
            DBCACPI_READ_REG_UCHAR(DeviceObject,
                                   ACPI_DBC_DBCCR,
                                   &subsystemDescriptor->bmAttributes);                                      

        subsystemDescriptor->bLength = sizeof(*subsystemDescriptor);
        subsystemDescriptor->bDescriptorType = DBC_SUSBSYSTEM_DESCRIPTOR_TYPE;

        RtlFillMemory(&subsystemDescriptor->guid1394Link[0], 8, 0x01);  

        // attempt to get the guid from the BIOS,
        // ignore any errors
        DBCACPI_ReadGuidRegister(DeviceObject,
                                 &subsystemDescriptor->guid1394Link[0],
                                 4,
                                 0);

        DBCACPI_ReadGuidRegister(DeviceObject,
                                 &subsystemDescriptor->guid1394Link[4],
                                 4,
                                 1);                         
                                                        
        
        // fixup or override subsystem descriptor based on registry parms
        
        ntStatus = DBCACPI_GetRegistryParameters(DeviceObject);

        // see if BIOS wants to set unlock_on_shutdown
        // behavior
        if (DBCACPI_ReadBayReleaseRegister(DeviceObject,
                                           &release_on_shutdown) == 
                                           STATUS_SUCCESS) { 
                                           
            DBCACPI_SetRegistryKeyValueForPdo(deviceExtension->PhysicalDeviceObject,
                                              TRUE,
                                              REG_DWORD,
                                              RELEASE_ON_SHUTDOWN,
                                              sizeof(RELEASE_ON_SHUTDOWN),
                                              &release_on_shutdown,
                                              sizeof(release_on_shutdown));
        }
    } 

    deviceExtension->BayCount = (UCHAR) subsystemDescriptor->bmAttributes.BayCount;

    // fail the start if we have no bays
    if (deviceExtension->BayCount == 0) {
        DBCACPI_KdPrint((0,"'***** Controller has bad bay count\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    // validate guid
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = STATUS_UNSUCCESSFUL;
        for (i=0; i< 8; i++) {
            if (subsystemDescriptor->guid1394Link[i] != 0x01) {
                ntStatus = STATUS_SUCCESS;
                break;
            }
        }            
    }                
    
    for (i=0; i< deviceExtension->BayCount; i++) {
        deviceExtension->BayState[i] = 0;            
    }
    
    // dump info about this controller
    DBCACPI_KdPrint((1,"'VID 0x%x REV 0x%x\n", vendorId, revisionId));
    LOGENTRY(LOG_MISC, "Ihw>", deviceExtension->BayCount, subsystemDescriptor, ntStatus);  

    if (NT_SUCCESS(ntStatus)) {
        deviceExtension->Flags |= DBCACPI_FLAG_STARTED; 
    } 
#if DBG    
      else {               
        DBCACPI_KdPrint((0,"'***** FAILING START\n"));
    }        
#endif

    return ntStatus;
}


VOID
DBCACPI_CancelChangeRequestIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is called to cancel a change request irp .

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    NT status code.
    
--*/
{
    
//    PDRB drb;
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;
     
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
    deviceExtension->ChangeRequestIrp = NULL;        
    KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;

    DBCACPI_DecrementIoCount(DeviceObject);
    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT);
}


NTSTATUS
DBCACPI_ProcessDrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp 
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDRB drb;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    USHORT function;
    KIRQL oldIrql, irql;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
     
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    drb = ioStackLocation->Parameters.Others.Argument1;

    function = drb->DrbHeader.Function;

    switch (function) {
    case DRB_FUNCTION_CHANGE_REQUEST:
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_CHANGE_REQUEST\n"));
        //
        //  Queue the change request, only one can be pending at a time.
        //
        KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
        
        if (deviceExtension->ChangeRequestIrp) {
            KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
            ntStatus = STATUS_DEVICE_BUSY;
        } else {

            deviceExtension->ChangeRequestIrp = Irp;
            KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
            
            //
            // set up a cancel routine
            //

            IoAcquireCancelSpinLock(&irql);
            if (Irp->Cancel) {
                TEST_TRAP();
                // Irp was canceled
                IoReleaseCancelSpinLock(irql);

                // call cancel routine
                DBCACPI_CancelChangeRequestIrp(DeviceObject, Irp);
                
            } else {
                IoSetCancelRoutine(Irp, DBCACPI_CancelChangeRequestIrp);
                IoReleaseCancelSpinLock(irql);
            }
            ntStatus = STATUS_PENDING;

            // we have a request in the queue, now check for 
            // a status change
            DBCACPI_CheckForStatusChange(DeviceObject);
        }
        break;
        
    case DRB_FUNCTION_GET_SUBSYSTEM_DESCRIPTOR :
        {
        PDBC_SUBSYSTEM_DESCRIPTOR subsystemDescriptor;
        
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_GET_SUBSYSTEM_DESCRIPTOR\n"));

        subsystemDescriptor = 
            &drb->DrbGetSubsystemDescriptor.SubsystemDescriptor;
            
        RtlCopyMemory(subsystemDescriptor,
                      &deviceExtension->SubsystemDescriptor,
                      sizeof(DBC_SUBSYSTEM_DESCRIPTOR));  
        }                                   
        break;    
        
    case DRB_FUNCTION_GET_BAY_DESCRIPTOR :
        {
        PDBC_BAY_DESCRIPTOR bayDescriptor;
        USHORT n;
        BSTR_REGISTER bstr;
        ULONG portUSBMap;
        ULONG port1394Map;
        ULONG acpiHubPort;
        
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_GET_BAY_DESCRIPTOR\n"));

        bayDescriptor = 
            &drb->DrbGetBayDescriptor.BayDescriptor;

        bayDescriptor->bLength = sizeof(*bayDescriptor);
        bayDescriptor->bDescriptorType = DBC_BAY_DESCRIPTOR_TYPE;             

        DBCACPI_ASSERT(drb->DrbGetBayStatus.BayNumber>0);
        n = drb->DrbGetBayStatus.BayNumber-1;

        bayDescriptor->bBayNumber = (UCHAR) drb->DrbGetBayStatus.BayNumber;
         
        DBCACPI_READ_REG_ULONG(DeviceObject,
                               ACPI_DBC_BSTR0+(n*8),
                               &bstr);   

        bayDescriptor->bFormFactor = (UCHAR) bstr.BayFormFactor;

        //
        // fetch bay/port maps from ACPI control methods here
        //        

        DBCACPI_ReadBayMapRegister(DeviceObject,
                                   TRUE,
                                   &portUSBMap,
                                   sizeof(portUSBMap),
                                   drb->DrbGetBayStatus.BayNumber);

        // the upstream port for the acpi hub is in the
        // high word
        acpiHubPort = portUSBMap & 0xFFFF0000;    
        acpiHubPort >>= 16;

        // mask off the upstream port info
        portUSBMap = portUSBMap & 0x0000FFFF;

        DBCACPI_KdPrint((1,"'USB upstrm port = %d\n", acpiHubPort));
        DBCACPI_KdPrint((1,"'USB port map = %d\n", portUSBMap));

        
        // mask off the USB upstream port                                   

        DBCACPI_ReadBayMapRegister(DeviceObject,
                                   FALSE,
                                   &port1394Map,
                                   sizeof(port1394Map),
                                   drb->DrbGetBayStatus.BayNumber);                                   

        DBCACPI_GetBayRegistryParameters(DeviceObject,
                                         drb->DrbGetBayStatus.BayNumber,
                                         &portUSBMap,
                                         &port1394Map);

                                        
        DBCACPI_SetRegistryKeyValueForPdo(deviceExtension->PhysicalDeviceObject,
                                          FALSE,
                                          REG_DWORD,
                                          ACPI_HUB_KEY,
                                          sizeof(ACPI_HUB_KEY),
                                          &acpiHubPort,
                                          sizeof(acpiHubPort));                                         
//TEST_TRAP();
//if (drb->DrbGetBayStatus.BayNumber == 1) {
//   port1394Map = 2; 
//}
//if (drb->DrbGetBayStatus.BayNumber == 2) {
//   port1394Map = 3; 
//}
                                         
        bayDescriptor->bPHYPortNumber = (UCHAR) port1394Map;
        bayDescriptor->bHubPortNumber = (UCHAR) portUSBMap;
        
        }
        break;    
    case DRB_FUNCTION_SET_BAY_FEATURE :
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_SET_BAY_FEATURE\n"));

        DBCACPI_SetFeature(DeviceObject,
                           drb->DrbBayFeatureRequest.BayNumber,
                           drb->DrbBayFeatureRequest.FeatureSelector);

        break;    
    case DRB_FUNCTION_GET_BAY_STATUS :
        {
        USHORT n;            
        BSTR_REGISTER bstr;
        BCER_REGISTER bcer;
        
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_GET_BAY_STATUS (%d)\n",
            drb->DrbGetBayStatus.BayNumber));

        DBCACPI_ASSERT(drb->DrbGetBayStatus.BayNumber>0);
        n = drb->DrbGetBayStatus.BayNumber-1;
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BSTR0+(n*8),
                                   &bstr);         
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = 
                DBCACPI_READ_REG_ULONG(DeviceObject,
                                       ACPI_DBC_BCER0+(n*8),
                                       &bcer);        
        }

        if (NT_SUCCESS(ntStatus)) {
            // now create the status bitmap
            drb->DrbGetBayStatus.BayStatus.VidEnabled = 
                bcer.EnableVid;
            drb->DrbGetBayStatus.BayStatus.RemovalWakeupEnabled = 
                bcer.RemovalEventEnable;    
            drb->DrbGetBayStatus.BayStatus.DeviceStatusChangeEnabled = 
                bcer.DeviceStatusChangeEnable;
            drb->DrbGetBayStatus.BayStatus.RemovalRequestEnabled = 
                bcer.RemovalRequestEnable;
            drb->DrbGetBayStatus.BayStatus.LastBayStateRequested = 
                bcer.BayStateRequested;
            drb->DrbGetBayStatus.BayStatus.InterlockEngaged  = 
                bcer.LockEngage;
            drb->DrbGetBayStatus.BayStatus.DeviceUsbIsPresent = 
                bstr.DeviceUsbIsPresent;
            drb->DrbGetBayStatus.BayStatus.Device1394IsPresent = 
                bstr.Device1394IsPresent;
            drb->DrbGetBayStatus.BayStatus.DeviceStatusChange = 
                bstr.DeviceStateChange;
            drb->DrbGetBayStatus.BayStatus.RemovalRequestChange = 
                bstr.RemovalRequested;
            drb->DrbGetBayStatus.BayStatus.CurrentBayState = 
                bstr.CurrentBayState;
            drb->DrbGetBayStatus.BayStatus.SecurityLockEngaged = 
                bstr.SecurityLockEngaged;
        }
        
        DBCACPI_KdPrint((2,"'BSTR = (0x%x)\n",
            drb->DrbGetBayStatus.BayStatus));
                                           
        }
        break;    
    case DRB_FUNCTION_CLEAR_BAY_FEATURE :
        DBCACPI_KdPrint((2,"'DRB_FUNCTION_CLEAR_BAY_FEATURE\n"));

        DBCACPI_ClearFeature(DeviceObject,
                           drb->DrbBayFeatureRequest.BayNumber,
                           drb->DrbBayFeatureRequest.FeatureSelector);
        break;            

    case DRB_FUNCTION_START_DEVICE_IN_BAY:        
    
        DBCACPI_KdPrint((1,"'OK to Start Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;

    case DRB_FUNCTION_STOP_DEVICE_IN_BAY:        
    
        DBCACPI_KdPrint((1,"'OK to Stop Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;   

    case DRB_FUNCTION_EJECT_DEVICE_IN_BAY:        
    
        DBCACPI_KdPrint((1,"'OK to Eject Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;        
        
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCACPI_KdPrint((0,"'Invalid DRB function (0x%x)\n", function));
        TRAP();
    }

    DBCACPI_KdPrint((2,"' DBCACPI_ProcessDrb(0x%x)\n", ntStatus));
    return ntStatus;
}


NTSTATUS
DBCACPI_SetFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BCER_REGISTER bcer;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    DBCACPI_ASSERT(BayNumber>0);

	bcer.ul = 0;

    // make zero based
    BayNumber--;

    switch (FeatureSelector) {
    case DEVICE_STATUS_CHANGE_ENABLE:
        DBCACPI_KdPrint((2,"'DEVICE_STATUS_CHANGE_ENABLE\n"));
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
                                   
        bcer.DeviceStatusChangeEnable = 1;
        ntStatus = 
            DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer);     
        break;
        
    case ENABLE_VID_POWER:
        DBCACPI_KdPrint((2,"'ENABLE_VID_POWER\n"));
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer); 
                                    
        DBCACPI_KdPrint((2,"' bcer = %x\n", bcer));                                           
        bcer.EnableVid = 1;
        
        ntStatus = 
            DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer);                 
        break;
        
    case LOCK_CTL:
        DBCACPI_KdPrint((2,"'LOCK_CTL(set)\n"));
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
                                    
        DBCACPI_KdPrint((2,"' bcer = %x\n", bcer));                                           
        bcer.LockEngage = 1;
        
        ntStatus = 
            DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer);     
        break;
        
    case REMOVAL_EVENT_WAKE_ENABLE:
        TEST_TRAP();
        break;
        
    case REQUEST_DEVICE_ENABLED_STATE:       
        DBCACPI_KdPrint((2,"'REQUEST_DEVICE_ENABLED_STATE\n"));
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
        if (NT_SUCCESS(ntStatus)) {                                   
            bcer.BayStateRequested = BAY_STATE_DEVICE_ENABLED;                                  
            

            ntStatus = 
                DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                        ACPI_DBC_BCER0+(BayNumber*8),
                                        &bcer);   
        }                                        
        break;
        
    case REMOVAL_REQUEST_ENABLE:
        DBCACPI_KdPrint((2,"'REMOVAL_REQUEST_ENABLE\n"));
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
                                   
        bcer.RemovalRequestEnable = 1;
        ntStatus = 
            DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer);     
        break;
        
    case REQUEST_REMOVAL_ALLOWED_STATE:
    
        DBCACPI_KdPrint((2,"'REQUEST_REMOVAL_ALLOWED_STATE\n"));
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
        if (NT_SUCCESS(ntStatus)) {                                   
            bcer.BayStateRequested = BAY_STATE_DEVICE_REMOVAL_ALLOWED;                                  

            ntStatus = 
                DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                        ACPI_DBC_BCER0+(BayNumber*8),
                                        &bcer);   
        }                                        
        break;

    case REQUEST_DEVICE_INSERTED_STATE:
    
        DBCACPI_KdPrint((2,"'REQUEST_DEVICE_INSERTED_STATE\n"));
        
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
        if (NT_SUCCESS(ntStatus)) {                                   
            bcer.BayStateRequested = BAY_STATE_DEVICE_INSERTED;                                  

            ntStatus = 
                DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                        ACPI_DBC_BCER0+(BayNumber*8),
                                        &bcer);   
        }         
        break;
        
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCACPI_KdPrint((0,"'Invalid feature selector (0x%x)\n", FeatureSelector));
        TRAP();
    }

    return ntStatus;
}


NTSTATUS
DBCACPI_ClearFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BCER_REGISTER bcer;
//    BSTR_REGISTER bstr;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    DBCACPI_ASSERT(BayNumber>0);

	bcer.ul = 0;

    // make zero based
    BayNumber--;

    switch (FeatureSelector) {
    case C_DEVICE_STATUS_CHANGE:
        DBCACPI_KdPrint((2,"'C_DEVICE_STATUS_CHANGE\n"));
        break;
        
    case C_REMOVE_REQUEST:
        DBCACPI_KdPrint((2,"'C_REMOVE_REQUEST\n"));
        break;
        
    case LOCK_CTL:
        DBCACPI_KdPrint((2,"'LOCK_CTL(clear)\n"));
        ntStatus = 
            DBCACPI_READ_REG_ULONG(DeviceObject,
                                   ACPI_DBC_BCER0+(BayNumber*8),
                                   &bcer); 
                                    
        DBCACPI_KdPrint((2,"' bcer = %x\n", bcer));                                           
        bcer.LockEngage = 0;
        
        ntStatus = 
            DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                    ACPI_DBC_BCER0+(BayNumber*8),
                                    &bcer);     
        break;        

    case ENABLE_VID_POWER:
        DBCACPI_KdPrint((2,"'ENABLE_VID_POWER\n"));
        break;
        
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCACPI_KdPrint((0,"'Invalid feature selector (0x%x)\n", FeatureSelector));
        TRAP();
    }

    return ntStatus;
}



VOID
DBCACPI_CompleteChangeRequest(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRP irp;
    KIRQL oldIrql;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);

    KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
    
    if (deviceExtension->ChangeRequestIrp) {
        irp = deviceExtension->ChangeRequestIrp;
        deviceExtension->ChangeRequestIrp = NULL;
        KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
        
        // now complete the irp        

        TEST_TRAP();
    }            

}        


NTSTATUS
DBCACPI_CheckForStatusChange(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BSTR_REGISTER bstr;
    ULONG n;
    KIRQL oldIrql;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCACPI_ASSERT_EXT(deviceExtension);
    LOGENTRY(LOG_MISC, "STck", 0, 0, deviceExtension->BayCount);  

    DBCACPI_KdPrint((1,"'-->check for changes\n"));
    for (n=0; n<deviceExtension->BayCount; n++) {
        // find the first bay that changed and indicated this
        // to the class driver
        ntStatus = 
                DBCACPI_READ_REG_ULONG(DeviceObject,
                                       ACPI_DBC_BSTR0+(n*8),
                                       &bstr); 

        LOGENTRY(LOG_MISC, "cBAY", ntStatus, n, bstr.ul);                                         
        
        if (NT_SUCCESS(ntStatus)) {                                       
            BOOLEAN change;
            
            DBCACPI_KdPrint((2,"'n= %d bstr = 0x%x\n", n, bstr));          

            // see if the bay change bits are set
            
            if (bstr.RemovalRequested == 1 ||
                bstr.DeviceStateChange == 1) {

                // we should never see these set
                DBCACPI_KdPrint((0,"'WARNING: possible BIOS bug, status change bits are set\n"));

                // clear the condition
                
                DBCACPI_WRITE_REG_ULONG(DeviceObject,
                                       ACPI_DBC_BSTR0+(n*8),
                                       &bstr);         
            }                

            LOGENTRY(LOG_MISC, "chkB", 0, bstr.CurrentBayState, deviceExtension->BayState[n]);      

            // compare the current state to the last state
            change = bstr.CurrentBayState != deviceExtension->BayState[n];
            
            DBCACPI_KdPrint((1,"--> check (%d) (%d)\n", bstr.CurrentBayState, deviceExtension->BayState[n]));          

            if (change) {
            
                // do we have a change irp pending?
                KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
        
                if (deviceExtension->ChangeRequestIrp) {

                    PDRB drb;
                    PIO_STACK_LOCATION ioStackLocation;    // our stack location
                    PIRP irp;
                    KIRQL irql;

                    // change indicated, update our current state
                    deviceExtension->BayState[n] = (UCHAR)
                        bstr.CurrentBayState;                        
                        
                    irp = deviceExtension->ChangeRequestIrp;
                    LOGENTRY(LOG_MISC, "cIRP", irp, 0, 0);  
                    deviceExtension->ChangeRequestIrp = NULL;
                    
                    KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);

                    // now check for cancel       
                    IoAcquireCancelSpinLock(&irql);
                    if (irp->Cancel) {
                        TEST_TRAP();
                        //Irp was canceled
                        IoReleaseCancelSpinLock(irql);
                    } else {
                        IoSetCancelRoutine(irp, NULL);
                        IoReleaseCancelSpinLock(irql);
                    
                        ioStackLocation = IoGetCurrentIrpStackLocation(irp);
                        drb = ioStackLocation->Parameters.Others.Argument1;

                        
                        SetBit(&drb->DrbChangeRequest.BayChange, n+1);
                        irp->IoStatus.Status = STATUS_SUCCESS;
                        DBCACPI_DecrementIoCount(DeviceObject);

                        LOGENTRY(LOG_MISC, "bCHG", drb, n, bstr.ul);  
                        DBCACPI_KdPrint((0,"'-->Indicate change on bay index [%d] BSTR(%x)\n", n, bstr));                               
                        IoCompleteRequest (irp,
                                           IO_NO_INCREMENT);
                    }                                           
                    
                } else {
                    // no irp available to notify 

                    LOGENTRY(LOG_MISC, "nIRP", 0, 0, 0);  
                    KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
                }              

                return ntStatus;
            }                
        }            
    }                               

    DBCACPI_KdPrint((1,"'-->No changes detected\n"));
                                    
    return ntStatus;
}    


VOID
DBCACPI_NotifyWorker(
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_OBJECT fdoDeviceObject = Context;
    PDEVICE_EXTENSION deviceExtension;
    KIRQL oldIrql;
    
    fdoDeviceObject = Context;
    deviceExtension = fdoDeviceObject->DeviceExtension;
    LOGENTRY(LOG_MISC, "cWK+", 0, Context, 0);
    
    DBCACPI_CheckForStatusChange(fdoDeviceObject);

    KeAcquireSpinLock(&deviceExtension->FlagsSpin, &oldIrql);
    DBCACPI_ASSERT(deviceExtension->Flags & DBCACPI_FLAG_WORKITEM_PENDING);
    deviceExtension->Flags &= ~DBCACPI_FLAG_WORKITEM_PENDING;
    KeReleaseSpinLock(&deviceExtension->FlagsSpin, oldIrql);

    LOGENTRY(LOG_MISC, "cWK-", 0, Context, 0);

    DBCACPI_DecrementIoCount(fdoDeviceObject);

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbfilter\dbfilter.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBFILTER.C

Abstract:

    This module implements the code to act as a filter 
    driver.

    The DB filter driver functions as several types of 
    filters.

    It is a upper filter sittiing above the FDO for the 
    USB hub and 1394 controller associated with a device
    bay subsystem.

        DB FDO - fdo owned by dbclass.sys
            |
        HUB FDO - fdo owned by usbhub.sys
            |
        HUB PDO - pdo enumerated by hub the device bay is part of

    It is also a filter sitting above the PDOs for devices of USB
    or 1394 that are in the bays

        
        USB/1394 DEVICE FDO - fdo owned USB/1394 device driver
            |
        DB FILTER FDO  - fdo owned by dbclass.sys
            |
        USB/1394 PDO - Pdo enumerated by the native bus 
                        owned by usbhub.sys or 1394bus.sys

    
Environment:

    kernel mode only

Notes:


Revision History:

    

--*/

#include "wdmwarn4.h"

#include <wdm.h>
#include <initguid.h>  
#include <wdmguid.h>  
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"  
#include "dbclib.h"  
#include "dbf.h"     

#define PDBC_CONTEXT PVOID

#include "dbfilter.h"       


VOID
DBF_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
}


NTSTATUS
DBF_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
DBF_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called when we are loaded as a filter for a USB 
    hub associated with a DBC or the as a global filter for the 1394
    bus.
    
Arguments:

    DriverObject - pointer to the driver object for this instance of UHCD

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject = NULL, stackTopDO;
    PDEVICE_EXTENSION deviceExtension;

#if DBG
    DBF_GetClassGlobalDebugRegistryParameters();
#endif

    ntStatus = DBF_CreateDeviceObject(DriverObject,
                                      &deviceObject);

    if (NT_SUCCESS(ntStatus)) {

        deviceExtension = deviceObject->DeviceExtension;

        deviceExtension->DriverObject = DriverObject; 
        deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

        // attach to the FDO for the HUB, ie we are an upper filter

        stackTopDO = 
        deviceExtension->TopOfStackDeviceObject =
                IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);


        // now that we have a device object we need to figure
        // out what bus we are on, query the bus ID to figure 
        // this out

        deviceExtension->FdoType = DB_FDO_BUS_UNKNOWN;

        //
        // Indicate that the device object is ready for requests.
        //

        //
        // Duplicate the buffering and alignment strategy
        //
        if(stackTopDO)
        {
            deviceObject->AlignmentRequirement = stackTopDO->AlignmentRequirement;
            deviceObject->Flags = stackTopDO->Flags;
        }

        
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        // register this filter with the correct DBC
        DBCLASS_RegisterBusFilter(DBCLASS_VERSION, DriverObject, deviceObject);        
    }

    return ntStatus;
}


NTSTATUS
DBF_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the DBC
    bus filter.

Arguments:

    DriverObject - pointer to the driver object for USBD.

    *DeviceObject - ptr to DeviceObject ptr to be filled
                    in with the device object we create.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    ntStatus = IoCreateDevice(DriverObject,
                              sizeof (DEVICE_EXTENSION),
                              NULL,// DeviceNameUnicodeString,
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE, //NOT Exclusive
                              DeviceObject);

    if (!NT_SUCCESS(ntStatus) && *DeviceObject) {
        IoDeleteDevice(*DeviceObject);
    }

    return ntStatus;
}

/* 
    We just call in to DBCLASS which has the code to hadnle 
    filtering the various types for Device Objects
*/   

NTSTATUS
DBF_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Device bay Filter FDO 

Return Value:

    NTSTATUS

--*/
{
    return DBCLASS_FilterDispatch(DeviceObject, Irp);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;

    DBF_KdPrint((2, "'DriverEntry\n"));

    //
    // Create dispatch points for device control, create, close.
    //

    for (i=0; i<= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DBF_Dispatch;
    }        
    
    DriverObject->DriverExtension->AddDevice = DBF_AddDevice;

    DriverObject->DriverUnload = DBF_Unload;

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\inc\dbfilter.h ===
/*++

Copyright (c) 1998      Microsoft Corporation

Module Name:

        DBFILTER.H

Abstract:

   common structures for DBC port drivers.

Environment:

    Kernel & user mode

Revision History:

    04-13-98 : created

--*/

#ifndef   __DBFILTER_H__
#define   __DBFILTER_H__

typedef struct _DBC_EJECT_TIMEOUT_CONTEXT {

    PDBC_CONTEXT    DbcContext;
    
    KTIMER TimeoutTimer;
    KDPC TimeoutDpc;

    USHORT BayNumber;

} DBC_EJECT_TIMEOUT_CONTEXT, *PDBC_EJECT_TIMEOUT_CONTEXT;


typedef struct _DEVICE_EXTENSION {

    ULONG FdoType;
    
    ULONG Flags;

    USHORT Bay;
    USHORT Pad;

    PDRIVER_OBJECT DriverObject;
    // device object we need to talk to the controller
    // ie pth DB port driver.
    
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // context of our controller
    PDBC_CONTEXT    DbcContext;

    PDBC_EJECT_TIMEOUT_CONTEXT TimeoutContext;

    KEVENT QBusRelations1394Event;

    BOOLEAN QBusRelations1394Success;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// values for DbfFlags
//


//#define DBFFLAG_USB_  

#define DB_FDO_BUS_IGNORE             0x00000000
#define DB_FDO_BUS_UNKNOWN            0xffffffff 
#define DB_FDO_USB_DEVICE             0xabadbab4
#define DB_FDO_USBHUB_BUS             0xababbab3
#define DB_FDO_1394_BUS               0xabadbab2
#define DB_FDO_1394_DEVICE            0xabadbab1




#endif /*  __DBFILTER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcacpi\dbcacpi.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dbcacpi.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-4-98 : created

--*/

#include "dbc100.h"

// "dbc" class global registry Keys
// these are found in HKLM\CCS\Services\Class\DBC
#define DEBUG_LEVEL_KEY                 L"debuglevel"
#define DEBUG_WIN9X_KEY                 L"debugWin9x"
#define POLL_MODE_KEY                   L"pollacpidbc"

// SW branch keys
#define RELEASE_ON_SHUTDOWN              L"releaseshutdown"

// HW branch keys
#define ACPI_HUB_KEY                    L"acpiHubParentPort"

#define DBCACPI_EXT_SIG     0x41434244     //"DBCA"

/* definitions from DBC core spec */

typedef union _DBCCR_REGISTER {
    ULONG       ul;
    struct {
        unsigned    BayCount:4;            /* 0 ..3 */
        unsigned    HasSecurityLock:1;     /* 4 */
        unsigned    Reserved:27;           /* 5..31 */
    };                
} DBCCR_REGISTER, *PDBCCR_REGISTER;

typedef union _BSTR_REGISTER {
    ULONG       ul;
    struct {
        unsigned    DeviceUsbIsPresent:1;  /* 0 */
        unsigned    Device1394IsPresent:1; /* 1 */
        unsigned    DeviceStateChange:1;   /* 2 */
        unsigned    RemovalRequested:1;    /* 3 */
        unsigned    CurrentBayState:3;     /* 4..6 */ 
        unsigned    SecurityLockEngaged:1; /* 7 */   
        unsigned    BayFormFactor:3;       /* 8..10 */   
        unsigned    Reserved:21;           /* 11..31 */
    };                
} BSTR_REGISTER, *PBSTR_REGISTER;

typedef union _BCER_REGISTER {
    ULONG       ul;
    struct {
        unsigned    EnableVid:1;                    /* 0 */
        unsigned    RemovalEventEnable:1;           /* 1 */
        unsigned    DeviceStatusChangeEnable:1;     /* 2 */
        unsigned    RemovalRequestEnable:1;         /* 3 */
        unsigned    BayStateRequested:3;            /* 4..6 */ 
        unsigned    LockEngage:1;                   /* 7 */   
        unsigned    Reserved:24;                    /* 8..31 */
    };                
} BCER_REGISTER, *PBCER_REGISTER;

typedef struct _DBCACPI_WORKITEM {

    ULONG Sig;
    WORK_QUEUE_ITEM WorkQueueItem;

} DBCACPI_WORKITEM, *PDBCACPI_WORKITEM;

typedef struct _DEVICE_EXTENSION {
    ULONG Sig;
    // Device object we call when submitting requests
    PDEVICE_OBJECT TopOfStackDeviceObject;
    // Our Pdo
    PDEVICE_OBJECT PhysicalDeviceObject;
    
    DEVICE_POWER_STATE CurrentDevicePowerState;
    
    PIRP PowerIrp;
    PIRP ChangeRequestIrp;
    ULONG Flags;

    // cached DBC Registers (read once at init)
    USHORT VendorId;
    UCHAR RevisionId;
    UCHAR BayCount;

    DBCCR_REGISTER DbControlCapabilities;   //DBCCR
    
    PIRP WakeIrp;
    KEVENT RemoveEvent;
    ULONG PendingIoCount;

    DBCACPI_WORKITEM WorkItem;
    // array we use to tack bay status changes
    // zero index not used
    UCHAR BayState[MAX_BAY_NUMBER+1]; //32 bays
    
    BOOLEAN AcceptingRequests;
    UCHAR Pad2[3];

    KSPIN_LOCK ChangeRequestSpin;
    KSPIN_LOCK FlagsSpin;

    KDPC PollDpc;
    KTIMER PollTimer;
    
    DEVICE_CAPABILITIES DeviceCapabilities;

    // subsystem descriptor to use
    // note that this may have some values set by the registry
    DBC_SUBSYSTEM_DESCRIPTOR SubsystemDescriptor;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


// define standard register offsets

#define ACPI_DBC_VENDOR_ID                      0x00000000
#define ACPI_DBC_REVISION_ID                    0x00000004
#define ACPI_DBC_SUBSYSTEM_VENDOR_ID            0x00000008
#define ACPI_DBC_SUBSYSTEM_ID                   0x0000000A
#define ACPI_DBC_DBCCR                          0x0000000C
#define ACPI_DBC_BSTR0                          0x00000010
#define ACPI_DBC_BCER0                          0x00000014

// define acpi methods
#define DBACPI_DBCC_METHOD               (ULONG) ('CCBD')
#define DBACPI_GUID_METHOD               (ULONG) ('DIUG')
#define DBACPI_BPM3_METHOD               (ULONG) ('3MPB')
#define DBACPI_BPMU_METHOD               (ULONG) ('UMPB')
#define DBACPI_BCTR_METHOD               (ULONG) ('RTCB')
#define DBACPI_BREL_METHOD               (ULONG) ('LERB')

// DBCACPI Flags
#define DBCACPI_FLAG_STOPPED                   0x00000001
#define DBCACPI_FLAG_ACPIREG                   0x00000002
#define DBCACPI_FLAG_ENABLED_FOR_WAKEUP        0x00000004
#define DBCACPI_FLAG_WORKITEM_PENDING          0x00000008
#define DBCACPI_FLAG_STARTED                   0x00000010

#define DBC_WORKITEM_SIG    0x54496B77         //"wkIT"

#define DBCACPI_READ_REG_UCHAR(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(UCHAR),\
                                  TRUE)                                  
    
#define DBCACPI_READ_REG_USHORT(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(USHORT),\
                                  TRUE)

#define DBCACPI_READ_REG_ULONG(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(ULONG),\
                                  TRUE)                                  

#define DBCACPI_WRITE_REG_UCHAR(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(UCHAR),\
                                  FALSE)                                  
    
#define DBCACPI_WRITE_REG_USHORT(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(USHORT),\
                                  FALSE)

#define DBCACPI_WRITE_REG_ULONG(devobj, offset, reg) \
     DBCACPI_ReadWriteDBCRegister((devobj),\
                                  (offset),\
                                  (reg),\
                                  sizeof(ULONG),\
                                  FALSE)       
/* 
Debug Macros
*/
#if DBG

#define DEBUG_LOG 

#define LOG_MISC          0x00000001        //debug log entries    

VOID
DBCACPI_LogInit(
    );

VOID
DBCACPI_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

VOID
DBCACPI_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    );    

#define LOGENTRY(mask, sig, info1, info2, info3)
//    DBCACPI_Debug_LogEntry(mask, sig, (ULONG)info1, (ULONG)info2, (ULONG)info3)
    

#define DBCACPI_ASSERT(exp) \
    if (!(exp)) { \
        DBCACPI_Assert( #exp, __FILE__, __LINE__, NULL );\
    }            

#define DBCACPI_ASSERT_EXT(de) DBCACPI_ASSERT((de)->Sig == DBCACPI_EXT_SIG)
    

ULONG
_cdecl
DBCACPI_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define DBCACPI_KdPrint(_x_) DBCACPI_KdPrintX _x_ 
#define TEST_TRAP() { DbgPrint( "DBCACPI: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                      TRAP();}
#ifdef MAX_DEBUG                      
#define MD_TEST_TRAP() { DbgPrint( "DBCACPI: Code test trap %s line: %d\n", __FILE__, __LINE__);\
                         TRAP();}                      
#else
#define MD_TEST_TRAP()
#endif                         

#ifdef NTKERN
#define TRAP() _asm {int 3}
#else
#define TRAP() DbgBreakPoint()
#endif

#else

#define LOGENTRY(mask, sig, info1, info2, info3) 
#define DBCACPI_ASSERT(exp)
#define DBCACPI_KdPrint(_x_)
#define DBCACPI_ASSERT_EXT(de)
#define DBCACPI_LogInit()

#define TRAP()
#define TEST_TRAP() 
#define MD_TEST_TRAP()

#endif

VOID
DBCACPI_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DBCACPI_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCACPI_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCACPI_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCACPI_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
DBCACPI_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
DBCACPI_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DBCACPI_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
DBCACPI_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );   

NTSTATUS
DBCACPI_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );    

NTSTATUS
DBCACPI_Pnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );        

NTSTATUS
DBCACPI_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );          

NTSTATUS
DBCACPI_WaitWakeIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
DBCACPI_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
DBCACPI_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
DBCACPI_Ioctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
DBCACPI_ReadWriteDBCRegister(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegisterOffset,
    PVOID RegisterData,
    USHORT RegisterDataLength,
    BOOLEAN ReadRegister    
    );    

NTSTATUS
DBCACPI_SyncAcpiCall(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            OutputSize
    );

NTSTATUS
DBCACPI_ProcessDrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp 
    );

NTSTATUS
DBCACPI_SetFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    );

NTSTATUS
DBCACPI_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS 
DBCACPI_RegisterWithACPI(
    IN PDEVICE_OBJECT FdoDeviceObject,
    IN BOOLEAN Register
    );

NTSTATUS
DBCACPI_GetAcpiInterfaces(
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
DBCACPI_ClearFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    );    

NTSTATUS
DBCACPI_CheckForStatusChange(
    IN PDEVICE_OBJECT DeviceObject
    );  

NTSTATUS 
DBCACPI_GetBayRegistryParameters(
    PDEVICE_OBJECT DeviceObject,
    USHORT BayNumber,
    PULONG PortUSBMap,
    PULONG Port1394Map
    );    

NTSTATUS 
DBCACPI_GetRegistryParameters(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCACPI_ReadBayMapRegister(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Usb,
    PVOID BayData,
    USHORT BayDataLength,
    ULONG BayNumber
    );    

NTSTATUS
DBCACPI_ReadBayReleaseRegister(
    PDEVICE_OBJECT DeviceObject,
    PULONG ReleaseOnShutdown
    );    

NTSTATUS
DBCACPI_GetClassGlobalDebugRegistryParameters(
    );

NTSTATUS
DBCACPI_GetClassGlobalRegistryParameters(
    );    

NTSTATUS
DBCACPI_ReadGuidRegister(
    PDEVICE_OBJECT DeviceObject,
    PVOID GuidData,
    USHORT GuidDataLength,
    ULONG Arg0
    );    

VOID
DBCACPI_NotifyWorker(
    IN PVOID Context
    );    

NTSTATUS
DBCACPI_BIOSControl(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Enable
    );

NTSTATUS 
DBCACPI_StartPolling(
    PDEVICE_OBJECT DeviceObject
    );    

NTSTATUS
DBCACPI_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS 
DBCACPI_SetRegistryKeyValueForPdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN SoftwareBranch,
    IN ULONG Type,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    );    

#if DBG

#define DEBUG_HEAP

extern ULONG TotalHeapSace;
#define DBCACPI_HEAP_SIG    0x12344321
#define DBCACPI_FREE_TAG    0x11111111

#define DbcExAllocatePool(p, l)  DBCLASS_GetHeap((p), (l), DBCLASS_HEAP_SIG,  &TotalHeapSace)
#define DbcExFreePool(l) DBCLASS_RetHeap((l), DBCLASS_HEAP_SIG, &TotalHeapSace)

#else

#define DbcExAllocatePool(p, l) ExAllocatePool((p), (l))
#define DbcExFreePool(l) ExFreePool((l))

#endif    

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcusb\dbcusb.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dbcusb.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-4-98 : created

--*/

#include "dbc100.h"
#include "usbdi.h"
#include "usb100.h"
#include "usbdlib.h"

// registry Keys
#define DEBUG_LEVEL_KEY                 L"debuglevel"
#define DEBUG_WIN9X_KEY                 L"debugWin9x"


#define DBCUSB_EXT_SIG              0x42535544       //"DUSB"

typedef struct _DEVICE_EXTENSION {
    ULONG Sig;
    // Device object we call when submitting requests
    PDEVICE_OBJECT TopOfStackDeviceObject;
    // Our Pdo
    PDEVICE_OBJECT PhysicalDeviceObject;
    // OurFdo
    PDEVICE_OBJECT FdoDeviceObject;
    
    DEVICE_POWER_STATE CurrentDevicePowerState;
    
    PIRP PowerIrp;
    PIRP ChangeRequestIrp;
    PIRP InterruptIrp;

    PIRP WakeIrp;
    KEVENT StopEvent;
    ULONG PendingIoCount;
    
    BOOLEAN AcceptingRequests;
    BOOLEAN EnabledForWakeup;
    UCHAR Flags;
    UCHAR InterruptDataBufferLength;

    //4 bytes, enough for 32 bays
    UCHAR InterruptDataBuffer[4]; 

    KSPIN_LOCK ChangeRequestSpin;

    USBD_PIPE_HANDLE InterruptPipeHandle;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
    DEVICE_CAPABILITIES DeviceCapabilities;
    DBC_SUBSYSTEM_DESCRIPTOR DbcSubsystemDescriptor;
    DBC_BAY_DESCRIPTOR BayDescriptor[32];
    
    struct _URB_BULK_OR_INTERRUPT_TRANSFER InterruptUrb;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DBCUSB_FLAG_INTERUPT_XFER_PENDING       0x01
#define DBCUSB_FLAG_STOPPED                     0x02
#define DBCUSB_FLAG_STARTED                     0x04

/* 
Debug Macros
*/
#if DBG

VOID
DBCUSB_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

#define DBCUSB_ASSERT(exp) \
    if (!(exp)) { \
        DBCUSB_Assert( #exp, __FILE__, __LINE__, NULL );\
    }            

#define DBCUSB_ASSERT_EXT(de) DBCUSB_ASSERT((de)->Sig == DBCUSB_EXT_SIG)
    

ULONG
_cdecl
DBCUSB_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define DBCUSB_KdPrint(_x_) DBCUSB_KdPrintX _x_ 
#define TEST_TRAP() { DbgPrint( "DBCUSB: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                      TRAP();}

#ifdef NTKERN
#define TRAP() _asm {int 3}
#else
#define TRAP() DbgBreakPoint()
#endif

#else

#define DBCUSB_ASSERT(exp)
#define DBCUSB_KdPrint(_x_)
#define DBCUSB_ASSERT_EXT(de)

#define TRAP()
#define TEST_TRAP() 

#endif

#ifdef MAXDEBUG                      
#define MD_TEST_TRAP() { DbgPrint( "DBCUSB: MAXDEBUG test trap %s line: %d\n", __FILE__, __LINE__);\
                         TRAP();}                      
#else
#define MD_TEST_TRAP()
#endif 

VOID
DBCUSB_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DBCUSB_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCUSB_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCUSB_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCUSB_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
DBCUSB_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
DBCUSB_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DBCUSB_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
DBCUSB_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );   

NTSTATUS
DBCUSB_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );    

NTSTATUS
DBCUSB_Pnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );        

NTSTATUS
DBCUSB_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );          

NTSTATUS
DBCUSB_WaitWakeIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
DBCUSB_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
DBCUSB_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
DBCUSB_Ioctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
DBCUSB_ReadWriteDBCRegister(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegisterOffset,
    PVOID RegisterData,
    USHORT RegisterDataLength,
    BOOLEAN ReadRegister    
    );    

NTSTATUS
DBCUSB_ProcessDrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp 
    );

NTSTATUS
DBCUSB_SetFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    );

NTSTATUS
DBCUSB_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DBCUSB_ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCUSB_SubmitInterruptTransfer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DBCUSB_SyncUsbCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );    

NTSTATUS 
DBCUSB_Transact(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,      
    IN UCHAR RequestType,    
    IN UCHAR Request,        
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred
    );

NTSTATUS
DBCUSB_GetBayStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN PBAY_STATUS BayStatus
    );

VOID
DBCUSB_CompleteChangeRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR ChangeData,
    IN ULONG ChangeDataLength,
     IN NTSTATUS NtStatus
    );

NTSTATUS
DBCUSB_ClearFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    );    

NTSTATUS
DBCUSB_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    );

NTSTATUS
DBCUSB_GetClassGlobalDebugRegistryParameters(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcusb\core.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    CORE.C

Abstract:

    This module contains core code for the USB
    Device Bay Controller 

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    05-13-98 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbcusb.h"
#include "dbci.h"

#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, )
#endif

#if 0
NTSTATUS
DBCUSB_GetBayStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BayNumber
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BSTR_REGISTER baystr;
    
    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);
     

    TEST_TRAP();
 
    // dump info about this bay
    DBCUSB_KdPrint((2,"'BAYSTR[%d] 0x%x\n", BayNumber, baystr.ul));
    DBCUSB_KdPrint((2,"'>BAY_FF 0x%x\n", baystr.BayFormFactor));
    DBCUSB_KdPrint((2,"'>SL_STS 0x%x\n", baystr.SecurityLockEngaged));
    DBCUSB_KdPrint((2,"'>BAY_ST 0x%x\n", baystr.BayState));
    DBCUSB_KdPrint((2,"'>REMREQ_STS 0x%x\n", baystr.RemovalRequested));
    DBCUSB_KdPrint((2,"'>DEVSTCHG 0x%x\n", baystr.DeviceStateChange));
    DBCUSB_KdPrint((2,"'>1394PRSN_STS 0x%x\n", baystr.p1394DeviceIsPresent));
    DBCUSB_KdPrint((2,"'>USBPRSN_STS 0x%x\n", baystr.UsbDeviceIsPresent));
    
    return ntStatus;
}
#endif


VOID
SetBit(
    PVOID Bitmap,
    ULONG BitNumber
    )
 /* ++
  *
  * Description:
  *
  * Set a bit in a given a string of bytes.
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PULONG l = (PULONG) Bitmap;


    dwordOffset = BitNumber / 32;
    bitOffset = BitNumber % 32;

    l[dwordOffset] |= (1 << bitOffset);
}


NTSTATUS
DBCUSB_StopDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    LONG pendingIoCount;

    DBCUSB_KdPrint((1,"'>STOP DBC\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;        
    
    if (deviceExtension->WakeIrp) {
        IoCancelIrp(deviceExtension->WakeIrp);
        deviceExtension->WakeIrp = NULL;
    }
        
    //
    // ounce this flag is set no irps will be pased 
    // down the stack to lower drivers
    //
    deviceExtension->AcceptingRequests = FALSE;

    if (deviceExtension->Flags & DBCUSB_FLAG_INTERUPT_XFER_PENDING) {
        IoCancelIrp(deviceExtension->InterruptIrp);
    }

    //
    // final decrement will trigger the stop
    //
    pendingIoCount = DBCUSB_DecrementIoCount(DeviceObject);

    {
        NTSTATUS status;

        // wait for any io request pending in our driver to
        // complete for finishing the remove

        status = KeWaitForSingleObject(
                    &deviceExtension->StopEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);

    }

    return STATUS_SUCCESS;
}            


NTSTATUS
DBCUSB_StartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();


    DBCUSB_KdPrint((1,"'Starting DBC driver\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    // get the device and config descriptors
    // and configure the device

    KeInitializeEvent(&deviceExtension->StopEvent, NotificationEvent, FALSE);

    ntStatus = DBCUSB_ConfigureDevice(DeviceObject);    

    if (NT_SUCCESS(ntStatus)) {
        // allocate an Irp to poll the controller

        deviceExtension->InterruptIrp = 
            IoAllocateIrp(DeviceObject->StackSize, FALSE);

        DBCUSB_KdPrint((2,"'StartDevice AllocateIrp Irp %x StackSize %d\n",
                   deviceExtension->InterruptIrp, DeviceObject->StackSize));

        if (deviceExtension->InterruptIrp == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } 

    } 

    return ntStatus;
}


VOID
DBCUSB_CancelChangeRequestIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is called to cancel a change request irp .

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    NT status code.
    
--*/
{
    
//    PDRB drb;
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;
     
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    DBCUSB_DecrementIoCount(DeviceObject);
    
    KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
    deviceExtension->ChangeRequestIrp = NULL;        
    KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT);
}


NTSTATUS
DBCUSB_ProcessDrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp 
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDRB drb;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    USHORT function;
    KIRQL oldIrql, irql;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);
     
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    drb = ioStackLocation->Parameters.Others.Argument1;

    function = drb->DrbHeader.Function;

    switch (function) {
    
    case DRB_FUNCTION_GET_CONTROLLER_STATUS:
        {

        ULONG portStatus;

        ntStatus = DBCUSB_GetPortStatus(DeviceObject,
                                        &portStatus);

        if (NT_SUCCESS(ntStatus)) {
        
            if (!(portStatus & USBD_PORT_CONNECTED)) {
                ntStatus = STATUS_DEVICE_NOT_CONNECTED;
            } else if (!(portStatus & USBD_PORT_ENABLED)) {
                // this is where we attempt 'babble boy'
                // recovery if necessary
            
                //ntStatus = STATUS_DEVICE_NOT_CONNECTED;
                ntStatus = STATUS_SUCCESS;
                    
                DBCUSB_KdPrint((0,"'PORT Disabled -- DB CONTROLLER MAY BE DEAD!\n"));
                TEST_TRAP();
            }
            
        } else {
            DBCUSB_KdPrint((0,
            "'PORT Status Failed -- DB CONTROLLER MAY BE DEAD or DISCONNECTED \n"));
            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
        }

        DBCUSB_KdPrint((2,"'Get Controller status %x\n", ntStatus));
        
        }
        
        break;
        
    case DRB_FUNCTION_CHANGE_REQUEST:
        DBCUSB_KdPrint((2,"'DRB_FUNCTION_CHANGE_REQUEST\n"));
        //
        //  Queue the change request, only one can be pending at a time.
        //
        KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
        
        if (deviceExtension->ChangeRequestIrp) {
            KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
            ntStatus = STATUS_DEVICE_BUSY;
        } else {

            deviceExtension->ChangeRequestIrp = Irp;
            KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);

            //
            // set up a cancel routine
            //

            IoAcquireCancelSpinLock(&irql);
            if (Irp->Cancel) {
                TEST_TRAP();
                // Irp was canceled
                IoReleaseCancelSpinLock(irql);

                // call cancel routine
                DBCUSB_CancelChangeRequestIrp(DeviceObject, Irp);
                
            } else {
                IoSetCancelRoutine(Irp, DBCUSB_CancelChangeRequestIrp);
                IoReleaseCancelSpinLock(irql);
            }

            // post an interrupt transfer
            DBCUSB_SubmitInterruptTransfer(DeviceObject);
            
            ntStatus = STATUS_PENDING;
        }
        break;
        
    case DRB_FUNCTION_GET_SUBSYSTEM_DESCRIPTOR :
        {
        PDBC_SUBSYSTEM_DESCRIPTOR subsystemDescriptor;
        
        DBCUSB_KdPrint((2,"'DRB_FUNCTION_GET_SUBSYSTEM_DESCRIPTOR\n"));

        subsystemDescriptor = 
            &drb->DrbGetSubsystemDescriptor.SubsystemDescriptor;

        RtlCopyMemory(subsystemDescriptor, 
                      &deviceExtension->DbcSubsystemDescriptor,
                      sizeof(DBC_SUBSYSTEM_DESCRIPTOR));
        
        ntStatus = STATUS_SUCCESS;
        }                                   
        break;    
        
    case DRB_FUNCTION_GET_BAY_DESCRIPTOR :
        {
        PDBC_BAY_DESCRIPTOR bayDescriptor;
        
        DBCUSB_KdPrint((2,"'DRB_FUNCTION_GET_BAY_DESCRIPTOR\n"));

        bayDescriptor = 
            &drb->DrbGetBayDescriptor.BayDescriptor;

        DBCUSB_ASSERT(drb->DrbGetBayDescriptor.BayNumber > 0);
         
        RtlCopyMemory(bayDescriptor,
                      &deviceExtension->BayDescriptor[drb->DrbGetBayDescriptor.BayNumber-1],
                      sizeof(DBC_BAY_DESCRIPTOR));
                      
        DBCUSB_ASSERT(bayDescriptor->bLength == sizeof(*bayDescriptor));
        DBCUSB_ASSERT(bayDescriptor->bDescriptorType == DBC_BAY_DESCRIPTOR_TYPE);             

        ntStatus = STATUS_SUCCESS;
        }
        break;    
        
    case DRB_FUNCTION_SET_BAY_FEATURE :
        DBCUSB_KdPrint((2,"'DRB_FUNCTION_SET_BAY_FEATURE\n"));

        ntStatus = DBCUSB_SetFeature(DeviceObject,
                                     drb->DrbBayFeatureRequest.BayNumber,
                                     drb->DrbBayFeatureRequest.FeatureSelector);

        break;    
        
    case DRB_FUNCTION_GET_BAY_STATUS :
        
        DBCUSB_KdPrint((1,"'>DRB_FUNCTION_GET_BAY_STATUS (%d)\n",
            drb->DrbGetBayStatus.BayNumber));
        
        ntStatus = DBCUSB_GetBayStatus(DeviceObject,
                                       drb->DrbGetBayStatus.BayNumber,
                                       &drb->DrbGetBayStatus.BayStatus);
                                       
        DBCUSB_KdPrint((1,"'>>BSTR = (0x%x)\n",
            drb->DrbGetBayStatus.BayStatus));
                                           
        break;   
        
    case DRB_FUNCTION_CLEAR_BAY_FEATURE :
    
        DBCUSB_KdPrint((2,"'DRB_FUNCTION_CLEAR_BAY_FEATURE\n"));
        ntStatus = DBCUSB_ClearFeature(DeviceObject,
                                       drb->DrbBayFeatureRequest.BayNumber,
                                       drb->DrbBayFeatureRequest.FeatureSelector);
        break;            
        
    case DRB_FUNCTION_START_DEVICE_IN_BAY:        
    
        DBCUSB_KdPrint((1,"'OK to Start Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;

    case DRB_FUNCTION_STOP_DEVICE_IN_BAY:        
    
        DBCUSB_KdPrint((1,"'OK to Start Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;        

    case DRB_FUNCTION_EJECT_DEVICE_IN_BAY:        
    
        DBCUSB_KdPrint((1,"'OK to Eject Device\n"));
        ntStatus = STATUS_SUCCESS;
        break;            
        
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCUSB_KdPrint((0,"'Invalid DRB function (0x%x)\n", function));
        TRAP();
    }

    DBCUSB_KdPrint((2,"' DBCUSB_ProcessDrb(0x%x)\n", ntStatus));
    return ntStatus;
}


NTSTATUS
DBCUSB_SetFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    DBCUSB_KdPrint((2,"'SET FEATURE\n"));
     
#if DBG
    switch (FeatureSelector) {
    case DEVICE_STATUS_CHANGE_ENABLE:
        DBCUSB_KdPrint((2,"'DEVICE_STATUS_CHANGE_ENABLE\n"));
        break;
    case ENABLE_VID_POWER:
        DBCUSB_KdPrint((2,"'ENABLE_VID_POWER\n"));
        break;
    case LOCK_CTL:
        DBCUSB_KdPrint((2,"'LOCK_CTL\n"));
        break;
    case REMOVAL_EVENT_WAKE_ENABLE:
        DBCUSB_KdPrint((2,"'REMOVAL_EVENT_WAKE_ENABLE\n"));
        break;
    case REMOVAL_REQUEST_ENABLE:
        DBCUSB_KdPrint((2,"'REMOVAL_REQUEST_ENABLE\n"));
        break;
    case REQUEST_DEVICE_INSERTED_STATE:
        DBCUSB_KdPrint((2,"'REQUEST_DEVICE_INSERTED_STATE\n"));
        break;
    case REQUEST_DEVICE_ENABLED_STATE:
        DBCUSB_KdPrint((2,"'REQUEST_DEVICE_INSERTED_STATE\n"));
        break;                
    case REQUEST_REMOVAL_ALLOWED_STATE:
        DBCUSB_KdPrint((2,"'REQUEST_DEVICE_INSERTED_STATE\n"));
        break;  
        
    }
#endif //DBG

    switch (FeatureSelector) {
    case DEVICE_STATUS_CHANGE_ENABLE:
    case REQUEST_DEVICE_INSERTED_STATE:
    case REQUEST_DEVICE_ENABLED_STATE: 
    case ENABLE_VID_POWER:
    case LOCK_CTL:
    case REMOVAL_EVENT_WAKE_ENABLE:
    case REMOVAL_REQUEST_ENABLE:
    case REQUEST_REMOVAL_ALLOWED_STATE:
    
        
        ntStatus = DBCUSB_Transact(
            DeviceObject,
            NULL,                           // no data
            0,
            TRUE,                           // direction out
            URB_FUNCTION_CLASS_INTERFACE,   // bmRequest
            0,                              // class, to interface
            USB_REQUEST_SET_FEATURE ,       // bRequest
            FeatureSelector,                // wValue
            BayNumber,                      // wIndex
            NULL);    
        
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCUSB_KdPrint((0,"'Invalid feature selector (0x%x)\n", FeatureSelector));
        TRAP();
    }

    return ntStatus;
}

NTSTATUS
DBCUSB_ClearFeature(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN USHORT FeatureSelector
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    DBCUSB_KdPrint((2,"'CLEAR FEATURE\n"));
     
#if DBG
    switch (FeatureSelector) {
    case C_DEVICE_STATUS_CHANGE:
        DBCUSB_KdPrint((2,"'C_DEVICE_STATUS_CHANGE\n"));
        break;
    case C_REMOVE_REQUEST:
        DBCUSB_KdPrint((2,"'C_REMOVE_REQUEST\n"));
        break;
    case LOCK_CTL:
        DBCUSB_KdPrint((2,"'LOCK_CTL\n"));
        break;
        
    }
#endif //DBG

    switch (FeatureSelector) {
    case LOCK_CTL:
    case ENABLE_VID_POWER:
    case C_REMOVE_REQUEST:
    case C_DEVICE_STATUS_CHANGE:
        
        ntStatus = DBCUSB_Transact(
            DeviceObject,
            NULL,                           // no data
            0,
            TRUE,                           // direction out
            URB_FUNCTION_CLASS_INTERFACE,   // bmRequest
            0,                              // class, to interface
            USB_REQUEST_CLEAR_FEATURE ,     // bRequest
            FeatureSelector,                // wValue
            BayNumber,                      // wIndex
            NULL);    
        
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        DBCUSB_KdPrint((0,"'Invalid feature selector (0x%x)\n", FeatureSelector));
        TRAP();
    }

    return ntStatus;
}


NTSTATUS
DBCUSB_GetBayStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT BayNumber,
    IN PBAY_STATUS BayStatus
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to FDO

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG length;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    DBCUSB_KdPrint((1,"'GET_BAY_STATUS bay [%d]\n", BayNumber));     
    
    ntStatus = DBCUSB_Transact(
        DeviceObject,
        (PUCHAR)BayStatus,                      // bay status
        3,                              // status is 3 bytes
        FALSE,                          // direction in
        URB_FUNCTION_CLASS_INTERFACE,   // bmRequest
        0,                              // class, from interface
        USB_REQUEST_GET_STATUS ,        // bRequest
        0,                              // wValue
        BayNumber,                      // wIndex
        &length);    

    return ntStatus;        
}


VOID
DBCUSB_CompleteChangeRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR ChangeData,
    IN ULONG ChangeDataLength,
    IN NTSTATUS NtStatus
    )
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRP irp;
    KIRQL oldIrql;
    PDRB drb;
    PIO_STACK_LOCATION ioStackLocation;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    KeAcquireSpinLock(&deviceExtension->ChangeRequestSpin, &oldIrql);
    
    if (deviceExtension->ChangeRequestIrp) {
        irp = deviceExtension->ChangeRequestIrp;
        deviceExtension->ChangeRequestIrp = NULL;
        KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
        
        // now complete the irp,        
        // check for cancel       
        IoAcquireCancelSpinLock(&oldIrql);
        if (irp->Cancel) {
            TEST_TRAP();
            //Irp was canceled
            IoReleaseCancelSpinLock(oldIrql);
        } else {
            IoSetCancelRoutine(irp, NULL);
            IoReleaseCancelSpinLock(oldIrql);
        
            ioStackLocation = IoGetCurrentIrpStackLocation(irp);
            drb = ioStackLocation->Parameters.Others.Argument1;

            DBCUSB_ASSERT(ChangeDataLength <= sizeof(ULONG));
            drb->DrbChangeRequest.BayChange = 0;
            RtlCopyMemory(&drb->DrbChangeRequest.BayChange,
                          ChangeData,
                          ChangeDataLength);

            DBCUSB_DecrementIoCount(DeviceObject);       
            
            irp->IoStatus.Status = NtStatus;
            IoCompleteRequest(irp,
                              IO_NO_INCREMENT);
        }
        
    } else {
        
        // no irp, we get here if the pending request was canceled
        // ie STOP_DEVICE
        KeReleaseSpinLock(&deviceExtension->ChangeRequestSpin, oldIrql);
    }

}        

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcacpi\dbg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for DBC driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    11-5-96 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbci.h"
#include "dbcacpi.h"

#ifdef MAX_DEBUG
#define DEBUG_HEAP
#endif

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


#if DBG 

extern ULONG DBCACPI_Debug_Trace_Level;
extern ULONG DBCACPI_W98_Debug_Trace;

VOID
DBCACPI_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    TRAP();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
DBCACPI_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (DBCACPI_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            // this code is useful for debugging on win9x where
            // the ntkernel emulator has a trace buffer...
            //
            // override the ntkern trace buffer for 
            // level 1 output -- ie go to terminal
            if (DBCACPI_W98_Debug_Trace) {    
                DbgPrint("DBCACPI.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'DBCACPI.SYS: ");
            }
        } else {
            DbgPrint("'DBCACPI.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


NTSTATUS
DBCACPI_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBCACPI_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL_KEY;
    QueryTable[0].EntryContext = &DBCACPI_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBCACPI_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(DBCACPI_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = DBCACPI_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X_KEY;
    QueryTable[1].EntryContext = &DBCACPI_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &DBCACPI_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(DBCACPI_W98_Debug_Trace);
    
    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         DBCACPI_KdPrint((1, "'Debug Trace Level Set: (%d)\n", DBCACPI_Debug_Trace_Level));
  
        if (DBCACPI_W98_Debug_Trace) {
            DBCACPI_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            DBCACPI_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }
    
        if (DBCACPI_Debug_Trace_Level > 0) {
            ULONG DBCACPI_Debug_Asserts = 1;
        }
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}


PVOID
DBCACPI_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    PoolType - pool type passed to ExAllocatePool
    
    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    
    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER)*2,
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;        
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;

        tagBuffer = (PHEAP_TAG_BUFFER) (p + NumberOfBytes);
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;     
    }                                            

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, "GetH", p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else    
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */                
    return p;
}


VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER endTagBuffer;    
    PHEAP_TAG_BUFFER beginTagBuffer;

    DBCACPI_ASSERT(P != 0);
    
    beginTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));
    endTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P + beginTagBuffer->Length);

    *TotalAllocatedHeapSpace -= beginTagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);    
//    LOGENTRY(LOG_MISC, "RetH", P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    DBCACPI_ASSERT(*TotalAllocatedHeapSpace >= 0);
    DBCACPI_ASSERT(beginTagBuffer->Sig == Signature);
    DBCACPI_ASSERT(endTagBuffer->Sig == Signature);
    DBCACPI_ASSERT(endTagBuffer->Length == beginTagBuffer->Length);
    
    // fill the buffer with bad data
    RtlFillMemory(P, beginTagBuffer->Length, 0xff);
    beginTagBuffer->Sig = DBCACPI_FREE_TAG;

    // free the original block
    ExFreePool(beginTagBuffer);    
#else
    ExFreePool(P);        
#endif /* DEBUG_HEAP */
}

#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct DBG_LOG_ENTRY {
    CHAR    le_name[4];        // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct DBG_LOG_ENTRY *DbcALStart = 0;    // No log yet
struct DBG_LOG_ENTRY *DbcALPtr;
struct DBG_LOG_ENTRY *DbcALEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else 
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
DBCACPI_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    )
/*++

Routine Description:

    Adds an Entry to USBH log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (DbcALStart == 0) {
        return;
    }        

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }        
    
    if (DbcALPtr > DbcALStart) {
        DbcALPtr -= 1;    // Decrement to next entry
    } else {
        DbcALPtr = DbcALEnd;
    }        

    DBCACPI_ASSERT(DbcALPtr >= DbcALStart);
    
    RtlCopyMemory(DbcALPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    DbcALPtr->le_info1 = Info1;
    DbcALPtr->le_info2 = Info2;
    DbcALPtr->le_info3 = Info3;

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }        

    return;
}


VOID
DBCACPI_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;    
#else
    ULONG logSize = 4096*3;    
#endif

    
    KeInitializeSpinLock(&LogSpinLock);

    DbcALStart = ExAllocatePool(NonPagedPool, 
                               logSize); 

    if (DbcALStart) {
        DbcALPtr = DbcALStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        DbcALEnd = DbcALStart + (logSize / sizeof(struct DBG_LOG_ENTRY)) - 1;
    } else {
        TRAP(); //(("no mem for log!\n"));
    }

    return;
}

VOID
DBCACPI_LogFree(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (DbcALStart) {
        ExFreePool(DbcALStart);
    }
}

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcusb\usb.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    USB.C

Abstract:

    This module contains code to execute USB 
    specific functions

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    05-13-98 : created

--*/
#include <wdm.h>
#include <initguid.h>
#include <wdmguid.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbcusb.h"



#define UsbBuildVendorClassUrb(\
                                    pUrb,\
                                    pDeviceData,\
                                    wFunction,\
                                    ulTransferFlags,\
                                    bRequestType,\
                                    bRequest,\
                                    wFeatureSelector,\
                                    wPort,\
                                    ulTransferBufferLength,\
                                    pTransferBuffer)\
    {\
    (pUrb)->UrbHeader.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);\
    (pUrb)->UrbHeader.Function = wFunction;\
    (pUrb)->UrbHeader.UsbdDeviceHandle = pDeviceData;\
    (pUrb)->UrbControlVendorClassRequest.TransferFlags = ulTransferFlags;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferLength = ulTransferBufferLength;\
    (pUrb)->UrbControlVendorClassRequest.TransferBuffer = pTransferBuffer;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferMDL = NULL;\
    (pUrb)->UrbControlVendorClassRequest.RequestTypeReservedBits = bRequestType;\
    (pUrb)->UrbControlVendorClassRequest.Request = bRequest;\
    (pUrb)->UrbControlVendorClassRequest.Value = wFeatureSelector;\
    (pUrb)->UrbControlVendorClassRequest.Index = wPort;\
    (pUrb)->UrbControlVendorClassRequest.UrbLink = NULL;\
    }




#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, DBCUSB_SyncUsbCall)
#endif


NTSTATUS
DBCUSB_SyncUsbCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
)
/*++

Routine Description:

    Called to send a request to the Pdo

Arguments:

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);
                
    if (!irp) {
        DBCUSB_KdPrint ((0, "'failed to allocate Irp\n"));
        TRAP();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->Parameters.Others.Argument1 = Urb;

    //
    // Pass request to Pdo, always wait for completion routine
    //

    status = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
            
        status = ioStatus.Status;

    }

    //
    // Done
    //
    DBCUSB_KdPrint((2, "'DBCUSB_SyncUsbCall(%x)\n", status)); 

    return status;
}


NTSTATUS
DBCUSB_ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB.
    All we do here is get the device descriptor and store it

Arguments:

    DeviceObject - pointer to the device object for this instance of a
                    USB DBC

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interface;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb;
    USHORT siz;
    UCHAR interfaceNumber, alternateSetting;

    deviceExtension = DeviceObject->DeviceExtension;

    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb) {

        deviceDescriptor = &deviceExtension->DeviceDescriptor;

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     deviceDescriptor,
                                     NULL,
                                     sizeof(*deviceDescriptor),
                                     NULL);

        ntStatus = DBCUSB_SyncUsbCall(DeviceObject, urb);

        if (NT_SUCCESS(ntStatus)) {
            DBCUSB_KdPrint ((2, "Device Descriptor = %x, len %x\n",
                            deviceDescriptor,
                            urb->UrbControlDescriptorRequest.TransferBufferLength));

            DBCUSB_KdPrint ((2, "'DBCUSB Device Descriptor:\n"));
            DBCUSB_KdPrint ((2, "'-------------------------\n"));
            DBCUSB_KdPrint ((2, "'bLength %d\n", deviceDescriptor->bLength));
            DBCUSB_KdPrint ((2, "'bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
            DBCUSB_KdPrint ((2, "'bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
            DBCUSB_KdPrint ((2, "'bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
            DBCUSB_KdPrint ((2, "'bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
            DBCUSB_KdPrint ((2, "'bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
            DBCUSB_KdPrint ((2, "'bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
            DBCUSB_KdPrint ((2, "'idVendor 0x%x\n", deviceDescriptor->idVendor));
            DBCUSB_KdPrint ((2, "'idProduct 0x%x\n", deviceDescriptor->idProduct));
            DBCUSB_KdPrint ((2, "'bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
            DBCUSB_KdPrint ((2, "'iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
            DBCUSB_KdPrint ((2, "'iProduct 0x%x\n", deviceDescriptor->iProduct));
            DBCUSB_KdPrint ((2, "'iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
            DBCUSB_KdPrint ((2, "'bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
        }

        ExFreePool(urb);
        
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {
    
        PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;

        urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

        if (urb) {

            siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;

get_config_descriptor_retry:

            configurationDescriptor = ExAllocatePool(NonPagedPool,
                                                     siz);
    
            if (configurationDescriptor) {

                UsbBuildGetDescriptorRequest(urb,
                                             (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                             USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                             0,
                                             0,
                                             configurationDescriptor,
                                             NULL,
                                             siz,
                                             NULL);
                
                ntStatus = DBCUSB_SyncUsbCall(DeviceObject, urb);

                DBCUSB_KdPrint((2, "'Configuration Descriptor = %x, len %x\n",
                                configurationDescriptor,
                                urb->UrbControlDescriptorRequest.TransferBufferLength));
            } else {
                // no mem for config descriptor
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // if we got some data see if it was enough.
            //
            // NOTE: we may get an error in URB because of buffer overrun
            if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                    configurationDescriptor->wTotalLength > siz) {

                siz = configurationDescriptor->wTotalLength;
                ExFreePool(configurationDescriptor);
                configurationDescriptor = NULL;
                goto get_config_descriptor_retry;
            }

            ExFreePool(urb);

        } else {
            // no mem for urb
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (configurationDescriptor) {

            DBCUSB_KdPrint((0, "'configurationDescriptor(%x)\n", configurationDescriptor));
            

            //
            // We have the configuration descriptor for the configuration
            // we want.
            //
            // Now we issue the select configuration command to get
            // the  pipes associated with this configuration.
            //

            //
            // DBCACPI driver only supports one interface
            //

            urb = USBD_CreateConfigurationRequest(configurationDescriptor, &siz);

            if (urb) {

                //
                // search thru all the interfaces
                // and find any we are interested in
                //

                interfaceNumber = 0;
                alternateSetting = 0;

                interfaceDescriptor =
                    USBD_ParseConfigurationDescriptor(configurationDescriptor,
                                                      interfaceNumber,
                                                      alternateSetting);

                // dbc only has one interface
                interface = &urb->UrbSelectConfiguration.Interface;

                // dbc always has one pipe
                DBCUSB_ASSERT(interface->NumberOfPipes == 1);
                
                //
                // perform any pipe initialization here
                //
                
                interface->Pipes[0].MaximumTransferSize = 1024;
                

                UsbBuildSelectConfigurationRequest(urb,
                                                  (USHORT) siz,
                                                  configurationDescriptor);

                ntStatus = DBCUSB_SyncUsbCall(DeviceObject, urb);

                deviceExtension->ConfigurationHandle =
                    urb->UrbSelectConfiguration.ConfigurationHandle;

                deviceExtension->InterruptPipeHandle =                    
                    interface->Pipes[0].PipeHandle;                            

                DBCUSB_ASSERT(interface->Pipes[0].MaximumPacketSize < 255);
                deviceExtension->InterruptDataBufferLength = (UCHAR)
                    interface->Pipes[0].MaximumPacketSize;
            
            } else {
               // no mem for urb
               ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(ntStatus)) {
            
                PUSB_COMMON_DESCRIPTOR usbDescriptor;            
                // extract the class specific descriptors from the config descriptor
                
                usbDescriptor = USBD_ParseDescriptors(
                                       configurationDescriptor,
                                       configurationDescriptor->wTotalLength,
                                       configurationDescriptor,
                                       DBC_SUSBSYSTEM_DESCRIPTOR_TYPE);

                if (usbDescriptor && usbDescriptor->bLength == 
                    sizeof(deviceExtension->DbcSubsystemDescriptor)) {
                    PUCHAR p;
                    ULONG i;
                    
                    RtlCopyMemory(&deviceExtension->DbcSubsystemDescriptor,
                                  usbDescriptor,
                                  sizeof(deviceExtension->DbcSubsystemDescriptor));

                    // copy the bay descriptors
                    p = (PUCHAR)  usbDescriptor;
                    usbDescriptor = 
                        (PUSB_COMMON_DESCRIPTOR) (p+usbDescriptor->bLength);
                        
                    for (i=0;
                         i < deviceExtension->DbcSubsystemDescriptor.bmAttributes.BayCount;
                         i++) {

                        RtlCopyMemory(&deviceExtension->BayDescriptor[i],
                                      usbDescriptor,
                                      sizeof(DBC_BAY_DESCRIPTOR));
                                  
                        p = (PUCHAR)  usbDescriptor;
                        usbDescriptor = 
                            (PUSB_COMMON_DESCRIPTOR) (p+usbDescriptor->bLength);   
                    }
                } else {
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            }
            
            ExFreePool(configurationDescriptor);    
        } else {
            // no mem for config descriptor
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }
    
    DBCUSB_KdPrint((2, "'DBCUSB_ConfigureDevice(%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
DBCUSB_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * This is a call back when the interrupt transfer completes.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PURB urb; // the Urb assocaited with this Irp
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = (PDEVICE_EXTENSION) Context; // the context is

    DBCUSB_DecrementIoCount(deviceExtension->FdoDeviceObject);                                                                
    
    urb = (PURB) &deviceExtension->InterruptUrb;
    deviceExtension->Flags &= ~DBCUSB_FLAG_INTERUPT_XFER_PENDING;  

    DBCUSB_KdPrint((1,"'ChangeIndication Irp status %x  URB status = %x\n",
        Irp->IoStatus.Status, urb->UrbHeader.Status));

    MD_TEST_TRAP();

    // complete the class drivers change request
    DBCUSB_CompleteChangeRequest(deviceExtension->FdoDeviceObject,
                                 urb->UrbBulkOrInterruptTransfer.TransferBuffer,
                                 urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                                 Irp->IoStatus.Status);

    return STATUS_MORE_PROCESSING_REQUIRED;

}  


NTSTATUS
DBCUSB_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an 
USB HID device

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension;

    *PortStatus = 0;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if(irp)
    {
        //
        // Call the class driver to perform the operation.  If the returned status
        // is PENDING, wait for the request to complete.
        //

        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack != NULL);

        nextStack->Parameters.Others.Argument1 = PortStatus;

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

        if (ntStatus == STATUS_PENDING) 
        {

            ntStatus = KeWaitForSingleObject(
                           &event,
                           Suspended,
                           KernelMode,
                           FALSE,
                           NULL);

        }
        else 
        {
            ioStatus.Status = ntStatus;
        }

        //
        // USBD maps the error code for us
        //
        ntStatus = ioStatus.Status;

    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBCUSB_KdPrint((1, "'>>Port status = %x ntStatus %x \n", *PortStatus, ntStatus));


    return ntStatus;
}


NTSTATUS
DBCUSB_SubmitInterruptTransfer(
    IN PDEVICE_OBJECT DeviceObject
    )
 /* ++
  *
  * Description:
  *
  * PPu an interrupt transfer down to listen for a change indication 
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    PIRP irp;
    PURB urb;
    CHAR stackSize;
    PDEVICE_EXTENSION deviceExtension;

    DBCUSB_KdPrint((0,"'Submit Interrupt Transfer\n"));
    deviceExtension = DeviceObject->DeviceExtension;

    DBCUSB_ASSERT(
        (deviceExtension->Flags & DBCUSB_FLAG_INTERUPT_XFER_PENDING) == 0);

    deviceExtension->Flags |= DBCUSB_FLAG_INTERUPT_XFER_PENDING;      
        
    irp = deviceExtension->InterruptIrp;
    urb = (PURB) &deviceExtension->InterruptUrb;

    DBCUSB_ASSERT(NULL != irp);
    DBCUSB_ASSERT(NULL != urb);
    DBCUSB_ASSERT(sizeof(*urb) >= sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    
    //
    // Fill in Urb header
    //

    //LOGENTRY(LOG_PNP, "Int>", DeviceObject, urb, irp);

    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb->UrbHeader.Function =
        URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

    //
    // Fill in Urb body
    //
    
    urb->UrbBulkOrInterruptTransfer.PipeHandle = deviceExtension->InterruptPipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
        deviceExtension->InterruptDataBufferLength;
    urb->UrbBulkOrInterruptTransfer.TransferBuffer = 
        &deviceExtension->InterruptDataBuffer[0];
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    stackSize = deviceExtension->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(irp,    // Irp
                           DBCUSB_ChangeIndication,
                           deviceExtension, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    //
    // Call the USB stack
    //

    DBCUSB_IncrementIoCount(DeviceObject);
     
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    //
    // completion routine will handle errors.
    //

    DBCUSB_KdPrint((2,"'DBCUSB_SubmitInterruptTransfer %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
DBCUSB_Transact(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,      
    IN UCHAR RequestType,    
    IN UCHAR Request,        
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred
    )
 /* ++
  * 
  * Description:
  * 
  * Arguments:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb;
    PUCHAR transferBuffer;
    ULONG transferFlags;

    PAGED_CODE();
    DBCUSB_KdPrint((2,"'Enter DBCUSB_Transact\n"));

    //
    // Allocate a transaction buffer and Urb from the non-paged pool
    //
    
    transferBuffer = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST) +
                                    DataBufferLength);

    if (transferBuffer) {
        urb = (PURB) (transferBuffer + DataBufferLength);

        DBCUSB_KdPrint((2,"'Transact transfer buffer = %x urb = %x\n", 
            transferBuffer, urb));

        transferFlags = 0;

        if (DataOutput) {
            // copy output data to transfer buffer
            if (DataBufferLength) {
                RtlCopyMemory(transferBuffer,
                              DataBuffer,
                              DataBufferLength);
            }                              

            transferFlags = USBD_TRANSFER_DIRECTION_OUT;
            
        } else {
            // zero the input buffer

            if (DataBufferLength) {
                RtlZeroMemory(DataBuffer,
                              DataBufferLength);
            }                              

            transferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;                          
        }

        UsbBuildVendorClassUrb(urb,
                               NULL,
                               Function,
                               transferFlags,
                               RequestType,
                               Request,
                               Feature,
                               Port,
                               DataBufferLength,
                               DataBufferLength ? transferBuffer : NULL);

        //
        // pass the URB to the USBD 'class driver'
        //
        
        ntStatus = DBCUSB_SyncUsbCall(DeviceObject, 
                                      urb);

        DataBufferLength = 
             urb->UrbControlVendorClassRequest.TransferBufferLength;
         
        if (!DataOutput && DataBufferLength) {
            RtlCopyMemory(DataBuffer,
                          transferBuffer,
                          DataBufferLength);
        }

        if (BytesTransferred) {
            *BytesTransferred = DataBufferLength;
        }
        
        ExFreePool(transferBuffer);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //LOGENTRY(LOG_PNP, "Xact", DeviceExtensionHub, 0, ntStatus); 

    DBCUSB_KdPrint((2,"'Exit DBCUSB_Transact %x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcusb\dbg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for DBC driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    11-5-96 : created

--*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"
#include "dbcusb.h"

#ifdef MAX_DEBUG
#define DEBUG_HEAP
#endif

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


#if DBG 

extern ULONG DBCUSB_Debug_Trace_Level;
extern ULONG DBCUSB_W98_Debug_Trace;

NTSTATUS
DBCUSB_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DBCUSB_KdPrint((2, "'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        // we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


NTSTATUS
DBCUSB_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"class\\dbc";

    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = DBCUSB_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL_KEY;
    QueryTable[0].EntryContext = &DBCUSB_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &DBCUSB_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(DBCUSB_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = DBCUSB_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X_KEY;
    QueryTable[1].EntryContext = &DBCUSB_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &DBCUSB_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(DBCUSB_W98_Debug_Trace);
    
    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         DBCUSB_KdPrint((1, "'Debug Trace Level Set: (%d)\n", DBCUSB_Debug_Trace_Level));
  
        if (DBCUSB_W98_Debug_Trace) {
            DBCUSB_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            DBCUSB_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }
    
        if (DBCUSB_Debug_Trace_Level > 0) {
            ULONG DBCUSB_Debug_Asserts = 1;
        }
    }
    
    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}


VOID
DBCUSB_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    TRAP();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
DBCUSB_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (DBCUSB_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            // this code is useful for debugging on win9x where
            // the ntkernel emulator has a trace buffer...
            //
            // override the ntkern trace buffer for 
            // level 1 output -- ie go to terminal
            if (DBCUSB_W98_Debug_Trace) {    
                DbgPrint("DBCUSB.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'DBCUSB.SYS: ");
            }
        } else {
            DbgPrint("'DBCUSB.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


#if 0
PVOID
UsbhGetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    PoolType - pool type passed to ExAllocatePool
    
    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    
    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER)*2,
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;        
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;

        tagBuffer = (PHEAP_TAG_BUFFER) (p + NumberOfBytes);
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;     
    }                                            

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, "GetH", p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else    
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */                
    return p;
}


VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER endTagBuffer;    
    PHEAP_TAG_BUFFER beginTagBuffer;

    USBH_ASSERT(P != 0);
    
    beginTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));
    endTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P + beginTagBuffer->Length);

    *TotalAllocatedHeapSpace -= beginTagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);    
//    LOGENTRY(LOG_MISC, "RetH", P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    USBH_ASSERT(*TotalAllocatedHeapSpace >= 0);
    USBH_ASSERT(beginTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Length == beginTagBuffer->Length);
    
    // fill the buffer with bad data
    RtlFillMemory(P, beginTagBuffer->Length, 0xff);
    beginTagBuffer->Sig = USBHUB_FREE_TAG;

    // free the original block
    ExFreePool(beginTagBuffer);    
#else
    ExFreePool(P);        
#endif /* DEBUG_HEAP */
}

#endif /* 0 */
#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct USBH_LOG_ENTRY {
    CHAR    le_name[4];        // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct USBH_LOG_ENTRY *DbcALStart = 0;    // No log yet
struct USBH_LOG_ENTRY *DbcALPtr;
struct USBH_LOG_ENTRY *DbcALEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else 
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
DBCUSB_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    )
/*++

Routine Description:

    Adds an Entry to USBH log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (DbcALStart == 0) {
        return;
    }        

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }        
    
    if (DbcALPtr > DbcALStart) {
        DbcALPtr -= 1;    // Decrement to next entry
    } else {
        DbcALPtr = DbcALEnd;
    }        

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }        

    USBH_ASSERT(DbcALPtr >= DbcALStart);
    
    RtlCopyMemory(DbcALPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    DbcALPtr->le_info1 = Info1;
    DbcALPtr->le_info2 = Info2;
    DbcALPtr->le_info3 = Info3;

    return;
}


VOID
DBCUSB_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;    
#else
    ULONG logSize = 4096*3;    
#endif

    
    KeInitializeSpinLock(&LogSpinLock);

    DbcALStart = ExAllocatePool(NonPagedPool, 
                               logSize); 

    if (DbcALStart) {
        DbcALPtr = DbcALStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        DbcALEnd = DbcALStart + (logSize / sizeof(struct USBH_LOG_ENTRY)) - 1;
    } else {
        USBH_KdBreak(("no mem for log!\n"));
    }

    return;
}

VOID
DBCUSB_LogFree(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (DbcALStart) {
        ExFreePool(DbcALStart);
    }
}

#endif /* DEBUG_LOG */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\devbay\dbport\dbcusb\dbcusb.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DBCUSB.C

Abstract:

    Driver for USB based device bay contoller

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-98 : created, jdunn

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "dbci.h"
#include "dbclib.h"
#include "dbcusb.h"

#ifdef ALLOC_PRAGMA
// pagable functions
#pragma alloc_text(PAGE, DBCUSB_QueryCapabilities)
#pragma alloc_text(PAGE, DBCUSB_Power)
#pragma alloc_text(PAGE, DBCUSB_Pnp)
#pragma alloc_text(PAGE, DBCUSB_StartDevice)
#pragma alloc_text(PAGE, DBCUSB_StopDevice)

#endif

//
// Globals
//

PDRIVER_OBJECT DBCUSB_DriverObject;

#ifndef DEBUG0
 #ifndef DEBUG1
  #ifndef DEBUG2
   #ifndef DEBUG3
    #if DBG
    #define DEBUG1
    #endif
   #endif 
  #endif  
 #endif    
#endif

#ifdef DEBUG0
ULONG DBCUSB_Debug_Trace_Level = 0;
#endif /* DEBUG0 */

#ifdef DEBUG1
ULONG DBCUSB_Debug_Trace_Level = 1;
#endif /* DEBUG1 */

#ifdef DEBUG2
ULONG DBCUSB_Debug_Trace_Level = 2;
#endif /* DEBUG2 */

#ifdef DEBUG3
ULONG DBCUSB_Debug_Trace_Level = 3;
#endif /* DEBUG3 */

#ifdef NTKERN_TRACE
ULONG DBCUSB_W98_Debug_Trace = 1;
#else
ULONG DBCUSB_W98_Debug_Trace = 0;
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;

    DBCUSB_DriverObject = DriverObject;

    //
    // Create dispatch points for device control.
    //

    DriverObject->DriverUnload = DBCUSB_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DBCUSB_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DBCUSB_Ioctl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DBCUSB_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = DBCUSB_Pnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = DBCUSB_Power;
    DriverObject->DriverExtension->AddDevice = DBCUSB_AddDevice;

    return ntStatus;
}


NTSTATUS
DBCUSB_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject = Context;
    NTSTATUS ntStatus;

    deviceExtension = deviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);
    irp = deviceExtension->PowerIrp;
    
    ntStatus = IoStatus->Status;

    IoCopyCurrentIrpStackLocationToNext(irp);      
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 irp);   

    DBCUSB_DecrementIoCount(deviceObject);                 

    return ntStatus;
}


#if 0
NTSTATUS
DBCUSB_PowerIrp_SetD0_Complete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;

    deviceObject = (PDEVICE_OBJECT) Context;

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);

    // we currently only call this going to D0
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);
    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;

    // at this point our driver is 'back on'
    // notify the class driver of this, it will 
    // drive the power on process for us
    TEST_TRAP();
    DBCLASS_SetD0_Complete(deviceObject, Irp);
    
    Irp->IoStatus.Status = ntStatus;

    DBCUSB_DecrementIoCount(deviceObject); 

    return ntStatus;
}
#endif


NTSTATUS
DBCUSB_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
DBCUSB_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    
    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           DBCUSB_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);
                           
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    // PnP rule: 
    // init all pnp irps we initiate with status_not_supported
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    
    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       TEST_TRAP(); // first time we hit this
       
       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;                 
    }

#if DBG                    
    if (!NT_SUCCESS(ntStatus)) {
        // failed? this is probably a bug
        DBCUSB_KdPrint((0, "'QueryCapabilities failed, why?\n"));
        TRAP();
    }
#endif

    IoFreeIrp(irp);

    return STATUS_SUCCESS;
}


NTSTATUS
DBCUSB_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

    NOTE: The class driver will handle all power messages
        the port driver should only see D-State messages

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN setD0 = FALSE;
    BOOLEAN handledByClass = FALSE;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    DBCUSB_IncrementIoCount(DeviceObject);

    // let the class driver have a peek at the 
    // power Irp
    ntStatus = DBCLASS_ClassDispatch(
            DeviceObject,
            Irp,
            &handledByClass);          

    if (handledByClass) {  
        DBCUSB_DecrementIoCount(DeviceObject);           
        return ntStatus;
    }
     
    //
    // We must handle the D state messages, the class driver
    // makes sure we only see changes from the current state
    // it also inteprets all the nasty wake rules so that the 
    // code remains as simple as possible
    //
    
    //
    // these asserts mean we have a bug in the class driver
    // please 'fix' the class driver not this driver
    //
    DBCUSB_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    DBCUSB_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
    DBCUSB_ASSERT(deviceExtension->CurrentDevicePowerState != 
                  irpStack->Parameters.Power.State.DeviceState);
    
    deviceExtension->CurrentDevicePowerState = 
        irpStack->Parameters.Power.State.DeviceState;
    
    IoCopyCurrentIrpStackLocationToNext(Irp);
    
    PoStartNextPowerIrp(Irp);
    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    DBCUSB_DecrementIoCount(DeviceObject);

    return ntStatus;
}


NTSTATUS
DBCUSB_Pnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT stackDeviceObject;
    BOOLEAN handledByClass = FALSE;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    DBCUSB_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);
    
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

    DBCUSB_IncrementIoCount(DeviceObject);

    DBCUSB_KdPrint((1, "'IRP_MJ_PNP MN(0x%x)\n", irpStack->MinorFunction));        

    ntStatus = Irp->IoStatus.Status;
    
    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        {
        KEVENT event;

        DBCUSB_KdPrint((1, "'IRP_MN_START_DEVICE\n"));
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);  
        IoSetCompletionRoutine(Irp,
                               DBCUSB_DeferIrpCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);


        ntStatus = IoCallDriver(stackDeviceObject,
                                Irp);
            
        if (ntStatus == STATUS_PENDING) {
             // wait for irp to complete
       
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);

            ntStatus = Irp->IoStatus.Status;                
        }

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = DBCUSB_StartDevice(DeviceObject);

            if (NT_SUCCESS(ntStatus)) {
                ntStatus = DBCLASS_ClassDispatch(
                        DeviceObject,
                        Irp,
                        &handledByClass);                               

                DBCUSB_ASSERT(handledByClass == FALSE);                       
            }                

            // set irp to the status of the start
            Irp->IoStatus.Status = ntStatus;

            deviceExtension->Flags &= ~DBCUSB_FLAG_STOPPED;
            //
            // transition to zero signals the event
            //
            DBCUSB_IncrementIoCount(DeviceObject);                                 

            deviceExtension->Flags |= DBCUSB_FLAG_STARTED;
        }  
#ifdef DBG        
          else {
            DBCUSB_KdPrint((0, "'Lower driver failed the START! (0x%x)\n", 
                    ntStatus));            
            TRAP();                    
        } 
#endif

        goto DBCUSB_Dispatch_CompleteRequest;
        }
        break;

    case IRP_MN_STOP_DEVICE:
        
        DBCUSB_KdPrint((1, "'IRP_MN_STOP_DEVICE\n"));
                
        ntStatus = DBCLASS_ClassDispatch(
            DeviceObject,
            Irp,
            &handledByClass);          
            
        DBCUSB_ASSERT(handledByClass == FALSE);  

        // match the inc at the begining of the dispatch
        // routine            
        DBCUSB_DecrementIoCount(DeviceObject);

        ntStatus = DBCUSB_StopDevice(DeviceObject);

        deviceExtension->Flags |= DBCUSB_FLAG_STOPPED;
        // note that in the complex world of PnP 
        // not being started is not the same 
        // as being stopped
        deviceExtension->Flags &= ~DBCUSB_FLAG_STARTED;

        IoCopyCurrentIrpStackLocationToNext(Irp);

        ntStatus = IoCallDriver(stackDeviceObject,
                                Irp);
                                
        goto DBCUSB_Dispatch_Done;
        break;

    case IRP_MN_REMOVE_DEVICE:

        DBCUSB_KdPrint((1, "'IRP_MN_REMOVE_DEVICE\n"));
        
        ntStatus = DBCLASS_ClassDispatch(
            DeviceObject,
            Irp,
            &handledByClass);          
            
        DBCUSB_ASSERT(handledByClass == FALSE);  

        // match the inc at the begining of the dispatch
        // routine            
        DBCUSB_DecrementIoCount(DeviceObject);

        if (!(deviceExtension->Flags & DBCUSB_FLAG_STOPPED)) {
            ntStatus = DBCUSB_StopDevice(DeviceObject);
            // note that in the complex world of PnP 
            // not being started is not the same 
            // as being stopped
            deviceExtension->Flags &= ~DBCUSB_FLAG_STARTED;
        }            

        // pass down the remove
        IoCopyCurrentIrpStackLocationToNext(Irp);  
        ntStatus = IoCallDriver(stackDeviceObject,
                                Irp);

        // Un-register with the Class Driver
        DBCLASS_UnRegisterController(
                DeviceObject,
                deviceExtension->TopOfStackDeviceObject);                                

        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);

        IoDeleteDevice (DeviceObject);
        DBCUSB_KdPrint((1, "'>REMOVE DONE\n"));

        goto DBCUSB_Dispatch_Done;
        
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        DBCUSB_KdPrint((1, "'IRP_MN_QUERY_STOP_DEVICE\n"));
        break;
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DBCUSB_KdPrint((1, "'IRP_MN_QUERY_REMOVE_DEVICE\n"));
        break;
    case IRP_MN_CANCEL_STOP_DEVICE:
        DBCUSB_KdPrint((1, "'IRP_MN_CANCEL_STOP_DEVICE\n"));
        break;
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        DBCUSB_KdPrint((1, "'IRP_MN_CANCEL_REMOVE_DEVICE\n"));
        break;
    case IRP_MN_QUERY_CAPABILITIES:
    {
        KEVENT event;
        PDEVICE_CAPABILITIES pDevCaps;

        DBCUSB_KdPrint((1, "'IRP_MN_QUERY_CAPABILITIES\n"));


        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);  
        IoSetCompletionRoutine(Irp,
                               DBCUSB_DeferIrpCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);


        ntStatus = IoCallDriver(stackDeviceObject,
                                Irp);
            
        if (ntStatus == STATUS_PENDING) {
             // wait for irp to complete
       
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);

            ntStatus = Irp->IoStatus.Status;                
        }

        //
        // Set surprise removal O.K.
        //

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        pDevCaps = irpStack->Parameters.DeviceCapabilities.Capabilities;

        pDevCaps->SurpriseRemovalOK   = TRUE;

        goto DBCUSB_Dispatch_CompleteRequest;

    }
    break;

    default:
        DBCUSB_KdPrint((1,"'PnP IOCTL not handled 0x%x\n", irpStack->MinorFunction));
    } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */


    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // All PNP_POWER messages get passed to the TopOfStackDeviceObject
    // we were given in PnPAddDevice
    //

    DBCUSB_DecrementIoCount(DeviceObject);

    ntStatus = IoCallDriver(stackDeviceObject,
                            Irp);

    goto DBCUSB_Dispatch_Done;

DBCUSB_Dispatch_CompleteRequest:

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT);

    DBCUSB_DecrementIoCount(DeviceObject);

DBCUSB_Dispatch_Done:

    return ntStatus;
}


NTSTATUS
DBCUSB_Ioctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    BOOLEAN handledByClass = FALSE;
    PIO_STACK_LOCATION ioStackLocation; 
    
    DBCUSB_IncrementIoCount(DeviceObject);

    ntStatus = DBCLASS_ClassDispatch(
                DeviceObject,
                Irp,
                &handledByClass);   

    if (!handledByClass) {

        // we need to handle this IRP
        
        ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

        switch (ioStackLocation->MajorFunction) {
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            {
            ULONG ioControlCode;

            ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
            switch (ioControlCode) {
            
            case IOCTL_INTERNAL_DBC_SUBMIT_DRB:
                DBCUSB_KdPrint((2,"'Handle DRB\n"));
                ntStatus = DBCUSB_ProcessDrb(DeviceObject,
                                              Irp);

                if (ntStatus == STATUS_PENDING) {
                    // we queued the irp, don't complete 
                    // it here
                    return ntStatus;                                    
                }                    
                break;
            default:            
                ntStatus = STATUS_NOT_SUPPORTED;                                      
            } /* ioControlCode */           
            }
            break;
        default:
            ntStatus = STATUS_NOT_SUPPORTED;    
            break;
        } /* ioStackLocation->MajorFunction */

        DBCUSB_DecrementIoCount(DeviceObject);
        
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp,
                           IO_NO_INCREMENT);
    } else {
        DBCUSB_DecrementIoCount(DeviceObject);
    }
                                          
    return ntStatus;
}


NTSTATUS
DBCUSB_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    NTSTATUS ntStatus;
    BOOLEAN handledByClass = FALSE;
    
    TEST_TRAP();

    DBCUSB_IncrementIoCount(DeviceObject);
        
    ntStatus = DBCLASS_ClassDispatch(
                DeviceObject,
                Irp,
                &handledByClass);   

    // class driver should handle all system control
    DBCUSB_ASSERT(handledByClass == TRUE);
    
    DBCUSB_DecrementIoCount(DeviceObject);
    
    return ntStatus;
}




VOID
DBCUSB_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
}


NTSTATUS
DBCUSB_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device

Arguments:

    DriverObject - pointer to the driver object for this instance of DBCUSB

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;

    //
    // create our funtional device object (FDO)
    //
#if DBG
    DBCUSB_GetClassGlobalDebugRegistryParameters();
#endif  

    if (NT_SUCCESS(ntStatus)) {
        ntStatus =
            DBCUSB_CreateDeviceObject(DriverObject, &deviceObject);
    }                    

    if (NT_SUCCESS(ntStatus)) {
        deviceExtension = deviceObject->DeviceExtension;

        deviceExtension->FdoDeviceObject = deviceObject;
        
        //
        // we support direct io for read/write
        //
        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        //** initialize our device extension
        deviceExtension->Sig = DBCUSB_EXT_SIG;
        deviceExtension->Flags = 0;
        
        //
        // remember the Physical device Object
        //
        deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

        //
        // Attach to the PDO
        //

        deviceExtension->TopOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        DBCUSB_QueryCapabilities(PhysicalDeviceObject,
                                 &deviceExtension->DeviceCapabilities);            

        //
        // display the device  caps
        //
#if DBG
        {
        ULONG i;
        
        DBCUSB_KdPrint((1, "'>>>>>> DeviceCaps\n"));  
        DBCUSB_KdPrint((1, "'SystemWake = (%d)\n", 
            deviceExtension->DeviceCapabilities.SystemWake));    
        DBCUSB_KdPrint((1, "'DeviceWake = (D%d)\n",
                deviceExtension->DeviceCapabilities.DeviceWake-1));

        for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++) {
            
            DBCUSB_KdPrint((1, "'Device State Map: sysstate %d = devstate 0x%x\n", i, 
                 deviceExtension->DeviceCapabilities.DeviceState[i]));       
        }
        DBCUSB_KdPrint((1, "'<<<<<<<<DeviceCaps\n"));
        }
#endif

        // Register with the Class Driver
        DBCLASS_RegisterController(
            DBCLASS_VERSION,
            deviceObject, 
            deviceExtension->TopOfStackDeviceObject,
            deviceExtension->PhysicalDeviceObject,
            DBC_USB_CONTROLLER_SIG);                                
                    

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return ntStatus;
}


NTSTATUS
DBCUSB_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
                    created device object.

    Instance - instnace of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    WCHAR deviceNameBuffer[]  = L"\\Device\\DBCUSB-0";
    UNICODE_STRING deviceNameUnicodeString;
    ULONG i = 0;

    //  do we need a name?
    do {

        deviceNameBuffer[15] = (USHORT) ('0' + i);

        RtlInitUnicodeString (&deviceNameUnicodeString,
                              deviceNameBuffer);

        ntStatus = IoCreateDevice (DriverObject,
                                   sizeof (DEVICE_EXTENSION),
                                   &deviceNameUnicodeString,
                                   FILE_DEVICE_UNKNOWN,
                                   0,
                                   FALSE,
                                   DeviceObject);

        i++;
        
    } while (!NT_SUCCESS(ntStatus));

    return ntStatus;
}


LONG
DBCUSB_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    LONG ioCount;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    ioCount = InterlockedDecrement(&deviceExtension->PendingIoCount);

    DBCUSB_KdPrint ((2, "'Dec Pending io count = %x\n", ioCount));

    if (ioCount==0 && 
        (deviceExtension->Flags & DBCUSB_FLAG_STARTED)) {
        KeSetEvent(&deviceExtension->StopEvent,
                   1,
                   FALSE);
    }

    return ioCount;
}


VOID
DBCUSB_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    DBCUSB_ASSERT_EXT(deviceExtension);

    InterlockedIncrement(&deviceExtension->PendingIoCount);
}


NTSTATUS
DBCUSB_WaitWakeIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    
Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    DBCUSB_DecrementIoCount(DeviceObject);     
    
    return IoStatus->Status;
}    

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\codguts.c ===
/* ++
  * 
  * Copyright (c) 1996  Microsoft Corporation
  * 
  * Module Name:
  * 
  * codguts.c
  * 
  * Abstract:
  * 
  * This is the WDM streaming class driver.  This module contains code related
  * to internal processing.
  * 
  * Author:
  * 
  * billpa
  * 
  * Environment:
  * 
  * Kernel mode only
  * 
  * 
  * Revision History:
  * 
  * -- */

#include "codcls.h"
#include <stdlib.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SCBuildRequestPacket)
#pragma alloc_text(PAGE, SCProcessDmaDataBuffers)
#pragma alloc_text(PAGE, SCProcessPioDataBuffers)
#pragma alloc_text(PAGE, SCOpenMinidriverInstance)
#pragma alloc_text(PAGE, SCMinidriverDevicePropertyHandler)
#pragma alloc_text(PAGE, SCMinidriverStreamPropertyHandler)
#pragma alloc_text(PAGE, SCUpdateMinidriverProperties)
#pragma alloc_text(PAGE, SCProcessCompletedPropertyRequest)
#pragma alloc_text(PAGE, SCLogError)
#pragma alloc_text(PAGE, SCLogErrorWithString)
#pragma alloc_text(PAGE, SCReferenceDriver)
#pragma alloc_text(PAGE, SCDereferenceDriver)
#pragma alloc_text(PAGE, SCReadRegistryValues)
#pragma alloc_text(PAGE, SCGetRegistryValue)
#pragma alloc_text(PAGE, SCSubmitRequest)
#pragma alloc_text(PAGE, SCProcessDataTransfer)
#pragma alloc_text(PAGE, SCShowIoPending)
#pragma alloc_text(PAGE, SCCheckPoweredUp)
#pragma alloc_text(PAGE, SCCheckPowerDown)
#pragma alloc_text(PAGE, SCCallNextDriver)
#pragma alloc_text(PAGE, SCSendUnknownCommand)
#pragma alloc_text(PAGE, SCMapMemoryAddress)
#pragma alloc_text(PAGE, SCUpdatePersistedProperties)
#pragma alloc_text(PAGE, SCProcessCompletedPropertyRequest)
#pragma alloc_text(PAGE, SCUpdateMinidriverEvents)
#pragma alloc_text(PAGE, SCQueryCapabilities)
#pragma alloc_text(PAGE, SCRescanStreams)
#pragma alloc_text(PAGE, SCCopyMinidriverProperties)
#pragma alloc_text(PAGE, SCCopyMinidriverEvents)
#endif

#ifdef ENABLE_KS_METHODS
#pragma alloc_text(PAGE, SCCopyMinidriverMethods)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

extern KSDISPATCH_TABLE FilterDispatchTable;

//
// registry string indicating that the minidriver should be paged out when
// unopened
//

static const WCHAR PageOutWhenUnopenedString[] = L"PageOutWhenUnopened";

//
// registry string indicating that the minidriver should be paged out when
// idle
//

static const WCHAR PageOutWhenIdleString[] = L"PageOutWhenIdle";

//
// registry string indicating that the device should be powered down when
// unopened
//

static const WCHAR PowerDownWhenUnopenedString[] = L"PowerDownWhenUnopened";

//
// registry string indicating that the device should not be suspended when
// pins are in run state
//

static const WCHAR DontSuspendIfStreamsAreRunning[] = L"DontSuspendIfStreamsAreRunning";

//
// This driver uses SWEnum to load, which means it is a kernel mode
// streaming driver that has no hardware associated with it. We need to
// AddRef/DeRef this driver special.
//

static const WCHAR DriverUsesSWEnumToLoad[] = L"DriverUsesSWEnumToLoad";

//
//
//

static const WCHAR OkToHibernate[] = L"OkToHibernate";

//
// array of registry settings to be read when the device is initialized
//

static const STREAM_REGISTRY_ENTRY RegistrySettings[] = {
    {
        (PWCHAR) PageOutWhenUnopenedString,
        sizeof(PageOutWhenUnopenedString),
        DEVICE_REG_FL_PAGE_CLOSED
    },

    {
        (PWCHAR) PageOutWhenIdleString,
        sizeof(PageOutWhenIdleString),
        DEVICE_REG_FL_PAGE_IDLE
    },

    {
        (PWCHAR) PowerDownWhenUnopenedString,
        sizeof(PowerDownWhenUnopenedString),
        DEVICE_REG_FL_POWER_DOWN_CLOSED
    },

    {
        (PWCHAR) DontSuspendIfStreamsAreRunning,
        sizeof(DontSuspendIfStreamsAreRunning),
        DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING
    },

    {
        (PWCHAR) DriverUsesSWEnumToLoad,
        sizeof(DriverUsesSWEnumToLoad),
        DRIVER_USES_SWENUM_TO_LOAD
    },
    
    {
        (PWCHAR) OkToHibernate,
        sizeof(OkToHibernate),
        DEVICE_REG_FL_OK_TO_HIBERNATE
    }
};

//
// this structure indicates the handlers for CreateFile on Streams
//

static const WCHAR PinTypeName[] = KSSTRING_Pin;

static const KSOBJECT_CREATE_ITEM CreateHandlers[] = {

    DEFINE_KSCREATE_ITEM(StreamDispatchCreate,
                         PinTypeName,
                         0)
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Routines start
//

NTSTATUS
SCDequeueAndStartStreamDataRequest(
                                   IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Start the queued data IRP for the stream.
    THE SPINLOCK MUST BE TAKEN ON THIS CALL AND A DATA IRP MUST BE ON THE
    QUEUE!


Arguments:

    StreamObject - address of stream info structure.

Return Value:

    NTSTATUS returned

--*/

{
    PIRP            Irp;
    PSTREAM_REQUEST_BLOCK Request;
    PLIST_ENTRY     Entry;
    BOOLEAN         Status;
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Entry = RemoveTailList(&StreamObject->DataPendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(Irp);

//    ASSERT((IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                       IOCTL_KS_READ_STREAM) ||
//            (IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                        IOCTL_KS_WRITE_STREAM));
    ASSERT((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] > 0x40000000);


    DebugPrint((DebugLevelVerbose, "'SCStartStreamDataReq: Irp = %x, S# = %x\n",
                Irp, StreamObject->HwStreamObject.StreamNumber));

    //
    // clear the ready flag as we are going to send one down.
    //

    ASSERT(StreamObject->ReadyForNextDataReq);

    StreamObject->ReadyForNextDataReq = FALSE;

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    //
    // build scatter/gather list if necessary
    //

    if (StreamObject->HwStreamObject.Dma) {

        //
        // allocate the adapter channel. call cannot fail as the only
        // time it would is when there aren't enough map registers, and
        // we've already checked for that condition.
        //

        Status = SCSetUpForDMA(DeviceExtension->DeviceObject,
                               Request);
        ASSERT(Status);

        //
        // DMA adapter allocation requires a
        // callback, so just exit
        //

        return (STATUS_PENDING);

    }                           // if DMA
    //
    // start the request for the PIO case.
    //

    SCStartMinidriverRequest(StreamObject,
                             Request,
                             (PVOID)
                             StreamObject->HwStreamObject.ReceiveDataPacket);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    return (STATUS_PENDING);

}



NTSTATUS
SCDequeueAndStartStreamControlRequest(
                                      IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Start the queued control IRP for the stream.
    THE SPINLOCK MUST BE TAKEN ON THIS CALL AND A DATA IRP MUST BE ON THE
    QUEUE!


Arguments:

    StreamObject - address of stream info structure.

Return Value:

    NTSTATUS returned

--*/

{
    PIRP            Irp;
    PSTREAM_REQUEST_BLOCK Request;
    PLIST_ENTRY     Entry;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    Entry = RemoveTailList(&StreamObject->ControlPendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(Irp);
    DebugPrint((DebugLevelTrace, "'SCStartStreamControlReq: Irp = %x, S# = %x\n",
                Irp, StreamObject->HwStreamObject.StreamNumber));

    //
    // clear the ready flag as we are going
    // to send one down.
    //

    ASSERT(StreamObject->ReadyForNextControlReq);

    StreamObject->ReadyForNextControlReq = FALSE;

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&StreamObject->DeviceExtension->SpinLock);

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    //
    // start the request.
    //

    SCStartMinidriverRequest(StreamObject,
                             Request,
                             (PVOID)
                         StreamObject->HwStreamObject.ReceiveControlPacket);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    return (STATUS_PENDING);

}



NTSTATUS
SCDequeueAndStartDeviceRequest(
                               IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Start the queued device IRP.
    THE DEV SPINLOCK MUST BE TAKEN ON THIS CALL AND AN IRP MUST BE ON THE QUEUE!


Arguments:

    DeviceExtension - address of device extension.

Return Value:

    NTSTATUS

--*/

{
    PIRP            Irp;
    PLIST_ENTRY     Entry;
    PSTREAM_REQUEST_BLOCK Request;

    Entry = RemoveTailList(&DeviceExtension->PendingQueue);
    Irp = CONTAINING_RECORD(Entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(Irp);

    //
    // clear the ready flag as we are going
    // to send one down.
    //

    ASSERT(DeviceExtension->ReadyForNextReq);

    DeviceExtension->ReadyForNextReq = FALSE;

    //
    // get the request packet from the IRP
    //

    Request = Irp->Tail.Overlay.DriverContext[0];

    ASSERT(Request);

    //
    // show that the request is active.
    //

    Request->Flags |= SRB_FLAGS_IS_ACTIVE;

    //
    // place the request on the outstanding
    // queue
    //

    InsertHeadList(
                   &DeviceExtension->OutstandingQueue,
                   &Request->SRBListEntry);

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // send down the request to the
    // minidriver.
    //

    DebugPrint((DebugLevelTrace, "'SCDequeueStartDevice: starting Irp %x, SRB = %x, Command = %x\n",
                Request->HwSRB.Irp, Request, Request->HwSRB.Command));

    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
        (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket,
                                          &Request->HwSRB);

    //
    // release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    return (STATUS_PENDING);
}



PSTREAM_REQUEST_BLOCK
SCBuildRequestPacket(
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PIRP Irp,
                     IN ULONG AdditionalSize1,      // scatter gather size
                     IN ULONG AdditionalSize2       // saved ptr array size
)
/*++

Routine Description:

    Routine builds an SRB and fills in generic fields

Arguments:

    DeviceExtension - address of device extension.
    Irp - Address of I/O request packet.
    AdditionalSize1 - additional size needed for scatter/gather, etc.
    AdditionalSize2 - additional size needed for the Saved pointer array.

Return Value:

    Address of the streaming request packet.

--*/

{
    ULONG           BlockSize;
    PSTREAM_REQUEST_BLOCK Request;

    PAGED_CODE();

    //
    // compute the size of the block needed.
    //

    BlockSize = sizeof(STREAM_REQUEST_BLOCK) +
        DeviceExtension->
        MinidriverData->HwInitData.PerRequestExtensionSize +
        AdditionalSize1+
        AdditionalSize2;

    Request = ExAllocatePool(NonPagedPool, BlockSize);

    if (Request == NULL) {
        DebugPrint((DebugLevelError,
                    "SCBuildRequestPacket: No pool for packet"));
        ASSERT(0);
        return (NULL);
    }
    //
    // alloc MDL for the request.
    //
    // GUBGUB  This a marginal performace enhancment chance. 
    // - should find a way to avoid allocating both an MDL and
    // SRB per request.   Maybe have a list of MDL's around and allocate only
    // if we run out.   Forrest won't like this.
    //
    //

    Request->Mdl = IoAllocateMdl(Request,
                                 BlockSize,
                                 FALSE,
                                 FALSE,
                                 NULL
        );

    if (Request->Mdl == NULL) {
        ExFreePool(Request);
        DebugPrint((DebugLevelError,
                    "SCBuildRequestPacket: can't get MDL"));
        return (NULL);
    }
    MmBuildMdlForNonPagedPool(Request->Mdl);

    //
    // fill in the various SRB fields
    // generically
    //

    Request->Length = BlockSize;
    Request->HwSRB.SizeOfThisPacket = sizeof(HW_STREAM_REQUEST_BLOCK);

    Request->HwSRB.Status = STATUS_PENDING;
    Request->HwSRB.StreamObject = NULL;
    Request->HwSRB.HwInstanceExtension = NULL;
    Request->HwSRB.NextSRB = (PHW_STREAM_REQUEST_BLOCK) NULL;
    Request->HwSRB.SRBExtension = Request + 1;
    Request->HwSRB.Irp = Irp;
    Request->Flags = 0;
    Request->MapRegisterBase = 0;
    Request->HwSRB.Flags = 0;
    Request->HwSRB.TimeoutCounter = 15;
    Request->HwSRB.TimeoutOriginal = 15;
    Request->HwSRB.ScatterGatherBuffer =
        (PKSSCATTER_GATHER) ((ULONG_PTR) Request->HwSRB.SRBExtension +
                             (ULONG_PTR) DeviceExtension->
                        MinidriverData->HwInitData.PerRequestExtensionSize);

    Request->pMemPtrArray = (PVOID) (((ULONG_PTR) Request->HwSRB.SRBExtension +
                            (ULONG_PTR) DeviceExtension->
                            MinidriverData->HwInitData.PerRequestExtensionSize) +
                            AdditionalSize1);
    //
    // point the IRP workspace to the request
    // packet
    //

    Irp->Tail.Overlay.DriverContext[0] = Request;

    return (Request);

}                               // end SCBuildRequestPacket()

VOID
SCProcessDmaDataBuffers(
                     IN PKSSTREAM_HEADER FirstHeader,
                     IN ULONG NumberOfHeaders,
                     IN PSTREAM_OBJECT StreamObject,
                     IN PMDL FirstMdl,
                     OUT PULONG NumberOfPages,
                     IN ULONG StreamHeaderSize,
                     IN BOOLEAN Write

)
/*++

Routine Description:

    Processes each data buffer for PIO &| DMA case

Arguments:

    FirstHeader - Address of the 1st s/g packet
    StreamObject- pointer to stream object
    NumberOfPages - number of pages in the request

Return Value:

--*/

{
    PKSSTREAM_HEADER CurrentHeader;
    PMDL            CurrentMdl;
    ULONG           i;
    ULONG           DataBytes;
    
    PAGED_CODE();

    //
    // loop through each scatter/gather elements
    //

    CurrentHeader = FirstHeader;
    CurrentMdl = FirstMdl;

    for (i = 0; i < NumberOfHeaders; i++) {

        //
        // pick up the correct data buffer, based on the xfer direction
        //

        if (Write) {

            DataBytes = CurrentHeader->DataUsed;

        } else {                // if write

            DataBytes = CurrentHeader->FrameExtent;

        }                       // if write

        //
        // if this header has data, process it.
        //

        if (DataBytes) {
            #if DBG
            if (CurrentHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                DebugPrint((DebugLevelVerbose, "'SCProcessData: time = %x\n",
                            CurrentHeader->PresentationTime.Time));
            }
            #endif
            //
            // add # pages to total if DMA
            //
            *NumberOfPages += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                         MmGetMdlVirtualAddress(CurrentMdl),
                                                                 DataBytes);
            CurrentMdl = CurrentMdl->Next;
        }
        //
        // offset to the next buffer
        //

        CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                             StreamHeaderSize));

    }                           // for # elements

}                               // end SCProcessDmaDataBuffers()

//
// mmGetSystemAddressForMdl() is defined as a macro in wdm.h which
// calls mmMapLockedPages() which is treated as an evil by verifier.
// mmMapLockedPages is reimplemented by mm via
// mmMapLockedPagesSpecifyCache(MDL,Mode,mmCaches,NULL,TRUE,HighPriority)
// where TRUE is to indicate a bug check, should the call fails.
// I don't need the bug check, therefore, I specify FALSE below.
//

#ifdef WIN9X_STREAM
#define SCGetSystemAddressForMdl(MDL) MmGetSystemAddressForMdl(MDL)

#else
#define SCGetSystemAddressForMdl(MDL)                       \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |         \
            MDL_SOURCE_IS_NONPAGED_POOL)) ?                 \
                  ((MDL)->MappedSystemVa) :                 \
                  (MmMapLockedPagesSpecifyCache((MDL),      \
                                    KernelMode,             \
                                    MmCached,               \
                                    NULL,                   \
                                    FALSE,                  \
                                    HighPagePriority)))
#endif                                    

BOOLEAN
SCProcessPioDataBuffers(
                     IN PKSSTREAM_HEADER FirstHeader,
                     IN ULONG NumberOfHeaders,
                     IN PSTREAM_OBJECT StreamObject,
                     IN PMDL FirstMdl,
                     IN ULONG StreamHeaderSize,
                     IN PVOID *pDataPtrArray,
                     IN BOOLEAN Write
)
/*++

Routine Description:

    Processes each data buffer for PIO &| DMA case

Arguments:

    FirstHeader - Address of the 1st s/g packet
    StreamObject- pointer to stream object
    NumberOfPages - number of pages in the request

Return Value:

--*/

{
    PKSSTREAM_HEADER CurrentHeader;
    PMDL            CurrentMdl;
    ULONG           i;
    ULONG           DataBytes;
    BOOLEAN         ret = FALSE;

    PAGED_CODE();

    //
    // loop through each scatter/gather elements
    //

    CurrentHeader = FirstHeader;
    CurrentMdl = FirstMdl;

    for (i = 0; i < NumberOfHeaders; i++) {

        //
        // pick up the correct data buffer, based on the xfer direction
        //

        if (Write) {

            DataBytes = CurrentHeader->DataUsed;

        } else {                // if write

            DataBytes = CurrentHeader->FrameExtent;

        }                       // if write

        //
        // if this header has data, process it.
        //

        if (DataBytes) {
            //
            // fill in the system virtual pointer
            // to the buffer if mapping is
            // needed
            //

            #if (DBG)
            if ( 0 !=  ( CurrentMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |
                    MDL_SOURCE_IS_NONPAGED_POOL))) {

                ASSERT(CurrentHeader->Data == (PVOID) ((ULONG_PTR) CurrentMdl->StartVa +
                                                   CurrentMdl->ByteOffset));                
            }
            #endif
            
            DebugPrint((DebugLevelVerbose, "Saving: Index:%x, Ptr:%x\n",
                i, CurrentHeader->Data));

            ret = TRUE;
            pDataPtrArray[i] = CurrentHeader->Data;
            CurrentHeader->Data = SCGetSystemAddressForMdl(CurrentMdl);

            DebugPrint((DebugLevelVerbose, "'SCPio: buff = %x, length = %x\n",
                        CurrentHeader->Data, DataBytes));
           
            CurrentMdl = CurrentMdl->Next;
        }
        //
        // offset to the next buffer
        //

        CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                             StreamHeaderSize));

    }                           // for # elements

    return(ret);
}                               // end SCProcessPioDataBuffers()


BOOLEAN
SCSetUpForDMA(
              IN PDEVICE_OBJECT DeviceObject,
              IN PSTREAM_REQUEST_BLOCK Request

)
/*++

Routine Description:

    process read/write DMA request.  allocate adapter channel.

Arguments:

    DeviceObject - device object for the device
    Request - address of Codec Request Block

Return Value:

    returns TRUE if channel is allocated

--*/

{
    NTSTATUS        status;

    //
    // Allocate the adapter channel with sufficient map registers
    // for the transfer.
    //

    status = IoAllocateAdapterChannel(
    ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->DmaAdapterObject,
                                      DeviceObject,
                                   Request->HwSRB.NumberOfPhysicalPages + 1,    // one more for the SRB
    // extension
                                      StreamClassDmaCallback,
                                      Request);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }
    return TRUE;

}


IO_ALLOCATION_ACTION
StreamClassDmaCallback(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP InputIrp,
                       IN PVOID MapRegisterBase,
                       IN PVOID Context
)
/*++

Routine Description:

    continues to process read/write request after DMA adapter is allocated
     builds scatter/gather list from logical buffer list.

Arguments:

     DeviceObject - dev object for adapter
     InputIrp - bogus
     MapRegisterBase - base address of map registers
     Context - address of Codec Request Block

Return Value:

     returns the appropriate I/O allocation action.

--*/

{
    PSTREAM_REQUEST_BLOCK Request = Context;
    PKSSCATTER_GATHER scatterList;
    BOOLEAN         writeToDevice;
    PVOID           dataVirtualAddress;
    ULONG           totalLength,
                    NumberOfBuffers;
    PIRP            Irp = Request->HwSRB.Irp;

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                Request->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PMDL            CurrentMdl;
    ULONG           NumberOfElements = 0;

    //
    // Save the MapRegisterBase for later use
    // to deallocate the map
    // registers.
    //

    Request->MapRegisterBase = MapRegisterBase;

    //
    // determine whether this is a write request
    //

    writeToDevice = Request->HwSRB.Command == SRB_WRITE_DATA ? TRUE : FALSE;

    scatterList = Request->HwSRB.ScatterGatherBuffer;

    NumberOfBuffers = Request->HwSRB.NumberOfBuffers;

    ASSERT(Irp);

    CurrentMdl = Irp->MdlAddress;

    while (CurrentMdl) {

        //
        // Determine the virtual address of the buffer
        //

        dataVirtualAddress = (PSCHAR) MmGetMdlVirtualAddress(CurrentMdl);

        //
        // flush the buffers since we are doing DMA.
        //

        KeFlushIoBuffers(CurrentMdl,
        (BOOLEAN) (Request->HwSRB.Command == SRB_WRITE_DATA ? TRUE : FALSE),
                         TRUE);

        //
        // Build the scatter/gather list by looping through the buffers
        // calling I/O map transfer.
        //

        totalLength = 0;

        while (totalLength < CurrentMdl->ByteCount) {

            NumberOfElements++;

            //
            // Request that the rest of the transfer be mapped.
            //

            scatterList->Length = CurrentMdl->ByteCount - totalLength;

            //
            // Since we are a master call I/O map transfer with a NULL
            // adapter.
            //

            scatterList->PhysicalAddress = IoMapTransfer(((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))
                                                         ->DmaAdapterObject,
                                                         CurrentMdl,
                                                         MapRegisterBase,
                                                 (PSCHAR) dataVirtualAddress
                                                         + totalLength,
                                                       &scatterList->Length,
                                                         writeToDevice);

            DebugPrint((DebugLevelVerbose, "'SCDma: seg = %x'%x, length = %x\n",
                scatterList->PhysicalAddress.HighPart,
                scatterList->PhysicalAddress.LowPart,
                scatterList->Length));

            totalLength += scatterList->Length;
            scatterList++;
        }


        CurrentMdl = CurrentMdl->Next;

    }                           // while CurrentMdl

    Request->HwSRB.NumberOfScatterGatherElements = NumberOfElements;

    //
    // now map the transfer for the SRB in case the minidriver needs the
    // physical address of the extension.
    //
    // NOTE:  This function changes the length field in the SRB, which
    // makes it invalid.   It is not used elsewhere, however.
    //
    // We must flush the buffers appropriately as the SRB extension
    // may be DMA'ed both from and to. According to JHavens, we want to
    // tell IOMapXfer and KeFlushIoBuffers that this is a write, and upon
    // completion tell IoFlushAdapterBuffers that this is a read.
    //
    // Need to investigate if doing these extra calls add more overhead than
    // maintaining a queue of SRB's & extensions.   However, on x86
    // platforms the KeFlush call gets compiled out and
    // on PCI systems the IoFlush call doesn't get made, so there is no
    // overhead on these system except the map xfer call.
    //

    //
    // flush the SRB buffer since we are doing DMA.
    //

    KeFlushIoBuffers(Request->Mdl,
                     FALSE,
                     TRUE);

    //
    // get the physical address of the SRB
    //

    Request->PhysicalAddress = IoMapTransfer(((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))
                                             ->DmaAdapterObject,
                                             Request->Mdl,
                                             MapRegisterBase,
                                             (PSCHAR) MmGetMdlVirtualAddress(
                                                              Request->Mdl),
                                             &Request->Length,
                                             TRUE);

    //
    // if we are async, signal the event which will cause the request to be
    // called down on the original thread; otherwise, send the request down
    // now at dispatch level.
    //


    if (((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->NoSync) {

        KeSetEvent(&Request->DmaEvent, IO_NO_INCREMENT, FALSE);

    } else {

        //
        // send the request to the minidriver
        //

        SCStartMinidriverRequest(StreamObject,
                                 Request,
                                 (PVOID)
                            StreamObject->HwStreamObject.ReceiveDataPacket);

    }                           // if nosync

    //
    // keep the map registers but release the I/O adapter channel
    //

    return (DeallocateObjectKeepRegisters);
}



VOID
SCStartMinidriverRequest(
                         IN PSTREAM_OBJECT StreamObject,
                         IN PSTREAM_REQUEST_BLOCK Request,
                         IN PVOID EntryPoint
)
/*++

Routine Description:

    adds request to outstanding queue and starts the minidriver.

Arguments:

     StreamObject - Address stream info struct
     Request - Address of streaming data packet
     EntryPoint - Minidriver routine to be called

Return Value:

--*/

{
    PIRP            Irp = Request->HwSRB.Irp;
    PDEVICE_EXTENSION DeviceExtension =
    StreamObject->DeviceExtension;

    //
    // show that the request is active.
    //

    Request->Flags |= SRB_FLAGS_IS_ACTIVE;

    //
    // place the request on the outstanding queue
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    InsertHeadList(
                   &DeviceExtension->OutstandingQueue,
                   &Request->SRBListEntry);

    //
    // set the cancel routine to outstanding
    //

    IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

    //
    // send down the request to the minidriver.  Protect the call with the
    // device spinlock to synchronize timers, etc.
    //

#if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
#endif

    DebugPrint((DebugLevelTrace, "'SCStartMinidriverRequeest: starting Irp %x, S# = %x, SRB = %x, Command = %x\n",
                Request->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber, Request, Request->HwSRB.Command));


    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          EntryPoint,
                                          &Request->HwSRB);


#if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
#endif

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    return;

}                               // SCStartMinidriverRequest



VOID
StreamClassDpc(
               IN PKDPC Dpc,
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context
)
/*++

Routine Description:

    this routine processes requests and notifications from the minidriver

Arguments:

    Dpc - pointer to Dpc structure
    DeviceObject - device object for the adapter
    Irp - not used
    Context - StreamObject structure

Return Value:

    None.

--*/

{
    PSTREAM_OBJECT  StreamObject = Context,
                    NeedyStream;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA  SavedStreamInterruptData;
    INTERRUPT_DATA  SavedDeviceInterruptData;
    PSTREAM_REQUEST_BLOCK SRB;
    PERROR_LOG_ENTRY LogEntry;
    HW_TIME_CONTEXT TimeContext;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Dpc);

    interruptContext.SavedStreamInterruptData = &SavedStreamInterruptData;
    interruptContext.SavedDeviceInterruptData = &SavedDeviceInterruptData;
    interruptContext.DeviceExtension = DeviceExtension;

    DebugPrint((DebugLevelVerbose, "'StreamClassDpc: enter\n"));

    //
    // if a stream object is passed in, first
    // check if work is pending
    //

    if (StreamObject) {

        SCStartRequestOnStream(StreamObject, DeviceExtension);

    }                           // if streamobject
RestartDpc:

    //
    // Check for a ready for next packet on
    // the device.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    if ((DeviceExtension->ReadyForNextReq) &&
        (!IsListEmpty(&DeviceExtension->PendingQueue))) {

        //
        // start the device request, which
        // clears the ready flag and
        // releases the spinlock.  Then
        // reacquire the spinloc.
        //

        SCDequeueAndStartDeviceRequest(DeviceExtension);
        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    }
    //
    // Get the interrupt state snapshot. This copies the interrupt state to
    // saved state where it can be processed. It also clears the interrupt
    // flags.  We acquired the device spinlock to protect the structure as
    // the minidriver could have requested a DPC call from this routine,
    // which could be preempted in the middle of minidriver's changing the
    // below structure, and we'd then take a snapshot of the structure while
    // it was changing.
    //

    interruptContext.NeedyStream = NULL;

    SavedDeviceInterruptData.CompletedSRB = NULL;
    SavedStreamInterruptData.CompletedSRB = NULL;
    SavedDeviceInterruptData.Flags = 0;
    SavedStreamInterruptData.Flags = 0;

    if (!DeviceExtension->SynchronizeExecution(DeviceExtension->InterruptObject,
                                               SCGetInterruptState,
                                               &interruptContext)) {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
        return;
    }
    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    NeedyStream = interruptContext.NeedyStream;

    if (NeedyStream) {

        //
        // try to start a request on this
        // stream
        //

        SCStartRequestOnStream(NeedyStream, DeviceExtension);

        //
        // Process any completed stream requests.
        //

        while (SavedStreamInterruptData.CompletedSRB != NULL) {

            //
            // Remove the request from the
            // linked-list.
            //

            SRB = CONTAINING_RECORD(SavedStreamInterruptData.CompletedSRB,
                                    STREAM_REQUEST_BLOCK,
                                    HwSRB);

            SavedStreamInterruptData.CompletedSRB = SRB->HwSRB.NextSRB;

            DebugPrint((DebugLevelTrace, "'SCDpc: Completing stream Irp %x, S# = %x, SRB = %x, Func = %x, Callback = %x, SRB->IRP = %x\n",
                   SRB->HwSRB.Irp, NeedyStream->HwStreamObject.StreamNumber,
                   SRB, SRB->HwSRB.Command, SRB->Callback, SRB->HwSRB.Irp));

            SCCallBackSrb(SRB, DeviceExtension);

        }

        //
        // Check for timer requests.
        //

        if (SavedStreamInterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) {

            SCProcessTimerRequest(&NeedyStream->ComObj,
                                  &SavedStreamInterruptData);
        }
        //
        // check to see if a change priority call has been requested.
        //

        if (SavedStreamInterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

            SCProcessPriorityChangeRequest(&NeedyStream->ComObj,
                                           &SavedStreamInterruptData,
                                           DeviceExtension);
        }
        //
        // Check for master clock queries.
        //

        if (SavedStreamInterruptData.Flags & INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST) {

            LARGE_INTEGER   ticks;
            ULONGLONG       rate;
            KIRQL           SavedIrql;

            //
            // call the master clock's entry point then call the minidriver's
            // callback procedure to report the time.
            //

            TimeContext.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
            TimeContext.HwStreamObject = &NeedyStream->HwStreamObject;
            TimeContext.Function = SavedStreamInterruptData.HwQueryClockFunction;

            //
            // take the lock so MasterCliockinfo won't disapear under us
            //
            KeAcquireSpinLock( &NeedyStream->LockUseMasterClock, &SavedIrql );

            if ( NULL == NeedyStream->MasterClockInfo ) {
                ASSERT( 0 && "Mini driver queries clock while we have no master clock");
                //
                // give a hint that something is wrong via Time, since we return void.
                //
                TimeContext.Time = (ULONGLONG)-1;
                goto callminidriver;
            }
                

            switch (SavedStreamInterruptData.HwQueryClockFunction) {

            case TIME_GET_STREAM_TIME:

                TimeContext.Time = NeedyStream->MasterClockInfo->
                    FunctionTable.GetCorrelatedTime(
                              NeedyStream->MasterClockInfo->ClockFileObject,
                                                    &TimeContext.SystemTime);

                goto callminidriver;

            case TIME_READ_ONBOARD_CLOCK:

                TimeContext.Time = NeedyStream->MasterClockInfo->
                    FunctionTable.GetTime(
                             NeedyStream->MasterClockInfo->ClockFileObject);

                //
                // timestamp the value as close as possible
                //

                ticks = KeQueryPerformanceCounter((PLARGE_INTEGER) & rate);

                TimeContext.SystemTime = KSCONVERT_PERFORMANCE_TIME( rate, ticks );
                    

        callminidriver:

                //
                // finish using MasterClockInfo.
                //
                
                KeReleaseSpinLock( &NeedyStream->LockUseMasterClock, SavedIrql );                            

                //
                // call the minidriver's callback procedure
                //


                if (!DeviceExtension->NoSync) {

                    //
                    // Acquire the device spinlock.
                    //

                    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                }
                DebugPrint((DebugLevelTrace, "'SCDPC: calling time func, S# = %x, Command = %x\n",
                            NeedyStream->HwStreamObject.StreamNumber, TimeContext.Function));

                DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                                      (PKSYNCHRONIZE_ROUTINE) SavedStreamInterruptData.HwQueryClockRoutine,
                                                      &TimeContext
                    );

                if (!DeviceExtension->NoSync) {

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                }
                break;


            default:
                KeReleaseSpinLock( &NeedyStream->LockUseMasterClock, SavedIrql );                            
                ASSERT(0);
            }                   // switch clock func
        }                       // if queryclock
    }                           // if needystream
    //
    // Check for an error log request.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_LOG_ERROR) {

        //
        // Process the error log request.
        //

        LogEntry = &SavedDeviceInterruptData.LogEntry;

        SCLogError(DeviceObject,
                   LogEntry->SequenceNumber,
                   LogEntry->ErrorCode,
                   LogEntry->UniqueId
            );

    }                           // if log error
    //
    // Process any completed device requests.
    //

    while (SavedDeviceInterruptData.CompletedSRB != NULL) {

        //
        // Remove the request from the linked-list.
        //

        SRB = CONTAINING_RECORD(SavedDeviceInterruptData.CompletedSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        SavedDeviceInterruptData.CompletedSRB = SRB->HwSRB.NextSRB;

        DebugPrint((DebugLevelTrace, "'SCDpc: Completing device Irp %x\n", SRB->HwSRB.Irp));

        SCCallBackSrb(SRB, DeviceExtension);
    }

    //
    // Check for device timer requests.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) {

        SCProcessTimerRequest(&DeviceExtension->ComObj,
                              &SavedDeviceInterruptData);
    }
    //
    // check if we have any dead events that need discarding.  if so, we'll
    // schedule a work item to get rid of them.
    //

    if ((!IsListEmpty(&DeviceExtension->DeadEventList)) &&
        (!(DeviceExtension->DeadEventItemQueued))) {

        DeviceExtension->DeadEventItemQueued = TRUE;

        ExQueueWorkItem(&DeviceExtension->EventWorkItem,
                        DelayedWorkQueue);
    }
    //
    // check to see if a change priority call
    // has been requested for the device.
    //

    if (SavedDeviceInterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        SCProcessPriorityChangeRequest(&DeviceExtension->ComObj,
                                       &SavedDeviceInterruptData,
                                       DeviceExtension);

    }                           // if change priority
    //
    // Check for stream rescan request.
    //

    if (SavedDeviceInterruptData.Flags & INTERRUPT_FLAGS_NEED_STREAM_RESCAN) {

        TRAP;
        ExQueueWorkItem(&DeviceExtension->RescanWorkItem,
                        DelayedWorkQueue);
    }
    //
    // Check for minidriver work requests. Note this is an unsynchronized
    // test on bits that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if ((DeviceExtension->NeedyStream)
        || (DeviceExtension->ComObj.InterruptData.Flags &
            INTERRUPT_FLAGS_NOTIFICATION_REQUIRED)) {

        //
        // Start over from the top.
        //

        DebugPrint((DebugLevelVerbose, "'StreamClassDpc: restarting\n"));
        goto RestartDpc;
    }
    return;

}                               // end StreamClassDpc()


VOID
SCStartRequestOnStream(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Routine tries to start either a control or data request on the specified
    stream.

Arguments:

    StreamObject - pointer to stream object
    DeviceExtension - pointer to device extension.

Return Value:

    None

Notes:

--*/
{
    //
    // Check for a ready for next packet. Acquire spinlock to protect
    // READY bits.  Note that we don't snapshot the ready flags as we do with
    // the remaining notification flags, as we don't want to clear the flags
    // unconditionally in the snapshot in case there is not currently a
    // request pending.   Also, starting a request before the snapshot will
    // give a slight perf improvement.  Note that the flags can be set via
    // the minidriver while we are checking them, but since the minidriver
    // cannot clear them and the minidriver cannot call for a next request
    // more than once before it receives one, this is not a problem.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    if ((StreamObject->ReadyForNextDataReq) &&
        (!IsListEmpty(&StreamObject->DataPendingQueue))) {

        //
        // start the request, which clears the ready flag and releases
        // the spinlock, then reobtain the spinlock.
        //

        SCDequeueAndStartStreamDataRequest(StreamObject);
        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    }                           // if ready for data
    if ((StreamObject->ReadyForNextControlReq) &&
        (!IsListEmpty(&StreamObject->ControlPendingQueue))) {

        //
        // start the request, which clears the ready flag and releases
        // the spinlock.
        //

        SCDequeueAndStartStreamControlRequest(StreamObject);

    } else {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }                           // if ready for control

    return;
}



BOOLEAN
SCGetInterruptState(
                    IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine saves the InterruptFlags, error log info, and
    CompletedRequests fields and clears the InterruptFlags.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT interruptContext = ServiceContext;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  NeedyStream;
    BOOLEAN         Work = FALSE;

    DeviceExtension = interruptContext->DeviceExtension;

    //
    // get the needy streams and zero the
    // link.
    //

    interruptContext->NeedyStream = NeedyStream = DeviceExtension->NeedyStream;

    //
    // capture the state of needy stream
    //

    if (NeedyStream) {

        //
        // Move the interrupt state to save
        // area.
        //

        ASSERT(NeedyStream->NextNeedyStream != NeedyStream);
        ASSERT(NeedyStream->ComObj.InterruptData.Flags & INTERRUPT_FLAGS_NOTIFICATION_REQUIRED);
        ASSERT(NeedyStream->OnNeedyQueue);

        DebugPrint((DebugLevelVerbose, "'SCGetInterruptState: Snapshot for stream %p, S# = %x, NextNeedy = %p\n",
                    NeedyStream, NeedyStream->HwStreamObject.StreamNumber, NeedyStream->NextNeedyStream));

        NeedyStream->OnNeedyQueue = FALSE;

        *interruptContext->SavedStreamInterruptData =
            NeedyStream->ComObj.InterruptData;

        //
        // Clear the interrupt state.
        //

        NeedyStream->ComObj.InterruptData.Flags &= STREAM_FLAGS_INTERRUPT_FLAG_MASK;
        NeedyStream->ComObj.InterruptData.CompletedSRB = NULL;

        Work = TRUE;

        DeviceExtension->NeedyStream = (PSTREAM_OBJECT) NeedyStream->NextNeedyStream;
        NeedyStream->NextNeedyStream = NULL;

#if DBG
        if (DeviceExtension->NeedyStream) {

            ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
        }
#endif

    }                           // if NeedyStream
    //
    // now copy over the device interrupt
    // data if necessary
    //

    if (DeviceExtension->ComObj.InterruptData.Flags &
        INTERRUPT_FLAGS_NOTIFICATION_REQUIRED) {

        *interruptContext->SavedDeviceInterruptData =
            DeviceExtension->ComObj.InterruptData;

        //
        // Clear the device interrupt state.
        //

        DeviceExtension->ComObj.InterruptData.Flags &=
            DEVICE_FLAGS_INTERRUPT_FLAG_MASK;

        DeviceExtension->ComObj.InterruptData.CompletedSRB = NULL;
        Work = TRUE;
    }
    return (Work);
}



NTSTATUS
SCProcessCompletedRequest(
                          IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PIRP            Irp = SRB->HwSRB.Irp;

    //
    // complete the IRP
    //

    return (SCCompleteIrp(Irp,
                          SCDequeueAndDeleteSrb(SRB),
                     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1));

}



NTSTATUS
SCDequeueAndDeleteSrb(
                      IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine dequeues and deletes a completed SRB

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    NTSTATUS        Status = SRB->HwSRB.Status;
    KIRQL           irql;

    //
    // remove the SRB from our outstanding
    // queue.  protect list with
    // spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    RemoveEntryList(&SRB->SRBListEntry);

    if (SRB->HwSRB.Irp) {

        IoSetCancelRoutine(SRB->HwSRB.Irp, NULL);
    }
    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    //
    // free the SRB and MDL
    //
    
    if ( !NT_SUCCESS( Status )) {
        DebugPrint((DebugLevelWarning, 
                   "SCDequeueAndDeleteSrb Command:%x Status=%x\n",
                   SRB->HwSRB.Command, 
                   Status ));
    }
    
    IoFreeMdl(SRB->Mdl);
    ExFreePool(SRB);
    return (Status);
}


VOID
SCProcessCompletedDataRequest(
                              IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a data request which has completed.  It completes any
    pending transfers, releases the adapter objects and map registers.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    PMDL            CurrentMdl;
    ULONG           i = 0;

    if (Irp) {

        PIO_STACK_LOCATION IrpStack;
        PKSSTREAM_HEADER CurrentHeader;

        CurrentHeader = SRB->HwSRB.CommandData.DataBufferArray;

        ASSERT(CurrentHeader);

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        ASSERT(IrpStack);

#if DBG

        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
#endif

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            //
            // flush the buffers if we did PIO data in
            //

            if (SRB->HwSRB.StreamObject->Pio) {

                //
                // find the first header with data...
                //

                while (!(CurrentHeader->DataUsed) && (!CurrentHeader->FrameExtent)) {

                    CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                                    SRB->StreamHeaderSize));
                }

                //
                // restore the pointer we changed
                //

//                CurrentHeader->Data = (PVOID) ((ULONG_PTR) CurrentMdl->StartVa +
//                                               CurrentMdl->ByteOffset);
//
                if (SRB->bMemPtrValid) { // safety first!
                    DebugPrint((DebugLevelVerbose, "Restoring: Index:%x, Ptr:%x\n",
                            i, SRB->pMemPtrArray[i]));

                    CurrentHeader->Data = SRB->pMemPtrArray[i];
                }

                DebugPrint((DebugLevelVerbose, "'SCPioComplete: Irp = %x, header = %x, Data = %x\n",
                            Irp, CurrentHeader, CurrentHeader->Data));

                //
                // update to the next header
                //
                i++;
                CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                                     SRB->StreamHeaderSize));

                if (SRB->HwSRB.Command == SRB_READ_DATA) {

                    KeFlushIoBuffers(CurrentMdl,
                                     TRUE,
                                     FALSE);

                }               // if data in
            }                   // if PIO
            //
            // Flush the adapter buffers if we had map registers => DMA.
            //

            if (SRB->MapRegisterBase) {

                //
                // Since we are a master call I/O flush adapter buffers
                // with a NULL adapter.
                //

                IoFlushAdapterBuffers(DeviceExtension->DmaAdapterObject,
                                      CurrentMdl,
                                      SRB->MapRegisterBase,
                                      MmGetMdlVirtualAddress(CurrentMdl),
                                      CurrentMdl->ByteCount,
                                      (BOOLEAN) (SRB->HwSRB.Command ==
                                               SRB_READ_DATA ? FALSE : TRUE)
                    );

            }                   // if DMA
            CurrentMdl = CurrentMdl->Next;


        }                       // while CurrentMdl

        //
        // flush the buffer for the SRB extension in case the adapter DMA'ed
        // to it.   JHavens says we must treat this as a READ.
        //

        //
        // Flush the adapter buffer for the SRB if we had map registers =>
        // DMA.
        //

        if (SRB->MapRegisterBase) {

            IoFlushAdapterBuffers(DeviceExtension->DmaAdapterObject,
                                  SRB->Mdl,
                                  SRB->MapRegisterBase,
                                  MmGetMdlVirtualAddress(
                                                         SRB->Mdl),
                                  SRB->Length,
                                  FALSE);

            //
            // Free the map registers if DMA.
            //

            IoFreeMapRegisters(DeviceExtension->DmaAdapterObject,
                               SRB->MapRegisterBase,
                               SRB->HwSRB.NumberOfPhysicalPages);

        }                       // if MapRegisterBase
        //
        // free the extra data, if any.
        //

        if (IrpStack->Parameters.Others.Argument4 != NULL) {

            TRAP;
            ExFreePool(IrpStack->Parameters.Others.Argument4);

        }                       // if extradata
    }                           // if Irp
    //
    // call the generic completion handler
    //

    SCProcessCompletedRequest(SRB);

}                               // SCProcessCompletedDataRequest



VOID
SCMinidriverStreamTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
)
/*++

Routine Description:

    This routine calls the minidriver when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.
    Context - Supplies a pointer to the stream object for this adapter.
    SystemArgument1 - Unused.
    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PSTREAM_OBJECT  StreamObject = ((PSTREAM_OBJECT) Context);
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // Acquire the device spinlock if synchronized.
    //

    if (!(DeviceExtension->NoSync)) {

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
    }
    //
    // Make sure the timer routine is still
    // desired.
    //

    if (StreamObject->ComObj.HwTimerRoutine != NULL) {

        DebugPrint((DebugLevelTrace, "'SCTimerDpc: Calling MD timer callback, S# = %x, Routine = %p\n",
                    StreamObject->HwStreamObject.StreamNumber, StreamObject->ComObj.HwTimerRoutine));

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) StreamObject->ComObj.HwTimerRoutine,
                                         StreamObject->ComObj.HwTimerContext
            );

    }
    //
    // Release the spinlock if we're synchronized.
    //

    if (!(DeviceExtension->NoSync)) {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }
    //
    // Call the DPC directly to check for work.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   StreamObject);

}



VOID
SCMinidriverDeviceTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
)
/*++

Routine Description:

    This routine calls the minidriver when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    Context - Supplies a pointer to the stream object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = Context;

    //
    // Acquire the device spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // Make sure the timer routine is still
    // desired.
    //

    if (DeviceExtension->ComObj.HwTimerRoutine != NULL) {

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
             (PKSYNCHRONIZE_ROUTINE) DeviceExtension->ComObj.HwTimerRoutine,
                                      DeviceExtension->ComObj.HwTimerContext
            );

    }
    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // Call the DPC directly to check for
    // work.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

}



VOID
SCLogError(
           IN PDEVICE_OBJECT DeviceObject,
           IN ULONG SequenceNumber,
           IN NTSTATUS ErrorCode,
           IN ULONG UniqueId
)
/*++

Routine Description:

    This function logs an error.

Arguments:

    DeviceObject - device or driver object
    SequenceNumber - supplies the sequence # of the error.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET packet;

    PAGED_CODE();
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                               sizeof(IO_ERROR_LOG_PACKET));

    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = SequenceNumber;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->DumpDataSize = 0;

        IoWriteErrorLogEntry(packet);
    }
}



VOID
SCLogErrorWithString(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN OPTIONAL PDEVICE_EXTENSION DeviceExtension,
                     IN NTSTATUS ErrorCode,
                     IN ULONG UniqueId,
                     IN PUNICODE_STRING String1
)
/*++

Routine Description

    This function logs an error and includes the string provided.

Arguments:

    DeviceObject - device or driver object
    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.
    String1 - The string to be inserted.

Return Value:

    None.

--*/

{
    ULONG           length;
    PCHAR           dumpData;
    PIO_ERROR_LOG_PACKET packet;

    PAGED_CODE();
    length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 2;
    if (length > ERROR_LOG_MAXIMUM_SIZE) {
        length = ERROR_LOG_MAXIMUM_SIZE;
    }
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                                            (UCHAR) length);
    if (packet) {
        packet->ErrorCode = ErrorCode;
        packet->SequenceNumber = (DeviceExtension != NULL) ?
            DeviceExtension->SequenceNumber++ : 0;
        packet->MajorFunctionCode = 0;
        packet->RetryCount = (UCHAR) 0;
        packet->UniqueErrorValue = UniqueId;
        packet->FinalStatus = STATUS_SUCCESS;
        packet->NumberOfStrings = 1;
        packet->StringOffset = (USHORT) ((PUCHAR) & packet->DumpData[0] - (PUCHAR) packet);
        packet->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
        packet->DumpDataSize /= sizeof(ULONG);
        dumpData = (PUCHAR) & packet->DumpData[0];

        RtlCopyMemory(dumpData, String1->Buffer, String1->Length);
        dumpData += String1->Length;
        *dumpData++ = '\0';
        *dumpData++ = '\0';


        IoWriteErrorLogEntry(packet);
    }
    return;
}




BOOLEAN
StreamClassSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
)
/*++

Routine Description:

    This routine calls the minidriver entry point which was passed in as
    a parameter.  It acquires a spin lock so that all accesses to the
    minidriver's routines are synchronized.  This routine is used as a
    subsitute for KeSynchronizedExecution for minidrivers which do not use
    hardware interrupts.


Arguments:

    Interrrupt - Supplies a pointer to the port device extension.
    SynchronizeRoutine - Supplies a pointer to the routine to be called.
    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION) Interrupt;
    BOOLEAN         returnValue;

#if DBG
    ULONGLONG       ticks;
    ULONGLONG       rate;
    ULONGLONG       StartTime,
                    EndTime;

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    StartTime = ticks * 10000 / rate;
#endif

    returnValue = SynchronizeRoutine(SynchronizeContext);

#if DBG
    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    EndTime = ticks * 10000 / rate;

    DebugPrint((DebugLevelVerbose, "'SCDebugSync: minidriver took %d microseconds at dispatch level.\n",
                (EndTime - StartTime) * 10));

    if ((EndTime - StartTime) > 100) {

        DebugPrint((DebugLevelFatal, "Stream Class: minidriver took %I64d millisecond(s) at "
                    "dispatch level.   See dev owner.  Type LN %p for the name of the minidriver\n",
                    (EndTime - StartTime) / 100, SynchronizeRoutine));
    }
#endif

    return (returnValue);
}

#if DBG

BOOLEAN
SCDebugKeSynchronizeExecution(
                              IN PKINTERRUPT Interrupt,
                              IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                              IN PVOID SynchronizeContext
)
/*++

Routine Description:

Arguments:

    Interrrupt - Supplies a pointer to the port device extension.
    SynchronizeRoutine - Supplies a pointer to the routine to be called.
    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    ULONGLONG       ticks;
    ULONGLONG       rate;
    ULONGLONG       StartTime,
                    EndTime;
    BOOLEAN         returnValue;

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    StartTime = ticks * 10000 / rate;

    returnValue = KeSynchronizeExecution(Interrupt,
                                         SynchronizeRoutine,
                                         SynchronizeContext);

    ticks = (ULONGLONG) KeQueryPerformanceCounter((PLARGE_INTEGER) & rate).QuadPart;

    EndTime = ticks * 10000 / rate;

    DebugPrint((DebugLevelVerbose, "'SCDebugSync: minidriver took %d microseconds at raised IRQL.\n",
                (EndTime - StartTime) * 10));

    if ((EndTime - StartTime) > 50) {

        DebugPrint((DebugLevelFatal, "Stream Class: minidriver took %d%d millisecond(s) at raised IRQL.   See dev owner.  Type LN %x for the name of the minidriver\n",
                    (EndTime - StartTime) / 100, SynchronizeRoutine));
    }
    return (returnValue);
}

#endif

NTSTATUS
SCCompleteIrp(
              IN PIRP Irp,
              IN NTSTATUS Status,
              IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Routine generically calls back a completed IRP, and shows one less I/O
    pending.

Arguments:

    Irp - IRP to complete
    Status - Status to complete it with
    DeviceExtension - pointer to device extension

Return Value:

    Returns the Status parameter

--*/

{

	#if DBG
    PMDL            CurrentMdl;
	#endif

    if (Irp) {
        Irp->IoStatus.Status = Status;

		#if DBG

        //
        // random asserts follow...
        // make sure we have not freed the system buffer.
        //


        if (Irp->AssociatedIrp.SystemBuffer) {

            DebugPrint((DebugLevelVerbose, "'SCComplete: Irp = %p, sys buffer = %p\n",
                        Irp, Irp->AssociatedIrp.SystemBuffer));
        }
        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
		#endif
		
        if ( Irp->CurrentLocation < Irp->StackCount+1 ) {
        
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
        } else {
            //
            // we got a dummy Irp we created. IoVerifier code will pews if
            // we call IoCompleteRequest because the Current Stack location
            // is at the end of last stack location. We can't use 
            // IoBuildIoControlRequest to create the Irp becuase it will
            // be added to a thread and the only way to get it off is to
            // call IoCompleteRequest.
            //
            IoFreeIrp( Irp );
        }  
    }
    
    if (!(InterlockedDecrement(&DeviceExtension->OneBasedIoCount))) {

        //
        // the device is being removed and all I/O is complete.  Signal the
        // removal thread to wake up.
        //

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }
    ASSERT(DeviceExtension->OneBasedIoCount >= 0);
    return (Status);
}


BOOLEAN
SCDummyMinidriverRoutine(
                         IN PVOID Context
)
/*++

Routine Description:

    Routine used when the minidriver fills in a null for an optional routine

Arguments:

    Context - unreferenced

Return Value:

    TRUE

--*/

{

    return (TRUE);
}


#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCOpenMinidriverInstance(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PFILTER_INSTANCE * ReturnedFilterInstance,
    IN PSTREAM_CALLBACK_PROCEDURE SCGlobalInstanceCallback,
    IN PIRP Irp)
/*++

Routine Description:

    Worker routine to process opening of a filter instance.
    Once open, we issue srb_get_stream_info.

Arguments:

    DeviceExtension - pointer to device extension
    ReturnedFilterInstance - pointer to the filter instance structure
    SCGlobalInstanceCallback - callback procedure to be called if we call the minidriver
    Irp - pointer to the irp

Return Value:

    Returns NTSTATUS and a filter instance structure if successfull

--*/

{
    ULONG                   FilterExtensionSize;
    PFILTER_INSTANCE        FilterInstance;
    PHW_STREAM_INFORMATION  CurrentInfo;
    PADDITIONAL_PIN_INFO    CurrentAdditionalInfo;
    ULONG                   i;
    BOOLEAN                 RequestIssued;
   	PKSOBJECT_CREATE_ITEM   CreateItem;
	ULONG                   FilterTypeIndex;
	ULONG                   NumberOfPins;
    NTSTATUS                Status = STATUS_SUCCESS;

    PAGED_CODE();

   	//
   	// The CreateItem is in Irp->Tail.Overlay.DriverContext[0] from KS
   	//
    CreateItem = (PKSOBJECT_CREATE_ITEM)Irp->Tail.Overlay.DriverContext[0];
	ASSERT( CreateItem != NULL );
    FilterTypeIndex = (ULONG)(ULONG_PTR)CreateItem->Context;
    
    ASSERT( FilterTypeIndex == 0 ||
            FilterTypeIndex < 
            DeviceExtension->MinidriverData->HwInitData.NumNameExtensions);
            
    FilterExtensionSize = DeviceExtension->FilterExtensionSize;

    ASSERT( DeviceExtension->FilterExtensionSize ==
        	DeviceExtension->MinidriverData->
        	    HwInitData.FilterInstanceExtensionSize);
        	    
    FilterInstance = NULL;

    NumberOfPins = DeviceExtension->FilterTypeInfos[FilterTypeIndex].
                        StreamDescriptor->StreamHeader.NumberOfStreams;

    //
    // don't call the minidriver to open the filter instance if 1x1 for backward
    // compat. We do this so that minidrivers that don't support
    // instancing (the vast majority) don't have to respond to this call.
    // 

    if ( DeviceExtension->NumberOfOpenInstances > 0 && 
         0 == FilterExtensionSize ) {
   		//
   		// Legacy 1x1 and non-1st open. assign the same
   		// FilterInstance and succeed it.
   		//

   		PLIST_ENTRY node;
   		ASSERT( !IsListEmpty( &DeviceExtension->FilterInstanceList));
   		node = DeviceExtension->FilterInstanceList.Flink;
        FilterInstance = CONTAINING_RECORD(node,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
        ASSERT_FILTER_INSTANCE( FilterInstance );
        *ReturnedFilterInstance = FilterInstance;
   		Status = STATUS_SUCCESS;
   		return Status; // can't goto Exit, it will insert FI again.
    }

    FilterInstance =
        ExAllocatePool(NonPagedPool, sizeof(FILTER_INSTANCE) + 
        							     FilterExtensionSize +
			            	             sizeof(ADDITIONAL_PIN_INFO) *
        				    	         NumberOfPins);

    if (!FilterInstance) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    RtlZeroMemory(FilterInstance, sizeof(FILTER_INSTANCE) + 
                                    FilterExtensionSize +
        	            	        sizeof(ADDITIONAL_PIN_INFO) *
                                    NumberOfPins);

    FilterInstance->Signature = SIGN_FILTER_INSTANCE;
    FilterInstance->DeviceExtension = DeviceExtension; // keep this handy    
    //
	// To get FilterInstance from HwInstanceExtension we need
	// to arrange the memory layout 
	// [FilterInstnace][HwInstanceExtension][AddionalPinInfo...]
	// as opposed to 
	// [FilterInstance][AdditionalPinInfo...][HwInstanceExtension]
	//

    FilterInstance->HwInstanceExtension = FilterInstance + 1;
    
	FilterInstance->PinInstanceInfo = 
		(PADDITIONAL_PIN_INFO) ((PBYTE)(FilterInstance+1) + FilterExtensionSize);

   	FilterInstance->FilterTypeIndex = FilterTypeIndex;
	
    //
    // initialize the filter instance list
    //

    InitializeListHead(&FilterInstance->FirstStream);
    InitializeListHead(&FilterInstance->NextFilterInstance);
    InitializeListHead(&FilterInstance->NotifyList);

	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        Status = KsRegisterWorker( CriticalWorkQueue, &FilterInstance->WorkerRead );
        if (!NT_SUCCESS( Status )) {            
            ExFreePool(FilterInstance);
            FilterInstance = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;            
            ASSERT( 0 );
            goto Exit;
        }

        Status = KsRegisterWorker( CriticalWorkQueue, &FilterInstance->WorkerWrite );
        if (!NT_SUCCESS( Status )) {
            KsUnregisterWorker( FilterInstance->WorkerRead );
            ExFreePool(FilterInstance);
            FilterInstance = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ASSERT( 0 );
            goto Exit;
        }
        DebugPrint((DebugLevelVerbose,
                   "RegisterReadWorker %x WriteWorker %x\n",
                   FilterInstance->WorkerRead,
                   FilterInstance->WorkerWrite));
	#endif
	
    //
    // initialize the current and max instances
    //

	
    CurrentAdditionalInfo = FilterInstance->PinInstanceInfo;
    CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

    for (i = 0; i < NumberOfPins; i++) {

        CurrentAdditionalInfo[i].CurrentInstances = 0;
        CurrentAdditionalInfo[i].MaxInstances =
            CurrentInfo->NumberOfPossibleInstances;

        //
   	    // index to next streaminfo and additional info structures.
       	//

        CurrentInfo++;
   	}

    //
    // fill in the filter dispatch table pointer
    //

    KsAllocateObjectHeader(&FilterInstance->DeviceHeader,
                           SIZEOF_ARRAY(CreateHandlers),
                           (PKSOBJECT_CREATE_ITEM) CreateHandlers,
                           Irp,
                           (PKSDISPATCH_TABLE) & FilterDispatchTable);

    if (FilterExtensionSize) {

        //
        // call the minidriver to open the instance if the call is supported.
        // final status will be processed in the callback procedure.
        //

        //
        // C4312 fix: This union corresponds to the _CommandData union within
        // HW_STREAM_REQUEST_BLOCK.  This is done to correctly align
        // FilterTypeIndex for assignment on 64-bit such that it doesn't
        // break on big endian machines.  I don't want to waste stack
        // space with an entire HW_STREAM_REQUEST_BLOCK for a 64-bit safe
        // cast.
        //
        union {
            PVOID Buffer;
            LONG FilterTypeIndex;
        } u;

        u.Buffer = NULL;
        u.FilterTypeIndex = (LONG)FilterTypeIndex;

        Status = SCSubmitRequest(
        			SRB_OPEN_DEVICE_INSTANCE,
                    u.Buffer,
                    0,
                    SCDequeueAndDeleteSrb, //SCGlobalInstanceCallback,
                    DeviceExtension,
                    FilterInstance->HwInstanceExtension,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        if (!RequestIssued) {

            //
            // if request not issued, fail the request as we could not send
            // it down.
            //

            ASSERT(Status != STATUS_SUCCESS);

            KsFreeObjectHeader(FilterInstance->DeviceHeader);
			#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
            KsUnregisterWorker( FilterInstance->WorkerRead );
            KsUnregisterWorker( FilterInstance->WorkerWrite );
			#endif
            //ExFreePool(FilterInstance);
        }        
    } // if minidriver supports multiple filter
	
    Exit: {
        if ( NT_SUCCESS( Status ) ) {
            DebugPrint((DebugLevelInfo,
                       "Inserting FilterInstance %x\n",
                       FilterInstance));
                       
   			SCInsertFiltersInDevice( FilterInstance, DeviceExtension );
   		}
   		else if ( NULL != FilterInstance) {
            ExFreePool( FilterInstance );
            FilterInstance = NULL;
        }
        
        *ReturnedFilterInstance = FilterInstance;        
        return (Status);
    }
}

#else // ENABLE_MULTIPLE_FILTER_TYPES
#endif // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCSubmitRequest(
                IN SRB_COMMAND Command,
                IN PVOID Buffer,
                IN ULONG DataSize,
                IN PSTREAM_CALLBACK_PROCEDURE Callback,
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PVOID InstanceExtension,
                IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                IN PIRP Irp,
                OUT PBOOLEAN RequestIssued,
                IN PLIST_ENTRY Queue,
                IN PVOID MinidriverRoutine
)
/*++

Routine Description:

    This routine generically submits a non-data SRB to the minidriver.  The
    callback procedure is called back at PASSIVE level.

Arguments:

    Command - command to issue
    Buffer - data buffer, if any
    DataSize - length of transfer
    Callback - procedure to call back at passive level
    DeviceExtension - pointer to device extension
    InstanceExtension - pointer to instance extension, if any
    HwStreamObject - optional pointer to minidriver's stream object
    Irp - pointer to IRP
    RequestIssued - pointer to boolean which is set if request issued
    Queue - queue upon which to enqueue the request
    MinidriverRoutine - request routine to call with the request

Return Value:

     Status
--*/

{
    PSTREAM_OBJECT  StreamObject = 0;
    PSTREAM_REQUEST_BLOCK Request = SCBuildRequestPacket(DeviceExtension,
                                                         Irp,
                                                         0,
                                                         0);
    NTSTATUS        Status;

    PAGED_CODE();

    //
    // assume request will be successfully issued.
    //

    *RequestIssued = TRUE;


    //
    // if the alloc failed, call the callback procedure with a null SRB
    //

    if (!Request) {

        *RequestIssued = FALSE;
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    if (HwStreamObject) {
        StreamObject = CONTAINING_RECORD(
                                         HwStreamObject,
                                         STREAM_OBJECT,
                                         HwStreamObject
            );


        //
        // hack.  we need to set the stream request flag if this is a stream
        // request.  the only case that we would NOT set this when a stream
        // object is passed in is on an OPEN or CLOSE, where the stream
        // object is
        // passed in on a device request.  special case this.  if later
        // this assumption changes, an assert will be hit in lowerapi.
        //

        if ((Command != SRB_OPEN_STREAM) && (Command != SRB_CLOSE_STREAM)) {

            Request->HwSRB.Flags |= SRB_HW_FLAGS_STREAM_REQUEST;
        }
    }
    //
    // initialize event for blocking for completion
    //

    KeInitializeEvent(&Request->Event, SynchronizationEvent, FALSE);

    Request->HwSRB.Command = Command;

    Request->Callback = SCSignalSRBEvent;
    Request->HwSRB.HwInstanceExtension = InstanceExtension;
    Request->HwSRB.StreamObject = HwStreamObject;
    Request->HwSRB.CommandData.StreamBuffer = Buffer;
    Request->HwSRB.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
    Request->HwSRB.NumberOfBytesToTransfer = DataSize;
    Request->DoNotCallBack = FALSE;

    //
    // call routine to actually submit request to the device
    //

    Status = SCIssueRequestToDevice(DeviceExtension,
                                    StreamObject,
                                    Request,
                                    MinidriverRoutine,
                                    Queue,
                                    Irp);

    //
    // block waiting for completion if pending
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Request->Event, Executive, KernelMode, FALSE, NULL);
    }
    return (Callback(Request));

}


VOID
SCSignalSRBEvent(
                 IN PSTREAM_REQUEST_BLOCK Srb
)
/*++

Routine Description:

    Sets the event for a completed SRB

Arguments:

    Srb - pointer to the request

Return Value:

     none
--*/

{

    KeSetEvent(&Srb->Event, IO_NO_INCREMENT, FALSE);
    return;
}


NTSTATUS
SCProcessDataTransfer(
                      IN PDEVICE_EXTENSION DeviceExtension,
                      IN PIRP Irp,
                      IN SRB_COMMAND Command
)
/*++

Routine Description:

    Process a data transfer request to a stream

Arguments:

    DeviceExtension - address of device extension.
    Irp - pointer to the IRP
    Command - read or write command

Return Value:

     NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_REQUEST_BLOCK Request;
    PSTREAM_OBJECT  StreamObject = IrpStack->FileObject->FsContext;
    NTSTATUS        Status;
    PKSSTREAM_HEADER OutputBuffer = NULL;
    ULONG           NumberOfPages = 0,
                    NumberOfBuffers = 0;
    ULONG           Flags =
                        KSPROBE_STREAMWRITE | 
                        KSPROBE_ALLOCATEMDL | 
                        KSPROBE_PROBEANDLOCK | 
                        KSPROBE_ALLOWFORMATCHANGE;
    ULONG           HeaderSize=0; // prefixbug 17392
    ULONG           ExtraSize=0; // prefixbug 17391
    #if DBG
    PMDL            CurrentMdl;
    #endif
    PVOID           pMemPtrArray = NULL;


    PAGED_CODE();

    //
    // if we are flushing, we must error any I/O during this period.
    //

    if (StreamObject->InFlush) {


        DebugPrint((DebugLevelError,
                    "'StreamDispatchIOControl: Aborting IRP during flush!"));
        TRAP;

        return (STATUS_DEVICE_NOT_READY);

    }                           // if flushing
    Irp->IoStatus.Information = 0;

    #if DBG
    DeviceExtension->NumberOfRequests++;
    #endif

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

        //
        // get the size of the header and the expansion from the minidriver.
        //

        HeaderSize = StreamObject->HwStreamObject.StreamHeaderMediaSpecific +
            sizeof(KSSTREAM_HEADER);
        ExtraSize = StreamObject->HwStreamObject.StreamHeaderWorkspace;

        //
        // we assumed this was a write. do additional processing if a read.
        //

        if (Command == SRB_READ_DATA) {

            Flags =
                KSPROBE_STREAMREAD | KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK;

            //
            // this is a read, so set the information field in the irp to
            // copy back the headers when the I/O is complete.
            //

            Irp->IoStatus.Information =
                IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        }
        //
        // lock and probe the buffer
        //
        DebugPrint((DebugLevelVerbose, "Stream: HeaderSize:%x\n",HeaderSize));
        DebugPrint((DebugLevelVerbose, "Stream: sizeof(KSSSTREAM_HEADER):%x\n",sizeof(KSSTREAM_HEADER)));
        DebugPrint((DebugLevelVerbose, "Stream: MediaSpecific:%x\n",StreamObject->HwStreamObject.StreamHeaderMediaSpecific));
        DebugPrint((DebugLevelVerbose, "Stream: StreamHeader->Size:%x\n",((PKSSTREAM_HEADER)(Irp->UserBuffer))->Size));


        if (!NT_SUCCESS(Status =
                        KsProbeStreamIrp(Irp,
                                         Flags,
                                         HeaderSize))) {

            DebugPrint((DebugLevelError, "Stream: ProbeStreamIrp failed!"));

            return (Status);

        }
        if (!ExtraSize) {

            OutputBuffer = (PKSSTREAM_HEADER)
                Irp->AssociatedIrp.SystemBuffer;

            IrpStack->Parameters.Others.Argument4 = NULL;
        } else {

            TRAP;
            if (!NT_SUCCESS(Status = KsAllocateExtraData(Irp,
                                                         ExtraSize,
                                                         &OutputBuffer))) {


                DebugPrint((DebugLevelError, "Stream: AllocExtraData failed!"));

                return (Status);
            }                   // if not success
            IrpStack->Parameters.Others.Argument4 = OutputBuffer;


        }


        #if DBG

        //
        // assert the MDL list.
        //

        CurrentMdl = Irp->MdlAddress;

        while (CurrentMdl) {

            CurrentMdl = CurrentMdl->Next;
        }                       // while
        #endif

        //
        // calculate the # of buffers.
        //

        NumberOfBuffers = IrpStack->Parameters.
            DeviceIoControl.OutputBufferLength / HeaderSize;


        //
        // do addtional processing on the data buffers.
        //
        if (StreamObject->HwStreamObject.Dma) {     // an optimization
            SCProcessDmaDataBuffers(OutputBuffer,
                             NumberOfBuffers,
                             StreamObject,
                             Irp->MdlAddress,
                             &NumberOfPages,
                             HeaderSize + ExtraSize,
                             (BOOLEAN) (Command == SRB_WRITE_DATA));
        }
        //
        // if number of pages is > than the max supported, return error.
        // Allow
        // for one extra map register for the SRB extension.
        //
        // GUBGUB - This is really a workitem to make it correct. 
        // need to break up requests that have too many elements.
        //

        if (NumberOfPages > (DeviceExtension->NumberOfMapRegisters - 1)) {

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }                           // if BufferSize
    //
    // build an SRB and alloc workspace for the request.   Allocate
    // scatter/gather space also if needed.
    //

    Request = SCBuildRequestPacket(DeviceExtension,
                                   Irp,
                                   NumberOfPages * sizeof(KSSCATTER_GATHER),
                                   NumberOfBuffers * sizeof(PVOID));

    if (Request == NULL) {

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

        //
        // do more addtional processing on the data buffers.
        //
        if (StreamObject->HwStreamObject.Pio) {     // a small optimization
            Request->bMemPtrValid = SCProcessPioDataBuffers(OutputBuffer,
                                    NumberOfBuffers,
                                    StreamObject,
                                    Irp->MdlAddress,
                                    HeaderSize + ExtraSize,
                                    Request->pMemPtrArray,
                                    (BOOLEAN) (Command == SRB_WRITE_DATA));
            }
    //
    // set # of physical pages
    //

    Request->HwSRB.NumberOfPhysicalPages = NumberOfPages;

    //
    // set # of data buffers
    //

    Request->HwSRB.NumberOfBuffers = NumberOfBuffers;

    //
    // set the command code in the packet.
    //

    Request->HwSRB.Command = Command;

    //
    // set the input and output buffers
    //

    Request->HwSRB.CommandData.DataBufferArray = OutputBuffer;
    Request->HwSRB.HwDeviceExtension = DeviceExtension->HwDeviceExtension;
    Request->Callback = SCProcessCompletedDataRequest;
    Request->HwSRB.StreamObject = &StreamObject->HwStreamObject;
    Request->StreamHeaderSize = HeaderSize + ExtraSize;
    Request->DoNotCallBack = FALSE;
    Request->HwSRB.Flags |= (SRB_HW_FLAGS_DATA_TRANSFER
                             | SRB_HW_FLAGS_STREAM_REQUEST);

    ASSERT_FILTER_INSTANCE( StreamObject->FilterInstance );
    Request->HwSRB.HwInstanceExtension = 
        StreamObject->FilterInstance->HwInstanceExtension;

    //
    // point the IRP workspace to the request
    // packet
    //

    Irp->Tail.Overlay.DriverContext[0] = Request;

    IoMarkIrpPending(Irp);

//    ASSERT((IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                       IOCTL_KS_READ_STREAM) ||
//            (IoGetCurrentIrpStackLocation(Irp)->MajorFunction ==
//                        IOCTL_KS_WRITE_STREAM));
    ASSERT((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] > 0x40000000);

    return (SCIssueRequestToDevice(DeviceExtension,
                                   StreamObject,
                                   Request,
                             StreamObject->HwStreamObject.ReceiveDataPacket,
                                   &StreamObject->DataPendingQueue,
                                   Irp));

}

VOID
SCErrorDataSRB(
               IN PHW_STREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    Dummy routine invoked when a data request is received for non-data
    receiving stream.

Arguments:

    SRB- address of STREAM request block

Return Value:

    None.

--*/

{

    //
    // just call the SRB back with error
    //

    SRB->Status = STATUS_NOT_SUPPORTED;
    StreamClassStreamNotification(StreamRequestComplete,
                                  SRB->StreamObject);
    StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                  SRB->StreamObject);
}                               // SCErrorDataSRB


NTSTATUS
SCIssueRequestToDevice(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN OPTIONAL PSTREAM_OBJECT StreamObject,
                       PSTREAM_REQUEST_BLOCK Request,
                       IN PVOID MinidriverRoutine,
                       IN PLIST_ENTRY Queue,
                       IN PIRP Irp
)
/*++

Routine Description:

    This routine calls the minidriver's request vector with a request.
    Both data and non-data requests are handled by this routine.  The routine
    either synchronizes the call or not, based on the NoSync boolean.

Arguments:

    DeviceExtension - pointer to device extension
    StreamObject - optional pointer to stream object
    MinidriverRoutine - request routine to call with the request
    Queue - queue upon which to enqueue the request
    Irp - pointer to IRP

Return Value:

     Status
--*/

{
    KIRQL           irql;
        
    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    if (DeviceExtension->NoSync) {

        //
        // place the request on the
        // outstanding queue and call it down
        // immediately
        //

        ASSERT((DeviceExtension->BeginMinidriverCallin == SCBeginSynchronizedMinidriverCallin) ||
               (DeviceExtension->BeginMinidriverCallin == SCBeginUnsynchronizedMinidriverCallin));

        Request->Flags |= SRB_FLAGS_IS_ACTIVE;
        
        InsertHeadList(
                       &DeviceExtension->OutstandingQueue,
                       &Request->SRBListEntry);

        IoSetCancelRoutine(Irp, StreamClassCancelOutstandingIrp);

        KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

        if ((StreamObject) && (StreamObject->HwStreamObject.Dma) &&
            (Request->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER)) {

            //
            // allocate the adapter channel. call cannot fail as the only
            // time it would is when there aren't enough map registers, and
            // we've already checked for that condition.  Block waiting til
            // it's allocated.
            //
            KIRQL oldIrql;

            KeInitializeEvent(&Request->DmaEvent, SynchronizationEvent, FALSE);

            ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql());

            KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
            SCSetUpForDMA(DeviceExtension->DeviceObject,
                          Request);
            KeLowerIrql( oldIrql );

            KeWaitForSingleObject(&Request->DmaEvent, Executive, KernelMode, FALSE, NULL);


        }
        // this could open a race window. It should be protected in spinlock.
        //Request->Flags |= SRB_FLAGS_IS_ACTIVE;

        ((PHW_RECEIVE_STREAM_CONTROL_SRB) (MinidriverRoutine))
            (&Request->HwSRB);

    } else {

        //
        // insert the item on the queue
        //

        InsertHeadList(
                       Queue,
                       &Irp->Tail.Overlay.ListEntry);

        //
        // set the cancel routine to pending
        //

        IoSetCancelRoutine(Irp, StreamClassCancelPendingIrp);

        //
        // check to see if the IRP is already cancelled.
        //

        if (Irp->Cancel) {

            //
            // the IRP is cancelled.   Make sure that the cancel routine
            // will be called.
            //

            if (IoSetCancelRoutine(Irp, NULL)) {

                //
                // wow, the cancel routine will not be invoked.
                // dequeue the request ourselves and complete
                // with cancelled status.

                RemoveEntryList(&Request->SRBListEntry);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

                //
                // free the SRB and MDL
                //

                IoFreeMdl(Request->Mdl);

                ExFreePool(Request);
                return (STATUS_CANCELLED);

            } else {            // if we must cancel

                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
            }                   // if we must cancel

            return (STATUS_PENDING);
        }                       // if cancelled
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        //
        // call the DPC routine directly. GUBGUB questionable performance improvement chance
        // BGP - is this really
        // faster than scheduling it?
        //

        StreamClassDpc(NULL, DeviceExtension->DeviceObject, Irp, StreamObject);

        KeLowerIrql(irql);
    }
    return (STATUS_PENDING);
}


BOOLEAN
SCCheckFilterInstanceStreamsForIrp(
                                   IN PFILTER_INSTANCE FilterInstance,
                                   IN PIRP Irp
)
/*++
Routine Description:

    This routine checks all filter instance streams for the specified IRP.

Arguments:

    FilterInstance - pointer to the filter instance
    Irp - pointer to the IRP.

Return Value:

    TRUE if the IRP is found.

--*/

{

    PSTREAM_OBJECT  StreamObject;
    PLIST_ENTRY     StreamListEntry,
                    StreamObjectEntry;

    StreamListEntry = StreamObjectEntry = &FilterInstance->FirstStream;

    while (StreamObjectEntry->Flink != StreamListEntry) {

        StreamObjectEntry = StreamObjectEntry->Flink;

        //
        // follow the link to the stream
        // object
        //

        StreamObject = CONTAINING_RECORD(StreamObjectEntry,
                                         STREAM_OBJECT,
                                         NextStream);

        if (SCCheckRequestsForIrp(
                                  &StreamObject->DataPendingQueue, Irp, TRUE, StreamObject->DeviceExtension)) {

            return (TRUE);
        }
        if (SCCheckRequestsForIrp(
                                  &StreamObject->ControlPendingQueue, Irp, TRUE, StreamObject->DeviceExtension)) {

            return (TRUE);
        }
    }

    return (FALSE);

}                               // SCCheckFilterInstanceStreamsForIrp




BOOLEAN
SCCheckRequestsForIrp(
                      IN PLIST_ENTRY ListEntry,
                      IN PIRP Irp,
                      IN BOOLEAN IsIrpQueue,
                      IN PDEVICE_EXTENSION DeviceExtension
)
/*++
Routine Description:

    This routine checks all requests on a queue for the specified IRP.
    If the IRP parameter is NULL, the first IRP on the queue is cancelled.

Arguments:

    ListEntry - list to check for the IRP
    Irp - pointer to the IRP or NULL to cancel the first IRP.
    IsIrpQueue - TRUE indicates an IRP queue, FALSE indicates an SRB queue
    DeviceExtension - pointer to the device extension

Return Value:

    TRUE if the IRP is found or if we cancel it.

--*/

{

    PLIST_ENTRY     IrpEntry = ListEntry;
    PIRP            CurrentIrp;

    while (IrpEntry->Flink != ListEntry) {

        IrpEntry = IrpEntry->Flink;

        ASSERT(IrpEntry);
        ASSERT(IrpEntry->Flink);
        ASSERT(IrpEntry->Blink);

        //
        // follow the link to the IRP
        //

        if (IsIrpQueue) {

            CurrentIrp = CONTAINING_RECORD(IrpEntry,
                                           IRP,
                                           Tail.Overlay.ListEntry);
        } else {

            CurrentIrp = ((PSTREAM_REQUEST_BLOCK) (CONTAINING_RECORD(IrpEntry,
                                                       STREAM_REQUEST_BLOCK,
                                                 SRBListEntry)))->HwSRB.Irp;
        }

        //
        // this routine is used to cancel irp's if IRP is null.
        //

        if ((!Irp) && (!CurrentIrp->Cancel)) {

            //
            // The IRP has not been previously cancelled, so cancel it after
            // releasing the spinlock to avoid deadlock with the cancel
            // routine.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // This code is suspicious that the CurrentIrp is not protected, i.e.
            // it could be processed and freed from other thread. However, we
            // are not never called with (!Irp). Therefore, we should never
            // come in executing this piece of code. here is the analysis.
            // 1. We are called from
            //      a. SCCheckFilterInstanceStreamIrp()
            //      b. SCCancelOutstandingIrp()
            //      c. StreamClassCancelPendingIrp()
            // 2. Further inspection shows that a. SCCheckFilterInstanceStreamForIrp() is
            //    only called by StreamClassCancelPendingIrp() which always has non-null Irp.
            // 3. SCCancelOutstandingIrp() is called by
            //      a. StreamClassCancelPendingIrp() which always has non-NULL irp.
            //      b. StreamClassCancelOutstandingIrp() which always has non-NULL irp.
            // The concusion is that we are never called with null irp. Therefore, this
            // piece code is never executed. But this driver has been thru win2k extenteded
            // test cycle. I rather be conservative. Add an Assertion instead of removing
            // the code for now.
            //
            ASSERT( 0 );
            IoCancelIrp(CurrentIrp);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            return (TRUE);
        }
        if (Irp == CurrentIrp) {

            return (TRUE);
        }
    }                           // while list entry

    return (FALSE);

}                               // SCCheckRequestsForIrp

VOID
SCNotifyMinidriverCancel(
                         IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    Synchronized routine to notify minidriver that an IRP has been canceled

Arguments:

    SRB - pointer to SRB that has been canceled.

Return Value:

    none

--*/


{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

    //
    // if the active flag is still set in the SRB, the minidriver still
    // has it so call him to abort it.
    //

    if (SRB->Flags & SRB_FLAGS_IS_ACTIVE) {

        //
        // call the minidriver with the SRB.
        //

        (DeviceExtension->MinidriverData->HwInitData.HwCancelPacket)
            (&SRB->HwSRB);
    }
    return;
}

VOID
SCCancelOutstandingIrp(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PIRP Irp
)
/*++
Routine Description:

    Routine to notify minidriver that an IRP has been canceled.   Device
    spinlock NUST be taken before this routine is called.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to the IRP.

Return Value:

    none

--*/

{
    PSTREAM_REQUEST_BLOCK Srb;

    //
    // just return if the request is not on
    // our queue.
    //

    if ((!IsListEmpty(&DeviceExtension->OutstandingQueue)) &&
        (SCCheckRequestsForIrp(
        &DeviceExtension->OutstandingQueue, Irp, FALSE, DeviceExtension))) {

        //
        // the request is sitting on our
        // outstanding queue.  call the
        // minidriver
        // via a synchronize routine to
        // cancel it.
        //

        Srb = Irp->Tail.Overlay.DriverContext[0];

#if DBG
        if (Srb->HwSRB.StreamObject) {

            DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: canceling, Irp = %x, Srb = %x, S# = %x\n",
                        Irp, Srb, Srb->HwSRB.StreamObject->StreamNumber));

        } else {

            DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: canceling nonstream, Irp = %x\n",
                        Irp));
        }                       // if SO

#endif

        if (DeviceExtension->NoSync) {

            //
            // we need to ensure that the SRB memory is valid for the async
            // minidriver, EVEN if it happens to call back the request just
            // before we call it to cancel it!   This is done for two
            // reasons:
            // it obviates the need for the minidriver to walk its request
            // queues to find the request, and I failed to pass the dev ext
            // pointer to the minidriver in the below call, which means that
            // the SRB HAS to be valid, and it's too late to change the API.
            //
            // Oh, well.   Spinlock is now taken (by caller).
            //

            if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {
                return;
            }
            Srb->DoNotCallBack = TRUE;

            //
            // release the spinlock temporarily since we need to call the
            // minidriver.   The caller won't be affected by this.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            (DeviceExtension->MinidriverData->HwInitData.HwCancelPacket)
                (&Srb->HwSRB);

            //
            // reacquire the spinlock since the caller will release it
            //

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

            Srb->DoNotCallBack = FALSE;

            //
            // if the ACTIVE flag is now clear, it indicates that the
            // SRB was completed during the above call into the minidriver.
            // since we blocked the internal completion of the request,
            // we must call it back ourselves in this case.
            //

            if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                (Srb->Callback) (Srb);

                KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            }                   // if ! active
        } else {

            DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                           (PVOID) SCNotifyMinidriverCancel,
                                                  Srb);
        }                       // if nosync

    }                           // if on our queue
    return;
}

NTSTATUS
SCMinidriverDevicePropertyHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSPROPERTY Property,
                                  IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get/set property to the device.

Arguments:

    Command - either GET or SET property
    Irp - pointer to the IRP
    Property - pointer to the property structure
    PropertyInfo - buffer for property information

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PSTREAM_PROPERTY_DESCRIPTOR PropDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    PropDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_PROPERTY_DESCRIPTOR));
    if (PropDescriptor == NULL) {
        DebugPrint((DebugLevelError,
                    "SCDevicePropHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the property set.
    //
    // this value is calculated by subtracting the base property set
    // pointer from the requested property set pointer.
    //
    // The requested property set is pointed to by Context[0] by
    // KsPropertyHandler.
    //

    PropDescriptor->PropertySetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
        IFN_MF( (ULONG_PTR) DeviceExtension->DevicePropertiesArray)
        IF_MF( (ULONG_PTR) FilterInstance->DevicePropertiesArray)
        )/ sizeof(KSPROPERTY_SET);

    PropDescriptor->Property = Property;
    PropDescriptor->PropertyInfo = PropertyInfo;
    PropDescriptor->PropertyInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PropDescriptor->PropertyOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // send a get or set property SRB to the device.
    //

    Status = SCSubmitRequest(Command,
                             PropDescriptor,
                             0,
                             SCProcessCompletedPropertyRequest,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );
    if (!RequestIssued) {

        ExFreePool(PropDescriptor);
    }
    return (Status);
}

NTSTATUS
SCMinidriverStreamPropertyHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSPROPERTY Property,
                                  IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get or set property to the device.

Arguments:

    Command - either GET or SET property
    Irp - pointer to the IRP
    Property - pointer to the property structure
    PropertyInfo - buffer for property information

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    PSTREAM_PROPERTY_DESCRIPTOR PropDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    StreamObject = IrpStack->FileObject->FsContext;

    PropDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_PROPERTY_DESCRIPTOR));
    if (PropDescriptor == NULL) {
        DebugPrint((DebugLevelError,
                    "SCDevicePropHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the property set.
    //
    // this value is calculated by subtracting the base property set
    // pointer from the requested property set pointer.
    //
    // The requested property set is pointed to by Context[0] by
    // KsPropertyHandler.
    //

    PropDescriptor->PropertySetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         (ULONG_PTR) StreamObject->PropertyInfo)
        / sizeof(KSPROPERTY_SET);

    PropDescriptor->Property = Property;
    PropDescriptor->PropertyInfo = PropertyInfo;
    PropDescriptor->PropertyInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    PropDescriptor->PropertyOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // send a get or set property SRB to the stream.
    //

    Status = SCSubmitRequest(Command,
                             PropDescriptor,
                             0,
                             SCProcessCompletedPropertyRequest,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {

        ExFreePool(PropDescriptor);
    }
    return (Status);
}

NTSTATUS
SCProcessCompletedPropertyRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a property request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // free the prop info structure and
    // complete the request
    //

    ExFreePool(SRB->HwSRB.CommandData.PropertyInfo);

    //
    // set the information field from the SRB
    // transferlength field
    //

    SRB->HwSRB.Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    return (SCDequeueAndDeleteSrb(SRB));

}

VOID
SCUpdateMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps,
                             IN BOOLEAN Stream
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    NumProps - number of properties to process
    MinidriverProps - pointer to the array of properties to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSPROPERTY_ITEM CurrentPropId;
    PKSPROPERTY_SET CurrentProp;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's property info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentProp = MinidriverProps;

    for (i = 0; i < NumProps; i++) {

        CurrentPropId = (PKSPROPERTY_ITEM) CurrentProp->PropertyItem;

        for (j = 0; j < CurrentProp->PropertiesCount; j++) {

            //
            // if support handler is supported, send it to the "get" handler
            //

            if (CurrentPropId->SupportHandler) {

                if (Stream) {

                    CurrentPropId->SupportHandler = StreamClassMinidriverStreamGetProperty;

                } else {

                    CurrentPropId->SupportHandler = StreamClassMinidriverDeviceGetProperty;
                }               // if stream

            }
            //
            // if get prop routine is
            // supported, add our vector.
            //

            if (CurrentPropId->GetPropertyHandler) {

                if (Stream) {

                    CurrentPropId->GetPropertyHandler = StreamClassMinidriverStreamGetProperty;
                } else {

                    CurrentPropId->GetPropertyHandler = StreamClassMinidriverDeviceGetProperty;
                }               // if stream

            }                   // if get supported
            //
            // if get prop routine is
            // supported, add our vector.
            //

            if (CurrentPropId->SetPropertyHandler) {

                if (Stream) {

                    CurrentPropId->SetPropertyHandler = StreamClassMinidriverStreamSetProperty;

                } else {

                    CurrentPropId->SetPropertyHandler = StreamClassMinidriverDeviceSetProperty;
                }               // if stream

            }
            //
            // index to next property item in
            // array
            //

            CurrentPropId++;

        }                       // for number of property items

        //
        // index to next property set in
        // array
        //

        CurrentProp++;

    }                           // for number of property sets

}

VOID
SCUpdateMinidriverEvents(
                         IN ULONG NumEvents,
                         IN PKSEVENT_SET MinidriverEvents,
                         IN BOOLEAN Stream
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    NumEvents - number of event sets to process
    MinidriverEvents - pointer to the array of properties to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSEVENT_ITEM   CurrentEventId;
    PKSEVENT_SET    CurrentEvent;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's event info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentEvent = MinidriverEvents;

    for (i = 0; i < NumEvents; i++) {

        CurrentEventId = (PKSEVENT_ITEM) CurrentEvent->EventItem;

        for (j = 0; j < CurrentEvent->EventsCount; j++) {

            if (Stream) {

                //
                // set up the add and remove handlers for the stream.
                // GUBGUB - Still not see justifications. 
                // don't support IsSupported currently, until
                // a good justification of it is made.
                //

                CurrentEventId->AddHandler = StreamClassEnableEventHandler;
                CurrentEventId->RemoveHandler = StreamClassDisableEventHandler;

            } else {

                //
                // set up the add and remove handlers for the device.
                // GUBGUB - still not see justifications
                // - don't support IsSupported currently, until
                // a good justification of it is made.
                //

                CurrentEventId->AddHandler = StreamClassEnableDeviceEventHandler;
                CurrentEventId->RemoveHandler = StreamClassDisableDeviceEventHandler;

            }                   // if stream


            //
            // index to next property item in
            // array
            //

            CurrentEventId++;

        }                       // for number of event items

        //
        // index to next event set in array
        //

        CurrentEvent++;

    }                           // for number of event sets

}


VOID
SCReadRegistryValues(IN PDEVICE_EXTENSION DeviceExtension,
                     IN PDEVICE_OBJECT PhysicalDeviceObject
)
/*++

Routine Description:

    Reads all registry values for the device

Arguments:

    DeviceExtension - pointer to the device extension
    PhysicalDeviceObject - pointer to the PDO

Return Value:

     None.

--*/

{
    ULONG           i;
    NTSTATUS        Status;
    HANDLE          handle;
    ULONG           DataBuffer;

    PAGED_CODE();

    Status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // loop through our table of strings,
    // reading the registry for each.
    //

    if (NT_SUCCESS(Status)) {

        for (i = 0; i < SIZEOF_ARRAY(RegistrySettings); i++) {

            //
            // read the registry value and set
            // the flag if the setting is true.
            //

            //
            // Need to init each time besides 
            // we only obtain one byte in the DataBuffer
            //
            
            DataBuffer = 0;
            
            Status = SCGetRegistryValue(handle,
                                        RegistrySettings[i].String,
                                        RegistrySettings[i].StringLength,
                                        &DataBuffer,
                                        1);

            DebugPrint((DebugLevelInfo,
                       "Reg Key %S value %x\n",
                       RegistrySettings[i].String,
                       (BYTE)DataBuffer));             
                       
            if ((NT_SUCCESS(Status)) && DataBuffer) {


                //
                // setting is true, so or in the
                // appropriate flag
                //

                DeviceExtension->RegistryFlags |= RegistrySettings[i].Flags;                
            }                   // if true            
        }                       // while strings
        DebugPrint((DebugLevelInfo,"====DeviceObject %x DeviceExtenion %x has RegFlags %x\n",
                   DeviceExtension->DeviceObject,
                   DeviceExtension,
                   DeviceExtension->RegistryFlags ));
                   

        //
        // close the registry handle.
        //

        ZwClose(handle);

    }                           // status = success
}


NTSTATUS
SCGetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PVOID Data,
                   IN ULONG DataLength
)
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    FullInfo = ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }                   // buffer right length

        }                       // if success
        ExFreePool(FullInfo);

    }                           // if fullinfo
    return Status;

}

NTSTATUS
SCReferenceSwEnumDriver(
                  IN PDEVICE_EXTENSION DeviceExtension,
                  IN BOOLEAN Reference  // AddRef or DeRef

)
/*++

Routine Description:

    This routine shows one more reference to the minidriver, and pages
    in the minidriver if the count was zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;
    PBUS_INTERFACE_REFERENCE    BusInterface;

    PMINIDRIVER_INFORMATION MinidriverInfo = DeviceExtension->DriverInfo;

    PAGED_CODE();

    BusInterface = ExAllocatePool(NonPagedPool,
                                  sizeof(BUS_INTERFACE_REFERENCE));
    if (BusInterface == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       DeviceExtension->AttachedPdo,
                                       NULL,
                                       0,
                                       NULL,
                                       &Event,
                                       &IoStatusBlock);
    if (Irp != NULL)
    {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);
        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)&REFERENCE_BUS_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_REFERENCE);
        IrpStackNext->Parameters.QueryInterface.Version = BUS_INTERFACE_REFERENCE_VERSION;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)BusInterface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        Status = IoCallDriver(DeviceExtension->AttachedPdo, Irp);
        if (Status == STATUS_PENDING)
        {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) 
    {
        if (Reference)
            BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
        else    
            BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
    }

    ExFreePool(BusInterface);

    return Status;

}

VOID
SCDereferenceDriver(
                    IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    This routine shows one fewer reference to the minidriver, and pages
    out the minidriver if the count goes to zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{

    PMINIDRIVER_INFORMATION MinidriverInfo;
    PDEVICE_EXTENSION CurrentDeviceExtension;
    BOOLEAN         RequestIssued,
                    DontPage = FALSE;
    KEVENT          Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;
    PDEVICE_OBJECT  DeviceObject;
    NTSTATUS        Status;

    PAGED_CODE();

    //
    // if the driver said it was a SWENUM driver, dereference it.
    //

    if (DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD)
    {
        SCReferenceSwEnumDriver(DeviceExtension,FALSE);
    }

    MinidriverInfo = IoGetDriverObjectExtension(DeviceExtension->DeviceObject->DriverObject,
                                                (PVOID) StreamClassPnP);

    DebugPrint(( DebugLevelVerbose, 
                 "DerefernceDriver %x Count %x DriverFlags=%x\n",
                 DeviceExtension->DeviceObject->DriverObject,
                 MinidriverInfo->UseCount, MinidriverInfo->Flags));
                 
    if (!(MinidriverInfo->Flags & DRIVER_FLAGS_NO_PAGEOUT)) {

        KeWaitForSingleObject(&MinidriverInfo->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        //
        // dec the refcount and see if we can page out.
        //
        DebugPrint(( DebugLevelVerbose, 
                    "DerefernceDriver CountDown\n"));

        ASSERT((LONG) MinidriverInfo->UseCount > 0);

        if (!(--MinidriverInfo->UseCount)) {

            //
            // page out the minidriver after alerting it that we are going to.
            // PNP is supposed to be serialized, so there should be
            // no need to protect this list.  I'm worried about this, tho.
            // need to research. 
            // My unstderstanding is that PnP is serialized.
            //
            // This is by-design, not a bug. 
            // This code assumes that the minidriver will bind only
            // with the stream class.   this needs to be doc'ed in the spec
            // that only single binders will be able to use autopage.
            //

            //
            // find the first device object chained to the driver object.
            //

            DeviceObject = DeviceExtension->DeviceObject->DriverObject->DeviceObject;

                    
            while (DeviceObject) {

                CurrentDeviceExtension = DeviceObject->DeviceExtension;

                DebugPrint((DebugLevelVerbose, 
                        "DerefernceDriver Checking Device=%x\n",
                        DeviceObject));
                        

                //
                // if the device is not started, don't call the minidriver
                // also don't process a child device
                //

                if ((CurrentDeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) &&
                  (!(CurrentDeviceExtension->Flags & DEVICE_FLAGS_CHILD))) {

                    KeInitializeEvent(&Event, NotificationEvent, FALSE);

                    //
                    // allocate IRP for issuing the pageout.  Since this IRP
                    // should not really be referenced, use dummy IOCTL code.
                    // I chose this one since it will always fail in the KS
                    // property handler if someone is silly enough to try to
                    // process it. Also make the irp internal i/o control.
                    //
                    // IoVerifier.c test code does not check IrpStack bound like
                    // the formal production code. And the owner does not want to
                    // fix it. It's more productive just work around here.

                    //Irp = IoBuildDeviceIoControlRequest(
                    //                                    IOCTL_KS_PROPERTY,
                    //                                    DeviceObject,
                    //                                    NULL,
                    //                                    0,
                    //                                    NULL,
                    //                                    0,
                    //                                    TRUE,
                    //                                    &Event,
                    //                                    &IoStatusBlock);
                    
                    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

                    if (!Irp) {

                        //
                        // could not allocate IRP.  don't page out.
                        //

                        DontPage = TRUE;

                        break;
                    }

                    else {
                        PIO_STACK_LOCATION NextStack;
                        //
                        // This is a dummy Irp, the MJ/MN are arbitrary
                        //
                        NextStack = IoGetNextIrpStackLocation(Irp);
                        ASSERT(NextStack != NULL);
                        NextStack->MajorFunction = IRP_MJ_PNP;
                        NextStack->MinorFunction = IRP_MN_CANCEL_STOP_DEVICE;
                        Irp->UserIosb = &IoStatusBlock;
                        Irp->UserEvent = &Event;                        
                    }                                                        

                    //
                    // show one more I/O pending on the device.
                    //
                    DebugPrint((DebugLevelVerbose, 
                            "Sending SRB_PAGING_OUT_DRIVER to Device=%x\n",
                            DeviceObject));

                    InterlockedIncrement(&CurrentDeviceExtension->OneBasedIoCount);

                    Status = SCSubmitRequest(SRB_PAGING_OUT_DRIVER,
                                             (PVOID) NULL,
                                             0,
                                             SCProcessCompletedRequest,
                                             CurrentDeviceExtension,
                                             NULL,
                                             NULL,
                                             Irp,
                                             &RequestIssued,
                                      &CurrentDeviceExtension->PendingQueue,
                                             (PVOID) CurrentDeviceExtension->
                                             MinidriverData->HwInitData.
                                             HwReceivePacket
                        );

                    if (!RequestIssued) {

                        //
                        // could not issue SRB.  complete IRP and don't page
                        // out.
                        //

                        DontPage = TRUE;
                        SCCompleteIrp(Irp, Status, CurrentDeviceExtension);
                        break;

                    }           // if ! requestissued
                    //
                    // check status.  note that we do not check for pending,
                    // since the above call is sync and won't return til the
                    // request is complete.
                    //

                    if (!NT_SUCCESS(Status)) {

                        //
                        // if the minidriver did not OK the pageout, don't
                        // page
                        // out.
                        //

                        DontPage = TRUE;
                        break;

                    }           // if !success
                }               // if started
                DeviceObject = DeviceObject->NextDevice;
            }                   // while deviceobject

            //
            // if we were able to alert each device controlled by the driver
            // that a pageout is emminent, page the driver out.
            //

            if (!DontPage) {

                DebugPrint((DebugLevelVerbose, 
                            "mmPageEntireDriver %x\n",
                            DeviceExtension->DeviceObject->DriverObject));
                            
                MinidriverInfo->Flags |= DRIVER_FLAGS_PAGED_OUT;
                MmPageEntireDriver(MinidriverInfo->HwInitData.HwReceivePacket);

            }                   // if ! dontpage
        }                       // if !usecount
        //
        // release the control event.
        //

        KeSetEvent(&MinidriverInfo->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if pageable
}

VOID
SCReferenceDriver(
                  IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    This routine shows one more reference to the minidriver, and pages
    in the minidriver if the count was zero

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/

{

    PMINIDRIVER_INFORMATION MinidriverInfo = DeviceExtension->DriverInfo;

    PAGED_CODE();

    //
    // if the driver said it was a SWENUM driver, reference it.
    //

    if (DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD)
    {
        SCReferenceSwEnumDriver(DeviceExtension,TRUE);
    }
    
    DebugPrint(( DebugLevelVerbose, 
                 "ReferenceDriver %x Count %x DriverFlags=%x\n",
                 DeviceExtension->DeviceObject->DriverObject,
                 MinidriverInfo->UseCount, MinidriverInfo->Flags));

    if (!(MinidriverInfo->Flags & DRIVER_FLAGS_NO_PAGEOUT)) {

        KeWaitForSingleObject(&MinidriverInfo->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        DebugPrint(( DebugLevelVerbose, 
                     "RefernceDriver Countup\n"));

        //
        // inc the refcount and see if we
        // need to page in.
        //

        ASSERT((LONG) MinidriverInfo->UseCount >= 0);

        if (!(MinidriverInfo->UseCount++)) {

            //
            // page in the minidriver
            //

            MmResetDriverPaging(MinidriverInfo->HwInitData.HwReceivePacket);
            MinidriverInfo->Flags &= ~(DRIVER_FLAGS_PAGED_OUT);

        }                       // if !usecount
        KeSetEvent(&MinidriverInfo->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if pageable
}


VOID
SCInsertStreamInFilter(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    Inserts a new stream in the stream queue on the filter instance

Arguments:

    StreamObject = pointer to stream object

Return Value:

    none.

--*/
{

    KIRQL           Irql;

    //
    // insert the stream object in the filter
    // instance list
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    InsertHeadList(&((PFILTER_INSTANCE) (StreamObject->FilterInstance))->
                   FirstStream,
                   &StreamObject->NextStream);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    return;
}

VOID
SCInsertFiltersInDevice(
                        IN PFILTER_INSTANCE FilterInstance,
                        IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Inserts a new filter in the device list at DPC level

Arguments:

Return Value:

    none.

--*/
{
    KIRQL           Irql;

    //
    // insert the filter instance in the global list
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    InsertHeadList(
                   &DeviceExtension->FilterInstanceList,
                   &FilterInstance->NextFilterInstance);


    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
}

VOID
SCInterlockedRemoveEntryList(
                             PDEVICE_EXTENSION DeviceExtension,
                             PLIST_ENTRY List
)
/*++

Routine Description:

    Removes the specified entry under spinlock

Arguments:

Return Value:

    none.

--*/
{
    KIRQL           Irql;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    RemoveEntryList(List);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

}

VOID
SCProcessTimerRequest(
                      IN PCOMMON_OBJECT CommonObject,
                      IN PINTERRUPT_DATA SavedInterruptData

)
/*++

Routine Description:

    This routine handles a minidriver request to either set or clear a timer

Arguments:

    CommonObject - pointer to common object
    SavedInterruptData - captured interrupt data

Return Value:

    none.

--*/
{
    LARGE_INTEGER   timeValue;

    CommonObject->HwTimerRoutine =
        SavedInterruptData->HwTimerRoutine;

    CommonObject->HwTimerContext =
        SavedInterruptData->HwTimerContext;

    //
    // The minidriver wants a timer request.
    // If the requested timer value is zero,
    // then cancel the timer.
    //

    if (SavedInterruptData->HwTimerValue == 0) {

        KeCancelTimer(&CommonObject->MiniDriverTimer);

    } else {

        //
        // Convert the timer value from
        // microseconds to a negative
        // 100
        // nanoseconds.
        //

//        timeValue.QuadPart = Int32x32To64(
//                   SavedInterruptData->HwTimerValue,
//                   -10);

        timeValue.LowPart = SavedInterruptData->HwTimerValue * -10;
        timeValue.HighPart = -1;

        //
        // Set the timer.
        //

        KeSetTimer(&CommonObject->MiniDriverTimer,
                   timeValue,
                   &CommonObject->MiniDriverTimerDpc);
    }
}


VOID
SCProcessPriorityChangeRequest(
                               IN PCOMMON_OBJECT CommonObject,
                               IN PINTERRUPT_DATA SavedInterruptData,
                               IN PDEVICE_EXTENSION DeviceExtension

)
/*++

Routine Description:

    Routine handles priority change requests from the minidriver

Arguments:

    CommonObject - pointer to common object
    SavedInterruptData - captured interrupt data
    DeviceExtension - pointer to device extension

Return Value:

    none.

--*/
{

#if DBG
    PDEBUG_WORK_ITEM DbgWorkItemStruct;
#endif

    if (SavedInterruptData->HwPriorityLevel == Dispatch) {

        DebugPrint((DebugLevelVerbose, "'SCDpc: Dispatch priority callout\n"));

        //
        // Acquire the device spinlock so
        // nothing else starts.
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

        //
        // call the minidriver at dispatch
        // level.
        //

        SavedInterruptData->HwPriorityRoutine(SavedInterruptData->HwPriorityContext);

        if ((CommonObject->InterruptData.Flags &
             INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST)
            &&
            (CommonObject->InterruptData.HwPriorityLevel == High)) {

            DebugPrint((DebugLevelVerbose, "'SCDpc: High priority callout\n"));

            //
            // if the minidriver now wants a high priority callback,
            // do so now.  This is safe since we have the device
            // spinlock and the minidriver cannot make
            // another priority request for this stream while one is
            // requested.
            //

            CommonObject->InterruptData.Flags &=
                ~(INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST);

            DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                      (PVOID) CommonObject->InterruptData.HwPriorityRoutine,
                             CommonObject->InterruptData.HwPriorityContext);


        }                       // if high requested
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    } else if (SavedInterruptData->HwPriorityLevel == Low) {

#if DBG

        //
        // make sure that the minidriver is not misusing this function.
        //

        if (DeviceExtension->NumberOfRequests > 0xFFFFFFF0) {
            DeviceExtension->Flags |= DEVICE_FLAGS_PRI_WARN_GIVEN;

        }
        if ((++DeviceExtension->NumberOfLowPriCalls > 100) &&
            ((DeviceExtension->NumberOfLowPriCalls) >
             DeviceExtension->NumberOfRequests / 4) &&
            (!(DeviceExtension->Flags & DEVICE_FLAGS_PRI_WARN_GIVEN))) {

            DeviceExtension->Flags |= DEVICE_FLAGS_PRI_WARN_GIVEN;


            DebugPrint((DebugLevelFatal, "Stream Class has determined that a minidriver is scheduling\n"));
            DebugPrint((DebugLevelFatal, "a low priority callback for more than 25 percent of the requests\n"));
            DebugPrint((DebugLevelFatal, "it has received.   This driver should probably be setting the\n"));
            DebugPrint((DebugLevelFatal, "TurnOffSynchronization boolean and doing its own synchronization.\n"));
            DebugPrint((DebugLevelFatal, "Please open a bug against the dev owner of this minidriver.\n"));
            DebugPrint((DebugLevelFatal, "Do an LN of %x to determine the name of the minidriver.\n", SavedInterruptData->HwPriorityRoutine));
            TRAP;
        }                       // if bad pri
        if (CommonObject->InterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

            DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
            ASSERT(1 == 0);
        }                       // if scheduled twice
        DbgWorkItemStruct = ExAllocatePool(NonPagedPool, sizeof(DEBUG_WORK_ITEM));
//        DebugPrint((DebugLevelFatal, "A %x\n", DbgWorkItemStruct));
        if (DbgWorkItemStruct) {

            DbgWorkItemStruct->HwPriorityRoutine = SavedInterruptData->HwPriorityRoutine;
            DbgWorkItemStruct->HwPriorityContext = SavedInterruptData->HwPriorityContext;
            DbgWorkItemStruct->Object = CommonObject;

            ExInitializeWorkItem(&CommonObject->WorkItem,
                                 SCDebugPriorityWorkItem,
                                 DbgWorkItemStruct);
        } else {

            ExInitializeWorkItem(&CommonObject->WorkItem,
                                 SavedInterruptData->HwPriorityRoutine,
                                 SavedInterruptData->HwPriorityContext);
        }

#else



        ExInitializeWorkItem(&CommonObject->WorkItem,
                             SavedInterruptData->HwPriorityRoutine,
                             SavedInterruptData->HwPriorityContext);
#endif

        ExQueueWorkItem(&CommonObject->WorkItem,
                        DelayedWorkQueue);
    }                           // if priority
}

VOID
SCBeginSynchronizedMinidriverCallin(
                                    IN PDEVICE_EXTENSION DeviceExtension,
                                    IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles begin processing of a synchronized minidriver callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/
{
    return;
}

VOID
SCBeginUnsynchronizedMinidriverCallin(
                                      IN PDEVICE_EXTENSION DeviceExtension,
                                      IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles begin processing of an unsynchronized minidriver callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeAcquireSpinLock(&DeviceExtension->SpinLock, Irql);
    \
        return;
}

VOID
SCEndSynchronizedMinidriverStreamCallin(
                                        IN PSTREAM_OBJECT StreamObject,
                                        IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of a synchronized minidriver
    stream callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    SCRequestDpcForStream(StreamObject);
    return;
}

VOID
SCEndSynchronizedMinidriverDeviceCallin(
                                        IN PDEVICE_EXTENSION DeviceExtension,
                                        IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of a synchronized minidriver
    device callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{

    DeviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
    return;
}

VOID
SCEndUnsynchronizedMinidriverDeviceCallin(
                                       IN PDEVICE_EXTENSION DeviceExtension,
                                          IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of an unsynchronized minidriver
    device callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    DeviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);
    KeLowerIrql(*Irql);
    return;
}

VOID
SCEndUnsynchronizedMinidriverStreamCallin(
                                          IN PSTREAM_OBJECT StreamObject,
                                          IN PKIRQL Irql)
/*++

Routine Description:

    This routine handles end processing of an unsynchronized minidriver
    stream callin

Arguments:

    DeviceExtension - pointer to the device extension
    Irql - POINTER to a KIRQL structure

Return Value:

    none.

--*/

{
    KeReleaseSpinLockFromDpcLevel(&StreamObject->DeviceExtension->SpinLock);
    SCRequestDpcForStream(StreamObject);

    StreamClassDpc(NULL,
                   StreamObject->DeviceExtension->DeviceObject,
                   NULL,
                   StreamObject);
    KeLowerIrql(*Irql);
    return;
}


VOID
SCCheckPoweredUp(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine powers up the HW if necessary

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{

    NTSTATUS        Status;
    POWER_STATE     PowerState;
    POWER_CONTEXT   PowerContext;

    PAGED_CODE();

    //
    // check to see if we are powered down
    //

    if (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED) {
        while (DeviceExtension->CurrentPowerState != PowerDeviceD0) {

            //
            // release the event to avoid deadlocks with the power up code.
            //

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // tell the power manager to power up the device.
            //

            PowerState.DeviceState = PowerDeviceD0;

            //
            // now send down a set power based on this info.
            //

            KeInitializeEvent(&PowerContext.Event, NotificationEvent, FALSE);

            Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       SCBustedSynchPowerCompletionRoutine,
                                       &PowerContext,
                                       NULL);

            if (Status == STATUS_PENDING) {

                //
                // wait for the IRP to complete
                //

                KeWaitForSingleObject(
                                      &PowerContext.Event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }
            //
            // reacquire the event and loop if good status. The only reason
            // we would get a good status here is if the HW powered up, but
            // some
            // policy maker instantly powered it down again.  This should
            // never
            // happen more than once, but if it does this thread could be
            // stuck.
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            if (!NT_SUCCESS(PowerContext.Status)) {

                //
                // if we could not power up, go ahead and let the request go
                // through.   The worst that will happen is that the request
                // will fail at the HW level.
                //

                break;
            }
        }

    }                           // if power down when closed
    return;
}

VOID
SCCheckPowerDown(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine powers down the hardware if possible

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{
    NTSTATUS        Status;
    POWER_STATE     PowerState;
    POWER_CONTEXT   PowerContext;

    PAGED_CODE();

    //
    // only power down if there are not open files
    //

    if (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED) {
        if (!DeviceExtension->NumberOfOpenInstances) {

            //
            // release the event to avoid deadlocks with the power up code.
            //

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // tell the power manager to power down the device.
            //

            PowerState.DeviceState = PowerDeviceD3;

            //
            // now send down a set power based on this info.
            //

            KeInitializeEvent(&PowerContext.Event, NotificationEvent, FALSE);

            Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       SCBustedSynchPowerCompletionRoutine,
                                       &PowerContext,
                                       NULL);

            if (Status == STATUS_PENDING) {

                //
                // wait for the IRP to complete
                //

                KeWaitForSingleObject(
                                      &PowerContext.Event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }
            //
            // reacquire the event.
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);
        }
    }                           // if power down closed
    return;
}

VOID
SCWaitForOutstandingIo(
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This routine decs the one based I/O counter and blocks until the counter
    goes to zero.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    none.

--*/
{
    KIRQL           Irql;
    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    if (InterlockedDecrement(&DeviceExtension->OneBasedIoCount)) {

#ifdef wecandothis

        PFILTER_INSTANCE FilterInstance;
        KIRQL           Irql;
        PLIST_ENTRY     FilterEntry,
                        FilterListEntry;

        //
        // there is I/O outstanding.   Cancel all outstanding IRP's.
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

checkfilters:
        FilterInstance = DeviceExtension->GlobalFilterInstance;

        if (FilterInstance) {

            if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, NULL)) {

                DebugPrint((DebugLevelWarning, "'SCCancelPending: found Irp on global instance\n"));

                //
                // we found one.  jump back to loop back through since the
                // spinlock
                // had to be released and reaquired to cancel the irp.
                //

                goto checkfilters;
            }
        }
        FilterListEntry = FilterEntry = &DeviceExtension->FilterInstanceList;

        while (FilterEntry->Flink != FilterListEntry->Blink) {

            FilterEntry = FilterEntry->Flink;

            //
            // follow the link to the instance
            //

            FilterInstance = CONTAINING_RECORD(FilterListEntry,
                                               FILTER_INSTANCE,
                                               NextFilterInstance);

            //
            // process the streams on this list
            //

            if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, NULL)) {

                //
                // we found one.  jump back to loop back through since the
                // spinlock
                // had to be released and reaquired to cancel the irp.
                //

                goto checkfilters;

            }
            //
            // get the list entry for this instance
            //

            FilterListEntry = &FilterInstance->NextFilterInstance;
        }

        //
        // now process any requests on the device itself
        //

        while (SCCheckRequestsForIrp(
         &DeviceExtension->OutstandingQueue, NULL, TRUE, DeviceExtension)) {

        }

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

#endif

        //
        // Block on the removal event which is signaled as the last I/O
        // completes.
        //

        KeWaitForSingleObject(&DeviceExtension->RemoveEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);
    }
    //
    // restore the counter to 1-based, since we've now assured that all
    // I/O to the device has completed.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    return;
}

NTSTATUS
SCShowIoPending(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PIRP Irp
)
/*++

Routine Description:

    This routine shows that one more I/O is outstanding, or errors the I/O
    if the device is inaccessible.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    TRUE if I/O can be submitted.

--*/
{
    PAGED_CODE();

    //
    // assume that the device is accessible and show one more request.
    // if it's not accessible, we'll show one less.   do it in this order
    // to prevent a race where the inaccessible flag has been set, but the
    // the i/o count has not been dec'd yet.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

        NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

        InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (Status);
    }
    return (STATUS_SUCCESS);

}


NTSTATUS
SCCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack,
                    NextStack;
    NTSTATUS        Status;

    PAGED_CODE();

    if ( NULL == DeviceExtension->AttachedPdo ) {
        //
        // DO has been detached, return success directly.
        //
        return STATUS_SUCCESS;
    }

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    NextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(NextStack != NULL);
    RtlCopyMemory(NextStack, IrpStack, sizeof(IO_STACK_LOCATION));

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           SCSynchCompletionRoutine,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    if ( IRP_MJ_POWER != IrpStack->MajorFunction ) {
    
        Status = IoCallDriver(DeviceExtension->AttachedPdo, Irp);
        
    } else {

        //
        // power Irp, use PoCallDriver()
        //
        Status = PoCallDriver( DeviceExtension->AttachedPdo, Irp );
    }
       

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }
    return (Status);
}

VOID
SCMinidriverTimeFunction(
                         IN PHW_TIME_CONTEXT TimeContext
)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) TimeContext->HwDeviceExtension - 1;
    KIRQL           Irql;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                TimeContext->HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    //
    // call the minidriver to process the time function
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);


    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          (PVOID) StreamObject->
                               HwStreamObject.HwClockObject.HwClockFunction,
                                          TimeContext);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

}


ULONGLONG
SCGetStreamTime(
                IN PFILE_OBJECT FileObject

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_GET_STREAM_TIME;

    SCMinidriverTimeFunction(&TimeContext);

    return (TimeContext.Time);
}

ULONGLONG       FASTCALL
                SCGetPhysicalTime(
                                                  IN PFILE_OBJECT FileObject

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_READ_ONBOARD_CLOCK;

    SCMinidriverTimeFunction(&TimeContext);

    return (TimeContext.Time);
}


ULONGLONG       FASTCALL
                SCGetSynchronizedTime(
                                                 IN PFILE_OBJECT FileObject,
                                                    IN PULONGLONG SystemTime

)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    HW_TIME_CONTEXT TimeContext;

    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE) FileObject->FsContext;

    TimeContext.HwStreamObject = &ClockInstance->StreamObject->HwStreamObject;

    TimeContext.HwDeviceExtension = ClockInstance->StreamObject->
        DeviceExtension->HwDeviceExtension;

    TimeContext.Function = TIME_GET_STREAM_TIME;

    SCMinidriverTimeFunction(&TimeContext);

    *SystemTime = TimeContext.SystemTime;
    return (TimeContext.Time);
}

NTSTATUS
SCSendUnknownCommand(
                     IN PIRP Irp,
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PVOID Callback,
                     OUT PBOOLEAN RequestIssued
)
/*++

Routine Description:


Arguments:

    Irp - pointer to the IRP

Return Value:

     NTSTATUS returned as appropriate.

--*/

{

    PAGED_CODE();

    //
    // send an UNKNOWN_COMMAND SRB to the minidriver.
    //

    return (SCSubmitRequest(SRB_UNKNOWN_DEVICE_COMMAND,
                            NULL,
                            0,
                            Callback,
                            DeviceExtension,
                            NULL,
                            NULL,
                            Irp,
                            RequestIssued,
                            &DeviceExtension->PendingQueue,
                            (PVOID) DeviceExtension->
                            MinidriverData->HwInitData.
                            HwReceivePacket
                            ));

}


BOOLEAN
SCMapMemoryAddress(PACCESS_RANGE AccessRanges,
                   PHYSICAL_ADDRESS TranslatedAddress,
                   PPORT_CONFIGURATION_INFORMATION ConfigInfo,
                   PDEVICE_EXTENSION DeviceExtension,
                   PCM_RESOURCE_LIST ResourceList,
                   PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    PMAPPED_ADDRESS newMappedAddress;

    PAGED_CODE();

    //
    // Now we need to map a linear address to the physical
    // address that HalTranslateBusAddress provided us.
    //

    //
    // set the access range in the structure.
    //

    AccessRanges->RangeLength = PartialResourceDescriptor->u.Memory.Length;

    AccessRanges->RangeInMemory = TRUE;

    AccessRanges->RangeStart.QuadPart = (ULONG_PTR) MmMapIoSpace(
                                                          TranslatedAddress,
                                                  AccessRanges->RangeLength,
                                                                 FALSE  // No caching
        );

    if (AccessRanges->RangeStart.QuadPart == 0) {

        //
        // Couldn't translate the resources, return an error
        // status
        //

        DebugPrint((DebugLevelFatal, "StreamClassPnP: Couldn't translate Memory Slot Resources\n"));
        return FALSE;

    }
    //
    // Allocate memory to store mapped address for unmap.
    //

    newMappedAddress = ExAllocatePool(NonPagedPool,
                                      sizeof(MAPPED_ADDRESS));

    //
    // save a link to the resources if the alloc succeeded.
    // if it failed, don't worry about it.
    //

    if (newMappedAddress != NULL) {

        //
        // Store mapped address, bytes count, etc.
        //

        newMappedAddress->MappedAddress = (PVOID)
            AccessRanges->RangeStart.QuadPart;
        newMappedAddress->NumberOfBytes =
            AccessRanges->RangeLength;
        newMappedAddress->IoAddress =
            PartialResourceDescriptor->u.Memory.Start;
        newMappedAddress->BusNumber =
            ConfigInfo->SystemIoBusNumber;

        //
        // Link current list to new entry.
        //

        newMappedAddress->NextMappedAddress =
            DeviceExtension->MappedAddressList;

        //
        // Point anchor at new list.
        //

        DeviceExtension->MappedAddressList = newMappedAddress;

    }                           // if newmappedaddress
    return TRUE;
}


VOID
SCUpdatePersistedProperties(IN PSTREAM_OBJECT StreamObject,
                            IN PDEVICE_EXTENSION DeviceExtension,
                            IN PFILE_OBJECT FileObject
)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    NTSTATUS        Status;
    HANDLE          handle;
    CHAR            AsciiKeyName[32];
    ANSI_STRING     AnsiKeyName;
    UNICODE_STRING  UnicodeKeyName;

    PAGED_CODE();

    Status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // loop through our table of strings,
    // reading the registry for each.
    //

    if (NT_SUCCESS(Status)) {

        //
        // create the subkey for the pin, in the form of "Pin0\Properties",
        // etc.
        //

        sprintf(AsciiKeyName, "Pin%d\\Properties", StreamObject->HwStreamObject.StreamNumber);
        RtlInitAnsiString(&AnsiKeyName, AsciiKeyName);


        if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeKeyName,
                                                    &AnsiKeyName, TRUE))) {
            //
            // call KS to unserialize the properties.
            //

            KsUnserializeObjectPropertiesFromRegistry(FileObject,
                                                      handle,
                                                      &UnicodeKeyName);
            //
            // free the unicode string
            //

            RtlFreeUnicodeString(&UnicodeKeyName);

        }                       // if rtl..
        //
        // close the registry handle.
        //

        ZwClose(handle);


    }                           // status = success
}

NTSTATUS
SCQueryCapabilities(
                    IN PDEVICE_OBJECT PdoDeviceObject,
                    IN PDEVICE_CAPABILITIES DeviceCapabilities
)
/*++

Routine Description:

    This routine reads the capabilities of our parent.

Arguments:

    DeviceObject        - "Real" physical device object

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION NextStack;
    PIRP            Irp;
    NTSTATUS        Status;
    KEVENT          Event;

    PAGED_CODE();

    //
    // allocate an IRP for the call.
    //

    Irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!Irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    NextStack = IoGetNextIrpStackLocation(Irp);

    ASSERT(NextStack != NULL);
    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           SCSynchCompletionRoutine,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    NextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    DebugPrint((DebugLevelInfo, 
                "Capabilities Version %x Flags %x\n", 
                (ULONG)DeviceCapabilities->Version,
                *(UNALIGNED ULONG*)(&DeviceCapabilities->Version+1)));

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;    // bug #282910

    Status = IoCallDriver(PdoDeviceObject,
                          Irp);

    if (Status == STATUS_PENDING) {

        //
        // block waiting for completion
        //

        KeWaitForSingleObject(
                              &Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    //
    // obtain final status and free IRP.
    //

    Status = Irp->IoStatus.Status;

    IoFreeIrp(Irp);

    return (Status);

}

NTSTATUS
SCEnableEventSynchronized(
                          IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine inserts the new event on the queue, and calls the minidriver
    with the event.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PHW_EVENT_DESCRIPTOR Event = ServiceContext;
    NTSTATUS        Status = STATUS_SUCCESS;

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     Event->StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // insert the event on our list, in case the minidriver decides to signal
    // from within this call.
    //

    InsertHeadList(&StreamObject->NotifyList,
                   &Event->EventEntry->ListEntry);

    //
    // call the minidriver's event routine, if present.
    //

    if (StreamObject->HwStreamObject.HwEventRoutine) {

        Status = StreamObject->HwStreamObject.HwEventRoutine(Event);

    }                           // if eventroutine
    if (!NT_SUCCESS(Status)) {

        //
        // minidriver did not like it.  remove the entry from the list.
        //

        DebugPrint((DebugLevelError, "StreamEnableEvent: minidriver failed enable!\n"));

        RemoveEntryList(&Event->EventEntry->ListEntry);
    }
    return (Status);
}

NTSTATUS
SCEnableDeviceEventSynchronized(
                                IN PVOID ServiceContext
)
/*++

Routine Description:

    This routine inserts the new event on the queue, and calls the minidriver
    with the event.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TRUE if there is new work and FALSE otherwise.

Notes:


--*/
{
    PHW_EVENT_DESCRIPTOR Event = ServiceContext;
    NTSTATUS        Status = STATUS_SUCCESS;

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)Event->DeviceExtension - 1;
    IF_MF( PFILTER_INSTANCE FilterInstance = (PFILTER_INSTANCE)Event->HwInstanceExtension -1;)

    //
    // insert the event on our list, in case the minidriver decides to signal
    // from within this call.
    //
	IFN_MF(InsertHeadList(&DeviceExtension->NotifyList,&Event->EventEntry->ListEntry);)
	IF_MF(InsertHeadList(&FilterInstance->NotifyList,&Event->EventEntry->ListEntry);)

    //
    // call the minidriver's event routine, if present.
    //

	IFN_MF(
	    if (DeviceExtension->HwEventRoutine) {

    	    Status = DeviceExtension->HwEventRoutine(Event);

	    }                           // if eventroutine
	)
	IF_MF(
	    if (FilterInstance->HwEventRoutine) {

    	    Status = FilterInstance->HwEventRoutine(Event);

	    }                           // if eventroutine
	)

	
    if (!NT_SUCCESS(Status)) {

        //
        // minidriver did not like it.  remove the entry from the list.
        //

        DebugPrint((DebugLevelError, "DeviceEnableEvent: minidriver failed enable!\n"));

        RemoveEntryList(&Event->EventEntry->ListEntry);
    }
    return (Status);
}

VOID
SCFreeDeadEvents(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Free dead events at passive level

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    LIST_ENTRY      EventList;
    PLIST_ENTRY     EventListEntry;
    PKSEVENT_ENTRY  EventEntry;
    KIRQL           Irql;

    //
    // capture the dead list at the appropriate synchronization level.
    //

    // hack to save code.  store the DeviceExtension* in the list entry.

    EventList.Flink = (PLIST_ENTRY) DeviceExtension;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          (PVOID) SCGetDeadListSynchronized,
                                          &EventList);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    //
    // discard each event on the captured list
    //

    while (!IsListEmpty(&EventList)) {


        EventListEntry = RemoveHeadList(&EventList);

        EventEntry = CONTAINING_RECORD(EventListEntry,
                                       KSEVENT_ENTRY,
                                       ListEntry);

        KsDiscardEvent(EventEntry);
    }                           // while not empty

    //
    // show event has been run
    //

    DeviceExtension->DeadEventItemQueued = FALSE;

    return;
}

VOID
SCGetDeadListSynchronized(
                          IN PLIST_ENTRY NewEventList
)
/*++

Routine Description:

    Get the list of dead events at the appropriate sync level

Arguments:

    NewListEntry - list head to add the event list.

Return Value:

    None

--*/

{

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) NewEventList->Flink;
    PLIST_ENTRY     ListEntry;

    InitializeListHead(NewEventList);


    //
    // capture the dead list to our temp list head
    //

    while (!IsListEmpty(&DeviceExtension->DeadEventList)) {

        ListEntry = RemoveTailList(&DeviceExtension->DeadEventList);

        InsertHeadList(NewEventList,
                       ListEntry);

    }                           // while dead list not empty

    InitializeListHead(&DeviceExtension->DeadEventList);
    return;

}

#if SUPPORT_MULTIPLE_FILTER_TYPES

VOID
SCRescanStreams(
                IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Rescan minidriver streams of all filters with the request

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PFILTER_INSTANCE	FilterInstance;
    BOOLEAN         RequestIssued;
    KEVENT          Event;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;
    ULONG           ul;
    PLIST_ENTRY         Node;

    PAGED_CODE();

    TRAP;
    DebugPrint((DebugLevelVerbose, "'RescanStreams: enter\n"));


    //
    // take the control event to avoid race
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    ASSERT( !IsListEmpty( DeviceExtension->FilterInstanceList ));

        
    Node = &DeviceExtension->FilterInstanceList;

	while ( Node !=  Node->Flink ) {
	    
        FilterInstance = CONTAINING_RECORD(Node,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
    
        if ( InterlockedExchange( &FilterInstance->NeedReenumeration, 0)) {
            //
            // send an SRB to retrieve the stream information
            //
            ASSERT( FilterInstance->StreamDescriptorSize );
            StreamBuffer =
                ExAllocatePool(NonPagedPool,
                       FilterInstance->StreamDescriptorSize);

            if (!StreamBuffer) {
                DebugPrint((DebugLevelError,
                           "RescanStreams: couldn't allocate!\n"));
                TRAP;
                KeSetEvent( &DeviceExtension->ControlEvent,IO_NO_INCREMENT, FALSE);
                return;
            }
            
            //
            // zero-init the buffer
            //

            RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);

            //
            // allocate IRP for issuing the get stream info.
            // Since this IRP
            // should not really be referenced, use dummy IOCTL code.
            // I chose this one since it will always fail in the KS
            // property handler if someone is silly enough to try to
            // process it. Also make the irp internal i/o control.
            //


            // IoVerifier.c test code does not check IrpStack bound like
            // the formal production code. And the owner does not want to
            // fix it. It's more productive just work around here.

            //Irp = IoBuildDeviceIoControlRequest(
            //                                    IOCTL_KS_PROPERTY,
            //                                    DeviceObject,
            //                                    NULL,
            //                                    0,
            //                                    NULL,
            //                                    0,
            //                                    TRUE,
            //                                    &Event,
            //                                    &IoStatusBlock);

            Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
            if (!Irp) {
                //
                // could not allocate IRP.  fail.
                //

          		ExFreePool( StreamBuffer );
                DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
                TRAP;
                return;
            } else {
                PIO_STACK_LOCATION NextStack;
                //
                // This is a dummy Ir, the MJ is arbitrary
                //
                NextStack = IoGetNextIrpStackLocation(Irp);
                ASSERT(NextStack != NULL);
                NextStack->MajorFunction = IRP_MJ_PNP;
                NextStack->MinorFunction = IRP_MN_CANCEL_STOP_DEVICE;
                Irp->UserIosb = &IoStatusBlock;
                Irp->UserEvent = &Event;                        
            }

            //
            // show one more I/O pending on the device.
            //

            InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

            //
            // submit the command to retrieve the stream info.
            // additional processing will be done by the callback
            // procedure.
            //

            Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                             StreamBuffer,
                             ConfigInfo->StreamDescriptorSize,
                             SCStreamInfoCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

        if (!RequestIssued) {
            KeSetEvent( &DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            ExFreePool(StreamBuffer);
            DebugPrint((DebugLevelError, "RescanStreams: couldn't issue request!\n"));
            TRAP;
            SCCompleteIrp(Irp, Status, DeviceExtension);
            return;
        }
    } // check all filterinstances
    
    //
    // processing will continue in callback procedure.
    //
    
    return;
}

#else // SUPPORT_MULTIPLE_FILTER_TYPES

VOID
SCRescanStreams(
                IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Rescan minidriver streams

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo =
    DeviceExtension->ConfigurationInformation;
    BOOLEAN         RequestIssued;
    KEVENT          Event;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;

    PAGED_CODE();

    TRAP;
    DebugPrint((DebugLevelVerbose, "'RescanStreams: enter\n"));

    //
    // send an SRB to retrieve the stream information
    //

    ASSERT(ConfigInfo->StreamDescriptorSize);

    StreamBuffer =
        ExAllocatePool(NonPagedPool,
                       ConfigInfo->StreamDescriptorSize
        );

    if (!StreamBuffer) {

        DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
        TRAP;
        return;
    }
    //
    // take the control event to avoid race
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // zero-init the buffer
    //

    RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);

    //
    // allocate IRP for issuing the get stream info.
    // Since this IRP
    // should not really be referenced, use dummy IOCTL code.
    // I chose this one since it will always fail in the KS
    // property handler if someone is silly enough to try to
    // process it. Also make the irp internal i/o control.
    //

    Irp = IoBuildDeviceIoControlRequest(
                                        IOCTL_KS_PROPERTY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &Event,
                                        &IoStatusBlock);

    if (!Irp) {

        //
        // could not allocate IRP.  fail.
        //
		ExFreePool( StreamBuffer );
        DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
        TRAP;
        return;

    }                           // if ! irp
    //
    // show one more I/O pending on the device.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // submit the command to retrieve the stream info.
    // additional processing will be done by the callback
    // procedure.
    //

    Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                             StreamBuffer,
                             ConfigInfo->StreamDescriptorSize,
                             SCStreamInfoCallback,
                             DeviceExtension,
                             NULL,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

    if (!RequestIssued) {

        ExFreePool(StreamBuffer);
        DebugPrint((DebugLevelError, "RescanStreams: couldn't issue request!\n"));
        TRAP;
        SCCompleteIrp(Irp, Status, DeviceExtension);
        return;

    }
    //
    // processing will continue in callback procedure.
    //

    return;

}
#endif // SUPPORT_MULTIPLE_FILTER_TYPES

BOOLEAN
SCCheckIfStreamsRunning(
                        IN PFILTER_INSTANCE FilterInstance
)
/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    PSTREAM_OBJECT  StreamObject;
    PLIST_ENTRY     StreamListEntry,
                    StreamObjectEntry;

    //
    // process the streams on this list
    //


    StreamListEntry = StreamObjectEntry = &FilterInstance->FirstStream;

    while (StreamObjectEntry->Flink != StreamListEntry) {

        StreamObjectEntry = StreamObjectEntry->Flink;

        //
        // follow the link to the stream
        // object
        //

        StreamObject = CONTAINING_RECORD(StreamObjectEntry,
                                         STREAM_OBJECT,
                                         NextStream);

        if (StreamObject->CurrentState == KSSTATE_RUN) {

            return (TRUE);


        }                       // if running
    }                           // while streams

    return (FALSE);

}

VOID
SCCallBackSrb(
              IN PSTREAM_REQUEST_BLOCK Srb,
              IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    KIRQL           Irql;

    if (DeviceExtension->NoSync) {

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        if (Srb->DoNotCallBack) {
            TRAP;
            DebugPrint((DebugLevelError, "'ScCallback: NOT calling back request - Irp = %x",
                        Srb->HwSRB.Irp));
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            return;

        }                       // if NoCallback
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }                           // if NoSync
    (Srb->Callback) (Srb);

}

#if DBG
VOID
SCDebugPriorityWorkItem(
                        IN PDEBUG_WORK_ITEM WorkItemStruct
)
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/

{
    PCOMMON_OBJECT  Object = WorkItemStruct->Object;
    PHW_PRIORITY_ROUTINE Routine = WorkItemStruct->HwPriorityRoutine;
    PVOID           Context = WorkItemStruct->HwPriorityContext;

//    DebugPrint((DebugLevelFatal, "F %x\n", WorkItemStruct));
    ExFreePool(WorkItemStruct);

    Object->PriorityWorkItemScheduled = FALSE;

    if (Object->InterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
        ASSERT(1 == 0);
    }                           // if scheduled twice
    Routine(Context);

    if (Object->InterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
        ASSERT(1 == 0);
    }                           // if scheduled twice
}

#endif

PKSPROPERTY_SET
SCCopyMinidriverProperties(
                           IN ULONG NumProps,
                           IN PKSPROPERTY_SET MinidriverProps
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumProps - number of properties to process
    MinidriverProps - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSPROPERTY_ITEM CurrentPropItem;
    PKSPROPERTY_SET CurrentProp;
    ULONG           i,
                    BufferSize;
    PVOID           NewPropertyBuffer;

    #if DBG
    ULONG           TotalBufferUsed;
    #endif

    PAGED_CODE();

    CurrentProp = MinidriverProps;
    BufferSize = NumProps * sizeof(KSPROPERTY_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumProps; i++) {

        BufferSize += CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentProp++;

    }                           // for number of property sets

    if (!(NewPropertyBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewPropertyBuffer,
                  MinidriverProps,
                  sizeof(KSPROPERTY_SET) * NumProps);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentProp = (PKSPROPERTY_SET) NewPropertyBuffer;
    CurrentPropItem = (PKSPROPERTY_ITEM) ((ULONG_PTR) NewPropertyBuffer + sizeof(KSPROPERTY_SET) * NumProps);

    #if DBG
    TotalBufferUsed = sizeof(KSPROPERTY_SET) * NumProps;
    #endif

    for (i = 0; i < NumProps; i++) {

        RtlCopyMemory(CurrentPropItem,
                      CurrentProp->PropertyItem,
                    CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM));

        #if DBG
        TotalBufferUsed += CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
        #endif

        CurrentProp->PropertyItem = CurrentPropItem;

        CurrentPropItem += CurrentProp->PropertiesCount;
        CurrentProp++;

    }

    return ((PKSPROPERTY_SET) NewPropertyBuffer);

}


PKSEVENT_SET
SCCopyMinidriverEvents(
                       IN ULONG NumEvents,
                       IN PKSEVENT_SET MinidriverEvents
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumEvents - number of event sets to process
    MinidriverEvents - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSEVENT_ITEM   CurrentEventItem;
    PKSEVENT_SET    CurrentEvent;
    ULONG           i,
                    BufferSize;
    PVOID           NewEventBuffer;

	#if DBG
    ULONG           TotalBufferUsed;
	#endif

    PAGED_CODE();

    CurrentEvent = MinidriverEvents;
    BufferSize = NumEvents * sizeof(KSEVENT_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumEvents; i++) {

        BufferSize += CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentEvent++;

    }                           // for number of property sets

    if (!(NewEventBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewEventBuffer,
                  MinidriverEvents,
                  sizeof(KSEVENT_SET) * NumEvents);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentEvent = (PKSEVENT_SET) NewEventBuffer;
    CurrentEventItem = (PKSEVENT_ITEM) ((ULONG_PTR) NewEventBuffer + sizeof(KSEVENT_SET) * NumEvents);

	#if DBG
    TotalBufferUsed = sizeof(KSEVENT_SET) * NumEvents;
	#endif

    for (i = 0; i < NumEvents; i++) {

        RtlCopyMemory(CurrentEventItem,
                      CurrentEvent->EventItem,
                      CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM));

		#if DBG
        TotalBufferUsed += CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
		#endif

        CurrentEvent->EventItem = CurrentEventItem;

        CurrentEventItem += CurrentEvent->EventsCount;
        CurrentEvent++;

    }

    return ((PKSEVENT_SET) NewEventBuffer);

}

#ifdef ENABLE_KS_METHODS

PKSMETHOD_SET
SCCopyMinidriverMethods(
                           IN ULONG NumMethods,
                           IN PKSMETHOD_SET MinidriverMethods
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumMethods - number of properties to process
    MinidriverMethods - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSMETHOD_ITEM CurrentMethodItem;
    PKSMETHOD_SET CurrentMethod;
    ULONG           i,
                    BufferSize;
    PVOID           NewMethodBuffer;

	#if DBG
    ULONG           TotalBufferUsed;
	#endif

    PAGED_CODE();

    CurrentMethod = MinidriverMethods;
    BufferSize = NumMethods * sizeof(KSMETHOD_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumMethods; i++) {

        BufferSize += CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentMethod++;

    }                           // for number of property sets

    if (!(NewMethodBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewMethodBuffer,
                  MinidriverMethods,
                  sizeof(KSMETHOD_SET) * NumMethods);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentMethod = (PKSMETHOD_SET) NewMethodBuffer;
    CurrentMethodItem = (PKSMETHOD_ITEM) ((ULONG_PTR) NewMethodBuffer + sizeof(KSMETHOD_SET) * NumMethods);

	#if DBG
    TotalBufferUsed = sizeof(KSMETHOD_SET) * NumMethods;
	#endif

    for (i = 0; i < NumMethods; i++) {

        RtlCopyMemory(CurrentMethodItem,
                      CurrentMethod->MethodItem,
                      CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM));

		#if DBG
        TotalBufferUsed += CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
		#endif

        CurrentMethod->MethodItem = CurrentMethodItem;

        CurrentMethodItem += CurrentMethod->MethodsCount;
        CurrentMethod++;

    }

    return ((PKSMETHOD_SET) NewMethodBuffer);

}

VOID
SCUpdateMinidriverMethods(
                             IN ULONG NumMethods,
                             IN PKSMETHOD_SET MinidriverMethods,
                             IN BOOLEAN Stream
)
/*++

Routine Description:

     Process method to the device.

Arguments:

    NumMethods - number of methods to process
    MinidriverMethods - pointer to the array of methods to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSMETHOD_ITEM CurrentMethodId;
    PKSMETHOD_SET CurrentMethod;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's property info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentMethod = MinidriverMethods;

    for (i = 0; i < NumMethods; i++) {

        CurrentMethodId = (PKSMETHOD_ITEM) CurrentMethod->MethodItem;

        for (j = 0; j < CurrentMethod->MethodsCount; j++) {

            //
            // if support handler is supported, send it to the handler
            //

            if (CurrentMethodId->SupportHandler) {

                if (Stream) {

                    CurrentMethodId->SupportHandler = StreamClassMinidriverStreamMethod;

                } else {

                    CurrentMethodId->SupportHandler = StreamClassMinidriverDeviceMethod;
                }               // if stream

            }
            //
            // if method routine is
            // supported, add our vector.
            //

            if (CurrentMethodId->MethodHandler) {

                if (Stream) {

                    CurrentMethodId->MethodHandler = StreamClassMinidriverStreamMethod;
                } else {

                    CurrentMethodId->MethodHandler = StreamClassMinidriverDeviceMethod;
                }               // if stream

            }                   // if supported

            //
            // index to next method item in
            // array
            //

            CurrentMethodId++;

        }                       // for number of property items

        //
        // index to next method set in
        // array
        //

        CurrentMethod++;

    }                           // for number of method sets

}



NTSTATUS
SCMinidriverDeviceMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
)
/*++

Routine Description:

     Process get/set method to the device.

Arguments:

    Command - either GET or SET method
    Irp - pointer to the IRP
    Method - pointer to the method structure
    MethodInfo - buffer for method information

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PSTREAM_METHOD_DESCRIPTOR MethodDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    MethodDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_METHOD_DESCRIPTOR));
    if (MethodDescriptor == NULL) {
        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelError,
                    "SCDeviceMethodHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the method set.
    //
    // this value is calculated by subtracting the base method set
    // pointer from the requested method set pointer.
    //
    // The requested method set is pointed to by Context[0] by
    // KsMethodHandler.
    //

    MethodDescriptor->MethodSetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         IFN_MF((ULONG_PTR) DeviceExtension->DeviceMethodsArray)
         IF_MF((ULONG_PTR) FilterInstance->DeviceMethodsArray)
         ) / sizeof(KSMETHOD_SET);

    MethodDescriptor->Method = Method;
    MethodDescriptor->MethodInfo = MethodInfo;
    MethodDescriptor->MethodInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    MethodDescriptor->MethodOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // send a get or set method SRB to the device.
    //

    Status = SCSubmitRequest(Command,
                             MethodDescriptor,
                             0,
                             SCProcessCompletedMethodRequest,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );
    if (!RequestIssued) {

        DEBUG_BREAKPOINT();
        ExFreePool(MethodDescriptor);
    }
    return (Status);
}

NTSTATUS
SCMinidriverStreamMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
)
/*++

Routine Description:

     Process get or set method to the device.

Arguments:

    Command - either GET or SET method
    Irp - pointer to the IRP
    Method - pointer to the method structure
    MethodInfo - buffer for method information

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    PSTREAM_METHOD_DESCRIPTOR MethodDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    StreamObject = IrpStack->FileObject->FsContext;

    MethodDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_METHOD_DESCRIPTOR));
    if (MethodDescriptor == NULL) {
        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelError,
                    "SCDeviceMethodHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the method set.
    //
    // this value is calculated by subtracting the base method set
    // pointer from the requested method set pointer.
    //
    // The requested method set is pointed to by Context[0] by
    // KsMethodHandler.
    //

    MethodDescriptor->MethodSetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         (ULONG_PTR) StreamObject->MethodInfo)
        / sizeof(KSMETHOD_SET);

    MethodDescriptor->Method = Method;
    MethodDescriptor->MethodInfo = MethodInfo;
    MethodDescriptor->MethodInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    MethodDescriptor->MethodOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // send a get or set method SRB to the stream.
    //

    Status = SCSubmitRequest(Command,
                             MethodDescriptor,
                             0,
                             SCProcessCompletedMethodRequest,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {

        DEBUG_BREAKPOINT();
        ExFreePool(MethodDescriptor);
    }
    return (Status);
}

NTSTATUS
SCProcessCompletedMethodRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a method request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // free the method info structure and
    // complete the request
    //

    ExFreePool(SRB->HwSRB.CommandData.MethodInfo);

    //
    // set the information field from the SRB
    // transferlength field
    //

    SRB->HwSRB.Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    return (SCDequeueAndDeleteSrb(SRB));

}
#endif // ENABLE_KS_METHODS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF
$(O)\codcls.def: ..\codcls.def
        $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\codcls.h ===
#define ENABLE_STREAM_CLASS_AS_ALLOCATOR
#define ENABLE_KS_METHODS
#define ENABLE_MULTIPLE_FILTER_TYPES 1	// enable/disable support for multiple
										// filters on a single hardware/driver.
//
// when the code for the method support is finally done, STRMINI.H will have
// to be checked into the tree also, in the include directory.
//

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codcls.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common CODEC class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

#ifndef _STREAMCLASS_H
#define _STREAMCLASS_H

#include "messages.h"
#include "strmini.h"
#include <stdarg.h>

#ifndef _WIN64
// 4 byte alignment causes Alignment Fault for spinlock.
#pragma pack(4)
#endif

#if ENABLE_MULTIPLE_FILTER_TYPES
#define IF_MF( s ) s
#define IF_MFS( s ) { s }
#define IFN_MF( s )
#define IFN_MFS( s )
#define MFTRACE( s ) StreamClassDebugPrint s
#else
#define IF_MF( s ) 
#define IF_MFS( s )
#define IFN_MF( s ) s
#define IFN_MFS( s ) { s }
#define MFTRACE( s ) 
#endif 

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//
// this is a debug string header
//
#define STR_MODULENAME "STREAM.SYS:"
//
// define some data allocation tags
//
#define STREAMCLASS_TAG_STREAMHEADER      'pdCS'
#define STREAMCLASS_TAG_FILTERCONNECTION  '10CS'
#define STREAMCLASS_TAG_DATAFORMAT        '20CS'
#define ID_DATA_DESTINATION_PIN     0
#define ID_DATA_SOURCE_PIN          1
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

#define MAX_STRING_LENGTH 256

#define TRAP DEBUG_BREAKPOINT()

//
// the following macros are used to correctly synchronize class driver entry
// points called by the minidriver.
//

#define BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, Irql) { \
    DeviceExtension->BeginMinidriverCallin(DeviceExtension, \
                                           Irql);  \
    ASSERT(++DeviceExtension->LowerApiThreads == 1);\
}                                                  

#define END_MINIDRIVER_STREAM_CALLIN(StreamObject, Irql) { \
    ASSERT(--DeviceExtension->LowerApiThreads == 0);\
    DeviceExtension->EndMinidriverStreamCallin(StreamObject, \
                                      Irql); \
}


#define BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, Irql) { \
    DeviceExtension->BeginMinidriverCallin(DeviceExtension, \
                                      Irql);  \
    ASSERT(++DeviceExtension->LowerApiThreads == 1);\
}

#define END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, Irql) { \
    ASSERT(--DeviceExtension->LowerApiThreads == 0);\
    DeviceExtension->EndMinidriverDeviceCallin(DeviceExtension, \
                                      Irql); \
}

//
// The following flags should not be cleared from the interrupt data structure
// by SCGetInterruptState.
//

#define STREAM_FLAGS_INTERRUPT_FLAG_MASK 0

//
// Device Extension flags follow - PASSIVE LEVEL ACCESS ONLY!!!!!!
//

//
// Indicates that the PNP start function has been received for the device.
//

#define DEVICE_FLAGS_PNP_STARTED               0x00001

//
// Indicates that this device is a child device (PDO)
//

#define DEVICE_FLAGS_CHILD                     0x0002

//
// indicates that the device has been removed
//

#define DEVICE_FLAGS_DEVICE_INACCESSIBLE   0x00100

//
// debug flag indicates that we've warned of too many low pri calls
//

#define DEVICE_FLAGS_PRI_WARN_GIVEN 0x00200

//
// flag indicates that we've received an NT style surprise remove call
//

#define DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED 0x00400

//
// flag indicated that a Child device ( PDO ) has received a remove
//

#define DEVICE_FLAGS_CHILD_MARK_DELETE 0x00800

//
// flag indicates (FDO) has enum children from registry
//

#define DEVICE_FLAGS_CHILDREN_ENUMED 0x01000

//
// device registry flags follow
//

//
// page out the driver when not opened
//

#define DEVICE_REG_FL_PAGE_CLOSED 0x00000001

//
// page out the driver when opened but idle
//

#define DEVICE_REG_FL_PAGE_IDLE 0x00000002

//
// power down the device when not opened
//

#define DEVICE_REG_FL_POWER_DOWN_CLOSED 0x00000004

//
// don't suspend if any pins are running
//

#define DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING 0x00000008

//
// This driver uses SWEnum to load, which means it is a kernel mode
// streaming driver that has no hardware associated with it. We need to
// AddRef/DeRef this driver special.
//

#define DRIVER_USES_SWENUM_TO_LOAD 0x00000010

//
// This flag indicates that the dirver is OK for system power to go to
// hibernation, even the driver does not process/support the irp_mn_query_power
// for system power hinbernation.
//

#define DEVICE_REG_FL_OK_TO_HIBERNATE 0x00000020

//
// The following flags should not be cleared from the interrupt data structure
// by SCGetInterruptState.
//

#define DEVICE_FLAGS_INTERRUPT_FLAG_MASK        0


//
// Interrupt flags follow.
//
//
// Indicates that StreamClassCompletionDpc needs to be run.  This is set when
// A minidriver makes a request which must be done at DPC and is cleared when
// when the request information is gotten by MpGetInterruptState.
//

#define INTERRUPT_FLAGS_NOTIFICATION_REQUIRED     0x00001

//
// Indicates the minidriver is wants a timer request.  Set by
// StreamClassNotification and cleared by MpGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define INTERRUPT_FLAGS_TIMER_CALL_REQUEST        0x00002

//
// Indicates the minidriver is wants a priority change.  Set by
// StreamClassRequestNewPriority and cleared by SCGetInterruptState.  This flag
// is stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST   0x00004

//
// Indicates that the PNP stop function has been received for the device.
//

#define INTERRUPT_FLAGS_LOG_ERROR                 0x00008

//
// Indicates that the clock is beinq queried.
//

#define INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST       0x00010

//
// Indicates that the streams need to be rescanned.
//

#define INTERRUPT_FLAGS_NEED_STREAM_RESCAN       0x00020

//
// Pointer to the synchronize execution routine.
//

typedef
BOOLEAN
(__stdcall * PSYNCHRONIZE_ROUTINE) (
	IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext);

//
// Pointer to the begin minidriver callin routine.
//

typedef         VOID
                (__stdcall * PBEGIN_CALLIN_ROUTINE) (
                              IN struct _DEVICE_EXTENSION * DeviceExtension,
                                                              IN PKIRQL Irql
);

//
// Pointer to the end minidriver callin routine.
//

typedef
                VOID
                (__stdcall * PEND_DEVICE_CALLIN_ROUTINE) (
                              IN struct _DEVICE_EXTENSION * DeviceExtension,
                                                              IN PKIRQL Irql
);

typedef
                VOID
                (__stdcall * PEND_STREAM_CALLIN_ROUTINE) (
                                    IN struct _STREAM_OBJECT * StreamObject,
                                                              IN PKIRQL Irql
);

//
// Queue link for mapped addresses stored for unmapping.
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID           MappedAddress;
    ULONG           NumberOfBytes;
    LARGE_INTEGER   IoAddress;
    ULONG           BusNumber;
}               MAPPED_ADDRESS, *PMAPPED_ADDRESS;

//
// error log entry definition
//

typedef struct _ERROR_LOG_ENTRY {
    NTSTATUS        ErrorCode;  // error code
    ULONG           SequenceNumber; // request sequence number
    ULONG           UniqueId;   // uniqe ID for the error
}               ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
// callback procedure definition
//

typedef         NTSTATUS
                (*PSTREAM_CALLBACK_PROCEDURE) (
                                                               IN PVOID SRB
);

typedef         VOID
                (*PSTREAM_ASYNC_CALLBACK_PROCEDURE) (
                                                               IN  struct _STREAM_REQUEST_BLOCK *SRB
);

//
// STREAM request block
//

typedef struct _STREAM_REQUEST_BLOCK {
    HW_STREAM_REQUEST_BLOCK HwSRB;
    ULONG           Flags;
    ULONG           SequenceNumber;
    ULONG           ExtensionLength;
    PMDL            Mdl;
    PVOID           MapRegisterBase;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG           Length;
    PSTREAM_ASYNC_CALLBACK_PROCEDURE Callback;
    LIST_ENTRY      SRBListEntry;
    KEVENT          Event;
    ULONG           StreamHeaderSize;
    BOOLEAN         DoNotCallBack;
    KEVENT          DmaEvent;
    BOOLEAN         bMemPtrValid;
    PVOID           *pMemPtrArray;
}               STREAM_REQUEST_BLOCK, *PSTREAM_REQUEST_BLOCK;

//
// SRB flags (not to be confused with the HW SRB flags)
//

#define SRB_FLAGS_IS_ACTIVE 0x00000001

//
// define the minidriver information structure
//

typedef struct _MINIDRIVER_INFORMATION {
    HW_INITIALIZATION_DATA HwInitData;
    ULONG           Flags;
    KEVENT          ControlEvent;
    ULONG           UseCount;
    ULONG           OpenCount;
} MINIDRIVER_INFORMATION, *PMINIDRIVER_INFORMATION;

//
// flags for minidriver information Flags field above
//

//
// indicates that the driver may not be paged out
//

#define DRIVER_FLAGS_NO_PAGEOUT 0x01

//
// indicates that the driver has been paged out
//

#define DRIVER_FLAGS_PAGED_OUT 0x02

//
// pin info not contained in the pin description
//

typedef struct _ADDITIONAL_PIN_INFO {

    ULONG           CurrentInstances;
    ULONG           MaxInstances;

    // NextFileObject must be per instance, i.e. can't be here. 
    // Move to streamobject
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    //PFILE_OBJECT    NextFileObject;         // The chained file object
	#endif
	ULONG           Reserved;
} ADDITIONAL_PIN_INFO, *PADDITIONAL_PIN_INFO;

//
// Define data storage for access at interrupt Irql.
//

typedef struct _INTERRUPT_DATA {

    //
    // interrupt flags
    //

    ULONG           Flags;

    ERROR_LOG_ENTRY LogEntry;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PHW_STREAM_REQUEST_BLOCK CompletedSRB;

    //
    // Minidriver timer request routine.
    //

    PHW_TIMER_ROUTINE HwTimerRoutine;

    //
    // Mindriver timer request time in micro seconds.
    //

    ULONG           HwTimerValue;

    PVOID           HwTimerContext;

    //
    // Mindriver priority change routine.
    //

    PHW_PRIORITY_ROUTINE HwPriorityRoutine;

    //
    // Mindriver priority change level.
    //

    STREAM_PRIORITY HwPriorityLevel;
    PVOID           HwPriorityContext;

    PHW_QUERY_CLOCK_ROUTINE HwQueryClockRoutine;
    TIME_FUNCTION   HwQueryClockFunction;


}               INTERRUPT_DATA, *PINTERRUPT_DATA;

//
// object common to both stream and filter instances
//

typedef struct _COMMON_OBJECT {
    PVOID DeviceHeader;
    ULONG Cookie;
#ifdef _WIN64
    ULONG Alignment;
#endif // _WIN64
    INTERRUPT_DATA  InterruptData;
    PHW_TIMER_ROUTINE HwTimerRoutine;   // Timer request routine
    PVOID           HwTimerContext;
    KTIMER          MiniDriverTimer;    // Miniclass timer object.
    KDPC            MiniDriverTimerDpc; // Miniclass DPC for timer object.
    WORK_QUEUE_ITEM WorkItem;
	#if DBG
    BOOLEAN         PriorityWorkItemScheduled;
	#endif    
}               COMMON_OBJECT, *PCOMMON_OBJECT;

//
// stream name info
//

typedef struct _STREAM_OPEN_INFORMATION {
    WCHAR           Guid[11];
    ULONG           Instance;
}               STREAM_OPEN_INFORMATION, *PSTREAM_OPEN_INFORMATION;

//
// clock instance structure
//

typedef struct _CLOCK_INSTANCE {

    PVOID DeviceHeader;
    PFILE_OBJECT    ParentFileObject;
    //PFILE_OBJECT    ClockFileObject; johnlee
    struct _STREAM_OBJECT *StreamObject;
}               CLOCK_INSTANCE, *PCLOCK_INSTANCE;

//
// master clock info structure
//

typedef struct _MASTER_CLOCK_INFO {

    PFILE_OBJECT    ClockFileObject;
    KSCLOCK_FUNCTIONTABLE FunctionTable;
} MASTER_CLOCK_INFO, *PMASTER_CLOCK_INFO;


#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
typedef enum {
    PinStopped,
    PinStopPending,
    PinPrepared,
    PinRunning
} PIN_STATE;

typedef enum {
    IrpSource,
    IrpSink,
} PIN_TYPE;

#define READ  0
#define WRITE 1
typedef struct _QUEUE {
    KSPIN_LOCK      QueueLock;
    LIST_ENTRY      ActiveQueue;
    WORK_QUEUE_ITEM     WorkItem;
    BOOL                WorkItemQueued;
    } QUEUE, PQUEUE;

#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

//
// TODO: WORKITEM: remove this once KS can multiplex cleanup calls.
//
#define STREAM_OBJECT_COOKIE 0xd73afe3f
typedef struct _COOKIE_CHECK {
    
    PVOID Header;
    ULONG PossibleCookie;

} COOKIE_CHECK, *PCOOKIE_CHECK;

//
// stream object definition
//


typedef struct _STREAM_OBJECT {
    COMMON_OBJECT   ComObj;
    PFILE_OBJECT    FilterFileObject;
    PFILE_OBJECT    FileObject;
    struct _FILTER_INSTANCE *FilterInstance;
    HW_STREAM_OBJECT HwStreamObject;
    LIST_ENTRY      DataPendingQueue;
    LIST_ENTRY      ControlPendingQueue;
    LIST_ENTRY      OutstandingQueue;
    LIST_ENTRY      NextStream;
    LIST_ENTRY      NotifyList;
    struct _DEVICE_EXTENSION *DeviceExtension;
    struct _STREAM_OBJECT *NextNeedyStream;
    PKSPROPERTY_SET PropertyInfo;
    ULONG           PropInfoSize;
    PKSEVENT_SET EventInfo;
    ULONG           EventInfoCount;
    KEVENT          ControlSetMasterClock; // to serialize SetMasterClock
    KSPIN_LOCK      LockUseMasterClock;    // control use of MasterClockInfo
    PMASTER_CLOCK_INFO MasterClockInfo;
    PCLOCK_INSTANCE ClockInstance;
    PKSPROPERTY_SET ConstructedPropertyInfo;
    ULONG           ConstructedPropInfoSize;
    KSSTATE         CurrentState;
    BOOLEAN         ReadyForNextControlReq;
    BOOLEAN         ReadyForNextDataReq;
    BOOLEAN         OnNeedyQueue;
    BOOLEAN         InFlush;
    
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

    PIN_STATE       PinState;
    PIN_TYPE        PinType;            // IrpSource or IrpSink
    PFILE_OBJECT    AllocatorFileObject;
    PFILE_OBJECT    NextFileObject;
    LIST_ENTRY      FreeQueue;
    KSPIN_LOCK      FreeQueueLock;
    KEVENT              StopEvent;
    PKSDATAFORMAT       DataFormat;
    ULONG               PinId;
    HANDLE              PinToHandle;
    KSALLOCATOR_FRAMING Framing;
    BOOL                EndOfStream;
    QUEUE               Queues[2];

	#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

	#ifdef ENABLE_KS_METHODS
    PKSMETHOD_SET   MethodInfo;
    ULONG           MethodInfoSize;
	#endif

    BOOLEAN         StandardTransport;
    
    //
    // This keeps track of the number of frames in circulation between the
    // output and the downstream input.  It is a total count of those frames
    // queued to EITHER pin or in a pending list OTHER THAN THE FREE LIST
    // on the output pin.
    //
    LONG            QueuedFramesPlusOne;

} STREAM_OBJECT, *PSTREAM_OBJECT;

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//
// NOTE!  This is the minimal structure size for STREAM_HEADER_EX.
// The connected pins are queried for the actual header size (including
// whatever extended header size is required).
//

typedef struct _STREAM_HEADER_EX *PSTREAM_HEADER_EX;
typedef struct _STREAM_HEADER_EX {
    ULONG               WhichQueue;
    ULONG               Id;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              CompletionEvent;
    LIST_ENTRY          ListEntry;
    ULONG               ReferenceCount;
    PFILE_OBJECT        OwnerFileObject;
    PFILE_OBJECT        NextFileObject;     // next one to stream to.
    
	#if (DBG)
    PVOID               Data;
    ULONG               OnFreeList;
    ULONG               OnActiveList;
	#else
    ULONG               Reserved;
	#endif
	
    KSSTREAM_HEADER     Header;

} STREAM_HEADER_EX, *PSTREAM_HEADER_EX;
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR
 
//
// struct for retrieving the interrupt data
//

typedef struct _INTERRUPT_CONTEXT {
    PSTREAM_OBJECT  NeedyStream;
    struct _DEVICE_EXTENSION *DeviceExtension;
    PINTERRUPT_DATA SavedStreamInterruptData;
    PINTERRUPT_DATA SavedDeviceInterruptData;
} INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

//
// Performance improvement chance - array for stream prop & event pointers
//

typedef struct _STREAM_ADDITIONAL_INFO {
   PKSPROPERTY_SET StreamPropertiesArray;
   PKSEVENT_SET StreamEventsArray;
} STREAM_ADDITIONAL_INFO, *PSTREAM_ADDITIONAL_INFO;

//
// filter instance structure
// (right now, this is global across all same filter creates!)
//

#if ENABLE_MULTIPLE_FILTER_TYPES

//
// for forward reference in FILTER_INSTANCE
//
typedef struct _DEVICE_EXTENSION;

//
// I claim that as it currently stands, 5/17/99 "No multiple instance
// mini driver works" because the bug in stream.sys. Therefore, backward
// compatibility is only a concern for single instance mini drivers.
//
// The reason is the implemention following:
//   FilterDispatchGlobalCreate()
//   {
//		...
//		if (!DeviceExtension->GlobalFilterInstance) {
//			
//
//			Status = SCOpenMinidriverInstance(DeviceExtension,
//                                  &FilterInstance,
//                                  SCGlobalInstanceCallback,
//                                  Irp);
//			...
//	        if (NT_SUCCESS(Status)) {
//				...
//			    DeviceExtension->GlobalFilterInstance = FilterInstance;
//				...
//			}
//		}
//		else { // will not call mini drivers
//		}
//	  }
//
//  At the 2nd call, the FilterInstance will point to the same 1st one.
//  
// We are braching out code here to support Multiple Filters without
// disturbing the exisitng support to max the backward compatibilty.
// The multiple filter support include 1 type n instances,
// and m types p instances.
//
// MinidriverData->HwInitData.
// 1 x 1	FilterInstanceExtensionSize =0 NumNameExtension	=0
// 1 x n	FilterInstanceExtensionSize!=0 NumNameExtension =0
// m x p	FilterInstanceExtensionSize!=0 NumNameExtension!=0 
//

typedef struct _FILTER_TYPE_INFORMATION {
    UNICODE_STRING          *SymbolicLinks;
    ULONG                   LinkNameCount;
    PHW_STREAM_DESCRIPTOR   StreamDescriptor;
    ULONG                   Reserved;
} FILTER_TYPE_INFO;

typedef FILTER_TYPE_INFO *PFILTER_TYPE_INFO;

#endif

typedef struct _DEVICE_EXTENSION;

typedef struct _FILTER_INSTANCE {
    PVOID           DeviceHeader;
    PDEVICE_OBJECT  DeviceObject;
    LIST_ENTRY      NextFilterInstance; // internal linked list of filter I's.
    LIST_ENTRY      FirstStream;
    PVOID           HwInstanceExtension;	
    PADDITIONAL_PIN_INFO PinInstanceInfo;   // pointer to array of pins
                                            // allocated directly below this
                                            // structure.
	#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
	//
	// Feature work: add per filter filter type when data splitting is enabled!
	//
    PKSWORKER           WorkerRead;         
    PKSWORKER           WorkerWrite;        

	#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

	#ifdef ENABLE_KS_METHODS
	IF_MF(	
	 	PKSMETHOD_SET DeviceMethodsArray;	// from pDevExt
	)
	#endif

	#define SIGN_FILTER_INSTANCE 'FrtS' //StrF
	#if ENABLE_MULTIPLE_FILTER_TYPES
	#define ASSERT_FILTER_INSTANCE(FI) ASSERT((FI)->Signature==SIGN_FILTER_INSTANCE)
	#else
	#define ASSERT_FILTER_INSTANCE(FI)
	#endif
	
	IF_MF( 
	    ULONG   Signature;
	    PKSPIN_DESCRIPTOR PinInformation; 	// moved from pDevExt
  		//ULONG           PinInformationSize;	// from pDevExt,not used
	    ULONG           NumberOfPins;		    // from pDevExt
	    PKSEVENT_SET 	EventInfo;				// from pDevExt
    	ULONG           EventInfoCount;			// from pDevExt
		LIST_ENTRY		NotifyList;				// from pDevExt
		PHW_EVENT_ROUTINE HwEventRoutine;		// from pDevExt
	    PKSPROPERTY_SET DevicePropertiesArray;	// from pDevExt
	    PSTREAM_ADDITIONAL_INFO StreamPropEventArray; // ditto
	    ULONG           Reenumerated;           // if 1, StreamDescriptor is newly alloc
	                                            // need to be freed. Else, it points into
	                                            // the global one which belong to DevExt.
	    ULONG           NeedReenumeration;      // requesting reenumeration
	    ULONG           StreamDescriptorSize;   // the new size for streamdescriptor;
	    struct _DEVICE_EXTENSION *DeviceExtension;
   	    PHW_STREAM_DESCRIPTOR StreamDescriptor;
	    ULONG		 	FilterTypeIndex;
	    //
	    // Performance improvement chance. Per filterinstance ControlEvent etc might be
	    // better.For now, let them share ones in DeviceExtension
	    //
		//KEVENT          ControlEvent
		//PHW_TIMER_ROUTINE HwTimerRoutine;   // Timer request routine
	    //PVOID           HwTimerContext;
	    //KTIMER          MiniDriverTimer;    // Miniclass timer object.
	    //KDPC            MiniDriverTimerDpc; // Miniclass DPC for timer object.
	    //WORK_QUEUE_ITEM WorkItem;
	) // IF_MF
	
} FILTER_INSTANCE, *PFILTER_INSTANCE;

//
// Per Device data
//

typedef struct _DEVICE_EXTENSION {
    COMMON_OBJECT   ComObj;
    ULONG           Flags;                  // per device flags (PD_xx)
    PDEVICE_OBJECT  DeviceObject;           // device object
    PDEVICE_OBJECT  AttachedPdo;            // device object returned from the attach
    ULONG           RegistryFlags;          // registry flags
    // callback routine on DMA allocate
    // callback function for
    // KeSynch execution

    PKINTERRUPT     InterruptObject;        // Interrupt object and routine
    PKSERVICE_ROUTINE InterruptRoutine;
    PADAPTER_OBJECT DmaAdapterObject;       // Dma Adapter information.
    ULONG           NumberOfMapRegisters;   // max. number of map registers
    // for
    // device
    PVOID           MapRegisterBase;
    PMINIDRIVER_INFORMATION MinidriverData; // pointer to minidriver data
    PDEVICE_OBJECT  PhysicalDeviceObject;   // pointer to PDO for adapter
    PVOID           HwDeviceExtension;      // minidriver's device extension
    PPORT_CONFIGURATION_INFORMATION ConfigurationInformation;
    // configuration info for adapter
    PMAPPED_ADDRESS MappedAddressList;      // address map list head

    //
    // Routine to call to synchronize execution for the minidriver.
    //

    PSYNCHRONIZE_ROUTINE SynchronizeExecution;

    KSPIN_LOCK      SpinLock;

    ULONG           SequenceNumber;         // offset 0x30

    ULONG           DmaBufferLength;
    PHYSICAL_ADDRESS DmaBufferPhysical;
    PVOID           DmaBuffer;

    LIST_ENTRY      PendingQueue;
    LIST_ENTRY      OutstandingQueue;
    KDPC            WorkDpc;

    IFN_MF(
    	//
    	// Move to FilterInstance for IF_MF
    	//
    	PKSPIN_DESCRIPTOR PinInformation;
    	ULONG           PinInformationSize;
    	ULONG           NumberOfPins;
    )

    #define SIGN_DEVICE_EXTENSION 'DrtS' //StrD
    #if ENABLE_MULTIPLE_FILTER_TYPES
    #define ASSERT_DEVICE_EXTENSION(DE) ASSERT((DE)->Signature==SIGN_DEVICE_EXTENSION)
    #else
    #define ASSERT_DEVICE_EXTENSION(DE)
    #endif

    ULONG           Signature2;
    LIST_ENTRY      FilterInstanceList;
    ULONG           NumberOfOpenInstances;
    
    IFN_MF(
    	//
    	// Don't need for IF_MF
    	//
    	PFILTER_INSTANCE GlobalFilterInstance;
	    ULONG           NumberOfGlobalInstances;
	)
	
    struct _STREAM_OBJECT *NeedyStream;
   	PHW_STREAM_DESCRIPTOR StreamDescriptor;    
	KEVENT          ControlEvent;
    KEVENT          RemoveEvent;
    BOOLEAN         NoSync;
    PMINIDRIVER_INFORMATION DriverInfo;
    PBEGIN_CALLIN_ROUTINE BeginMinidriverCallin;
    PEND_STREAM_CALLIN_ROUTINE EndMinidriverStreamCallin;
    PEND_DEVICE_CALLIN_ROUTINE EndMinidriverDeviceCallin;
    LONG            OneBasedIoCount;
    UNICODE_STRING    *SymbolicLinks;
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    DEVICE_POWER_STATE CurrentPowerState;
    LIST_ENTRY Children;
    LIST_ENTRY DeadEventList;
    WORK_QUEUE_ITEM EventWorkItem;
    WORK_QUEUE_ITEM RescanWorkItem;
    WORK_QUEUE_ITEM PowerCompletionWorkItem; // this is used for S Irp, S and D Irps dont exclude between.
    WORK_QUEUE_ITEM DevIrpCompletionWorkItem; // this is for D Irp as opposed to S Irp which uses above
    BOOLEAN ReadyForNextReq;
    BOOLEAN DeadEventItemQueued;

   	IFN_MF( 
		//
		// move to FilterInstace for MF
		// 
    	PKSEVENT_SET 	EventInfo;
    	ULONG           EventInfoCount;
    	LIST_ENTRY      NotifyList;
	    PHW_EVENT_ROUTINE HwEventRoutine;
	    PKSPROPERTY_SET DevicePropertiesArray;
	    PSTREAM_ADDITIONAL_INFO StreamPropEventArray;
	)

	#ifdef ENABLE_KS_METHODS
	IFN_MF(
		//
		// move to FilterInstance for MF
	 	PKSMETHOD_SET DeviceMethodsArray;
	)
	#endif

	IF_MF(
	    ULONG       NumberOfNameExtensions;
	    ULONG       NumberOfFilterTypes;
	    PKSOBJECT_CREATE_ITEM CreateItems;
	    PFILTER_TYPE_INFO FilterTypeInfos;
	    ULONG       Signature;
        ULONG       FilterExtensionSize;	    
	)

	#if DBG
    ULONG LowerApiThreads;
    ULONG NumberOfRequests;
    ULONG NumberOfLowPriCalls;
	#endif

    LIST_ENTRY PendedIrps;
    KSPIN_LOCK PendedIrpsLock;
    KSPIN_LOCK PowerLock;
    SYSTEM_POWER_STATE CurrentSystemState;
    KEVENT BlockPoweredDownEvent;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// debug work item trap structure
//

#if DBG

typedef struct _DEBUG_WORK_ITEM {
    PCOMMON_OBJECT Object;
    PHW_PRIORITY_ROUTINE    HwPriorityRoutine;
    PVOID           HwPriorityContext;
} DEBUG_WORK_ITEM, *PDEBUG_WORK_ITEM;
    
#endif

//
// registry entry structure
//

typedef struct _STREAM_REGISTRY_ENTRY {
    PWCHAR          String;
    ULONG           StringLength;
    ULONG           Flags;
}               STREAM_REGISTRY_ENTRY, *PSTREAM_REGISTRY_ENTRY;

//
// power context structure
//

typedef struct _POWER_CONTEXT {
    KEVENT   Event;
    NTSTATUS Status;
}               POWER_CONTEXT, *PPOWER_CONTEXT;


//
// child device extension
//

typedef struct _CHILD_DEVICE_EXTENSION {
    COMMON_OBJECT   ComObj;
    ULONG           Flags;      // per device flags (PD_xx)
    PDEVICE_OBJECT ChildDeviceObject;
    PDEVICE_OBJECT ParentDeviceObject;
    LIST_ENTRY ChildExtensionList;
    PWCHAR   DeviceName;
    ULONG DeviceIndex;
}               CHILD_DEVICE_EXTENSION, *PCHILD_DEVICE_EXTENSION;

//
// Function declarations
//

NTSTATUS
StreamClassOpen(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);

NTSTATUS
StreamClassClose(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
);

NTSTATUS
StreamClassDeviceControl(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp
);

NTSTATUS
StreamClassNull(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);

VOID
StreamClassDpc(
               IN PKDPC Dpc,
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context
);

BOOLEAN
StreamClassInterrupt(
                     IN PKINTERRUPT InterruptObject,
                     IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
StreamClassShutDown(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);

BOOLEAN
SCGetInterruptState(
                    IN PVOID ServiceContext
);

VOID
SCMinidriverDeviceTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID DeviceObject,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
);



VOID
SCMinidriverStreamTimerDpc(
                           IN struct _KDPC * Dpc,
                           IN PVOID Context,
                           IN PVOID SystemArgument1,
                           IN PVOID SystemArgument2
);


PSTREAM_REQUEST_BLOCK
SCBuildRequestPacket(
                     IN PDEVICE_EXTENSION DeviceExtension,
                     IN PIRP Irp,
                     IN ULONG AdditionalSize1,
                     IN ULONG AdditionalSize2
);

BOOLEAN
SCSynchronizeExecution(
                       IN PKINTERRUPT Interrupt,
                       IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                       IN PVOID SynchronizeContext
);

VOID
SCLogError(
           IN PDEVICE_OBJECT DeviceObject,
           IN ULONG SequenceNumber,
           IN NTSTATUS ErrorCode,
           IN ULONG UniqueId
);

VOID
SCLogErrorWithString(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN OPTIONAL PDEVICE_EXTENSION DeviceExtension,
                     IN NTSTATUS ErrorCode,
                     IN ULONG UniqueId,
                     IN PUNICODE_STRING String1
);

VOID
SCMinidriverTimerDpc(
                     IN struct _KDPC * Dpc,
                     IN PVOID Context,
                     IN PVOID SystemArgument1,
                     IN PVOID SystemArgument2
);

BOOLEAN
SCSetUpForDMA(
              IN PDEVICE_OBJECT DeviceObject,
              IN PSTREAM_REQUEST_BLOCK Request
);

IO_ALLOCATION_ACTION
StreamClassDmaCallback(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PVOID MapRegisterBase,
                       IN PVOID Context
);

VOID
SCStartMinidriverRequest(
                         IN PSTREAM_OBJECT StreamObject,
                         IN PSTREAM_REQUEST_BLOCK Request,
                         IN PVOID EntryPoint
);

NTSTATUS
SCProcessCompletedRequest(
                          IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
StreamClassUninitializeMinidriver(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp);

NTSTATUS
StreamClassVideoRegister(
                         IN PVOID Argument1,
                         IN PVOID Argument2,
                         IN PHW_INITIALIZATION_DATA HwInitializationData
);

NTSTATUS
StreamClassCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

void
SCSetCurrentDPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_POWER_STATE PowerState
    );

void
SCSetCurrentSPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN SYSTEM_POWER_STATE PowerState
    );

void
SCRedispatchPendedIrps (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN FailRequests
    );

NTSTATUS
StreamClassPassThroughIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StreamClassPnP(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassPower(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassPnPAddDevice(
                        IN PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject
);

VOID
SCFreeAllResources(
                   IN PDEVICE_EXTENSION DeviceExtension
);

VOID
StreamClassUnload(
                  IN PDRIVER_OBJECT DriverObject
);



BOOLEAN
StreamClassSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
);

VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
);

NTSTATUS
SCCompleteIrp(
              IN PIRP Irp,
              IN NTSTATUS Status,
              IN PDEVICE_EXTENSION DeviceExtension
);


NTSTATUS
SCUninitializeMinidriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp);


BOOLEAN
SCDummyMinidriverRoutine(
                         IN PVOID Context
);

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
FilterDispatchGlobalCreate(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
);

NTSTATUS
StreamDispatchCreate(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
);

NTSTATUS
FilterDispatchIoControl(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PIRP Irp
);

NTSTATUS
FilterDispatchClose
(
 IN PDEVICE_OBJECT pdo,
 IN PIRP pIrp
);

NTSTATUS
SCStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
);

NTSTATUS
StreamDispatchIoControl
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);


NTSTATUS        StreamDispatchRead
                (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
);

NTSTATUS        StreamDispatchWrite
                (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
);

NTSTATUS
SCLocalInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
);

IFN_MF(
NTSTATUS
SCGlobalInstanceCallback(
                         IN PSTREAM_REQUEST_BLOCK SRB
);
)

NTSTATUS
SCOpenStreamCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

VOID
SCRequestDpcForStream(
                      IN PSTREAM_OBJECT StreamObject

);

NTSTATUS
SCSubmitRequest(
                IN SRB_COMMAND Command,
                IN PVOID Buffer,
                IN ULONG BufferLength,
                IN PSTREAM_CALLBACK_PROCEDURE Callback,
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PVOID InstanceExtension,
                IN PHW_STREAM_OBJECT HwStreamObject,
                IN PIRP Irp,
                OUT PBOOLEAN RequestIssued,
                IN PLIST_ENTRY Queue,
                IN PVOID MinidriverRoutine
);

NTSTATUS
SCCloseInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCFilterPinInstances(
                     IN PIRP Irp,
                     IN PKSPROPERTY Property,
                     IN OUT PVOID Data);

NTSTATUS
SCFilterPinDataRouting(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PVOID Data);

NTSTATUS
SCFilterPinDataIntersection(
                            IN PIRP Irp,
                            IN PKSPROPERTY Property,
                            IN OUT PVOID Data);

NTSTATUS
SCFilterPinPropertyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data);

NTSTATUS
SCFilterProvider(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PVOID Data);


NTSTATUS
StreamDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);

NTSTATUS
StreamDispatchCleanup 
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
);

NTSTATUS
SCCloseStreamCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


BOOLEAN
SCProcessPioDataBuffers(
                       IN PKSSTREAM_HEADER FirstHeader,
                       IN ULONG NumberOfHeaders,
                       IN PSTREAM_OBJECT StreamObject,
                       IN PMDL FirstMdl,
                       IN ULONG StreamHeaderSize,
                       IN PVOID *pMemPtrArray,
                       IN BOOLEAN Write
);

VOID
SCProcessDmaDataBuffers(
                       IN PKSSTREAM_HEADER FirstHeader,
                       IN ULONG NumberOfHeaders,
                       IN PSTREAM_OBJECT StreamObject,
                       IN PMDL FirstMdl,
                       OUT PULONG NumberOfPages,
                       IN ULONG StreamHeaderSize,
                       IN BOOLEAN Write
);
VOID
SCErrorDataSRB(
               IN PHW_STREAM_REQUEST_BLOCK SRB
);

VOID
SCCheckOutstandingRequestsForTimeouts(
                                      IN PLIST_ENTRY ListEntry
);

VOID
SCCheckFilterInstanceStreamsForTimeouts(
                                        IN PFILTER_INSTANCE FilterInstance
);

VOID
StreamClassTickHandler(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PVOID Context
);

VOID
StreamClassCancelOutstandingIrp(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp
);

VOID
StreamClassCancelPendingIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
);

VOID
SCCancelOutstandingIrp(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PIRP Irp
);

BOOLEAN
SCCheckFilterInstanceStreamsForIrp(
                                   IN PFILTER_INSTANCE FilterInstance,
                                   IN PIRP Irp
);

BOOLEAN
SCCheckRequestsForIrp(
                      IN PLIST_ENTRY ListEntry,
                      IN PIRP Irp,
                      IN BOOLEAN IsIrpQueue,
                      IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCNotifyMinidriverCancel(
                         IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCProcessCompletedPropertyRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
);


NTSTATUS
StreamClassMinidriverDeviceGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
StreamClassMinidriverDeviceSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);


NTSTATUS
StreamClassMinidriverStreamGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
StreamClassMinidriverStreamSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);


NTSTATUS
SCOpenMinidriverInstance(
                         IN PDEVICE_EXTENSION DeviceExtension,
                         OUT PFILTER_INSTANCE * ReturnedFilterInstance,
                         IN PSTREAM_CALLBACK_PROCEDURE Callback,
                         IN PIRP Irp
);

NTSTATUS
SCMinidriverDevicePropertyHandler
(
 IN SRB_COMMAND Command,
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

NTSTATUS
SCMinidriverStreamPropertyHandler
(
 IN SRB_COMMAND Command,
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
);

VOID
SCStartRequestOnStream(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
StreamClassPnPAddDeviceWorker(
                              IN PDRIVER_OBJECT DriverObject,
                              IN PDEVICE_OBJECT PhysicalDeviceObject,
                          IN OUT PDEVICE_EXTENSION * ReturnedDeviceExtension
);

NTSTATUS
SCProcessDataTransfer(
                      IN PDEVICE_EXTENSION DeviceExtension,
                      IN PIRP Irp,
                      IN SRB_COMMAND Command
);

VOID
SCUpdateMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps,
                             IN BOOLEAN Stream
);

VOID
SCInitializeWorkItem(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCInitializeCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

VOID
SCStreamInfoWorkItem(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCDequeueAndDeleteSrb(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


VOID
SCReadRegistryValues(IN PDEVICE_EXTENSION DeviceExtension,
                     IN PDEVICE_OBJECT PhysicalDeviceObject
);

NTSTATUS
SCGetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PVOID Data,
                   IN ULONG DataLength
);


VOID
SCInsertStreamInFilter(
                       IN PSTREAM_OBJECT StreamObject,
                       IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCReferenceDriver(
                  IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCDereferenceDriver(
                    IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCQueueSrbWorkItem(
                   IN PSTREAM_REQUEST_BLOCK Srb
);


VOID
SCProcessPriorityChangeRequest(
                               IN PCOMMON_OBJECT CommonObject,
                               IN PINTERRUPT_DATA SavedInterruptData,
                               IN PDEVICE_EXTENSION DeviceExtension

);

VOID
SCProcessTimerRequest(
                      IN PCOMMON_OBJECT CommonObject,
                      IN PINTERRUPT_DATA SavedInterruptData

);

NTSTATUS
SCPowerCallback(
                  IN PSTREAM_REQUEST_BLOCK SRB
);

BOOLEAN
SCCheckIfOkToPowerDown(
                       IN PDEVICE_EXTENSION DeviceExtension

);


NTSTATUS
SCIssueRequestToDevice(
                       IN PDEVICE_EXTENSION DeviceExtension,
                       IN PSTREAM_OBJECT StreamObject,
                       PSTREAM_REQUEST_BLOCK Request,
                       IN PVOID MinidriverRoutine,
                       IN PLIST_ENTRY Queue,
                       IN PIRP Irp
);

VOID
SCBeginSynchronizedMinidriverCallin(
                                    IN PDEVICE_EXTENSION DeviceExtension,
                                    IN PKIRQL Irql
);

VOID
SCBeginUnsynchronizedMinidriverCallin(
                                      IN PDEVICE_EXTENSION DeviceExtension,
                                      IN PKIRQL Irql
);

VOID
SCEndUnsynchronizedMinidriverDeviceCallin(
                                       IN PDEVICE_EXTENSION DeviceExtension,
                                          IN PKIRQL Irql
);

VOID
SCEndUnsynchronizedMinidriverStreamCallin(
                                          IN PSTREAM_OBJECT StreamObject,
                                          IN PKIRQL Irql
);

VOID
SCEndSynchronizedMinidriverStreamCallin(
                                        IN PSTREAM_OBJECT StreamObject,
                                        IN PKIRQL Irql
);

VOID
SCEndSynchronizedMinidriverDeviceCallin(
                                        IN PDEVICE_EXTENSION DeviceExtension,
                                        IN PKIRQL Irql
);


NTSTATUS
SCStartWorker(
                IN PIRP Irp
);


NTSTATUS
SCShowIoPending(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PIRP Irp
);

VOID
SCWaitForOutstandingIo(
                       IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCCheckPoweredUp(
                 IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCCheckPowerDown(
                 IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCUninitializeCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCRemoveComplete(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp,
                 IN PVOID Context
);

VOID
SCRemoveCompleteWorkItem(
                         IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCDetachDevice(
               IN PDEVICE_OBJECT Fdo,
               IN PDEVICE_OBJECT Pdo
);

NTSTATUS
SCQueryWorker(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
);


NTSTATUS
SCCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
);

VOID
StreamFlushIo(
                    IN PDEVICE_EXTENSION DeviceExtension,
                    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS
ClockDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);

NTSTATUS
SCOpenMasterCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCSetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
);

NTSTATUS
SCClockGetTime(
               IN PIRP Irp,
               IN PKSPROPERTY Property,
               IN OUT PULONGLONG StreamTime
);

NTSTATUS
SCClockGetPhysicalTime(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONGLONG PhysicalTime
);

NTSTATUS
SCClockGetSynchronizedTime(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PKSCORRELATED_TIME SyncTime
);

NTSTATUS
SCClockGetFunctionTable(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
);

NTSTATUS
ClockDispatchClose(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp
);

ULONGLONG       FASTCALL
                SCGetSynchronizedTime(
                                                 IN PFILE_OBJECT FileObject,
                                                    IN PULONGLONG SystemTime

);

ULONGLONG       FASTCALL
                SCGetPhysicalTime(
                                                  IN PFILE_OBJECT FileObject

);

ULONGLONG
SCGetStreamTime(
                IN PFILE_OBJECT FileObject

);

VOID
SCMinidriverTimeFunction(
                         IN PHW_TIME_CONTEXT TimeContext
);

NTSTATUS
ClockDispatchIoControl(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
);

VOID
StreamClassQueryMasterClock(
                            IN PHW_STREAM_OBJECT HwStreamObject,
                            IN HANDLE MasterClockHandle,
                            IN TIME_FUNCTION TimeFunction,
                            IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
);

NTSTATUS
SCSendUnknownCommand(
                                  IN PIRP Irp,
                                  IN PDEVICE_EXTENSION DeviceExtension,
                                  IN PVOID Callback,
                                  OUT PBOOLEAN RequestIssued
);

NTSTATUS
SCPNPQueryCallback(
    IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCUnknownPNPCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCUnknownPowerCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
);

BOOLEAN
SCMapMemoryAddress(PACCESS_RANGE AccessRanges,
                   PHYSICAL_ADDRESS TranslatedAddress,                                 
                   PPORT_CONFIGURATION_INFORMATION     ConfigInfo,
                   PDEVICE_EXTENSION        DeviceExtension,
                   PCM_RESOURCE_LIST ResourceList,
                   PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor
);


VOID
SCUpdatePersistedProperties(IN PSTREAM_OBJECT StreamObject,
                            IN PDEVICE_EXTENSION DeviceExtension,
                            IN PFILE_OBJECT FileObject
);

VOID
SCCreateSymbolicLinks(
                   IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SCDestroySymbolicLinks(
                   IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
SCSignalSRBEvent(
                   IN PSTREAM_REQUEST_BLOCK Srb
);

NTSTATUS
SCFilterTopologyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data);

NTSTATUS
SCStreamProposeNewFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
);

NTSTATUS
SCGetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
);

NTSTATUS
SCCloseClockCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);


NTSTATUS
SCStreamDeviceRate
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSRATE DeviceRate
);

NTSTATUS
SCStreamDeviceRateCapability
(
 IN PIRP Irp,
 IN PKSRATE_CAPABILITY RateCap,
 IN OUT PKSRATE DeviceRate
);

NTSTATUS
SCFilterPinIntersectionHandler(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );

NTSTATUS
SCIntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
);

NTSTATUS
SCDataIntersectionCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
SCQueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
SCSynchPowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
);

NTSTATUS
SCGetStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
);

NTSTATUS
SCCreateChildPdo(
                 IN PVOID PnpId,
                 IN PDEVICE_OBJECT DeviceObject,
                 IN ULONG InstanceNumber
);

NTSTATUS
SCEnumerateChildren(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassEnumPnp(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
StreamClassEnumPower(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
SCEnumGetCaps(
    IN  PCHILD_DEVICE_EXTENSION       DeviceExtension,
    OUT PDEVICE_CAPABILITIES    Capabilities
);


NTSTATUS
SCQueryEnumId(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      BUS_QUERY_ID_TYPE   BusQueryIdType,
    IN  OUT PWSTR             * BusQueryId
);

NTSTATUS
AllocatorDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
);


NTSTATUS
StreamClassEnableEventHandler(
                                  IN PIRP Irp,
                           IN PKSEVENTDATA EventData,
                           IN PKSEVENT_ENTRY EventEntry
);

VOID
StreamClassDisableEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
);

VOID
SCUpdateMinidriverEvents(
                             IN ULONG NumEvents,
                             IN PKSEVENT_SET MinidriverEvents,
                             IN BOOLEAN Stream
);

NTSTATUS
SCEnableEventSynchronized(
                    IN PVOID ServiceContext
);

VOID
SCGetDeadListSynchronized(
                               IN PLIST_ENTRY NewListEntry
);

VOID
SCFreeDeadEvents(
                               IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
StreamClassForwardUnsupported(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
);

NTSTATUS
SCStreamSetFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
);

VOID
SCInsertStreamInfo(
                IN PDEVICE_EXTENSION DeviceExtension,
                IN PKSPIN_DESCRIPTOR PinDescs,
                IN PHW_STREAM_DESCRIPTOR StreamDescriptor,
                IN ULONG NumberOfPins
);

VOID
SCRescanStreams(
                 IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCGetStreamHeaderSize(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONG StreamHeaderSize
);

VOID
SCInterlockedRemoveEntryList(
                       PDEVICE_EXTENSION DeviceExtension,
                       PLIST_ENTRY List
);

VOID
SCInsertFiltersInDevice(
                       IN PFILTER_INSTANCE FilterInstance,
                       IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
SCBustedSynchPowerCompletionRoutine(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE DeviceState,
                              IN PVOID Context,
                              IN PIO_STATUS_BLOCK IoStatus
);

BOOLEAN
SCCheckIfStreamsRunning(
                IN PFILTER_INSTANCE FilterInstance
);

#if DBG

BOOLEAN
SCDebugKeSynchronizeExecution(
                                IN PKINTERRUPT Interrupt,
                                IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
                                IN PVOID SynchronizeContext
);

#endif // DEBUG

NTSTATUS
SCEnableDeviceEventSynchronized(
                          IN PVOID ServiceContext
);

NTSTATUS
StreamClassEnableDeviceEventHandler(
                              IN PIRP Irp,
                              IN PKSEVENTDATA EventData,
                              IN PKSEVENT_ENTRY EventEntry
);

VOID
StreamClassDisableDeviceEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
);


VOID
SCCallBackSrb(
                  IN PSTREAM_REQUEST_BLOCK Srb,
                  IN PDEVICE_EXTENSION DeviceExtension
);

NTSTATUS
DllUnload(
    VOID
);

VOID 
SCPowerCompletionWorker(
                            IN PIRP SystemIrp
);

VOID
SCSendSurpriseNotification(
              IN PDEVICE_EXTENSION DeviceExtension,
              IN PIRP Irp
);

#if DBG
VOID
SCDebugPriorityWorkItem(
                 IN PDEBUG_WORK_ITEM WorkItemStruct
);
#endif 

PKSPROPERTY_SET
SCCopyMinidriverProperties(
                             IN ULONG NumProps,
                             IN PKSPROPERTY_SET MinidriverProps
);

PKSEVENT_SET
SCCopyMinidriverEvents(
                         IN ULONG NumEvents,
                         IN PKSEVENT_SET MinidriverEvents
);

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
NTSTATUS
SCStreamAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
);

NTSTATUS
SCStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
);

NTSTATUS
IoCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
);

NTSTATUS
CleanupTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS
EndTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT   StreamObject
);

NTSTATUS
BeginTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    );

NTSTATUS
PrepareTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS 
PinCreateHandler(
    IN PIRP Irp,
    IN PSTREAM_OBJECT StreamObject
);

NTSTATUS 
AllocateFrame(
    PFILE_OBJECT Allocator,
    PVOID *Frame
    );

NTSTATUS
FreeFrame(
    PFILE_OBJECT Allocator,
    PVOID Frame
    );
#endif //ENABLE_STREAM_CLASS_AS_ALLOCATOR

#ifdef ENABLE_KS_METHODS

NTSTATUS
SCProcessCompletedMethodRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
);

NTSTATUS
StreamClassMinidriverStreamMethod
(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
StreamClassMinidriverDeviceMethod
(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
SCMinidriverStreamMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
);

NTSTATUS
SCMinidriverDeviceMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
);

VOID
SCUpdateMinidriverMethods(
                             IN ULONG NumMethods,
                             IN PKSMETHOD_SET MinidriverMethods,
                             IN BOOLEAN Stream
);

PKSMETHOD_SET
SCCopyMinidriverMethods(
                         IN ULONG NumMethods,
                         IN PKSMETHOD_SET MinidriverMethods
);


NTSTATUS
SCStreamMethodHandler(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

NTSTATUS
SCStreamAllocatorMethodHandler(
 IN PIRP Irp,
 IN PKSMETHOD Method,
 IN OUT PVOID MethodInfo
);

#endif

#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SciOnFilterStreamDescriptor(
    PFILTER_INSTANCE FilterInstance,
    PHW_STREAM_DESCRIPTOR StreamDescriptor);
    
VOID
SciInsertFilterStreamInfo(
                   IN PFILTER_INSTANCE FilterInstance,
                   IN PKSPIN_DESCRIPTOR PinDescs,
                   IN ULONG NumberOfPins);

NTSTATUS
SciFreeFilterInstance(
    PFILTER_INSTANCE pFilterInstance
);                   

NTSTATUS
SciQuerySystemPowerHiberCallback(
                   IN PSTREAM_REQUEST_BLOCK SRB
);

#endif // ENABLE_MULTIPLE_FILTER_TYPES

#define SCLOG_FLAGS_CLOCK   0x00000001
#define SCLOG_FLAGS_PNP     0x00000002
#define SCLOG_FLAGS_PRINT   0x80000000

#if (DBG) && !defined(_WIN64)

NTSTATUS SCLog( ULONG ulTag, ULONG ulArg1, ULONG ulArg2, ULONG ulArg3 );
NTSTATUS SCLogWithTime( ULONG ulTag, ULONG ulArg1, ULONG ulArg2 );
#define SCLOG( ulTag, Arg1, Arg2, Arg3 ) SCLog( ulTag, (ULONG)Arg1, (ULONG)Arg2, (ULONG)Arg3 )
#define SCLOGWITHTIME( ulTag, Arg1, Arg2 ) SCLogWithTime( ulTag, Arg1, Arg2 )

#else

#define SCLOG( ulTag, Arg1, Arg2, Arg3 )
#define SCLOGWITHTIME( ulTag, Arg1, Arg2 )

#endif


#endif  // #ifndef _STREAMCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\lowerapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   decinit.c

Abstract:

   This is the WDM decoder class driver.  This module contains code related
   to request processing.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"

#if DBG

#if WIN95_BUILD
ULONG           StreamDebug = DebugLevelInfo;
#else
ULONG           StreamDebug = DebugLevelError;
#endif

#define STREAM_BUFFER_SIZE 256
UCHAR           StreamBuffer[STREAM_BUFFER_SIZE];
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PscS')
#endif


VOID
StreamClassStreamNotification(
             IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
                              IN PHW_STREAM_OBJECT HwStreamObject,
                              ...
)
/*++

Routine Description:

  stream notification routine for minidriver

Arguments:

  NotificationType - indicates what has happened
  HwStreamObject - address of minidriver's stream struct

Return Value:

  none

--*/

{
    va_list         Arguments;
    PSTREAM_REQUEST_BLOCK SRB;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
                                                    );
    PDEVICE_EXTENSION DeviceExtension;
    KIRQL           Irql;

    #if DBG
    PMDL            CurrentMdl;
    #endif

    va_start(Arguments, HwStreamObject);

    ASSERT(HwStreamObject != NULL);

    DeviceExtension = StreamObject->DeviceExtension;

    ASSERT((DeviceExtension->BeginMinidriverCallin == SCBeginSynchronizedMinidriverCallin) ||
           (DeviceExtension->BeginMinidriverCallin == SCBeginUnsynchronizedMinidriverCallin));

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    //
    // optimization for async drivers - just directly call back the request
    // rather than queuing it on the DPC processed completed list.
    //

    if ((DeviceExtension->NoSync) && (NotificationType == StreamRequestComplete)) {

        SRB = CONTAINING_RECORD(va_arg(Arguments,
                                       PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        //
        // Clear the active flag.
        //

        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        #if DBG
        //
        // assert the MDL list.
        //

        if (SRB->HwSRB.Irp) {
            CurrentMdl = SRB->HwSRB.Irp->MdlAddress;

            while (CurrentMdl) {

                CurrentMdl = CurrentMdl->Next;
            }                   // while

        }                       // if IRP
        ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);

        if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
            (SRB->HwSRB.Command == SRB_WRITE_DATA)) {

            ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
        } else {

            ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
        }                       // if read/write
        #endif


        if (SRB->DoNotCallBack) {

            DebugPrint((DebugLevelError, "'ScNotify: NOT calling back request - Irp = %x, S# = %x\n",
                SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber));
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            return;

        }                       // if NoCallback
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        DebugPrint((DebugLevelTrace, "'SCNotification: Completing async stream Irp %x, S# = %x, SRB = %x, Func = %x, Callback = %x, SRB->IRP = %x\n",
                  SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber,
                    SRB, SRB->HwSRB.Command, SRB->Callback, SRB->HwSRB.Irp));
        (SRB->Callback) (SRB);

        return;

    }                           // if nosync & complete
    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    switch (NotificationType) {

    case ReadyForNextStreamDataRequest:

        //
        // Start next data packet on adapter's stream queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream data request, S# = %x\n",
                    StreamObject->HwStreamObject.StreamNumber));

        ASSERT(!(StreamObject->ReadyForNextDataReq));
        ASSERT(!(DeviceExtension->NoSync));

        StreamObject->ReadyForNextDataReq = TRUE;
        break;

    case ReadyForNextStreamControlRequest:

        //
        // Start next data packet on adapter's stream queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream control request, S# = %x\n",
                    StreamObject->HwStreamObject.StreamNumber));

        ASSERT(!(StreamObject->ReadyForNextControlReq));
        ASSERT(!(DeviceExtension->NoSync));

        StreamObject->ReadyForNextControlReq = TRUE;
        break;

    case StreamRequestComplete:

        SRB = CONTAINING_RECORD(va_arg(Arguments,
                                       PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        DebugPrint((DebugLevelTrace, "'SCStreamNot: completing Irp %x, S# = %x, SRB = %x, Command = %x\n",
                    SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber, SRB, SRB->HwSRB.Command));
        ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);

        //
        // Clear the active flag.
        //

        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        //
        // add the SRB to the list of completed SRB's.
        //

        SRB->HwSRB.NextSRB = StreamObject->ComObj.InterruptData.CompletedSRB;
        StreamObject->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

        #if DBG
        //
        // assert the MDL list.
        //

        if (SRB->HwSRB.Irp) {
            CurrentMdl = SRB->HwSRB.Irp->MdlAddress;

            while (CurrentMdl) {

                CurrentMdl = CurrentMdl->Next;
            }                   // while

        }                       // if IRP
        ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);

        if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
            (SRB->HwSRB.Command == SRB_WRITE_DATA)) {

            ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
        } else {

            ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
        }                       // if read/write
        #endif

        break;

    case SignalMultipleStreamEvents:
        {

            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //

            KsGenerateEventList(EventGuid,
                                EventItem,
                                &StreamObject->NotifyList,
                                KSEVENTS_NONE,
                                NULL);


        }                       // case event

        break;

    case SignalStreamEvent:

        KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));
        break;


    case DeleteStreamEvent:
        {

            PKSEVENT_ENTRY  EventEntry;

            //
            // remove the entry from the list, and add it to the dead list.
            // note
            // that we are already at the correct sync level to do this.
            //

            EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
            RemoveEntryList(&EventEntry->ListEntry);

            InsertTailList(&DeviceExtension->DeadEventList,
                           &EventEntry->ListEntry);

        }
        break;

    default:

        ASSERT(0);
    }

    va_end(Arguments);

    END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

}                               // end StreamClassStreamNotification()



VOID
StreamClassDeviceNotification(
             IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
                              IN PVOID HwDeviceExtension,
                              ...
)
/*++

Routine Description:

  device notification routine for minidriver

Arguments:

  NotificationType - indicates what has happened
  HwDeviceExtension - address of minidriver's device extension

Return Value:

  none

--*/

{
    va_list         Arguments;
    PSTREAM_REQUEST_BLOCK SRB;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;

    KIRQL           Irql;

    va_start(Arguments, HwDeviceExtension);

    ASSERT(HwDeviceExtension != NULL);

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    switch (NotificationType) {

    case ReadyForNextDeviceRequest:

        //
        // Start next control packet on adapter's device queue.
        //

        DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: ready for next stream.\n"));
        ASSERT(!(DeviceExtension->ReadyForNextReq));
        ASSERT(!(DeviceExtension->NoSync));
        DeviceExtension->ReadyForNextReq = TRUE;
        break;

    case DeviceRequestComplete:

        SRB = CONTAINING_RECORD(va_arg(Arguments, PHW_STREAM_REQUEST_BLOCK),
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: stream request complete.\n"));
        ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
        ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
        ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST));
        ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));

        //
        // Clear the active flag.
        //

        SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

        //
        // add the SRB to the list of completed SRB's.
        //

        SRB->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;
        DeviceExtension->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

        break;

    case SignalMultipleDeviceEvents:
        {

            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //

            PFILTER_INSTANCE FilterInstance;
            
            ASSERT( 0 == DeviceExtension->MinidriverData->
                         HwInitData.FilterInstanceExtensionSize);
                         
            //
            // this is synced should not need to avoid race
            //

            FilterInstance = (PFILTER_INSTANCE)
                              DeviceExtension->FilterInstanceList.Flink;

            if ( (PLIST_ENTRY)FilterInstance == 
                    &DeviceExtension->FilterInstanceList ) {

                DebugPrint((DebugLevelWarning, "Filter Closed\n"));                    
                break;
            }
            
            FilterInstance = CONTAINING_RECORD(FilterInstance,
                                       FILTER_INSTANCE,
                                       NextFilterInstance);
                                       
            KsGenerateEventList(EventGuid,
                                EventItem,
                                &FilterInstance->NotifyList,
                                KSEVENTS_NONE,
                                NULL);
                                
        }
        
        break;
    #if ENABLE_MULTIPLE_FILTER_TYPES
    case SignalMultipleDeviceInstanceEvents:
        {            
            PFILTER_INSTANCE FilterInstance =
                (PFILTER_INSTANCE)va_arg( Arguments, PVOID) -1;
            GUID           *EventGuid = va_arg(Arguments, GUID *);
            ULONG           EventItem = va_arg(Arguments, ULONG);

            //
            // signal all events that match the criteria.  note that we are
            // already
            // at the level required for synchronizing the list, so no lock
            // type is specified.
            //
            
            KsGenerateEventList(EventGuid,
                                EventItem,
                                &FilterInstance->NotifyList,
                                KSEVENTS_NONE,
                                NULL);
        } 
        break;
    #endif // ENABLE_MULTIPLE_FILTER_TYPES

    case SignalDeviceEvent:

        KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));
        break;


    case DeleteDeviceEvent:
        {

            PKSEVENT_ENTRY  EventEntry;

            //
            // remove the entry from the list, and add it to the dead list.
            // note
            // that we are already at the correct sync level to do this.
            //

            EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
            RemoveEntryList(&EventEntry->ListEntry);

            InsertTailList(&DeviceExtension->DeadEventList,
                           &EventEntry->ListEntry);

        }
        break;

    default:

        ASSERT(0);
    }

    va_end(Arguments);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

}                               // end StreamClassDeviceNotification()



VOID
StreamClassScheduleTimer(
                         IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                         IN PVOID HwDeviceExtension,
                         IN ULONG NumberOfMicroseconds,
                         IN PHW_TIMER_ROUTINE TimerRoutine,
                         IN PVOID Context
)
/*++

Routine Description:

  schedules a timer callback for the minidriver

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - address of minidriver's device extension
  NumberOfMicroseconds - # of microseconds that should elapse before calling
  TimerRoutine - routine to call when the time expires
  Context - value to pass into the timer routine

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject;
    KIRQL           Irql;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    (HwDeviceExtension) - 1;
    PCOMMON_OBJECT  ComObj;

    ASSERT(HwDeviceExtension != NULL);

    StreamObject = CONTAINING_RECORD(
                                     HwStreamObject,
                                     STREAM_OBJECT,
                                     HwStreamObject
        );

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    //
    // The driver wants to set the timer.
    // Save the timer parameters.
    //

    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    if (HwStreamObject) {

        ComObj = &StreamObject->ComObj;
        //DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for stream.\n"));

    } else {

        StreamObject = NULL;
        ComObj = &DeviceExtension->ComObj;
        ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;
        DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for device.\n"));

    }

    //
    // assert that a timer is not scheduled multiple times.
    //

    #if DBG
    if ((ComObj->InterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) &&
        ((NumberOfMicroseconds != 0) && (ComObj->InterruptData.HwTimerValue
                                         != 0))) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled same timer twice!\n"));
        DEBUG_BREAKPOINT();
        ASSERT(1 == 0);
    }                           // if scheduled twice
    #endif

    ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_TIMER_CALL_REQUEST;
    ComObj->InterruptData.HwTimerRoutine = TimerRoutine;
    ComObj->InterruptData.HwTimerValue = NumberOfMicroseconds;
    ComObj->InterruptData.HwTimerContext = Context;

    if (StreamObject) {
        END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

    } else {

        END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    }                           // if streamobject
}



VOID
StreamClassCallAtNewPriority(
                             IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                             IN PVOID HwDeviceExtension,
                             IN STREAM_PRIORITY Priority,
                             IN PHW_PRIORITY_ROUTINE PriorityRoutine,
                             IN PVOID Context
)
/*++

Routine Description:

  schedules a callback at the specified priority

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - address of minidriver's device extension
  Priority - priority at which to call minidriver
  PriorityRoutine - routine to call at specified priority
  Context - value to pass into the priority routine

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject;
    KIRQL           Irql;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    (HwDeviceExtension) - 1;
    PCOMMON_OBJECT  ComObj;

    ASSERT(HwDeviceExtension != NULL);

    StreamObject = CONTAINING_RECORD(
                                     HwStreamObject,
                                     STREAM_OBJECT,
                                     HwStreamObject
        );

    //
    // The driver wants to get called back at a different priority.
    // Save the priority parameters.
    //

    if (Priority == LowToHigh) {

        //
        // the minidriver wishes to be called from low priority to high
        // we must call it directly from this routine as we cannot use
        // the interruptcontext structure due to the possibility of
        // reentrancy.
        //


        DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority LowToHigh.\n"));
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                                              (PVOID) PriorityRoutine,
                                              Context);

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);


        //
        // Call the DPC directly to check for work.
        //

        StreamClassDpc(NULL,
                       DeviceExtension->DeviceObject,
                       NULL,
                       NULL);

        KeLowerIrql(Irql);

    } else {

        if (HwStreamObject) {

            DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority to %x for stream %x\n",
                        StreamObject->ComObj.InterruptData.HwPriorityLevel, StreamObject->HwStreamObject.StreamNumber));
            ComObj = &StreamObject->ComObj;
            SCRequestDpcForStream(StreamObject);

        } else {

            DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority for device.\n"));
            ComObj = &DeviceExtension->ComObj;
            ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

        }                       // if streamobject

        #if DBG
        if ((ComObj->InterruptData.Flags &
            INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) || 
             ((ComObj->PriorityWorkItemScheduled) && (Priority == Low))) {

            DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
            DEBUG_BREAKPOINT();
            ASSERT(1 == 0);
        }                       // if scheduled twice

        ComObj->PriorityWorkItemScheduled = TRUE;

        #endif

        ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST;
        ComObj->InterruptData.HwPriorityLevel = Priority;
        ComObj->InterruptData.HwPriorityRoutine = PriorityRoutine;
        ComObj->InterruptData.HwPriorityContext = Context;
    }                           // if lowtohigh

}

VOID
StreamClassLogError(
                    IN PVOID HwDeviceExtension,
                    IN PHW_STREAM_REQUEST_BLOCK hwSRB OPTIONAL,
                    IN ULONG ErrorCode,
                    IN ULONG UniqueId
)
/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    SRB - Supplies an optional pointer to SRB if there is one.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
    ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PDEVICE_OBJECT  DeviceObject = deviceExtension->DeviceObject;
    PERROR_LOG_ENTRY errorLogEntry;
    PSTREAM_REQUEST_BLOCK SRB;
    KIRQL           Irql;

    //
    // If the error log entry is already full, then dump the error.
    //

    DEBUG_BREAKPOINT();
    ASSERT(HwDeviceExtension != NULL);
    BEGIN_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

    DebugPrint((DebugLevelError, "StreamClassLogError.\n"));
    if (deviceExtension->ComObj.InterruptData.Flags & INTERRUPT_FLAGS_LOG_ERROR) {
        DEBUG_BREAKPOINT();
        DebugPrint((1, "'StreamClassLogError: Ignoring error log packet.\n"));
        return;
    }
    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->ComObj.InterruptData.LogEntry;
    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB.
    //

    if (hwSRB != NULL) {

        DEBUG_BREAKPOINT();
        SRB = CONTAINING_RECORD(hwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);
        errorLogEntry->SequenceNumber = SRB->SequenceNumber;
    } else {

        DEBUG_BREAKPOINT();
        errorLogEntry->SequenceNumber = 0;
    }

    //
    // Indicate that the error log entry is in use and that a
    // notification
    // is required.
    //

    deviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_LOG_ERROR;

    END_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

    return;

}                               // end StreamClassLogError()


#if DBG


VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
)
/*++

Routine Description:

    Debug print routine

Arguments:

    DebugPrintLevel - Debug print level
    DebugMessage - message to print


Return Value:

    None

--*/

{
    va_list         ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= (INT) StreamDebug) {

        _vsnprintf(StreamBuffer, STREAM_BUFFER_SIZE-1, DebugMessage, ap);

        DbgPrint(StreamBuffer);
    }
    va_end(ap);

}                               // end StreamClassDebugPrint()

#else

//
// StreamClassDebugPrint stub
//

VOID
StreamClassDebugPrint(
                      STREAM_DEBUG_LEVEL DebugPrintLevel,
                      PSCHAR DebugMessage,
                      ...
)
{
}

#endif




STREAM_PHYSICAL_ADDRESS
StreamClassGetPhysicalAddress(
                              IN PVOID HwDeviceExtension,
                              IN PHW_STREAM_REQUEST_BLOCK HwSRB OPTIONAL,
                              IN PVOID VirtualAddress,
                              IN STREAM_BUFFER_TYPE Type,
                              OUT ULONG * Length
)
/*++

Routine Description:

    Convert virtual address to physical address for DMA.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.
    HwSRB - Supplies an optional pointer to SRB if there is one.
    VirtualAddress - pointer to address for which to retrieve physical address
    Type - type of buffer in VirtualAddress

Return Value:

    Returns phys address and length or NULL if invalid address

--*/

{
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PKSSTREAM_HEADER CurrentHeader;
    PKSSCATTER_GATHER ScatterList;
    PSTREAM_REQUEST_BLOCK SRB;
    ULONG           VirtualOffset;
    PHYSICAL_ADDRESS address;
    ULONG           NumberOfBuffers,
                    i,
                    SizeSoFar = 0,
                    ListSize = 0;
    ULONG           DataBytes;
    PHW_STREAM_OBJECT HwStreamObject;

    ASSERT(HwDeviceExtension != NULL);

    switch (Type) {

    case PerRequestExtension:

        ASSERT(HwSRB);
        SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) (SRB + 1));
        *Length = SRB->ExtensionLength - VirtualOffset;
        address.QuadPart = SRB->PhysicalAddress.QuadPart +
            sizeof(STREAM_REQUEST_BLOCK) +
            VirtualOffset;

        return (address);

    case DmaBuffer:
        VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) deviceExtension->DmaBuffer);
        *Length = deviceExtension->DmaBufferLength - VirtualOffset;
        address.QuadPart = deviceExtension->DmaBufferPhysical.QuadPart
            + VirtualOffset;

        return (address);

    case SRBDataBuffer:
        ASSERT(HwSRB);

        SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
                                STREAM_REQUEST_BLOCK,
                                HwSRB);

        HwStreamObject = SRB->HwSRB.StreamObject;
        ASSERT(HwStreamObject);

        CurrentHeader = SRB->HwSRB.CommandData.DataBufferArray;

        NumberOfBuffers = SRB->HwSRB.NumberOfBuffers;

        for (i = 0; i < NumberOfBuffers; i++) {

            if (SRB->HwSRB.Command == SRB_WRITE_DATA) {

                DataBytes = CurrentHeader->DataUsed;

            } else {            // if write

                DataBytes = CurrentHeader->FrameExtent;

            }                   // if write


            //
            // see if the buffer is within the range of this element
            //

            VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) CurrentHeader->Data + 1);
            if (VirtualOffset > DataBytes) {

                //
                // buffer not within this element.  add the size of this one
                // to our total.
                //

                SizeSoFar += DataBytes;

            } else {

                //
                // we've found the element.  Now calculate the phys
                // address from the phys list.
                //
                // GUBGUB - This function is seldom called. n is most ofen small
                // <=3. The O(n^2) performance concern is insignificant.
                // - this algorithm gets n^2 expensive for long lists
                // an alternative is to build a separate array which holds
                // the mapping between the stream headers and the s/g
                // elements
                // for each header.  We currently don't get that many
                // elements
                // so the below is more efficient now.
                //

                ScatterList = SRB->HwSRB.ScatterGatherBuffer;

                while (SizeSoFar > ListSize) {

                    ListSize += ScatterList++->Length;
                }

                //
                // Now ScatterList points to the correct scatter/gather
                // element.
                //


                while (VirtualOffset > ScatterList->Length) {
                    VirtualOffset -= ScatterList->Length;
                    ScatterList++;
                }

                *Length = ScatterList->Length - VirtualOffset + 1;
                address.QuadPart = ScatterList->PhysicalAddress.QuadPart
                    + VirtualOffset - 1;
                return (address);
            }                   // if buffer

            CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
                                 HwStreamObject->StreamHeaderMediaSpecific +
                                    HwStreamObject->StreamHeaderWorkspace));

        }                       // for # buffers

        DebugPrint((DebugLevelFatal, "StreamClassGetPhysicalAddress: address not in SRB!\n"));

    default:
        DEBUG_BREAKPOINT();
        *Length = 0;
        address.QuadPart = (LONGLONG) 0;
        return (address);

    }                           // switch

}                               // end StreamClassGetPhysicalAddress()

VOID
StreamClassDebugAssert(
                       IN PCHAR File,
                       IN ULONG Line,
                       IN PCHAR AssertText,
                       IN ULONG AssertValue
)
/*++

Routine Description:

    This is the minidriver debug assert call.  When running a checked version
    of the class driver, asserts are recognized resulting in a debug
    message and breakpoint.  When running a free version of the port driver,
    asserts are ignored.

Arguments:
    File - file name where assert occurred
    Line - line number of assert
    AssertText - Text to be printed
    AssertValue - value to be printed

Return Value:

    none

--*/
{
    DebugPrint((DebugLevelError, "(%s:%d) Assert failed (%s)=0x%x\n", File, Line, AssertText, AssertValue));
    DbgBreakPoint();
}



VOID
SCRequestDpcForStream(
                      IN PSTREAM_OBJECT StreamObject

)
/*++

Routine Description:

    This routine places a stream object on the NeedyStream queue if it is
    not already there

Arguments:

    StreamObject - pointer to stream object

Return Value:

    none

--*/
{
    PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

    //
    // add the stream to the queue of needy streams unless it is already
    // there.
    //

    #if DBG
    if (DeviceExtension->NeedyStream) {

        ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
    }
    #endif

    ASSERT(StreamObject->NextNeedyStream != StreamObject);

    if (!(StreamObject->OnNeedyQueue)) {

        ASSERT(!StreamObject->NextNeedyStream);

        DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x added to needy queue, Next = %x\n",
                    StreamObject, StreamObject->NextNeedyStream));

        StreamObject->OnNeedyQueue = TRUE;
        StreamObject->NextNeedyStream = DeviceExtension->NeedyStream;
        DeviceExtension->NeedyStream = StreamObject;

        ASSERT(StreamObject->NextNeedyStream != StreamObject);

    } else {

        DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x already on needy queue\n",
                    StreamObject));
    }                           // if on needy queue

    StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

}



VOID
StreamClassAbortOutstandingRequests(
                                    IN PVOID HwDeviceExtension,
                                    IN PHW_STREAM_OBJECT HwStreamObject,
                                    IN NTSTATUS Status
)
/*++

Routine Description:

  aborts outstanding requests on the specified device or stream

Arguments:

  HwStreamObject - address of minidriver's stream struct
  HwDeviceExtension - device extension
  Status - NT Status to use for aborting

Return Value:

  none

--*/

{
    PSTREAM_OBJECT  StreamObject = NULL;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    KIRQL           Irql;
    PLIST_ENTRY     SrbEntry,
                    ListEntry;
    PSTREAM_REQUEST_BLOCK CurrentSrb;
    PHW_STREAM_OBJECT CurrentHwStreamObject;
    PSTREAM_OBJECT  CurrentStreamObject;

    ASSERT(HwDeviceExtension != NULL);

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    if (HwStreamObject) {

        DEBUG_BREAKPOINT();
        StreamObject = CONTAINING_RECORD(HwStreamObject,
                                         STREAM_OBJECT,
                                         HwStreamObject);
    }
    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    DebugPrint((DebugLevelError, "StreamClassAbortOutstandingRequests.\n"));

    //
    // walk the outstanding queue and abort all requests on it.
    //

    SrbEntry = ListEntry = &DeviceExtension->OutstandingQueue;

    while (SrbEntry->Flink != ListEntry) {

        SrbEntry = SrbEntry->Flink;

        //
        // follow the link to the Srb
        //

        CurrentSrb = CONTAINING_RECORD(SrbEntry,
                                       STREAM_REQUEST_BLOCK,
                                       SRBListEntry);

        CurrentHwStreamObject = CurrentSrb->HwSRB.StreamObject;

        if ((!HwStreamObject) || (CurrentHwStreamObject ==
                                  HwStreamObject)) {


            //
            // abort this one and show that it's ready for a next request,
            // assuming it's active.  it might not be active if the
            // minidriver
            // just called it back.
            //

            if (CurrentSrb->Flags & SRB_FLAGS_IS_ACTIVE) {

                //
                // Clear the active flag.
                //

                CurrentSrb->Flags &= ~SRB_FLAGS_IS_ACTIVE;

                CurrentSrb->HwSRB.Status = Status;

                if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST) {

                    CurrentStreamObject = CONTAINING_RECORD(
                                                      CurrentHwStreamObject,
                                                            STREAM_OBJECT,
                                                            HwStreamObject
                        );
                    //
                    // indicate that the appropriate queue is ready for a
                    // next
                    // request.
                    //

                    if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER) {

                        CurrentStreamObject->ReadyForNextDataReq = TRUE;

                    } else {    // if data

                        CurrentStreamObject->ReadyForNextControlReq = TRUE;
                    }           // if data

                    DebugPrint((DebugLevelTrace, "'SCAbort: aborting stream IRP %x\n",
                                CurrentSrb->HwSRB.Irp));

                    //
                    // add the SRB to the list of completed stream SRB's.
                    //

                    CurrentSrb->HwSRB.NextSRB = CurrentStreamObject->ComObj.InterruptData.CompletedSRB;
                    CurrentStreamObject->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;

                    //
                    // add this stream to the queue of needy streams
                    //

                    SCRequestDpcForStream(CurrentStreamObject);

                } else {        // if stream

                    DebugPrint((DebugLevelTrace, "'SCAbort: aborting device IRP %x\n",
                                CurrentSrb->HwSRB.Irp));

                    //
                    // add the SRB to the list of completed device SRB's.
                    //

                    DEBUG_BREAKPOINT();
                    CurrentSrb->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;
                    DeviceExtension->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;

                    DeviceExtension->ReadyForNextReq = TRUE;

                }               // if stream

            }                   // if active
        }                       // if aborting this one
    }                           // while list entry

    //
    // all necessary requests have been aborted.  exit.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
}


PKSEVENT_ENTRY
StreamClassGetNextEvent(
                        IN PVOID HwInstanceExtension_OR_HwDeviceExtension,
                        IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                        IN OPTIONAL GUID * EventGuid,
                        IN OPTIONAL ULONG EventItem,
                        IN OPTIONAL PKSEVENT_ENTRY CurrentEvent
)
/*++

Routine Description:

Arguments:
    HwInstanceExtenion: was HwDeviceExtension. But we now support multiinstances.
    Therefore, we need the HwInstanceExtension instead for MF.

    CurrentEvent - event (if any) to get the next from

Return Value:

  next event, if any

--*/

{

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PFILTER_INSTANCE FilterInstance;    
    PDEVICE_EXTENSION DeviceExtension;
    
    //(PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PLIST_ENTRY     EventListEntry,
                    EventEntry;
    PKSEVENT_ENTRY  NextEvent,
                    ReturnEvent = NULL;
    KIRQL           Irql;

    //
    // see which is HwInstanceExtension_OR_HwDeviceExtension
    // need to try HwInstanceExtension first because is has a smaller
    // offset backward so we don't touch invalid memory.
    //
    // try
    FilterInstance = (PFILTER_INSTANCE) 
                     HwInstanceExtension_OR_HwDeviceExtension-1;
                     
    if ( SIGN_FILTER_INSTANCE != FilterInstance->Signature ) {
        //
        // single instance legacy driver
        //    
        DeviceExtension = (PDEVICE_EXTENSION)
                          HwInstanceExtension_OR_HwDeviceExtension -1;
                          
        ASSERT( 0 == DeviceExtension->MinidriverData->
                     HwInitData.FilterInstanceExtensionSize);

        if (DeviceExtension->NoSync) {
            KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
        }

        if ( IsListEmpty( &DeviceExtension->FilterInstanceList ) ) {
			//
			// filter has been closed. but we are called. 
			// Single instance drivers do not receive open/close
			// they don't know when to sotp calling this. 
			// We need to check.
			//
			DebugPrint((DebugLevelWarning, "GetNextEvent no open filters\n"));
			
            if (DeviceExtension->NoSync) {
                KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            }
            
			return NULL;
		}
		

        FilterInstance = (PFILTER_INSTANCE)
                         DeviceExtension->FilterInstanceList.Flink;

        if (DeviceExtension->NoSync) {
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
        }
                                           
        FilterInstance = CONTAINING_RECORD(FilterInstance,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
    }
    
    else {
        DeviceExtension = FilterInstance ->DeviceExtension;        
    }
    
    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }
    
    #endif
    //
    // take the spinlock if we are unsynchronized.
    //

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // loop thru the events, trying to find the requested one.
    //

    if (HwStreamObject) {

        EventListEntry = EventEntry = &StreamObject->NotifyList;

    } else { 
    
        EventListEntry = EventEntry = &FilterInstance->NotifyList;
    }

    while (EventEntry->Flink != EventListEntry) {

        EventEntry = EventEntry->Flink;
        NextEvent = CONTAINING_RECORD(EventEntry,
                                      KSEVENT_ENTRY,
                                      ListEntry);


        if ((EventItem == NextEvent->EventItem->EventId) &&
            (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

            //
            // if we are to return the 1st event which matches, break.
            //

            if (!CurrentEvent) {

                ReturnEvent = NextEvent;
                break;

            }                   // if !current
            //
            // if we are to return the next event after the specified one,
            // check
            // to see if these match.   If they do, zero the specified event
            // so
            // that we will return the next event of the specified type.
            //

            if (CurrentEvent == NextEvent) {
                CurrentEvent = NULL;

            }                   // if cur=next
        }                       // if guid & id match
    }                           // while events

    //
    // if we are unsynchronized, release the spinlock acquired in the macro
    // above.
    //

    ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok

    if (DeviceExtension->NoSync) {

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }
    //
    // return the next event, if any.
    //

    return (ReturnEvent);
}


VOID
StreamClassQueryMasterClock(
                            IN PHW_STREAM_OBJECT HwStreamObject,
                            IN HANDLE MasterClockHandle,
                            IN TIME_FUNCTION TimeFunction,
                            IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
)
/*++

Routine Description:

Arguments:

  HwStreamObject - address of minidriver's stream struct
  Context - value to pass into the time callback routine

Return Value:

  none

--*/

{

    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) StreamObject->DeviceExtension;
    KIRQL           Irql;

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

    //
    // save away the parameters for the clock query.  The DPC will do the
    // actual processing.
    //

    StreamObject->ComObj.InterruptData.HwQueryClockRoutine = ClockCallbackRoutine;
    StreamObject->ComObj.InterruptData.HwQueryClockFunction = TimeFunction;

    StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST;


    END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);
}

#if ENABLE_MULTIPLE_FILTER_TYPES
VOID
StreamClassFilterReenumerateStreams(
    IN PVOID HwInstanceExtension,
    IN ULONG StreamDescriptorSize )
/*++

    Description:

        Reenumerates all streams on the filter instance.
        This is used to increase the number of pins exposed to
        the world so that application can make connections on
        new streams exposed. It's caller's responsibility
        not to change the order of the streams that have been
        open ( connected ). If there is no reduction of the streams
        This won't be an issue.

    Arguments;

        HwInstanceExtension:
            The instanc extension pointer we gave to the mini driver

        StreamDecriptorSize:
            # of bytes to contain the new stream descriptor for the filter

    Return Valuse:

        None    
--*/
{
    PFILTER_INSTANCE    FilterInstance;
    PDEVICE_EXTENSION   DeviceExtension; 
    KIRQL               Irql;

    FilterInstance = ( PFILTER_INSTANCE ) HwInstanceExtension -1;
    DeviceExtension = FilterInstance->DeviceExtension;
    
    //
    // take the spinlock if we are unsynchronized.
    //

    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }
    #   endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // show that we need to rescan the stream info, and set the new size in
    // the config info structure.
    //

    DeviceExtension->ComObj.InterruptData.Flags |=
        INTERRUPT_FLAGS_NEED_STREAM_RESCAN;

    InterlockedExchange( &FilterInstance->NeedReenumeration, 1 );
    FilterInstance->StreamDescriptorSize = StreamDescriptorSize;

    //
    // queue a DPC to service the request.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    return;
}
#endif // ENABLE_MULTIPLE_FILTER_TYPES

VOID
StreamClassReenumerateStreams(
                              IN PVOID HwDeviceExtension,
                              IN ULONG StreamDescriptorSize
)
/*++

Routine Description:

    Reenumerates all streams on the device

Arguments:

    HwDeviceExtension - pointer to minidriver's device extension
    StreamDescriptorSize - size of the buffer needed by the minidriver to
     hold the stream info.

Return Value:

    none

--*/

{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    KIRQL           Irql;

    //
    // take the spinlock if we are unsynchronized.
    //

    TRAP;
    #if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
    #endif

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // show that we need to rescan the stream info, and set the new size in
    // the config info structure.
    //

    ASSERT(!DeviceExtension->ComObj.InterruptData.Flags &
           INTERRUPT_FLAGS_NEED_STREAM_RESCAN);

    DeviceExtension->ComObj.InterruptData.Flags |=
        INTERRUPT_FLAGS_NEED_STREAM_RESCAN;
    DeviceExtension->ConfigurationInformation->StreamDescriptorSize =
        StreamDescriptorSize;

    //
    // queue a DPC to service the request.
    //

    END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);
    return;
}



#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// OK to have zero instances of pin In this case you will have to
// Create a pin to have even one instance
#define REG_PIN_B_ZERO 0x1

// The filter renders this input
#define REG_PIN_B_RENDERER 0x2

// OK to create many instance of  pin
#define REG_PIN_B_MANY 0x4

// This is an Output pin
#define REG_PIN_B_OUTPUT 0x8

typedef struct {
    ULONG           Version;
    ULONG           Merit;
    ULONG           Pins;
    ULONG           Reserved;
}               REGFILTER_REG;

typedef struct {
    ULONG           Signature;
    ULONG           Flags;
    ULONG           PossibleInstances;
    ULONG           MediaTypes;
    ULONG           MediumTypes;
    ULONG           CategoryOffset;
    ULONG           MediumOffset;   // By definition, we always have a Medium
    //#ifdef _WIN64
    //This method create filterdata that upset ring3 code.
    //ULONG           ulPad;        // align to quadword to make ia64 happy
    //#endif
}               REGFILTERPINS_REG2;


NTSTATUS
StreamClassRegisterFilterWithNoKSPins(
                                      IN PDEVICE_OBJECT DeviceObject,
                                      IN const GUID * InterfaceClassGUID,
                                      IN ULONG PinCount,
                                      IN BOOL * PinDirection,
                                      IN KSPIN_MEDIUM * MediumList,
                                      IN OPTIONAL GUID * CategoryList
)
/*++

Routine Description:

    This routine is used to register filters with DShow which have no
    KS pins and therefore do not stream in kernel mode.  This is typically
    used for TvTuners, Crossbars, and the like.  On exit, a new binary
    registry key, "FilterData" is created which contains the Mediums and
    optionally the Categories for each pin on the filter.

Arguments:

    DeviceObject -
           Device object

    InterfaceClassGUID
           GUID representing the class to register

    PinCount -
           Count of the number of pins on this filter

    PinDirection -
           Array of BOOLS indicating pin direction for each pin (length PinCount)
           If TRUE, this pin is an output pin

    MediumList -
           Array of PKSMEDIUM_DATA (length PinCount)

    CategoryList -
           Array of GUIDs indicating pin categories (length PinCount) OPTIONAL


Return Value:

    NTSTATUS SUCCESS if the Blob was created

--*/
{
    NTSTATUS        Status;
    ULONG           CurrentPin;
    ULONG           TotalCategories;
    REGFILTER_REG  *RegFilter;
    REGFILTERPINS_REG2 UNALIGNED * RegPin;
    GUID            UNALIGNED * CategoryCache;
    KSPIN_MEDIUM    UNALIGNED * MediumCache;
    ULONG           FilterDataLength;
    PUCHAR          FilterData;
    PWSTR           SymbolicLinkList;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if ((PinCount == 0) || (!InterfaceClassGUID) || (!PinDirection) || (!MediumList)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Calculate the maximum amount of space which could be taken up by
    // this cache data.
    //
    
    TotalCategories = (CategoryList ? PinCount : 0);

    FilterDataLength = sizeof(REGFILTER_REG) +
        PinCount * sizeof(REGFILTERPINS_REG2) +
        PinCount * sizeof(KSPIN_MEDIUM) +
        TotalCategories * sizeof(GUID);
    //
    // Allocate space to create the BLOB
    //

    FilterData = ExAllocatePool(PagedPool, FilterDataLength);
    if (!FilterData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Place the header in the data, defaulting the Merit to "unused".
    //

    DebugPrint((DebugLevelTrace,
                "FilterData:%p\n",
                FilterData ));

    RegFilter = (REGFILTER_REG *) FilterData;
    RegFilter->Version = 2;
    RegFilter->Merit = 0x200000;
    RegFilter->Pins = PinCount;
    RegFilter->Reserved = 0;

    //
    // Calculate the offset to the list of pins, and to the
    // MediumList and CategoryList
    //

    RegPin = (REGFILTERPINS_REG2 *) (RegFilter + 1);
    MediumCache = (PKSPIN_MEDIUM) ((PUCHAR) (RegPin + PinCount));
    CategoryCache = (GUID *) (MediumCache + PinCount);

    //
    // Create each pin header, followed by the list of Mediums
    // followed by the list of optional categories.
    //

    for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++, RegPin++) {

        //
        // Initialize the pin header.
        //
        
        DebugPrint((DebugLevelTrace,
                    "CurrentPin:%d RegPin:%p MediumCache:%p CategoryCache:%p\n",
                    CurrentPin, RegPin, MediumCache, CategoryCache ));
                    
        RegPin->Signature = FCC('0pi3');
        (*(PUCHAR) & RegPin->Signature) += (BYTE) CurrentPin;
        RegPin->Flags = (PinDirection[CurrentPin] ? REG_PIN_B_OUTPUT : 0);
        RegPin->PossibleInstances = 1;
        RegPin->MediaTypes = 0;
        RegPin->MediumTypes = 1;
        RegPin->MediumOffset = (ULONG) ((PUCHAR) MediumCache - (PUCHAR) FilterData);

        *MediumCache++ = MediumList[CurrentPin];

        if (CategoryList) {
            RegPin->CategoryOffset = (ULONG) ((PUCHAR) CategoryCache - (PUCHAR) FilterData);
            *CategoryCache++ = CategoryList[CurrentPin];
        } else {
            RegPin->CategoryOffset = 0;
        }

    }

    //
    // Now create the BLOB in the registry
    //

	//
	// Note for using the flag DEVICE_INTERFACE_INCLUDE_NONACTIVE following:
	// PnP change circa 3/30/99 made the funtion IoSetDeviceInterfaceState() become
	// asynchronous. It returns SUCCESS even when the enabling is deferred. Now when
	// we arrive here, the DeviceInterface is still not enabled, we receive empty 
	// Symbolic link if the flag is not set. Here we only try to write relevent
	// FilterData to the registry. I argue this should be fine for 
	// 1. Currently, if a device is removed, the registry key for the DeviceClass
	//	  remains and with FilterData.Whatever components use the FilterData should
	//	  be able to handle if the device is removed by either check Control\Linked
	//	  or handling the failure in attempt to make connection to the non-exiting device.
	// 2. I have found that if a device is moved between slots ( PCI, USB ports ) the
	//	  DeviceInterface at DeviceClass is reused or at lease become the first entry in 
	//    the registry. Therefore, we will be updating the right entry with the proposed flag.
	//
    if (NT_SUCCESS(Status = IoGetDeviceInterfaces(
                       InterfaceClassGUID,   // ie.&KSCATEGORY_TVTUNER,etc.
                       DeviceObject, // IN PDEVICE_OBJECT PhysicalDeviceObject,OPTIONAL,
                       DEVICE_INTERFACE_INCLUDE_NONACTIVE,    // IN ULONG Flags,
                       &SymbolicLinkList // OUT PWSTR *SymbolicLinkList
                       ))) {
        UNICODE_STRING  SymbolicLinkListU;
        HANDLE          DeviceInterfaceKey;

        RtlInitUnicodeString(&SymbolicLinkListU, SymbolicLinkList);

        DebugPrint((DebugLevelVerbose,
                    "NoKSPin for SymbolicLink %S\n",
                    SymbolicLinkList ));
                    
        if (NT_SUCCESS(Status = IoOpenDeviceInterfaceRegistryKey(
                           &SymbolicLinkListU,    // IN PUNICODE_STRING SymbolicLinkName,
                           STANDARD_RIGHTS_ALL,   // IN ACCESS_MASK DesiredAccess,
                           &DeviceInterfaceKey    // OUT PHANDLE DeviceInterfaceKey
                           ))) {

            UNICODE_STRING  FilterDataString;

            RtlInitUnicodeString(&FilterDataString, L"FilterData");

            Status = ZwSetValueKey(DeviceInterfaceKey,
                                   &FilterDataString,
                                   0,
                                   REG_BINARY,
                                   FilterData,
                                   FilterDataLength);

            ZwClose(DeviceInterfaceKey);
        }
        
        // START NEW MEDIUM CACHING CODE
        for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {
            NTSTATUS LocalStatus;

            LocalStatus = KsCacheMedium(&SymbolicLinkListU, 
                                        &MediumList[CurrentPin],
                                        (DWORD) ((PinDirection[CurrentPin] ? 1 : 0))   // 1 == output
                                        );
            #if DBG
            if (LocalStatus != STATUS_SUCCESS) {
                DebugPrint((DebugLevelError,
                           "KsCacheMedium: SymbolicLink = %S, Status = %x\n",
                           SymbolicLinkListU.Buffer, LocalStatus));
            }
            #endif
        }
        // END NEW MEDIUM CACHING CODE
        
        ExFreePool(SymbolicLinkList);
    }
    ExFreePool(RegFilter);

    return Status;
}

BOOLEAN
StreamClassReadWriteConfig(
                           IN PVOID HwDeviceExtension,
                           IN BOOLEAN Read,
                           IN PVOID Buffer,
                           IN ULONG Offset,
                           IN ULONG Length
)
/*++

Routine Description:

    Sends down a config space read/write.   MUST BE CALLED AT PASSIVE LEVEL!

Arguments:

    HwDeviceExtension - device extension

    Read - TRUE if read, FALSE if write.

    Buffer - The info to read or write.

    Offset - The offset in config space to read or write.

    Length - The length to transfer.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP            irp;
    NTSTATUS        ntStatus;
    KEVENT          event;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;

    PAGED_CODE();

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if (Read) {
        memset(Buffer, '\0', Length);
    }
    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (!irp) {
        DebugPrint((DebugLevelError, "StreamClassRWConfig: no IRP.\n"));
        TRAP;
        return (FALSE);
    }

    //
    // new rule says all PnP Irp must be initialized to this
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           SCSynchCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.WhichSpace = 0;
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Offset = Offset;
    nextStack->Parameters.ReadWriteConfig.Length = Length;

    ASSERT( DeviceExtension->HwDeviceExtension == HwDeviceExtension );
    ntStatus = IoCallDriver(DeviceExtension->PhysicalDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
        // wait for irp to complete

        TRAP;
        KeWaitForSingleObject(
                              &event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    if (!NT_SUCCESS(ntStatus)) {
        DebugPrint((DebugLevelError, "StreamClassRWConfig: bad status!.\n"));
        TRAP;
    }
    IoFreeIrp(irp);
    return (TRUE);

}


VOID
StreamClassQueryMasterClockSync(
                                IN HANDLE MasterClockHandle,
                                IN OUT PHW_TIME_CONTEXT TimeContext
)
/*++

Routine Description:

  synchronously returns the current time requested, based on the TimeContext
  parameter.

Arguments:

Return Value:

  none

--*/

{

    PHW_STREAM_OBJECT HwStreamObject = TimeContext->HwStreamObject;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject);

    LARGE_INTEGER       ticks;
    ULONGLONG       rate;
    KIRQL           SavedIrql;

    ASSERT(MasterClockHandle);
    ASSERT(TimeContext->HwDeviceExtension);
    ASSERT(HwStreamObject);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Lock the use of MasterClock, so it won't dispear under us
    // 
    KeAcquireSpinLock( &StreamObject->LockUseMasterClock, &SavedIrql );

    if ( NULL == StreamObject->MasterClockInfo ) {
        //
        // If we are called when MasterClockInfo is NULL,
        // the mini driver has screwed up. We don't want to fault.
        //    
        ASSERT(0 && "Mini driver queries clock while there is no master clock" );
        //
        // give a hint that something is wrong via Time, since we return void.
        //
        TimeContext->Time = (ULONGLONG)-1;
        goto Exit;
    }

    //
    // process the requested time function
    //

    switch (TimeContext->Function) {

    case TIME_GET_STREAM_TIME:

        TimeContext->Time = StreamObject->MasterClockInfo->
            FunctionTable.GetCorrelatedTime(
                             StreamObject->MasterClockInfo->ClockFileObject,
                                            &TimeContext->SystemTime);
        break;


    case TIME_READ_ONBOARD_CLOCK:

        TRAP;

        TimeContext->Time = StreamObject->MasterClockInfo->
            FunctionTable.GetTime(
                            StreamObject->MasterClockInfo->ClockFileObject);

        //
        // timestamp the value as close as possible
        //

        ticks = KeQueryPerformanceCounter((PLARGE_INTEGER) & rate);

        TimeContext->SystemTime = KSCONVERT_PERFORMANCE_TIME( rate, ticks );
            

        break;

    default:
        DebugPrint((DebugLevelFatal, "SCQueryClockSync: unknown type!"));
        TRAP;
    }

Exit:
    KeReleaseSpinLock( &StreamObject->LockUseMasterClock, SavedIrql );
    return;
}

VOID
StreamClassCompleteRequestAndMarkQueueReady(
                                            IN PHW_STREAM_REQUEST_BLOCK Srb
)
/*++

Routine Description:

  completes a stream request and marks the appropriate queue as ready for next

Arguments:

Return Value:

  none

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) Srb->HwDeviceExtension - 1;

    ASSERT(!(DeviceExtension->NoSync));

    ASSERT(Srb->Status != STATUS_PENDING);

    DebugPrint((DebugLevelTrace, "'StreamClassComplete&Mark:SRB = %p\n",
                Srb));

    switch (Srb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
                          SRB_HW_FLAGS_STREAM_REQUEST)) {

    case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:

        StreamClassStreamNotification(StreamRequestComplete,
                                      Srb->StreamObject,
                                      Srb);

        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      Srb->StreamObject);

        break;

    case SRB_HW_FLAGS_STREAM_REQUEST:


        StreamClassStreamNotification(StreamRequestComplete,
                                      Srb->StreamObject,
                                      Srb);

        StreamClassStreamNotification(ReadyForNextStreamControlRequest,
                                      Srb->StreamObject);

        break;

    default:


        StreamClassDeviceNotification(DeviceRequestComplete,
                                      Srb->HwDeviceExtension,
                                      Srb);

        StreamClassDeviceNotification(ReadyForNextDeviceRequest,
                                      Srb->HwDeviceExtension);

        break;

    }                           // switch

}

#if ENABLE_MULTIPLE_FILTER_TYPES

VOID STREAMAPI
StreamClassFilterNotification(
	IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwInstanceExtension,
    ...
);

VOID STREAMAPI
StreamClassFilterScheduleTimer(
    IN PVOID HwInstanceExtension,
    IN ULONG NumberOfMicroseconds,
    IN PHW_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
);


PKSEVENT_ENTRY
StreamClassDeviceInstanceGetNextEvent(
    IN PVOID HwInstanceExtension,
    IN OPTIONAL GUID * EventGuid,
	IN OPTIONAL ULONG EventItem,
    IN OPTIONAL PKSEVENT_ENTRY CurrentEvent
)
/*++

Routine Description:

Arguments:

    CurrentEvent - event (if any) to get the next from

Return Value:

  next event, if any

--*/
{
	PFILTER_INSTANCE FilterInstance= (PFILTER_INSTANCE)
										HwInstanceExtension - 1;
    PDEVICE_EXTENSION DeviceExtension =
					    FilterInstance->DeviceObject->DeviceExtension;
    PLIST_ENTRY     EventListEntry, EventEntry;
    PKSEVENT_ENTRY  NextEvent, ReturnEvent = NULL;
    KIRQL           Irql;

	#if DBG
    if (DeviceExtension->NoSync) {

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    }                           // if nosync
	#endif

    //
    // take the spinlock if we are unsynchronized.
    //

    BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

    //
    // loop thru the events, trying to find the requested one.
    //

    EventListEntry = EventEntry = &FilterInstance->NotifyList;

    while (EventEntry->Flink != EventListEntry) {

        EventEntry = EventEntry->Flink;
        NextEvent = CONTAINING_RECORD(EventEntry,
                                      KSEVENT_ENTRY,
                                      ListEntry);


        if ((EventItem == NextEvent->EventItem->EventId) &&
            (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

            //
            // if we are to return the 1st event which matches, break.
            //

            if (!CurrentEvent) {

                ReturnEvent = NextEvent;
                break;

            }                   // if !current
            //
            // if we are to return the next event after the specified one,
            // check
            // to see if these match.   If they do, zero the specified event
            // so
            // that we will return the next event of the specified type.
            //

            if (CurrentEvent == NextEvent) {
                CurrentEvent = NULL;

            }                   // if cur=next
        }                       // if guid & id match
    }                           // while events

    //
    // if we are unsynchronized, release the spinlock acquired in the macro
    // above.
    //

    ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok.

    if (DeviceExtension->NoSync) {

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }
    //
    // return the next event, if any.
    //

    return (ReturnEvent);
}


#endif // ENABLE_MULTIPLE_FILTER_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\messages.h ===
/*---
Copyright (c) 1995  Microsoft Corporation

Module Name:

    messages.h

Abstract:

    Log message file for Codec Class Driver

Author:

	 billpa

Revision History:

--*/


//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_CODCLASS_ERROR_CODE     0x6
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CODCLASS_NO_ADAPTERS_FOUND
//
// MessageText:
//
//  Codec Minidriver found no usable adapter cards.
//
#define CODCLASS_NO_ADAPTERS_FOUND       ((NTSTATUS)0xC0060001L)

//
// MessageId: CODCLASS_ADAPTER_FOUND
//
// MessageText:
//
//  Codec Minidriver found adapter card.
//
#define CODCLASS_ADAPTER_FOUND           ((NTSTATUS)0x40060002L)

//
// MessageId: CODCLASS_CLASS_MINIDRIVER_MISMATCH
//
// MessageText:
//
//  Codec Minidriver does not match the revision of the Codec Class driver.
//
#define CODCLASS_CLASS_MINIDRIVER_MISMATCH  ((NTSTATUS)0xC0060003L)

//
// MessageId: CODCLASS_MINIDRIVER_MISSING_ENTRIES
//
// MessageText:
//
//  Codec Minidriver is missing required entries in HW_INITIALIZATION_DATA structure.
//  (HwInitialize, HwFindAdapter or HwStartIo)
//
#define CODCLASS_MINIDRIVER_MISSING_ENTRIES ((NTSTATUS)0xC0060004L)

//
// MessageId: CODCLASS_NO_PAGEDPOOL
//
// MessageText:
//
//  Codec Class driver could not allocate sufficient Paged Pool.
//
#define CODCLASS_NO_PAGEDPOOL            ((NTSTATUS)0xC0060005L)

//
// MessageId: CODCLASS_NO_NONPAGEDPOOL
//
// MessageText:
//
//  Codec Class driver could not allocate sufficient Non-Paged Pool.
//
#define CODCLASS_NO_NONPAGEDPOOL         ((NTSTATUS)0xC0060006L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_VIDEO_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_VIDEO_DEVICE ((NTSTATUS)0xC0060007L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_AUDIO_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_AUDIO_DEVICE ((NTSTATUS)0xC0060008L)

//
// MessageId: CODCLASS_COULD_NOT_CREATE_OVERLAY_DEVICE
//
// MessageText:
//
//  Codec Class driver could not create Video device for %1.
//
#define CODCLASS_COULD_NOT_CREATE_OVERLAY_DEVICE ((NTSTATUS)0xC0060009L)

//
// MessageId: CODCLASS_MINIDRIVER_BAD_CONFIG
//
// MessageText:
//
//  Codec Minidriver reported Bad Configuration info.
//  Possibly insufficient I/O resources.
//
#define CODCLASS_MINIDRIVER_BAD_CONFIG     ((NTSTATUS)0xC006000AL)

//
// MessageId: CODCLASS_MINIDRIVER_INTERNAL
//
// MessageText:
//
//  Codec Minidriver %1 reported an invalid error code while attempting to find the adapter.
//
#define CODCLASS_MINIDRIVER_INTERNAL       ((NTSTATUS)0xC006000BL)

//
// MessageId: CODCLASS_RESOURCE_CONFLICT
//
// MessageText:
//
//  A conflict was detected while reporting resources.
//
#define CODCLASS_RESOURCE_CONFLICT       ((NTSTATUS)0xC006000CL)

//
// MessageId: CODCLASS_INTERRUPT_CONNECT
//
// MessageText:
//
//  Codec Minidriver unable to connect to Interrupt.
//
#define CODCLASS_INTERRUPT_CONNECT       ((NTSTATUS)0xC006000DL)

//
// MessageId: CODCLASS_MINIDRIVER_HWINITIALIZE
//
// MessageText:
//
//  Codec Minidriver Hardware Initialize failed.
//
#define CODCLASS_MINIDRIVER_HWINITIALIZE   ((NTSTATUS)0xC006000EL)

//
// MessageId: CODCLASS_DOSNAME
//
// MessageText:
//
//  Codec Class failed creating DOS name: %2.
//
#define CODCLASS_DOSNAME                 ((NTSTATUS)0xC006000FL)

//
// MessageId: CODCLASS_DMA_ALLOCATE
//
// MessageText:
//
//  Codec Class could not Get DMA Adapter.
//
#define CODCLASS_DMA_ALLOCATE            ((NTSTATUS)0xC0060010L)

//
// MessageId: CODCLASS_DMA_BUFFER_ALLOCATE
//
// MessageText:
//
//  Codec Class could not allocate DMA buffer.
//
#define CODCLASS_DMA_BUFFER_ALLOCATE     ((NTSTATUS)0xC0060011L)

//
// MessageId: CODCLASS_MINIDRIVER_ERROR
//
// MessageText:
//
//  Codec Minidriver reported unspecified error:
//   (%2).
//
#define CODCLASS_MINIDRIVER_ERROR          ((NTSTATUS)0xC0060012L)

//
// MessageId: CODCLASS_MINIDRIVER_REVISION_MISMATCH
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Class / Minidriver revision mismatch (%2).
//
#define CODCLASS_MINIDRIVER_REVISION_MISMATCH ((NTSTATUS)0xC0060013L)

//
// MessageId: CODCLASS_MINIDRIVER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Insufficient resources available (%2).
//
#define CODCLASS_MINIDRIVER_INSUFFICIENT_RESOURCES ((NTSTATUS)0xC0060014L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_INTERRUPT
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid interrupt setting (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_INTERRUPT ((NTSTATUS)0xC0060015L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_DMA
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid DMA channel setting (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_DMA    ((NTSTATUS)0xC0060016L)

//
// MessageId: CODCLASS_MINIDRIVER_NO_DMA_BUFFER
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Insufficient resources for DMA buffer (%2).
//
#define CODCLASS_MINIDRIVER_NO_DMA_BUFFER  ((NTSTATUS)0xC0060017L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_MEMORY
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid Memory address range specified  (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_MEMORY ((NTSTATUS)0xC0060018L)

//
// MessageId: CODCLASS_MINIDRIVER_INVALID_CLASS
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Invalid Class address range specified (%2).
//
#define CODCLASS_MINIDRIVER_INVALID_CLASS   ((NTSTATUS)0xC0060019L)

//
// MessageId: CODCLASS_MINIDRIVER_HW_UNSUPCLASSED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Revision of hardware detected is not supported (%2).
//
#define CODCLASS_MINIDRIVER_HW_UNSUPCLASSED ((NTSTATUS)0xC006001AL)

//
// MessageId: CODCLASS_NO_GLOBAL_INFO_POOL
//
// MessageText:
//
//   Could not allocate MPEG info structure.
//
#define CODCLASS_NO_GLOBAL_INFO_POOL ((NTSTATUS)0xC006001BL)

//
// MessageId: CODCLASS_NO_MINIDRIVER_INFO
//
// MessageText:
//
//   Could not find MPEG info structure.
//
#define CODCLASS_NO_MINIDRIVER_INFO ((NTSTATUS)0xC006001CL)

//
// MessageId: CODCLASS_NO_ACCESS_RANGE_POOL
//
// MessageText:
//
//   Could not allocate access range space
//

#define CODCLASS_NO_ACCESS_RANGE_POOL ((NTSTATUS)0xC006001DL)

//
// MessageId: CODCLASS_NO_STREAM_INFO_POOL
//
// MessageText:
//
// Could not allocate stream information structure
//
#define CODCLASS_NO_STREAM_INFO_POOL ((NTSTATUS)0xC006001EL)

//
// MessageId: CODCLASS_MINIDRIVER_VIDEO_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Video device failed (%2).
//
#define CODCLASS_MINIDRIVER_VIDEO_FAILED   ((NTSTATUS)0xC006001FL)

//
// MessageId: CODCLASS_MINIDRIVER_AUDIO_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Audio device failed (%2).
//
#define CODCLASS_MINIDRIVER_AUDIO_FAILED   ((NTSTATUS)0xC0060020L)

//
// MessageId: CODCLASS_MINIDRIVER_OVERLAY_FAILED
//
// MessageText:
//
//  Codec Minidriver reported error:
//   Overlay device failed (%2).
//
#define CODCLASS_MINIDRIVER_OVERLAY_FAILED ((NTSTATUS)0xC0060021L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\sources.inc ===
TARGETNAME=stream
TARGETTYPE=EXPORT_DRIVER
DRIVERTYPE=WDM
DLLDEF=$(O)\codcls.def

TARGETPATH=obj

INCLUDES=..\inc

TARGETLIBS=$(DDK_LIB_PATH)\ks.lib \
           $(DDK_LIB_PATH)\ksguid.lib

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(DDK_LIB_PATH)\$(TARGETNAME).lib}

MSC_WARNING_LEVEL=/W3

LINKER_FLAGS =$(LINKER_FLAGS) -merge:PAGECONST=PAGE
C_DEFINES=$(C_DEFINES) -DUSE_DMA_MACROS


SOURCES=codguts.c        \
        codinit.c        \
        lowerapi.c        \
        upperapi.c      \
        codcls.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\codinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   codinit.c

Abstract:

   This is the WDM streaming class driver.  This module contains code related
   to driver initialization.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, StreamClassRegisterAdapter)

#if ENABLE_MULTIPLE_FILTER_TYPES
//#pragma alloc_text(PAGE, StreamClassRegisterNameExtensions)
#endif

#pragma alloc_text(PAGE, StreamClassPnPAddDevice)
#pragma alloc_text(PAGE, StreamClassPnPAddDeviceWorker)
#pragma alloc_text(PAGE, StreamClassPnP)
#pragma alloc_text(PAGE, SCStartWorker)
#pragma alloc_text(PAGE, SCUninitializeMinidriver)
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SCFreeAllResources)
#pragma alloc_text(PAGE, SCInitializeCallback)
#pragma alloc_text(PAGE, SCStreamInfoCallback)
#pragma alloc_text(PAGE, SCUninitializeCallback)
#pragma alloc_text(PAGE, SCUnknownPNPCallback)
#pragma alloc_text(PAGE, SCUnknownPowerCallback)
#pragma alloc_text(PAGE, SciQuerySystemPowerHiberCallback)
#pragma alloc_text(PAGE, SCInsertStreamInfo)
#pragma alloc_text(PAGE, SCPowerCallback)
#pragma alloc_text(PAGE, SCCreateSymbolicLinks)
#pragma alloc_text(PAGE, SCDestroySymbolicLinks)
#pragma alloc_text(PAGE, SCCreateChildPdo)
#pragma alloc_text(PAGE, SCEnumerateChildren)
#pragma alloc_text(PAGE, SCEnumGetCaps)
#pragma alloc_text(PAGE, SCQueryEnumId)
#pragma alloc_text(PAGE, StreamClassForwardUnsupported)
#pragma alloc_text(PAGE, SCPowerCompletionWorker)
#pragma alloc_text(PAGE, SCSendSurpriseNotification)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

static const WCHAR EnumString[] = L"Enum";
static const WCHAR PnpIdString[] = L"PnpId";

// CleanUp - the following three strings should go away

static const WCHAR ClsIdString[] = L"CLSID";
static const WCHAR DriverDescString[] = L"DriverDesc";
static const WCHAR FriendlyNameString[] = L"FriendlyName";

static const WCHAR DeviceTypeName[] = L"GLOBAL";

static const    DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems)
{
    DEFINE_KSCREATE_ITEM(
                         FilterDispatchGlobalCreate,
                         DeviceTypeName,
                         NULL),
};

//
// list anchor for global minidriver info.
//

DEFINE_KSPIN_INTERFACE_TABLE(PinInterfaces)
{
    DEFINE_KSPIN_INTERFACE_ITEM(
                                KSINTERFACESETID_Standard,
                                KSINTERFACE_STANDARD_STREAMING),
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMediums)
{
    DEFINE_KSPIN_MEDIUM_ITEM(
                             KSMEDIUMSETID_Standard,
                             KSMEDIUM_TYPE_ANYINSTANCE),
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

NTSTATUS
StreamClassRegisterAdapter(
                           IN PVOID Argument1,
                           IN PVOID Argument2,
                           IN PHW_INITIALIZATION_DATA HwInitializationData
)
/*++

Routine Description:

    This routine registers a new streaming minidriver.

Arguments:
    Argument1 - Pointer to driver object created by system.
    Argument2 - Pointer to a UNICODE string of the registry path created
            by system.
    HwInitializationData - Minidriver initialization structure.

Return Value:

    Returns STATUS_SUCCESS if successful

--*/
{
    NTSTATUS        Status;

    PDRIVER_OBJECT  driverObject = Argument1;
    PDEVICE_EXTENSION deviceExtension = NULL;
    PMINIDRIVER_INFORMATION pMinidriverInfo;

    PAGED_CODE();

    DebugPrint((DebugLevelVerbose, "'StreamClassInitialize: enter\n"));

    //
    // Check that the length of this structure is what the
    // port driver expects it to be. This is effectively a
    // version check.
    //
    #if ENABLE_MULTIPLE_FILTER_TYPES
    //
    // we split the ULONG HwInitializationDataSize into two ushorts, one for 
    // SizeOfThisPacket, another for StreamClassVersion which must be 0x0200 to
    // indicate the two reserved fields now NumNameExtesnions and NameExtensionArray,
    // contain valid information.
    //
     
    if (HwInitializationData->SizeOfThisPacket != sizeof(HW_INITIALIZATION_DATA) ||
        ( HwInitializationData->StreamClassVersion != 0 &&
          HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20)) {
          
        DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);
        ASSERT( 0 );
        return (STATUS_REVISION_MISMATCH);
    }
    
    #else // ENABLE_MULTIPLE_FILTER_TYPES
    
    if (HwInitializationData->HwInitializationDataSize < sizeof(HW_INITIALIZATION_DATA)) {
        DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);
        ASSERT( 0 );
        return (STATUS_REVISION_MISMATCH);
    }
    #endif // ENABLE_MULTIPLE_FILTER_TYPES
    
    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwReceivePacket) ||
        (!HwInitializationData->HwRequestTimeoutHandler)) {
        DebugPrint((DebugLevelFatal,
                    "StreamClassInitialize: Minidriver driver missing required entry\n"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_MINIDRIVER_MISSING_ENTRIES, 0x1003);
        return (STATUS_REVISION_MISMATCH);
    }
    //
    // set up dummy routines for each unsupported function
    //

    if (!HwInitializationData->HwCancelPacket) {
        HwInitializationData->HwCancelPacket = SCDummyMinidriverRoutine;
    }
    //
    // Set up the device driver entry points.
    //

    driverObject->MajorFunction[IRP_MJ_PNP] = StreamClassPnP;
    driverObject->MajorFunction[IRP_MJ_POWER] = StreamClassPower;
    driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = StreamClassForwardUnsupported;
    // TODO: remove this once KS can multiplex cleanup Irps
    driverObject->MajorFunction[IRP_MJ_CLEANUP] = StreamClassCleanup;
    driverObject->DriverUnload = KsNullDriverUnload;
    driverObject->DriverExtension->AddDevice = StreamClassPnPAddDevice;

    //
    // set ioctl interface
    //
    driverObject->MajorFunction[IRP_MJ_CREATE] = StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
        StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_CLOSE] = StreamClassPassThroughIrp;
    driverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = 
        StreamClassPassThroughIrp;

    //
    // Allocate a driver object extension to contain the minidriver's
    // vectors.
    //

    Status = IoAllocateDriverObjectExtension(driverObject,
                                             (PVOID) StreamClassPnP,
                                             sizeof(MINIDRIVER_INFORMATION),
                                             &pMinidriverInfo);

    if (!NT_SUCCESS(Status)) {
        DebugPrint((DebugLevelError,
                    "StreamClassInitialize: No pool for global info"));
        SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_NO_GLOBAL_INFO_POOL, 0x1004);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(pMinidriverInfo, sizeof(MINIDRIVER_INFORMATION));

    RtlCopyMemory(pMinidriverInfo, HwInitializationData,
                  sizeof(HW_INITIALIZATION_DATA));

    #if ENABLE_MULTIPLE_FILTER_TYPES
    if ( HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20 ) {
        //
        // name extension not supplied.
        //
        pMinidriverInfo->HwInitData.NumNameExtensions = 0;
        pMinidriverInfo->HwInitData.NameExtensionArray = NULL;
    }

    else {
        //
        // ver20, should have filter extension size
        // 
        if ( 0 == pMinidriverInfo->HwInitData.FilterInstanceExtensionSize ) {
            DebugPrint((DebugLevelWarning, "Version 20 driver should not "
                        " have FilterInstanceExtensionSize 0" ));
            pMinidriverInfo->HwInitData.FilterInstanceExtensionSize = 4;
        }
    }
    #endif

    //
    // initialize the control event for this driver
    //

    KeInitializeEvent(&pMinidriverInfo->ControlEvent,
                      SynchronizationEvent,
                      TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
StreamClassPassThroughIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Pass through all Irps before being multiplexed through KS.  If the device
    cannot handle the request right now (the device is in a low power state
    like D3), queue the Irp and complete it later.

Arguments:

    DeviceObject -
        The device object

    Irp -
        The Irp in question

Return Value:

    Either STATUS_PENDING or per the KS multiplex

--*/

{

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
        DeviceObject -> DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Block user mode requests here in D3.  Queue kernel mode ones.
    //
    if (Irp -> RequestorMode == UserMode) {

        //
        // Only do this rigmarole if we look to be outside D0.
        //
        if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {

            //
            // Handle PowerDownUnopened cases specially since they don't
            // actually go into D0 until an instance is opened.  We cannot
            // block an open request in that case.
            //
            if (DeviceExtension -> RegistryFlags & 
                DEVICE_REG_FL_POWER_DOWN_CLOSED) {

                KIRQL OldIrql;

                KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

                if (DeviceExtension -> CurrentSystemState == 
                        PowerSystemWorking &&
                    DeviceExtension -> CurrentPowerState !=
                        PowerDeviceD0)  {

                    KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

                    //
                    // If we got here, the Irp must pass through as transition
                    // to D0 is keyed off it.
                    //
                    return KsDispatchIrp (DeviceObject, Irp);

                }

                KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

                //
                // At this point, we're not sleeping and not in SystemWorking.
                // We're safe to block.  Yes -- this might be an open -- and
                // yes -- we might transition to SystemWorking before the
                // KeWaitForSingleObject; however -- if that's the case, 
                // this **Notification** event will be signalled by that
                // transition and we don't block the D0 key Irp.
                //

            }

            ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

            //
            // At this point, it appeared that we weren't in D0.  Block this
            // thread until the device actually wakes.  It doesn't matter if
            // a state transition happened between the time we check and now
            // since this is a notification event.
            //
            KeWaitForSingleObject (
                &DeviceExtension -> BlockPoweredDownEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }

        return KsDispatchIrp (DeviceObject, Irp);
    
    }

    //
    // If we're in a low power state, queue the Irp and redispatch it later.
    //
    if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {
        //
        // Guard against PM changes while we're queueing the Irp.  I don't 
        // want to get pre-empted before adding it to the queue, redispatch
        // a bunch of Irps, and THEN have this one queued only to be lost
        // until the next power transition.
        //
        // As an optimization, only grab the spinlock when it looks like we
        // care.  I don't want to spinlock on every Irp.
        //
        KIRQL OldIrql;
        KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

        //
        // DEVICE_REG_FL_POWER_DOWN_CLOSED devices will not power up until
        // an open happens and they power down when not opened.  We cannot
        // queue creates on them unless they are not in D0 due to an actual
        // S-state transition.  This is guarded against racing with an 
        // S-state transition by the PowerLock spinlock.
        //  
        // NOTE: this will implicitly only allow creates to pass in non-D0
        // for these power down closed devices because the only way we are
        // in D3 / SystemWorking for these devices is when there are no opens
        // currently on the device.  Any Irp that comes through here at that
        // time will be a create.
        //
        if (DeviceExtension -> CurrentPowerState != PowerDeviceD0 &&
            !((DeviceExtension -> RegistryFlags & 
                    DEVICE_REG_FL_POWER_DOWN_CLOSED) &&
                DeviceExtension -> CurrentSystemState == PowerSystemWorking)) {
    
            IoMarkIrpPending (Irp);
    
            KsAddIrpToCancelableQueue (
                &DeviceExtension -> PendedIrps,
                &DeviceExtension -> PendedIrpsLock,
                Irp,
                KsListEntryTail,
                NULL
                );

            KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

            return STATUS_PENDING;

        }

        KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

    }

    return KsDispatchIrp (DeviceObject, Irp);

}

void
SCRedispatchPendedIrps (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN FailRequests
    )

/*++

Routine Description:

    Redispatch any Irps that were queued as a result of the device being
    unavailable.

Arguments:

    DeviceExtension -
        The device extension

    FailRequests -
        Indication of whether to fail the requests or redispatch them
        to the device.

Return Value:

    None

--*/

{

    PIRP Irp;

    //
    // If we redispatch for any reason, allow Irps through.
    //
    KeSetEvent (
        &DeviceExtension -> BlockPoweredDownEvent, 
        IO_NO_INCREMENT, 
        FALSE
        );

    Irp = KsRemoveIrpFromCancelableQueue (
        &DeviceExtension -> PendedIrps,
        &DeviceExtension -> PendedIrpsLock,
        KsListEntryHead,
        KsAcquireAndRemove
        );

    while (Irp) {
        //
        // If we were to fail the requests instead of redispatching, do
        // this for everything but close Irps.
        //
        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
        if (FailRequests &&
            IrpSp -> MajorFunction != IRP_MJ_CLOSE) {

            Irp -> IoStatus.Status = STATUS_DEVICE_BUSY;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        }
        else {
            KsDispatchIrp (DeviceExtension -> DeviceObject, Irp);
        }

        Irp = KsRemoveIrpFromCancelableQueue (
            &DeviceExtension -> PendedIrps,
            &DeviceExtension -> PendedIrpsLock,
            KsListEntryHead,
            KsAcquireAndRemove
            );

    }

}

void
SCSetCurrentDPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN DEVICE_POWER_STATE PowerState
    )

{
    KIRQL OldIrql;

    KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);
    //
    // On any transition out of D0, block user mode requests until we're back
    // in D0.
    //
    if (PowerState != PowerDeviceD0) {
        KeResetEvent (&DeviceExtension->BlockPoweredDownEvent);
    }
    DeviceExtension->CurrentPowerState = PowerState;
    KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);
}

void
SCSetCurrentSPowerState (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN SYSTEM_POWER_STATE PowerState
    )

{
    KIRQL OldIrql;

    KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);
    DeviceExtension->CurrentSystemState = PowerState;
    KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);

}

NTSTATUS
StreamClassPnPAddDevice(
                        IN PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject
)
/*++

Routine Description:

    This routine is called to create a new instance of the streaming minidriver

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

Return Value:

    Returns status of the worker routine.

--*/

{

    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    //
    // call the worker routine and return its status
    //

    return (StreamClassPnPAddDeviceWorker(DriverObject,
                                          PhysicalDeviceObject,
                                          &DeviceExtension));
}

NTSTATUS
StreamClassPnPAddDeviceWorker(
                              IN PDRIVER_OBJECT DriverObject,
                              IN PDEVICE_OBJECT PhysicalDeviceObject,
                          IN OUT PDEVICE_EXTENSION * ReturnedDeviceExtension
)
/*++

Routine Description:

    This routine is the worker for processing the PNP add device call.

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

    ReturnedDeviceExtension - pointer to the minidriver's extension

Return Value:

    Status is returned.

--*/

{
    PMINIDRIVER_INFORMATION pMinidriverInfo;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    PDEVICE_OBJECT  DeviceObject,
                    AttachedPdo;

    PAGED_CODE();

    DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: enter\n"));

    pMinidriverInfo = IoGetDriverObjectExtension(DriverObject,
                                                 (PVOID) StreamClassPnP);


    if (pMinidriverInfo == NULL) {
        DebugPrint((DebugLevelError,
                    "StreamClassAddDevice: No minidriver info"));
                    
        SCLogError((PDEVICE_OBJECT) DriverObject, 0, CODCLASS_NO_MINIDRIVER_INFO, 0x1004);
        return (STATUS_DEVICE_DOES_NOT_EXIST);
    }
    //
    // bump the add count in the minidriver object
    //

    pMinidriverInfo->OpenCount++;

    //
    // Create our device object with a our STREAM specific device extension
    // No need to name it thanks to Plug N Play.
    //

    Status = IoCreateDevice(
                            DriverObject,
                            sizeof(DEVICE_EXTENSION) +
                            pMinidriverInfo->HwInitData.DeviceExtensionSize,
                            NULL,
                            FILE_DEVICE_KS,
                            FILE_AUTOGENERATED_DEVICE_NAME,
                            FALSE,
                            &DeviceObject
        );

    if (!NT_SUCCESS(Status)) {

        return (Status);

    }
    //
    // Attach ourself into the driver stack on top of our parent.
    //

    AttachedPdo = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

    if (!(AttachedPdo)) {

        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelFatal, "StreamClassAddDevice: could not attach"));
        IoDeleteDevice(DeviceObject);
        return (Status);

    }
    *ReturnedDeviceExtension = DeviceExtension = DeviceObject->DeviceExtension;

    (*ReturnedDeviceExtension)->Signature = SIGN_DEVICE_EXTENSION;
    (*ReturnedDeviceExtension)->Signature2 = SIGN_DEVICE_EXTENSION;

    //
    // set the minidriver info in the device extension
    //

    DeviceExtension->AttachedPdo = AttachedPdo;

    //
    // set the I/O counter
    //

    DeviceExtension->OneBasedIoCount = 1;

    DeviceExtension->DriverInfo = pMinidriverInfo;

    //
    // Initialize timer.
    //

    IoInitializeTimer(DeviceObject, StreamClassTickHandler, NULL);

    ///
    /// move from start device, we could have child PDO if we start and stop
    ///
    InitializeListHead(&DeviceExtension->Children);
       
    //
    // Moved from StartDevice. We use the control event at Remove_device
    // which can come in before the device starts.
    //
    KeInitializeEvent(&DeviceExtension->ControlEvent,
                      SynchronizationEvent,
                      TRUE);

    //
    // set the current power state to D0
    //

    DeviceExtension->CurrentPowerState = PowerDeviceD0;
    DeviceExtension->CurrentSystemState = PowerSystemWorking;

    //
    // fill in the minidriver info pointer to the dev extension
    //

    DeviceExtension->MinidriverData = pMinidriverInfo;

    //
    // keep this handy
    //
    DeviceExtension->FilterExtensionSize = 
        pMinidriverInfo->HwInitData.FilterInstanceExtensionSize;

    DeviceExtension->DeviceObject = DeviceObject;
    DeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    DeviceExtension->HwDeviceExtension = (PVOID) (DeviceExtension + 1);

    //
    // Initialize the pended Irp list.
    //
    InitializeListHead (&DeviceExtension -> PendedIrps);
    KeInitializeSpinLock (&DeviceExtension -> PendedIrpsLock);
    KeInitializeSpinLock (&DeviceExtension -> PowerLock);
    KeInitializeEvent (&DeviceExtension -> BlockPoweredDownEvent, NotificationEvent, TRUE);

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in read/write irps.
    //

    DeviceObject->Flags |= DO_DIRECT_IO;

    {
		PKSOBJECT_CREATE_ITEM 	pCreateItems;
		PWCHAR					*NameInfo;
		ULONG					i;
		ULONG                   NumberOfFilterTypes;
		PFILTER_TYPE_INFO FilterTypeInfo;
	    //
    	// build an on-the-fly table of name extensions (including "GLOBAL"),
    	// from the minidriver's table.
    	//

        InitializeListHead( &DeviceExtension->FilterInstanceList );
        
        NumberOfFilterTypes = pMinidriverInfo->HwInitData.NumNameExtensions;
        DeviceExtension->NumberOfNameExtensions = NumberOfFilterTypes;
        if ( 0 == NumberOfFilterTypes ) {
            NumberOfFilterTypes = 1;
        }

        DebugPrint((DebugLevelVerbose,
                   "Sizeof(FILTER_TYPE_INFO)=%x\n",
                   sizeof(FILTER_TYPE_INFO)));
                   
    	FilterTypeInfo = ExAllocatePool(NonPagedPool, 
                                   (sizeof(FILTER_TYPE_INFO) +
                                    sizeof(KSOBJECT_CREATE_ITEM))*
                                    NumberOfFilterTypes);

	    if (!(FilterTypeInfo)) {

    	    DebugPrint((DebugLevelFatal, 
    	               "StreamClassAddDevice: could not alloc createitems"));
	        TRAP;
    	    IoDetachDevice(DeviceExtension->AttachedPdo);
	        IoDeleteDevice(DeviceObject);
	        return (Status);
    	}

    	pCreateItems = (PKSOBJECT_CREATE_ITEM)(FilterTypeInfo+NumberOfFilterTypes);

        DebugPrint((DebugLevelVerbose,
                   "FilterTypeInfo@%x,pCreateItems@%x\n",
                   FilterTypeInfo,pCreateItems ));        


        DeviceExtension->NumberOfFilterTypes = NumberOfFilterTypes;
    	DeviceExtension->FilterTypeInfos = FilterTypeInfo;

	    //
	    // first copy the single default create item.   
	    //
	    ASSERT( sizeof(CreateItems) == sizeof(KSOBJECT_CREATE_ITEM));

	    RtlCopyMemory(pCreateItems, CreateItems, sizeof (KSOBJECT_CREATE_ITEM));

	    //
	    // now construct the rest of the table based on the minidriver's values.
	    //

	    NameInfo = pMinidriverInfo->HwInitData.NameExtensionArray;

	    for (i = 0; 
    	     i < DeviceExtension->NumberOfNameExtensions; 
        	 i++, NameInfo++) {

        	 LONG StringLength;
                  
	         StringLength = wcslen(*NameInfo)*sizeof(WCHAR);

    	     pCreateItems[i].ObjectClass.Length = (USHORT)StringLength;
	         pCreateItems[i].ObjectClass.MaximumLength = (USHORT)(StringLength + sizeof(UNICODE_NULL));
    	     pCreateItems[i].ObjectClass.Buffer = *NameInfo;
        	 pCreateItems[i].Create = FilterDispatchGlobalCreate;        
	         pCreateItems[i].Context = ULongToPtr(i);
	         pCreateItems[i].SecurityDescriptor = NULL;
	         pCreateItems[i].Flags = 0;

	    } // for # createitems
	    DeviceExtension->CreateItems = pCreateItems;
	    KsAllocateDeviceHeader(&DeviceExtension->ComObj.DeviceHeader,
                           i+1,
                           (PKSOBJECT_CREATE_ITEM) pCreateItems);

    }

    //
    // set the flag indicating whether we need to do synchronization.
    //

    DeviceExtension->NoSync =
        pMinidriverInfo->HwInitData.TurnOffSynchronization;

    //
    // presuppose we will need synchronization.
    //

    #if DBG
    DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
    #else
    DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
    #endif

    //
    // set the synchronized minidriver callin routine vectors
    //

    DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginSynchronizedMinidriverCallin;
    DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndSynchronizedMinidriverDeviceCallin;
    DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndSynchronizedMinidriverStreamCallin;

    if (DeviceExtension->NoSync) {

        //
        // we won't do synchronization, so use the dummy sync routine.
        //

        DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
        DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

        //
        // set the unsynchronized minidriver callin routine vectors
        //


        DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginUnsynchronizedMinidriverCallin;
        DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndUnsynchronizedMinidriverDeviceCallin;
        DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndUnsynchronizedMinidriverStreamCallin;

    }
    //
    // read registry settings for this adapter
    //

    SCReadRegistryValues(DeviceExtension, PhysicalDeviceObject);

    //
    // if the device cannot be paged out when closed, turn off this feature
    // for the whole driver
    //

    if (!(DeviceExtension->RegistryFlags & DEVICE_REG_FL_PAGE_CLOSED)) {

        pMinidriverInfo->Flags |= DRIVER_FLAGS_NO_PAGEOUT;
    }
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    DeviceObject->Flags |= DO_POWER_PAGABLE;

    DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: leave\n"));

    return (STATUS_SUCCESS);

}

NTSTATUS
StreamClassPnP(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
)
/*++

Routine Description:

    This routine processes the various Plug N Play messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    NTSTATUS        Status;
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack,
                    NextStack;
    BOOLEAN         RequestIssued;
    DEVICE_CAPABILITIES DeviceCapabilities;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // check to see if the device is a child
    //
    
	DebugPrint((DebugLevelVerbose, "'SCPNP:DevObj=%x,Irp=%x\n",DeviceObject, Irp ));
	
    if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

        PCHILD_DEVICE_EXTENSION ChildExtension = (PCHILD_DEVICE_EXTENSION) DeviceExtension;

        switch (IrpStack->MinorFunction) {

        case IRP_MN_QUERY_INTERFACE:

            IoCopyCurrentIrpStackLocationToNext( Irp );

            DebugPrint((DebugLevelInfo, 
                       "Child PDO=%x forwards Query_Interface to Parent FDO=%x\n",
                       DeviceObject,
                       ChildExtension->ParentDeviceObject));
            
            return (IoCallDriver(ChildExtension->ParentDeviceObject,
                                 Irp));

        case IRP_MN_START_DEVICE:
        	DebugPrint((DebugLevelInfo,
        	            "StartChild DevObj=%x Flags=%x\n" 
        	            ,DeviceObject,
        	            ChildExtension->Flags ));
            ChildExtension->Flags &= ~DEVICE_FLAGS_CHILD_MARK_DELETE;
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            if (IrpStack->Parameters.QueryDeviceRelations.Type ==
                TargetDeviceRelation) {

                PDEVICE_RELATIONS DeviceRelations = NULL;

                DeviceRelations = ExAllocatePool(PagedPool, sizeof(*DeviceRelations));

                if (DeviceRelations == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    //
                    // TargetDeviceRelation reported PDOs need to be ref'ed.
                    // PNP will deref this later.
                    //
                    ObReferenceObject(DeviceObject);
                    DeviceRelations->Count = 1;
                    DeviceRelations->Objects[0] = DeviceObject;
                    Status = STATUS_SUCCESS;
                }

                Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

            } else {
                Status = Irp->IoStatus.Status;
            }

            goto done;

        case IRP_MN_REMOVE_DEVICE:

            DEBUG_BREAKPOINT();

            DebugPrint((DebugLevelInfo,
                        "Child PDO %x receives REMOVE\n",
                        DeviceObject ));

            //
            // remove this extension from the list.
            // This is true - pierre tells me that PNP won't reenter me.  Verify
            // that this is true on NT also.
            //
            //
            // When a PDO first receives this msg, it is usually forwarded
            // from FDO. We can't just delete this PDO, but mark it delete
            // pending.
            //

            if ( !(ChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE )) {
                Status = STATUS_SUCCESS;
                goto done;
            }
            
	        RemoveEntryList(&ChildExtension->ChildExtensionList);

	        //
    	    // free the device name string if it exists.
        	//

	        if (ChildExtension->DeviceName) {

	            ExFreePool(ChildExtension->DeviceName);
    	    }

	        //
    	    // delete the PDO
        	//

	        IoDeleteDevice(DeviceObject);

            Status = STATUS_SUCCESS;

            goto done;

        case IRP_MN_QUERY_CAPABILITIES:

            Status = SCEnumGetCaps(ChildExtension,
                      IrpStack->Parameters.DeviceCapabilities.Capabilities);
            goto done;

        case IRP_MN_QUERY_ID:

            //
            // process the ID query for the child devnode.
            //

            Status = SCQueryEnumId(DeviceObject,
                                   IrpStack->Parameters.QueryId.IdType,
                                   (PWSTR *) & (Irp->IoStatus.Information));
            goto done;

        default:
            Status = STATUS_NOT_IMPLEMENTED;

    done:

            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (Status);

        }                       // switch
    }                           // if child
    //
    // this is not a child device.  do adult processing
    //

    HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);

    //
    // show one more I/O pending
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    switch (IrpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Start Device %x\n",
                    DeviceObject));

        //
        // reinitialize the minidriver's device extension.   This is
        // necessary as we may receive a start before a remove, such as in
        // the case of a PNP rebalance.
        //

        RtlZeroMemory(DeviceExtension->HwDeviceExtension,
               DeviceExtension->DriverInfo->HwInitData.DeviceExtensionSize);

        //
        // clear the inaccessible flag since we may have stopped the
        // device previously.
        //

        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // The START message gets passed to the PhysicalDeviceObject
        // we were give in PnPAddDevice, so call 'er down first.
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // get the capabilities of our parent.   This info is used for
        // controlling the system power state.
        //

        Status = SCQueryCapabilities(DeviceExtension->AttachedPdo,
                                     &DeviceCapabilities);

        ASSERT(NT_SUCCESS(Status));

        //
        // copy the device state info into the device extension.
        //

        if (NT_SUCCESS(Status)) {

            RtlCopyMemory(&DeviceExtension->DeviceState[0],
                          &DeviceCapabilities.DeviceState[0],
                          sizeof(DeviceExtension->DeviceState));

        }                       // if query succeeded
        //
        // call the worker routine to complete the start processing.
        // this routine completes the IRP.
        //

        Status = SCStartWorker(Irp);

        //
        // dereference the minidriver which will page it out if possible.
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);


    case IRP_MN_QUERY_DEVICE_RELATIONS:


        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Relations %x\n",
                   DeviceObject));
                   
        switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            //
            // just call the next driver and fall thru, since we're being
            // called for the FDO of a PDO for which we are not the parent.
            //

            Status = SCCallNextDriver(DeviceExtension, Irp);
            break;

        case BusRelations:

            //
            // invoke routine to enumerate any child devices
            //

            Status = SCEnumerateChildren(DeviceObject,
                                         Irp);
            break;


        default:
            //
            // pass down unmodified irp. see bug 282915.
            //
            Status = SCCallNextDriver(DeviceExtension, Irp);

        }                       // switch

        SCDereferenceDriver(DeviceExtension);
        return (SCCompleteIrp(Irp, Status, DeviceExtension));

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // According to DDK, QUERY_STOP and QUERY_REMOVE
        // requeire very different repsonses. It's not best to
        // handle by the same code, if not erroneous.
        //
        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Stop %x\n",
                   DeviceObject));

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Performace improvement chance: The ControlEvent should be init in AddDevice, so 
        // that we don't need a check here. This check is not an optimal
        // fix for 283057. Refix it and the same in Query_Remove.
        //
        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        }
        
        //
        // Refer to DDK.
        //   We must fail a query_stop if any of the following is true. 
        //      a. we are notified with IRP_MN_DEVICE_USAGE_NOTIFICATION
        //          that the device is in the path of a paging, hiberation
        //          or crash dump file.
        //      b. The device's hardware resources cannot be released.
        //
        // Assuming we are not in the paging path for a. For b, we will
        // pass this Irp down to the mini driver to let it have a say.
        // We will not reject the Query just because of outstanding opens.
        // 

        //DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // calldown to next driver will be done in the callback.
        //
        //Status = SCSendUnknownCommand(Irp,
        //                              DeviceExtension,
        //                              SCPNPQueryCallback,
        //                              &RequestIssued);

        //
        // However, to achieve the noble goal, as everything stands now, is opening
        // a whole can of worms. I will keep this old behavior that existed 
        // since win98. The bug OSR4.1 #98132 said to be a regression is completely
        // false. This code is in win98 and win2k. And I have set up win98 to repro
        // this behavior to disapprove the regression claim.
        // 

        if (DeviceExtension->NumberOfOpenInstances == 0) {

            //
            // if there are no open instances, there can be no outstanding
            // I/O, so mark the device as going away.
            //


            DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

            SCCallNextDriver(DeviceExtension, Irp);

            //
            // call the worker routine to complete the query processing.
            // this routine calls back the IRP.
            //

            Status = SCQueryWorker(DeviceObject, Irp);

        } else {

            //
            // the device is open.  fail the query.
            //

            Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);

        }


        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        }
        //
        // show one fewer reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);
        
    case IRP_MN_QUERY_REMOVE_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Remove %x\n",
                   DeviceObject));

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);

        }
        
        //
        // According DDK, if there are opens that can't be closed
        // we must fail the query.
        // So, if there are opened files, just fail the query.
        //
        if (DeviceExtension->NumberOfOpenInstances == 0) {

            //
            // if there are no open instances, there can be no outstanding
            // I/O, so mark the device as going away.
            //


            DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

            SCCallNextDriver(DeviceExtension, Irp);

            //
            // call the worker routine to complete the query processing.
            // this routine calls back the IRP.
            //

            Status = SCQueryWorker(DeviceObject, Irp);

        } else {

            //
            // the device is open.  fail the query.
            //

            Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);

        }

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
        {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        }
        //
        // show one fewer reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // clear the inaccessible flag and call'er down
        //

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_CANCEL_REMOVE %x\n",
                   DeviceObject));
                   
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // call next driver
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver which will page out if possible.
        //

        SCDereferenceDriver(DeviceExtension);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

    case IRP_MN_CANCEL_STOP_DEVICE:

        //
        // clear the inaccessible flag and call'er down
        //

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_CANCEL_STOP %x\n",
                   DeviceObject));
                   
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        //
        // call next driver
        //

        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver which will page out if possible.
        //

        SCDereferenceDriver(DeviceExtension);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

        break;

    case IRP_MN_STOP_DEVICE:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_STOP_DEVICE %x\n",
                   DeviceObject));

        //
        // presuppose good status.  if we have actually started the device,
        // stop it now.
        //

        Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

            //
            // call routine to uninitialize minidriver
            //

            Status = SCUninitializeMinidriver(DeviceObject, Irp);

            //
            // now call the next driver in the stack with the IRP, which will
            // determine the final status.
            //

        }                       // if started
        if (NT_SUCCESS(Status)) {
            Status = SCCallNextDriver(DeviceExtension, Irp);
        }

        //
        // Fail everything that's been queued.
        //
        SCRedispatchPendedIrps (DeviceExtension, TRUE);

        //
        // call routine to complete the IRP
        //

        SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // show one less reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    case IRP_MN_REMOVE_DEVICE:

        DebugPrint((DebugLevelInfo, 
                    "StreamClassPnP: MN_REMOVE_DEVICE %x\n",
                    DeviceObject));

        //
        // handle a "suprise" style removal if we have not been stopped.
        // set success status in case we have already stopped.
        //

        Status = STATUS_SUCCESS;

        if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {
            
            SCSendSurpriseNotification(DeviceExtension, Irp);

            Status = SCUninitializeMinidriver(DeviceObject, Irp);

        }
        
        if (NT_SUCCESS(Status)) {

            Status = SCCallNextDriver(DeviceExtension, Irp);
        }

        //
        // Fail any pended Irps.
        //
        SCRedispatchPendedIrps (DeviceExtension, TRUE);

        //
        // call routine to complete the IRP
        //

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);

        if (NT_SUCCESS(Status)) {

            //
            // free the device header.
            //

            if ( NULL != DeviceExtension->ComObj.DeviceHeader ) {
                KsFreeDeviceHeader(DeviceExtension->ComObj.DeviceHeader);
            }

            //
            // take the event to avoid race
            //

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            //
            // detach from the PDO now if the opened file count is zero.
            //

            if (DeviceExtension->NumberOfOpenInstances == 0) {

                DebugPrint((DebugLevelInfo,
                            "SCPNP: detaching %x from %x\n",
                            DeviceObject,
                            DeviceExtension->AttachedPdo));

                if ( NULL != DeviceExtension->AttachedPdo ) {
                    //
                    // detach could happen at close, check before leap.
                    // event is taken, check is safe.
                    //
                    IoDetachDevice(DeviceExtension->AttachedPdo);
                    DeviceExtension->AttachedPdo = NULL;
                }
                
                ///
                /// mark child pdos if any
                ///
                {
                    PLIST_ENTRY Node;
                    PCHILD_DEVICE_EXTENSION ChildExtension;
                
                    while (!IsListEmpty( &DeviceExtension->Children )) {
                        Node = RemoveHeadList( &DeviceExtension->Children );
                        ChildExtension = CONTAINING_RECORD(Node,
                                                       CHILD_DEVICE_EXTENSION,
                                                       ChildExtensionList);  
                        DebugPrint((DebugLevelInfo, 
                                "Marking and delete childpdo Extension %p\n",
                                ChildExtension));
      
                        ChildExtension->Flags |= DEVICE_FLAGS_CHILD_MARK_DELETE;
                        IoDeleteDevice(ChildExtension->ChildDeviceObject);
                    }                
                }            
            }
            
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // delete the device
            //
            
            // A dev could be stop and start. Free stuff allocated
            // at AddDevice.
            // FilterTypeInfos includes FilterTypeInfos CreateItems.
            // Free these here at remove_device
    	    if (  DeviceExtension->FilterTypeInfos ) {
                ExFreePool( DeviceExtension->FilterTypeInfos );    	        
                DeviceExtension->FilterTypeInfos = NULL;
                DeviceExtension->CreateItems = NULL;
            }
            
            IoDeleteDevice(DeviceExtension->DeviceObject);
        }
        return (Status);

    case IRP_MN_SURPRISE_REMOVAL:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPnP: MN_SURPRISE_REMOVAL %x\n",
                   DeviceObject));

        //
        // handle a "suprise" style removal if we have not been stopped.
        // set success status in case we have already stopped.
        //

        Status = STATUS_SUCCESS;

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {
                                  
            SCSendSurpriseNotification(DeviceExtension, Irp);
            Status = SCUninitializeMinidriver(DeviceObject, Irp);
        }
        
        //
        // forward the surprise removal IRP to the next layer, regardless of
        // our status.
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        //
        // call routine to complete the IRP
        //

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);

        //
        // indicate that we received an "NT style" surprise removal
        // notification
        // so that we won't do the "memphis style" behavior on filter close.
        //

        DeviceExtension->Flags |= DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED;

        return (Status);

    case IRP_MN_QUERY_CAPABILITIES:

        DebugPrint((DebugLevelInfo, 
                   "StreamClassPNP: Query Caps\n",
                   DeviceObject));

        //
        // indicate that suprise removal is OK after calling request down
        // to next level.
        //

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Status = SCCallNextDriver(DeviceExtension, Irp);

        IrpStack->Parameters.DeviceCapabilities.
            Capabilities->SurpriseRemovalOK = TRUE;

        Status = SCCompleteIrp(Irp, Status, DeviceExtension);

        //
        // show one less reference to driver.
        //

        SCDereferenceDriver(DeviceExtension);

        return (Status);

    default:

        DebugPrint((DebugLevelInfo, 
                   "StreamPnP: unknown function\n",
                   DeviceObject));

        if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

            //
            // unknown function, so call it down to the minidriver as such.
            // this routine completes the IRP if we are able to issue the
            // request.
            //

            Status = SCSendUnknownCommand(Irp,
                                          DeviceExtension,
                                          SCUnknownPNPCallback,
                                          &RequestIssued);

            if (!RequestIssued) {
                //
                // could not send the unknown command down.  show one fewer
                // I/O
                // pending and fall thru to generic handler.
                //

                DEBUG_BREAKPOINT();
                Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
            }            
        } 

        else {

            //
            // call next driver
            //

            Status = SCCallNextDriver(DeviceExtension, Irp);

            SCCompleteIrp(Irp, Status, DeviceExtension);

        }                       // if started

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);

    }

}

NTSTATUS
StreamClassCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    TODO: Remove this once KS can multiplex CLEANUP Irps.

    Manual multiplex of cleanup Irps.  Note that FsContext is NOT NECESSARILY
    OURS.  The cookie check is done to check for streams until KS handles
    this correctly.

Arguments:

    DeviceObject -
        The device object

    Irp -
        The CLEANUP irp

Return Value:

    The Irp return code set appropriately.

--*/

{

    PIO_STACK_LOCATION IoStack = IoGetCurrentIrpStackLocation (Irp);
    PCOOKIE_CHECK CookieCheck = 
        (PCOOKIE_CHECK) IoStack -> FileObject -> FsContext;

    //
    // Check for the cookie.  If it's not there or the context is not there,
    // bail.
    //
    if (CookieCheck &&
        CookieCheck -> PossibleCookie == STREAM_OBJECT_COOKIE) {

        return StreamDispatchCleanup (DeviceObject, Irp);

    }

    Irp -> IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;

}

NTSTATUS
SciQuerySystemPowerHiberCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown Power command for query system hiber

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB since we are done with it
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }

    if ( STATUS_NOT_SUPPORTED == MiniStatus ) {

        //
        // not surprising, old driver doesn't handle this.
        //

        if ( 0 != (DeviceExtension->RegistryFlags &
                   DRIVER_USES_SWENUM_TO_LOAD )  || 
             0 != (DeviceExtension->RegistryFlags &
                   DEVICE_REG_FL_OK_TO_HIBERNATE ) ) {
                              
            //
            // default for swenum driver is OK to hiber
            // No hiber for other drivers unless explicitly
            // say so in the registry
            //

            DebugPrint((DebugLevelInfo, 
                        "%ws Allow hibernation!\n",
                        DeviceExtension->DeviceObject->
                        DriverObject->DriverName.Buffer));
            MiniStatus = STATUS_SUCCESS;
        }

        else {

            //
            // for others, disallow
            //
            
            DebugPrint((DebugLevelInfo, 
                        "%ws Disallow hibernation!\n",
                        DeviceExtension->DeviceObject->
                        DriverObject->DriverName.Buffer));
            MiniStatus = STATUS_DEVICE_BUSY;
        }
    }
    
    if ( NT_SUCCESS( MiniStatus )) {

        //
        // it is not explicitly failed by the mini driver pass down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);
        if ( Status == STATUS_NOT_SUPPORTED ) {
        
            //
            // no one below knows/cares. Use our mini status
            //
            
            Status = MiniStatus;
        }
    }

    else {
    
        //
        // mini driver explicitly failed this
        //
        
        Status = MiniStatus;
    }
    
    //
    // complete the IRP with the final status
    //

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCSysWakeCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

    This is called when we receive a wake up system Irp which we can't not block. 
    If we block, the lower driver might queue this Irp ( such as acpi ) and the
    po system could be dead locked. In theory, we should complete the requested
    D Irp and use the status as the status for the SWake Irp. In practise, we can
    just send down this Irp assuming all is well. In the unlikely condition, the SWake
    Irp was unsuccessful, the D Irp will fail. But there is really nothing we can 
    improve or nothing will get worse.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    NTSTATUS        Status;

    //
    // call down and be done with this SWake Irp; the D Irp completion routine
    // should not complete this SWake Irp.
    //
    
    PoStartNextPowerIrp( Irp );
    IoSkipCurrentIrpStackLocation( Irp );
    Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

    //
    // If we get an error, we complete this S irp in the caller with the error.
    //
    
    return (Status);
}

VOID
SCDevIrpCompletionWorker(
    PIRP pIrp
)
/*++

    Description:

        This is the worker routine for Device Power Wakeup Irp which schedule
        a workitem to continue the work at the Irp on its way up. We
        need to schedule this work because the completion routine could be called at
        DISPATCH_LEVEL. We schedule the workitem so we can safely take 
        control event and call to our mini driver.
        IRQL < DISPATCH_LEVEL
        

    Parameter:

        pIrp: the original Irp which we have marked MORE_PROCEESING_REQUIRED.
             We will complete it after we call our mini driver.

    Return: 

        None.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(pIrp);
    PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;
    BOOLEAN         RequestIssued;
    NTSTATUS Status;

    
    PAGED_CODE();
    
    //
    // take the event to avoid race
    //    

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,    // not alertable
                          NULL);

    //
    // send a set power SRB to the device.
    // additional processing will be done by the callback
    // procedure.  This routine completes the IRP if it is able
    // to issue the request.
    //

    Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
                              (PVOID) PowerDeviceD0,
                              0,
                              SCPowerCallback,
                              DeviceExtension,
                              NULL,
                              NULL,
                              pIrp,
                              &RequestIssued,
                              &DeviceExtension->PendingQueue,
                              (PVOID) DeviceExtension->
                              MinidriverData->HwInitData.
                              HwReceivePacket );


    if (!RequestIssued) {

        //
        // If we fail to issue SRB, the SCPowerCallback won't happen which is
        // supposed to call PoStartNextPowerIrp().
        // We need to call PoStartNextPowerIrp() here;
        //
        PoStartNextPowerIrp( pIrp );
        Status = SCCompleteIrp(pIrp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
    }

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    //
    // Redispatch any Irps pended because of lower power states.
    //
    SCRedispatchPendedIrps (DeviceExtension, FALSE);

    //
    // show one fewer reference to driver.
    //

    SCDereferenceDriver(DeviceExtension);
    return;
}


NTSTATUS 
SCDevWakeCompletionRoutine(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PVOID pContext
)
/*++

Routine Description:

    This routine is for Device wakeup Irp completion.
    We sent it to NextDeviceObject first. Now this is back.
    We process out work for the mini driver. We might be called
    at Dispatch_LEVEL.

    IRQL <= DISPATCH_LEVEL

Arguments:

    DriverObject - Pointer to driver object created by system.
    Irp - Irp that just completed
    pContext - the context

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Schedule a work item in case we are called at DISPATCH_LEVEL
    // note that we can use a global Devcice Power item since we have 
    // not yet issued the PoNextPowerIrp call which is called at the callback
    // of the power Srb
    //

    ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                         SCDevIrpCompletionWorker,
                         Irp);

    ExQueueWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                    DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SCDevWakeCallNextDriver(
                 IN PDEVICE_EXTENSION DeviceExtension,
                 IN PIRP Irp
)
/*++

Routine Description:

    Receive device wake up Irp. Need to send down the Irp 1st.
    Also this can't be synchronous. We could dead lock, if we do this
    synchronously. Send it down without waiting. Process it when it compltes
    back to us.

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    NTSTATUS        Status;

    IoCopyCurrentIrpStackLocationToNext( Irp );
    
    IoSetCompletionRoutine(Irp,
                           SCDevWakeCompletionRoutine,
                           NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // We are to schedule a workitem to complete the work
    // in the completion routin. Mark the Irp pending
    //
    IoMarkIrpPending( Irp );
    
    Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

    ASSERT( NT_SUCCESS( Status ));
    return STATUS_PENDING;
}


NTSTATUS
StreamClassPower(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
)
/*++

Routine Description:

    This routine processes the various Plug N Play messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    NTSTATUS        Status;
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

        switch (IrpStack->MinorFunction) {

        default:
            PoStartNextPowerIrp( Irp ); // shut down would bugcheck w/o this
            Status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (Status);

        }
    }                           // if child
    //
    // if the device is stopped, just call the power message down to the next
    // level.
    //

    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

        Status = SCCallNextDriver(DeviceExtension, Irp);
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (Status);
    }                           // if inaccessible
    HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);

    //
    // show one more I/O pending
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    switch (IrpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        switch (IrpStack->Parameters.Power.Type) {

        case SystemPowerState:

            DebugPrint((DebugLevelInfo, 
                        "Query_power S[%d]\n",
                        IrpStack->Parameters.Power.State.SystemState));            

            //
            // some minidrivers want to not suspend if their pins are in
            // the RUN state.   check for this case.
            //

            DebugPrint((DebugLevelInfo,
                       "POWER Query_Power DevObj %x RegFlags=%x SysState=%x\n",
                       DeviceObject,
                       DeviceExtension->RegistryFlags,
                       IrpStack->Parameters.Power.State.SystemState));

            #ifdef WIN9X_STREAM

            if ( PowerSystemHibernate == 
                 IrpStack->Parameters.Power.State.SystemState ) {
                 
                //
                // Power query to hibernation state. Many existing drivers
                // are hibernation unaware. We will reject this query. Or
                // drivers' devices woken up from hiber will be in un-init
                // state. Some drivers would fault. Lucky others do not but
                // would not work. For less of the evil, we try to protect
                // the system by rejecting the hibernation. Note though, this
                // chance to reject is not available with forced ( low battery
                // or user force ) hibernation.
                //
                //
                // unknown function, so call it down to the minidriver as such.
                // this routine completes the IRP if it is able to issue the request.
                //
                
                Status = SCSendUnknownCommand(Irp,
                                              DeviceExtension,
                                              SciQuerySystemPowerHiberCallback,
                                              &RequestIssued);

                if (!RequestIssued) {
                
                    //
                    // could not send the unknown command down.  show one fewer I/O
                    // pending and fall thru to generic handler.
                    //
                    
                    PoStartNextPowerIrp(Irp);
                    Status = SCCompleteIrp(Irp, 
                                           STATUS_INSUFFICIENT_RESOURCES, 
                                           DeviceExtension);
                }
                
                //
                // dereference the driver
                //

                SCDereferenceDriver(DeviceExtension);
                return Status;
            } else 

            #endif //WIN9X_STREAM

            if (DeviceExtension->RegistryFlags &
                DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING) {


                PFILTER_INSTANCE FilterInstance;
                KIRQL           Irql;
                PLIST_ENTRY     FilterEntry,
                                FilterListHead;

                KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
                
                FilterListHead = FilterEntry = &DeviceExtension->FilterInstanceList;

                while (FilterEntry->Flink != FilterListHead) {

                    FilterEntry = FilterEntry->Flink;

                    //
                    // follow the link to the instance
                    //

                    FilterInstance = CONTAINING_RECORD(FilterEntry,
                                                       FILTER_INSTANCE,
                                                       NextFilterInstance);


                    if (SCCheckIfStreamsRunning(FilterInstance)) {

                        DebugPrint((DebugLevelInfo, 
                                    "POWER Query_Power FilterInstance %x busy\n",
                                    FilterInstance ));
                                    
                        Status = STATUS_DEVICE_BUSY;
                        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
                        goto QuerySystemSuspendDone;
                    }           // if streams running
                    //
                    // get the list entry for the next instance
                    //

                    FilterEntry = &FilterInstance->NextFilterInstance;

                }               // while local filter instances

                KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

            }                   // if no suspend if running
            Status = SCCallNextDriver(DeviceExtension, Irp);


    QuerySystemSuspendDone:

            //
            // indicate we're ready for next power irp
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (SCCompleteIrp(Irp, Status, DeviceExtension));

        case DevicePowerState:

            switch (IrpStack->Parameters.Power.State.DeviceState) {

            default:
            case PowerDeviceD2:
            case PowerDeviceD3:

                //
                // check to see if the device is opened.
                //
                if (!DeviceExtension->NumberOfOpenInstances) {

                    //
                    // show pending status and call next driver without a
                    // completion
                    // handler
                    //
                    Status = SCCallNextDriver(DeviceExtension, Irp);

                } else {

                    //
                    // the device is opened.  Don't do the power down.
                    //
                    Status = STATUS_DEVICE_BUSY;
                }

                PoStartNextPowerIrp(Irp);

                //
                // show one fewer reference to driver.
                //

                SCDereferenceDriver(DeviceExtension);

                return (SCCompleteIrp(Irp, Status, DeviceExtension));
            }

        default:

            //
            // unknown power type: indicate we're ready for next power irp
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceExtension));



        }                       // switch minorfunc
        break;

    case IRP_MN_SET_POWER:

        //
        // presuppose good status.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        switch (IrpStack->Parameters.Power.Type) {

        case SystemPowerState:

            if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {
            
          		//
            	// Only care if the device is started.
            	// We depend on DE->ControlEvent being inited at SCStartWorker.
            	//
            	
                POWER_STATE     PowerState;
                SYSTEM_POWER_STATE RequestedSysState =
                IrpStack->Parameters.Power.State.SystemState;
                //
                // look up the correct device power state in the table
                //

                PowerState.DeviceState =
                    DeviceExtension->DeviceState[RequestedSysState];

                DebugPrint((DebugLevelInfo, 
                            "SCPower: DevObj %x S[%d]->D[%d]\n",
                            DeviceExtension->PhysicalDeviceObject,
                            RequestedSysState,
                            PowerState.DeviceState));

                //
                // if this is a wakeup, we must first pass the request down
                // to the PDO for preprocessing.
                //

                if (RequestedSysState == PowerSystemWorking) {

                    //
                    // Send down this S power IRP to the next layer and be
                    // done with it, except requesting D Irp in the following
                    // condition that related to the S Irp but does not reference
                    // it any further.
                    //

                    Status = SCSysWakeCallNextDriver(DeviceExtension, Irp);
                    ASSERT( NT_SUCCESS( Status ) );

                    //
                    // Nullify Irp, so at the D Irp completion, we dont complete this Irp.
                    // Be careful not to touch the Irp afterwards.
                    //

                    InterlockedDecrement(&DeviceExtension->OneBasedIoCount);
                    Irp = NULL; 
                    
                }

                //
                // Mark the S State.
                //
                SCSetCurrentSPowerState (DeviceExtension, RequestedSysState);

                //
                // take the event to avoid race.
                //

                KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,    // not alertable
                                      NULL);

                if ((RequestedSysState == PowerSystemWorking) &&
                    (!DeviceExtension->NumberOfOpenInstances) &&
                    (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)) {

                    // We are awakening from a suspend.
                    // we don't want to wake up the device at this
                    // point.  We'll just wait til the first open
                    // occurs to wake it up.
                    //

                    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

                    //
                    // Since there are no open instances, there can only be
                    // pended creates.  Since we key device powerup off the
                    // creates, redispatch them now if there are any. 
                    //
                    SCRedispatchPendedIrps (DeviceExtension, FALSE);

                    return Status;

                } else {        // if state = working

                    //
                    // now send down a set power based on this info.
                    //

                    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

                    //
                    // per Pierre and Lonny, we should use D3 instead of the
                    // mapped array value, as the array value is always D0!
                    // of course, they'll change this next week...
                    //

                    if (RequestedSysState != PowerSystemWorking) {

                        PowerState.DeviceState = PowerDeviceD3;

                    }
                    DebugPrint((DebugLevelInfo, 
                                "SCPower: PoRequestPowerIrp %x to state=%d\n",
                                DeviceExtension->PhysicalDeviceObject,
                                PowerState));

                    //
                    // when (RequestedSysState == PowerSystemWorking) but 
                    // (DeviceExtension->NumberOfOpenInstances) ||
                    // !(DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)
                    // we come here with Irp==NULL. Don't touch NULL Irp.
                    //
                    
                    if ( NULL != Irp ) {
                        IoMarkIrpPending (Irp);
                    }
                                
                    Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                               IRP_MN_SET_POWER,
                                               PowerState,
                                               SCSynchPowerCompletionRoutine,
                                               Irp, // when NULL, it tells callback don't bother.
                                               NULL);

                    if (!NT_SUCCESS (Status) && NULL != Irp ) {                        
                        PoStartNextPowerIrp (Irp);
                        SCCompleteIrp (Irp, Status, DeviceExtension);
                    }
                    
                    //
                    // The Irp has been marked pending.  We MUST return
                    // pending.  Error case will complete the Irp with the
                    // appropriate status.
                    //
                    return STATUS_PENDING;

                }               // if system state working

                //
                // if this is a NOT wakeup, we must first pass the request
                // down to the PDO for postprocessing.
                //

                if (RequestedSysState != PowerSystemWorking) {

                    //
                    // send down the power IRP to the next layer.  this
                    // routine
                    // has a completion routine which does not complete the
                    // IRP.
                    //

                    Status = SCCallNextDriver(DeviceExtension, Irp);

                    #if DBG
                    if (!NT_SUCCESS(Status)) {

                        DebugPrint((DebugLevelError, "'SCPower: PDO failed power request!\n"));
                    }
                    #endif
                }
          	}
          	else {
          		//
            	// We have not started the device, don't bother.
            	// Besides, we can't use the DE->ControlEvent which is not
            	// inited yet in this case.
            	//
            	Status = STATUS_SUCCESS;
            }
            
            //
            // indicate that we're ready for the next power IRP.
            //

            PoStartNextPowerIrp(Irp);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);

            //
            // now complete the original request
            //

            return (SCCompleteIrp(Irp, Status, DeviceExtension));

            // end of set system power state

        case DevicePowerState:

            {

                DEVICE_POWER_STATE DeviceState;
                DeviceState = IrpStack->Parameters.Power.State.DeviceState;

                //
                // if this is a power up, send the IRP down first to allow
                // the PDO to preprocess it.
                //

                if (DeviceState == PowerDeviceD0) {

                    //
                    // Call down async or the Wakeup might dead lock.
                    // The subsequent work continues in the completion routine.
                    //
                    
                    return SCDevWakeCallNextDriver(DeviceExtension, Irp);
                }
                //
                // take the event to avoid race
                //

                KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,    // not alertable
                                      NULL);

                //
                // send down a set power SRB to the device.
                // additional processing will be done by the callback
                // procedure.  This routine completes the IRP if it is able
                // to issue the request.
                //

                Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
                                         (PVOID) DeviceState,
                                         0,
                                         SCPowerCallback,
                                         DeviceExtension,
                                         NULL,
                                         NULL,
                                         Irp,
                                         &RequestIssued,
                                         &DeviceExtension->PendingQueue,
                                         (PVOID) DeviceExtension->
                                         MinidriverData->HwInitData.
                                         HwReceivePacket
                    );


                if (!RequestIssued) {

                    //
                    // if we could not issue a request, release event.
                    //

                    PoStartNextPowerIrp( Irp );
                    Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
                }
            }

            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

            //
            // show one fewer reference to driver.
            //

            SCDereferenceDriver(DeviceExtension);
            return (Status);

        }                       // case devicepowerstate

    default:

        DebugPrint((DebugLevelInfo, 
                   "StreamPower: unknown function %x\n",
                   DeviceObject));

        //
        // unknown function, so call it down to the minidriver as such.
        // this routine completes the IRP if it is able to issue the request.
        //

        Status = SCSendUnknownCommand(Irp,
                                      DeviceExtension,
                                      SCUnknownPowerCallback,
                                      &RequestIssued);

        if (!RequestIssued) {
            //
            // could not send the unknown command down.  show one fewer I/O
            // pending and fall thru to generic handler.
            //
            PoStartNextPowerIrp(Irp);
            Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);
        }
        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        return (Status);

    }
}

NTSTATUS
SCPNPQueryCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an PNP Query Stop/Remove command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    //
    // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
    // are supposed to traverse the whole device stack unless
    // it is to be failed right here.
    // It should have been STATUS_NOT_SUUPORTED ||
    // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
    // there are some mini drivers return it which should
    // have been STATUS_NOT_SUPPORTED
    //

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus ||
         NT_SUCCESS( MiniStatus ) ) {

        //
        // Mini driver did not explicitly failed this, passs down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explcitly failed this Irp, use MiniStatus
        //
        Status = MiniStatus;
    }

    if ( !NT_SUCCESS( Status ) ) {    
        //
        // query is vetoed, reset the INACCESSIBLE flag
        //
        KIRQL Irql;
        
        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);
        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }

    //
    // complete the IRP with the final status
    //
    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCUnknownPNPCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown PNP command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    //
    // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
    // are supposed to traverse the whole device stack unless
    // it is to be failed right here.
    // It should have been STATUS_NOT_SUUPORTED ||
    // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
    // there are some mini drivers return it which should
    // have been STATUS_NOT_SUPPORTED
    //

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus ||
         NT_SUCCESS( MiniStatus ) ) {

        //
        // Mini driver did not explicitly failed this, passs down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);

        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explcitly failed this Irp, use MiniStatus
        //
        Status = MiniStatus;
    }

    //
    // complete the IRP with the final status
    //

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}


NTSTATUS
SCUnknownPowerCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an unknown PNP command.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status, MiniStatus;

    PAGED_CODE();

    //
    // delete the SRB
    //

    MiniStatus = SCDequeueAndDeleteSrb(SRB);

    if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {
        MiniStatus = STATUS_NOT_SUPPORTED;
    }
    
    if ( STATUS_NOT_SUPPORTED == MiniStatus || 
         NT_SUCCESS( MiniStatus )) {

        //
        // it is not explicitly failed by the mini driver pass down the Irp
        //

        Status = SCCallNextDriver(DeviceExtension, Irp);
        if ( Status == STATUS_NOT_SUPPORTED ) {
            //
            // noone below knows/cares. Use our mini status
            //
            Status = MiniStatus;
        }
    }

    else {
        //
        // mini driver explicitly failed this
        //
        Status = MiniStatus;
    }
    //
    // complete the IRP with the final status
    //

    PoStartNextPowerIrp( Irp );
    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}

NTSTATUS
SCQueryWorker(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp
)
/*++

Routine Description:

     IRP completion handler for querying removal of the hardware

Arguments:

     DeviceObject - pointer to device object
     Irp - pointer to Irp

Return Value:

     NTSTATUS returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL           Irql;

    //
    // if the query did not succeed, reenable the device.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // clear the inaccessible bit.
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    }
    return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));
}


NTSTATUS
SCStartWorker(
              IN PIRP Irp
)
/*++

Routine Description:

     Passive level routine to process starting the hardware.

Arguments:

     Irp - pointer to Irp

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT  DeviceObject = IrpStack->DeviceObject;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo;
    PHW_INITIALIZATION_DATA HwInitData;
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor;
    KAFFINITY       affinity;
    PVOID           Buffer;
    PACCESS_RANGE   pAccessRanges = NULL;
    ULONG           CurrentRange = 0;
    BOOLEAN         interruptSharable = TRUE;
    DEVICE_DESCRIPTION deviceDescription;
    ULONG           numberOfMapRegisters;
    ULONG           DmaBufferSize;
    ULONG           i;
    PHYSICAL_ADDRESS TranslatedAddress;
    NTSTATUS        Status = Irp->IoStatus.Status;
    BOOLEAN         RequestIssued;
    INTERFACE_TYPE  InterfaceBuffer;
    ULONG           InterfaceLength;


    PAGED_CODE();

    //
    // continue processing if we got good status from our parent.
    //

    if (NT_SUCCESS(Status)) {

        HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

        DebugPrint((DebugLevelInfo, 
                   "SCPNPStartWorker %x\n",
                   DeviceObject));

        //
        // Initialize spin lock for critical sections.
        //

        KeInitializeSpinLock(&DeviceExtension->SpinLock);

        //
        // initialize a worker DPC for this device
        //

        KeInitializeDpc(&DeviceExtension->WorkDpc,
                        StreamClassDpc,
                        DeviceObject);
        //
        // initialize the control and remove events for this device
        //
        // move this to AddDevice, we use the control event at Remove_device
        // which can come in before the device starts.
        // KeInitializeEvent(&DeviceExtension->ControlEvent,
        //                  SynchronizationEvent,
        //                  TRUE);

        KeInitializeEvent(&DeviceExtension->RemoveEvent,
                          SynchronizationEvent,
                          FALSE);

        //
        // Initialize minidriver timer and timer DPC for this stream
        //

        KeInitializeTimer(&DeviceExtension->ComObj.MiniDriverTimer);
        KeInitializeDpc(&DeviceExtension->ComObj.MiniDriverTimerDpc,
                        SCMinidriverDeviceTimerDpc,
                        DeviceExtension);

        //
        // retrieve the resources for the device
        //

        ResourceList = IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

        //
        // allocate space for the config info structure.
        //

        ConfigInfo = ExAllocatePool(NonPagedPool,
                                    sizeof(PORT_CONFIGURATION_INFORMATION)
            					   );


        if (ConfigInfo == NULL) {

            DebugPrint((DebugLevelFatal, "StreamClassPNP: ConfigInfo alloc failed."));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        DebugPrint((DebugLevelVerbose, "StreamClassPNP: ConfigInfo = %x\n", ConfigInfo));

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        DeviceExtension->ConfigurationInformation = ConfigInfo;

        //
        // fill in the ConfigInfo fields we know about.
        //

        ConfigInfo->SizeOfThisPacket = sizeof(PORT_CONFIGURATION_INFORMATION);

		#if DBG

        //
        // make sure that the minidriver handles receiving a bigger structure
        // so we can expand it later
        //

        ConfigInfo->SizeOfThisPacket *= ConfigInfo->SizeOfThisPacket;
		#endif
		
        //
        // set the callable PDO in the configinfo structure
        //

        ConfigInfo->PhysicalDeviceObject = DeviceExtension->AttachedPdo;
        ConfigInfo->RealPhysicalDeviceObject = DeviceExtension->PhysicalDeviceObject;

        ConfigInfo->BusInterruptVector = MP_UNINITIALIZED_VALUE;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->DmaChannel = MP_UNINITIALIZED_VALUE;
        ConfigInfo->Irp = Irp;

        //
        // Now we get to chew thru the resources the OS found for us, if any.
        //

        if (ResourceList) {

            FullResourceDescriptor = &ResourceList->List[0];

            PartialResourceList = &FullResourceDescriptor->PartialResourceList;

            //
            // fill in the bus # and interface type based on the device
            // properties
            // for the PDO.  default to InterfaceTypeUndefined if
            // failure to retrieve interface type (if the miniport tries to
            // use
            // this value when filling in DEVICE_DESCRIPTION.InterfaceType
            // for
            // calling IoGetDmaAdapter, the right thing will happen, since
            // PnP
            // will automatically pick the correct legacy bus in the system
            // (ISA or MCA).
            //

            if (!NT_SUCCESS(
                  IoGetDeviceProperty(
                  		DeviceExtension->PhysicalDeviceObject,
                        DevicePropertyBusNumber,
                        sizeof(ULONG),
                        (PVOID) & (ConfigInfo->SystemIoBusNumber),
                        &InterfaceLength))) {
                //
                // Couldn't retrieve bus number property--assume bus zero.
                //
                ConfigInfo->SystemIoBusNumber = 0;
            }
            if (NT_SUCCESS(
                  IoGetDeviceProperty(
                  		DeviceExtension->PhysicalDeviceObject,
                        DevicePropertyLegacyBusType,
                        sizeof(INTERFACE_TYPE),
                        &InterfaceBuffer,
                        &InterfaceLength))) {


                ASSERT(InterfaceLength == sizeof(INTERFACE_TYPE));
                ConfigInfo->AdapterInterfaceType = InterfaceBuffer;

            } else {            // if success
                //
                // Couldn't retrieve bus interface type--initialize to
                // InterfaceTypeUndefined.
                //
                ConfigInfo->AdapterInterfaceType = InterfaceTypeUndefined;

            }                   // if success


            //
            // allocate space for access ranges.  We use the Count field
            // in the resource list for determining this size, as the count
            // will be >= the max # of ranges we will need.
            //

            if (PartialResourceList->Count) {

                pAccessRanges = ExAllocatePool(NonPagedPool,
                                               sizeof(ACCESS_RANGE) *
                                               PartialResourceList->Count
                    						  );

                if (pAccessRanges == NULL) {

                    DebugPrint((DebugLevelFatal,
                                "StreamClassPNP: No pool for global info"));

                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    SCFreeAllResources(DeviceExtension);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }                   // if count

            //
            // Stash the AccessRanges structure at this time so that
            // SCFreeAllResources will free it on resource failures below.
            //
            ConfigInfo->AccessRanges = pAccessRanges;

            //
            // Now update the port configuration info structure by looping
            // thru the config
            //

            for (i = 0; i < PartialResourceList->Count; i++) {

                switch (PartialResourceList->PartialDescriptors[i].Type) {

                case CmResourceTypePort:

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Port Resources Found at %x, Length  %x\n",
                    PartialResourceList->PartialDescriptors[i].u.Port.Start,
                                PartialResourceList->PartialDescriptors[i].u.Port.Length));

                    //
                    // translate the bus address for the minidriver
                    //

                    TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Port.Start;

                    //
                    // set the access range in the structure.
                    //

                    pAccessRanges[CurrentRange].RangeStart = TranslatedAddress;

                    pAccessRanges[CurrentRange].RangeLength =
                        PartialResourceList->
                        PartialDescriptors[i].u.Port.Length;

                    pAccessRanges[CurrentRange++].RangeInMemory =
                        FALSE;

                    break;

                case CmResourceTypeInterrupt:

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Interrupt Resources Found!  Level = %x Vector = %x\n",
                                PartialResourceList->PartialDescriptors[i].u.Interrupt.Level,
                                PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector));

                    //
                    // Set the interrupt vector in the config info
                    //

                    ConfigInfo->BusInterruptVector = PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector;

                    ;
                    affinity = PartialResourceList->PartialDescriptors[i].u.Interrupt.Affinity;

                    ConfigInfo->BusInterruptLevel = (ULONG) PartialResourceList->PartialDescriptors[i].u.Interrupt.Level;

                    ConfigInfo->InterruptMode = PartialResourceList->PartialDescriptors[i].Flags;

                    //
                    // Go to next resource for this Adapter
                    //

                    break;

                case CmResourceTypeMemory:

                    //
                    // translate the bus address for the minidriver
                    //

                    DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Memory Resources Found @ %x'%x, Length = %x\n",
                                PartialResourceList->PartialDescriptors[i].u.Memory.Start.HighPart,
                                PartialResourceList->PartialDescriptors[i].u.Memory.Start.LowPart,
                                PartialResourceList->PartialDescriptors[i].u.Memory.Length));


                    TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Memory.Start;

                    if (!SCMapMemoryAddress(&pAccessRanges[CurrentRange++],
                                            TranslatedAddress,
                                            ConfigInfo,
                                            DeviceExtension,
                                            ResourceList,
                                            &PartialResourceList->
                                            PartialDescriptors[i])) {

                        SCFreeAllResources(DeviceExtension);
                        Status = STATUS_CONFLICTING_ADDRESSES;
                        goto exit;

                    }           // if !scmapmemoryaddress
                default:

                    break;

                }

            }

        }                       // if resources
        //
        // reference the access range structure to the
        // config info structure & the ConfigInfo structure to the
        // device extension & indicate # of ranges.
        //

        ConfigInfo->NumberOfAccessRanges = CurrentRange;

        //
        // Determine if a Dma Adapter must be allocated.
        //

        DmaBufferSize = HwInitData->DmaBufferSize;

        if ((HwInitData->BusMasterDMA) || (DmaBufferSize)) {

            //
            // Get the adapter object for this card.
            //

            DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Allocating DMA adapter\n"));

            RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));
            deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
            deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
            deviceDescription.DmaWidth = Width32Bits;
            deviceDescription.DmaSpeed = Compatible;
            deviceDescription.ScatterGather = TRUE;
            deviceDescription.Master = TRUE;
            deviceDescription.Dma32BitAddresses = !(HwInitData->Dma24BitAddresses);
            deviceDescription.AutoInitialize = FALSE;
            deviceDescription.MaximumLength = (ULONG) - 1;

            DeviceExtension->DmaAdapterObject = IoGetDmaAdapter(
                                      DeviceExtension->PhysicalDeviceObject,
                                                         &deviceDescription,
                                                       &numberOfMapRegisters
                );
            ASSERT(DeviceExtension->DmaAdapterObject);

            //
            // Set maximum number of pages
            //

            DeviceExtension->NumberOfMapRegisters = numberOfMapRegisters;

            //
            // expose the object to the minidriver
            //

            ConfigInfo->DmaAdapterObject = DeviceExtension->DmaAdapterObject;


        } else {

            //
            // no DMA adapter object.  show unlimited map registers so
            // we won't have to do a real time check later for DMA.
            //

            DeviceExtension->NumberOfMapRegisters = -1;

        }

        if (DmaBufferSize) {

            Buffer = HalAllocateCommonBuffer(DeviceExtension->DmaAdapterObject,
                                             DmaBufferSize,
                                        &DeviceExtension->DmaBufferPhysical,
                                             FALSE);

            if (Buffer == NULL) {
                DEBUG_BREAKPOINT();
                DebugPrint((DebugLevelFatal, "StreamClassPnPStart: Could not alloc buffer, size: %d\n", DmaBufferSize));
                SCFreeAllResources(DeviceExtension);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            //
            // zero init the common buffer.
            //

            RtlZeroMemory(Buffer, DmaBufferSize);

            //
            // save virtual address of buffer
            //

            DeviceExtension->DmaBuffer = Buffer;
            DeviceExtension->DmaBufferLength = DmaBufferSize; // osr#99489

        }                       // if DMA buffer
        //
        // Performance Improvement chance 
        //   - on rebalance, the uninitialize handler clears the sync
        // vector when the interrupt is disconnected, but since we
        // initialized this vector ONLY at AddDevice time, it wasn't getting
        // reset correctly since only a new start (and not an adddevice) is
        // sent on a rebalance.  the correct fix is to move all of the
        // initial vector setting to here, but I'm worried that there could
        // be a case where if they aren't set up on the adddevice we could
        // reference a null.   So, I've duplicated the following few lines to
        // reset the vector here.   For code savings, this should be done
        // only in one place.
        //

        //
        // presuppose full synch
        //

		#if DBG
        DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
		#else
        DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
		#endif

        if (DeviceExtension->NoSync) {

            //
            // we won't do synchronization, so use the dummy sync routine.
            //

            DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
            DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

        }
        //
        // see if the driver has an interrupt, and process if so.
        //

        if (HwInitData->HwInterrupt == NULL ||
            (ConfigInfo->BusInterruptLevel == 0 &&
             ConfigInfo->BusInterruptVector == 0)) {

            //
            // There is no interrupt so use the dummy sync routine.
            //

            DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
            DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

            DebugPrint((1, "'StreamClassInitialize: Adapter has no interrupt.\n"));

        } else {

            DebugPrint((1,
                        "'StreamClassInitialize: STREAM adapter IRQ is %d\n",
                        ConfigInfo->BusInterruptLevel));

            //
            // Set up for a real interrupt.
            //

            Status = IoConnectInterrupt(
            			&DeviceExtension->InterruptObject,
                        StreamClassInterrupt,
                        DeviceObject,
                        (PKSPIN_LOCK) NULL,
                        ConfigInfo->BusInterruptVector,
                        (UCHAR) ConfigInfo->BusInterruptLevel,
                        (UCHAR) ConfigInfo->BusInterruptLevel,
                        ConfigInfo->InterruptMode,
                        interruptSharable,
                        affinity,
                        FALSE);

            if (!NT_SUCCESS(Status)) {

                DebugPrint((1, "'SCStartWorker: Can't connect interrupt %d\n",
                            ConfigInfo->BusInterruptLevel));
                DeviceExtension->InterruptObject = NULL;
                SCFreeAllResources(DeviceExtension);
                goto exit;
            }
            //
            // set the interrupt object for the minidriver
            //

            ConfigInfo->InterruptObject = DeviceExtension->InterruptObject;

        }

        //
        // point the config info structure to the device extension &
        // device object as
        // we can only pass in one context value to KeSync....
        //

        ConfigInfo->HwDeviceExtension =
            DeviceExtension->HwDeviceExtension;

        ConfigInfo->ClassDeviceObject = DeviceObject;

        //
        // Start timer.
        //

        IoStartTimer(DeviceObject);

        //
        // the ConfigInfo structure is filled in and the IRQ hooked.
        // call the minidriver to find the specified adapter.
        //

        //
        // initialize the device extension queues
        //

        InitializeListHead(&DeviceExtension->PendingQueue);
        InitializeListHead(&DeviceExtension->OutstandingQueue);

        /// move to add device, we could have child PDO if we start and stop
        ///InitializeListHead(&DeviceExtension->Children);
        InitializeListHead(&DeviceExtension->DeadEventList);
        IFN_MF(InitializeListHead(&DeviceExtension->NotifyList);)

        ExInitializeWorkItem(&DeviceExtension->EventWorkItem,
                             SCFreeDeadEvents,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->RescanWorkItem,
                             SCRescanStreams,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                             SCPowerCompletionWorker,
                             DeviceExtension);

        ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
                             SCDevIrpCompletionWorker,
                             DeviceExtension);


        //
        // show that the device is ready for its first request.
        //

        DeviceExtension->ReadyForNextReq = TRUE;

        //
        // submit the initialize command.
        // additional processing will be done by the callback procedure.
        //

        Status = SCSubmitRequest(
        			SRB_INITIALIZE_DEVICE,
                    ConfigInfo,
                    sizeof(PORT_CONFIGURATION_INFORMATION),
                    SCInitializeCallback,
                    DeviceExtension,
                    NULL,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        //
        // If the device failed to start then set the error and return.
        //

        if (!RequestIssued) {

            DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));

            SCFreeAllResources(DeviceExtension);
            goto exit;
        }
    }
    return (Status);

exit:
    return (SCCompleteIrp(Irp, Status, DeviceExtension));

}


NTSTATUS
SCInitializeCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PIRP            Irp = SRB->HwSRB.Irp;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo =
    SRB->HwSRB.CommandData.ConfigInfo;
    BOOLEAN         RequestIssued;
    NTSTATUS        Status;

    PAGED_CODE();

    if (NT_SUCCESS(SRB->HwSRB.Status)) {

        DebugPrint((DebugLevelVerbose, "'Stream: returned from HwInitialize\n"));

        //
        // send an SRB to retrieve the stream information
        //

        ASSERT(ConfigInfo->StreamDescriptorSize);

        StreamBuffer =
            ExAllocatePool(NonPagedPool,
                           ConfigInfo->StreamDescriptorSize
            );

        if (!StreamBuffer) {

            SCUninitializeMinidriver(DeviceObject, Irp);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return (SCProcessCompletedRequest(SRB));
        }
        //
        // zero-init the buffer
        //

        RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);


        //
        // submit the command.
        // additional processing will be done by the callback
        // procedure.
        //

        Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                   StreamBuffer,
                   ConfigInfo->StreamDescriptorSize,
                   SCStreamInfoCallback,
                   DeviceExtension,
                   NULL,
                   NULL,
                   Irp,
                   &RequestIssued,
                   &DeviceExtension->PendingQueue,
                   (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
            	 );

        if (!RequestIssued) {

            ExFreePool(StreamBuffer);
            SCUninitializeMinidriver(DeviceObject, Irp);
            return (SCProcessCompletedRequest(SRB));

        }
    } else {

        //
        // If the device failed to start then set the error and
        // return.
        //

        DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));
        SCFreeAllResources(DeviceExtension);
        return (SCProcessCompletedRequest(SRB));
    }

    //
    // dequeue and delete the SRB for initialize.  Null out the IRP field
    // so the dequeue routine won't try to access it, as it has been freed.
    //

    SRB->HwSRB.Irp = NULL;
    SCDequeueAndDeleteSrb(SRB);
    return (Status);

}


#if ENABLE_MULTIPLE_FILTER_TYPES

PUNICODE_STRING
SciCreateSymbolicLinks(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG FilterTypeIndex,
    IN PHW_STREAM_HEADER StreamHeader)
/*++

Routine Description:

    Create symbolic links for all categories in the Topology of 
    one filter type so that clients can find them.
    The Symbolic link array is kept in the FilterType so that
    they can be released later.

Arguments:

    DeviceExtenion: The device instance.
    FiltertypeIndex: The filter type to create symbolic links.
    StreamHeader: Go thru the categories in the Topology.

Return Value:

    NTSTATUS

--*/
{
   	LPGUID  GuidIndex = (LPGUID)StreamHeader->Topology->Categories;
   	ULONG   ArrayCount = StreamHeader->Topology->CategoriesCount;
   	PUNICODE_STRING NamesArray;
    ULONG           i,j;
    HANDLE          ClassHandle, PdoHandle=NULL; // prefixbug 17135
    UNICODE_STRING  TempUnicodeString;
    PVOID           DataBuffer[MAX_STRING_LENGTH];
    //ULONG           NumberOfFilterTypes;
    NTSTATUS        Status=STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_DEVICE_EXTENSION( DeviceExtension );
    
    //
    // allocate space for the array of catagory names
    //
    NamesArray = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING) * ArrayCount);
    if ( NULL == NamesArray ) {
        DEBUG_BREAKPOINT();                           
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    //
    // zero the array in case we're unable to fill it in below.  the Destroy
    // routine below will then correctly handle this case.
    //

    RtlZeroMemory(NamesArray, sizeof(UNICODE_STRING) * ArrayCount);

    //
    // open the PDO
    //

    Status = IoOpenDeviceRegistryKey(
                            DeviceExtension->PhysicalDeviceObject,
                            PLUGPLAY_REGKEY_DRIVER,
                            STANDARD_RIGHTS_ALL,
                            &PdoHandle);
                            
    if ( !NT_SUCCESS(Status) ) {
        DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't open Pdo\n"));
        PdoHandle = NULL;
        goto Exit;
    }
    
    //
    // loop through each of the catagory GUID's for each of the pins,
    // creating a symbolic link for each one.
    //

    for (i = 0; i < ArrayCount; i++) {
        //
        // Create the symbolic link for each category
        //
        PKSOBJECT_CREATE_ITEM CreateItem;

        CreateItem = &DeviceExtension->CreateItems[FilterTypeIndex];

        DebugPrint((DebugLevelVerbose, 
                   "RegisterDeviceInterface FType %d,"
                   "CreateItemName=%S\n",
                   FilterTypeIndex,
                   CreateItem->ObjectClass.Buffer));
        
        Status = IoRegisterDeviceInterface(
                    DeviceExtension->PhysicalDeviceObject,
                    &GuidIndex[i],
                    (PUNICODE_STRING) &CreateItem->ObjectClass,
                    &NamesArray[i]);
                        
        if ( !NT_SUCCESS(Status)) {
            //
            //  Can't register device interface
            //
            DebugPrint((DebugLevelError,
                       "StreamCreateSymLinks: couldn't register\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }

        DebugPrint((DebugLevelVerbose,
                   "SymbolicLink:%S\n",
                   NamesArray[i].Buffer));
        //
        // Now set the symbolic link for the association
        //
        Status = IoSetDeviceInterfaceState(&NamesArray[i], TRUE);
        if (!NT_SUCCESS(Status)) {
            //
            //  unsuccessful
            //
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }
        //
        // add the strings from the PDO's key to the association key.
        // Performance Improvement Chance 
        //   - the INF should be able to directly propogate these;
        // forrest & lonny are fixing.
        //

        Status = IoOpenDeviceInterfaceRegistryKey(&NamesArray[i],
                                                  STANDARD_RIGHTS_ALL,
                                                  &ClassHandle);
        if ( !NT_SUCCESS( Status )) {
            //
            //  unsuccessful open Class interface
            //
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            goto Exit;
        }

        //
        // write the class ID for the proxy, if any.
        //
        Status = SCGetRegistryValue(PdoHandle,
                                    (PWCHAR) ClsIdString,
                                    sizeof(ClsIdString),
                                    DataBuffer,
                                    MAX_STRING_LENGTH);
                                    
        if ( NT_SUCCESS(Status) ){
            //
            // write the class ID for the proxy
            //
            RtlInitUnicodeString(&TempUnicodeString, ClsIdString);

            ZwSetValueKey(ClassHandle,
                          &TempUnicodeString,
                          0,
                          REG_SZ,
                          DataBuffer,
                          MAX_STRING_LENGTH);
        } // if cls guid read
        //
        // first check if a friendly name has already been propogated
        // to the class via the INF.   If not, we'll just use the device
        // description string for this.
        //
        Status = SCGetRegistryValue(ClassHandle,
                                    (PWCHAR) FriendlyNameString,
                                    sizeof(FriendlyNameString),
                                    DataBuffer,
                                    MAX_STRING_LENGTH);
                                    
        if ( !NT_SUCCESS(Status) ) {
            //
            // friendly name non-exists yet.
            // write the friendly name for the device, if any.
            //

            Status = SCGetRegistryValue(PdoHandle,
                                        (PWCHAR) DriverDescString,
                                        sizeof(DriverDescString),
                                        DataBuffer,
                                        MAX_STRING_LENGTH);
                                       
            if ( NT_SUCCESS(Status) ) {
                //
                // driver descrption string available, use it. 
                //
                RtlInitUnicodeString(&TempUnicodeString, FriendlyNameString);

                ZwSetValueKey(ClassHandle,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              DataBuffer,
                              MAX_STRING_LENGTH);


            }
        }
        ZwClose(ClassHandle);

    } // for # Categories

    //
    // If we reach here, consider as successful.
    // 
    Status = STATUS_SUCCESS;

    Exit: {
        if ( NULL != PdoHandle ) {
            ZwClose(PdoHandle);
        }
        if ( !NT_SUCCESS( Status ) ) {
            if ( NULL != NamesArray ) {
                ExFreePool( NamesArray );
                NamesArray = NULL;
            }
        }
        return NamesArray;
    }
}


NTSTATUS
SciOnFilterStreamDescriptor(
    PFILTER_INSTANCE FilterInstance,
    PHW_STREAM_DESCRIPTOR StreamDescriptor)
/*++

Routine Description:

     Process the minidriver's stream descriptor structure.
     This is used for one FilterType specific streams.
     
Arguments:

     FilterInstance: The one that we are to process for.
     StreamDescriptor: Point to the descriptor to process for the filter.

Return Value:

     None.

--*/
{
    ULONG           NumberOfPins, i;
    PKSPIN_DESCRIPTOR PinDescs = NULL;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           PinSize;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;
    NTSTATUS Status=STATUS_SUCCESS;
    
    PAGED_CODE();

    NumberOfPins = StreamDescriptor->StreamHeader.NumberOfStreams;

    DebugPrint((DebugLevelVerbose,
               "Parsing StreamInfo Pins=%x\n", NumberOfPins ));

    if (StreamDescriptor->StreamHeader.SizeOfHwStreamInformation < 
        sizeof(HW_STREAM_INFORMATION)) {

        DebugPrint((DebugLevelError, "minidriver stream info too small!"));

        DEBUG_BREAKPOINT();
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }    

    if (NumberOfPins) {
        //
        // parse the minidriver's info into CSA format to build the
        // mother of all structures.
        //

        PinSize = (sizeof(KSPIN_DESCRIPTOR) + sizeof(STREAM_ADDITIONAL_INFO))*
                    NumberOfPins;

        PinDescs = ExAllocatePool(NonPagedPool, PinSize);
        if (PinDescs == NULL) {
            DebugPrint((DebugLevelError, "Stream: No pool for stream info"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        RtlZeroMemory(PinDescs, PinSize);

        //
        // we need a new array to hold the new copies of the
        // stream properties and events which are allocated below.
        //

        NewStreamArray = (PSTREAM_ADDITIONAL_INFO) 
            ((PBYTE) PinDescs + sizeof(KSPIN_DESCRIPTOR) * NumberOfPins);

        FilterInstance->StreamPropEventArray = NewStreamArray;

        CurrentInfo = &StreamDescriptor->StreamInfo;

        for (i = 0; i < StreamDescriptor->StreamHeader.NumberOfStreams; i++) {
            //
            // process each pin info
            //
            
            PinDescs[i].InterfacesCount = SIZEOF_ARRAY(PinInterfaces);
            PinDescs[i].Interfaces = PinInterfaces;

            //
            // use default medium if minidriver does not specify
            //
            if (CurrentInfo->MediumsCount) {
                PinDescs[i].MediumsCount = CurrentInfo->MediumsCount;
                PinDescs[i].Mediums = CurrentInfo->Mediums;

            }
            else {
                PinDescs[i].MediumsCount = SIZEOF_ARRAY(PinMediums);
                PinDescs[i].Mediums = PinMediums;
            }

            //
            // set the # of data format blocks
            //

            PinDescs[i].DataRangesCount = 
                    CurrentInfo->NumberOfFormatArrayEntries;

            //
            // point to the data format blocks for the pin
            //

            PinDescs[i].DataRanges = CurrentInfo->StreamFormatsArray;

            //
            // set the data flow direction
            //

            PinDescs[i].DataFlow = (KSPIN_DATAFLOW) CurrentInfo->DataFlow;

            //
            // set the communication field
            //

            if (CurrentInfo->BridgeStream) {
                PinDescs[i].Communication = KSPIN_COMMUNICATION_BRIDGE;
            }
            else {
                #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
                PinDescs[i].Communication = KSPIN_COMMUNICATION_BOTH;
				#else
                PinDescs[i].Communication = KSPIN_COMMUNICATION_SINK;
				#endif
            }

            //
            // copy the pointers for the pin name and category
            //
            PinDescs[i].Category = CurrentInfo->Category;
            PinDescs[i].Name = CurrentInfo->Name;

            if ( CurrentInfo->NumStreamPropArrayEntries) {

                ASSERT(CurrentInfo->StreamPropertiesArray);
                //
                // make a copy of the properties since we modify the struct
                // though parts of it may be marked as a const.
                // Performance Imporovement Chance 
                //   - check for const in future if possible
                //

                if (!(NewStreamArray[i].StreamPropertiesArray = 
               		  SCCopyMinidriverProperties(
               		      CurrentInfo->NumStreamPropArrayEntries,
                          CurrentInfo->StreamPropertiesArray))) {
                        //
                        // Fail to copy
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                }
            }
            if (CurrentInfo->NumStreamEventArrayEntries) {

                ASSERT(CurrentInfo->StreamEventsArray);
                //
                // make a copy of the events since we modify the
                // struct
                // though parts of it may be marked as a const.
                // Performance Improvement Chance 
                //   - check for const in future if possible
                //
                    
                if (!(NewStreamArray[i].StreamEventsArray = 
                      SCCopyMinidriverEvents(
                            CurrentInfo->NumStreamEventArrayEntries,
                            CurrentInfo->StreamEventsArray))) {
                        //
                        // Fail to copy
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                }
                
            //
            // update the minidriver's properties for this stream.
            //
            SCUpdateMinidriverProperties(
            	    CurrentInfo->NumStreamPropArrayEntries,
            	    NewStreamArray[i].StreamPropertiesArray,
                    TRUE);

            //
            // update the minidriver's events for this stream.
            //
            SCUpdateMinidriverEvents(
	                CurrentInfo->NumStreamEventArrayEntries,
	                NewStreamArray[i].StreamEventsArray,
                    TRUE);


            //
            // index to next streaminfo structure.
            //
            CurrentInfo++;
        } // for # pins
    } // if there are pins

    if (StreamDescriptor->StreamHeader.NumDevPropArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DevicePropertiesArray);

        //
        // make a copy of the properties since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        // - check for const in future if possible
        //

        if (!(FilterInstance->DevicePropertiesArray =
              SCCopyMinidriverProperties(
                StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                StreamDescriptor->StreamHeader.DevicePropertiesArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }
    
    if (StreamDescriptor->StreamHeader.NumDevEventArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DeviceEventsArray);

        //
        // make a copy of the events since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        //   - check for const in future if possible
        //

        if (!(FilterInstance->EventInfo =
              SCCopyMinidriverEvents(
                StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                StreamDescriptor->StreamHeader.DeviceEventsArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    #ifdef ENABLE_KS_METHODS
    //
    // process the device methods
    //
    if (StreamDescriptor->StreamHeader.NumDevMethodArrayEntries) {

        ASSERT(StreamDescriptor->StreamHeader.DeviceMethodsArray);

        //
        // make a copy of the properties since we modify the struct
        // though parts of it may be marked as a const.
        // Performance Improvement Chance
        //   - check for const in future if possible
        //

        if (!(FilterInstance->DeviceMethodsArray =
              SCCopyMinidriverMethods(
                StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                StreamDescriptor->StreamHeader.DeviceMethodsArray))) {
            //
            // Fail to copy
            //
            ASSERT( 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }
	#endif
  
    //
    // process the minidriver's device properties.
    //

    SCUpdateMinidriverProperties(
          StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
          FilterInstance->DevicePropertiesArray,
          FALSE);


    //
    // process the minidriver's device events.
    //

    SCUpdateMinidriverEvents(
          StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
          FilterInstance->EventInfo,
          FALSE);

	#ifdef ENABLE_KS_METHODS
    //
    // process the minidriver's device methods.
    //

    SCUpdateMinidriverMethods(
          StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
          FilterInstance->DeviceMethodsArray,
              FALSE);
	#endif

    //
    // set the event info count in the device extension
    //

    FilterInstance->EventInfoCount = 
            StreamDescriptor->StreamHeader.NumDevEventArrayEntries;

    FilterInstance->HwEventRoutine = 
            StreamDescriptor->StreamHeader.DeviceEventRoutine;

    //
    // call routine to save new stream info
    //

    SciInsertFilterStreamInfo(FilterInstance,
                              PinDescs,
                              NumberOfPins);
	
    Exit:{
        // ToDo: need to cleanup in error conditions.
        return Status;
    }
}

VOID
SciInsertFilterStreamInfo(
    IN PFILTER_INSTANCE FilterInstance,
    IN PKSPIN_DESCRIPTOR PinDescs,
    IN ULONG NumberOfPins)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/
{
    PAGED_CODE();

    //
    // save the pin info in the dev extension
    //

    if (FilterInstance->PinInformation) {

        ExFreePool(FilterInstance->PinInformation);
    }
    FilterInstance->PinInformation = PinDescs;
    FilterInstance->NumberOfPins = NumberOfPins;
    
    return;
}

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure(s). This is used to 
     process an StreamDescriptor list as well as for one StreamInfo when 
     called by StreamClassReenumerateFilterStreams() to rescan.
     
Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/
{
	PHW_STREAM_DESCRIPTOR StreamDescriptor;
	PDEVICE_EXTENSION 	  DeviceExtension;
	NTSTATUS              Status;
	
	DeviceExtension= (PDEVICE_EXTENSION)SRB->HwSRB.HwDeviceExtension -1;

	ASSERT_DEVICE_EXTENSION( DeviceExtension );
	
	if ( NULL == SRB->HwSRB.HwInstanceExtension ) {
		//
		// This is a complete list of StreamInfos for the mini driver
		//
	
		//
		// some validations and Just hang it off the DeviceExtension
		//
		ULONG TotalLength;
		ULONG ul;
		PFILTER_TYPE_INFO FilterTypeInfo;
		PHW_STREAM_DESCRIPTOR NextStreamDescriptor;
		BOOLEAN         RequestIssued;


        FilterTypeInfo = DeviceExtension->FilterTypeInfos;
		StreamDescriptor = 
			(PHW_STREAM_DESCRIPTOR) SRB->HwSRB.CommandData.StreamBuffer;
		DeviceExtension->StreamDescriptor = StreamDescriptor;
		NextStreamDescriptor = StreamDescriptor;
		
		Status = STATUS_SUCCESS;

        //
        // take the event early here. an open could come in the middle of
        // enabling device interface.
        //
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                              Executive,
                              KernelMode,
                              FALSE,    // not alertable
                              NULL);
		
		for ( ul=0, TotalLength=0; 
			  ul < DeviceExtension->NumberOfFilterTypes;
			  ul++) {
	        //
	        // need a StreamDescriptor for each filter type
	        //
	        if ((TotalLength+sizeof(HW_STREAM_HEADER) >
                 SRB->HwSRB.ActualBytesTransferred ) ||
                (sizeof(HW_STREAM_INFORMATION) !=
                 NextStreamDescriptor->StreamHeader.SizeOfHwStreamInformation)){
                //
                // Invalid data, bail out                
                //
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if ( !(DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD )) {
                //
                // Don't create symbolic link if loaded by SWEnum which
                // will create a duplicate one.
                //
                // create the symbolic link to the device.
                //

                FilterTypeInfo[ul].SymbolicLinks = 
                    SciCreateSymbolicLinks( 
                           DeviceExtension,
                           ul,
                           &NextStreamDescriptor->StreamHeader );
                FilterTypeInfo[ul].LinkNameCount = 
                    NextStreamDescriptor->StreamHeader.Topology->CategoriesCount;
            }

            else {
                //
                // no creation, 0 count and null pointer.
                //
                FilterTypeInfo[ul].LinkNameCount = 0;
                FilterTypeInfo[ul].SymbolicLinks = NULL;
            }

    		FilterTypeInfo[ul].StreamDescriptor = NextStreamDescriptor;
    		

		    TotalLength = TotalLength + 
		                  sizeof(HW_STREAM_HEADER) +
		                  (sizeof(HW_STREAM_INFORMATION) *
		                   NextStreamDescriptor->StreamHeader.NumberOfStreams);

	        DebugPrint((DebugLevelVerbose, "TotalLength=%d\n", TotalLength ));
		                     
            NextStreamDescriptor = (PHW_STREAM_DESCRIPTOR)
                    ((PBYTE) StreamDescriptor + TotalLength);
            
		}
		
	    if ( TotalLength != SRB->HwSRB.ActualBytesTransferred ) {
	        DebugPrint((DebugLevelWarning,
	                   "TotalLength %x of StreamInfo not equal to "
	                   "ActualBytesTransferred %x\n",
	                   TotalLength,
	                   SRB->HwSRB.ActualBytesTransferred ));
	    }

	    DeviceExtension->Flags |= DEVICE_FLAGS_PNP_STARTED;

        //
        // call the minidriver to indicate that initialization is
        // complete.
        //

        SCSubmitRequest(SRB_INITIALIZATION_COMPLETE,
                NULL,
                0,
                SCDequeueAndDeleteSrb,
                DeviceExtension,
                NULL,
                NULL,
                SRB->HwSRB.Irp,
                &RequestIssued,
                &DeviceExtension->PendingQueue,
                (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
                );


        //
        // tell the device to power down now, since it is not yet opened.
        // acquire the control event since this routine needs it.
        //
        
        //KeWaitForSingleObject(&DeviceExtension->ControlEvent,
        //                      Executive,
        //                      KernelMode,
        //                      FALSE,    // not alertable
        //                      NULL);

        SCCheckPowerDown(DeviceExtension);

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
	}

	else {
        //
        // This is a rescan for the specific FilterInstance
        //

		PFILTER_INSTANCE FilterInstance;

		FilterInstance = (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension-1;
		StreamDescriptor = (PHW_STREAM_DESCRIPTOR) 
		                    SRB->HwSRB.CommandData.StreamBuffer;

		Status = SciOnFilterStreamDescriptor(
		                FilterInstance,
		                StreamDescriptor);

        if ( NT_SUCCESS( Status ) ) {
            ASSERT( NULL != FilterInstance->StreamDescriptor );
            ExFreePool( FilterInstance->StreamDescriptor );
            ///if ( InterlockedExchange( &FilterInstance->Reenumerated, 1)) {
            ///    ASSERT( FilterInstance->StreamDescriptor );
            ///    ExFreePool( FilterInstance->StreamDescriptor );
            ///}
            FilterInstance->StreamDescriptor = StreamDescriptor;
        }
	}
	
    return (SCProcessCompletedRequest(SRB));
}



#else // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCStreamInfoCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the minidriver's stream info structure.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{

    PHW_STREAM_DESCRIPTOR StreamDescriptor = SRB->HwSRB.CommandData.StreamBuffer;
    ULONG           NumberOfPins,
                    i;
    PKSPIN_DESCRIPTOR PinDescs = NULL;
    PHW_STREAM_INFORMATION CurrentInfo;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    ULONG           PinSize;
    BOOLEAN         Rescan = FALSE;
    BOOLEAN         RequestIssued;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;

    PAGED_CODE();

    //
    // if this is a stream rescan, set the boolean
    //

    if (DeviceExtension->StreamDescriptor) {

        Rescan = TRUE;

    }
    if (NT_SUCCESS(SRB->HwSRB.Status)) {
        NumberOfPins = StreamDescriptor->StreamHeader.NumberOfStreams;

        if (StreamDescriptor->StreamHeader.SizeOfHwStreamInformation < sizeof(HW_STREAM_INFORMATION)) {

            DebugPrint((DebugLevelError,
                    "DecoderClassInit: minidriver stream info too small!"));

            DEBUG_BREAKPOINT();
            SRB->HwSRB.Status = STATUS_REVISION_MISMATCH;

            //
            // if this is not a rescan, uninitialize
            //

            if (!Rescan) {

                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
            }
            return (SCProcessCompletedRequest(SRB));
        }
        if (NumberOfPins) {

            //
            // parse the minidriver's info into CSA format to build the
            // mother of all structures.
            //

            PinSize = (sizeof(KSPIN_DESCRIPTOR) + sizeof(STREAM_ADDITIONAL_INFO)) * NumberOfPins;

            PinDescs = ExAllocatePool(NonPagedPool,
                                      PinSize);
            if (PinDescs == NULL) {
                DebugPrint((DebugLevelError,
                            "DecoderClassInit: No pool for stream info"));

                SRB->HwSRB.Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // if this is not a rescan, uninitialize
                //

                if (!Rescan) {
                    SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                             SRB->HwSRB.Irp);
                }
                return (SCProcessCompletedRequest(SRB));
            }
            RtlZeroMemory(PinDescs, PinSize);

            //
            // we need a new array to hold the new copies of the
            // stream properties and events which are allocated below.
            //

            NewStreamArray = (PSTREAM_ADDITIONAL_INFO) ((ULONG_PTR) PinDescs + sizeof(KSPIN_DESCRIPTOR) * NumberOfPins);

            DeviceExtension->StreamPropEventArray = NewStreamArray;

            CurrentInfo = &StreamDescriptor->StreamInfo;

            for (i = 0; i < StreamDescriptor->StreamHeader.NumberOfStreams; i++) {


                PinDescs[i].InterfacesCount = SIZEOF_ARRAY(PinInterfaces);
                PinDescs[i].Interfaces = PinInterfaces;

                //
                // use default medium if minidriver does not specify
                //

                if (CurrentInfo->MediumsCount) {

                    PinDescs[i].MediumsCount = CurrentInfo->MediumsCount;
                    PinDescs[i].Mediums = CurrentInfo->Mediums;

                } else {

                    PinDescs[i].MediumsCount = SIZEOF_ARRAY(PinMediums);
                    PinDescs[i].Mediums = PinMediums;

                }               // if minidriver mediums

                //
                // set the # of data format blocks
                //

                PinDescs[i].DataRangesCount =
                    CurrentInfo->NumberOfFormatArrayEntries;

                //
                // point to the data format blocks for the pin
                //

                PinDescs[i].DataRanges = CurrentInfo->StreamFormatsArray;

                //
                // set the data flow direction
                //

                PinDescs[i].DataFlow = (KSPIN_DATAFLOW) CurrentInfo->DataFlow;

                //
                // set the communication field
                //

                if (CurrentInfo->BridgeStream) {

                    PinDescs[i].Communication = KSPIN_COMMUNICATION_BRIDGE;

                } else {

					#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
                    PinDescs[i].Communication = KSPIN_COMMUNICATION_BOTH;
					#else
                    PinDescs[i].Communication = KSPIN_COMMUNICATION_SINK;
					#endif
                }

                //
                // copy the pointers for the pin name and category
                //

                PinDescs[i].Category = CurrentInfo->Category;
                PinDescs[i].Name = CurrentInfo->Name;


                if ((!Rescan) && (CurrentInfo->NumStreamPropArrayEntries)) {

                    ASSERT(CurrentInfo->StreamPropertiesArray);

                    //
                    // make a copy of the properties since we modify the struct
                    // though parts of it may be marked as a const.
                    // Performance Improvement Chance
                    //   - check for const in future if possible
                    //

                    if (!(NewStreamArray[i].StreamPropertiesArray = SCCopyMinidriverProperties(CurrentInfo->NumStreamPropArrayEntries,
                                     CurrentInfo->StreamPropertiesArray))) {


                        SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                                 SRB->HwSRB.Irp);
                        return (SCProcessCompletedRequest(SRB));
                    }
                }
                if ((!Rescan) && (CurrentInfo->NumStreamEventArrayEntries)) {

                    ASSERT(CurrentInfo->StreamEventsArray);

                    //
                    // make a copy of the events since we modify the struct
                    // though parts of it may be marked as a const.
                    // Performance Improvement Chance:
                    //   - check for const in future if possible
                    //

                    if (!(NewStreamArray[i].StreamEventsArray = SCCopyMinidriverEvents(CurrentInfo->NumStreamEventArrayEntries,
                                         CurrentInfo->StreamEventsArray))) {


                        SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                                 SRB->HwSRB.Irp);
                        return (SCProcessCompletedRequest(SRB));
                    }
                }
                //
                // update the minidriver's properties for this stream.
                //

                SCUpdateMinidriverProperties(
                                     CurrentInfo->NumStreamPropArrayEntries,
                                    NewStreamArray[i].StreamPropertiesArray,
                                             TRUE);

                //
                // update the minidriver's events for this stream.
                //

                SCUpdateMinidriverEvents(
                                    CurrentInfo->NumStreamEventArrayEntries,
                                         NewStreamArray[i].StreamEventsArray,
                                         TRUE);


                //
                // index to next streaminfo structure.
                //

                CurrentInfo++;


            }                   // for # pins

        }                       // if pins
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevPropArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DevicePropertiesArray);

            //
            // make a copy of the properties since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance:
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->DevicePropertiesArray =
                  SCCopyMinidriverProperties(StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                   StreamDescriptor->StreamHeader.DevicePropertiesArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevEventArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DeviceEventsArray);

            //
            // make a copy of the events since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->EventInfo =
                  SCCopyMinidriverEvents(StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                       StreamDescriptor->StreamHeader.DeviceEventsArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }

		#ifdef ENABLE_KS_METHODS
        //
        // process the device methods
        //
        if ((!Rescan) && (StreamDescriptor->StreamHeader.NumDevMethodArrayEntries)) {

            ASSERT(StreamDescriptor->StreamHeader.DeviceMethodsArray);

            //
            // make a copy of the properties since we modify the struct
            // though parts of it may be marked as a const.
            // Performance Improvement Chance
            //   - check for const in future if possible
            //

            if (!(DeviceExtension->DeviceMethodsArray =
                  SCCopyMinidriverMethods(StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                   StreamDescriptor->StreamHeader.DeviceMethodsArray))) {


                SCUninitializeMinidriver(DeviceExtension->DeviceObject,
                                         SRB->HwSRB.Irp);
                return (SCProcessCompletedRequest(SRB));
            }
        }
		#endif
  
        //
        // process the minidriver's device properties.
        //

        SCUpdateMinidriverProperties(
                      StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
                                     DeviceExtension->DevicePropertiesArray,
                                     FALSE);


        //
        // process the minidriver's device events.
        //

        SCUpdateMinidriverEvents(
                     StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
                                 DeviceExtension->EventInfo,
                                 FALSE);

		#ifdef ENABLE_KS_METHODS
        //
        // process the minidriver's device methods.
        //

        SCUpdateMinidriverMethods(
                     StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
                                 DeviceExtension->DeviceMethodsArray,
                                 FALSE);
		#endif

        //
        // set the event info count in the device extension
        //

        DeviceExtension->EventInfoCount = StreamDescriptor->StreamHeader.NumDevEventArrayEntries;

        DeviceExtension->HwEventRoutine = StreamDescriptor->StreamHeader.DeviceEventRoutine;

        //
        // call routine to save new stream info
        //

        SCInsertStreamInfo(DeviceExtension,
                		   PinDescs,
                           StreamDescriptor,
                           NumberOfPins);


        if (!Rescan) {

            //
            // show device is started from PNP's perspective
            //            

            DeviceExtension->Flags |= DEVICE_FLAGS_PNP_STARTED;

            //
            // create the symbolic link to the device.
            //

            if ( !(DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD )) {
                //
                // Don't create symbolic link if loaded by SWEnum which
                // will create a duplicate one.
                //
                // create the symbolic link to the device.
                //

                SCCreateSymbolicLinks(DeviceExtension);
            }

            //
            // call the minidriver to indicate that initialization is
            // complete.
            //


            SCSubmitRequest(SRB_INITIALIZATION_COMPLETE,
                            NULL,
                            0,
                            SCDequeueAndDeleteSrb,
                            DeviceExtension,
                            NULL,
                            NULL,
                            SRB->HwSRB.Irp,
                            &RequestIssued,
                            &DeviceExtension->PendingQueue,
                            (PVOID) DeviceExtension->
                            MinidriverData->HwInitData.
                            HwReceivePacket
                );


            //
            // tell the device to power down now, since it is not yet opened.
            // acquire the control event since this routine needs it.

            KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // not alertable
                                  NULL);

            SCCheckPowerDown(DeviceExtension);

        }                       // if !rescan
        //
        // release the event. if we are doing a rescan, this is taken
        // by the caller.  If not, we took it a few lines above.
        //

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    }                           // if good status
    //
    // complete this SRB and the original IRP with the final
    // status.
    //

    return (SCProcessCompletedRequest(SRB));

}

VOID
SCInsertStreamInfo(
                   IN PDEVICE_EXTENSION DeviceExtension,
                   IN PKSPIN_DESCRIPTOR PinDescs,
                   IN PHW_STREAM_DESCRIPTOR StreamDescriptor,
                   IN ULONG NumberOfPins
)
/*++

Routine Description:

Arguments:

Return Value:

     None.

--*/

{
    PAGED_CODE();

    //
    // save the pin info in the dev extension
    //

    if (DeviceExtension->PinInformation) {

        ExFreePool(DeviceExtension->PinInformation);
    }
    DeviceExtension->PinInformation = PinDescs;
    DeviceExtension->NumberOfPins = NumberOfPins;

    //
    // save the minidriver's descriptor also.
    //

    if (DeviceExtension->StreamDescriptor) {

        ExFreePool(DeviceExtension->StreamDescriptor);
    }
    DeviceExtension->StreamDescriptor = StreamDescriptor;

    return;

}

#endif //ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCPowerCallback(
                IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     SRB callback procedure for powering down the hardware

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    NTSTATUS        Status = SRB->HwSRB.Status;
    PIRP            Irp = SRB->HwSRB.Irp;

    PAGED_CODE();

    if ( (NT_SUCCESS(Status)) || 
        (Status == STATUS_NOT_IMPLEMENTED) || 
        (Status == STATUS_NOT_SUPPORTED)) {

        //
        // set the new power state in the device extension.
        //
        SCSetCurrentDPowerState (DeviceExtension, SRB->HwSRB.CommandData.DeviceState);

        //
        // free our SRB structure
        //

        SCDequeueAndDeleteSrb(SRB);

        //
        // set status to SUCCESS in case the minidriver didn't.
        //

        Status = STATUS_SUCCESS;

        //
        // if the state is NOT a power up, we must now send it to the PDO
        // for postprocessing.
        //

        if (DeviceExtension->CurrentPowerState != PowerDeviceD0) {

            //
            // send the Irp down to the next layer, and return that status
            // as the final one.
            //

            Status = SCCallNextDriver(DeviceExtension, Irp);

			#if DBG
            if (!NT_SUCCESS(Status)) {

                DebugPrint((DebugLevelError, "'SCPowerCB: PDO failed power request!\n"));
            }
			#endif

        }
        PoStartNextPowerIrp(Irp);
        SCCompleteIrp(Irp, Status, DeviceExtension);

    } else {

        DEBUG_BREAKPOINT();

        //
        // complete the request with error
        //

        PoStartNextPowerIrp(Irp);
        SCProcessCompletedRequest(SRB);

    }

    return (Status);
}


NTSTATUS
SCUninitializeMinidriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp)
/*++

Routine Description:

    This function calls the minidriver's HWUninitialize routine.  If
    successful, all adapter resources are freed, and the adapter is marked
    as stopped.

Arguments:

    DeviceObject - pointer to device object for adapter
    Irp - pointer to the PNP Irp.

Return Value:

     NT status code is returned.

--*/

{
    PHW_INITIALIZATION_DATA HwInitData;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    //
    // call minidriver to indicate we are uninitializing.
    //

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // remove the symbolic links for the device
    //

    SCDestroySymbolicLinks(DeviceExtension);

    //
    // show one less I/O on this call since our wait logic won't
    // finish until the I/O count goes to zero.
    //

    InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

    //
    // wait for any outstanding I/O to complete
    //

    SCWaitForOutstandingIo(DeviceExtension);
    
    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
    // release event at the callback. or next if !RequestIssued.
        
    //
    // restore I/O count to one as we have the PNP I/O outstanding.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    HwInitData = &DeviceExtension->MinidriverData->HwInitData;

    Status = SCSubmitRequest(SRB_UNINITIALIZE_DEVICE,
                             NULL,
                             0,
                             SCUninitializeCallback,
                             DeviceExtension,
                             NULL,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }                             
                             
    return (Status);

}


NTSTATUS
SCUninitializeCallback(
                       IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

    SRB callback procedure for uninitialize

Arguments:

    SRB - pointer to the uninitialize SRB

Return Value:

     NT status code is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status = SRB->HwSRB.Status;

    PAGED_CODE();

    //
    // free all adapter resources we allocated on the START
    // function if the minidriver did not fail
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);


    if (Status != STATUS_ADAPTER_HARDWARE_ERROR) {

        //
        // show not started
        //

        DeviceExtension->Flags &= ~DEVICE_FLAGS_PNP_STARTED;

        //
        // free all resources on our device.
        //

        SCFreeAllResources(DeviceExtension);

    }                           // if hwuninitialize
    //
    // free the SRB but don't call back the IRP.
    //

    SCDequeueAndDeleteSrb(SRB);

    return (Status);
}

PVOID
StreamClassGetDmaBuffer(
                        IN PVOID HwDeviceExtension)
/*++

Routine Description:

     This function returns the DMA buffer previously allocated.


Arguments:

    HwDeviceExtension - Supplies a pointer to the minidriver's device extension.

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    return (DeviceExtension->DmaBuffer);
}



NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Entry point for explicitely loaded stream class.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

   STATUS_SUCCESS

--*/
{

    UNREFERENCED_PARAMETER(DriverObject);
    PAGED_CODE();
    DEBUG_BREAKPOINT();
    return STATUS_SUCCESS;
}

#if DBG

#define DEFAULT_STREAMDEBUG     1
#define DEFAULT_MAX_LOG_ENTRIES 1024
#define SCLOG_LEVEL             0
#define SCLOG_MASK              0
#define SCLOG_FL_PNP            0x0001

#define STR_REG_DBG_STREAM L"\\Registry\\Machine\\system\\currentcontrolset\\services\\stream"

typedef struct _SCLOG_ENTRY {
    ULONG ulTag;
    ULONG ulArg1;
    ULONG ulArg2;
    ULONG ulArg3;
} SCLOG_ENTRY, *PSCLOG_ENTRY;

PSCLOG_ENTRY psclogBuffer;
ULONG scLogNextEntry;
ULONG scMaxLogEntries;
ULONG sclogMask;
ULONG ulTimeIncrement;

NTSTATUS
SCLog(
	ULONG ulTag,
	ULONG ulArg1,
	ULONG ulArg2,
	ULONG ulArg3 )
/*++
	Description:
	    Log the information to the psclogBuffer in a circular mannar. Start from entry 0.
    	Wrap around when we hit the end.

    Parameters:
        ulTag: Tag for the log entry
        ulArg1: argument 1
        ulArg2: argument 2
        ulArg3: argument 3

    Return:
        SUCCESS: if logged
        UNSUCCESSFUL: otherwise

--*/
{
    NTSTATUS Status=STATUS_UNSUCCESSFUL;
	ULONG ulMyLogEntry;

	if ( NULL == psclogBuffer ) return Status;

    //
    // grab the line ticket
    //
	ulMyLogEntry = (ULONG)InterlockedIncrement( &scLogNextEntry );
	//
	// land in the range
	//
	ulMyLogEntry = ulMyLogEntry % scMaxLogEntries;

    //
    // fill the entry
    //
	psclogBuffer[ulMyLogEntry].ulTag = ulTag;
	psclogBuffer[ulMyLogEntry].ulArg1 = ulArg1;
	psclogBuffer[ulMyLogEntry].ulArg2 = ulArg2;
	psclogBuffer[ulMyLogEntry].ulArg3 = ulArg3;

	if ( sclogMask & SCLOG_FLAGS_PRINT)  {
		char *pCh=(char*) &ulTag;
		DbgPrint( "++scLOG %c%c%c%c %08x %08x %08x\n", 
				 pCh[0], pCh[1], pCh[2], pCh[3],
				 ulArg1,
				 ulArg2,
				 ulArg3);
	}
	return STATUS_SUCCESS;
}

NTSTATUS SCLogWithTime(
    ULONG ulTag,
    ULONG ulArg1,
    ULONG ulArg2 )
/*++
    Description:
        A wrapper to SCLog to also log time in ms in the record. We can have one less
        Argument because time use 1.

    Parameters:
        ulTag: Tag for the log entry
        ulArg1: argument 1
        ulArg2: argument 2

    Return:
        SUCCESS: if logged
        UNSUCCESSFUL: otherwise

--*/
{
    LARGE_INTEGER liTime;
    ULONG ulTime;


    KeQueryTickCount(&liTime);
	ulTime = (ULONG)(liTime.QuadPart*ulTimeIncrement/10000); // convert to ms
    
    if ( NULL == psclogBuffer ) return STATUS_UNSUCCESSFUL;
    return SCLog( ulTag, ulArg1, ulArg2, ulTime );
}

NTSTATUS
DbgDllUnload()
/*++
    called by DllUnload to undo the work at DllInitialize

--*/
{
    if ( NULL != psclogBuffer ) {
        ExFreePool( psclogBuffer );
    }

    return STATUS_SUCCESS;
}



NTSTATUS
SCGetRegValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    Copied from IopGetRegistryValue().
    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

NTSTATUS
SCGetRegDword(
    HANDLE h,
    PWCHAR ValueName,
    PULONG pDword)
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION pFullInfo;

    Status = SCGetRegValue( h, ValueName, &pFullInfo );
    if ( NT_SUCCESS( Status ) ) {
        *pDword = *(PULONG)((PUCHAR)pFullInfo+pFullInfo->DataOffset);
        ExFreePool( pFullInfo );
    }
    return Status;
}

NTSTATUS
SCSetRegDword(
    IN HANDLE KeyHandle,
    IN PWCHAR ValueName,
    IN ULONG  ValueData
    )

/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) 
type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the name of the value key

    ValueData - Supplies a pointer to the value to be stored in the key.  

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    ASSERT(ValueName);

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Set the registry value
    //
    Status = ZwSetValueKey(KeyHandle,
                    &unicodeString,
                    0,
                    REG_DWORD,
                    &ValueData,
                    sizeof(ValueData));
    
    return Status;
}


NTSTATUS
SCCreateDbgReg(void)
{
    NTSTATUS Status;
    HANDLE   hStreamDebug;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING  PathName;
    UNICODE_STRING  uiStreamDebug;
    ULONG ulDisposition;
    ULONG dword;
    static WCHAR strStreamDebug[]=L"StreamDebug";
    static WCHAR strMaxLogEntries[]=L"MaxLogEntries";
    static WCHAR strLogMask[]=L"MaxMask";

    RtlInitUnicodeString( &PathName, STR_REG_DBG_STREAM );
    
    InitializeObjectAttributes(&objectAttributes,
                                &PathName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    
    Status = ZwCreateKey( &hStreamDebug,
                            KEY_ALL_ACCESS,
                            &objectAttributes,
                            0, // title index
                            NULL, // class
                            0,// create options
                            &ulDisposition);

    if ( NT_SUCCESS( Status )) {
        //
        // getset StreamDebug
        //
        Status = SCGetRegDword( hStreamDebug, strStreamDebug, &dword);
        if ( NT_SUCCESS( Status )) {
            extern ULONG StreamDebug;
            StreamDebug = dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = SCSetRegDword(hStreamDebug, strStreamDebug, DEFAULT_STREAMDEBUG);
            ASSERT( NT_SUCCESS( Status ));
        }

        //
        // getset LogMask
        //        
        Status = SCGetRegDword( hStreamDebug, strLogMask, &dword);
        if ( NT_SUCCESS( Status )) {
            sclogMask=dword;
        }
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default to all ( 0x7fffffff )
            //
            Status = SCSetRegDword(hStreamDebug, strLogMask, 0x7fffffff);
            ASSERT( NT_SUCCESS( Status ));
        }        
        
        //
        // getset MaxLogEntries
        //
        Status = SCGetRegDword( hStreamDebug, strMaxLogEntries, &dword);
        if ( NT_SUCCESS( Status )) {
            scMaxLogEntries=dword;
        }
        
        else if ( STATUS_OBJECT_NAME_NOT_FOUND == Status ) {
            //
            // create one with the default value
            //
            Status = SCSetRegDword(hStreamDebug, strMaxLogEntries, DEFAULT_MAX_LOG_ENTRIES);
            ASSERT( NT_SUCCESS( Status ));
        }

        ZwClose( hStreamDebug );
    }

    return Status;
}

NTSTATUS
SCInitDbg( 
    void )
{
    NTSTATUS Status;
    

    Status = SCCreateDbgReg(); // read or create

    if ( NT_SUCCESS( Status ) ) {
        if ( scMaxLogEntries ) {
            psclogBuffer = ExAllocatePool( NonPagedPool, scMaxLogEntries*sizeof(SCLOG_ENTRY));            
            if ( NULL == psclogBuffer ) {
                DbgPrint( "SC: Cant allocate log buffer for %d entries\n", scMaxLogEntries );
                sclogMask = 0; // disable logging
            }
            else {
                DbgPrint( "SC: Allocate log buffer for %d entries\n", scMaxLogEntries );
                ulTimeIncrement = KeQueryTimeIncrement();
            }
        }
    }
    return Status;
}


#endif // DBG

NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
/*++
Description:
    System invokes this entry point when it load the image in memory.

Arguments:
    RegistryPath - unreferenced parameter.

Return:
    STATUS_SUCCESS or appropriate error code.        
--*/
{
    //UNICODE_STRING DriverName;
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();

    #if DBG
    Status = SCInitDbg();
    #endif 
    //RtlInitUnicodeString(&DriverName, STREAM_DRIVER_NAME);
    //Status = IoCreateDriver(&DriverName, StreamDriverEntry);
        
    if(!NT_SUCCESS(Status)){
        DbgPrint("Stream DLL Initialization failed = %x\n",Status);
        ASSERT(FALSE);        
    }
    return Status;
}


VOID
SCFreeAllResources(
    IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    This functions deletes all of the storage associated with a device
    extension, disconnects from the timers and interrupts.
    This function can be called any time during the initialization.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{

    PMAPPED_ADDRESS tempPointer;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo;
    PADAPTER_OBJECT DmaAdapterObject;
    ULONG           DmaBufferSize;
    ULONG           i;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCFreeAllResources: enter\n"));

    //
    // take the event to avoid race with the CLOSE handler, which is
    // the only code that will be executed at this point since the
    // INACCESSIBLE bit has been set.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // if an interrupt is in use, disconnect from it.
    //

    if ((DeviceExtension->InterruptObject != (PKINTERRUPT) DeviceExtension) &&
        (DeviceExtension->InterruptObject != NULL)) {

        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: Interrupt Disconnect\n"));
        IoDisconnectInterrupt(DeviceExtension->InterruptObject);

        //
        // change the synchronization mechanism to internal, since
        // the IRQ is gone away, hence IRQL level sync.
        //

        DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;
        DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

    }
    //
    // Free the configuration information structure if it exists.
    //

    ConfigInfo = DeviceExtension->ConfigurationInformation;
    if (ConfigInfo) {

        //
        // free the access range structure if it exists
        //

        if (ConfigInfo->AccessRanges) {
            ExFreePool(ConfigInfo->AccessRanges);
        }
        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: freeing ConfigurationInfo\n"));
        ExFreePool(ConfigInfo);
        DeviceExtension->ConfigurationInformation = NULL;
    }
    //
    // free the DMA adapter object and DMA buffer if present
    //

    DmaAdapterObject = DeviceExtension->DmaAdapterObject;


    if (DmaAdapterObject) {

        DmaBufferSize = DeviceExtension->DriverInfo->HwInitData.DmaBufferSize;

        if (DeviceExtension->DmaBufferPhysical.QuadPart) {

            //
            // free the DMA buffer
            //

            DebugPrint((DebugLevelVerbose, "'StreamClass SCFreeAllResources- Freeing DMA stuff\n"));
            HalFreeCommonBuffer(DmaAdapterObject,
                                DmaBufferSize,
                                DeviceExtension->DmaBufferPhysical,
                                DeviceExtension->DmaBuffer,
                                FALSE);
        }
        DeviceExtension->DmaAdapterObject = NULL;
    }
    //
    // Unmap any mapped areas.
    //

    while (DeviceExtension->MappedAddressList != NULL) {
        DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: unmapping addresses\n"));
        MmUnmapIoSpace(
                       DeviceExtension->MappedAddressList->MappedAddress,
                       DeviceExtension->MappedAddressList->NumberOfBytes
            );

        tempPointer = DeviceExtension->MappedAddressList;
        DeviceExtension->MappedAddressList =
            DeviceExtension->MappedAddressList->NextMappedAddress;

        ExFreePool(tempPointer);
    }

    DeviceExtension->MappedAddressList = NULL;

	//
	// We can't free FilterInstances or PinInstances. They
	// must be freed at close calls. However, release StreamDescriptor
	// which is allocated at Start device
	//
    if ( DeviceExtension->StreamDescriptor ) {
        ExFreePool( DeviceExtension->StreamDescriptor );
        DeviceExtension->StreamDescriptor = NULL;
    }
	
    //
    // Stop our timers and release event.
    //

    IoStopTimer(DeviceExtension->DeviceObject);
    KeCancelTimer(&DeviceExtension->ComObj.MiniDriverTimer);

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
}


#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SciFreeFilterInstance(
    PFILTER_INSTANCE pFilterInstance
)
/*++

    Free all resources associated with a FilterInstance and the filter
    instance itself. This function assume Device control event is taken
    by the caller.

    Argument:

        pFilterInstance : pointer to the filter instance to free

    Return:

        NTSTATUS: STATUS_SUCCESS of successful, error otherwise

--*/
{
    PDEVICE_EXTENSION       pDeviceExtension;
    PSTREAM_ADDITIONAL_INFO NewStreamArray;
    ULONG                   i;

    ASSERT_FILTER_INSTANCE( pFilterInstance );
    
    pDeviceExtension = pFilterInstance->DeviceExtension;

    ASSERT_DEVICE_EXTENSION( pDeviceExtension );


    NewStreamArray = pFilterInstance->StreamPropEventArray;
    pFilterInstance->StreamPropEventArray = NULL;

    DebugPrint((DebugLevelInfo,
               "Freeing filterinstance %x\n", pFilterInstance));

    while (!IsListEmpty( &pFilterInstance->FirstStream )) {

        //
        // free all stream instances
        //
        PLIST_ENTRY         Node;
        PSTREAM_OBJECT  StreamObject;

        DebugPrint((DebugLevelWarning,
                   "Freeing filterinstance %x still open streams\n", pFilterInstance));
        
        Node = RemoveHeadList( &pFilterInstance->FirstStream );

        StreamObject = CONTAINING_RECORD(Node,
                                         STREAM_OBJECT,
                                         NextStream);

        if ( NULL != StreamObject->ComObj.DeviceHeader )                                             {
            KsFreeObjectHeader( StreamObject->ComObj.DeviceHeader );
        }

        //
        // null out FsContext for "surprise" stop cases
        //
        ASSERT( StreamObject->FileObject );
        ASSERT( StreamObject->FileObject->FsContext );
        StreamObject->FileObject->FsContext = NULL;
        ExFreePool( StreamObject );
    }
		    
    if (pFilterInstance->StreamDescriptor) {

        //
   	    // free each of the property buffers for the pins
       	//

        DebugPrint((DebugLevelInfo,
                    "FI StreamDescriptor %x has %x pins\n",
                    pFilterInstance->StreamDescriptor,
                    pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams));

        for (i = 0;
	       	 i < pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams;
	       	 i++) {

	        if (NewStreamArray[i].StreamPropertiesArray) {
	        
   	        	DebugPrint((DebugLevelInfo,"\tFree pin %x Prop %x\n",
   	        	            i, NewStreamArray[i].StreamPropertiesArray));
    	        ExFreePool(NewStreamArray[i].StreamPropertiesArray);
        	}
        	
	        if (NewStreamArray[i].StreamEventsArray) {
   	        	DebugPrint((DebugLevelInfo,"\tFree pin %x event %x\n",
   	                       i, NewStreamArray[i].StreamEventsArray));
	    	    ExFreePool(NewStreamArray[i].StreamEventsArray);
    	    } 
    	}

	    if (pFilterInstance->DevicePropertiesArray) {
	    
        	DebugPrint((DebugLevelInfo,"Free dev prop %x\n",
   	    	            pFilterInstance->DevicePropertiesArray));
            ExFreePool(pFilterInstance->DevicePropertiesArray);
            pFilterInstance->DevicePropertiesArray = NULL;

	    }
	     
	    if (pFilterInstance->EventInfo) {
	     
            DebugPrint((DebugLevelInfo,"Free dev Event %x\n",
   	                   pFilterInstance->EventInfo));	    	    
    	    ExFreePool(pFilterInstance->EventInfo);
	    	pFilterInstance->EventInfo = NULL;
    	}

        //
    	// always allocate, always free
        //
        DebugPrint((DebugLevelInfo,"Free StreamDescriptor %x\n",
	               pFilterInstance->StreamDescriptor));
	                   
        ExFreePool(pFilterInstance->StreamDescriptor);
    	pFilterInstance->StreamDescriptor = NULL;
    }
    
	if (pFilterInstance->PinInformation) {
	
        DebugPrint((DebugLevelInfo,"Free pininformationn %x\n",
   	              		            pFilterInstance->PinInformation));
    	ExFreePool(pFilterInstance->PinInformation);
	    pFilterInstance->PinInformation = NULL;
	 }

	 if ( NULL != pFilterInstance->DeviceHeader ) {
	    KsFreeObjectHeader( pFilterInstance->DeviceHeader );
	    pFilterInstance->DeviceHeader = NULL;
	 }

	 if ( pFilterInstance->WorkerRead ) {
    	 KsUnregisterWorker( pFilterInstance->WorkerRead );
    	 pFilterInstance->WorkerRead = NULL;
     }

     if ( pFilterInstance->WorkerWrite ) {
       	 KsUnregisterWorker( pFilterInstance->WorkerWrite );
    	 pFilterInstance->WorkerWrite = NULL;
     }

	 //
	 // finally the pFilterInstance itself.
	 //
	 ExFreePool( pFilterInstance );

	 return STATUS_SUCCESS;
}

VOID
SCDestroySymbolicLinks(
    IN PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

    For all device interfaces of all filter types of a device, disable
    it and free the name list ofeach filter type

Arguments:

    DeviceExtension - pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
    PFILTER_TYPE_INFO   FilterTypeInfo;
    ULONG               i, j;
    UNICODE_STRING      *LinkNames;
    ULONG               LinkNameCount;

    PAGED_CODE();

    for ( i =0; i < DeviceExtension->NumberOfFilterTypes; i++ ) {
    
        LinkNames = DeviceExtension->FilterTypeInfos[i].SymbolicLinks;
        LinkNameCount = DeviceExtension->FilterTypeInfos[i].LinkNameCount;
        //
        // if no names array, we're done.
        //

        if ( NULL == LinkNames ) {
            continue;
        }
        
        //
        // loop through each of the catagory GUID's for each of the pins,
        // deleting the symbolic link for each one.
        //

        for (j = 0; j < LinkNameCount; j++) {

            if (LinkNames[j].Buffer) {

                //
                // Delete the symbolic link, ignoring the status.
                //
                 DebugPrint((DebugLevelVerbose, 
                            " Deleteing symbolic link %S\n",
                            LinkNames[j].Buffer));
                            
                IoSetDeviceInterfaceState(&LinkNames[j], FALSE);

                //
                // free the buffer allocated by
                // IoRegisterDeviceClassAssociation.
                //
                ExFreePool(LinkNames[j].Buffer);
            }
        }

        //
        // free the links structure and null the pointer
        //

        ExFreePool(LinkNames);
        DeviceExtension->FilterTypeInfos[i].SymbolicLinks = NULL;
        
    } // for # of FilterTypes
    
    return;
}

#else // ENABLE_MULTIPLE_FILTER_TYPES

VOID
SCCreateSymbolicLinks(
                      IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
   	PHW_STREAM_DESCRIPTOR StreamDescriptor = DeviceExtension->StreamDescriptor;
   	LPGUID	GuidIndex = (LPGUID) StreamDescriptor->StreamHeader.Topology->Categories;
   	ULONG    ArrayCount = StreamDescriptor->StreamHeader.Topology->CategoriesCount;
	UNICODE_STRING *NamesArray;
    ULONG           i;
    HANDLE          ClassHandle,
                    PdoHandle;
    UNICODE_STRING  TempUnicodeString;
    PVOID           DataBuffer[MAX_STRING_LENGTH];

    PAGED_CODE();

    //
    // allocate space for the array of catagory names
    //

    if (!(NamesArray = ExAllocatePool(PagedPool,
                                    sizeof(UNICODE_STRING) * ArrayCount))) {
        return;
    }
    //
    // zero the array in case we're unable to fill it in below.  the Destroy
    // routine below will then correctly handle this case.
    //

    RtlZeroMemory(NamesArray,
                  sizeof(UNICODE_STRING) * ArrayCount);

    DeviceExtension->SymbolicLinks = NamesArray;


    //
    // open the PDO
    //


    if (!NT_SUCCESS(IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                            PLUGPLAY_REGKEY_DRIVER,
                                            STANDARD_RIGHTS_ALL,
                                            &PdoHandle))) {

        DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't open\n"));
        return;

    }
    //
    // loop through each of the catagory GUID's for each of the pins,
    // creating a symbolic link for each one.
    //

    for (i = 0; i < ArrayCount; i++) {

        //
        // Create the symbolic link
        //

        if (!NT_SUCCESS(IoRegisterDeviceInterface(
                                      DeviceExtension->PhysicalDeviceObject,
                                                  &GuidIndex[i],
                             (PUNICODE_STRING) & CreateItems[0].ObjectClass,
                                                  &NamesArray[i]))) {
            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't register\n"));
            DEBUG_BREAKPOINT();
            return;

        }
        //
        // Now set the symbolic link for the association
        //

        if (!NT_SUCCESS(IoSetDeviceInterfaceState(&NamesArray[i], TRUE))) {

            DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
            DEBUG_BREAKPOINT();
            return;

        }
        //
        // add the strings from the PDO's key to the association key.
        // Performance Improvement Chance 
        //   - the INF should be able to directly propogate these;
        // forrest & lonny are fixing.
        //

        if (NT_SUCCESS(IoOpenDeviceInterfaceRegistryKey(&NamesArray[i],
                                                        STANDARD_RIGHTS_ALL,
                                                        &ClassHandle))) {


            //
            // write the class ID for the proxy, if any.
            //

            if (NT_SUCCESS(SCGetRegistryValue(PdoHandle,
                                              (PWCHAR) ClsIdString,
                                              sizeof(ClsIdString),
                                              &DataBuffer,
                                              MAX_STRING_LENGTH))) {


                RtlInitUnicodeString(&TempUnicodeString, ClsIdString);

                ZwSetValueKey(ClassHandle,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              &DataBuffer,
                              MAX_STRING_LENGTH
                    );

            }                   // if cls guid read
            //
            // first check if a friendly name has already been propogated
            // to the class via the INF.   If not, we'll just use the device
            // description string for this.
            //

            if (!NT_SUCCESS(SCGetRegistryValue(ClassHandle,
                                               (PWCHAR) FriendlyNameString,
                                               sizeof(FriendlyNameString),
                                               &DataBuffer,
                                               MAX_STRING_LENGTH))) {


                //
                // write the friendly name for the device, if any.
                //

                if (NT_SUCCESS(SCGetRegistryValue(PdoHandle,
                                                  (PWCHAR) DriverDescString,
                                                  sizeof(DriverDescString),
                                                  &DataBuffer,
                                                  MAX_STRING_LENGTH))) {


                    RtlInitUnicodeString(&TempUnicodeString, FriendlyNameString);

                    ZwSetValueKey(ClassHandle,
                                  &TempUnicodeString,
                                  0,
                                  REG_SZ,
                                  &DataBuffer,
                                  MAX_STRING_LENGTH
                        );


                }               // if cls guid read
            }                   // if !friendly name already
            ZwClose(ClassHandle);

        }                       // if class key opened
    }                           // for # Categories

    ZwClose(PdoHandle);

}


VOID
SCDestroySymbolicLinks(
                       IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

    DeviceExtension - Supplies a pointer to the device extension to be processed.

Return Value:

    None.

--*/
{
    PHW_STREAM_DESCRIPTOR StreamDescriptor = DeviceExtension->StreamDescriptor;

    PAGED_CODE();

    if (StreamDescriptor) {

        ULONG           ArrayCount = StreamDescriptor->StreamHeader.Topology->CategoriesCount;
        UNICODE_STRING *NamesArray;
        ULONG           i;

        //
        // if no names array, we're done.
        //

        if (NULL == DeviceExtension->SymbolicLinks) {

            return;
        }

        NamesArray = DeviceExtension->SymbolicLinks;
        
        //
        // loop through each of the catagory GUID's for each of the pins,
        // deleting the symbolic link for each one.
        //

        for (i = 0; i < ArrayCount; i++) {


            if (NamesArray[i].Buffer) {

                //
                // Delete the symbolic link, ignoring the status.
                //

                IoSetDeviceInterfaceState(&NamesArray[i], FALSE);

                //
                // free the buffer allocated by
                // IoRegisterDeviceClassAssociation.
                //

                ExFreePool(NamesArray[i].Buffer);

            }                   // if buffer
        }                       // for # Categories

        //
        // free the links structure and null the pointer
        //

        ExFreePool(NamesArray);
        DeviceExtension->SymbolicLinks = NULL;

    }                           // if StreamDescriptor
}

#endif // ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
SCSynchCompletionRoutine(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PKEVENT Event
)
/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);

}

NTSTATUS
SCSynchPowerCompletionRoutine(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE DeviceState,
                              IN PVOID Context,
                              IN PIO_STATUS_BLOCK IoStatus
)
/*++

Routine Description:

    This routine is for use with synchronous IRP power processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - power state

    Context - Driver defined context, in our case, an IRP.

    IoStatus - The status of the IRP.

Return Value:

    None.

--*/

{
    PIRP            SystemIrp = Context;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;

    if ( NULL == SystemIrp ) {
    
        //
        // SystemIrp has been completed if it is a Wake Irp
        //
        
        return ( IoStatus->Status );
    }

    IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    //
    // cache the status of the device power irp we sent in the system IRP
    //

    SystemIrp->IoStatus.Status = IoStatus->Status;

    //
    // schedule a worker item to complete processing.   note that we can use
    // a global item since we have not yet issued the PoNextPowerIrp call.
    //

    ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                         SCPowerCompletionWorker,
                         SystemIrp);

    ExQueueWorkItem(&DeviceExtension->PowerCompletionWorkItem,
                    DelayedWorkQueue);

    return (IoStatus->Status);
}

VOID
SCPowerCompletionWorker(
                        IN PIRP SystemIrp
)
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;

    //
    // preset the status to the status of the Device request, which we cached
    // in the system IRP's status field.   We'll override it with the status
    // of the system request if we haven't sent it yet.
    //

    NTSTATUS        Status = SystemIrp->IoStatus.Status;

    PAGED_CODE();

    //
    // if this is a NOT wakeup, we must first pass the request down
    // to the PDO for postprocessing.
    //

    if (IrpStack->Parameters.Power.State.SystemState != PowerSystemWorking) {


        //
        // send down the system power IRP to the next layer.  this routine
        // has a completion routine which does not complete the IRP.
        // preset the status to SUCCESS in this case.
        //

        SystemIrp->IoStatus.Status = STATUS_SUCCESS;
        Status = SCCallNextDriver(DeviceExtension, SystemIrp);

    }
    //
    // indicate that we're ready for the next power IRP.
    //

    PoStartNextPowerIrp(SystemIrp);

    //
    // show one fewer reference to driver.
    //

    SCDereferenceDriver(DeviceExtension);

    //
    // now complete the system power IRP.
    //

    SCCompleteIrp(SystemIrp, Status, DeviceExtension);
}


NTSTATUS
SCBustedSynchPowerCompletionRoutine(
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN UCHAR MinorFunction,
                                    IN POWER_STATE DeviceState,
                                    IN PVOID Context,
                                    IN PIO_STATUS_BLOCK IoStatus
)
/*++

Routine Description:

    (I don't see this can go away) this routine needs to go away
    This routine is for use with synchronous IRP power processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - power state

    Context - Driver defined context, in our case, an event.

    IoStatus - The status of the IRP.

Return Value:

    None.

--*/

{
    PPOWER_CONTEXT  PowerContext = Context;

    PAGED_CODE();

    PowerContext->Status = IoStatus->Status;
    KeSetEvent(&PowerContext->Event, IO_NO_INCREMENT, FALSE);
    return (PowerContext->Status);

}

NTSTATUS
SCCreateChildPdo(
                 IN PVOID PnpId,
                 IN PDEVICE_OBJECT DeviceObject,
                 IN ULONG InstanceNumber
)
/*++

Routine Description:

    Called to create a PDO for a child device.

Arguments:

    PnpId - ID of device to create

    ChildNode - node for the device

Return Value:

    Status is returned.

--*/
{
    PDEVICE_OBJECT  ChildPdo;
    NTSTATUS        Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PCHILD_DEVICE_EXTENSION ChildDeviceExtension;
    PWCHAR          NameBuffer;

    PAGED_CODE();

    //
    // create a PDO for the child device.
    //

    Status = IoCreateDevice(DeviceObject->DriverObject,
                            sizeof(CHILD_DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_UNKNOWN,
                            FILE_AUTOGENERATED_DEVICE_NAME,
                            FALSE,
                            &ChildPdo);                            

    if (!NT_SUCCESS(Status)) {

        DEBUG_BREAKPOINT();
        return Status;
    }
    //
    // set the stack size to be the # of stacks used by the FDO.
    //

    ChildPdo->StackSize = DeviceObject->StackSize+1;

    //
    // Initialize fields in the ChildDeviceExtension.
    //

    ChildDeviceExtension = ChildPdo->DeviceExtension;
    ChildDeviceExtension->ChildDeviceObject = ChildPdo;
    ChildDeviceExtension->Flags |= DEVICE_FLAGS_CHILD;
    ChildDeviceExtension->DeviceIndex = InstanceNumber;
    ChildDeviceExtension->ParentDeviceObject = DeviceObject;


    //
    // create a new string for the device name and save it away in the device
    // extension.   I spent about 4 hours trying to find a way to
    // get unicode strings to work with this.   If you ask me why I didn't
    // use a unicode string, I will taunt you and #%*&# in your general
    // direction.
    //


    if (NameBuffer = ExAllocatePool(PagedPool,
                                    wcslen(PnpId) * 2 + 2)) {


        wcscpy(NameBuffer,
               PnpId);

        //
        // save the device name pointer. this is freed when the device is
        // removed.
        //

        ChildDeviceExtension->DeviceName = NameBuffer;

    }                           // if namebuffer
    //
    // initialize the link and insert this node
    //

    InitializeListHead(&ChildDeviceExtension->ChildExtensionList);

    InsertTailList(
                   &DeviceExtension->Children,
                   &ChildDeviceExtension->ChildExtensionList);

    ChildPdo->Flags |= DO_POWER_PAGABLE;
    ChildPdo->Flags &= ~DO_DEVICE_INITIALIZING;
    return Status;
}

NTSTATUS
SCEnumerateChildren(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
)
/*++

Routine Description:

    Called in the context of an IRP_MN_QUERY_DEVICE_RELATIONS

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PVOID           PnpId;
    PCHILD_DEVICE_EXTENSION ChildDeviceExtension = NULL,
                    CurrentChildExtension;
    PDEVICE_RELATIONS DeviceRelations = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS        Status;
    HANDLE          ParentKey,
                    RootKey,
                    ChildKey;

    UNICODE_STRING  UnicodeEnumName;
    ULONG           NumberOfChildren,
                    RelationsSize;
    PDEVICE_OBJECT *ChildPdo;
    PLIST_ENTRY     ListEntry,
                    ChildEntry;

    PAGED_CODE();

    DebugPrint((DebugLevelInfo,
                "EnumChilds for %x %s\n",
                DeviceObject,
                (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) == 0 ?
                    "1st Time": "has enumed" ));
                    
    if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) ) {
        //
        // we haven't enumerated children from the registry
        // do it now.
        //

        Status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &ParentKey);


        if (!NT_SUCCESS(Status)) {

            DebugPrint((DebugLevelError, "SCEnumerateChildren: couldn't open\n"));
            return STATUS_NOT_IMPLEMENTED;

        }
        //
        // create the subkey for the enum section, in the form "\enum"
        //

        RtlInitUnicodeString(&UnicodeEnumName, EnumString);

        //
        // read the registry to determine if children are present.
        //

        InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeEnumName,
                               OBJ_CASE_INSENSITIVE,
                               ParentKey,
                               NULL);

        if (!NT_SUCCESS(Status = ZwOpenKey(&RootKey, KEY_READ, &ObjectAttributes))) {

            ZwClose(ParentKey);
            return Status;
        }
        
        //
        // allocate a buffer to contain the ID string.  Performance Improvement Chance
        // - this should
        // really get the size and alloc only that size, but I have an existing
        // routine that reads the registry, & this is a temp allocation only.
        //

        if (!(PnpId = ExAllocatePool(PagedPool, MAX_STRING_LENGTH))) {

            ZwClose(RootKey);
            ZwClose(ParentKey);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // Loop through all the values until either no more entries exist, or an
        // error occurs.
        //

        for (NumberOfChildren = 0;; NumberOfChildren++) {

            ULONG           BytesReturned;
            PKEY_BASIC_INFORMATION BasicInfoBuffer;
            KEY_BASIC_INFORMATION BasicInfoHeader;

            //
            // Retrieve the value size.
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                &BasicInfoHeader,
                                sizeof(BasicInfoHeader),
                                &BytesReturned);

            if ((Status != STATUS_BUFFER_OVERFLOW) && !NT_SUCCESS(Status)) {

                //
                // exit the loop, as we either had an error or reached the end
                // of the list of keys.
                //

                break;
            }                       // if error
            //
            // Allocate a buffer for the actual size of data needed.
            //

            BasicInfoBuffer = (PKEY_BASIC_INFORMATION)
                ExAllocatePool(PagedPool,
                           BytesReturned);

            if (!BasicInfoBuffer) {

                break;
            }
            //
            // Retrieve the name of the nth child device
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                BasicInfoBuffer,
                                BytesReturned,
                                &BytesReturned);

            if (!NT_SUCCESS(Status)) {

                ExFreePool(BasicInfoBuffer);
                break;

            }
            //
            // build object attributes for the key, & try to open it.
            //

            UnicodeEnumName.Length = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.MaximumLength = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.Buffer = (PWCHAR) BasicInfoBuffer->Name;

            InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeEnumName,
                                   OBJ_CASE_INSENSITIVE,
                                   RootKey,
                                   NULL);


            if (!NT_SUCCESS(Status = ZwOpenKey(&ChildKey, KEY_READ, &ObjectAttributes))) {

                ExFreePool(BasicInfoBuffer);
                break;
            }
            //
            // we've now opened the key for the child.  We next read in the PNPID
            // value, and if present, create a PDO of that name.
            //

            if (!NT_SUCCESS(Status = SCGetRegistryValue(ChildKey,
                                                    (PWCHAR) PnpIdString,
                                                    sizeof(PnpIdString),
                                                    PnpId,
                                                    MAX_STRING_LENGTH))) {

                ExFreePool(BasicInfoBuffer);
                ZwClose(ChildKey);
                break;
            }

            //
            // create a PDO representing the child.
            //

            Status = SCCreateChildPdo(PnpId,
                                  DeviceObject,
                                  NumberOfChildren);

            //
            // free the Basic info buffer and close the child key
            //

            ExFreePool(BasicInfoBuffer);
            ZwClose(ChildKey);

            if (!NT_SUCCESS(Status)) {

                //
                // break out of the loop if we could not create the
                // PDO
                //

                DEBUG_BREAKPOINT();
                break;
            }                       // if !success
        }                           // for NumberOfChildren

        //
        // close the root and parent keys and free the ID buffer
        //

        ZwClose(RootKey);
        ZwClose(ParentKey);
        ExFreePool(PnpId);

        //
        // has enumed, remember this
        //
        
        DeviceExtension->Flags |= DEVICE_FLAGS_CHILDREN_ENUMED;

        //
        // we now have processed all children, and have a linked list of
        // them.
        //

        if (!NumberOfChildren) {

            //
            // if no children, just return not supported.  this means that the
            // device did not have children.
            //

            return (STATUS_NOT_IMPLEMENTED);

        }                           // if !NumberOfChildren
        
    }
    
    else {
        
        //
        // count children which are not marked delete pending
        //
        ListEntry = ChildEntry = &DeviceExtension->Children;
        NumberOfChildren = 0;
        
        while (ChildEntry->Flink != ListEntry) {

            ChildEntry = ChildEntry->Flink;

            CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
                                                  CHILD_DEVICE_EXTENSION,
                                                  ChildExtensionList );
            if (!(CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)){
                NumberOfChildren++;
            }
        }
    }

    //
    // allocate the device relations buffer.   This will be freed by the
    // caller.
    //

    RelationsSize = sizeof(DEVICE_RELATIONS) +
            (NumberOfChildren * sizeof(PDEVICE_OBJECT));

    DeviceRelations = ExAllocatePool(PagedPool, RelationsSize);

    if (DeviceRelations == NULL) {

        //
        // return, but keep the list of children allocated.
        //

        DEBUG_BREAKPOINT();
        return STATUS_INSUFFICIENT_RESOURCES;

    }                           // if no heap
    RtlZeroMemory(DeviceRelations, RelationsSize);

    //
    // Walk our chain of children, and initialize the relations
    //

    ChildPdo = &(DeviceRelations->Objects[0]);

    //
    // get the 1st child from the parent device extension anchor
    //

    ListEntry = ChildEntry = &DeviceExtension->Children;

    while (ChildEntry->Flink != ListEntry) {

        ChildEntry = ChildEntry->Flink;

        CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
                                                  CHILD_DEVICE_EXTENSION,
                                                  ChildExtensionList);

        DebugPrint((DebugLevelInfo,
                    "Enumed Child DevObj %x%s marked delete\n",
                    CurrentChildExtension->ChildDeviceObject,
                    (CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)==0 ?
                        " not" : ""));

        if ( CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE ) {
            continue;
        }
        
        *ChildPdo = CurrentChildExtension->ChildDeviceObject;

        //
        // per DDK doc we need to inc ref count
        //
        ObReferenceObject( *ChildPdo );
        
        ChildPdo++;

    }                           // while Children


    DeviceRelations->Count = NumberOfChildren;

    //
    // Stuff that pDeviceRelations into the IRP and return SUCCESS.
    //

    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

    return STATUS_SUCCESS;

}


NTSTATUS
SCEnumGetCaps(
              IN PCHILD_DEVICE_EXTENSION DeviceExtension,
              OUT PDEVICE_CAPABILITIES Capabilities
)
/*++

Routine Description:

    Called to get the capabilities of a child

Arguments:

    DeviceExtension - child device extension
    Capibilities - capabilities structure

Return Value:

    Status is returned.

--*/

{
    ULONG           i;
    PAGED_CODE();

    //
    // fill in the structure with non-controversial values
    //

    Capabilities->SystemWake = PowerSystemUnspecified;
    Capabilities->DeviceWake = PowerDeviceUnspecified;
    Capabilities->D1Latency = 10;
    Capabilities->D2Latency = 10;
    Capabilities->D3Latency = 10;
    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = FALSE; // set to false so PNP will make us

    for (i = 0; i < PowerDeviceMaximum; i++) {
        Capabilities->DeviceState[i] = PowerDeviceD0;

    }                           // for i

    return STATUS_SUCCESS;
}


NTSTATUS
SCQueryEnumId(
              IN PDEVICE_OBJECT DeviceObject,
              IN BUS_QUERY_ID_TYPE BusQueryIdType,
              IN OUT PWSTR * BusQueryId
)
/*++

Routine Description:

    Called to get the ID of a child device

Arguments:

    DeviceObject - device object from child
    QueryIdType - ID type from PNP
    BusQueryId - buffer containing the info requested if successful

Return Value:

    Status is returned.

--*/

{


    PUSHORT         NameBuffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    PCHILD_DEVICE_EXTENSION DeviceExtension =
    (PCHILD_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Allocate enough space to hold a MULTI_SZ. This will be passed to the
    // Io
    // subsystem (via BusQueryId) who has the responsibility of freeing it.
    //

    NameBuffer = ExAllocatePool(PagedPool, MAX_STRING_LENGTH);

    if (!NameBuffer) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(NameBuffer, MAX_STRING_LENGTH);

    //
    // process the query
    //

    switch (BusQueryIdType) {

    case BusQueryCompatibleIDs:

        //
        // Pierre tells me I do not need to support compat id.
        //

    default:

        ExFreePool(NameBuffer);
        return (STATUS_NOT_SUPPORTED);

    case BusQueryDeviceID:

        //
        // pierre tells me I can use the same name for both Device &
        // HW ID's.  Note that the buffer we've allocated has been zero
        // inited, which will ensure the 2nd NULL for the Hardware ID.
        //

    case BusQueryHardwareIDs:

        //
        // create the 1st part of the ID, which consists of "Stream\"
        //

        RtlMoveMemory(NameBuffer,
                      L"Stream\\",
                      sizeof(L"Stream\\"));

        //
        // create the 2nd part of the ID, which is the PNP ID from the
        // registry.
        //

        wcscat(NameBuffer, DeviceExtension->DeviceName);
        break;

    case BusQueryInstanceID:

        {

            UNICODE_STRING  DeviceName;
            WCHAR           Buffer[8];

            //
            // convert the instance # from the device extension to unicode,
            // then copy it over to the output buffer.
            //

            DeviceName.Buffer = Buffer;
            DeviceName.Length = 0;
            DeviceName.MaximumLength = 8;

            RtlIntegerToUnicodeString(DeviceExtension->DeviceIndex,
                                      10,
                                      &DeviceName);

            wcscpy(NameBuffer, DeviceName.Buffer);

            break;

        }
    }

    //
    // return the string and good status.
    //

    *BusQueryId = NameBuffer;

    return (Status);
}

NTSTATUS
StreamClassForwardUnsupported(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP Irp
)
/*++

Routine Description:

    This routine forwards unsupported major function calls to the PDO.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS Status;

    PAGED_CODE();

    DeviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;


    DebugPrint((DebugLevelVerbose, "'StreamClassForwardUnsupported: enter\n"));

    if ( !(DeviceExtension->Flags & DEVICE_FLAGS_CHILD)) {

        //
        // show one more reference to driver.
        //
        SCReferenceDriver(DeviceExtension);

        //
        // show one more I/O pending & verify that we can actually do I/O.
        //
        Status = SCShowIoPending(DeviceExtension, Irp);

        if ( !NT_SUCCESS( Status )) {
            //
            // the device is currently not accessible, so just return with error
            //
            Irp->IoStatus.Status= Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return Status;
        }
        
        //
        // synchronouosly call the next driver in the stack.
        //
        SCCallNextDriver(DeviceExtension, Irp);

        //
        // dereference the driver
        //

        SCDereferenceDriver(DeviceExtension);
        //
        // complete the IRP and return status
        //
        return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));
    } else {
        //
        // We are the PDO, return error and complete the Irp
        //
        Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return Status;
    }
}

VOID
SCSendSurpriseNotification(
                           IN PDEVICE_EXTENSION DeviceExtension,
                           IN PIRP Irp
)
/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    BOOLEAN         RequestIssued;

    PAGED_CODE();
    SCSubmitRequest(SRB_SURPRISE_REMOVAL,
                    NULL,
                    0,
                    SCDequeueAndDeleteSrb,
                    DeviceExtension,
                    NULL,
                    NULL,
                    Irp,
                    &RequestIssued,
                    &DeviceExtension->PendingQueue,
                    (PVOID) DeviceExtension->
                    MinidriverData->HwInitData.
                    HwReceivePacket
        );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\millen\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\nt\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\class\upperapi.c ===
/*
Copyright (c) 1996  Microsoft Corporation

Module Name:

   upperapi.c

Abstract:

   This is the WDM streaming class driver.  This module contains code related
   to the driver's upper edge api.

Author:

   billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"
#include "ksguid.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FilterDispatchGlobalCreate)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, StreamDispatchCreate)
#pragma alloc_text(PAGE, StreamDispatchIoControl)
#pragma alloc_text(PAGE, StreamDispatchClose)
#pragma alloc_text(PAGE, ClockDispatchCreate)
#pragma alloc_text(PAGE, ClockDispatchIoControl)
#pragma alloc_text(PAGE, ClockDispatchClose)
#pragma alloc_text(PAGE, StreamClassMinidriverDeviceGetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverDeviceSetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverStreamGetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverStreamSetProperty)
#pragma alloc_text(PAGE, StreamClassNull)
#pragma alloc_text(PAGE, SCStreamDeviceState)
#pragma alloc_text(PAGE, SCStreamDeviceRate)
#pragma alloc_text(PAGE, SCFilterPinInstances)
#pragma alloc_text(PAGE, SCFilterPinPropertyHandler)
#pragma alloc_text(PAGE, SCOpenStreamCallback)
#pragma alloc_text(PAGE, SCOpenMasterCallback)

#if ENABLE_MULTIPLE_FILTER_TYPES
#else
#pragma alloc_text(PAGE, SCGlobalInstanceCallback)
#endif

#pragma alloc_text(PAGE, SCSetMasterClock)
#pragma alloc_text(PAGE, SCClockGetTime)
#pragma alloc_text(PAGE, SCGetStreamDeviceState)
#pragma alloc_text(PAGE, SCStreamDeviceRateCapability)
#pragma alloc_text(PAGE, SCStreamProposeNewFormat)
#pragma alloc_text(PAGE, SCStreamSetFormat)
#pragma alloc_text(PAGE, AllocatorDispatchCreate)
#pragma alloc_text(PAGE, SCGetMasterClock)
#pragma alloc_text(PAGE, SCClockGetPhysicalTime)
#pragma alloc_text(PAGE, SCClockGetSynchronizedTime)
#pragma alloc_text(PAGE, SCClockGetFunctionTable)
#pragma alloc_text(PAGE, SCCloseClockCallback)
#pragma alloc_text(PAGE, SCFilterTopologyHandler)
#pragma alloc_text(PAGE, SCFilterPinIntersectionHandler)
#pragma alloc_text(PAGE, SCIntersectHandler)
#pragma alloc_text(PAGE, SCDataIntersectionCallback)
#pragma alloc_text(PAGE, SCGetStreamHeaderSize)
#pragma alloc_text(PAGE, DllUnload)

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
#pragma alloc_text(PAGE, SCStreamAllocator)
#pragma alloc_text(PAGE, AllocateFrame)
#pragma alloc_text(PAGE, FreeFrame)
#pragma alloc_text(PAGE, PrepareTransfer)
#pragma alloc_text(PAGE, PinCreateHandler)
#endif

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

static const WCHAR ClockTypeName[] = KSSTRING_Clock;
static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;

//
// this structure is the dispatch table for a filter instance of the device
//

DEFINE_KSDISPATCH_TABLE(
                        FilterDispatchTable,
                        FilterDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        FilterDispatchClose,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

//
// dispatch table for pin properties that we support in the class driver
//

static          DEFINE_KSPROPERTY_TABLE(PinPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(SCFilterPinInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(SCFilterPinIntersectionHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(SCFilterPinPropertyHandler),
//  DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(),
//  DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(),
//  DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(SCFilterPinPropertyHandler)
};

static          DEFINE_KSPROPERTY_TOPOLOGYSET(
                                                   TopologyPropertyHandlers,
                                                   SCFilterTopologyHandler);

//
// filter property sets supported by the class driver
//

static          DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Pin,
                          SIZEOF_ARRAY(PinPropertyHandlers),
                          (PKSPROPERTY_ITEM) PinPropertyHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Topology,
                          SIZEOF_ARRAY(TopologyPropertyHandlers),
                          (PKSPROPERTY_ITEM) TopologyPropertyHandlers,
                          0, NULL),
};

//
// handlers for the control properties
//

static          DEFINE_KSPROPERTY_TABLE(StreamControlHandlers)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(SCGetStreamDeviceState, SCStreamDeviceState),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(SCStreamProposeNewFormat),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(NULL, SCStreamSetFormat),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(),
};

DEFINE_KSPROPERTY_TABLE(StreamStreamHandlers)
{
#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(SCStreamAllocator,SCStreamAllocator),
#else
//  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(),
#endif
//  DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(),
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(NULL, SCSetMasterClock),
//  DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(),
        DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(SCStreamDeviceRateCapability),
        DEFINE_KSPROPERTY_ITEM_STREAM_RATE(NULL, SCStreamDeviceRate),
};

DEFINE_KSPROPERTY_TABLE(StreamInterfaceHandlers)
{
    {
        KSPROPERTY_STREAMINTERFACE_HEADERSIZE,
            SCGetStreamHeaderSize,
            0,
            0,
            NULL,
            0,
            0,
            NULL
    }
};

//
// stream property sets supported by the class driver
//

static          DEFINE_KSPROPERTY_SET_TABLE(StreamProperties)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Connection,
                          SIZEOF_ARRAY(StreamControlHandlers),
                          (PVOID) StreamControlHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Stream,
                          SIZEOF_ARRAY(StreamStreamHandlers),
                          (PVOID) StreamStreamHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_StreamInterface,
                          SIZEOF_ARRAY(StreamInterfaceHandlers),
                          (PVOID) StreamInterfaceHandlers,
                          0, NULL),
};

//
// template for on the fly constructed properties
// DO NOT CHANGE without MODIFYING the code that references this set.
//

DEFINE_KSPROPERTY_TABLE(ConstructedStreamHandlers)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(SCGetMasterClock, SCSetMasterClock)
};


//
// template for on-the-fly constructed property sets.
// DO NOT CHANGE without MODIFYING the code that references this set.
//

static          DEFINE_KSPROPERTY_SET_TABLE(ConstructedStreamProperties)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Stream,
                          SIZEOF_ARRAY(ConstructedStreamHandlers),
                          (PVOID) ConstructedStreamHandlers,
                          0, NULL),
};


static const    DEFINE_KSCREATE_DISPATCH_TABLE(StreamDriverDispatch)
{

    DEFINE_KSCREATE_ITEM(ClockDispatchCreate,
                         ClockTypeName,
                         0),
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreate,
                         AllocatorTypeName,
                         0),
};


//
// dispatch table for stream functions
//

DEFINE_KSDISPATCH_TABLE(
                        StreamDispatchTable,
                        StreamDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        StreamDispatchClose,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

DEFINE_KSDISPATCH_TABLE(
                        ClockDispatchTable,
                        ClockDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        ClockDispatchClose,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchFastIoDeviceControlFailure,
                        KsDispatchFastReadFailure,
                        KsDispatchFastWriteFailure);

DEFINE_KSPROPERTY_TABLE(ClockPropertyItems)
{
    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(SCClockGetTime),
        DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(SCClockGetPhysicalTime),
        DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(SCClockGetSynchronizedTime),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(SCClockGetResolution),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(SCClockGetState),
        DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(SCClockGetFunctionTable)
};


DEFINE_KSPROPERTY_SET_TABLE(ClockPropertySets)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Clock,
                          SIZEOF_ARRAY(ClockPropertyItems),
                          ClockPropertyItems,
                          0,
                          NULL
        )
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
FilterDispatchGlobalCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:

    This routine receives global createfile IRP's for the device.

	After the Srb_Open_Device_Instance instance we immediate
	send Srb_Get_Stream_Info for this filter.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/
{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PFILTER_INSTANCE FilterInstance;
    NTSTATUS        Status; // = STATUS_TOO_MANY_OPENED_FILES;

    IFN_MF( PAGED_CODE());

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    DebugPrint((DebugLevelTrace,
                "'Closing global filter with Irp %x\n", Irp));


    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {
        //
        // the device is currently not accessible, so just return with error
        //

        return (Status);

    }                           // if !showiopending
    
    //
    // if the device is not started, bail out.
    // swenum enables device interfaces very early. It should not have
    // done that for the pdo. we, the fdo, should be the one to
    // enable this. for now, try to work around the problem that we
    // come here before device is started.
    //
    if ( DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD ) {
        #define OPEN_TIMEOUT -1000*1000 // 100 mili second
        #define OPEN_WAIT 50
        LARGE_INTEGER liOpenTimeOut;
        int i;

        liOpenTimeOut.QuadPart = OPEN_TIMEOUT;

        for ( i=0; i < OPEN_WAIT; i++ ) {
            if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {
                break;
            }
            KeDelayExecutionThread( KernelMode, FALSE, &liOpenTimeOut );
        }

        if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) ) {
            Status = STATUS_DEVICE_NOT_READY;
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            DebugPrint((DebugLevelError,
                        "SWEnum device %p not ready!\n", DeviceObject));
            return Status;
        }
    }

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);
    
    //
    // set the context of createfiles for the filter
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // Make sure adapter is powered on
    //

    SCCheckPoweredUp(DeviceExtension);

    Status = SCOpenMinidriverInstance(DeviceExtension,
                                      &FilterInstance,
                                      NULL, //SCGlobalInstanceCallback,
                                      Irp);

    //
    // if status != success, we failed so dereference the
    // driver.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // show one fewer reference to driver.
        //
        SCDereferenceDriver(DeviceExtension);
    }

    else {
        //
   	    // Open is successul. Fill in the filter dispatch table pointer
       	//
        
       	if ( 0 == DeviceExtension->NumberOfOpenInstances ||
       	     0 != DeviceExtension->FilterExtensionSize ) {
       	    //
            // 1st open of 1x1 or non 1x1 ( i.e. instance opne )
       		//
       		// add FilterInstance to DeviceExtension except non-1st open of legacy 1x1 
			//		
            PHW_STREAM_DESCRIPTOR StreamDescriptor, StreamDescriptorI;
            ULONG nPins;

            //
            // remeber DO for later
            //
            FilterInstance->DeviceObject = DeviceObject;

			//
			// Process stream info for this filterinstance
			//
			StreamDescriptorI = DeviceExtension->FilterTypeInfos
    			    [FilterInstance->FilterTypeIndex].StreamDescriptor;

    	    nPins = StreamDescriptorI->StreamHeader.NumberOfStreams;
			
            StreamDescriptor = 
                ExAllocatePool(	NonPagedPool,
                    sizeof(HW_STREAM_HEADER) +
                        sizeof(HW_STREAM_INFORMATION) * nPins );

            if ( NULL != StreamDescriptor ) {

                RtlCopyMemory( StreamDescriptor,
                               StreamDescriptorI,
                               sizeof(HW_STREAM_HEADER) +
                                   sizeof(HW_STREAM_INFORMATION) * nPins );

    			    
    			Status = SciOnFilterStreamDescriptor( 
    			                FilterInstance,
    			                StreamDescriptor);

                if ( NT_SUCCESS( Status ) ) {
                    FilterInstance->StreamDescriptor = StreamDescriptor;
                    DebugPrint((DebugLevelInfo,
                               "NumNameExtensions=%x NumopenInstances=%x "
                               "FilterInstance %x StreamDescriptor %x\n",
                               DeviceExtension->NumberOfNameExtensions,
                               DeviceExtension->NumberOfOpenInstances,
                               FilterInstance,
                               StreamDescriptor));
                }
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

		}
		
        DeviceExtension->NumberOfOpenInstances++;        
        DebugPrint((DebugLevelVerbose,
                    "DevExt:%x, Open OpenCount=%x\n", 
                    DeviceExtension,
                    DeviceExtension->NumberOfOpenInstances));

        //
        // Make FilterInstance the File Handle Context
        //
        IrpStack->FileObject->FsContext = FilterInstance;
        DebugPrint((DebugLevelVerbose, 
                    "CreateFilterInstance=%x ExtSize=%x\n",
                    FilterInstance, 
                    DeviceExtension->MinidriverData->HwInitData.FilterInstanceExtensionSize ));

        //
        // Reference the FDO so that itwon't go away before all handles are closed.
        //
        ObReferenceObject(DeviceObject);
    }

    //
    // we're done so release the event
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);



    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}

#else // ENABLE_MULTIPLE_FILTER_TYPES

#endif // ENABLE_MULTIPLE_FILTER_TYPES


NTSTATUS
StreamDispatchCreate(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
)
/*++

Routine Description:

    This routine receives createfile IRP's for a stream.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{

    NTSTATUS        Status;
    PFILTER_INSTANCE FilterInstance;
    PIO_STACK_LOCATION IrpStack;
    PKSPIN_CONNECT  Connect;
    PFILE_OBJECT    FileObject;
    PSTREAM_OBJECT  StreamObject;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    DeviceObject->DeviceExtension;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           i;
    BOOLEAN         RequestIssued;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    DebugPrint((DebugLevelTrace,
                "'Creating stream with Irp %x\n", Irp));

    PAGED_CODE();

    DebugPrint((DebugLevelTrace,"entering StreamDispatchCreate()\n"));

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error1\n"));
        return (Status);

    }

    //
    // get the parent file object from the child object.
    //

    FileObject = IrpStack->FileObject->RelatedFileObject;

    //
    // get the filter instance & additional info pointers
    //

    FilterInstance =
        (PFILTER_INSTANCE) FileObject->FsContext;

    AdditionalInfo = FilterInstance->PinInstanceInfo;
    
    DebugPrint((DebugLevelVerbose,
                    "FilterInstance=%x NumberOfPins=%x PinInfo=%x\n",
                    FilterInstance,
                    FilterInstance->NumberOfPins,
                    FilterInstance->PinInformation));
                    
    Status = KsValidateConnectRequest(Irp,
                                          FilterInstance->NumberOfPins,
                                          FilterInstance->PinInformation,
                                          &Connect);
                                          
    if ( !NT_SUCCESS( Status )) {                                                      

            DebugPrint((DebugLevelError,
                        "exiting StreamDispatchCreate():error2\n"));
            return (SCCompleteIrp(Irp, Status, DeviceExtension));
    }
    
    //
    // take the control event to protect the instance counter
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // if the # of instances for this pin is already opened, error the
    // request.
    //

    DebugPrint((DebugLevelVerbose,
               "AdditionalInfo@%x PinId=%x CurrentInstances=%x Max=%x\n",
               AdditionalInfo, Connect->PinId, 
               AdditionalInfo[Connect->PinId].CurrentInstances,
               AdditionalInfo[Connect->PinId].MaxInstances));
               
    if (AdditionalInfo[Connect->PinId].CurrentInstances ==
        AdditionalInfo[Connect->PinId].MaxInstances) {

        DebugPrint((DebugLevelWarning,
                    "StreamDispatchCreate: too many opens "));
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error3\n"));
        return (SCCompleteIrp(Irp, STATUS_TOO_MANY_OPENED_FILES, DeviceExtension));
    }
    //
    // initialize the stream object for this instance
    //

    StreamObject = ExAllocatePool(NonPagedPool,
                                  sizeof(STREAM_OBJECT) +
                                  DeviceExtension->MinidriverData->
                                  HwInitData.PerStreamExtensionSize
        );

    if (!StreamObject) {
        DebugPrint((DebugLevelError,
                    "StreamDispatchCreate: No pool for stream info"));

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error4\n"));
        return (SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension));
    }
    RtlZeroMemory(StreamObject,
                  sizeof(STREAM_OBJECT) +
                  DeviceExtension->MinidriverData->
                  HwInitData.PerStreamExtensionSize
        );

    //
    // TODO: Remove this once KS can multiplex CLEANUP requests.
    //
    StreamObject->ComObj.Cookie = STREAM_OBJECT_COOKIE;

    //
    // default state to stopped
    //

    StreamObject->CurrentState = KSSTATE_STOP;

    KsAllocateObjectHeader(&StreamObject->ComObj.DeviceHeader,
                           SIZEOF_ARRAY(StreamDriverDispatch),
                           (PKSOBJECT_CREATE_ITEM) StreamDriverDispatch,
                           Irp,
                           (PKSDISPATCH_TABLE) & StreamDispatchTable);

    StreamObject->HwStreamObject.StreamNumber = Connect->PinId;
    StreamObject->FilterFileObject = FileObject;
    StreamObject->FileObject = IrpStack->FileObject;
    StreamObject->FilterInstance = FilterInstance;
    StreamObject->DeviceExtension = DeviceExtension;

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    StreamObject->PinToHandle = Connect->PinToHandle;
    #endif

    KeInitializeEvent (&StreamObject -> StopEvent, SynchronizationEvent, FALSE);

    //
    // For potential "source" pins, don't start sourcing standard 
    // medium/interface stream requests across non-standard medium/interfaces.
    //
    if (!IsEqualGUIDAligned (&Connect->Medium.Set, &KSMEDIUMSETID_Standard) ||
        !IsEqualGUIDAligned (&Connect->Interface.Set, &KSINTERFACESETID_Standard)) {
        StreamObject->StandardTransport = FALSE;
    } else {
        StreamObject -> StandardTransport = TRUE;
    }

    //
    // set the minidriver's parameters in the HwStreamObject struct.
    //

    StreamObject->HwStreamObject.SizeOfThisPacket = sizeof(HW_STREAM_OBJECT);

    StreamObject->HwStreamObject.HwDeviceExtension =
        DeviceExtension->HwDeviceExtension;

    StreamObject->HwStreamObject.HwStreamExtension =
        (PVOID) (StreamObject + 1);

    //
    // walk the minidriver's stream info structure to find the properties
    // for this stream.
    //

    
    if ( NULL == FilterInstance->StreamDescriptor ) {
        //
        // has not reenum, use the global one
        //
        CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;
    }
    else {
        CurrentInfo = &FilterInstance->StreamDescriptor->StreamInfo;
    }

    CurrentInfo = CurrentInfo + Connect->PinId;

    //
    // set the property info in the stream object.
    //
    
    StreamObject->PropertyInfo = FilterInstance->
        StreamPropEventArray[Connect->PinId].StreamPropertiesArray;
    StreamObject->PropInfoSize = CurrentInfo->
        NumStreamPropArrayEntries;
        
    //
    // set the event info in the stream object
    //

    StreamObject->EventInfo = FilterInstance->
        StreamPropEventArray[Connect->PinId].StreamEventsArray;
    StreamObject->EventInfoCount = CurrentInfo->
        NumStreamEventArrayEntries;

    // moved from callback
    InitializeListHead(&StreamObject->NotifyList);        

    //
    // call the minidriver to open the stream.  processing will continue
    // when the callback procedure is called.
    //

    Status = SCSubmitRequest(SRB_OPEN_STREAM,
                             (PVOID) (Connect + 1),
                             0,
                             SCOpenStreamCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

    if (!RequestIssued) {

        //
        // failure submitting the request
        //

        DEBUG_BREAKPOINT();

        ExFreePool(StreamObject);
        DebugPrint((DebugLevelWarning,
                    "StreamClassOpen: stream open failed"));

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error6\n"));
        return (SCCompleteIrp(Irp, Status, DeviceExtension));

    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    DebugPrint((DebugLevelTrace,"exiting StreamDispatchCreate()\n"));
    return (Status);
}




NTSTATUS
SCOpenStreamCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream open

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );

    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS        Status = SRB->HwSRB.Status;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PVOID           PropertyInfo;
    PKSPROPERTY_ITEM PropertyItem;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           i;

    PAGED_CODE();

    if (NT_SUCCESS(Status)) {

        //
        // if required parameters have not been filled in, fail the open.
        //

        if (!StreamObject->HwStreamObject.ReceiveControlPacket) {

            DEBUG_BREAKPOINT();

            ExFreePool(StreamObject);
            SRB->HwSRB.Status = STATUS_ADAPTER_HARDWARE_ERROR;
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            return (SCProcessCompletedRequest(SRB));
        }
        //
        // if the minidriver does not accept data, use dummy routine.
        //

        if (!StreamObject->HwStreamObject.ReceiveDataPacket) {

            StreamObject->HwStreamObject.ReceiveDataPacket = SCErrorDataSRB;
        }
        //
        // Save the pointer to our per stream structure in the FsContext
        // field of FileObject.  Null out the 2nd context param.
        //

        IrpStack->FileObject->FsContext = StreamObject;
        IrpStack->FileObject->FsContext2 = NULL;

        //
        // Initialize ControlSetMasterClock to serialize the concurrent
        // calls of the function on us, and lock the Read/write of the
        // MasterLockInfo
        //
        KeInitializeEvent(&StreamObject->ControlSetMasterClock, SynchronizationEvent, TRUE);
        KeInitializeSpinLock(&StreamObject->LockUseMasterClock );
                    
        DebugPrint((DebugLevelTrace, "'StreamClassOpen: Stream opened.\n"));

        //
        // Initialize minidriver timer and timer DPC for this stream
        //

        KeInitializeTimer(&StreamObject->ComObj.MiniDriverTimer);
        KeInitializeDpc(&StreamObject->ComObj.MiniDriverTimerDpc,
                        SCMinidriverStreamTimerDpc,
                        StreamObject);

        //
        // initialize the lists for this stream
        //
 
        InitializeListHead(&StreamObject->DataPendingQueue);
        InitializeListHead(&StreamObject->ControlPendingQueue);
        InitializeListHead(&StreamObject->NextStream);
        // a mini driver might start to call GetNextEvent once
        // returns from SRB_OPNE_STREAM. Do it earlier than submit.
        //InitializeListHead(&StreamObject->NotifyList);

        #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

        InitializeListHead(&StreamObject->FreeQueue);
        KeInitializeSpinLock(&StreamObject->FreeQueueLock );

        InitializeListHead(&StreamObject->Queues[READ].ActiveQueue);
        KeInitializeSpinLock(&StreamObject->Queues[READ].QueueLock );

        InitializeListHead(&StreamObject->Queues[WRITE].ActiveQueue);
        KeInitializeSpinLock(&StreamObject->Queues[WRITE].QueueLock );

        StreamObject->PinId = StreamObject->HwStreamObject.StreamNumber;
    	StreamObject->PinType = IrpSink;		// assume irp sink

        if (StreamObject->PinToHandle) {  // if irp source

            StreamObject->PinType = IrpSource;
            Status = PinCreateHandler( Irp, StreamObject );
    
            if (!NT_SUCCESS(Status)) {
                DebugPrint((DebugLevelError,
                    "\nStreamDispatchCreate: PinCreateHandler() returned ERROR"));

                ExFreePool(StreamObject);
                SRB->HwSRB.Status = Status;
                KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
                return (SCProcessCompletedRequest(SRB));
            }
        }
        #endif
        //
        // show we're ready for a request.   Don't show this for data if the
        // minidriver does not want data on this stream.
        //

        CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

        for (i = 0; i < StreamObject->HwStreamObject.StreamNumber; i++) {

            //
            // index to next streaminfo structure
            //

            CurrentInfo++;
        }

        if (CurrentInfo->DataAccessible) {

            StreamObject->ReadyForNextDataReq = TRUE;
        }
        StreamObject->ReadyForNextControlReq = TRUE;

        //
        // call locked routine to insert this stream in the list
        //

        SCInsertStreamInFilter(StreamObject, DeviceExtension);

        //
        // reference the filter so we won't be called to close the instance
        // before all streams are closed.
        //

        ObReferenceObject(IrpStack->FileObject->RelatedFileObject);

        //
        // call routine to update the persisted properties for this pin, if
        // any.
        //

        SCUpdatePersistedProperties(StreamObject, DeviceExtension,
                                    IrpStack->FileObject);

        //
        // show one more instance of this pin opened.
        //

        AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
                          RelatedFileObject->FsContext)->PinInstanceInfo;

        AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
            CurrentInstances++;

        //
        // construct on-the-fly properties for the stream, if necessary
        //

        if (StreamObject->HwStreamObject.HwClockObject.HwClockFunction) {

            //
            // create a property set describing the characteristics of the
            // clock.
            //

            PropertyInfo = ExAllocatePool(PagedPool,
                                          sizeof(ConstructedStreamHandlers) +
                                       sizeof(ConstructedStreamProperties));

            if (PropertyInfo) {

                PropertyItem = (PKSPROPERTY_ITEM) ((ULONG_PTR) PropertyInfo +
                                       sizeof(ConstructedStreamProperties));

                RtlCopyMemory(PropertyInfo,
                              &ConstructedStreamProperties,
                              sizeof(ConstructedStreamProperties));

                RtlCopyMemory(PropertyItem,
                              &ConstructedStreamHandlers,
                              sizeof(ConstructedStreamHandlers));


                //
                // patch the address of the handler
                //

                ((PKSPROPERTY_SET) PropertyInfo)->PropertyItem = PropertyItem;

                //
                // modify the master clock property based on the support
                // level.
                //

                if (0 == (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags
                    & CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME)) {

                    DEBUG_BREAKPOINT();
                    PropertyItem->GetPropertyHandler
                        = NULL;
                }               // if cannot return stream time
                StreamObject->ConstructedPropInfoSize =
                    SIZEOF_ARRAY(ConstructedStreamProperties);

                StreamObject->ConstructedPropertyInfo =
                    (PKSPROPERTY_SET) PropertyInfo;

            }                   // if property info
        }                       // if clock function
    } else {

        ExFreePool(StreamObject);
    }                           // if good status

    //
    // signal the event and complete the IRP.
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    SCProcessCompletedRequest(SRB);
    return (Status);
}

NTSTATUS
SCSetMasterClockWhenDeviceInaccessible( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
/*++

Description:

    This function look for special case in pin property request when the device
    is inaccessible, probably by surprise removal. Yet we need to process the 
    SetMasterClock(NULL) so that the MC ref'ed by us can be released. The MC could
    be on our pin or external.

    This function should only be called in StreamDispatchIoControl. We look for the
    Stream property.SetMasterClock(NULL). We returned SUCCESS if it is. Otherwise
    we return STATUS_UNCESSFUL to indicate that we don't process it.

Arguments:

    DeviceObject - Device Object for the device
    Irp - the request packet

Return:

    SUCCESS : If it is streamproperty.setmasterclock(NULL).
    UNSUCCESSFUL : otherwise.
    
--*/
{
    NTSTATUS Status=STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PKSPROPERTY Property;
    
    if ( IOCTL_KS_PROPERTY == IrpStack->Parameters.DeviceIoControl.IoControlCode && 
         InputBufferLength >= sizeof(KSPROPERTY) && 
         OutputBufferLength >= sizeof( HANDLE )) {
        //
        // only ksproperty is in our interest.
        //
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, 
                             InputBufferLength,
                             sizeof(BYTE));                           
                ProbeForRead(Irp->UserBuffer, 
                             OutputBufferLength,
                             sizeof(DWORD));                                 
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_UNSUCCESSFUL;
        }
        //
        // Capture the property request
        //
        Property = (PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        
        if ( KSPROPERTY_TYPE_SET == Property->Flags && 
             KSPROPERTY_STREAM_MASTERCLOCK == Property->Id &&
             IsEqualGUIDAligned(&Property->Set, &KSPROPSETID_Stream) &&
             NULL == *(PHANDLE) Irp->UserBuffer ) {
            //
            // All match. Now process it. In theory we should call mini driver. 
            // But we did not before. To avoid potential regression in mini drivers
            // we refrain from sending set_master_clock in this condition.
            //
            PSTREAM_OBJECT StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;
            
            DebugPrint((DebugLevelInfo, "SCSetMasterClockWhen:Devobj %x Irp %x\n",
                        DeviceObject, Irp));
                        
            if (StreamObject->MasterClockInfo) {
                ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
                ExFreePool(StreamObject->MasterClockInfo);
                StreamObject->MasterClockInfo = NULL;
            }
            return STATUS_SUCCESS;
        }             
    }
    return Status;
}

NTSTATUS
StreamDispatchIoControl
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

     Process an ioctl to the stream.

Arguments:

    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT)
    IrpStack->FileObject->FsContext;

    PAGED_CODE();

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //
    Status = STATUS_INVALID_DEVICE_REQUEST;
    
    ///Status = SCShowIoPending(DeviceExtension, Irp);
    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {
        ///
        // Note. When our device is surprised removed && we have ref on the master clock
        // && we receive the stream property to set the master clock to null, 
        // we need to process it to deref the MC so the MC can be released. 
        // We will special case it here otherwise there will be big code churn. And
        // the perf impact of this special case should be minimum for we get
        // in here quite rarely.
        //
        // (the device is currently not accessible, so just return with error)
        //
        NTSTATUS StatusProcessed;
        StatusProcessed = SCSetMasterClockWhenDeviceInaccessible( DeviceObject, Irp );

        if ( NT_SUCCESS( StatusProcessed ) ) {
            Status = StatusProcessed;
        }         
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (Status);
    }
    //
    // show one more IO pending.
    //
    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);
    
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_READ_STREAM:

        //
        // process read data request
        //

        DebugPrint((DebugLevelTrace, "'SCReadStream:Irp %x\n", Irp));
        Status = SCProcessDataTransfer(DeviceExtension,
                                       Irp,
                                       SRB_READ_DATA);
        break;

    case IOCTL_KS_WRITE_STREAM:

        //
        // process write data request
        //

        DebugPrint((DebugLevelTrace, "'SCWriteStream:Irp %x\n", Irp));
        Status = SCProcessDataTransfer(DeviceExtension,
                                       Irp,
                                       SRB_WRITE_DATA);
        break;

    case IOCTL_KS_RESET_STATE:
        {

            BOOLEAN         RequestIssued;
            KSRESET        *Reset,
                            ResetType;

            Reset = (KSRESET *) IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            if (Irp->RequestorMode != KernelMode) {
                try {
                    ProbeForRead(Reset, sizeof(KSRESET), sizeof(ULONG));
                    ResetType = *Reset;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    TRAP;
                    Status = GetExceptionCode();
                    break;
                }               // except
            }                   // if !kernelmode

            else {

                //
                // trusted kernel mode, just use it. #131858 prefixbug 17400
                //
                
                ResetType = *Reset;
            }
            
            ASSERT(ResetType == *Reset);
            if (ResetType == KSRESET_BEGIN) {

                StreamObject->InFlush = TRUE;

                Status = SCSubmitRequest(SRB_BEGIN_FLUSH,
                                         NULL,
                                         0,
                                         SCDequeueAndDeleteSrb,
                                         DeviceExtension,
                                         ((PFILTER_INSTANCE)
                                          (StreamObject->FilterInstance))
                                         ->HwInstanceExtension,
                                         &StreamObject->HwStreamObject,
                                         Irp,
                                         &RequestIssued,
                                         &StreamObject->ControlPendingQueue,
                                         StreamObject->HwStreamObject.
                                         ReceiveControlPacket
                    );


                StreamFlushIo(DeviceExtension, StreamObject);

            } else {

                Status = SCSubmitRequest(SRB_END_FLUSH,
                                         NULL,
                                         0,
                                         SCDequeueAndDeleteSrb,
                                         DeviceExtension,
                                         ((PFILTER_INSTANCE)
                                          (StreamObject->FilterInstance))
                                         ->HwInstanceExtension,
                                         &StreamObject->HwStreamObject,
                                         Irp,
                                         &RequestIssued,
                                         &StreamObject->ControlPendingQueue,
                                         StreamObject->HwStreamObject.
                                         ReceiveControlPacket
                    );

                StreamObject->InFlush = FALSE;

            }                   // if begin

            break;
        }                       // case reset

    case IOCTL_KS_PROPERTY:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Property with Irp %x\n", Irp));

        //
        // assume that there are no minidriver properties.
        //

        Status = STATUS_PROPSET_NOT_FOUND;

        //
        // first try the minidriver's properties, giving it a chance to
        // override our built in sets.
        //

        if (StreamObject->PropInfoSize) {

            ASSERT( StreamObject->PropertyInfo );
            Status = KsPropertyHandler(Irp,
                                       StreamObject->PropInfoSize,
                                       StreamObject->PropertyInfo);

        }                       // if minidriver props
        //
        // if the minidriver did not support it, try our on the fly set.
        //

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            if (StreamObject->ConstructedPropertyInfo) {

                Status = KsPropertyHandler(Irp,
                                      StreamObject->ConstructedPropInfoSize,
                                     StreamObject->ConstructedPropertyInfo);

            }                   // if constructed exists
        }                       // if not found
        //
        // if neither supported it, try our built-in set.
        //

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            Status =
                KsPropertyHandler(Irp,
                                  SIZEOF_ARRAY(StreamProperties),
                                  (PKSPROPERTY_SET) StreamProperties);


        }                       // if property not found
        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Enable event with Irp %x\n", Irp));

        Status = KsEnableEvent(Irp,
                               StreamObject->EventInfoCount,
                               StreamObject->EventInfo,
                               NULL, 0, NULL);


        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //


            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            Status = KsDisableEvent(Irp,
                                    &StreamObject->NotifyList,
                                    LockType,
                                    LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

    	#ifdef ENABLE_KS_METHODS
        DebugPrint((DebugLevelTrace,
                     "'StreamDispatchIO: Method in Irp %x\n", Irp));

        //
        // assume that there are no minidriver properties.
        //

        Status = STATUS_PROPSET_NOT_FOUND;

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            if (StreamObject->MethodInfo) {

                Status = KsMethodHandler(Irp,
                                       StreamObject->MethodInfoSize,
                                      StreamObject->MethodInfo);

            }                   // if constructed exists
        }                       // if not found
        break;

		#else

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
        #endif

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return Status;
}


NTSTATUS
SCStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
)
/*++

Routine Description:

     Process get/set device state to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpStack;
    PDEVICE_EXTENSION   DeviceExtension;
    PSTREAM_OBJECT      StreamObject;
    BOOLEAN             RequestIssued;

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    
	PAGED_CODE();


    DebugPrint((DebugLevelTrace, "'SCStreamDeviceState:Irp %x, State = %x\n",
                Irp, *DeviceState));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    FilterInstance = ((PFILTER_INSTANCE) (StreamObject->FilterInstance));
    AdditionalInfo = FilterInstance->PinInstanceInfo;

    Status = STATUS_SUCCESS;

    //
    // Synchronize pin state changes
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);


    if (StreamObject->CurrentState == *DeviceState) {
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        return STATUS_SUCCESS;
    }

    switch (*DeviceState) {
    case KSSTATE_RUN:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_RUN on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_ACQUIRE:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_ACQUIRE on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_PAUSE:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_PAUSE on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_STOP:

        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_STOP on stream:%x\n",StreamObject)); 
        break;

    default:
        DebugPrint((DebugLevelTrace, "STREAM: Invalid Device State\n")); 
        break;

    }
    DebugPrint((DebugLevelTrace, "STREAM: Stream->AllocatorFileObject:%x\n",StreamObject->AllocatorFileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->NextFileObject:%x\n",StreamObject->NextFileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->FileObject:%x\n",StreamObject->FileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->PinType:")); 
    if (StreamObject->PinType == IrpSource)
        DebugPrint((DebugLevelTrace, "IrpSource\n")); 
    else if (StreamObject->PinType == IrpSink)
        DebugPrint((DebugLevelTrace, "IrpSink\n")); 
    else {
        DebugPrint((DebugLevelTrace, "neither\n"));     // this is a bug.
    }
    //
    // send a set state SRB to the stream.
    //

    //
    // GUBGUB: "we may need to send this if Status == STATUS_SUCCESS only"
    // is a bugus concern since Status is inited to Success.
    //
    Status = SCSubmitRequest(SRB_SET_STREAM_STATE,
                             (PVOID) * DeviceState,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    //
    // if good status, set the new state in the stream object.
    //
                      
    if (NT_SUCCESS(Status)) {

        StreamObject->CurrentState = *DeviceState;
    }
    else {
        DebugPrint((DebugLevelTrace, "STREAM: error sending DeviceState Irp\n")); 
    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    switch (*DeviceState) {
    //
    // 1. should start sourcing irps at pause
    // 2. worker thread shutdown if pins are connected in certain order.......
    // 3. check MSTEE bugs assigned to dalesat.
    //
    case KSSTATE_RUN:
        if(StreamObject->PinType == IrpSource &&
           StreamObject->StandardTransport)
        {
            Status = BeginTransfer(
                FilterInstance,
                StreamObject);
        }
        break;

    case KSSTATE_ACQUIRE:
        Status = STATUS_SUCCESS;
        break;

    case KSSTATE_PAUSE:
        if (NT_SUCCESS (Status)) {
            if(StreamObject->PinType == IrpSource &&
               StreamObject->StandardTransport)
            {
                Status = PrepareTransfer(
                    FilterInstance,
                    StreamObject);
            }
        }
        break;

    case KSSTATE_STOP:
        if(StreamObject->PinType == IrpSource &&
           StreamObject->StandardTransport)
            Status = EndTransfer( FilterInstance, StreamObject );
        else 
            //
            // cancel any pending I/O on this stream if the state is STOP.
            //
            StreamFlushIo(DeviceExtension, StreamObject);

        break;

    default:
        break;

    }


    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    return (Status);
}
#else
    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceState:Irp %x, State = %x\n",
                Irp, *DeviceState));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // cancel any pending I/O on this stream if the state is STOP.
    //

    if (*DeviceState == KSSTATE_STOP) {

        StreamFlushIo(DeviceExtension, StreamObject);
    }
    //
    // send a set state SRB to the stream.
    //

    DebugPrint((DebugLevelTrace,
             "'SetStreamState: State %x with Irp %x\n", *DeviceState, Irp));

    Status = SCSubmitRequest(SRB_SET_STREAM_STATE,
                             (PVOID) * DeviceState,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    //
    // if good status, set the new state in the stream object.
    //

    if (NT_SUCCESS(Status)) {

        StreamObject->CurrentState = *DeviceState;
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
    }
#endif


NTSTATUS
SCGetStreamDeviceStateCallback
(
 IN PSTREAM_REQUEST_BLOCK SRB
)
{
// yep, its a do nothing routine.
    return (SRB->HwSRB.Status);

}

NTSTATUS
SCGetStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
)
/*++

Routine Description:

     Process get device state to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{

    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;
    PSTREAM_REQUEST_BLOCK SRB;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a get state SRB to the stream.
    //

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    DebugPrint((DebugLevelTrace,
                "'GetStreamState: State with StreamObj:%x\n", StreamObject));
    if (StreamObject->PinType == IrpSource)
        DebugPrint((DebugLevelTrace, "'GetStreamState: Is IrpSource\n"));
    else
        DebugPrint((DebugLevelTrace,"'GetStreamState: Is IrpSink\n"));
    #endif

    //
    // set the returned data size to the correct size regardless of status.
    //

    Irp->IoStatus.Information = sizeof(KSSTATE);

    Status = SCSubmitRequest(SRB_GET_STREAM_STATE,
                             (PVOID) DeviceState,
                             0,
                             SCGetStreamDeviceStateCallback,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );
    SRB = (PSTREAM_REQUEST_BLOCK) Irp->Tail.Overlay.DriverContext[0];
    *DeviceState = SRB->HwSRB.CommandData.StreamState;

    SCDequeueAndDeleteSrb(SRB);

    //
    // if not supported, return the last known state of the stream.
    //

    if ((Status == STATUS_NOT_SUPPORTED)
        || (Status == STATUS_NOT_IMPLEMENTED)) {

        Status = STATUS_SUCCESS;
        *DeviceState = StreamObject->CurrentState;

    }
    DebugPrint((DebugLevelTrace,
                "'GetStreamState: Returning:%x: DeviceState:", Status));

    switch (*DeviceState) {
    case KSSTATE_RUN:
        DebugPrint((DebugLevelTrace, "KSSTATE_RUN\n")); 
        break;

    case KSSTATE_ACQUIRE:
        DebugPrint((DebugLevelTrace, "KSSTATE_AQUIRE\n")); 
        break;

    case KSSTATE_PAUSE:
        DebugPrint((DebugLevelTrace, "KSSTATE_PAUSE\n")); 
        break;

    case KSSTATE_STOP:
        DebugPrint((DebugLevelTrace, "KSSTATE_STOP\n")); 
        break;

    default:
        DebugPrint((DebugLevelTrace, "Invalid Device State\n")); 
        break;
    }

    return (Status);
}

NTSTATUS
SCStreamDeviceRate
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSRATE DeviceRate
)
/*++

Routine Description:

     Process set device rate to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceRate - rate at which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
                Irp, *DeviceRate));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a set rate SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_SET_STREAM_RATE,
                             (PVOID) DeviceRate,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (Status);
}

NTSTATUS
SCStreamDeviceRateCapability
(
 IN PIRP Irp,
 IN PKSRATE_CAPABILITY RateCap,
 IN OUT PKSRATE DeviceRate
)
/*++

Routine Description:

     Process set device rate to the stream.

Arguments:

    Irp - pointer to the irp
    RateCap - pointer to the information for device state property
    DeviceRate - rate to which the device was set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
                Irp, *DeviceRate));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // presuppose a successful completion, which means that the minidriver
    // can normalize rate to 1.
    //

    *DeviceRate = RateCap->Rate;
    DeviceRate->Rate = 1000;
    Irp->IoStatus.Information = sizeof(KSRATE);

    //
    // send a set rate SRB to the stream.
    //

    Status = SCSubmitRequest(
    		SRB_PROPOSE_STREAM_RATE,
            (PVOID) RateCap,
            0,
            SCDequeueAndDeleteSrb,
            DeviceExtension,
            ((PFILTER_INSTANCE)(StreamObject->FilterInstance))->HwInstanceExtension,
            &StreamObject->HwStreamObject,
            Irp,
            &RequestIssued,
            &StreamObject->ControlPendingQueue,
            StreamObject->HwStreamObject.ReceiveControlPacket
        	);


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}


NTSTATUS
SCStreamProposeNewFormat

(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
)
/*++

Routine Description:

     Process propose data format to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for propose format property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamProposeNewFormat:Irp %x, Format = %x\n",
                Irp, *Format));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a propose format SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_PROPOSE_DATA_FORMAT,
                             (PVOID) Format,
                    IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}



NTSTATUS
SCStreamSetFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
)
/*++

Routine Description:

    Sets the data format on the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the set format property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamSetFormat:Irp %x, Format = %x\n",
                Irp, *Format));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a set format SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_SET_DATA_FORMAT,
                             (PVOID) Format,
                    IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}


NTSTATUS
StreamClassMinidriverDeviceGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDevicePropertyHandler(SRB_GET_DEVICE_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverDeviceSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process set property to the device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer that contains the property info

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDevicePropertyHandler(SRB_SET_DEVICE_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}


NTSTATUS
StreamClassMinidriverStreamGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get property of a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamPropertyHandler(SRB_GET_STREAM_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverStreamSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process set property to a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer that contains the property info

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamPropertyHandler(SRB_SET_STREAM_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}


#ifdef ENABLE_KS_METHODS

NTSTATUS
StreamClassMinidriverStreamMethod(  
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN OUT PVOID MethodInfo)
/*++

Routine Description:

     Process get property of a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamMethodHandler(SRB_STREAM_METHOD,
                                               Irp,
                                               Method,
                                               MethodInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverDeviceMethod(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN OUT PVOID MethodInfo)
/*++

Routine Description:

     Process get property of a device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDeviceMethodHandler(SRB_DEVICE_METHOD,
                                               Irp,
                                               Method,
                                               MethodInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}
#endif


NTSTATUS
StreamClassEnableEventHandler(
                              IN PIRP Irp,
                              IN PKSEVENTDATA EventData,
                              IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an enable event for the stream.

Arguments:

    Irp - pointer to the IRP
    EventData - data describing the event
    EventEntry - more info about the event :-)

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    NTSTATUS        Status;
    ULONG           EventSetID;
    KIRQL           irql;
    HW_EVENT_DESCRIPTOR Event;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    //
    // clock events are indicated on the pin by the minidriver, for
    // simplicity.
    // but, we will receive clock events on the clock's handle.   We need to
    // determine if this file object is the clock's or the pin's.
    //

    StreamObject = IrpStack->FileObject->FsContext;

    if ((PVOID) StreamObject == IrpStack->FileObject->FsContext2) {

        StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;
    }
    //
    // compute the index of the event set.
    //
    // this value is calculated by subtracting the base event set
    // pointer from the requested event set pointer.
    //
    //

    EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
                          (ULONG_PTR) StreamObject->EventInfo)
        / sizeof(KSEVENT_SET);

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EnableEventSetIndex = EventSetID;
    Event.EventEntry = EventEntry;
    Event.StreamObject = &StreamObject->HwStreamObject;
    Event.Enable = TRUE;
    Event.EventData = EventData;

    //
    // acquire the spinlock to protect the interrupt structures
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    //
    // call the synchronized routine to add the event to the list
    //

    Status = DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                          (PKSYNCHRONIZE_ROUTINE) SCEnableEventSynchronized,
                                                   &Event);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    return (Status);

}


VOID
StreamClassDisableEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an event disable for the stream.
    NOTE: we are either at interrupt IRQL or the spinlock is taken on this call!

Arguments:

    FileObject - file object for the pin
    EventEntry - info about the event

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    HW_EVENT_DESCRIPTOR Event;

    //
    // clock events are indicated on the pin by the minidriver, for
    // simplicity.
    // but, we will receive clock events on the clock's handle.   We need to
    // determine if this file object is the clock's or the pin's.
    //

    StreamObject = FileObject->FsContext;

    if ((PVOID) StreamObject == FileObject->FsContext2) {

        StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;
    }
    DeviceExtension = StreamObject->DeviceExtension;

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EventEntry = EventEntry;
    Event.StreamObject = &StreamObject->HwStreamObject;
    Event.Enable = FALSE;

    if (StreamObject->HwStreamObject.HwEventRoutine) {

        //
        // call the minidriver.  ignore the status.  note that we are
        // already at the correct synchronization level.
        //

        StreamObject->HwStreamObject.HwEventRoutine(&Event);

    }                           // if eventroutine
    //
    // remove the event from the list.
    //

    RemoveEntryList(&EventEntry->ListEntry);
}

NTSTATUS
StreamClassEnableDeviceEventHandler(
                                    IN PIRP Irp,
                                    IN PKSEVENTDATA EventData,
                                    IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an enable event for the device.

Arguments:

    Irp - pointer to the IRP
    EventData - data describing the event
    EventEntry - more info about the event :-)

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    ULONG           EventSetID;
    KIRQL           irql;
    HW_EVENT_DESCRIPTOR Event;
    PFILTER_INSTANCE FilterInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;


    FilterInstance = IrpStack->FileObject->FsContext;

    //
    // compute the index of the event set.
    //
    // this value is calculated by subtracting the base event set
    // pointer from the requested event set pointer.
    //
    //

    EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
                          (ULONG_PTR) FilterInstance->EventInfo)
                           / sizeof(KSEVENT_SET);
                           
    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EnableEventSetIndex = EventSetID;
    Event.EventEntry = EventEntry;
    Event.DeviceExtension = DeviceExtension->HwDeviceExtension;
    IF_MF( Event.HwInstanceExtension = FilterInstance->HwInstanceExtension; )
    Event.Enable = TRUE;
    Event.EventData = EventData;

    //
    // acquire the spinlock to protect the interrupt structures
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    //
    // call the synchronized routine to add the event to the list
    //

    Status = DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SCEnableDeviceEventSynchronized,
                                                   &Event);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    return (Status);

}


VOID
StreamClassDisableDeviceEventHandler(
                                     IN PFILE_OBJECT FileObject,
                                     IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an event disable for the stream.
    NOTE: we are either at interrupt IRQL or the spinlock is taken on this call!

Arguments:

    FileObject - file object for the pin
    EventEntry - info about the event

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    HW_EVENT_DESCRIPTOR Event;
    PFILTER_INSTANCE FilterInstance;

    FilterInstance = (PFILTER_INSTANCE) FileObject->FsContext;
    ASSERT_FILTER_INSTANCE( FilterInstance );

    DeviceExtension = FilterInstance->DeviceExtension;

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EventEntry = EventEntry;
    Event.DeviceExtension = DeviceExtension->HwDeviceExtension;
    Event.Enable = FALSE;


	Event.HwInstanceExtension = FilterInstance->HwInstanceExtension;
    if (FilterInstance->HwEventRoutine) {

	    //
        // call the minidriver.  ignore the status.  note that we are
	    // already at the correct synchronization level.
        //

        FilterInstance->HwEventRoutine(&Event);
    }
	
    //
    // remove the event from the list.
    //

    RemoveEntryList(&EventEntry->ListEntry);
}

NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:

    This routine receives control IRP's for the device.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    NTSTATUS        Status;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return.
        //

        return (Status);
    }
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = STATUS_PROPSET_NOT_FOUND;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext; 
        ASSERT( FilterInstance );
        if (FilterInstance->StreamDescriptor->
            StreamHeader.NumDevPropArrayEntries) {
            ASSERT( FilterInstance->DevicePropertiesArray );
            Status = KsPropertyHandler(Irp,
                                   FilterInstance->StreamDescriptor->
                                   StreamHeader.NumDevPropArrayEntries,
                                   FilterInstance->DevicePropertiesArray);
        }
        
        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            Status = KsPropertyHandler(Irp,
                                    SIZEOF_ARRAY(FilterPropertySets),
                                    (PKSPROPERTY_SET) &FilterPropertySets);


        }
        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'FilterDispatchIO: Enable event with Irp %x\n", Irp));

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

        Status = KsEnableEvent(Irp,
                           FilterInstance->EventInfoCount,
                           FilterInstance->EventInfo,
                           NULL, 0, NULL);

        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            DebugPrint((DebugLevelTrace,
                    "'FilterDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //

            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            FilterInstance = (PFILTER_INSTANCE) IrpStack->
                                FileObject->FsContext;
            Status = KsDisableEvent(Irp,
                                &FilterInstance->NotifyList,
                                LockType,
                                LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
    default:

        Status = STATUS_NOT_SUPPORTED;

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
ClockDispatchIoControl(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
)
/*++

Routine Description:

    This routine receives control IRP's for the clock.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSTREAM_OBJECT  StreamObject;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return.
        //

        return (Status);
    }
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = KsPropertyHandler(Irp,
                                   SIZEOF_ARRAY(ClockPropertySets),
                                   (PKSPROPERTY_SET) & ClockPropertySets);

        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Enable event with Irp %x\n", Irp));

        //
        // locate the stream object of the pin for this clock from the IRP.
        // note that we use the event set of the pin for the clock events.
        //

        StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
            FsContext;

        ASSERT(StreamObject);

        Status = KsEnableEvent(Irp,
                               StreamObject->EventInfoCount,
                               StreamObject->EventInfo,
                               NULL, 0, NULL);


        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            //
            // locate the stream object of the pin for this clock from the
            // IRP.
            // note that we use the event set of the pin for the clock
            // events.
            //

            StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
                FsContext;

            ASSERT(StreamObject);

            DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //

            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            Status = KsDisableEvent(Irp,
                                    &StreamObject->NotifyList,
                                    LockType,
                                    LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

    	#ifdef ENABLE_KS_METHODS

        Status = STATUS_PROPSET_NOT_FOUND;
        {
            PFILTER_INSTANCE FilterInstance;
            PHW_STREAM_DESCRIPTOR StreamDescriptor;

            FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
            if ( NULL == FilterInstance->StreamDescriptor ) {
                StreamDescriptor = DeviceExtension->FilterTypeInfos
                    [FilterInstance->FilterTypeIndex].StreamDescriptor;
            }
            else {
                StreamDescriptor = FilterInstance->StreamDescriptor;
            }

            Status = KsMethodHandler(Irp,
                                     StreamDescriptor->
                                     StreamHeader.NumDevMethodArrayEntries,
                                     FilterInstance->DeviceMethodsArray);

        }
        break;
		#else

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
        #endif

    default:

        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
FilterDispatchClose(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for the device/instance

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_INSTANCE FilterInstance =
    (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         IsGlobal;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // remove the filter instance structure from our list
    //

    #if DBG
    IFN_MF( 
        if (DeviceExtension->NumberOfGlobalInstances == 1) {

            ASSERT(IsListEmpty(&FilterInstance->FirstStream));
        }                           // if global = 1
    )
    #endif

    //
    // check to see if this is a global instance
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    DebugPrint(( DebugLevelInfo,
                 "Closing FilterInstance %x NeameExts=%x\n",
                 FilterInstance,
                 DeviceExtension->NumberOfNameExtensions));
                     
    if ( 0 == DeviceExtension->FilterExtensionSize &&
         DeviceExtension->NumberOfOpenInstances > 1) {

        PFILE_OBJECT pFileObject;
            
        //
        // this is not the last close of the global instance, so just
        // deref this instance and return good status.
        //

        DeviceExtension->NumberOfOpenInstances--;
                
        DebugPrint(( DebugLevelInfo,
                     "DevExt=%x Close OpenCount=%x\n",
                     DeviceExtension,
                     DeviceExtension->NumberOfOpenInstances));
                     
        IrpStack->FileObject->FsContext = NULL;
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(DeviceObject);
        SCDereferenceDriver(DeviceExtension);
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));
    }
       

    //
    // we now know that this is either a local instance, or the last open of
    // the global instance.   process the close.
    //

    if ( 0 != DeviceExtension->FilterExtensionSize ) {

        Status = SCSubmitRequest(SRB_CLOSE_DEVICE_INSTANCE,
                                 NULL,
                                 0,
                                 SCCloseInstanceCallback,
                                 DeviceExtension,
                                 FilterInstance->HwInstanceExtension,
                                 NULL,
                                 Irp,
                                 &RequestIssued,
                                 &DeviceExtension->PendingQueue,
                                 (PVOID) DeviceExtension->
                                 MinidriverData->HwInitData.
                                 HwReceivePacket);

        if (!RequestIssued) {
            DEBUG_BREAKPOINT();
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            SCCompleteIrp(Irp, Status, DeviceExtension);
        }
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        return (Status);


    } else {                    // if instanceextension

        //
        // the minidriver doesn't need to be called as it does not support
        // instancing.   dereference the instance now.
        //

        DeviceExtension->NumberOfOpenInstances--;
                
        DebugPrint(( DebugLevelInfo,
                     "DevExt=%x Close OpenCount=%x\n",
                     DeviceExtension,
                     DeviceExtension->NumberOfOpenInstances));
        //
        // we are ready to free the instance.   if it is global, just zero
        // the pointer.   if it is local, remove it from the list.
        //

        IrpStack->FileObject->FsContext = NULL;

        DebugPrint((DebugLevelInfo, "FilterCloseInstance=%x\n", FilterInstance));

        if ( !IsListEmpty( &DeviceExtension->FilterInstanceList)) {
            //
            // The list could be emptied at surprise removal
            // where all instances are removed. so when come in here
            // check it first. Event is taken, check is safe.
            //
            RemoveEntryList(&FilterInstance->NextFilterInstance);
            SciFreeFilterInstance( FilterInstance );
            FilterInstance = NULL;
        }
        
        else {
            //
            // it has been closed by surprise removal. mark it.
            //
            FilterInstance= NULL;
        }

        //
        // if this is the last close of a removed device, detach from
        // the PDO now, since we couldn't do it on the remove.  note that
        // we will NOT do this if the NT style surprise remove IRP has been
        // received, since we'll still receive an IRP_REMOVE in that case
        // after
        // this close.
        //

        if ((DeviceExtension->NumberOfOpenInstances == 0) &&
            (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) &&
        !(DeviceExtension->Flags & DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED)) {

            DebugPrint((DebugLevelInfo,
                        "SCPNP: detaching %x from %x\n",
                        DeviceObject,
                        DeviceExtension->AttachedPdo));

            //
            // detach could happen at remove, check before leap.
            // event is taken, check is safe.
            //
            if ( NULL != DeviceExtension->AttachedPdo ) {
                IoDetachDevice(DeviceExtension->AttachedPdo);
                DeviceExtension->AttachedPdo = NULL;
            }
        } 

        else {

            //
            // check if we can power down the device.
            //

            SCCheckPowerDown(DeviceExtension);

        }                       // if inaccessible

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        if ( NULL != FilterInstance ) {
            DebugPrint(( DebugLevelVerbose,
                     "Unregistering ReadWorker %x WriteWorker %x\n",
                     FilterInstance->WorkerRead,
                     FilterInstance->WorkerWrite));                     
            KsUnregisterWorker( FilterInstance->WorkerRead );
            KsUnregisterWorker( FilterInstance->WorkerWrite );
            KsFreeObjectHeader(FilterInstance->DeviceHeader);
            ExFreePool(FilterInstance);
        }

        SCDereferenceDriver(DeviceExtension);
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        Status = SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension);
        ObDereferenceObject(DeviceObject);
        return (Status);
    }
}



NTSTATUS
SCCloseInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an instance close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_INSTANCE FilterInstance =
    (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension - 1;
    NTSTATUS        Status = SRB->HwSRB.Status;
    KIRQL           irql;

    //
    // Close should not fail. If it does, should clean up anyway
    ASSERT( NT_SUCCESS(Status) && "Close Instance failed" );    
    ///if (NT_SUCCESS(Status)) {

        //
        // we are ready to free the instance.   if it is global, just zero
        // the pointer.   if it is local, remove it from the list.
        //

        DeviceExtension->NumberOfOpenInstances--;

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);


        RemoveEntryList(&FilterInstance->NextFilterInstance);

        //
        // free the instance and return success.
        //

        KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

        //
        // if this is the last close of a removed device, detach from
        // the PDO now, since we couldn't do it on the remove.
        //

        if ((DeviceExtension->NumberOfOpenInstances == 0) &&
            (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE)) {

            DebugPrint((DebugLevelTrace,
                        "'SCPNP: detaching from PDO\n"));

            TRAP;
            IoDetachDevice(DeviceExtension->AttachedPdo);
            DeviceExtension->AttachedPdo = NULL;
        }
        //
        // check if we can power down the device.
        //

        SCCheckPowerDown(DeviceExtension);
        ObDereferenceObject(DeviceExtension->DeviceObject);

        //
        // free the instance and header and dereference the driver
        //

        SciFreeFilterInstance( FilterInstance );
        ///#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        
        ///DebugPrint(( DebugLevelVerbose,
        ///             "Unregistering ReadWorker %x WriteWorker %x\n",
        ///             FilterInstance->WorkerRead,
        ///             FilterInstance->WorkerWrite));
        ///             
        ///KsUnregisterWorker( FilterInstance->WorkerRead );
        ///KsUnregisterWorker( FilterInstance->WorkerWrite );
        ///#endif
        
        ///KsFreeObjectHeader(FilterInstance->DeviceHeader);
        ///ExFreePool(FilterInstance);
        SCDereferenceDriver(DeviceExtension);

    ///}                           // if good status
    //
    // signal the event and complete the IRP.
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    SCProcessCompletedRequest(SRB);
    return (Status);

}

NTSTATUS
StreamDispatchCleanup 
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLEANUP IRP's for a stream

Arguments:

    DeviceObject - device object for the device
    Irp - The CLEANUP Irp

Return Value:

    The IRP status set as appropriate

--*/

{

    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation (Irp);
    PSTREAM_OBJECT StreamObject =
        (PSTREAM_OBJECT) IrpStack -> FileObject -> FsContext;
    PDEVICE_EXTENSION DeviceExtension =
        (PDEVICE_EXTENSION) DeviceObject -> DeviceExtension;
    BOOLEAN BreakClockCycle = FALSE;

    KeWaitForSingleObject (
        &DeviceExtension -> ControlEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // If the stream in question is a source stream and it has not yet
    // stopped the sourcing worker, it must be done at this point in time.
    //
    if (StreamObject -> CurrentState > KSSTATE_STOP &&
        StreamObject -> PinType == IrpSource &&
        StreamObject -> StandardTransport) {

        EndTransfer (StreamObject -> FilterInstance, StreamObject);

    }

    //
    // Check for the clock<->pin cycle and break it if present.
    //
    if (StreamObject -> MasterClockInfo) {

        PFILE_OBJECT ClockFile = StreamObject -> MasterClockInfo -> 
            ClockFileObject;

        if (ClockFile && 
            ClockFile -> RelatedFileObject == StreamObject -> FileObject) 

            BreakClockCycle = TRUE;

    }

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    //
    // Synchronously submit an Irp down our own stack to get break the 
    // clock<->pin cycle.  Otherwise, the stream can't close.  The driver should
    // guard against the clock disappearing while running.  Stream class does
    // on TOP of that if they do not.
    //
    if (BreakClockCycle) {
        KSPROPERTY Property;
        HANDLE NewClock = NULL;
        ULONG BytesReturned;
        NTSTATUS Status;

        Property.Set = KSPROPSETID_Stream;
        Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
        Property.Flags = KSPROPERTY_TYPE_SET;

        Status =
            KsSynchronousIoControlDevice (
                StreamObject -> FileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof (KSPROPERTY),
                &NewClock,
                sizeof (HANDLE),
                &BytesReturned
                );

        ASSERT (NT_SUCCESS (Status));

    }

    Irp -> IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

}

NTSTATUS
StreamDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for a stream

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_OBJECT  StreamObject =
    (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;
    KSEVENTS_LOCKTYPE LockType;
    PVOID           LockObject;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    ASSERT(IsListEmpty(&StreamObject->ControlPendingQueue));
    ASSERT(IsListEmpty(&StreamObject->DataPendingQueue));

    //
    // free events associated with this stream. this will cause our remove
    // handler to be called for each, and will hence notify the minidriver.
    //

    //
    // determine the type of lock necessary based on whether we are
    // using interrupt or spinlock synchronization.
    //

    #if DBG
    if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
    #else
    if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
    #endif
        LockType = KSEVENTS_INTERRUPT;
        LockObject = DeviceExtension->InterruptObject;

    } else {

        LockType = KSEVENTS_SPINLOCK;
        LockObject = &DeviceExtension->SpinLock;

    }

    KsFreeEventList(IrpStack->FileObject,
                    &StreamObject->NotifyList,
                    LockType,
                    LockObject);

    //
    // call the minidriver to close the stream.  processing will continue
    // when the callback procedure is called.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    Status = SCSubmitRequest(SRB_CLOSE_STREAM,
                             NULL,
                             0,
                             SCCloseStreamCallback,
                             DeviceExtension,
                             StreamObject->
                             FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);

}



NTSTATUS
SCCloseStreamCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KIRQL           Irql;
    NTSTATUS        Status = SRB->HwSRB.Status;

    ASSERT( NT_SUCCESS(Status) && "CloseStream Failed by Minidriver");

    //
    // Close should not fail. Even it does, we want to clean up.
    //
    // if (NT_SUCCESS(Status)) {

        //
        // show one fewer instance open
        //

        DebugPrint((DebugLevelInfo, "SC Closing StreamObject %x\n", StreamObject));

        AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
                          RelatedFileObject->FsContext)->PinInstanceInfo;
        AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
            CurrentInstances--;

        //
        // free the object header for the stream
        //

        KsFreeObjectHeader(StreamObject->ComObj.DeviceHeader);

        //
        // free the constructed props, if any.
        //

        if (StreamObject->ConstructedPropertyInfo) {

            ExFreePool(StreamObject->ConstructedPropertyInfo);
        }
        //
        // signal the event.
        // signal now so that we won't
        // deadlock when we dereference the object and the filter is closed.
        //

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

        //
        // Zero the pointer to our per stream structure in the FsContext
        // field of
        // of FileObject.
        //

        IrpStack->FileObject->FsContext = 0;

        //
        // remove the stream object from the filter instance list
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        RemoveEntryList(&StreamObject->NextStream);

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        //
        // kill the timer, which might have been left dangling by the
        // minidriver.
        //

        KeCancelTimer(&StreamObject->ComObj.MiniDriverTimer);

        //
        // dereference the master clock if any
        //

        if (StreamObject->MasterClockInfo) {

            ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
            ExFreePool(StreamObject->MasterClockInfo);
        }
 
        #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        //
        // dereference the next file object
        //
        if (StreamObject->NextFileObject)
        {
            ObDereferenceObject(StreamObject->NextFileObject);
            StreamObject->NextFileObject = NULL;
        }

        //
        // Dereference the allocator object or stream obj won't be
        // release while it should. Problems would follow particularly
        // with SWEnum loaded driver.
        //
        if ( StreamObject->AllocatorFileObject ) {
            ObDereferenceObject( StreamObject->AllocatorFileObject );
            StreamObject->AllocatorFileObject = NULL;
        }            
        #endif

        //
        // dereference the filter
        //

        ObDereferenceObject(StreamObject->FilterFileObject);
 
        ExFreePool(StreamObject);
    ///} else {                    // if good status

    ///    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    ///}                           // if good status

    SCProcessCompletedRequest(SRB);
    return (Status);

}



BOOLEAN
StreamClassInterrupt(
                     IN PKINTERRUPT Interrupt,
                     IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    Process interrupt from the device

Arguments:

    Interrupt - interrupt object

    Device Object - device object which is interrupting

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN         returnValue;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // check if the interrupt cannot currently go down
    //

    if (deviceExtension->DriverInfo->Flags & DRIVER_FLAGS_PAGED_OUT) {

        return (FALSE);
    }
    //
    // call the minidriver's interrupt service routine.
    //

    returnValue = deviceExtension->MinidriverData->
        HwInitData.HwInterrupt(deviceExtension->HwDeviceExtension);

    //
    // Queue up a DPC if needed.
    //

    if ((deviceExtension->NeedyStream) || (deviceExtension->ComObj.
             InterruptData.Flags & INTERRUPT_FLAGS_NOTIFICATION_REQUIRED)) {

        KeInsertQueueDpc(&deviceExtension->WorkDpc, NULL, NULL);

    }
    return (returnValue);

}                               // end StreamClassInterrupt()


NTSTATUS
StreamClassNull(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp

)
/*++

Routine Description:

    This routine fails incoming irps.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is returned

--*/

{
    //
    // complete the IRP with error status
    //

    PAGED_CODE();
    return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceObject->DeviceExtension));
}

NTSTATUS
SCFilterPinInstances(
                     IN PIRP Irp,
                     IN PKSPROPERTY Property,
                     IN OUT PVOID Data)
/*++

Routine Description:

    Returns the # of instances supported by a pin

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - instance info

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    ULONG           Pin;
    PKSPIN_CINSTANCES CInstances;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalPinInfo;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
        DeviceObject->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    //
    // get the pin #
    //

    Pin = ((PKSP_PIN) Property)->PinId;

    //
    // if max pin number exceeded, return error
    //

    IFN_MF(
        if (Pin >= DeviceExtension->NumberOfPins) {

            DEBUG_BREAKPOINT();
         return (STATUS_INVALID_PARAMETER);
        }
    )

    IF_MF(
        if (Pin >= FilterInstance->NumberOfPins) {

            DEBUG_BREAKPOINT();
            return (STATUS_INVALID_PARAMETER);
        }
    )
    CInstances = (PKSPIN_CINSTANCES) Data;

    AdditionalPinInfo = FilterInstance->PinInstanceInfo;

    CInstances->PossibleCount = AdditionalPinInfo[Pin].MaxInstances;
    CInstances->CurrentCount = AdditionalPinInfo[Pin].CurrentInstances;

    Irp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (STATUS_SUCCESS);
}

NTSTATUS
SCFilterPinPropertyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data)
/*++

Routine Description:

    Dispatches a pin property request

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - property specific buffer

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
                                        DeviceObject->DeviceExtension;
        PFILTER_INSTANCE    FilterInstance= (PFILTER_INSTANCE) IrpStack->
                                            FileObject->FsContext;

    PAGED_CODE();
    

    return KsPinPropertyHandler(Irp,
                            Property,
                            Data,
                            FilterInstance->NumberOfPins,
                            FilterInstance->PinInformation);
}



VOID
StreamClassTickHandler(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PVOID Context
)
/*++

Routine Description:

    Tick handler for device.

Arguments:

    DeviceObject - pointer to the device object
    Context - unreferenced

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PLIST_ENTRY     ListEntry;
    PLIST_ENTRY     SrbListEntry = ListEntry = &DeviceExtension->OutstandingQueue;
    PSTREAM_REQUEST_BLOCK Srb;

    UNREFERENCED_PARAMETER(Context);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // acquire the device spinlock to protect the queues.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // process any timed out requests on the device
    //

    while (SrbListEntry->Flink != ListEntry) {

        SrbListEntry = SrbListEntry->Flink;

        Srb = CONTAINING_RECORD(SrbListEntry,
                                STREAM_REQUEST_BLOCK,
                                SRBListEntry);
        //
        // first make sure the request is active, since it could have been
        // called back but not yet removed from the queue.
        //

        if (Srb->Flags & SRB_FLAGS_IS_ACTIVE) {

            //
            // check for a timeout if the counter is currently nonzero.
            //

            if (Srb->HwSRB.TimeoutCounter != 0) {

                if (--Srb->HwSRB.TimeoutCounter == 0) {

                    //
                    // request timed out.  Call the minidriver to process it.
                    // first reset the timer in case the minidriver is
                    // busted.
                    //

                    DebugPrint((DebugLevelError, "SCTickHandler: Irp %x timed out!  SRB = %x, SRB func = %x, Stream Object = %x\n",
                                Srb->HwSRB.Irp, Srb, Srb->HwSRB.Command, Srb->HwSRB.StreamObject));
                    Srb->HwSRB.TimeoutCounter = Srb->HwSRB.TimeoutOriginal;

                    DeviceExtension = (PDEVICE_EXTENSION)
                        Srb->HwSRB.HwDeviceExtension - 1;

                    //
                    // if we are not synchronizing the minidriver, release
                    // and reacquire the spinlock around the call into it.
                    //

                    if (DeviceExtension->NoSync) {

                        //
                        // we need to ensure that the SRB memory is valid for
                        // the async
                        // minidriver, EVEN if it happens to call back the
                        // request just
                        // before we call it to cancel it!   This is done for
                        // two reasons:
                        // it obviates the need for the minidriver to walk
                        // its request
                        // queues to find the request, and I failed to pass
                        // the dev ext
                        // pointer to the minidriver in the below call, which
                        // means that
                        // the SRB HAS to be valid, and it's too late to
                        // change the API.
                        //
                        // Oh, well.   Spinlock is now taken (by caller).
                        //

                        Srb->DoNotCallBack = TRUE;

                        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                        (DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler)
                            (&Srb->HwSRB);
                        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                        //
                        // if the ACTIVE flag is now clear, it indicates that
                        // the
                        // SRB was completed during the above call into the
                        // minidriver.
                        // since we blocked the internal completion of the
                        // request,
                        // we must call it back ourselves in this case.
                        //

                        Srb->DoNotCallBack = FALSE;
                        if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {
                            TRAP;

                            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
                            (Srb->Callback) (Srb);
                            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
                        }       // if ! active
                        break;

                    } else {    // if nosync

                        DeviceExtension->SynchronizeExecution(
                            DeviceExtension->InterruptObject,
                            (PVOID) DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler,
                            &Srb->HwSRB);

                        // return now in case the minidriver aborted any
                        // other
                        // requests that
                        // may be timing out now.
                        //

                        break;

                    }           // if nosync


                }               // if timed out
            }                   // if counter != 0
        }                       // if active
    }                           // while list entry

    //
    // let my people go...
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    return;

}                               // end StreamClassTickHandler()


VOID
StreamClassCancelPendingIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
)
/*++

Routine Description:

    Cancel routine for pending IRP's.

Arguments:

    DeviceObject - pointer to the device object
    Irp - pointer to IRP to be cancelled

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PLIST_ENTRY     ListHead, ListEntry;
    KIRQL           CancelIrql,
                    Irql;
    PSTREAM_REQUEST_BLOCK SRB;

    DebugPrint((DebugLevelWarning, "'SCCancelPending: trying to cancel Irp = %x\n",
                Irp));

    //
    // acquire the device spinlock then release the cancel spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    CancelIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(Irql);

    //
    // there are two possibilities here.   1) the IRP is on the pending queue
    // for the particular stream.  2) the IRP was moved from pending to
    // outstanding and has been submitted to the minidriver.
    // If we are running above an external bus driver, don't
    //

    //
    // now process all streams on the local filter instances.
    //

    ListHead = &DeviceExtension->FilterInstanceList;
    ListEntry = ListHead->Flink;

    while ( ListEntry != ListHead ) {

        //
        // follow the link to the instance
        //

        FilterInstance = CONTAINING_RECORD(ListEntry,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);

        //
        // process the streams on this list
        //

        if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, Irp)) {
            goto found;
        }

        ListEntry = ListEntry->Flink;
    }

    //
    // now process any requests on the device itself
    //

    if (SCCheckRequestsForIrp(
          &DeviceExtension->OutstandingQueue, Irp, TRUE, DeviceExtension)) {
        goto found;
    }
    //
    // request is not on pending queue, so call to check the outstanding
    // queue
    //

    SCCancelOutstandingIrp(DeviceExtension, Irp);

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

exit:

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    KeLowerIrql(CancelIrql);

    return;

found:

    //
    // the irp is on one of our pending queues.  remove it from the queue and
    // complete it.
    //

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // retrieve the SRB.
    //

    SRB = Irp->Tail.Overlay.DriverContext[0];

    //
    // hack - the completion handlers will try to remove the SRB from the
    // outstanding queue.  Point the SRB's queues to itself so this will not
    // cause a problem.
    //

    SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
    SRB->SRBListEntry.Blink = &SRB->SRBListEntry;

    SRB->HwSRB.Status = STATUS_CANCELLED;

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    (SRB->Callback) (SRB);
    goto exit;

}

VOID
StreamClassCancelOutstandingIrp(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp
)
/*++

Routine Description:

    Cancel routine for IRP's outstanding in the minidriver

Arguments:

    DeviceObject - pointer to the device object
    Irp - pointer to IRP to be cancelled

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL           Irql,
                    CancelIrql;

    DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: trying to cancel Irp = %x\n",
                Irp));

    //
    // acquire the device spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    CancelIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(Irql);

    SCCancelOutstandingIrp(DeviceExtension, Irp);

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    KeLowerIrql(CancelIrql);
    return;
}


VOID
StreamFlushIo(
              IN PDEVICE_EXTENSION DeviceExtension,
              IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Cancel all IRP's on the specified stream.

Arguments:

Return Value:

    STATUS_SUCCESS

--*/

{

    PLIST_ENTRY     IrpEntry;
    KIRQL           Irql;
    PSTREAM_REQUEST_BLOCK SRB;
    PIRP            Irp;

    //
    // abort all I/O on the specified stream.   first acquire the spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    //
    // if there is I/O on our pending data queue, abort it.
    //

    while (!IsListEmpty(&StreamObject->DataPendingQueue)) {

        //
        // grab the IRP at the head of the queue and abort it.
        //

        IrpEntry = StreamObject->DataPendingQueue.Flink;

        Irp = CONTAINING_RECORD(IrpEntry,
                                IRP,
                                Tail.Overlay.ListEntry);

        //
        // remove the IRP from our pending queue and call it back with
        // cancelled status
        //

        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

        //
        // null out the cancel routine
        //

        IoSetCancelRoutine(Irp, NULL);

        DebugPrint((DebugLevelTrace,
                    "'StreamFlush: Canceling Irp %x \n", Irp));


        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        SCCompleteIrp(Irp, STATUS_CANCELLED, DeviceExtension);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    }

    //
    // if there is I/O on our pending control queue, abort it.
    //

    while (!IsListEmpty(&StreamObject->ControlPendingQueue)) {

        //
        // grab the IRP at the head of the queue and abort it.
        //

        DEBUG_BREAKPOINT();
        IrpEntry = StreamObject->ControlPendingQueue.Flink;

        Irp = CONTAINING_RECORD(IrpEntry,
                                IRP,
                                Tail.Overlay.ListEntry);


        //
        // remove the IRP from our pending queue and call it back with
        // cancelled status
        //

        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

        //
        // null out the cancel routine
        //

        IoSetCancelRoutine(Irp, NULL);

        DebugPrint((DebugLevelTrace,
                    "'StreamFlush: Canceling Irp %x \n", Irp));

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        SCCompleteIrp(Irp, STATUS_CANCELLED, DeviceExtension);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    }

    //
    // now cancel any irps for this stream on the outstanding queue.
    // walk the outstanding queue trying to find an SRB for this stream.
    //

    IrpEntry = &DeviceExtension->OutstandingQueue;

    while (IrpEntry->Flink != &DeviceExtension->OutstandingQueue) {

        IrpEntry = IrpEntry->Flink;

        //
        // follow the link to the SRB
        //

        SRB = (PSTREAM_REQUEST_BLOCK) (CONTAINING_RECORD(IrpEntry,
                                                       STREAM_REQUEST_BLOCK,
                                                         SRBListEntry));
        //
        // if this SRB's stream object matches the one we're cancelling for,
        // AND it has not been previously cancelled, AND the IRP itself has
        // not been completed (non-null IRP field), abort this request.
        //


        if ((StreamObject == CONTAINING_RECORD(
                                               SRB->HwSRB.StreamObject,
                                               STREAM_OBJECT,
                                               HwStreamObject)) &&
            (SRB->HwSRB.Irp) &&
            !(SRB->HwSRB.Irp->Cancel)) {

            //
            // The IRP has not been previously cancelled, so cancel it after
            // releasing the spinlock to avoid deadlock with the cancel
            // routine.
            //

            DebugPrint((DebugLevelTrace,
                      "'StreamFlush: Canceling Irp %x \n", SRB->HwSRB.Irp));

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            IoCancelIrp(SRB->HwSRB.Irp);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

            //
            // restart at the top of the queue since we released the
            // spinlock.
            // we won't get in an endless loop since we set the cancel flag
            // in the IRP.
            //

            IrpEntry = &DeviceExtension->OutstandingQueue;


        }                       // if streamobjects match
    }                           // while entries


    //
    // release the spinlock but remain at DPC level.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    //
    // lower IRQL
    //

    KeLowerIrql(Irql);

}

NTSTATUS
ClockDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
)
{
    NTSTATUS        Status;
    PCLOCK_INSTANCE ClockInstance=NULL; //Prefixbug 17399
    PIO_STACK_LOCATION IrpStack;
    PKSCLOCK_CREATE ClockCreate;
    PFILE_OBJECT    ParentFileObject;
    PSTREAM_OBJECT  StreamObject=NULL; // prefixbug 17399
    BOOLEAN         RequestIssued=FALSE; // prefixbug 17398

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        return (Status);

    }
    Status = KsValidateClockCreateRequest(Irp,
                                          &ClockCreate);

    ParentFileObject = IrpStack->FileObject->RelatedFileObject;

    DebugPrint((DebugLevelTrace,
                "'ClockCreate: Creating clock with Irp %x \n", Irp));

    if (NT_SUCCESS(Status)) {

        //
        // allocate a clock instance for the clock
        //

        ClockInstance =
            (PCLOCK_INSTANCE)
            ExAllocatePool(NonPagedPool, sizeof(CLOCK_INSTANCE));

        if (ClockInstance) {

            //
            // fill in the clock instance structure and reference it in the
            // file
            // object for the clock
            //

            ClockInstance->ParentFileObject = ParentFileObject;

            #if 0
            ClockInstance->ClockFileObject = IrpStack->FileObject;
            DebugPrint((DebugLevelInfo,
                       "++++++++ClockInstance=%x, FileObject=%x\n",
                       ClockInstance,
                       ClockInstance->ClockFileObject));
            #endif

            KsAllocateObjectHeader(&ClockInstance->DeviceHeader,
                                   SIZEOF_ARRAY(StreamDriverDispatch),
                                   (PKSOBJECT_CREATE_ITEM) NULL,
                                   Irp,
                                   (PKSDISPATCH_TABLE) & ClockDispatchTable);

            IrpStack->FileObject->FsContext = ClockInstance;

            //
            // set the 2nd context parameter so that we can identify this
            // object as the clock object.
            //

            IrpStack->FileObject->FsContext2 = ClockInstance;

            //
            // call the minidriver to indicate that this stream is the master
            // clock.  pass the file object as a handle to the master clock.
            //

            StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;

            StreamObject->ClockInstance = ClockInstance;
            ClockInstance->StreamObject = StreamObject;


            Status = SCSubmitRequest(SRB_OPEN_MASTER_CLOCK,
                                     (HANDLE) IrpStack->FileObject,
                                     0,
                                     SCOpenMasterCallback,
                                     StreamObject->DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                                     &StreamObject->HwStreamObject,
                                     Irp,
                                     &RequestIssued,
                                     &StreamObject->ControlPendingQueue,
                                     (PVOID) StreamObject->HwStreamObject.
                                     ReceiveControlPacket
                );

        } else {                // if clockinstance

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }                       // if clockinstance

    }                           // if validate success
    if (!RequestIssued) {

        if ( NULL != StreamObject && NULL != StreamObject->ClockInstance ) {
            ExFreePool(StreamObject->ClockInstance);
            StreamObject->ClockInstance = NULL; // prefixbug 17399
        }

        SCCompleteIrp(Irp,
                      STATUS_INSUFFICIENT_RESOURCES,
                      DeviceObject->DeviceExtension);

    }
    return (Status);

}

NTSTATUS
AllocatorDispatchCreate(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PIRP Irp
)
/*++

Routine Description:

     Processes the allocator create IRP.   Currently just uses the default
     allocator.

Arguments:

Return Value:

     None.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PFILE_OBJECT    ParentFileObject;
    PSTREAM_OBJECT  StreamObject;
    NTSTATUS        Status;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace,"entering AllocatorDispatchCreate\n"));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ParentFileObject = IrpStack->FileObject->RelatedFileObject;
    StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        DebugPrint((DebugLevelError,"exiting AllocatorDispatchCreate-REMOVED\n"));
        return (Status);

    }
    //
    // if allocator is not needed for this stream, just fail the call.
    //

    if (!StreamObject->HwStreamObject.Allocator) {

        DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-not implemented\n"));
        return SCCompleteIrp(Irp,
                             STATUS_NOT_IMPLEMENTED,
                             DeviceObject->DeviceExtension);
    }

    DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-complete\n"));
    return SCCompleteIrp(Irp,
                         KsCreateDefaultAllocator(Irp),
                         DeviceObject->DeviceExtension);
}

NTSTATUS
SCOpenMasterCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a master clock open.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    // log 'oMC ', StreamObject, DevExt, Status
    SCLOG( ' CMo', StreamObject, StreamObject->DeviceExtension, SRB->HwSRB.Status);
    
    if (!NT_SUCCESS(SRB->HwSRB.Status)) {

        //
        // if we could not set the master, free the clock handle and zero
        // the link to the clock.
        //

        ExFreePool(StreamObject->ClockInstance);
        StreamObject->ClockInstance = NULL;

    } else {                    // if status success

        //
        // reference the pin handle so we won't be called to close the pin
        // before the clock is closed
        //

        ObReferenceObject(IrpStack->FileObject->RelatedFileObject);
    }                           // if status success

    //
    // complete the SRB
    //

    return (SCProcessCompletedRequest(SRB));
}


NTSTATUS
SCGetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
)
{
    //
    // WorkWork - for now do nothing.
    //

    PAGED_CODE();

    return (STATUS_NOT_SUPPORTED);

}

VOID
SciSetMasterClockInfo(
    IN PSTREAM_OBJECT pStreamObject,
    IN PMASTER_CLOCK_INFO pMasterClockInfo )
/*++
    Decription:

        This function simply set the new masterclock info for the stream
        with LockUseMasterClock hold. Because of taking a spinlock we need
        this function in lock memory. This function is intended to be called
        by SCSetMasterClockOnly. pStreamObject is assumed valid.

    Parameters:

        pStreamObject: the target stream object to set to the new MasterCLockInfo
        pMasterClockInfo: the new master clock info.

    Return: None.
    
--*/
{
    KIRQL SavedIrql;
    
    KeAcquireSpinLock( &pStreamObject->LockUseMasterClock, &SavedIrql );
    pStreamObject->MasterClockInfo = pMasterClockInfo;
    KeReleaseSpinLock( &pStreamObject->LockUseMasterClock, SavedIrql );

    return;
}


NTSTATUS
SCSetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN PHANDLE ClockHandle
)
/*++

Description:

    This is a Set property on a the stream. The request may be setting to
    NULL CLockHandle which indicates master clock is revoked. If ClockHandle
    is non-NULL, it is a new Master clock chosen by the graph manager. 

Parameters:

    Irp: the IO request packet to Set the master clock.
    Property: the Set Master clock property
    ClockHanlde: the handle of the clock designated as the new master clcok.

Return: 

    NTSTAUS: depending on the result of processing the request.

Comments:

    This function must be called at IRQL < DISPATCH_LEVEL

--*/
{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PSTREAM_OBJECT  StreamObject;
    KSPROPERTY      FuncProperty;
    PMASTER_CLOCK_INFO NewMasterClockInfo=NULL; //prefixbug 17396
    PMASTER_CLOCK_INFO OldMasterClockInfo;
    ULONG           BytesReturned;
    PFILE_OBJECT    ClockFileObject = NULL;
    BOOLEAN         RequestIssued=FALSE;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    
    //
    // This function can be called from multiple threads. We will serialize
    // this function on the Stream to protect against concurrent accesses.
    //
    KeWaitForSingleObject(&StreamObject->ControlSetMasterClock,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // N.B.
    //
    // If our clock is open, we are potentially the master clock. But this
    // is not guaranteed. Ksproxy opens our clock in attempt to use it as
    // the master clock. But it can change its mind to choose another clock,
    // while keeping our clock open.
    //

    //
    // log 'sMC ', StreamObject, MasterClockInfo, *ClockHandle )
    //
    SCLOG( ' CMs', StreamObject, StreamObject->MasterClockInfo, *ClockHandle );

    /* 
        Not so soon. We have not told mini drivers the new master clock yet. 
        Mini drivers might think they still have the retiring Master clock and
        can query the clock in the mean time. We would crash on accessing NULL
        MasterClockInfo. We should not nullify it before we notify the mini 
        driver first.
        
    if (StreamObject->MasterClockInfo) {

        ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
        ExFreePool(StreamObject->MasterClockInfo);
        StreamObject->MasterClockInfo = NULL;
    }
    */
    OldMasterClockInfo = StreamObject->MasterClockInfo;
    
    //
    // if there is a clock, reference it.  If not, we'll send down a null handle.
    //

    if (*ClockHandle) {

        //
        // alloc a structure to represent the master clock
        //

        NewMasterClockInfo = ExAllocatePool(NonPagedPool, sizeof(MASTER_CLOCK_INFO));

        if (!NewMasterClockInfo) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;

        }

        //
        // This is too early to assign. We have not setup MasterClockInfo yet.
        //
        // StreamObject->MasterClockInfo = MasterClockInfo;

        //
        // reference the clock handle, thereby getting the file object for it.
        //

        if (!NT_SUCCESS((Status = ObReferenceObjectByHandle(*ClockHandle,
                                             FILE_READ_ACCESS | SYNCHRONIZE,
                                                          *IoFileObjectType,
                                                         Irp->RequestorMode,
                                                            &ClockFileObject,
                                                            NULL
                                                            )))) {

            ExFreePool(NewMasterClockInfo);
            NewMasterClockInfo = NULL;
            goto exit;

        }                       // if Ob succeeded
        NewMasterClockInfo->ClockFileObject = ClockFileObject;
        
        // check master clock
        #if 0
        {
            if ( StreamObject->ClockInstance ) {
                //
                // we are chosen the master clock
                //
                DebugPrint((DebugLevelInfo,
                            "--------ClockInstance=%x, FileObject=%x "
                            "Indicated ClockFileObject=%x context=%x\n",
                            StreamObject->ClockInstance,
                            StreamObject->ClockInstance->ParentFileObject,
                            ClockFileObject,
                            ClockFileObject->FsContext));
            }
            else {
                DebugPrint((DebugLevelInfo,
                            "--------Indicated ClockFileObject=%x context=%x\n",
                            ClockFileObject,
                            ClockFileObject->FsContext));
            }
        }
        #endif

        //
        // issue the IOCtl to get the function table of the master clock.
        //

        FuncProperty.Id = KSPROPERTY_CLOCK_FUNCTIONTABLE;
        FuncProperty.Flags = KSPROPERTY_TYPE_GET;

        RtlMoveMemory(&FuncProperty.Set, &KSPROPSETID_Clock, sizeof(GUID));

        if (!NT_SUCCESS((Status = KsSynchronousIoControlDevice(
                                                            ClockFileObject,
                                                               KernelMode,
                                                          IOCTL_KS_PROPERTY,
                                                               &FuncProperty,
                                                         sizeof(KSPROPERTY),
                                            &NewMasterClockInfo->FunctionTable,
                                              sizeof(KSCLOCK_FUNCTIONTABLE),
                                                        &BytesReturned)))) {


            ObDereferenceObject(NewMasterClockInfo->ClockFileObject);
            ExFreePool(NewMasterClockInfo);
            NewMasterClockInfo = NULL;
            goto exit;
        }
    }                           // if *ClockHandle
    //
    // call the minidriver to indicate the master clock. 
    //
    if ( NULL != NewMasterClockInfo ) {
        //
        // but first, let's put in the MasterClockInfo. When mini driver
        // gets notified with the masterclock, it could fire GetTime right away
        // before the notification returns. Get ready to deal with it. This is
        // critical if oldMasterClockInfo is NULL. Not much so otherwise.
        //
        //
        // Make sure no one is querying master clock when setting the new clock info.
        //
        SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );
    }

    Status = SCSubmitRequest(SRB_INDICATE_MASTER_CLOCK,
                             ClockFileObject,
                             0,
                             SCDequeueAndDeleteSrb,
                             StreamObject->DeviceExtension,
                             StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket);

    ASSERT( RequestIssued );
    ASSERT( NT_SUCCESS( Status ) );
    
    //
    // SCSubmitRequest is a synch call. When we return here, We can finish our work
    // based on the Status code.
    //
    if ( NT_SUCCESS( Status )) {
        //
        // Everything is cool. Finish up. The assignment is redundent if 
        // NewMasterClockInfo is not NULL. Better assign unconditionally than check.
        //
        //
        // Make sure no one is querying master clock when updating MasterClockInfo
        //
        SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );

        if (NULL != OldMasterClockInfo) {
            
            ObDereferenceObject(OldMasterClockInfo->ClockFileObject);
            ExFreePool(OldMasterClockInfo);
        }
        
    } else {
        //
        // Failed to tell mini driver the new clock. Clean up shop. But don't update
        // StreamObject->MasterClockInfo. Keep the status quo.
        //
        //
        // Make sure no one is querying master clock when updateing MasterClockInfo.
        //
        SciSetMasterClockInfo( StreamObject, OldMasterClockInfo );
        
        if (NewMasterClockInfo) {
            ObDereferenceObject(ClockFileObject);
            ExFreePool(NewMasterClockInfo);
        }
    }
    
exit:
    KeSetEvent(&StreamObject->ControlSetMasterClock, IO_NO_INCREMENT, FALSE);
    return (Status);

}


NTSTATUS
SCClockGetTime(
               IN PIRP Irp,
               IN PKSPROPERTY Property,
               IN OUT PULONGLONG StreamTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        *StreamTime = SCGetStreamTime(IrpStack->FileObject);

        Irp->IoStatus.Information = sizeof(ULONGLONG);

        return STATUS_SUCCESS;

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}


NTSTATUS
SCClockGetPhysicalTime(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONGLONG PhysicalTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

        *PhysicalTime = SCGetPhysicalTime(IrpStack->FileObject->FsContext);

        Irp->IoStatus.Information = sizeof(ULONGLONG);

        return (STATUS_SUCCESS);

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}


NTSTATUS
SCClockGetSynchronizedTime(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PKSCORRELATED_TIME SyncTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        SyncTime->Time = SCGetSynchronizedTime(IrpStack->FileObject,
                                               &SyncTime->SystemTime);

        Irp->IoStatus.Information = sizeof(KSCORRELATED_TIME);

        return (STATUS_SUCCESS);

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}

NTSTATUS
SCClockGetFunctionTable(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
)
{
    PCLOCK_INSTANCE ClockInstance;
    PIO_STACK_LOCATION IrpStack;
    PSTREAM_OBJECT  StreamObject;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ClockInstance = (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    StreamObject = ClockInstance->ParentFileObject->FsContext;

    RtlZeroMemory(FunctionTable, sizeof(KSCLOCK_FUNCTIONTABLE));

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        FunctionTable->GetTime = (PFNKSCLOCK_GETTIME) SCGetStreamTime;
        FunctionTable->GetCorrelatedTime = (PFNKSCLOCK_CORRELATEDTIME) SCGetSynchronizedTime;

    }
    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

        FunctionTable->GetPhysicalTime = (PFNKSCLOCK_GETTIME) SCGetPhysicalTime;
    }
    Irp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE);
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for a stream

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;
    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE)
    IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->StreamObject;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // call the minidriver to indicate that there is no master clock.
    // processing will continue when the callback procedure is called.
    //

    Status = SCSubmitRequest(SRB_CLOSE_MASTER_CLOCK,
                             NULL,
                             0,
                             SCCloseClockCallback,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);

}


NTSTATUS
SCCloseClockCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS        Status = SRB->HwSRB.Status;
    PCLOCK_INSTANCE ClockInstance;

    PAGED_CODE();

    // log 'cMC ', StreamObject, ClockInstance, Status )
    SCLOG( ' CMc', StreamObject, IrpStack->FileObject->FsContext, Status );

    if (NT_SUCCESS(Status)) {

        //
        // free the clock instance structure and the object header
        //

        ClockInstance =
            (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

        KsFreeObjectHeader(ClockInstance->DeviceHeader);

        ExFreePool(ClockInstance);
        StreamObject->ClockInstance = NULL;

        //
        // dereference the pin handle
        //

        ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);

    }                           // if good status
    SCProcessCompletedRequest(SRB);
    return (Status);

}


NTSTATUS
SCFilterTopologyHandler(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PVOID Data)
/*++

Routine Description:

    Dispatches a pin property request

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - property specific buffer

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
    DeviceObject->DeviceExtension;

    PAGED_CODE();

    IFN_MF(
        return KsTopologyPropertyHandler(Irp,
                                     Property,
                                     Data,
                    DeviceExtension->StreamDescriptor->StreamHeader.Topology
        );
    )
    IF_MFS(
        PFILTER_INSTANCE FilterInstance;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
        
        return KsTopologyPropertyHandler(
                    Irp,
                    Property,
                    Data,
                    FilterInstance->StreamDescriptor->StreamHeader.Topology);
    )
}



NTSTATUS
SCFilterPinIntersectionHandler(
                               IN PIRP Irp,
                               IN PKSP_PIN Pin,
                               OUT PVOID Data
)
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
    DeviceObject->DeviceExtension;

    PAGED_CODE();

    IFN_MF(
        return KsPinDataIntersection(
                                 Irp,
                                 Pin,
                                 Data,
                                 DeviceExtension->NumberOfPins,
                                 DeviceExtension->PinInformation,
                                 SCIntersectHandler);
    )
    IF_MFS(
        PSTREAM_OBJECT StreamObject;
        PFILTER_INSTANCE FilterInstance;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
        
        DebugPrint((DebugLevelVerbose, 
                   "PinIntersection FilterInstance=%p\n", FilterInstance ));
                   
        return KsPinDataIntersection(
                                 Irp,
                                 Pin,
                                 Data,
                                 FilterInstance->NumberOfPins,
                                 FilterInstance->PinInformation,
                                 SCIntersectHandler);
    )    
}

NTSTATUS
SCIntersectHandler(
                   IN PIRP Irp,
                   IN PKSP_PIN Pin,
                   IN PKSDATARANGE DataRange,
                   OUT PVOID Data
)
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. If there is a wave format selected in a current pin
    connection, and it is contained within the data range passed in, it is chosen
    as the data format to return. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;
    PFILTER_INSTANCE FilterInstance;
    STREAM_DATA_INTERSECT_INFO IntersectInfo;
    PDEVICE_EXTENSION DeviceExtension;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
    DeviceExtension = (PDEVICE_EXTENSION)
        IrpStack->DeviceObject->DeviceExtension;

    ASSERT_FILTER_INSTANCE( FilterInstance );
    ASSERT_DEVICE_EXTENSION( DeviceExtension );

    //
    // fill in the intersect info struct from the input params.
    //

    IntersectInfo.DataRange = DataRange;
    IntersectInfo.DataFormatBuffer = Data;
    IntersectInfo.SizeOfDataFormatBuffer =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    IntersectInfo.StreamNumber = Pin->PinId;

    //
    // call the minidriver to process the intersection.  processing will
    // continue
    // when the callback procedure is called.  take the event to ensure that
    // pins don't come and go as we process the intersection.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    Status = SCSubmitRequest(SRB_GET_DATA_INTERSECTION,
                             &IntersectInfo,
                             0,
                             SCDataIntersectionCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }
    return Status;
}


NTSTATUS
SCDataIntersectionCallback(
                           IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a data intersection query.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status = SRB->HwSRB.Status;

    PAGED_CODE();

    Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    //
    // signal the event
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    SCDequeueAndDeleteSrb(SRB);
    return (Status);

}

NTSTATUS
SCGetStreamHeaderSize(
                      IN PIRP Irp,
                      IN PKSPROPERTY Property,
                      IN OUT PULONG StreamHeaderSize
)
/*++

Routine Description:

     Process the get stream header extension property

Arguments:

Return Value:

     None.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    PAGED_CODE();

    ASSERT(StreamObject);

    *StreamHeaderSize = StreamObject->HwStreamObject.StreamHeaderMediaSpecific;

    Irp->IoStatus.Information = sizeof(ULONG);
    return (STATUS_SUCCESS);

}

NTSTATUS
DllUnload(
          VOID
)
{
    NTSTATUS Status=STATUS_SUCCESS;
    
    #if DBG
    NTSTATUS DbgDllUnload();
    DebugPrint((1, "Stream Class DllUnload: Unloading\n"));
    Status = DbgDllUnload();
    #endif 

    return Status;
}
#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
NTSTATUS
SCStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
    )

/*++

Routine Description:
    If KSPROPERTY_TYPE_SET, this function sets the stream allocator
    for this connection by referencing the file handle to obtain
    the file object pointer and stores this pointer in the filter(stream?)
    instance structure.

    Otherwise, a KSPROPERTY_TYPE_GET request returns a NULL handle
    and STATUS_SUCCESS to show that we support allocator creation.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    IN OUT PHANDLE AllocatorHandle -
        pointer to the handle representing the file object

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      IrpStack;
    PSTREAM_OBJECT          StreamObject;
    PDEVICE_EXTENSION       DeviceExtension;

    IrpStack = IoGetCurrentIrpStackLocation( Irp );

    StreamObject = IrpStack->FileObject->FsContext;

    DebugPrint((DebugLevelTrace, "STREAM:entering SCStreamAllocator:Stream:%x\n",StreamObject));
    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // allocators.  The returned handle is always NULL, but we
        // signal that we support the creation of allocators by
        // returning STATUS_SUCCESS.
        //
        *AllocatorHandle = NULL;
        Status = STATUS_SUCCESS;
        DebugPrint((DebugLevelTrace,"SCStreamAllocator-GET"));
    } else {
        PFILTER_INSTANCE    FilterInstance;

        FilterInstance =
            (PFILTER_INSTANCE) StreamObject->FilterFileObject->FsContext;

        DeviceExtension = StreamObject->DeviceExtension;

        DebugPrint((DebugLevelTrace,"SCStreamAllocator-SET"));
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

        //
        // The allocator can only be specified when the device is
        // in KSSTATE_STOP.
        //

        if (StreamObject->CurrentState != KSSTATE_STOP) {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            DebugPrint((DebugLevelTrace,"SCStreamAllocator-device not in STOP"));
            return STATUS_INVALID_DEVICE_STATE;
        }

// if we are in _STOP, the flush was already done.
// this call may have to be enabled.
//
//        StreamFlushIo(DeviceExtension, StreamObject);

        //
        // Release the previous allocator, if any.
        //
        if (StreamObject->AllocatorFileObject) {
            ObDereferenceObject( StreamObject->AllocatorFileObject );
            StreamObject->AllocatorFileObject = NULL;
        }

        //
        // Reference this handle and store the resultant pointer
        // in the filter instance.  Note that the default allocator
        // does not ObReferenceObject() for its parent
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the allocator and the pin object has a reference to the
        // allocator file object.
        //
        if (*AllocatorHandle != NULL) {
            Status =
                ObReferenceObjectByHandle(
                    *AllocatorHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    *IoFileObjectType,
                    ExGetPreviousMode(),
                    &StreamObject->AllocatorFileObject,
                    NULL );
        DebugPrint((DebugLevelTrace, "SCStreamAllocator: got %x as Allocator file object\n",StreamObject->AllocatorFileObject));
        } else {
            Status = STATUS_SUCCESS;
        }
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }

    DebugPrint((DebugLevelTrace,"exiting SCStreamAllocator-normal path\n"));
    return Status;
}

//---------------------------------------------------------------------------
BOOLEAN
HeaderTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject,
    IN PFILE_OBJECT   DestinationFileObject,
    IN OUT PSTREAM_HEADER_EX *StreamHeader
    )

/*++

Routine Description:
    Sets up the stream header for a no-copy transfer to the
    opposite pin.

Arguments:
    IN PFILTER_INSTANCE FilterInstance -
        pointer to the filter instance

    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance structure

    IN PSTREAM_OBJECT DestinationInstance -
        pointer to the opposite transform instance structure

    IN OUT PSTREAM_HEADER_EX *StreamHeader -
        pointer containing a pointer to the current stream header,
        this member is updated with a pointer to the next stream
        header to submit to the opposite pin or NULL if there is
        no header to submit.

Return:
    An indication of whether stop can proceed now or not

Comments:
    Not pageable, uses SpinLocks.
    
--*/

{
    KIRQL               irqlQueue, irqlFree;
    ULONG WhichQueue = (*StreamHeader)->WhichQueue;    
    ULONG OppositeQueue = WhichQueue ^ 0x00000001; // 1 to 0, 0 to 1   
    BOOLEAN SignalStop = FALSE;
    
    ASSERT(DestinationFileObject);
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    if (StreamObject->PinState > PinStopPending) { // if normal running case

        //
        // If we are here after submitting an ENDOFSTREAM Irp to the 
        // outflow pin, then we have already read the end of stream 
        // from the input and there is no need to continue I/O.
        //    
    
        if (DestinationFileObject) {
            ULONG HeaderFlags = (*StreamHeader)->Header.OptionsFlags;

            //
            // Clear the options flags so that we continue
            // reading from where we left off.  
            //
            
//            (*StreamHeader)->Header.OptionsFlags = 0;
        
            //
            // Reset the stream segment valid data length
            //
//            (*StreamHeader)->Header.DataUsed = 0;
//            (*StreamHeader)->Header.Duration = 0;
                
            //
            // Check for the end of the stream.
            //
            if ((HeaderFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) ||
                StreamObject->EndOfStream) {
                
                DebugPrint((DebugLevelTrace,
                    "end of stream") );
                
                //
                // Make sure that this is set for the next time through.
                //
                StreamObject->EndOfStream = TRUE;


                if (!(*StreamHeader)->ReferenceCount) {
                    
                    //
                    // Put the header back on the free list of the inflow pin.
                    //
                    
                    KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
#if (DBG)
                    if ((*StreamHeader)->OnFreeList) {
                        DebugPrint((DebugLevelTrace,
                            "stream header already on free list.") );
                    }
#endif
                    DebugPrint((DebugLevelTrace,
                        "EOS adding %x to free queue", *StreamHeader) );

                    InsertTailList( 
                        &StreamObject->FreeQueue, 
                        &(*StreamHeader)->ListEntry );

                    if (!InterlockedDecrement (
                        &StreamObject -> QueuedFramesPlusOne
                        ))
                        SignalStop = TRUE;

#if (DBG)
                    (*StreamHeader)->OnFreeList = TRUE;
                    if ((*StreamHeader)->OnActiveList) {
                        DebugPrint((DebugLevelTrace,
                            "stream header on both lists.") );
                    }
#endif
                    KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        
                }                        
                
                //
                // No more I/O to opposite pin.
                //
                *StreamHeader = NULL;
            }
        }
    
        //
        // Grab the spin lock for the other queue, insert this
        // stream header on the queue.
        //
        
        if (*StreamHeader) {
            KeAcquireSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, &irqlQueue );

#if (DBG)
            if ((*StreamHeader)->OnActiveList) {
                DebugPrint((DebugLevelTrace,
                    "stream header already on active list.") );
            }
#endif

            InsertTailList(
                &StreamObject->Queues[OppositeQueue].ActiveQueue,
                &(*StreamHeader)->ListEntry );
#if (DBG)
            (*StreamHeader)->OnActiveList = TRUE;

            if ((*StreamHeader)->OnFreeList) {
                DebugPrint((DebugLevelTrace,
                    "stream header on both lists.") );
            }
#endif
            KeReleaseSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, irqlQueue );        
        }
        
    } 
    else                           // pin stop IS pending 
    {
        //
        // Location of frames (for this type of transfer, all frames
        // are held on the source pin).
        //
        
        if (!(*StreamHeader)->ReferenceCount) {
    
            DebugPrint((DebugLevelTrace,
                "stop: adding %x to free queue.", *StreamHeader) );
    
            KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
#if (DBG)
            if ((*StreamHeader)->OnFreeList) {
                DebugPrint((DebugLevelTrace,
                    "stream header already on free list.") );
            }
#endif
            InsertTailList( 
                &StreamObject->FreeQueue, &(*StreamHeader)->ListEntry );

            if (!InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) 
                SignalStop = TRUE;
#if (DBG)
            (*StreamHeader)->OnFreeList = TRUE;
            if ((*StreamHeader)->OnActiveList) {
                DebugPrint((DebugLevelTrace,
                    "stream header on both lists.") );
            }
#endif
            KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        
        }
    
        //
        // No I/O to opposite pin this round.
        //

        *StreamHeader = NULL;

    }

    return SignalStop;

}
//---------------------------------------------------------------------------
VOID
IoWorker(
    PVOID Context,
    ULONG WhichQueue
    )

/*++

Routine Description:
    This is the work item for the source pins.  Walks the queue
    associated with the stream header looking for sequentially 
    completed headers and submits those headers to the opposite
    pin.

Arguments:
    PVOID Context -
        pointer to the stream header 

Return:
    Nothing.
    
Comments:
    Not pageable, uses SpinLocks.
    
--*/

{
    KIRQL               irqlOld;
    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PLIST_ENTRY         Node;
    PSTREAM_OBJECT      StreamObject;
    PFILE_OBJECT        DestinationFileObject;
    PSTREAM_HEADER_EX   StreamHeader;
    NTSTATUS            Status;
    ULONG               Operation;
    PDEVICE_EXTENSION   DeviceExtension;
    BOOLEAN             SignalStop = FALSE;
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    StreamObject =  (PSTREAM_OBJECT) Context;

    DeviceExtension = StreamObject->DeviceExtension;

#if (DBG)
    DebugPrint((DebugLevelTrace,
        "entering IoWorker:Source StreamObject:%x\n",StreamObject));
#endif
    FilterInstance = 
        (PFILTER_INSTANCE)
            StreamObject->FilterFileObject->FsContext;

    if (!FilterInstance) {
        //
        // For some reason, the filter instance has gone missing.
        //
        DebugPrint((DebugLevelTrace,
            "error: FilterInstance has gone missing.\n") );
        return;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    //
    // Synchronize with control changes and protect from reentrancy.
    //    

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
     
    //
    // Synchronize with queues.
    //

    KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
    
    //
    // Loop while there are completed items on the queue.
    //     
    
    while (!IsListEmpty( &StreamObject->Queues[WhichQueue].ActiveQueue )) {
        Node = StreamObject->Queues[WhichQueue].ActiveQueue.Flink;
        
        StreamHeader = 
            CONTAINING_RECORD( 
                Node,
                STREAM_HEADER_EX,
                ListEntry );
        
#if (DBG)
            DebugPrint((DebugLevelTrace,
                "got StreamHeader:%08x\n", StreamHeader ));
#endif
        if (StreamHeader->ReferenceCount) {

            DebugPrint((DebugLevelTrace,
                "breaking StreamHeader:%08x\n", StreamHeader ));

            break;
        } else {
            //
            // Remove this header from the current queue.
            //
            
            RemoveHeadList( &StreamObject->Queues[WhichQueue].ActiveQueue );
#if (DBG)
            StreamHeader->OnActiveList = FALSE;
#endif
            KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
            
            //
            // Wait for the APC to complete.  Note that if an error was
            // returned, the I/O status block is not updated and the
            // event is not signalled.
            //
            
            DebugPrint((DebugLevelTrace,
                "waiting for StreamHeader (%08x) to complete\n",  StreamHeader ));
        
            KeWaitForSingleObject(
                &StreamHeader->CompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);

            DebugPrint((DebugLevelTrace,
                "StreamHeader (%08x) completed\n",  StreamHeader));
        
            DestinationFileObject = 
                StreamHeader->NextFileObject;

            //
            // At the time this returns TRUE, the loop will be finished.
            //
            SignalStop = HeaderTransfer(
                FilterInstance,
                StreamObject, 
                DestinationFileObject,
                &StreamHeader );
        

            if (StreamHeader)
            {    
                DebugPrint((DebugLevelTrace, "IoWorker issuing: "));

                if (DestinationFileObject == StreamObject->NextFileObject)
                {
                    DebugPrint((DebugLevelTrace,"KSSTREAM_WRITE:dest=%x\n",DestinationFileObject));

                    Operation = KSSTREAM_WRITE;

                    StreamHeader->NextFileObject =
                        StreamObject->FileObject;

					#if (DBG)
                    if (StreamHeader->Id == 7)
                        DebugPrint((DebugLevelVerbose,"iw%x\n",StreamHeader->Id));
                    else
                        DebugPrint((DebugLevelVerbose,"iw%x",StreamHeader->Id));
					#endif

                }
                else
                {
                    DebugPrint((DebugLevelTrace,"KSSTREAM_READ:dest=%x\n",DestinationFileObject));
                    Operation = KSSTREAM_READ;
                    StreamHeader->Header.OptionsFlags = 0;
                    //
                    // Reset the stream segment valid data length
                    //
                    StreamHeader->Header.DataUsed = 0;
                    StreamHeader->Header.Duration = 0;

                    StreamHeader->NextFileObject = StreamObject->NextFileObject;
					#if (DBG)
                    if (StreamHeader->Id == 7)
                        DebugPrint((DebugLevelVerbose,"ir%x\n",StreamHeader->Id));
                    else
                        DebugPrint((DebugLevelVerbose,"ir%x",StreamHeader->Id));
					#endif
                }

                InterlockedIncrement( &StreamHeader->ReferenceCount );

                StreamHeader->WhichQueue = WhichQueue ^ 0x00000001;

                Status =    
                    KsStreamIo(
                        DestinationFileObject,
                        &StreamHeader->CompletionEvent, // Event
                        NULL,                           // PortContext
                        IoCompletionRoutine,
                        StreamHeader,                   // CompletionContext
                        KsInvokeOnSuccess |
                            KsInvokeOnCancel |
                            KsInvokeOnError,
                        &StreamHeader->IoStatus,
                        &StreamHeader->Header,
                        StreamHeader->Header.Size,
                        KSSTREAM_SYNCHRONOUS | Operation,
                        KernelMode );
                
                if (Status != STATUS_PENDING) {
                    //
                    // If this I/O completes immediately (failure or not), the
                    // event is not signalled.
                    //
                    KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );
                }
            }
            KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
        }
    //
    // Ok to schedule another work item now.
    //
    } // end while
    
    InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, FALSE );

    // 
    // If a stop needs to be signalled, signal it.
    //    
    if (SignalStop) { 
        KeSetEvent( &StreamObject->StopEvent,
                    IO_NO_INCREMENT,
                    FALSE );
    }

    KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
    
    //
    // Release the control event
    //
    
    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    DebugPrint((DebugLevelTrace,"exiting IoWorker\n"));
}
//---------------------------------------------------------------------------
/*++

Routine Description:
    These are the work items for the source and destination pins.  
    Calls the IoWorker code above, passing in READ or WRITE header
    queue information. 

Arguments:
    PVOID Context -
        pointer to the stream header 

Return:
    Nothing.
    
Comments:
    
--*/

VOID
IoWorkerRead(
    PVOID Context
    )
{
    IoWorker(Context,READ);
}

VOID
IoWorkerWrite(
    PVOID Context
    )
{
    IoWorker(Context,WRITE);
}
//---------------------------------------------------------------------------
NTSTATUS
IoCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:
    Processes the completion of the given Irp by marking the
    associated stream header as completed and scheduling a
    worker item to complete processing if necessary.

Arguments:
    PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    PIRP Irp -
        pointer to the I/O request packet

    PVOID Context -
        a context pointer (pointer to the associated stream header)
        

Return:
    The IoStatus.Status member of the Irp.

Comments:
    Not pageable, uses SpinLocks and may be called at DISPATCH_LEVEL.
    
--*/

{
    KIRQL               irqlOld;
    PSTREAM_HEADER_EX   StreamHeader = Context;
    PFILTER_INSTANCE    FilterInstance;
    PSTREAM_OBJECT      StreamObject;
    ULONG WhichQueue;
    
#if (DBG)
     ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
                        
    StreamObject = 
        (PSTREAM_OBJECT) StreamHeader->OwnerFileObject->FsContext;

    DebugPrint((DebugLevelTrace,
        "IoCompletionRoutine:StreamHeader %08x, StreamObject %08x\n",StreamHeader,StreamObject));

    FilterInstance = 
        (PFILTER_INSTANCE) 
            StreamHeader->OwnerFileObject->RelatedFileObject->FsContext;
        
        
    WhichQueue = StreamHeader->WhichQueue;
    KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
    
    //
    // Remove this reference count on the IRP so that we can continue
    // the loop if this work item is not the head item of the list.
    //

    InterlockedDecrement( &StreamHeader->ReferenceCount );
    
    //
    // Copy the status block so that we don't have to wait for the APC.
    //
    StreamHeader->IoStatus = Irp->IoStatus;

    //
    // Sweep the active queue in the worker to complete the transfer.
    //
    if (!StreamObject->Queues[WhichQueue].WorkItemQueued) {
        //
        // A work item is not pending, initialize the worker item
        // for the new context and queue it.
        //

        ExInitializeWorkItem( 
            &StreamObject->Queues[WhichQueue].WorkItem,
            (WhichQueue == READ) ? IoWorkerRead : IoWorkerWrite,
            StreamObject );
    
        InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, TRUE );
        
        KsQueueWorkItem( 
            (WhichQueue == READ) ? FilterInstance->WorkerRead :
            FilterInstance->WorkerWrite,
            &StreamObject->Queues[WhichQueue].WorkItem );
    }
    
    KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
    
    
    DebugPrint((DebugLevelTrace,
        "exiting IoCompletionRoutine:Irp->IoStatus.Status:%x\n",Irp->IoStatus.Status));

    return Irp->IoStatus.Status;
}
//---------------------------------------------------------------------------
NTSTATUS
PrepareTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    Prepares for the data transfer by distributing the assigned allocators
    for the source and destination pins.

Arguments:
    IN PFILTER_INSTANCE FilterInstance,
        pointer to the filter instance
        
    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance
        
Return:
    STATUS_SUCCESS or an appropriate error code.

--*/

{
    KSPROPERTY                  Property;
    KSSTREAMALLOCATOR_STATUS    AllocatorStatus;
    NTSTATUS                    Status;
    PSTREAM_HEADER_EX           StreamHeader;
    ULONG                       i, Returned;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    
    //
    // If the PinState is not PinStopped, then return.
    //
    
    DebugPrint((DebugLevelTrace,"entering PrepareTransfer\n"));
    
    if (!StreamObject->AllocatorFileObject) {
        DebugPrint((DebugLevelTrace,"!! AllocatorFileObject is NULL"));
        return STATUS_SUCCESS;
    }
    if (StreamObject->PinState != PinStopped) {
        //
        // We only need to do this work when the pin has been 
        // completely stopped.  If we were running, just reflect the
        // state.
        //
        DebugPrint((DebugLevelTrace,"PrepareTransfer exiting, PinState != PinStopped\n"));
        StreamObject->PinState = PinPrepared;    
        return STATUS_SUCCESS;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    //
    // Retrieve the allocator framing information for the pin.
    //    
    
    Property.Set = KSPROPSETID_StreamAllocator;
    Property.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;
    Property.Flags = KSPROPERTY_TYPE_GET;
    
    Status = 
        KsSynchronousIoControlDevice(
            StreamObject->AllocatorFileObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof( Property ),
            &AllocatorStatus,
            sizeof( AllocatorStatus ),
            &Returned );
    
    if (!NT_SUCCESS( Status )) 
    {
        DebugPrint((DebugLevelTrace,
            "PrepareTransfer exiting, unable to retrieve allocator status\n"));
        return Status;        
    }        
    
    //
    // Save the framing information
    //    

    StreamObject->Framing = AllocatorStatus.Framing;    
            
    //
    // Allocate the frames from the allocator
    //
    // 1. Always allocate frames when starting the IrpSource.
    //
    // 2. If the allocator is not shared, then allocate the frames when
    //    the (each) destination pin is started.
    //
    
    if (StreamObject->PinType == IrpSource) {

        InterlockedExchange (&StreamObject -> QueuedFramesPlusOne, 1);

#if (DBG)
       DebugPrint((DebugLevelTrace,"Framing.Frames:%x\n", StreamObject->Framing.Frames));
       DebugPrint((DebugLevelTrace,"Framing.FrameSize:%x\n", StreamObject->Framing.FrameSize));
#endif
        for (i = 0; i < StreamObject->Framing.Frames; i++) {
			DebugPrint((DebugLevelTrace,"StreamObject->ExtendedHeaderSize:%x\n", StreamObject->HwStreamObject.StreamHeaderMediaSpecific));

            StreamHeader = 
                ExAllocatePoolWithTag( 
                    NonPagedPool, 
                    sizeof( STREAM_HEADER_EX ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific,
                    STREAMCLASS_TAG_STREAMHEADER );
                                
            if (NULL == StreamHeader) {
                DebugPrint((DebugLevelTrace,
                    "out of pool while allocating frames\n") );
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                
                RtlZeroMemory( 
                    StreamHeader, 
                    sizeof( STREAM_HEADER_EX ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific);

                KeInitializeEvent( 
                    &StreamHeader->CompletionEvent, 
                    SynchronizationEvent, 
                    FALSE );

                StreamHeader->Header.Size =
                    sizeof( KSSTREAM_HEADER ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific;
                        
                if (StreamObject->HwStreamObject.StreamHeaderMediaSpecific) {                        
                    *(PULONG)((&StreamHeader->Header) + 1) =
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific;
                }                        
                
                Status = 
                    AllocateFrame( 
                        StreamObject->AllocatorFileObject, 
                        &StreamHeader->Header.Data );
#if (DBG)                        
                //
                // Track who is stomping on the headers...
                //        
                StreamHeader->Data = StreamHeader->Header.Data;        
#endif                

                StreamHeader->WhichQueue = READ;

                StreamHeader->Id = i;
                
                if (!NT_SUCCESS( Status )) {
                    DebugPrint((DebugLevelTrace,
                        "failed to allocate a frame\n") );
                    //
                    // Free this header here and the routine below will 
                    // clean up whatever has been added to the queue.
                    // 
                    
                    ExFreePool( StreamHeader );
                } else {
                    //
                    // Start with the owner file object as this connection,
                    // if a no-copy condition exists, this will be adjusted
                    // in the transfer function.
                    //
                    StreamHeader->OwnerFileObject = 
                        StreamObject->FileObject;
                    StreamHeader->Header.DataUsed = 0;
                    StreamHeader->Header.FrameExtent = 
                        StreamObject->Framing.FrameSize;
#if (DBG)
                    if (StreamHeader->OnFreeList) {
                        DebugPrint((DebugLevelTrace,"stream header already on free list.\n") );
                    }
#endif
                    InsertTailList( 
                        &StreamObject->FreeQueue, 
                        &StreamHeader->ListEntry );
#if (DBG)
                    StreamHeader->OnFreeList = TRUE;
#endif
                }
            }    
        }
        
        //
        // Clean up orphaned frames from the allocator and free headers
        // to the pool if there was a failure.
        //   
         
        if (!NT_SUCCESS( Status )) {
            while (!IsListEmpty( &StreamObject->FreeQueue )) {
                PLIST_ENTRY Node;
                
                Node = RemoveHeadList( &StreamObject->FreeQueue );
                StreamHeader = 
                    CONTAINING_RECORD( 
                        Node,
                        STREAM_HEADER_EX,
                        ListEntry );

#if (DBG)
                StreamHeader->OnFreeList = FALSE;

                ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
                FreeFrame( 
                    StreamObject->AllocatorFileObject, 
                    StreamHeader->Header.Data );

#if (DBG)
                if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
                    DebugPrint((DebugLevelTrace,
                        "freeing header %x still on list\n", StreamHeader) );
                }
#endif
                ExFreePool( StreamHeader );
            }
            DebugPrint((DebugLevelTrace,
                "PrepareTransfer exiting, frame allocation failed: %08x\n", Status) );
            return Status;    
        } 
    }

    StreamObject->PinState = PinPrepared;    

    DebugPrint((DebugLevelTrace,"exiting PrepareTransfer\n"));

    return STATUS_SUCCESS;    
}

//---------------------------------------------------------------------------

NTSTATUS
BeginTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    Begins the data transfer from each pin by initiating stream reads
    from the inflow pin. The completion routine for each read will
    continue the stream processing.

Arguments:
    IN PFILTER_INSTANCE FilterInstance,
        pointer to the filter instance
        
    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance
        
Return:
    STATUS_SUCCESS or an appropriate error code.
    
Comments:
    Not pageable, uses SpinLocks.

--*/

{
    KIRQL                       irql0,irqlFree;
    NTSTATUS                    Status;
    PSTREAM_HEADER_EX           StreamHeader;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    
    DebugPrint((DebugLevelTrace,"entering BeginTransfer\n"));
    
    //
    // If the PinState is not PinPrepared, then return.
    //
    
    if (StreamObject->PinState != PinPrepared) {
        DebugPrint((DebugLevelTrace,"BeginTransfer exiting, PinState != PinPrepared\n") );
        return STATUS_INVALID_DEVICE_STATE;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    StreamObject->PinState = PinRunning;
    
    //
    // All preparation is complete.  If this is the source pin, begin
    // the actual data transfer.
    //
    
    Status = STATUS_SUCCESS;
    
    if (StreamObject->PinType == IrpSource) {

#if (DBG)
//
// get the dataflow direction
//
            DebugPrint((DebugLevelVerbose,
                "BeginTransfer, DataFlow:"));
    
            if (StreamObject->DeviceExtension->StreamDescriptor->StreamInfo.DataFlow == KSPIN_DATAFLOW_IN)
                    DebugPrint((DebugLevelVerbose,
                        "KSPIN_DATAFLOW_IN\n"));
            else
                DebugPrint((DebugLevelVerbose,
                    "KSPIN_DATAFLOW_OUT\n"));
#endif
        //
        // Begin the transfer by reading from the inflow pin.
        // 
        
        KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );
        KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
        while (!IsListEmpty( &StreamObject->FreeQueue )) {
            PLIST_ENTRY Node;
            
            Node = RemoveHeadList( &StreamObject->FreeQueue );

            StreamHeader = 
                CONTAINING_RECORD( 
                    Node,
                    STREAM_HEADER_EX,
                    ListEntry );
#if (DBG)
            StreamHeader->OnFreeList = FALSE;

            if (StreamHeader->OnActiveList) {
                DebugPrint((DebugLevelTrace,"stream header %x already on active list.\n",StreamHeader) );
            }
#endif
            InterlockedIncrement (&StreamObject -> QueuedFramesPlusOne);
            InsertTailList( &StreamObject->Queues[0].ActiveQueue, Node );

#if (DBG)
            StreamHeader->OnActiveList = TRUE;
#endif

            KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );
            KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );

            DebugPrint((DebugLevelTrace,
                "BeginTransfer, KsStreamIo: %x\n", StreamHeader));
                
            DebugPrint((DebugLevelTrace,
                "BeginTransfer, KsStreamIo: FileObject:%x\n", StreamObject->FileObject));
            DebugPrint((DebugLevelTrace,
                "BeginTransfer:HeaderSize:=%x\n",StreamHeader->Header.Size));

            InterlockedIncrement( &StreamHeader->ReferenceCount );

            StreamHeader->NextFileObject = StreamObject->NextFileObject;

			//
			// send a data irp to myself, first.
			//
            DebugPrint((DebugLevelTrace,
                "BeginTransfer:Reading:%x\n",StreamHeader->Id));
            Status =
                KsStreamIo(
                    StreamObject->FileObject,
                    &StreamHeader->CompletionEvent,     // Event
                    NULL,                               // PortContext
                    IoCompletionRoutine,
                    StreamHeader,                       // CompletionContext
                    KsInvokeOnSuccess |
                        KsInvokeOnCancel |
                        KsInvokeOnError,
                    &StreamHeader->IoStatus,
                    &StreamHeader->Header,
                    StreamHeader->Header.Size,
                    KSSTREAM_SYNCHRONOUS | KSSTREAM_READ,
                    KernelMode );
            
            if (Status != STATUS_PENDING) {
                //
                // If this I/O completes immediately (failure or not), the
                // event is not signalled.
                //
                KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );
            }        
            
            if (!NT_SUCCESS( Status )) {
                DebugPrint((DebugLevelTrace, "KsStreamIo returned %08x\n", Status ));
            } else {
                Status = STATUS_SUCCESS;
            }
            KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );
            KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
        }        
        KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );
        KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );
    }

    DebugPrint((DebugLevelTrace,"exiting BeginTransfer\n"));
    return Status;
}

//---------------------------------------------------------------------------

NTSTATUS
EndTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT   StreamObject
    )

/*++

Routine Description:
    Ends the data transfer, waits for all Irps to complete

Arguments:
    IN PFILTER_INSTANCE FilterInstance -
        pointer to the filter instance

    IN PSTREAM_OBJECT   StreamObject
        pointer to the Stream object

Return:
    STATUS_SUCCESS or an appropriate error code.

Comments:
    Not pageable, uses SpinLocks.

--*/

{
    PDEVICE_EXTENSION   DeviceExtension;
    KIRQL irqlOld;

    DeviceExtension = StreamObject->DeviceExtension;
    
    DebugPrint((DebugLevelTrace,"entering EndTransfer!\n"));

    //
    // Set the marker indicating that we stop sourcing frames and then flush
    // to ensure that anything blocked on the output pin at least gets 
    // cancelled before we block and deadlock on it.
    //
    StreamObject -> PinState = PinStopPending;
    StreamFlushIo (DeviceExtension, StreamObject);
    if (InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) {
        //
        // Release the control mutex to allow the I/O thread to run.
        //
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

        DebugPrint((DebugLevelTrace,
            "waiting for pin %d queue to empty\n", StreamObject->PinId));
        
        //
        // Wait for the queue to empty
        //
        KeWaitForSingleObject(
            &StreamObject -> StopEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    
        DebugPrint((DebugLevelTrace,"queue emptied\n") );
        
        //
        // Re-acquire the control object.
        //    
        
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
    }

    //
    // Free the frames so that we can reprepare for new allocator
    // framing, a new allocator or just general cleanup/shutdown.
    //    
    
    KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );
    
    while (!IsListEmpty( &StreamObject->FreeQueue )) {
    
        PLIST_ENTRY         Node;
        PSTREAM_HEADER_EX   StreamHeader;
        
        Node = RemoveHeadList( &StreamObject->FreeQueue );

        StreamHeader = 
            CONTAINING_RECORD( 
                Node,
                STREAM_HEADER_EX,
                ListEntry );

#if (DBG)
        StreamHeader->OnFreeList = FALSE;
#endif
        KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    
#if (DBG)
        ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
        FreeFrame( 
            StreamObject->AllocatorFileObject, 
            StreamHeader->Header.Data );

        DebugPrint((DebugLevelTrace,
            "freeing header: %08x, list: %08x\n", StreamHeader, &StreamObject->FreeQueue) );

#if (DBG)
        if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
            DebugPrint((DebugLevelTrace,
                "freeing header %x still on list\n", StreamHeader) );
        }
#endif

        ExFreePool( StreamHeader );

        KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );
    }
    StreamObject->PinState = PinStopped;

    KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    
    
    DebugPrint((DebugLevelTrace,"exiting CleanupTransfer\n"));
    return STATUS_SUCCESS;
}

//---------------------------------------------------------------------------

NTSTATUS
AllocateFrame(
    PFILE_OBJECT Allocator,
    PVOID *Frame
    )

/*++

Routine Description:
    Allocates a frame from the given allocator

Arguments:
    PFILE_OBJECT Allocator -
        pointer to the allocator's file object

    PVOID *Frame -
        pointer to receive the allocated frame pointer

Return:
    STATUS_SUCCESS and *Frame contains a pointer to the allocated
    frame, otherwise an appropriate error code.

--*/

{
    NTSTATUS    Status;
    KSMETHOD    Method;
    ULONG       Returned;

    DebugPrint((DebugLevelTrace,"entering AllocateFrame\n"));
    Method.Set = KSMETHODSETID_StreamAllocator;
    Method.Id = KSMETHOD_STREAMALLOCATOR_ALLOC;
    Method.Flags = KSMETHOD_TYPE_WRITE;

    Status =
        KsSynchronousIoControlDevice(
            Allocator,
            KernelMode,
            IOCTL_KS_METHOD,
            &Method,
            sizeof( Method ),
            Frame,
            sizeof( PVOID ),
            &Returned );

    DebugPrint((DebugLevelTrace,"exiting AllocateFrame\n"));
    return Status;
}

//---------------------------------------------------------------------------

NTSTATUS
FreeFrame(
    PFILE_OBJECT Allocator,
    PVOID Frame
    )

/*++

Routine Description:
    Frees a frame to the given allocator

Arguments:
    PFILE_OBJECT Allocator -
        pointer to the allocator's file object

    PVOID Frame -
        pointer to the frame to be freed.

Return:
    STATUS_SUCCESS or else an appropriate error code.

--*/

{
    NTSTATUS    Status;
    KSMETHOD    Method;
    ULONG       Returned;

    DebugPrint((DebugLevelTrace,"entering FreeFrame\n"));
    Method.Set = KSMETHODSETID_StreamAllocator;
    Method.Id = KSMETHOD_STREAMALLOCATOR_FREE;
    Method.Flags = KSMETHOD_TYPE_READ;

    Status =
        KsSynchronousIoControlDevice(
            Allocator,
            KernelMode,
            IOCTL_KS_METHOD,
            &Method,
            sizeof( Method ),
            &Frame,
            sizeof( PVOID ),
            &Returned );

    DebugPrint((DebugLevelTrace,"exiting FreeFrame\n"));
    return Status;
}
//---------------------------------------------------------------------------

NTSTATUS 
PinCreateHandler(
    IN PIRP Irp,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    This is the pin creation handler which is called by KS when a
    pin create request is submitted to the filter.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS or an appropriate error return code.

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpStack;
    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    PFILE_OBJECT    NextFileObject;


    IrpStack = IoGetCurrentIrpStackLocation( Irp );
    DebugPrint((DebugLevelTrace,"entering PinCreateHandler\n"));

    FilterInstance = 
        (PFILTER_INSTANCE) IrpStack->FileObject->RelatedFileObject->FsContext;
    AdditionalInfo = FilterInstance->PinInstanceInfo;

    Status = STATUS_SUCCESS;
    StreamObject->NextFileObject = NULL;

    DebugPrint((DebugLevelTrace,"PinCreateHandler:its an IrpSource\n"));
    //
    // Validate that we can handle this connection request
    //
    if (StreamObject->NextFileObject) {
        DebugPrint((DebugLevelTrace,"invalid connection request\n") );
        Status = STATUS_CONNECTION_REFUSED;
	}
    else
	{
	    Status =
    	    ObReferenceObjectByHandle( 
        	    StreamObject->PinToHandle,
	            FILE_READ_ACCESS | FILE_WRITE_ACCESS | SYNCHRONIZE,
    	        *IoFileObjectType,
        	    KernelMode, 
            	&NextFileObject,
	            NULL );
    
    	if (!NT_SUCCESS(Status)) {
        	DebugPrint((DebugLevelTrace,"PinCreateHandler:error referencing PinToHandle\n"));
	  	}
		else
		{

		// NextFileObject must be per instance
		//AdditionalInfo[ StreamObject->PinId ].NextFileObject = NextFileObject;
		StreamObject->NextFileObject = 	NextFileObject;	
	    	//
		    // Add the pin's target to the list of targets for 
    		// recalculating stack depth.
		    //
    		KsSetTargetDeviceObject(
	    	    StreamObject->ComObj.DeviceHeader,
    	    	IoGetRelatedDeviceObject( 
	            NextFileObject ) );
        }

    }

    DebugPrint((DebugLevelTrace,"PinCreateHandler returning %x\n", Status ));
    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\ddvptype.h ===
// this file includes all the data structures and guids, the minidriver
// needs, which are part of directdraw.

typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;                               // size of the DDVIDEOPORTCONNECT structure
    GUID  guidTypeID;                   // Description of video port connection
    DWORD dwPortWidth;                  // Width of the video port
    DWORD dwFlags;                              // Connection flags
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
	DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
	DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
	DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
	DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
	DWORD   dwRBitMask;             // mask for red bit
	DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
	DWORD   dwGBitMask;             // mask for green bits
	DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {                                                           
	DWORD   dwBBitMask;             // mask for blue bits
	DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
	DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
	DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
	DWORD   dwRGBZBitMask;          // mask for Z channel
	DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#define DDVPTYPE_E_HREFH_VREFH  \
	0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
	0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\dxapi\vxd.asm ===
page	,132
	title	vxd.asm - vxd interface for dx mapper
	name	vxd.asm
;
;*****************************************************************************
;									     *
; Copyright (c) Microsoft Corporation 1990, 1991			     *
;									     *
; All Rights Reserved							     *
;									     *
;*****************************************************************************
;
; this module contains the NTMap port driver initialization code
;
;
.386

.xlist
	include	vmm.inc
        include dsdriver.inc
	include	debug.inc
.list

VxD_LOCKED_DATA_SEG

VxD_LOCKED_DATA_ENDS

VxD_LOCKED_CODE_SEG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       DXCheckDSoundVersion - check DSOUND version
;
;       Input - none
;
;       Output - eax contains version, 0 if not
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc	DXCheckDSoundVersion, scall, public

        EnterProc
        VxDCall _DSOUND_GetVersion
        jnc      DXCVReturn

        xor     eax, eax

DXCVReturn:

        LeaveProc
        Return
EndProc DXCheckDSoundVersion


public _DXIssueIoctl@20

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       DXIssueIoctl - issue IOCtl to DSOUND
;
;       Input - esp => DIOC
;
;       Output - none
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BeginProc	DXIssueIoctl, scall, public
ArgVar dwFunctionNum, DWORD
ArgVar lpvInBuffer, DWORD
ArgVar cbInBuffer, DWORD
ArgVar lpvOutBuffer, DWORD
ArgVar cbOutBuffer, DWORD

        EnterProc

	push	cbOutBuffer
	push	lpvOutBuffer
	push	cbInBuffer
	push	lpvInBuffer
	push	dwFunctionNum
        VxDCall _DSOUND_DD_IOCTL
	pop	ebx
	pop	ebx
	pop	ebx
	pop	ebx
	pop	ebx

        LeaveProc
        return
EndProc DXIssueIoctl



VxD_LOCKED_CODE_ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\dxapi\dxmapper.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxmapper.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXMAP class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

#define DEBUG_BREAKPOINT() DbgBreakPoint()
#define DXVERSION 4

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);


ULONG
DXCheckDSoundVersion(
);


ULONG
DXIssueIoctl(IN ULONG	dwFunctionNum,
             IN PVOID	lpvInBuffer,
             IN ULONG	cbInBuffer,
             IN PVOID	lpvOutBuffer,
             IN ULONG	cbOutBuffer
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\dxapi\wdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   wdm.c

Abstract:

   This is the WDM DX mapper driver.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "wdm.h"
#include "basedef.h"
#include "vmm.h"
#include "dxapi.h"
#include "dxmapper.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#endif

BOOLEAN DsoundOk = FALSE;

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Entry point for explicitely loaded stream class.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

   STATUS_SUCCESS

--*/
{

    UNREFERENCED_PARAMETER(DriverObject);
    DEBUG_BREAKPOINT();
    return STATUS_SUCCESS;
}


ULONG
DxApiGetVersion(
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    return (DXCheckDSoundVersion());
}


ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    DEBUG_BREAKPOINT();

    //
    // if we haven't checked if DSOUND is present and the right version,
    // (or if we've checked before and failed) check and return error if not
    // loaded or correct version.
    //

    if (!DsoundOk) {

    DEBUG_BREAKPOINT();
        if (DXCheckDSoundVersion() < DXVERSION) {

    DEBUG_BREAKPOINT();
             return 0;

        } else {

             DsoundOk = TRUE;
        }
    }

    return DXIssueIoctl( dwFunctionNum, lpvInBuffer, cbInBuffer, 
    	lpvOutBuffer, cbOutBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\dxapi\dsdriver.inc ===
;
;DSVXD.INC
;
;Include file for HAL and HEL VXD layers
;

                ;
                ;Return byte count to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTCNT          MACRO RetCnt
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpcbBytesReturned
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetCnt
exit:           pop esi

                ENDM

                ;
                ;Return 4-byte DWORD to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTDWORD        MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvOutBuffer
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetVal
                OUTCNT 4
exit:           pop esi

                ENDM

                ;
                ;Read 4-byte DWORD from caller
                ;
                ;Do not use ESI as parameter!
                ;

INDWORD         MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvInBuffer
                mov RetVal,-1
                or esi,esi
                jz exit
                mov RetVal,DWORD PTR [esi]
exit:           pop esi

                ENDM

                ;
                ;String copy/write macros
                ;

REP_MOVSB       MACRO

                push ecx
                and ecx,3
                rep movsb
                pop ecx
                shr ecx,2
                rep movsd

                ENDM

REP_STOSB       MACRO

                push ecx
                and ecx,3
                rep stosb
                pop ecx
                shr ecx,2
                rep stosd

                ENDM

                ;
                ;Scale definition
                ;
DS_SCALE_MAX	equ 65535
DS_SCALE_MID	equ 32768

                ;
                ;Error codes
                ;

HAL_OK              equ 0
HAL_ERROR           equ 1
HAL_CANT_OPEN_VXD   equ 2
HAL_ALLOC_FAILED    equ 3
HAL_NOT_ALLOCATED   equ 4
HAL_MUST_STOP_FIRST equ 5

HAL_SYSALLOCMEM	    equ 11

                ;
                ;Base mode flag equates
                ;        Note: This file is generated by modeflag.m4

                ;
                ;HALHWMODE afAbilityFlags values
                ;
                ;These flags describe dynamic capabilities (what the device
                ;can/cannot do)
                ;

A_CAN_CHANGE_VOLUME         equ 00000001b  ;Can change volume while playing
A_CANNOT_CHANGE_VOLUME      equ 00000000b  ;Cannot change volume while playing

A_CAN_CHANGE_MODE           equ 00000010b  ;Can change PCM mode while playing
A_CANNOT_CHANGE_MODE        equ 00000000b  ;Cannot change PCM mode while playing

A_CAN_CHANGE_RATE           equ 00000100b  ;Can change rate while playing
A_CANNOT_CHANGE_RATE        equ 00000000b  ;Cannot change rate while playing

A_CAN_LOOP_SECONDARY        equ 00001000b  ;Can loop secondary buffers before starting
A_CANNOT_LOOP_SECONDARY     equ 00000000b  ;Cannot loop secondary buffers before starting

A_CAN_UNLOOP_SECONDARY      equ 00010000b  ;Secondary bufers do not have to loop
A_CANNOT_UNLOOP_SECONDARY   equ 00000000b  ;Secondary buffers must always loop

A_CAN_CHANGE_LOOP_STATUS    equ 00100000b  ;Can turn looping on/off during playback
A_CANNOT_CHANGE_LOOP_STATUS equ 00000000b  ;Cannot turn looping on/off during playback

                ;
                ;HALSTRBUF.dwFlags values
                ;

HSB_DMA_ALLOC   equ 1h		;Buffer was allocated from DMA services
HSB_RAM_ALLOC   equ 2h		;Buffer was allocated from sound card RAM

                ;
                ;
                ;Passed to HAL_ChangeStreamFormat() to inhibit parameter
                ;change
                ;

HF_NO_CHANGE    equ -1


                ;
                ;DSound Caps
                ;


DSC_LOCK_SYSMEM		equ 65535
DSC_LOCK_SLOW		equ 64
DSC_PLAY_DMA		equ 20
DSC_PLAY_ONBOARD	equ 0


DSC_CAPSF_MONO		equ 1
DSC_CAPSF_STEREO	equ 2
DSC_CAPSF_8BIT		equ 4
DSC_CAPSF_16BIT		equ 8


                ;
                ;Stream buffer descriptor
                ;
HALSTRBUF STRUCT
 hfFormat       DWORD ?
 dwSampleRate   DWORD ?
 dwUserSampleRate DWORD ?
 dwVolume       DWORD ?
 dwPan	        DWORD ?
 dwLVolume      DWORD ?
 dwRVolume      DWORD ?
 dwMVolume      DWORD ?
HALSTRBUF ENDS

                ;
                ;Mix session descriptor
                ;

MIXSESSION STRUCT
 lpBuildBuffer  DWORD ?
 dwBuildSize    DWORD ?
 HALOutStrBuf   HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 nOutputBytes   DWORD ?
MIXSESSION ENDS

                ;
                ;Mixer input descriptor
                ;

MIXERINPUT STRUCT
 HALInStrBuf    HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 lpdwInputPos   DWORD ?
 dwInputBytes   DWORD ?
 dwOutputOffset DWORD ?
MIXERINPUT ENDS


; VxD ID registered to DSHEL.VXD
DSOUND_Device_ID		EQU	357Eh

ifdef DDB_Sys_Crit_Init_Done

; DSound Driver  VxDs use this service to

Begin_Service_Table	DSOUND
        DSOUND_Service  _DSOUND_GetVersion, LOCAL
        DSOUND_Service  _DSOUND_RegisterDeviceDriver, VxD_CODE
	DSOUND_Service  _DSOUND_DeregisterDeviceDriver, VxD_CODE
				DSOUND_Service  _DSOUND_DD_IOCTL, VxD_CODE
End_Service_Table DSOUND


ENDIF   ; DDB_Sys_Crit_Init_Done (VxD's only)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\mpeg2typ.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

/*  Define video type for MPEG-2 */
#ifndef __MPEG2TYP__
#define __MPEG2TYP__

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*  MPEG-2 stuff */

#define MPEG2VIDEOINFO_PROFILE_SIMPLE             5
#define MPEG2VIDEOINFO_PROFILE_MAIN               4
#define MPEG2VIDEOINFO_PROFILE_SNR_SCALABLE       3
#define MPEG2VIDEOINFO_PROFILE_SPATIALLY_SCALABLE 2
#define MPEG2VIDEOINFO_PROFILE_HIGH               1

#define MPEG2VIDEINFO_LEVEL_LOW                   10
#define MPEG2VIDEINFO_LEVEL_MAIN                  8
#define MPEG2VIDEINFO_LEVEL_HIGH_1440             6
#define MPEG2VIDEINFO_LEVEL_HIGH                  4

typedef struct tagMPEG2VIDEOINFO
{
    /* -- Matches VIDEOINFOHEADER -- */

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    /* ----------------------------- */


    DWORD           dwProfile;              // Which profile
    DWORD           dwLevel;                // What level
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
                                            // and extension

} MPEG2VIDEOINFO;



/*  AC3 audio

    wFormatTag          WAVE_FORMAT_DOLBY_AC3
    nChannels           1 -6 channels valid
    nSamplesPerSec      48000, 44100, 32000
    nAvgByesPerSec      4000 to 80000
    nBlockAlign         128 - 3840
    wBitsPerSample      Up to 24 bits - (in the original)

*/

#define WAVE_FORMAT_DOLBY_AC3 0x2000

typedef struct tagDOLBYAC3WAVEFORMAT
{
    WAVEFORMATEX     wfx;
    BYTE             bBigEndian;       /* TRUE = Big Endian, FALSE little endian */
    BYTE             bsid;
    BYTE             lfeon;
    BYTE             copyrightb;
    BYTE             nAuxBitsCode;  /*  Aux bits per frame */
} DOLBYAC3WAVEFORMAT;


#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\mpegguid.h ===
#define STATIC_KSPROPSETID_Mpeg2Vid\
   0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDEX( KSPROPSETID_Mpeg2Vid );
   

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\mpegprop.h ===
typedef struct _BUF_LVL_DATA
{
	LONGLONG	BufferCapacity;		// size of overall data buffer in bytes
	LONGLONG	CurBufferLevel;		// current byte count in buffer
} BUF_LVL_DATA, *PBUF_LVL_DATA;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\mpeg2ids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//
//  MPEG2IDS.H
//

//  GUIDs for use with MPEG-2, AC3, DVD and related projects
//  To reserve a GUID just annotate its usage to the right of its value

//  Major types and subtypes for media types

DEFINE_GUID(MEDIATYPE_MPEG2_PES,
    0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIATYPE_CONTROL,
    0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIASUBTYPE_MPEG2_PROGRAM, 0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIASUBTYPE_MPEG2_TRANSPORT,
    0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIASUBTYPE_DVD                           ,
    0xe06d8024, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#if 0 // UNUSED
DEFINE_GUID(, 0xe06d8025, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // UNUSED
DEFINE_GUID(MEDIASUBTYPE_MPEG2_VIDEO,
    0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#if 0 // UNUSED
DEFINE_GUID(, 0xe06d8027, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8028, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8029, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d802a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // UNUSED
DEFINE_GUID(MEDIASUBTYPE_MPEG2_AUDIO,
    0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIASUBTYPE_DOLBY_AC3,
    0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(MEDIASUBTYPE_SUBPICTURE ,
    0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);

#if 0
DEFINE_GUID(, 0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8033, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8034, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8035, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8036, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8037, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8038, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8039, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d803f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8040, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8041, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8042, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8043, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8044, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8045, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8046, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8047, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8048, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8049, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d804f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8050, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8051, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8052, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8053, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8054, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8055, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8056, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8057, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8058, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8059, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d805f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8060, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8061, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8062, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8063, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8064, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8065, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8066, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8067, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8068, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8069, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d806f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8070, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8071, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8072, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8073, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8074, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8075, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8076, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8077, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8078, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8079, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d807f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8080, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8081, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8082, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8083, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8084, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8085, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8086, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8087, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8088, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8089, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d808f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8090, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8091, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8092, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8093, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8094, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8095, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8096, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8097, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8098, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8099, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d809f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80a9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80aa, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ab, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ac, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ad, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ae, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80af, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80b9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ba, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80bb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80bc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80bd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80be, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80bf, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80c9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ca, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80cb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80cc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80cd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ce, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80cf, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80d9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80da, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80db, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80dc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80dd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80de, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80df, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);

//
//  Format blocks
//


#endif // UNUSED
DEFINE_GUID(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);

#if 0 // UNUSED
DEFINE_GUID(, 0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80e9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ea, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80eb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ec, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ed, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ee, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ef, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80f9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80fa, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80fb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80fc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80fd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80fe, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d80ff, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8100, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8101, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8102, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8103, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8104, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8105, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8106, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8107, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8108, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8109, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d810f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8110, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8111, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8112, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8113, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8114, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8115, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8116, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8117, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8118, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8119, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d811f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8120, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8121, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8122, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8123, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8124, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8125, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8126, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8127, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8128, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8129, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d812f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8130, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8131, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8132, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8133, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8134, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8135, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8136, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8137, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8138, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8139, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d813f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8140, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8141, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8142, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8143, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8144, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8145, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8146, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8147, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8148, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8149, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d814f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8150, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8151, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8152, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8153, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8154, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8155, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8156, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8157, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8158, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8159, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d815f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8160, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8161, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8162, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8163, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8164, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8165, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8166, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8167, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8168, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8169, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d816f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8170, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8171, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8172, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8173, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8174, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8175, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8176, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8177, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8178, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8179, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d817f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8180, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8181, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8182, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8183, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8184, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8185, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8186, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8187, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8188, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8189, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d818f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8190, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8191, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8192, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8193, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8194, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8195, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8196, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8197, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8198, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8199, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d819f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81a9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81aa, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ab, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ac, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ad, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ae, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81af, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81b9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ba, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81bb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81bc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81bd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81be, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81bf, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81c9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ca, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81cb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81cc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81cd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ce, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81cf, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81d9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81da, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81db, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81dc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81dd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81de, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81df, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81e9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ea, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81eb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ec, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ed, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ee, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ef, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f0, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f1, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f2, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f7, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f8, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81f9, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81fa, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81fb, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81fc, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81fd, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81fe, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d81ff, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8200, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8201, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8202, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8203, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8204, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8205, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8206, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8207, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8208, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8209, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d820f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8210, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8211, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8212, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8213, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8214, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8215, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8216, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8217, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8218, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d8219, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821a, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
DEFINE_GUID(, 0xe06d821f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\uuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types
// for standard media types, and also class ids for well-known components.


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- sub types ---


// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// --- class IDs ---


// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85		  .MOV reader
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D3588AB0-0781-11ce-B03A-0020AF0BA770     	  AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// D3588AB1-0781-11ce-B03A-0020AF0BA770	          AVIFile-based writer
OUR_GUID_ENTRY(CLSID_AVIDocWriter,
0xd3588ab1, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a		  Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}	  AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {5f2759c0-7685-11cf-8b23-00805f6cef60}    IAMovie plug-in distributor
OUR_GUID_ENTRY(CLSID_AMovie,
0x5f2759c0, 0x7685, 0x11cf, 0x8b, 0x23, 0x00, 0x80, 0x5f, 0x6c, 0xef, 0x60)


// -- format types ---


// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

OUR_GUID_ENTRY(IID_IDirectDraw,         0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,  0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,  0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,  0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\debug.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    debug routines for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
#if DBG
void DebugDumpWriteData( PHW_STREAM_REQUEST_BLOCK pSrb );
void DebugDumpPackHeader( PHW_STREAM_REQUEST_BLOCK pSrb );
void DebugDumpKSTIME( PHW_STREAM_REQUEST_BLOCK pSrb );
char * DebugLLConvtoStr( ULONGLONG val, int base );
#endif
DWORD GgetSCR( void *pBuf );

#define TRAP DEBUG_BREAKPOINT();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\debug.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    debug routines for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/

#include "strmini.h"
#include "ks.h"
#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "que.h"
#include "DvdTDCod.h" // header for DvdTDCod.lib routines hiding proprietary HW stuff



typedef struct tagPack {
	DWORD	pack_start_code;
	BYTE	scr_byte[6];
	DWORD	program_mux_rate;	
} PACK, *PPACK;

#if DBG

void DebugDumpWriteData( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	ULONG	i;
	unsigned char	*p;
	PKSSTREAM_HEADER pStruc;
//	PHYSICAL_ADDRESS	phyadd;
	static DWORD	scr;

	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelVerbose, "DVDTS:  SRB pointer 0x%x\r\n", pSrb ) );

	DebugPrint( (DebugLevelVerbose, "DVDTS:  NumberOfPhysicalPages %d\r\n", pSrb->NumberOfPhysicalPages ) );
	for( i = 0; i < pSrb->NumberOfPhysicalPages; i++ ) {
		DebugPrint( (DebugLevelVerbose, "DVDTS:  PhysicalAddress[%d] 0x%x\r\n", i, pSrb->ScatterGatherBuffer[i].PhysicalAddress ) );
		DebugPrint( (DebugLevelVerbose, "DVDTS:  Length[%d] %d(0x%x)\r\n", i, pSrb->ScatterGatherBuffer[i].Length, pSrb->ScatterGatherBuffer[i].Length ) );
	}

	DebugPrint( (DebugLevelVerbose, "DVDTS:NumberOfBuffers %d\r\n", pSrb->NumberOfBuffers ) );
	DebugPrint( (DebugLevelVerbose, "DVDTS:NumberOfBytesToTransfer %d\r\n", pSrb->NumberOfBytesToTransfer ) );

	for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
		DebugPrint( (DebugLevelVerbose, "DVDTS:DataBufferArray[%d] 0x%x\r\n", i, &(pSrb->CommandData.DataBufferArray[i]) ) );

		pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

		DebugPrint( (DebugLevelVerbose, "DVDTS:  Time 0x%x 0x%x\r\n", (DWORD)( ((ULONGLONG)pStruc->PresentationTime.Time) >> 32 ), (DWORD)( pStruc->PresentationTime.Time ) ) );
		DebugPrint( (DebugLevelVerbose, "DVDTS:  Numerator 0x%x\r\n", pStruc->PresentationTime.Numerator ) );
		DebugPrint( (DebugLevelVerbose, "DVDTS:  Denominator 0x%x\r\n", pStruc->PresentationTime.Denominator ) );
		if( pStruc->PresentationTime.Denominator != 0 ) {
			DebugPrint( (DebugLevelVerbose, "DVDTS:    ? Time ? %d\r\n",
				(DWORD)( pStruc->PresentationTime.Time * pStruc->PresentationTime.Numerator / pStruc->PresentationTime.Denominator )
				) );
		}
		DebugPrint( (DebugLevelVerbose, "DVDTS:  Duration 0x%x 0x%x\r\n", (DWORD)( ((ULONGLONG)pStruc->Duration) >> 32), (DWORD)(pStruc->Duration) ) );
		DebugPrint( (DebugLevelVerbose, "DVDTS:  DataUsed %d\r\n", pStruc->DataUsed ) );

		DebugPrint( (DebugLevelVerbose, "DVDTS:  Data 0x%x\r\n", pStruc->Data ) );
		p = (PUCHAR)pStruc->Data;
        p += 14;

		DebugPrint( (DebugLevelVerbose, "DVDTS:    %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
			*(p+0), *(p+1), *(p+2), *(p+3),
			*(p+4), *(p+5), *(p+6), *(p+7)
				) );
		if( p != NULL ) {
			scr = GgetSCR( p - 14 );
			DebugPrint( (DebugLevelVerbose, "DVDTS:  SCR 0x%x( %d )\r\n", scr, scr ) );
		}

//		if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) {
//			TRAP;
//		}
//		if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) {
//			TRAP;
//		}
//		if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE ) {
//			TRAP;
//		}

	}

//	if( pSrb->NumberOfBuffers > 1 )
//		TRAP;

}

//void DebugDumpPackHeader( PHW_STREAM_REQUEST_BLOCK pSrb )
//{
//	ULONG	i, j;
//	unsigned char	*p;
//	PKSSTREAM_HEADER pStruc;
//	DWORD	scr;
//	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
//	static int count = 0;
//
//	for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
//		pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];
//		p = pStruc->Data;
//		if( p != NULL ) {
//			scr = GgetSCR( p);
//
//			if( scr < 0x100 ) {
//				for( j = 0; j < 32; j++ )
//					pHwDevExt->dmp[count++] = 0xaa;
//			}
//			if( count >= 32*10000 )
//				TRAP;
//
//			for( j = 0; j < 32; j++ )
//				pHwDevExt->dmp[count++] = *(p+j);
//			if( count >= 32*10000 )
//				TRAP;
//			pHwDevExt->dmp[count] = 0xff;
//			pHwDevExt->dmp[count+1] = 0xff;
//			pHwDevExt->dmp[count+2] = 0xff;
//			pHwDevExt->dmp[count+3] = 0xff;
//		}
//	}
//}


//void DebugDumpKSTIME( PHW_STREAM_REQUEST_BLOCK pSrb )
//{
//	int j;
//	PKSSTREAM_HEADER pStruc;
//	PUCHAR p;
//	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
//	static int count = 0;
//
//	pStruc = (PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray;
//
//	if( pStruc->OptionsFlags == 0 ) {
//		p = (PUCHAR)&pStruc[0];
//
//		for( j = 0; j < 16; j++ )
//			pHwDevExt->dmp2[count++] = *(p+j);
//		if( count >= 16*10000 ) {
//			TRAP;
//			count = 0;
//		}
//	}
//}

char * DebugLLConvtoStr( ULONGLONG val, int base )
{
	static char str[5][100];
	static int cstr = -1;

	int count = 0;
	int digit;
	char tmp[100];
	int i;

	if( ++cstr >= 5 )
		cstr = 0;

	if( base == 10 ) {
		for( ; ; ) {
			digit = (int)( val % 10 );
			tmp[count++] = (char)( digit + '0' );
			val /= 10;
			if( val == 0 )
				break;
		}
	}
	else if( base == 16 ) {
		for( ; ; ) {
			digit = (int)( val & 0xF );
			if( digit < 10 )
				tmp[count++] = (char)( digit + '0' );
			else
				tmp[count++] = (char)( digit - 10 + 'a' );
			val >>= 4;
			if( val == 0 )
				break;
		}
	}
	else
		TRAP;

	for( i = 0; i < count; i++ ) {
		str[cstr][i] = tmp[count-i-1];
	}
	str[cstr][i] = '\0';

	return str[cstr];
}

#endif


DWORD GgetSCR( void *pBuf )
{
	PPACK	pPack = (PPACK)pBuf;
	DWORD	scr;

	if( ( (DWORD)pPack->scr_byte[0] & 0xc0L ) == 0 ) {	// MPEG1
		scr  = ( (DWORD)pPack->scr_byte[0] & 0x6L ) << 29;
		scr |= ( (DWORD)pPack->scr_byte[1] ) << 22;
		scr |= ( (DWORD)pPack->scr_byte[2] & 0xfeL ) << 14;
		scr |= ( (DWORD)pPack->scr_byte[3] ) << 7;
		scr |= ( (DWORD)pPack->scr_byte[4] & 0xfeL ) >> 1;
	}
	else {	// MPEG2 or DVD
		scr  = ( (DWORD)pPack->scr_byte[0] & 0x18L ) << 27;
		scr |= ( (DWORD)pPack->scr_byte[0] & 0x3L ) << 28;
		scr |= ( (DWORD)pPack->scr_byte[1] ) << 20;
		scr |= ( (DWORD)pPack->scr_byte[2] & 0xf8L ) << 12;
		scr |= ( (DWORD)pPack->scr_byte[2] & 0x3L ) << 13;
		scr |= ( (DWORD)pPack->scr_byte[3] ) << 5;
		scr |= ( (DWORD)pPack->scr_byte[4] & 0xf8L ) >> 3;
	}

	return scr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\inc\vptype.h ===
// this file includes all the data structures defined for the IVPConfig
// interface.

// AMVIDEOSIGNALINFO
typedef struct _AMVIDEOSIGNALINFO
{
    DWORD dwSize;						// [in] Size of the structure
	DDPIXELFORMAT ddPixelFormat;			// [in] All the rest of the parameters are valid for this pixel format
	DWORD dwFieldWidth;					// [out] field width
    DWORD dwFieldHeight;				// [out] field height
	DWORD dwVBIHeight;					// [out] height of the VBI data
	DWORD dwMicrosecondsPerField;		// [out] time taken by each field
    DWORD dwVREFHeight;					// [out] Specifies the number of lines of data in the vref
	BOOL  bDoubleClock;					// [out] videoport should enable double clocking
	BOOL  bVACT;						// [out] videoport should use an external VACT signal
	BOOL  bInterlaced;					// [out] Indicates that the signal is interlaced
	BOOL  bHalfline;					// [out] Device will write half lines into the frame buffer
	BOOL  bInvertedPolarity;			// [out] Device inverts the polarity by default
	BOOL  bGetBestBandwidth;
} AMVIDEOSIGNALINFO, *LPAMVIDEOSIGNALINFO; 

// AMPIXELRATEINFO
typedef struct _AMPIXELRATEINFO
{

	DDPIXELFORMAT ddPixelFormat;		// [in] the pixel format
    DWORD dwWidth;						// [in|out] the width of the field.
	DWORD dwHeight;						// [in|out] the height of the field
	DWORD dwMaxPixelsPerSecond;			// [out] the maximum pixel rate expected
} AMPIXELRATEINFO, *LPAMPIXELRATEINFO;

// AMSCALINGINFO
typedef struct _AMSCALINGINFO
{
	DWORD dwWidth;						// [in|out] the new width requested/granted
	DWORD dwHeight;						// [in|out] the new height requested/granted
} AMSCALINGINFO, *LPAMSCALINGINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\devque.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    devque.c 

Abstract:

    device que routines for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
#include "strmini.h"
#include "ks.h"
#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "que.h"
#include "DvdTDCod.h" // header for DvdTDCod.lib routines hiding proprietary HW stuff


void DeviceQueue_init( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->DevQue.count = 0;
	pHwDevExt->DevQue.top = pHwDevExt->DevQue.bottom = NULL;
}

void DeviceQueue_put( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pOrigin, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	pSrb->NextSRB = NULL;
	if ( pHwDevExt->DevQue.top == NULL ) {
		pHwDevExt->DevQue.top = pHwDevExt->DevQue.bottom = pSrb;
		pHwDevExt->DevQue.count++;
		return;
	}

	pHwDevExt->DevQue.bottom->NextSRB = pSrb;
	pHwDevExt->DevQue.bottom = pSrb;
	pHwDevExt->DevQue.count++;

	return;
}



void DeviceQueue_put_video( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	SRBIndex( pSrb ) = 0;
	SRBpfnEndSrb( pSrb ) = NULL;
	SRBparamSrb( pSrb ) = NULL;

	DeviceQueue_put( pHwDevExt, pHwDevExt->DevQue.top, pSrb );
}

void DeviceQueue_put_audio( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	SRBIndex( pSrb ) = 0;
	SRBpfnEndSrb( pSrb ) = NULL;
	SRBparamSrb( pSrb ) = NULL;

	DeviceQueue_put( pHwDevExt, pHwDevExt->DevQue.top, pSrb );
}

void DeviceQueue_put_subpic( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	SRBIndex( pSrb ) = 0;
	SRBpfnEndSrb( pSrb ) = NULL;
	SRBparamSrb( pSrb ) = NULL;

	DeviceQueue_put( pHwDevExt, pHwDevExt->DevQue.top, pSrb );
}

PHW_STREAM_REQUEST_BLOCK DeviceQueue_get( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last )
{
	PHW_STREAM_REQUEST_BLOCK srb;

	if ( pHwDevExt->DevQue.top == NULL )
		return NULL;

	srb = pHwDevExt->DevQue.top;
	(*index) = SRBIndex( srb );

// debug
	if( srb->NumberOfPhysicalPages == 0 )
		TRAP;

	if ( SRBIndex( srb ) != ( srb->NumberOfPhysicalPages - 1 ) ) {
		(*last) = FALSE;
		SRBIndex( srb )++;
		return srb;
	}

	(*last) = TRUE;

	pHwDevExt->DevQue.top = pHwDevExt->DevQue.top->NextSRB;

	pHwDevExt->DevQue.count--;
	if ( pHwDevExt->DevQue.count == 0 )
		pHwDevExt->DevQue.top = pHwDevExt->DevQue.bottom = NULL;

	return srb;
}

PHW_STREAM_REQUEST_BLOCK DeviceQueue_refer1st( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last )
{
	PHW_STREAM_REQUEST_BLOCK srb;

	if( pHwDevExt->DevQue.top == NULL )
		return NULL;

	srb = pHwDevExt->DevQue.top;
	(*index) = SRBIndex( srb );

	if ( SRBIndex( srb ) != ( srb->NumberOfPhysicalPages - 1 ) ) {
		(*last) = FALSE;
	}
	else {
		(*last) = TRUE;
	}

	return srb;
}

PHW_STREAM_REQUEST_BLOCK DeviceQueue_refer2nd( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last )
{
	PHW_STREAM_REQUEST_BLOCK srb;

	if( pHwDevExt->DevQue.top == NULL )
		return NULL;

	srb = pHwDevExt->DevQue.top;
	if( SRBIndex( srb ) != ( srb->NumberOfPhysicalPages - 1) ) {
		(*index) = SRBIndex( srb ) + 1;
		if( (SRBIndex( srb ) + 1) != ( srb->NumberOfPhysicalPages - 1 ) ) {
			(*last) = FALSE;
		}
		else {
			(*last) = TRUE;
		}
	}
	else {
		srb = srb->NextSRB;
		if( srb == NULL )
			return NULL;
		(*index) = SRBIndex( srb );
		if( SRBIndex( srb ) != ( srb->NumberOfPhysicalPages - 1 ) ) {
			(*last) = FALSE;
		}
		else {
			(*last) = TRUE;
		}
	}
	return srb;
}

void DeviceQueue_remove( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_STREAM_REQUEST_BLOCK srbPrev;
	PHW_STREAM_REQUEST_BLOCK srb;

	if ( pHwDevExt->DevQue.top == NULL )
		return;

	if( pHwDevExt->DevQue.top == pSrb ) {
		pHwDevExt->DevQue.top = pHwDevExt->DevQue.top->NextSRB;
		pHwDevExt->DevQue.count--;
		if ( pHwDevExt->DevQue.count == 0 )
			pHwDevExt->DevQue.top = pHwDevExt->DevQue.bottom = NULL;

		DebugPrint(( DebugLevelTrace, "DVDTS:DeviceQueue_remove srb = 0x%x\r\n", pSrb ));

		return;
	}


	srbPrev = pHwDevExt->DevQue.top;
	srb = srbPrev->NextSRB;

	while ( srb != NULL ) {
		if( srb == pSrb ) {
			srbPrev->NextSRB = srb->NextSRB;
			if( srbPrev->NextSRB == pHwDevExt->DevQue.bottom )
				pHwDevExt->DevQue.bottom = srbPrev;
			pHwDevExt->DevQue.count--;

			DebugPrint(( DebugLevelTrace, "DVDTS:DeviceQueue_remove srb = 0x%x\r\n", pSrb ));

			break;
		}
		srbPrev = srb;
		srb = srbPrev->NextSRB;
	}
}

BOOL DeviceQueue_setEndAddress( PHW_DEVICE_EXTENSION pHwDevExt, PHW_TIMER_ROUTINE pfn, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_STREAM_REQUEST_BLOCK srb;

	srb = pHwDevExt->DevQue.top;
	while( srb != NULL ) {
		if( srb->NextSRB == NULL ) {
			SRBpfnEndSrb( srb ) = pfn;
			SRBparamSrb( srb ) = pSrb;

			DebugPrint(( DebugLevelTrace, "DVDTS:setEndAddress srb = 0x%x\r\n", srb ));

			return TRUE;
		}
		srb = srb->NextSRB;
	}
	return FALSE;
}

BOOL DeviceQueue_isEmpty( PHW_DEVICE_EXTENSION pHwDevExt )
{
	if( pHwDevExt->DevQue.top==NULL )
		return TRUE;
	else
		return FALSE;
}

ULONG DeviceQueue_getCount( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return( pHwDevExt->DevQue.count );
}
//--- End.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdcmd.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dvdcmd.h 

Abstract:

    main command processing routines for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
VOID STREAMAPI AdapterCancelPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AdapterTimeoutPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AdapterStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID HwProcessDataIntersection( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AdapterOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AdapterCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb );

void ClockEvents( PHW_DEVICE_EXTENSION pHwDevExt );
NTSTATUS STREAMAPI AudioEvent( PHW_EVENT_DESCRIPTOR pEvent );
NTSTATUS STREAMAPI CycEvent( PHW_EVENT_DESCRIPTOR pEvent );

VOID STREAMAPI VideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI VideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AudioReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AudioReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI SubpicReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI SubpicReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI NtscReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI NtscReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI VpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI VpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI CCReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI CCReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );

void VideoDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );
void AudioDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );
void SubpicDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );
void VideoTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );
void AudioTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );
void SubpicTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt );

void VideoQueryAccept(PHW_STREAM_REQUEST_BLOCK pSrb);
void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
void BadWait( DWORD dwTime );
void FastSlowControl( PHW_STREAM_REQUEST_BLOCK pSrb );
DWORD xunGetPTS(void *pBuf);
DWORD	GetStreamID(void *pBuf);
ULONG GetHowLongWait( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc );
void ScheduledDMAxfer( PHW_DEVICE_EXTENSION pHwDevExt );
void PreDMAxfer( PHW_DEVICE_EXTENSION pHwDevExt );
void DMAxfer( PHW_DEVICE_EXTENSION pHwDevExt );
void DMAxferKeyData( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb, PUCHAR addr, DWORD dwSize, PHW_TIMER_ROUTINE pfnCallBack );
void EndKeyData( PHW_DEVICE_EXTENSION pHwDevExt );
void MenuDecodeStart( PHW_DEVICE_EXTENSION pHwDevExt );
void DecodeStart( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC );
void TimerDecodeStart( PHW_DEVICE_EXTENSION pHwDevExt );
VOID TimerAudioMuteOff( PHW_DEVICE_EXTENSION pHwDevExt );

void GetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetNtscProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetNtscProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void GetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb, LONG strm );
void SetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );

VOID STREAMAPI StreamClockRtn( IN PHW_TIME_CONTEXT TimeContext );
ULONGLONG GetSystemTime();
ULONGLONG ConvertPTStoStrm(ULONG pts);
ULONG ConvertStrmtoPTS(ULONGLONG strm);
void TimerCppReset( PHW_STREAM_REQUEST_BLOCK pSrb );

void SetPlayMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode );

void StopData( PHW_DEVICE_EXTENSION pHwDevExt );
void CheckAudioUnderflow( PHW_DEVICE_EXTENSION pHwDevExt );
void UnderflowStopData( PHW_DEVICE_EXTENSION pHwDevExt );
void ForcedStopData( PHW_DEVICE_EXTENSION pHwDevExt, ULONG flag );
void StopDequeue( PHW_DEVICE_EXTENSION pHwDevExt );

void SetAudioID( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc );
void SetSubpicID( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc );

void SetCppFlag( PHW_DEVICE_EXTENSION pHwDevExt );

void AudioQueryAccept( PHW_STREAM_REQUEST_BLOCK pSrb );
void ProcessAudioFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
void ProcessAudioFormat2( PMYAUDIOFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );

void SetVideoRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
void SetAudioRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
void SetSubpicRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
void SetRateChange( PHW_DEVICE_EXTENSION pHwDevExt, LONG strm );
void SetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
void SetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
void SetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
void GetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
void GetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
void GetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );


#define	VIDEO_DISCONT_FLAG	0x01
#define	AUDIO_DISCONT_FLAG	0x02
#define	SUBPIC_DISCONT_FLAG	0x03

#define IsEqualGUID2(guid1, guid2) \
	(!memcmp((guid1), (guid2), sizeof(GUID)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdcmd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dvdcmd.c 

Abstract:

    main command processing module for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/

#include "strmini.h"
#include "ks.h"
#include <mmsystem.h>

#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "que.h"
#include "DvdTDCod.h" // header for DvdTDCod.lib routines hiding proprietary HW stuff

#include "dvdcmd.h"

#include "strmid.h"

//#include "ddkmapi.h"


HANDLE	hClk;
HANDLE	hMaster;

BOOL fClkPause;
ULONGLONG LastSysTime = 0;
ULONGLONG PauseTime = 0;

static ULONGLONG LastStamp;
static ULONGLONG LastSys;
static BOOLEAN fValid;
extern BOOLEAN fProgrammed;
extern BOOLEAN fStarted;
BOOLEAN fProgrammed;
BOOLEAN fStarted;
static ULONGLONG StartSys;

KSPIN_MEDIUM VPMedium = {
	STATIC_KSMEDIUMSETID_VPBus,
	0,
	0
};


VOID STREAMAPI AdapterCancelPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
/*++

Routine Description:

    routine to cancel a packet that may be in progress

Arguments:

   pSrb - pointer to stream request block to be cancelled

Return Value:

    none

--*/
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "DVDTS:AdapterCancelPacket\r\n" ));
	DebugPrint(( DebugLevelVerbose, "DVDTS:  pSrb = 0x%x\r\n", pSrb ));

	if( pHwDevExt->pSrbDMA0 == pSrb ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  pSrb == pSrbDMA0\r\n" ) );
		pHwDevExt->pSrbDMA0 = NULL;
		pHwDevExt->fSrbDMA0last = FALSE;
	}
	if( pHwDevExt->pSrbDMA1 == pSrb ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  pSrb == pSrbDMA1\r\n" ) );
		pHwDevExt->pSrbDMA1 = NULL;
		pHwDevExt->fSrbDMA1last = FALSE;
	}

	pSrb->Status = STATUS_CANCELLED;

    // need to find this packet, pull it off our queues, and cancel it

	switch (pSrb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
								SRB_HW_FLAGS_STREAM_REQUEST)) {
		//
		// find all stream commands, and do stream notifications
		//

	  case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:

		DebugPrint(( DebugLevelVerbose, "DVDTS:    SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER\r\n", pSrb ));


		DeviceQueue_remove( pHwDevExt,pSrb );
		CCQueue_remove( pHwDevExt, pSrb );

		StreamClassStreamNotification( StreamRequestComplete,
										pSrb->StreamObject,
										pSrb);
		break;

	  case SRB_HW_FLAGS_STREAM_REQUEST:

		DebugPrint( (DebugLevelTrace, "DVDTS:    SRB_HW_FLAGS_STREAM_REQUEST\r\n", pSrb ) );

		StreamClassStreamNotification( ReadyForNextStreamControlRequest,
										pSrb->StreamObject);

		StreamClassStreamNotification( StreamRequestComplete,
										pSrb->StreamObject,
										pSrb);
		break;

	  default:

		DebugPrint( (DebugLevelTrace, "DVDTS:    default\r\n", pSrb ) );

		StreamClassDeviceNotification( ReadyForNextDeviceRequest,
										pSrb->HwDeviceExtension );
		StreamClassDeviceNotification( DeviceRequestComplete,
										pSrb->HwDeviceExtension,
										pSrb );
		break;
	}
}

/*
** AdapterTimeoutPacket()
*/
VOID STREAMAPI AdapterTimeoutPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:AdapterTimeoutPacket\r\n") );

	if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FREEZE ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  pause mode\r\n") );
		pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
		return;
	}

	TRAP;

//	pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

	if( pHwDevExt->pSrbDMA0 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  pSrbDMA0 exist\r\n" ));
		pHwDevExt->pSrbDMA0 = NULL;
		pHwDevExt->fSrbDMA0last = FALSE;
	}
	if( pHwDevExt->pSrbDMA1 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  pSrbDMA1 exist\r\n" ));
		pHwDevExt->pSrbDMA1 = NULL;
		pHwDevExt->fSrbDMA1last = FALSE;
	}

	if( pHwDevExt->pstroVid ) {
		StreamClassScheduleTimer(
			pHwDevExt->pstroVid,
			pHwDevExt,
			0,
			NULL,
			pHwDevExt->pstroVid
			);
	}
	if( pHwDevExt->pstroAud ) {
		StreamClassScheduleTimer(
			pHwDevExt->pstroAud,
			pHwDevExt,
			0,
			NULL,
			pHwDevExt->pstroAud
			);
	}
	if( pHwDevExt->pstroSP ) {
		StreamClassScheduleTimer(
			pHwDevExt->pstroSP,
			pHwDevExt,
			0,
			NULL,
			pHwDevExt->pstroSP
			);
	}

	// init the main and closed-caption SRB queues
	DeviceQueue_init(pHwDevExt);
	CCQueue_init(pHwDevExt);

	pHwDevExt->pSrbCpp = NULL;
	pHwDevExt->bDMAstop = FALSE;

	StreamClassAbortOutstandingRequests( pHwDevExt, NULL, STATUS_CANCELLED );

}


/*
** AdapterReceivePacket()
*/
VOID STREAMAPI AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
//	DWORD st, et;

	DebugPrint( (DebugLevelTrace, "DVDTS:AdapterReceivePacket\r\n") );

	switch( pSrb->Command ){
		case SRB_GET_STREAM_INFO:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_INFO\r\n") );
			AdapterStreamInfo( pSrb );
			break;

		case SRB_OPEN_STREAM:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_STREAM\r\n") );
			AdapterOpenStream( pSrb );
			break;

		case SRB_CLOSE_STREAM:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_STREAM\r\n") );
			AdapterCloseStream( pSrb );
			break;

		case SRB_INITIALIZE_DEVICE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_INITIALIZE_DEVICE\r\n") );

			//
			// schedule a low priority callback to get the config
			// space.  processing will continue when this runs.
			//

			StreamClassCallAtNewPriority(
				NULL,
				pSrb->HwDeviceExtension,
				Low,
				(PHW_PRIORITY_ROUTINE) GetPCIConfigSpace,
				pSrb
			);

			return;

//			st = GetCurrentTime_ms();
//
//			HwInitialize( pSrb );
//
//			et = GetCurrentTime_ms();
//			DebugPrint( (DebugLevelTrace, "DVDTS:init %dms\r\n", et - st ) );
//
//			break;

		case SRB_OPEN_DEVICE_INSTANCE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_DEVICE_INSTANCE\r\n") );
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_CLOSE_DEVICE_INSTANCE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_DEVICE_INSTANCE\r\n") );
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_GET_DEVICE_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_DEVICE_PROPERTY\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_DEVICE_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_DEVICE_PROPERTY\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_CHANGE_POWER_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CHANGE_POWER_STATE\r\n") );

			if (pSrb->CommandData.DeviceState == PowerDeviceD0) {

				//
				// should turn power back on here if was off; we're not sleeping in this sample.
				//

			} else {

				//
				// disable interrupts.
				// 

				decDisableInt( pHwDevExt );
			}

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNINITIALIZE_DEVICE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNINITIALIZE_DEVICE\r\n") );

			decDisableInt( pHwDevExt );

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_DEVICE_COMMAND:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_DEVICE_COMMAND\r\n") );
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

//		case SRB_QUERY_UNLOAD:
//			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_QUERY_UNLOAD\r\n") );
//			pSrb->Status = STATUS_NOT_IMPLEMENTED;
//			break;

		case SRB_PAGING_OUT_DRIVER:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PAGING_OUT_DRIVER\r\n") );

			decDisableInt( pHwDevExt );

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_DATA_INTERSECTION:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_DATA_INTERSECTION\r\n") );
			HwProcessDataIntersection( pSrb );
			break;

		default:
			if( pSrb->Command == 0x10D ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:  ---------------------------------------------\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:  -------- UNKNOWN SRB COMMAND (0x10D) --------\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:  ---------------------------------------------\r\n" ) );
			}
			else {
				DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
				TRAP;
			}

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}

	StreamClassDeviceNotification( ReadyForNextDeviceRequest,
									pSrb->HwDeviceExtension );
	StreamClassDeviceNotification( DeviceRequestComplete,
									pSrb->HwDeviceExtension,
									pSrb );
}

/*
** AdapterStreamInfo()
*/
VOID AdapterStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_STREAM_INFORMATION pstrinfo =
			&(pSrb->CommandData.StreamBuffer->StreamInfo );

	// define the number of streams which this mini driver can support.
	pSrb->CommandData.StreamBuffer->StreamHeader.NumberOfStreams = STREAMNUM;

	pSrb->CommandData.StreamBuffer->StreamHeader.SizeOfHwStreamInformation =
		sizeof(HW_STREAM_INFORMATION);

	// store a pointer to the topology for the device
	pSrb->CommandData.StreamBuffer->StreamHeader.Topology = (KSTOPOLOGY *)&Topology;

//	pSrb->CommandData.StreamBuffer->StreamHeader.NumDevPropArrayEntries = 1;
//	pSrb->CommandData.StreamBuffer->StreamHeader.DevicePropertiesArray = devicePropSet;


/* Video */
	pstrinfo->NumberOfPossibleInstances = 1;
	pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
	pstrinfo->DataAccessible = TRUE;
	pstrinfo->NumberOfFormatArrayEntries = 1;
	pstrinfo->StreamFormatsArray = Mpeg2VidInfo;	// see strmid.h

//	pstrinfo->NumStreamPropArrayEntries = 2;
	pstrinfo->NumStreamPropArrayEntries = 3;
	pstrinfo->StreamPropertiesArray = mpegVidPropSet;	// see strmid.h

	pstrinfo++;

/* Audio */
	pstrinfo->NumberOfPossibleInstances = 1;
	pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
	pstrinfo->DataAccessible = TRUE;
	pstrinfo->NumberOfFormatArrayEntries = 2;
	pstrinfo->StreamFormatsArray = AudioFormatBlocks;
//	pstrinfo->NumStreamPropArrayEntries = 2;
	pstrinfo->NumStreamPropArrayEntries = 3;
	pstrinfo->StreamPropertiesArray = mpegAudioPropSet;	// see strmid.h

	pstrinfo->StreamEventsArray = ClockEventSet;
	pstrinfo->NumStreamEventArrayEntries = SIZEOF_ARRAY(ClockEventSet);

	pstrinfo++;

/* Sub-pic */
	pstrinfo->NumberOfPossibleInstances = 1;
	pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
	pstrinfo->DataAccessible = TRUE;
	pstrinfo->NumberOfFormatArrayEntries = 1;
	pstrinfo->StreamFormatsArray = Mpeg2SubpicInfo;
//	pstrinfo->NumStreamPropArrayEntries = 2;
	pstrinfo->NumStreamPropArrayEntries = 3;
	pstrinfo->StreamPropertiesArray = SPPropSet;

	pstrinfo++;

/* V-port */
	pstrinfo->NumberOfPossibleInstances = 1;
	pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
	pstrinfo->DataAccessible = TRUE;
	pstrinfo->NumberOfFormatArrayEntries = 1;
	pstrinfo->StreamFormatsArray = VPEInfo;
	pstrinfo->NumStreamPropArrayEntries = 1;
	pstrinfo->StreamPropertiesArray = VideoPortPropSet;

	pstrinfo->MediumsCount = 1;
	pstrinfo->Mediums = &VPMedium;

	pstrinfo->StreamEventsArray = VPEventSet;
	pstrinfo->NumStreamEventArrayEntries = SIZEOF_ARRAY(VPEventSet);

	pstrinfo++;

/* CC */
	pstrinfo->NumberOfPossibleInstances = 1;
	pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
	pstrinfo->DataAccessible = TRUE;
	pstrinfo->NumberOfFormatArrayEntries = 1;
	pstrinfo->StreamFormatsArray = CCInfo;
	pstrinfo->NumStreamPropArrayEntries = 1;
	pstrinfo->StreamPropertiesArray = CCPropSet;

	pSrb->Status = STATUS_SUCCESS;
}

/*
** HwProcessDataIntersection()
*/

VOID HwProcessDataIntersection( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PSTREAM_DATA_INTERSECT_INFO	IntersectInfo;
	PKSDATARANGE	DataRange;
	PKSDATAFORMAT	pFormat = NULL;
	ULONG			formatSize;

	//
	// We need to compare
	// the data types passed in and error if the ranges don't overlap.
	// we also need to return valid format blocks, not just the data range.
	//

	IntersectInfo = pSrb->CommandData.IntersectInfo;
   DataRange = IntersectInfo->DataRange;

	switch (IntersectInfo->StreamNumber) {

	case strmVideo:

		pFormat = &hwfmtiMpeg2Vid;
		formatSize = sizeof hwfmtiMpeg2Vid;
		break;

	case strmAudio:

      if (IsEqualGUID2(&(DataRange->SubFormat), &(Mpeg2AudioFormat.DataFormat.SubFormat))) {
         // DebugPrint( (DebugLevelError, "DVDTS:    AC3 Audio format query\r\n") );
         pFormat = (PKSDATAFORMAT) &Mpeg2AudioFormat;
         formatSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);
      }
      else if (IsEqualGUID2(&(DataRange->SubFormat), &(LPCMAudioFormat.DataFormat.SubFormat))) {
         // DebugPrint( (DebugLevelError, "DVDTS:    LPCM Audio format query\r\n") );
         pFormat = (PKSDATAFORMAT) &LPCMAudioFormat;
         formatSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);
      }
      else {
         // DebugPrint( (DebugLevelError, "DVDTS:    unknown Audio format query\r\n") );
         pFormat = NULL;
         formatSize = 0;
      }
		break;

	case strmSubpicture:

		pFormat = &hwfmtiMpeg2Subpic;
		formatSize = sizeof hwfmtiMpeg2Subpic;
		break;

	case strmYUVVideo:

		DebugPrint( (DebugLevelTrace, "DVDTS:    VPE\r\n") );
		pFormat = &hwfmtiVPEOut;
		formatSize = sizeof hwfmtiVPEOut;
		break;

	case strmCCOut:

		DebugPrint(( DebugLevelTrace, "DVDTS:    CC\r\n" ));
		pFormat = &hwfmtiCCOut;
		formatSize = sizeof hwfmtiCCOut;
		break;

	default:
			DebugPrint( (DebugLevelTrace, "DVDTS:    STATUS_NOT_IMPLEMENTED\r\n") );
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			return;

	}						   // end streamnumber switch

	if (pFormat) {

		//
		// do a minimal compare of the dataranges to at least verify
		// that the guids are the same.
		//

		DataRange = IntersectInfo->DataRange;

		if (!(IsEqualGUID2(&DataRange->MajorFormat,
						  &pFormat->MajorFormat) &&
			  IsEqualGUID2(&DataRange->Specifier,
						  &pFormat->Specifier))) {

			DebugPrint( (DebugLevelTrace, "DVDTS:      STATUS_NO_MATCH\r\n") );
			Status = STATUS_NO_MATCH;

		} else {				// if guids are equal


			//
			// check to see if the size of the passed in buffer is a ULONG.
			// if so, this indicates that we are to return only the size
			// needed, and not return the actual data.
			//
         // if (IntersectInfo->StreamNumber == strmAudio)
         //   DebugPrint( (DebugLevelError, "DVDTS:    Audio GUIDs are equal\r\n") );

			if (IntersectInfo->SizeOfDataFormatBuffer != sizeof(ULONG)) {

				//
				// we are to copy the data, not just return the size
				//

				if (IntersectInfo->SizeOfDataFormatBuffer < formatSize) {

					DebugPrint( (DebugLevelTrace, "DVDTS:      STATUS_BUFFER_TOO_SMALL\r\n") );
					Status = STATUS_BUFFER_TOO_SMALL;

				} else {		// if too small

					RtlCopyMemory(IntersectInfo->DataFormatBuffer,
								  pFormat,
								  formatSize);

					pSrb->ActualBytesTransferred = formatSize;

               // if (IntersectInfo->StreamNumber == strmAudio)
               //   DebugPrint( (DebugLevelError, "DVDTS:    Audio STATUS_SUCCESS\r\n") );
					DebugPrint( (DebugLevelTrace, "DVDTS:      STATUS_SUCCESS(data copy)\r\n") );
					Status = STATUS_SUCCESS;

				}			   // if too small

			} else {			// if sizeof ULONG specified

				//
				// caller wants just the size of the buffer.  Get that.
				//

				*(PULONG) IntersectInfo->DataFormatBuffer = formatSize;
				pSrb->ActualBytesTransferred = sizeof(ULONG);

				DebugPrint( (DebugLevelTrace, "DVDTS:      STATUS_SUCCESS(return size)\r\n") );

			}				   // if sizeof ULONG

		}					   // if guids are equal

	} else {					// if pFormat

		DebugPrint( (DebugLevelTrace, "DVDTS:      STATUS_NOT_SUPPORTED\r\n") );
		Status = STATUS_NOT_SUPPORTED;
	}						   // if pFormat

	pSrb->Status = Status;

	return;
}


/*
** AdapterOpenStream()
*/
VOID AdapterOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	pSrb->Status = STATUS_SUCCESS;

	pHwDevExt->lCPPStrm = -1;	// reset the copy protection stream number.

	ASSERT( pHwDevExt->CppFlagCount == 0 );
	ASSERT( pHwDevExt->pSrbCpp == NULL );
	ASSERT( pHwDevExt->bCppReset == FALSE );

	pHwDevExt->CppFlagCount = 0;
	pHwDevExt->pSrbCpp = NULL;
	pHwDevExt->bCppReset = FALSE;

	switch( pSrb->StreamObject->StreamNumber ){
		case strmVideo:
			DebugPrint( (DebugLevelTrace, "DVDTS:    Video\r\n") );
			pSrb->StreamObject->ReceiveDataPacket =
				VideoReceiveDataPacket;
			pSrb->StreamObject->ReceiveControlPacket =
				VideoReceiveCtrlPacket;

			pHwDevExt->pstroVid = pSrb->StreamObject;

			ProcessVideoFormat( pSrb->CommandData.OpenFormat, pHwDevExt );

			DeviceQueue_init(pHwDevExt);

			SetVideoRateDefault( pHwDevExt );

			// If you would like to take out of previous picture,
			// insert codes here to reset and initialize MPEG Decoder Chip.

			pHwDevExt->cOpenInputStream++;

			decVsyncOn(pHwDevExt);

			decClosedCaptionOn( pHwDevExt );
			break;

		case strmAudio:
			DebugPrint( (DebugLevelTrace, "DVDTS:    Audio\r\n") );
			pSrb->StreamObject->ReceiveDataPacket =
				AudioReceiveDataPacket;
			pSrb->StreamObject->ReceiveControlPacket =
				AudioReceiveCtrlPacket;

			pSrb->StreamObject->HwClockObject.HwClockFunction = StreamClockRtn;
			pSrb->StreamObject->HwClockObject.ClockSupportFlags =
				CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK | CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK |
				CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME;

			pHwDevExt->pstroAud = pSrb->StreamObject;

			ProcessAudioFormat( pSrb->CommandData.OpenFormat, pHwDevExt );

			pSrb->StreamObject->HwEventRoutine = (PHW_EVENT_ROUTINE) AudioEvent;

			fStarted = fProgrammed = FALSE;

			SetAudioRateDefault( pHwDevExt );

			pHwDevExt->cOpenInputStream++;

			break;

		case strmSubpicture:
			DebugPrint( (DebugLevelTrace, "DVDTS:    Subpic\r\n") );
			pSrb->StreamObject->ReceiveDataPacket =
				SubpicReceiveDataPacket;
			pSrb->StreamObject->ReceiveControlPacket =
				SubpicReceiveCtrlPacket;

			pHwDevExt->pstroSP = pSrb->StreamObject;

			SetSubpicRateDefault( pHwDevExt );

			pHwDevExt->cOpenInputStream++;

			break;

		case strmYUVVideo:
			DebugPrint( (DebugLevelTrace, "DVDTS:    VPE\r\n") );
			pSrb->StreamObject->ReceiveDataPacket =
				VpeReceiveDataPacket;
			pSrb->StreamObject->ReceiveControlPacket =
				VpeReceiveCtrlPacket;

			pHwDevExt->pstroYUV = pSrb->StreamObject;

			pSrb->StreamObject->HwEventRoutine = (PHW_EVENT_ROUTINE) CycEvent;

			break;

		case strmCCOut:
			DebugPrint(( DebugLevelTrace, "DVDTS:    CC\r\n" ));
			pSrb->StreamObject->ReceiveDataPacket =
				CCReceiveDataPacket;
			pSrb->StreamObject->ReceiveControlPacket =
				CCReceiveCtrlPacket;

			pHwDevExt->pstroCC = pSrb->StreamObject;

			CCQueue_init(pHwDevExt);

			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->StreamObject->StreamNumber, pSrb->StreamObject->StreamNumber ) );
			TRAP;

			break;
	}

	pSrb->StreamObject->Dma = TRUE;
	pSrb->StreamObject->Pio = TRUE;	// Need Pio = TRUE for access on CPU
}

/*
** AdapterCloseStream()
*/
VOID AdapterCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	pSrb->Status = STATUS_SUCCESS;

	switch ( pSrb->StreamObject->StreamNumber ) {
	  case strmVideo:
		DebugPrint(( DebugLevelTrace, "DVDTS:    Video\r\n" ));
		pHwDevExt->pstroVid = NULL;
		pHwDevExt->cOpenInputStream--;

// Temporary ??
		pHwDevExt->XferStartCount = 0;
		pHwDevExt->DecodeStart = FALSE;
		pHwDevExt->SendFirst = FALSE;

		break;

	  case strmAudio:
		DebugPrint(( DebugLevelTrace, "DVDTS:    Audio\r\n" ));
		pHwDevExt->pstroAud = NULL;
		pHwDevExt->cOpenInputStream--;
		break;

	  case strmSubpicture:
		DebugPrint(( DebugLevelTrace, "DVDTS:    Subpic\r\n" ));
		pHwDevExt->pstroSP = NULL;
		pHwDevExt->cOpenInputStream--;
		break;

	  case strmYUVVideo:
		DebugPrint(( DebugLevelTrace, "DVDTS:    VPE\r\n" ));
		pHwDevExt->pstroYUV = NULL;
        decSetVideoPort( pHwDevExt, 0 );   // Disable
		break;

	  case strmCCOut:
		DebugPrint(( DebugLevelTrace, "DVDTS:    CC\r\n" ));
		pHwDevExt->pstroCC = NULL;

//		PHW_STREAM_REQUEST_BLOCK pSrbTmp;
//		for( ; ; ) {
//			pSrbTmp = pHwDevExt->CCQue.get();
//			if( pSrbTmp == NULL )
//				break;
//			pSrbTmp->Status = STATUS_SUCCESS;
//
//			DebugPrint(( DebugLevelTrace, "DVDTS:  CC pSrb = 0x%x\r\n", pSrbTmp ));
//
//			StreamClassStreamNotification( StreamRequestComplete,
//											pSrbTmp->StreamObject,
//											pSrbTmp );
//		}

		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->StreamObject->StreamNumber, pSrb->StreamObject->StreamNumber ) );
		TRAP;

		break;
	}
}


/*
** ClockEvents ()
**
**     handle any time event mark events
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

void ClockEvents( PHW_DEVICE_EXTENSION pHwDevExt )
{
   //
   // This is called from the VSync ISR once every 12 times that the ISR is entered.
   //
	PKSEVENT_ENTRY pEvent, pLast;
	PMYTIME pTim;
	LONGLONG MinIntTime;
	LONGLONG strmTime;

	if( !pHwDevExt || !pHwDevExt->pstroAud || !pHwDevExt->pstroSP )
		return;


	strmTime = LastStamp + ( GetSystemTime() - LastSys );

	//
	// loop through all time_mark events
	//

	pEvent = NULL;
	pLast = NULL;

	while(( pEvent = StreamClassGetNextEvent(
				pHwDevExt,
				pHwDevExt->pstroAud,
				(GUID *)&KSEVENTSETID_Clock,
				KSEVENT_CLOCK_POSITION_MARK,
				pLast )) != NULL )
	{
		DebugPrint((
			DebugLevelTrace,
			"DVDTS:ClockEvent(1) 0x%s, 0x%s\r\n",
			DebugLLConvtoStr( ((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime, 16 ),
			DebugLLConvtoStr( strmTime, 16 )
			));
//c		DebugPrint(( DebugLevelTrace, "DVDTS:  strmTime        0x%x\r\n", strmTime ));
//c		DebugPrint(( DebugLevelTrace, "DVDTS:  LastStamp       0x%x\r\n", LastStamp ));
//c		DebugPrint(( DebugLevelTrace, "DVDTS:  GetSystemTime() 0x%x\r\n", GetSystemTime() ));
//c		DebugPrint(( DebugLevelTrace, "DVDTS:  LastSys         0x%x\r\n", LastSys ));

//		TRAP;

		if (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime <= strmTime ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:    Notify\r\n" ));
//			TRAP;

			//
			// signal the event here
			//

			StreamClassStreamNotification(
				SignalStreamEvent,
				pHwDevExt->pstroAud,
				pEvent
				);

		}
		pLast = pEvent;
	}

	//
	// loop through all time_interval events
	//

	pEvent = NULL;
	pLast = NULL;

	while(( pEvent = StreamClassGetNextEvent(
                pHwDevExt,
                pHwDevExt->pstroAud,
                (GUID *)&KSEVENTSETID_Clock,
                KSEVENT_CLOCK_INTERVAL_MARK,
                pLast )) != NULL )
	{
		//
		// check if this event has been used for this interval yet
		//

		pTim = ((PMYTIME)(pEvent + 1));

		DebugPrint((
			DebugLevelTrace,
			"DVDTS:ClockEvent(2) strmTime 0x%s\r\n",
			DebugLLConvtoStr( strmTime, 16 )
			));
		DebugPrint((
			DebugLevelTrace,
			"DVDTS:               Interval 0x%s\r\n",
			DebugLLConvtoStr( pTim->tim.Interval, 16 )
			));
		DebugPrint((
			DebugLevelTrace,
			"DVDTS:               TimeBase 0x%s\r\n",
			DebugLLConvtoStr( pTim->tim.TimeBase, 16 )
			));

		if (pTim && pTim->tim.Interval)
		{

			if (pTim->tim.TimeBase <= strmTime)
			{
				MinIntTime = (strmTime - pTim->tim.TimeBase) / pTim->tim.Interval;
				MinIntTime *= pTim->tim.Interval;
				MinIntTime +=  pTim->tim.TimeBase;

			DebugPrint((
				DebugLevelTrace,
				"DVDTS:               MinIntTime 0x%s\r\n",
				DebugLLConvtoStr( MinIntTime, 16 )
				));
			DebugPrint((
				DebugLevelTrace,
				"DVDTS:               LastTime 0x%s\r\n",
				DebugLLConvtoStr( pTim->LastTime, 16 )
				));

				if (MinIntTime > pTim->LastTime  )
				{

					DebugPrint(( DebugLevelTrace, "DVDTS:  Notify\r\n" ));
					TRAP;

					//
					// signal the event here
					//

					StreamClassStreamNotification(
						SignalStreamEvent,
						pHwDevExt->pstroAud,
						pEvent
						);

					pTim->LastTime = strmTime;

				}
			}

		}
		else
		{
			DebugPrint(( DebugLevelTrace, "DVDTS:ClockEvent(?)\r\n" ));
			TRAP;
		}
		pLast = pEvent;
	}
}


/*
** AudioEvent ()
**
**    receives notification for audio clock enable / disable events
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

NTSTATUS STREAMAPI AudioEvent( PHW_EVENT_DESCRIPTOR pEvent )
{
	PUCHAR pCopy = (PUCHAR)( pEvent->EventEntry + 1 );
        PMYTIME pmyt = (PMYTIME)pCopy;
	PUCHAR pSrc = (PUCHAR)pEvent->EventData;
	ULONG cCopy;

	DebugPrint(( DebugLevelVerbose, "DVDTS:AudioEvent\r\n" ));

	if( pEvent->Enable ) {
		switch( pEvent->EventEntry->EventItem->EventId ) {
		  case KSEVENT_CLOCK_POSITION_MARK:
			cCopy = sizeof( KSEVENT_TIME_MARK );
			break;

		  case KSEVENT_CLOCK_INTERVAL_MARK:
			cCopy = sizeof( KSEVENT_TIME_INTERVAL );
			break;

		  default:

			TRAP;

			return( STATUS_NOT_IMPLEMENTED );
		}

		if( pEvent->EventEntry->EventItem->DataInput != cCopy ) {
			TRAP;

			return( STATUS_INVALID_BUFFER_SIZE );
		}

		//
		// copy the input buffer
		//

		for( ; cCopy > 0; cCopy-- ) {
			*pCopy++ = *pSrc++;
		}
		if( pEvent->EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
                         pmyt->LastTime = 0;
                }

	}

	return( STATUS_SUCCESS );
}


/*
** CycEvent ()
**
**    receives notification for stream event enable/ disable
**
** Arguments:}
**
**
**
** Returns:
**
** Side Effects:
*/


NTSTATUS STREAMAPI CycEvent( PHW_EVENT_DESCRIPTOR pEvent )
{
	PSTREAMEX pstrm = (PSTREAMEX)( pEvent->StreamObject->HwStreamExtension );

	DebugPrint( (DebugLevelTrace, "DVDTS:CycEvent\r\n") );

	if( pEvent->Enable ) {
		pstrm->EventCount++;
	}
	else {
		pstrm->EventCount--;
	}

	return( STATUS_SUCCESS );
}


/*
** VideoReceiveDataPacket()
*/
VOID STREAMAPI VideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PULONG pCount = &(pHwDevExt->XferStartCount);

	DebugPrint( (DebugLevelVerbose, "DVDTS:VideoReceiveDataPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_WRITE_DATA:
			DebugPrint( (DebugLevelVerbose, "DVDTS:  SRB_WRITE_DATA\r\n") );

			{	// Temporary
				ULONG i;
				PKSSTREAM_HEADER pStruc;

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					if( !( pStruc->OptionsFlags & (KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY |
						KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY |
							KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ))) {
//						DebugPrint(( DebugLevelTrace, "DVDTS: *** Video # 0x%x\r\n",
//							pStruc->xHdr.MediaSpecificFlags >> 16 ));
					}

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  DATADISCONTINUITY(Video)\r\n" ));

						VideoDataDiscontinuity( pHwDevExt );
						pHwDevExt->bStopCC = TRUE;
						decClosedCaptionOff( pHwDevExt );

					}
					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  TIMEDISCONTINUITY(Video)\r\n" ));
						pHwDevExt->TimeDiscontFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  TimeDiscontFlagCount=%ld\r\n", pHwDevExt->TimeDiscontFlagCount ));
						if( pHwDevExt->TimeDiscontFlagCount >= pHwDevExt->cOpenInputStream ) {
							StreamClassScheduleTimer(
								NULL,
								pHwDevExt,
								1,
								(PHW_TIMER_ROUTINE)MenuDecodeStart,	
								pHwDevExt
							);
						}
					}
					if( pStruc->TypeSpecificFlags & KS_AM_UseNewCSSKey ) {
						pHwDevExt->CppFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  CppFlagCount=%ld\r\n", pHwDevExt->CppFlagCount ));
						if( pHwDevExt->CppFlagCount >= pHwDevExt->cOpenInputStream + 1 )
							SetCppFlag( pHwDevExt );
					}
				}

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					DebugPrint( (DebugLevelVerbose, "DVDTS: VideoPacet Flag = 0x%x\r\n", pStruc->OptionsFlags ));

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:TYPECHANGE(Video)\r\n" ));
						if( pStruc->DataUsed >= sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2) ) {
							ProcessVideoFormat( (PKSDATAFORMAT)pStruc->Data, pHwDevExt );
						}
						else {
							TRAP;
						}
						i = pSrb->NumberOfBuffers;
						break;
					}

					if( pStruc->DataUsed )
						break;

				}
				if( i == pSrb->NumberOfBuffers ) {
					pSrb->Status = STATUS_SUCCESS;
					break;
				}
			}

//			DebugDumpKSTIME( pSrb );

//			if(	pHwDevExt->Rate < 10000 ) {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  Change PTS for F.F. (Video)\r\n" ) );
//			}

			FastSlowControl( pSrb );
			if( pHwDevExt->bVideoQueue == TRUE ) {
            pHwDevExt->bStopCC = FALSE;
				DeviceQueue_put_video( pHwDevExt, pSrb );
			}
			else {
				pSrb->Status = STATUS_SUCCESS;
				DebugPrint( (DebugLevelTrace, "DVDTS:  VideoData was Discarded\r\n" ) );
				break;
			}

//			if( *pCount <= 24 )
//				(*pCount)++;
//			if( *pCount == 24 )
//				DMAxfer( pHwDevExt, 0x03 );
//			else if( (*pCount) == 25 ) {

			if( pHwDevExt->pSrbDMA0 == NULL && pHwDevExt->pSrbDMA1 == NULL )
				PreDMAxfer( pHwDevExt/*, 0x03 */);

//			}

// for Debug
//	if(	pHwDevExt->Rate < 10000 ) {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  ReadyForNextStreamDataRequest(Video)\r\n" ) );
//	}
// end
			StreamClassStreamNotification( ReadyForNextStreamDataRequest,
											pSrb->StreamObject );

			return;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	DebugPrint(( DebugLevelTrace, "DVDTS:---------VideoReceiveDataPacket( SRB has no data)\r\n" ));

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}


/*
** VideoReceiveCtrlPacket()
*/
VOID STREAMAPI VideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:VideoReceiveCtrlPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_SET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_STATE\r\n") );

			switch( pSrb->CommandData.StreamState ) {
				case KSSTATE_STOP:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_STOP\r\n") );

					StopData( pHwDevExt );

					SetVideoRateDefault( pHwDevExt );
					pHwDevExt->bVideoQueue = FALSE;
					pHwDevExt->bAudioQueue = FALSE;
					pHwDevExt->bSubpicQueue = FALSE;

					break;

				case KSSTATE_PAUSE:

					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_PAUSE\r\n") );

					PauseTime = GetSystemTime();
					if( !fStarted ) {
						fStarted = TRUE;
						LastStamp = 0;
						StartSys = LastSysTime = PauseTime;
					}

					fClkPause = TRUE;

					SetPlayMode( pHwDevExt, PLAY_MODE_FREEZE );

					break;

				case KSSTATE_RUN:

					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_RUN\r\n") );

					if( !fStarted && !fProgrammed ) {
						LastStamp = 0;
						StartSys = LastSysTime = GetSystemTime();
					}

					fStarted = TRUE;
					fClkPause = FALSE;

					SetPlayMode( pHwDevExt, decGetVideoRunMode( pHwDevExt ) );

					break;
			}

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_STATE\r\n") );
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_PROPERTY\r\n") );

			GetVideoProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_SET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_PROPERTY\r\n") );

			SetVideoProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_INDICATE_MASTER_CLOCK\r\n") );

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_STREAM_COMMAND\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_RATE\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PROPOSE_DATA_FORMAT\r\n") );

			VideoQueryAccept( pSrb );

			break;

		case SRB_PROPOSE_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PROPOSE_STREAM_RATE\r\n") );

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
//			SetRateChange( pSrb );
			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** AudioReceiveDataPacket()
*/
VOID STREAMAPI AudioReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelVerbose, "DVDTS:AudioReceiveDataPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_WRITE_DATA:
			DebugPrint( (DebugLevelVerbose, "DVDTS:  SRB_WRITE_DATA\r\n") );

			{	// Temporary
				ULONG i;
				PKSSTREAM_HEADER pStruc;

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					if( !( pStruc->OptionsFlags & (KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY |
						KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY |
							KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ))) {
//						DebugPrint(( DebugLevelTrace, "DVDTS: *** Audio # 0x%x\r\n",
//							pStruc->xHdr.MediaSpecificFlags >> 16 ));
					}

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  DATADISCONTINUITY(Audio)\r\n" ));
						AudioDataDiscontinuity( pHwDevExt );
					}
					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  TIMEDISCONTINUITY(Audio)\r\n" ));
						pHwDevExt->TimeDiscontFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  TimeDiscontFlagCount=%ld\r\n", pHwDevExt->TimeDiscontFlagCount ));
						if( pHwDevExt->TimeDiscontFlagCount >= pHwDevExt->cOpenInputStream ) {
							StreamClassScheduleTimer(
								NULL,
								pHwDevExt,
								1,
								(PHW_TIMER_ROUTINE)MenuDecodeStart,	
								pHwDevExt
							);
						}
					}
					if( pStruc->TypeSpecificFlags & KS_AM_UseNewCSSKey ) {
						pHwDevExt->CppFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  CppFlagCount=%ld\r\n", pHwDevExt->CppFlagCount ));
						if( pHwDevExt->CppFlagCount >= pHwDevExt->cOpenInputStream + 1 )
							SetCppFlag( pHwDevExt );
					}
				}

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					DebugPrint( (DebugLevelVerbose, "DVDTS: AudioPacket Flag = 0x%x\r\n", pStruc->OptionsFlags ));

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:TYPECHANGE(Audio)\r\n" ));
//						if( pStruc->DataUsed >= sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2) ) {
						if( pStruc->DataUsed ) {
							ProcessAudioFormat( (PKSDATAFORMAT)pStruc->Data, pHwDevExt );
						}
						else {
							TRAP;
						}
						i = pSrb->NumberOfBuffers;
						break;
					}

					if( pStruc->DataUsed )
						break;
				}
				if( i == pSrb->NumberOfBuffers ) {
					pSrb->Status = STATUS_SUCCESS;
					break;
				}
			}

// for Debug
//	if(	pHwDevExt->Rate < 10000 ) {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  Change PTS for F.F. (Audio)\r\n" ) );
//	}
// end
//			FastSlowControl( pSrb );
			if( pHwDevExt->bAudioQueue == TRUE ) {
				DeviceQueue_put_audio( pHwDevExt, pSrb );
			}
			else {
				pSrb->Status = STATUS_SUCCESS;
				DebugPrint( (DebugLevelTrace, "DVDTS:  AudioData was Discarded\r\n" ) );
				break;
			}

			if( pHwDevExt->pSrbDMA0 == NULL && pHwDevExt->pSrbDMA1 == NULL )
				PreDMAxfer( pHwDevExt/*, 0x03 */);

// for Debug
//	if(	pHwDevExt->Rate < 10000 ) {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  ReadyForNextStreamDataRequest(Audio)\r\n" ) );
//	}
// end
			StreamClassStreamNotification( ReadyForNextStreamDataRequest,
											pSrb->StreamObject );

			return;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	DebugPrint(( DebugLevelTrace, "DVDTS:---------AudioReceiveDataPacket( SRB has no data)\r\n" ));

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** AudioReceiveCtrlPacket()
*/
VOID STREAMAPI AudioReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:AudioReceiveCtrlPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_SET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_STATE\r\n") );

			switch( pSrb->CommandData.StreamState ) {
				case KSSTATE_STOP:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_STOP\r\n") );
					SetAudioRateDefault( pHwDevExt );
					pHwDevExt->bAudioQueue = FALSE;
					break;

				case KSSTATE_PAUSE:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_PAUSE\r\n") );
					break;

				case KSSTATE_RUN:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_RUN\r\n") );
					break;
			}

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_STATE\r\n") );
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_PROPERTY\r\n") );

			GetAudioProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_SET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_PROPERTY\r\n") );

			SetAudioProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_INDICATE_MASTER_CLOCK\r\n") );

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_STREAM_COMMAND\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_RATE\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PROPOSE_DATA_FORMAT\r\n") );

			AudioQueryAccept( pSrb );

			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}


/*
** SubpicReceiveDataPacket()
*/
VOID STREAMAPI SubpicReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelVerbose, "DVDTS:SubpicReceiveDataPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_WRITE_DATA:
			DebugPrint( (DebugLevelVerbose, "DVDTS:  SRB_WRITE_DATA\r\n") );

			{	// Temporary
				ULONG i;
				PKSSTREAM_HEADER pStruc;

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					if(!( pStruc->OptionsFlags & (KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY |
						KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY |
							KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ))) {
//						DebugPrint(( DebugLevelTrace, "DVDTS: *** Subpic # 0x%x\r\n",
//							pStruc->xHdr.MediaSpecificFlags >> 16 ));
					}

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  DATADISCONTINUITY(Subpic)\r\n" ));
						SubpicDataDiscontinuity( pHwDevExt );
					}
					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:  TIMEDISCONTINUITY(Subpic)\r\n" ));
						pHwDevExt->TimeDiscontFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  TimeDiscontFlagCount=%ld\r\n", pHwDevExt->TimeDiscontFlagCount ));
						if( pHwDevExt->TimeDiscontFlagCount >= pHwDevExt->cOpenInputStream ) {
							StreamClassScheduleTimer(
								NULL,
								pHwDevExt,
								1,
								(PHW_TIMER_ROUTINE)MenuDecodeStart,	
								pHwDevExt
							);
						}
					}
					if( pStruc->TypeSpecificFlags & KS_AM_UseNewCSSKey ) {
						pHwDevExt->CppFlagCount++;
						DebugPrint(( DebugLevelTrace, "DVDTS:  CppFlagCount=%ld\r\n", pHwDevExt->CppFlagCount ));
						if( pHwDevExt->CppFlagCount >= pHwDevExt->cOpenInputStream + 1 )
							SetCppFlag( pHwDevExt );
					}
				}

				for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];

					DebugPrint( (DebugLevelVerbose, "DVDTS: SubPicPacket Flag = 0x%x\r\n", pStruc->OptionsFlags ));

					if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED ) {
						DebugPrint(( DebugLevelTrace, "DVDTS:TYPECHANGE(subpic)\r\n" ));
						TRAP;
						i = pSrb->NumberOfBuffers;
						break;
					}

					if( pStruc->DataUsed )
						break;
				}
				if( i == pSrb->NumberOfBuffers ) {
					pSrb->Status = STATUS_SUCCESS;
					break;
				}
			}
			{
				ULONG i;
				PKSSTREAM_HEADER pStruc;

				for ( i=0; i<pSrb->NumberOfBuffers; i++ ) {
					pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];
					SetSubpicID( pHwDevExt, pStruc );
				}
			}


			if( pHwDevExt->bSubpicQueue == TRUE ) {
				DeviceQueue_put_subpic( pHwDevExt, pSrb );
			}
			else {
				pSrb->Status = STATUS_SUCCESS;
				DebugPrint( (DebugLevelTrace, "DVDTS:  SubpicData was Discarded\r\n" ) );
				break;
			}


			StreamClassStreamNotification( ReadyForNextStreamDataRequest,
											pSrb->StreamObject );

			return;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	DebugPrint(( DebugLevelTrace, "DVDTS:---------SubpicReceiveDataPacket( SRB has no data)\r\n" ));

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** SubpicReceiveCtrlPacket()
*/
VOID STREAMAPI SubpicReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

//h	DebugPrint( (DebugLevelTrace, "DVDTS:SubpicReceiveCtrlPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_SET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_STATE\r\n") );

			switch( pSrb->CommandData.StreamState ) {
				case KSSTATE_STOP:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_STOP\r\n") );
					SetSubpicRateDefault( pHwDevExt );
					pHwDevExt->bSubpicQueue = FALSE;
					break;
				case KSSTATE_PAUSE:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_PAUSE\r\n") );
					break;
				case KSSTATE_RUN:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_RUN\r\n") );
					break;
			}

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_STATE\r\n") );
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_PROPERTY\r\n") );

			GetSubpicProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_SET_STREAM_PROPERTY:
//h			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_PROPERTY\r\n") );

			SetSubpicProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_INDICATE_MASTER_CLOCK\r\n") );

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_STREAM_COMMAND\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_RATE\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PROPOSE_DATA_FORMAT\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** VpeReceiveDataPacket()
*/
VOID STREAMAPI VpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelVerbose, "DVDTS:VpeReceiveDataPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_READ_DATA:
			DebugPrint( (DebugLevelVerbose, "DVDTS:  SRB_READ_DATA\r\n") );

			pSrb->ActualBytesTransferred = 0;
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_WRITE_DATA:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_WRITE_DATA\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** VpeReceiveCtrlPacket()
*/
VOID STREAMAPI VpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:VpeReceiveCtrlPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_SET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_STATE\r\n") );

			switch( pSrb->CommandData.StreamState ) {
				case KSSTATE_STOP:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_STOP\r\n") );
					break;
				case KSSTATE_PAUSE:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_PAUSE\r\n") );
					break;
				case KSSTATE_RUN:
					DebugPrint( (DebugLevelTrace, "DVDTS:    KSSTATE_RUN\r\n") );
					break;
			}

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_STATE\r\n") );
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_PROPERTY\r\n") );

			GetVpeProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_SET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_PROPERTY\r\n") );

			SetVpeProperty( pSrb );

			break;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_CLOSE_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_INDICATE_MASTER_CLOCK\r\n") );

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_STREAM_COMMAND\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_RATE\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_PROPOSE_DATA_FORMAT\r\n") );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** CCReceiveDataPacket()
*/
VOID STREAMAPI CCReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "DVDTS:CCReceiveDataPacket---------\r\n" ));

	switch( pSrb->Command ) {
		case SRB_READ_DATA:
			DebugPrint(( DebugLevelVerbose, "DVDTS:  SRB_READ_DATA\r\n" ));

			DebugPrint(( DebugLevelTrace, "DVDTS:  put queue CC pSrb = 0x%x\r\n", pSrb ));
			CCQueue_put( pHwDevExt, pSrb );

			pSrb->Status = STATUS_PENDING;

                        pSrb->TimeoutCounter = 0;        // prevent the packet from timing out, ever
			StreamClassStreamNotification( ReadyForNextStreamDataRequest,
											pSrb->StreamObject );
			return;

		case SRB_WRITE_DATA:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_WRITE_DATA\r\n" ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint(( DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** CCReceiveCtrlPacket()
*/
VOID STREAMAPI CCReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelTrace, "DVDTS:CCReceiveCtrlPacket---------\r\n" ));

	switch( pSrb->Command ) {
		case SRB_SET_STREAM_STATE:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_STATE\r\n" ));

			switch( pSrb->CommandData.StreamState ) {
				case KSSTATE_STOP:
					DebugPrint(( DebugLevelTrace, "DVDTS:    KSSTATE_STOP\r\n" ));
					break;
				case KSSTATE_PAUSE:
					DebugPrint(( DebugLevelTrace, "DVDTS:    KSSTATE_PAUSE\r\n" ));
					break;
				case KSSTATE_RUN:
					DebugPrint(( DebugLevelTrace, "DVDTS:    KSSTATE_RUN\r\n" ));
					break;
			}

			((PSTREAMEX)(pHwDevExt->pstroCC->HwStreamExtension))->state = pSrb->CommandData.StreamState;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_STATE\r\n" ));
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_GET_STREAM_PROPERTY\r\n" ));

			GetCCProperty( pSrb );

			break;

		case SRB_SET_STREAM_PROPERTY:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_PROPERTY\r\n" ));

			SetCCProperty( pSrb );

			break;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, "DVDTS:  SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_CLOSE_MASTER_CLOCK\r\n" ));

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_INDICATE_MASTER_CLOCK\r\n" ));

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_UNKNOWN_STREAM_COMMAND\r\n" ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_SET_STREAM_RATE\r\n" ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint(( DebugLevelTrace, "DVDTS:  SRB_PROPOSE_DATA_FORMAT\r\n" ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint(( DebugLevelTrace, "DVDTS:  default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ));
			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

void VideoQueryAccept(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PKSDATAFORMAT pfmt = pSrb->CommandData.OpenFormat;
	ULONGLONG tptr = (ULONGLONG) pfmt + sizeof  (KSDATAFORMAT);
	KS_MPEGVIDEOINFO2 * pblock = (KS_MPEGVIDEOINFO2 *)tptr;

	DebugPrint( (DebugLevelTrace, "DVDTS:VideoQueryAccept\r\n" ) );
	//
	// pick up the format block and examine it. Default to not implemented
	//

	pSrb->Status = STATUS_NOT_IMPLEMENTED;

	if (pfmt->FormatSize != sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2))
	{
		return;
	}

	pSrb->Status = STATUS_SUCCESS;

}

void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt )
{

	ULONGLONG tptr = (ULONGLONG) pfmt + sizeof  (KSDATAFORMAT);
	KS_MPEGVIDEOINFO2 * VidFmt = (KS_MPEGVIDEOINFO2 *)tptr;

	DebugPrint( (DebugLevelTrace, "DVDTS:ProcessVideoFormat\r\n" ) );

	if( pfmt->FormatSize != sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2) ) {
		TRAP;

		return;
	}

	//
	// copy the picture aspect ratio for now
	//

	pHwDevExt->VPFmt.dwPictAspectRatioX = VidFmt->hdr.dwPictAspectRatioX;
	pHwDevExt->VPFmt.dwPictAspectRatioY = VidFmt->hdr.dwPictAspectRatioY;

	DebugPrint(( DebugLevelTrace, "DVDTS:  AspectRatioX %d\r\n", VidFmt->hdr.dwPictAspectRatioX ));
	DebugPrint(( DebugLevelTrace, "DVDTS:  AspectRatioY %d\r\n", VidFmt->hdr.dwPictAspectRatioY ));

	if( pHwDevExt->VPFmt.dwPictAspectRatioX == 4 && pHwDevExt->VPFmt.dwPictAspectRatioY == 3 ) {
		decCGuard_CPGD_SET_ASPECT( pHwDevExt, 0 );
	}
	else if (pHwDevExt->VPFmt.dwPictAspectRatioX == 16 && pHwDevExt->VPFmt.dwPictAspectRatioY == 9 ) {
		decCGuard_CPGD_SET_ASPECT( pHwDevExt, 1 );
	}

	//
	// check for pan scan enabled
	//

	if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
		DebugPrint(( DebugLevelTrace, "DVDTS:  KS_MPEG2_DoPanScan\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_DVDLine21Field1 )
		DebugPrint(( DebugLevelTrace, "DVDTS:  KS_MPEG2_DVDLine21Field1\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_DVDLine21Field2 )
		DebugPrint(( DebugLevelTrace, "DVDTS:  KS_MPEG2_DVDLine21Field2\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_SourceIsLetterboxed )
		DebugPrint(( DebugLevelTrace, "DVDTS:  KS_MPEG2_SourceIsLetterboxed\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_FilmCameraMode )
		DebugPrint(( DebugLevelTrace, "DVDTS:  KS_MPEG2_FilmCameraMode\r\n" ));

	if (VidFmt->dwFlags & KS_MPEG2_DoPanScan)
	{
		TRAP;

		//
		// under pan scan for DVD for NTSC, we must be going to a 540 by
		// 480 bit image, from a 720 x 480 (or 704 x 480)  We will
		// use this as the base starting dimensions.  If the Sequence
		// header provides other sizes, then those should be updated,
		// and the Video port connection should be updated when the
		// sequence header is received.
		//

		//
		// change the picture aspect ratio.  Since we will be stretching
		// from 540 to 720 in the horizontal direction, our aspect ratio
		// will 
		//

		pHwDevExt->VPFmt.dwPictAspectRatioX = (VidFmt->hdr.dwPictAspectRatioX * (54000 / 72));
		pHwDevExt->VPFmt.dwPictAspectRatioY = VidFmt->hdr.dwPictAspectRatioY * 1000;

	}

	//
	// call the IVPConfig interface here
	//

	if (pHwDevExt->pstroYUV &&
			((PSTREAMEX)(pHwDevExt->pstroYUV->HwStreamExtension))->EventCount)
	{
		StreamClassStreamNotification(
			SignalMultipleStreamEvents,
			pHwDevExt->pstroYUV,
			&MY_KSEVENTSETID_VPNOTIFY,
			KSEVENT_VPNOTIFY_FORMATCHANGE
			);

	}
}





// Debug

void BadWait( DWORD dwTime )
{
	DWORD st, et;

	st = GetCurrentTime_ms();
	for( ; ; ) {
		KeStallExecutionProcessor( 1 );
		et = GetCurrentTime_ms();
		if( st + dwTime < et )
			break;
	}
	DebugPrint( (DebugLevelTrace, "DVDTS:wait %dms\r\n", et - st ) );
}

void VideoDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->DataDiscontFlagCount |= VIDEO_DISCONT_FLAG;
	pHwDevExt->bVideoQueue = TRUE;
}

void AudioDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->DataDiscontFlagCount |= AUDIO_DISCONT_FLAG;
	pHwDevExt->bAudioQueue = TRUE;
}

void SubpicDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->DataDiscontFlagCount |= SUBPIC_DISCONT_FLAG;
	pHwDevExt->bSubpicQueue = TRUE;
}

void ClearDataDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->DataDiscontFlagCount = 0;
}

void VideoTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
}

void AudioTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
}

void SubpicTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
}

void ClearTimeDiscontinuity( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->TimeDiscontFlagCount = 0;
}

void FastSlowControl( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	ULONG i;
	PKSSTREAM_HEADER pStruc;
	PUCHAR pDat;
	LONGLONG pts = 0;
	LONGLONG dts = 0;
	LONGLONG tmp = 0;
	LONG Rate;
	LONGLONG start;
	REFERENCE_TIME InterceptTime;

	for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
		pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];
		if( pStruc->DataUsed ) {
			pDat = (PUCHAR)pStruc->Data;
			if( *(pDat+21) & 0x80 ) { 
				pts += ((DWORD)(*(pDat+23) & 0x0E)) << 29;
				pts += ((DWORD)(*(pDat+24) & 0xFF)) << 22;
				pts += ((DWORD)(*(pDat+25) & 0xFE)) << 14;
				pts += ((DWORD)(*(pDat+26) & 0xFF)) <<  7;
				pts += ((DWORD)(*(pDat+27) & 0xFE)) >>  1;

				DebugPrint( (DebugLevelTrace, "DVDTS:ReceiveDataPacket PTS 0x%lx(100ns)\r\n", pts * 1000 / 9));
			}
		}
	}
	pts = 0;

//	if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST ) {
	if( decGetVideoRunMode( pHwDevExt ) == PLAY_MODE_FAST ) {

//		DebugPrint( (DebugLevelTrace, "DVDTS:    FastSlowControl\r\n") );

		Rate = pHwDevExt->Rate;
		InterceptTime = pHwDevExt->InterceptTime;
		start = pHwDevExt->StartTime * 9 / 1000;
		for( i = 0; i < pSrb->NumberOfBuffers; i++ ) {
			pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[i];
			if( pStruc->DataUsed ) {
				pDat = (PUCHAR)pStruc->Data;

				// PTS modify
				if( *(pDat+21) & 0x80 ) { 
					pts += ((DWORD)(*(pDat+23) & 0x0E)) << 29;
					pts += ((DWORD)(*(pDat+24) & 0xFF)) << 22;
					pts += ((DWORD)(*(pDat+25) & 0xFE)) << 14;
					pts += ((DWORD)(*(pDat+26) & 0xFF)) <<  7;
					pts += ((DWORD)(*(pDat+27) & 0xFE)) >>  1;

					DebugPrint( (DebugLevelTrace, "DVDTS:  PTS before Rate Change = %lx\r\n", pts ));
//					DebugPrint( (DebugLevelTrace, "DVDTS:  Rate                   = %lx\r\n", Rate ));
//					DebugPrint( (DebugLevelTrace, "DVDTS:  InterceptTime          = %lx\r\n", InterceptTime ));

					tmp = pts;
//					pts = Rate * ( pts - ConvertStrmtoPTS(InterceptTime) ) / 10000;
					pts = Rate * ( pts - (InterceptTime * 9 / 1000) ) / 10000;

					*(pDat+23) = (UCHAR)(((pts & 0xC0000000) >> 29) | 0x11);
					*(pDat+24) = (UCHAR)(((pts & 0x3FC00000) >> 22) | 0x00);
					*(pDat+25) = (UCHAR)(((pts & 0x003F8000) >> 14) | 0x01);
					*(pDat+26) = (UCHAR)(((pts & 0x00007F80) >>  7) | 0x00);
					*(pDat+27) = (UCHAR)(((pts & 0x0000007F) <<  1) | 0x01);

					DebugPrint( (DebugLevelTrace, "DVDTS:  PTS after Rate Change = %lx\r\n", pts ));

				}

				// DTS modify
				if( *(pDat+17)==0xE0 ) {			// 0xE0 is Video Stream ID
					if( (*(pDat+21) & 0xC0) == 0xC0 ) {
						dts += ((DWORD)(*(pDat+28) & 0x0E)) << 29;
						dts += ((DWORD)(*(pDat+29) & 0xFF)) << 22;
						dts += ((DWORD)(*(pDat+30) & 0xFE)) << 14;
						dts += ((DWORD)(*(pDat+31) & 0xFF)) <<  7;
						dts += ((DWORD)(*(pDat+32) & 0xFE)) >>  1;
						dts = pts - (tmp - dts);
						*(pDat+28) = (UCHAR)(((dts & 0xC0000000) >> 29) | 0x11);
						*(pDat+29) = (UCHAR)(((dts & 0x3FC00000) >> 22) | 0x00);
						*(pDat+30) = (UCHAR)(((dts & 0x003F8000) >> 14) | 0x01);
						*(pDat+31) = (UCHAR)(((dts & 0x00007F80) >>  7) | 0x00);
						*(pDat+32) = (UCHAR)(((dts & 0x0000007F) <<  1) | 0x01);
					}
				}
			}
		}
	}
}

DWORD xunGetPTS(void *pBuf)
{
	PUCHAR  pDat;
	DWORD	pts = 0;
	DWORD	dts = 0;
	static  count = 0;

	pDat = (PUCHAR)pBuf;
	if (*(pDat+21) & 0x80) {	// if PTS exists, 
		pts += ((DWORD)(*(pDat+23) & 0x0E)) << 29;
		pts += ((DWORD)(*(pDat+24) & 0xFF)) << 22;
		pts += ((DWORD)(*(pDat+25) & 0xFE)) << 14;
		pts += ((DWORD)(*(pDat+26) & 0xFF)) <<  7;
		pts += ((DWORD)(*(pDat+27) & 0xFE)) >>  1;
	}
	if (*(pDat+17)==0xE0) {			// 0xE0 is Video Stream ID

//		if ( (*(pDat+21) & 0xC0) == 0xC0 ) {
//			dts += ((DWORD)(*(pDat+28) & 0x0E)) << 29;
//			dts += ((DWORD)(*(pDat+29) & 0xFF)) << 22;
//			dts += ((DWORD)(*(pDat+30) & 0xFE)) << 14;
//			dts += ((DWORD)(*(pDat+31) & 0xFF)) <<  7;
//			dts += ((DWORD)(*(pDat+32) & 0xFE)) >>  1;
////			DebugPrint( (DebugLevelTrace, "DVDTS:  DTS(V) 0x%08lX\r\n", dts) );
////			DebugPrint( (DebugLevelTrace, "DVDTS:  DIFF(pts - dts) = 0x%04lX\r\n", pts-dts) );
//
//			dts = pts - 0x2328; // PTS - 100ms
//			*(pDat+28) = (UCHAR)(((dts & 0xC0000000) >> 29) | 0x11);
//			*(pDat+29) = (UCHAR)(((dts & 0x3FC00000) >> 22) | 0x00);
//			*(pDat+30) = (UCHAR)(((dts & 0x003F8000) >> 14) | 0x01);
//			*(pDat+31) = (UCHAR)(((dts & 0x00007F80) >>  7) | 0x00);
//			*(pDat+32) = (UCHAR)(((dts & 0x0000007F) <<  1) | 0x01);
//		}

//		if (pts!=0) {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(V) 0x%04lX\r\n", pts) );
//		}
//		else {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(V) ******\r\n") );
//		}
	}
	else if (*(pDat+17)==0xBD && (*(pDat+(*(pDat+22)+23)) & 0xF8)==0x80) {
//		if (pts!=0) {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(A) 0x%04lX\r\n", pts) );
//		}
//		else {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(A) ******\r\n") );
//		}
	}
	else if (*(pDat+17)==0xBD && (*(pDat+(*(pDat+22)+23)) & 0xE0)==0x20) {
//		if (pts!=0) {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(S) 0x%04lX\r\n", pts) );
//		}
//		else {
//			DebugPrint( (DebugLevelTrace, "DVDTS:  PTS(S) ******\r\n") );
//		}
	}
	else if (*(pDat+17)==0xBD && (*(pDat+(*(pDat+22)+23)) & 0xF8)==0xA0) {
	}
	else {
		DebugPrint( (DebugLevelTrace, "DVDTS:  unexpected ID(%02X)  "/*\r\n"*/, *(pDat+17) ) );
		pts = 0xFFFFFFFF;
		DebugPrint( (DebugLevelTrace, "--> %02X %02X %02X %02X\r\n", *(pDat+0), *(pDat+1), *(pDat+2), *(pDat+3) ));
	}
	return(pts);
}

//---

DWORD	GetStreamID(void *pBuf)
{
	PUCHAR  pDat = (PUCHAR)pBuf;
	UCHAR	strID;
	UCHAR	subID;

	strID = *(pDat+17);
	// Check Video Stream
	if( strID==0xE0 ) {
		return( (DWORD)strID );
	}
#if 0
	// MPEG Audio
	else if ( (strID & 0x??) == 0x@@ ) {
		return( (DWORD)strID );
	}
#endif
	// Check Private Stream 1 (AC-3/PCM/Subpic)
	else {
		subID = *(pDat+(*(pDat+22)+23));
		return( (DWORD)subID );
	}
}

ULONG GetHowLongWait( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc )
{
	ULONGLONG stc;
	ULONGLONG pts = 0;
	ULONGLONG waitTime = 0;
	PUCHAR pDat;

	if( pStruc->DataUsed ) {
		pDat = (PUCHAR)pStruc->Data;
		if( *(pDat+21) & 0x80 ) { 
			pts += ((ULONGLONG)(*(pDat+23) & 0x0E)) << 29;
			pts += ((ULONGLONG)(*(pDat+24) & 0xFF)) << 22;
			pts += ((ULONGLONG)(*(pDat+25) & 0xFE)) << 14;
			pts += ((ULONGLONG)(*(pDat+26) & 0xFF)) <<  7;
			pts += ((ULONGLONG)(*(pDat+27) & 0xFE)) >>  1;
			stc = (ULONGLONG)decGetVideoSTCA(pHwDevExt);
			DebugPrint( (DebugLevelTrace, "DVDTS:  pts = %lx(90KHz) %ld(100ns dec)\r\n", pts, pts * 1000 / 9) );
			DebugPrint( (DebugLevelTrace, "DVDTS:  stc = %lx(90KHz) %ld(100ns dec)\r\n", stc, stc * 1000 / 9) );
			if( stc < pts && pts - stc > 45000 ) {
				waitTime = (pts - stc - 45000) * 100 / 9;
				if( waitTime > 1000000 ) {
					// Buggy. This is temporary coding for Windows98 beta 3
					decVIDEO_SET_STCA( pHwDevExt, (ULONG)pts );
					DebugPrint( (DebugLevelTrace, "DVDTS:  <<<< Bad Wait Time (%ldms)\r\n", waitTime/1000 ) );
					waitTime = 0;
				}
			}
		}
	}
	return( (ULONG)waitTime );
}

void ScheduledDMAxfer( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ Schedule flag off ++++\r\n" ) );
	if( pHwDevExt->bDMAscheduled == TRUE ) {
		pHwDevExt->bDMAscheduled = FALSE;
		PreDMAxfer( pHwDevExt );
	}
}

void PreDMAxfer( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK pSrb;
	PKSSTREAM_HEADER pStruc;
	ULONG	index;
	BOOLEAN	last;
	BOOLEAN	fDMA0 = FALSE;
	BOOLEAN	fDMA1 = FALSE;
	ULONG	time0 = 0;
	ULONG	time1 = 0;

	if( pHwDevExt->bDMAstop == TRUE ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ bDMAstop == TRUE ++++\r\n" ) );
		return;
	}

	pHwDevExt->fDMA = 0x03;


	if( decGetVideoRunMode( pHwDevExt ) != PLAY_MODE_FAST || pHwDevExt->DecodeStart == FALSE ) {
		if( pHwDevExt->bDMAscheduled == TRUE ) {
			pHwDevExt->bDMAscheduled = FALSE;
		}
		DMAxfer( pHwDevExt );
		return;
	}


	// If called from end of DMA interrupt routine when scheduled, then no operation.
	if( pHwDevExt->bDMAscheduled == TRUE )
		return;

	if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FREEZE )
		return;

	if( pHwDevExt->pSrbDMA0 == NULL ) {
		pSrb = DeviceQueue_refer1st( pHwDevExt, &index, &last );
		if( pSrb != NULL ) {
			fDMA0 = TRUE;
			pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[index];
			time0 = GetHowLongWait( pHwDevExt, pStruc );
		}
		if( pHwDevExt->pSrbDMA1 == NULL ) {
			pSrb = DeviceQueue_refer2nd( pHwDevExt, &index, &last );
			if( pSrb != NULL ) {
				fDMA1 = TRUE;
				pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[index];
				time1 = GetHowLongWait( pHwDevExt, pStruc );
			}
		}
	}
	else if( pHwDevExt->pSrbDMA1 == NULL ) {
		pSrb = DeviceQueue_refer1st( pHwDevExt, &index, &last );
		if( pSrb != NULL ) {
			fDMA1 = TRUE;
			pStruc = &((PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray))[index];
			time1 = GetHowLongWait( pHwDevExt, pStruc );
		}
	}

	// both DMA0 and DMA1 are available
	if( fDMA0 == TRUE && fDMA1 == TRUE ) {
		if( time0 == 0 && time1 == 0 ) {
			DMAxfer( pHwDevExt );
		}
		else if( time0 == 0 ) {
			pHwDevExt->fDMA = 0x01;
			DMAxfer( pHwDevExt );
			// Scheduling
			DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ Scheduling ++++\r\n" ) );
			DebugPrint( (DebugLevelTrace, "DVDTS:  time1 = %x\r\n", time1 ) );
			pHwDevExt->bDMAscheduled = TRUE;
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				time1,
				(PHW_TIMER_ROUTINE)ScheduledDMAxfer,
				pHwDevExt
			);
		}
		else {
			// Scheduling
			DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ Scheduling ++++\r\n" ) );
			DebugPrint( (DebugLevelTrace, "DVDTS:  time0 = %x\r\n", time0 ) );
			pHwDevExt->bDMAscheduled = TRUE;
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				time0,
				(PHW_TIMER_ROUTINE)ScheduledDMAxfer,
				pHwDevExt
			);
		}
	}
	// only DMA0 is available
	else if( fDMA0 == TRUE ) {
		if( time0 == 0 ) {
			DMAxfer( pHwDevExt );
		}
		else {
			// Scheduling
			DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ Scheduling ++++\r\n" ) );
			DebugPrint( (DebugLevelTrace, "DVDTS:  time0 = %x\r\n", time0 ) );
			pHwDevExt->bDMAscheduled = TRUE;
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				time0,
				(PHW_TIMER_ROUTINE)ScheduledDMAxfer,
				pHwDevExt
			);
		}
	}
	// only DMA1 is available
	else if( fDMA1 == TRUE ) {
		if( time1 == 0 ) {
			DMAxfer( pHwDevExt );
		}
		else {
			// Scheduling
			DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ Scheduling ++++\r\n" ) );
			DebugPrint( (DebugLevelTrace, "DVDTS:  time1 = %x\r\n", time1 ) );
			pHwDevExt->bDMAscheduled = TRUE;
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				time1,
				(PHW_TIMER_ROUTINE)ScheduledDMAxfer,
				pHwDevExt
			);
		}
	}
	else {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  ++++++ No Data in queue (PreDMAxfer) ++++++\r\n" ) );
	}
}

void DMAxfer( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG	addr;
	ULONG	vbuffsize;
	ULONG	index0, index1;
	PUCHAR ioBase = pHwDevExt->ioBaseLocal;
	BOOL fDMA0 = FALSE;
	BOOL fDMA1 = FALSE;
	UCHAR fDMA;

	// SCR discontinue test
	PKSSTREAM_HEADER pStruc;
//	unsigned char	*p;
	DWORD dwTMP;
	DWORD dwPTS = 0;
	BOOL TimeValid = FALSE;

	if( (fDMA = pHwDevExt->fDMA) == 0 )
		return;

	if( !pHwDevExt->SendFirst ) {
		fProgrammed = FALSE;
		pHwDevExt->bSTCvalid = FALSE;
	}

	if( pHwDevExt->pSrbDMA0 == NULL && (fDMA & 0x01) ) {
		pHwDevExt->pSrbDMA0 = DeviceQueue_get( pHwDevExt, &index0, &(pHwDevExt->fSrbDMA0last) );
		if( pHwDevExt->pSrbDMA0 == NULL ) {
			pHwDevExt->fSrbDMA0last = FALSE;
			DebugPrint( (DebugLevelVerbose, "DVDTS:  pHwDevExt->pSrbDMA0 == NULL\r\n") );
		}
		else {
			ULONG	index;
			fDMA0 = TRUE;

			index = index0;
			// debug
			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(DmaXfer0) srb = 0x%x, %d\r\n", pHwDevExt->pSrbDMA0, pHwDevExt->fSrbDMA0last ));
			}

			if( pHwDevExt->pSrbDMA0->NumberOfBuffers != pHwDevExt->pSrbDMA0->NumberOfPhysicalPages )
				index++;
			pStruc = &((PKSSTREAM_HEADER)(pHwDevExt->pSrbDMA0->CommandData.DataBufferArray))[index];
			SetAudioID( pHwDevExt, pStruc );
//--- Change DTS ---//
//xunGetPTS( (PUCHAR)pStruc->Data );
//------------------//
			if( !pHwDevExt->DecodeStart ) {
				if( !(pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG) && !pHwDevExt->bSTCvalid ) {
					dwPTS = pHwDevExt->dwSTCtemp;
					TimeValid = TRUE;
					DebugPrint( (DebugLevelTrace, "DVDTS:  <---- Underflow STC ---->\r\n") );
				}
				else if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID ) {
					if( TimeValid==FALSE ) {
						dwPTS = ConvertStrmtoPTS( pStruc->PresentationTime.Time );
					}
					else {
						dwTMP = ConvertStrmtoPTS( pStruc->PresentationTime.Time );
						dwPTS = (dwPTS>dwTMP) ? dwTMP : dwPTS;
					}
					TimeValid = TRUE;
				}
			}
		}
	}

	if( pHwDevExt->pSrbDMA1 == NULL && (fDMA & 0x02) ) {
		pHwDevExt->pSrbDMA1 = DeviceQueue_get( pHwDevExt, &index1, &(pHwDevExt->fSrbDMA1last) );
		if( pHwDevExt->pSrbDMA1 == NULL ) {
			pHwDevExt->fSrbDMA1last = FALSE;
			DebugPrint( (DebugLevelVerbose, "DVDTS:  pHwDevExt->pSrbDMA1 == NULL\r\n") );
		}
		else {
			ULONG	index;
			// debug
			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(DmaXfer1) srb = 0x%x, %d\r\n", pHwDevExt->pSrbDMA1, pHwDevExt->fSrbDMA1last ));
			}

			fDMA1 = TRUE;

			index = index1;
			if( pHwDevExt->pSrbDMA1->NumberOfBuffers != pHwDevExt->pSrbDMA1->NumberOfPhysicalPages )
				index++;
			pStruc = &((PKSSTREAM_HEADER)(pHwDevExt->pSrbDMA1->CommandData.DataBufferArray))[index];
			SetAudioID( pHwDevExt, pStruc );
//--- Change DTS ---//
//xunGetPTS( (PUCHAR)pStruc->Data );
//------------------//
			if( !pHwDevExt->DecodeStart ) {
				if( !(pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG) && !pHwDevExt->bSTCvalid ) {
					dwPTS = pHwDevExt->dwSTCtemp;
					TimeValid = TRUE;
					DebugPrint( (DebugLevelTrace, "DVDTS:  <---- Underflow STC ---->\r\n") );
				}
				else if( pStruc->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID ) {
					if( TimeValid==FALSE ) {
						dwPTS = ConvertStrmtoPTS( pStruc->PresentationTime.Time );
					}
					else {
						dwTMP = ConvertStrmtoPTS( pStruc->PresentationTime.Time );
						dwPTS = (dwPTS>dwTMP) ? dwTMP : dwPTS;
					}
					TimeValid = TRUE;
				}
			}
		}
	}

	if( !fDMA0 && !fDMA1 ) {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  ++++ No Data in Queue (DMAxfer) ++++\r\n") );
		return;
	}

	if( pHwDevExt->SendFirst && !pHwDevExt->DecodeStart ) {

		if( TimeValid && pHwDevExt->bSTCvalid == FALSE ) {
			pHwDevExt->bSTCvalid = TRUE;
			pHwDevExt->dwSTCInit = dwPTS;
		}

		if( TimeValid && pHwDevExt->dwSTCInit > dwPTS ) {
			DebugPrint( (DebugLevelTrace, "DVDTS:  %lx --> %lx\r\n", pHwDevExt->dwSTCInit, dwPTS ) );
			pHwDevExt->dwSTCInit = dwPTS;
		}

		vbuffsize = decVIDEO_GET_STD_CODE(pHwDevExt);

		if( vbuffsize > 250000 ) {
			DWORD ct = GetCurrentTime_ms();
			DebugPrint(( DebugLevelTrace, "DVDTS:VBuff Size %d ( %dms )\r\n", vbuffsize, ct - pHwDevExt->SendFirstTime ));

			if( pHwDevExt->bSTCvalid == FALSE ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:  Use old STC in Decode Start %lx --> %lx\r\n", pHwDevExt->dwSTCInit, pHwDevExt->dwSTCtemp ) );
				pHwDevExt->dwSTCInit = pHwDevExt->dwSTCtemp;
			}
			DecodeStart( pHwDevExt, pHwDevExt->dwSTCInit );
		}
	}

	if( ! pHwDevExt->SendFirst ) {

		DebugPrint( (DebugLevelTrace, "DVDTS:Send First\r\n" ) );

		pHwDevExt->bSTCvalid = TimeValid;
		if( pHwDevExt->bSTCvalid==FALSE ) {
			DebugPrint( (DebugLevelTrace, "DVDTS:  <-------- PTS as STC is invalid in SendFirst -------->\r\n" ) );
		}
		decInitMPEG( pHwDevExt, dwPTS );
		pHwDevExt->SendFirst = TRUE;
		pHwDevExt->dwSTCInit = dwPTS;

		StreamClassScheduleTimer(
			pHwDevExt->pstroVid,
			pHwDevExt,
			3000000,
			(PHW_TIMER_ROUTINE)TimerDecodeStart,
			pHwDevExt
			);

		fProgrammed = TRUE;

		pHwDevExt->SendFirstTime = GetCurrentTime_ms();
	}

	if( fDMA0 ) {
//		DebugDumpPackHeader( pHwDevExt->pSrbDMA0 );
//		DebugDumpWriteData( pHwDevExt->pSrbDMA0 );

		addr = (ULONG)( pHwDevExt->pSrbDMA0->ScatterGatherBuffer[index0].PhysicalAddress.LowPart );
		decSetDma0Addr( pHwDevExt, addr );

		ASSERT( ( pHwDevExt->pSrbDMA0->ScatterGatherBuffer[index0].Length & 0x7ff ) == 0 );

		decSetDma0Size( pHwDevExt, pHwDevExt->pSrbDMA0->ScatterGatherBuffer[index0].Length );

		decSetDma0Start(pHwDevExt);

		DebugPrint(( DebugLevelVerbose, "DVDTS:DMA0 start! srb = 0x%x\r\n", pHwDevExt->pSrbDMA0 ));
	}
	if( fDMA1 ) {
//		DebugDumpPackHeader( pHwDevExt->pSrbDMA1 );
//		DebugDumpWriteData( pHwDevExt->pSrbDMA1 );

		addr = (ULONG)( pHwDevExt->pSrbDMA1->ScatterGatherBuffer[index1].PhysicalAddress.LowPart );
		decSetDma1Addr( pHwDevExt, addr );

		ASSERT( ( pHwDevExt->pSrbDMA1->ScatterGatherBuffer[index1].Length & 0x7ff ) == 0 );

		decSetDma1Size( pHwDevExt, pHwDevExt->pSrbDMA1->ScatterGatherBuffer[index1].Length );

		decSetDma1Start(pHwDevExt);

		DebugPrint(( DebugLevelVerbose, "DVDTS:DMA1 start! srb = 0x%x\r\n", pHwDevExt->pSrbDMA1 ));
	}
}

void DMAxferKeyData( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb, PUCHAR addr, DWORD dwSize, PHW_TIMER_ROUTINE pfnCallBack )
{
	PHYSICAL_ADDRESS	phyadd;

	DebugPrint( (DebugLevelTrace, "DVDTS:DMAxferKeyData\r\n" ) );

	ASSERT( pHwDevExt->pSrbDMA0 == NULL && pHwDevExt->pSrbDMA1 == NULL );

	// must be wait underflow!

	// SendFirst
	decStopData( pHwDevExt, TRUE );
	decInitMPEG( pHwDevExt, 0 );

	RtlCopyMemory(pHwDevExt->pDmaBuf,
					addr,
					dwSize);

	phyadd = pHwDevExt->addr;

	decSetDma0Addr( pHwDevExt, phyadd.LowPart );
	decSetDma0Size( pHwDevExt, dwSize );
	decSetDma0Start(pHwDevExt);

	pHwDevExt->bKeyDataXfer = TRUE;
	pHwDevExt->pSrbDMA0 = pSrb;
	pHwDevExt->pfnEndKeyData = pfnCallBack;

	pSrb->Status = STATUS_PENDING; // add by seichan 1997/07/10
	return;
}

void EndKeyData( PHW_DEVICE_EXTENSION pHwDevExt )
{
	BOOLEAN	bStatus;

	DebugPrint( (DebugLevelTrace, "DVDTS:EndKeyData\r\n" ) );

	pHwDevExt->bKeyDataXfer = FALSE;

	bStatus = decCpp_DiscKeyEnd(pHwDevExt);

	ASSERTMSG( "\r\n...CPro Status Error!!( DiscKeyEnd )", bStatus );

	pHwDevExt->pSrbDMA0->Status = STATUS_SUCCESS;

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pHwDevExt->pSrbDMA0->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pHwDevExt->pSrbDMA0->StreamObject,
									pHwDevExt->pSrbDMA0 );

	pHwDevExt->pSrbDMA0 = NULL;

	pHwDevExt->XferStartCount = 0;
	pHwDevExt->DecodeStart = FALSE;
	pHwDevExt->SendFirst = FALSE;

	StreamClassScheduleTimer(
		pHwDevExt->pstroVid,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)TimerDecodeStart,
		pHwDevExt
		);

	return;
}



void MenuDecodeStart( PHW_DEVICE_EXTENSION pHwDevExt )
{
	// if no data exists in queue,
	if( DeviceQueue_isEmpty( pHwDevExt )==TRUE ) {
		// if DMA transfer dosen't finish, wait.
		if( pHwDevExt->pSrbDMA0 != NULL || pHwDevExt->pSrbDMA1 != NULL ) {
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				100000,
				(PHW_TIMER_ROUTINE)MenuDecodeStart,
				pHwDevExt
			);
			DebugPrint( (DebugLevelTrace, "DVDTS:Schedule MenuDecodeStart(1)\r\n" ) );
			return;
		}
	}
	// if data exist in queue, wait.
	else {
		StreamClassScheduleTimer(
			NULL,
			pHwDevExt,
			100000,
			(PHW_TIMER_ROUTINE)MenuDecodeStart,
			pHwDevExt
		);
		DebugPrint( (DebugLevelTrace, "DVDTS:Schedule MenuDecodeStart(2)\r\n" ) );
		return;
	}
//--- for Debug
	{
		ULONG vbuffsize = decVIDEO_GET_STD_CODE( pHwDevExt );
		DWORD ct = GetCurrentTime_ms();
		DebugPrint(( DebugLevelTrace, "DVDTS:MenuDecodeStart\r\n" ));
		DebugPrint(( DebugLevelTrace, "DVDTS:  VBuff Size %d ( %dms )\r\n", vbuffsize, ct - pHwDevExt->SendFirstTime ));
	}
//---
//--- End.
	pHwDevExt->fCauseOfStop = 0x01;
	if( pHwDevExt->DecodeStart == FALSE ) {
		DecodeStart( pHwDevExt, pHwDevExt->dwSTCInit );
	}
}
//--- End.

void DecodeStart( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:Decode Start\r\n" ));
	DebugPrint(( DebugLevelTrace, "DVDTS:  STC 0x%x( 0x%s(100ns) )\r\n", dwSTC, DebugLLConvtoStr( ConvertPTStoStrm(dwSTC), 16 ) ));

	if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_NORMAL ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  PlayMode = PLAY_MODE_NORMAL\r\n") );

		decDecodeStartNormal(  pHwDevExt,  dwSTC );


		StreamClassScheduleTimer(
			NULL,
			pHwDevExt,
			1,
			(PHW_TIMER_ROUTINE)TimerAudioMuteOff,
			pHwDevExt
			);
	} // end play normal

	else if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST ) {

		DebugPrint( (DebugLevelTrace, "DVDTS:  PlayMode = PLAY_MODE_FAST\r\n") );

		decDecodeStartFast(  pHwDevExt,  dwSTC );
	} // end play mode fast

	else if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_SLOW ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  PlayMode = PLAY_MODE_SLOW\r\n") );

		decDecodeStartSlow(  pHwDevExt,  dwSTC );

	} // end play mode slow

	else if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FREEZE ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:  PlayMode = PLAY_MODE_FREEZE\r\n") );
	}

	else {
		DebugPrint( (DebugLevelTrace, "DVDTS:  PlayMode = PLAY_MODE_??????\r\n") );
	}

		ClearDataDiscontinuity( pHwDevExt );
		ClearTimeDiscontinuity( pHwDevExt );
		pHwDevExt->DecodeStart = TRUE;

	StreamClassScheduleTimer(
		pHwDevExt->pstroVid,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)TimerDecodeStart,
		pHwDevExt
		);
}

void TimerDecodeStart( PHW_DEVICE_EXTENSION pHwDevExt )
{

	ULONG vbuffsize = decVIDEO_GET_STD_CODE( pHwDevExt );
	DWORD ct = GetCurrentTime_ms();

	DebugPrint(( DebugLevelTrace, "DVDTS:TimerDecodeStart()\r\n" ));

	DebugPrint(( DebugLevelTrace, "DVDTS:  VBuff Size %d ( %dms )\r\n", vbuffsize, ct - pHwDevExt->SendFirstTime ));

// Temporary
	if( vbuffsize > 0 )
		DecodeStart( pHwDevExt, pHwDevExt->dwSTCInit );
	else
		pHwDevExt->SendFirst = FALSE;
}

VOID TimerAudioMuteOff( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG Diff, VStc;

	DebugPrint( (DebugLevelTrace, "DVDTS:TimerAudioCheck\r\n") );

	if( !pHwDevExt->DecodeStart ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  Timer cancel\r\n" ));
		return;
	}

	decAUDIO_ZR38521_STAT( pHwDevExt, &Diff );
	if( (Diff > 0xfb50) || (Diff < 0x01e0) ) {
		decAUDIO_ZR38521_MUTE_OFF( pHwDevExt );
		DebugPrint(( DebugLevelTrace, "DVDTS:  Audio Mute Off\r\n" ));
	}
	else {
		VStc = decGetVideoSTCA( pHwDevExt );
		decAUDIO_ZR38521_VDSCR_ON( pHwDevExt, VStc );

		StreamClassScheduleTimer(
			NULL,
			pHwDevExt,
			120000,
			(PHW_TIMER_ROUTINE)TimerAudioMuteOff,
			pHwDevExt
			);
	}
}


// Property

void GetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetVideoProperty 0\r\n") );
		TRAP;

		pSrb->Status = STATUS_SUCCESS;
		break;

	  case 1:
		GetCppProperty( pSrb, strmVideo );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetVideoProperty 2\r\n") );
		GetVideoRateChange( pSrb );
		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetVideoProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		pSrb->Status = STATUS_SUCCESS;
		break;
	}
}

void SetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetVideoProperty 0\r\n") );
		TRAP;

		pSrb->Status = STATUS_SUCCESS;
		break;

	  case 1:
		SetCppProperty( pSrb );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetVideoProperty 2\r\n") );
		SetVideoRateChange( pSrb );
		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetVideoProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		pSrb->Status = STATUS_SUCCESS;
		break;
	}
}

ULONG audiodecoutmode = KSAUDDECOUTMODE_STEREO_ANALOG;

void GetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetAudioProperty\r\n") );

		pSrb->Status = STATUS_SUCCESS;

		switch(pSrb->CommandData.PropertyInfo->Property->Id) {
		  case KSPROPERTY_AUDDECOUT_MODES:
			*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) =
				KSAUDDECOUTMODE_STEREO_ANALOG | KSAUDDECOUTMODE_SPDIFF;
			break;

		  case KSPROPERTY_AUDDECOUT_CUR_MODE:
			*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) = audiodecoutmode;
			break;

		  default:
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
		}
		break;

	  case 1:
		GetCppProperty( pSrb, strmAudio );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetAudioProperty 2\r\n") );
		GetAudioRateChange( pSrb );
		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetAudioProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		pSrb->Status = STATUS_SUCCESS;
		break;
	}
}

void SetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetAudioProperty\r\n") );

		pSrb->Status = STATUS_SUCCESS;

		switch(pSrb->CommandData.PropertyInfo->Property->Id) {
		  case KSPROPERTY_AUDDECOUT_CUR_MODE:
			if ((*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo)) &
				(!(KSAUDDECOUTMODE_STEREO_ANALOG | KSAUDDECOUTMODE_SPDIFF)))
			{
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;
			}

//			HwCodecAc3BypassMode(*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) &
//				 KSAUDDECOUTMODE_SPDIFF);

			audiodecoutmode = *(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo);
			break;

		  default:
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
		}
		break;

	  case 1:
		SetCppProperty( pSrb );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetAudioProperty 2\r\n") );
		SetAudioRateChange( pSrb );
		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetAudioProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		pSrb->Status = STATUS_SUCCESS;
		break;
	}
}

void GetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetSubpicProperty\r\n") );
		TRAP;

		pSrb->Status = STATUS_SUCCESS;
		break;

	  case 1:
		GetCppProperty( pSrb, strmSubpicture );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetSubpicProperty 2\r\n") );
		GetSubpicRateChange( pSrb );
		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    GetSubpicProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		pSrb->Status = STATUS_SUCCESS;
		break;
	}
}

void SetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	pSrb->Status = STATUS_SUCCESS;

	switch ( pSrb->CommandData.PropertyInfo->PropertySetID ) {
	  case 0:
		switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  	  case KSPROPERTY_DVDSUBPIC_PALETTE:
			{

			PKSPROPERTY_SPPAL ppal;
			UCHAR paldata[48];
			int i;

			DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_DVDSUBPIC_PALETTE\r\n") );

			ppal = (PKSPROPERTY_SPPAL)pSrb->CommandData.PropertyInfo->PropertyInfo;
			for( i = 0; i < 16; i++ ) {
				paldata[i*3+0] = ppal->sppal[i].Y;
				paldata[i*3+1] = ppal->sppal[i].U;	// -> Cb
				paldata[i*3+2] = ppal->sppal[i].V;	// -> Cr
			}

			decVPRO_SUBP_PALETTE( pHwDevExt, paldata );
			decCGuard_CPGD_SUBP_PALETTE( pHwDevExt, paldata );

			}
			break;

	  	  case KSPROPERTY_DVDSUBPIC_HLI:
			{
//h			DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_DVDSUBPIC_HLI\r\n") );

			PKSPROPERTY_SPHLI	phli;
			phli = (PKSPROPERTY_SPHLI)pSrb->CommandData.PropertyInfo->PropertyInfo;

			pHwDevExt->hli = *phli;

			decHighlight( pHwDevExt, phli );

			}
			break;

	  	  case KSPROPERTY_DVDSUBPIC_COMPOSIT_ON:
//			DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_DVDSUBPIC_COMPOSIT_ON\r\n") );

			if( *((PKSPROPERTY_COMPOSIT_ON)pSrb->CommandData.PropertyInfo->PropertyInfo )) {
				DebugPrint(( DebugLevelTrace, "DVDTS:    COMPOSIT_ON\r\n" ));
				decSetSubpicMute(  pHwDevExt, FALSE );
			}
			else {
				DebugPrint(( DebugLevelTrace, "DVDTS:    COMPOSIT_OFF\r\n" ));
				decSetSubpicMute(  pHwDevExt, TRUE );
			}
			break;

	  	  default:
			DebugPrint( (DebugLevelTrace, "DVDTS:    PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
			TRAP;
			break;
		}
		break;

	  case 1:
		SetCppProperty( pSrb );
		break;

	  case 2:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetSubpicProperty 2\r\n") );
		SetSubpicRateChange( pSrb );
		break;
//--- End.

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    SetVideoProperty-default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->PropertySetID, pSrb->CommandData.PropertyInfo->PropertySetID ) );
		TRAP;
		break;
	}
}

void GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
	DWORD dwNumConnectInfo = 2;
	DWORD dwNumVideoFormat = 1;
	DWORD dwFieldWidth = 720;
	DWORD dwFieldHeight = 240;

	// the pointers to which the input buffer will be cast to
	LPDDVIDEOPORTCONNECT pConnectInfo;
	LPDDPIXELFORMAT pVideoFormat;
	PKSVPMAXPIXELRATE pMaxPixelRate;
	PKS_AMVPDATAINFO pVpdata;

	// LPAMSCALINGINFO pScaleFactor;

	//
	// NOTE:  ABSOLUTELY DO NOT use pmulitem, until it is determined that
	// the stream property descriptor describes a multiple item, or you will
	// pagefault.
	//

	PKSMULTIPLE_ITEM  pmulitem =
		&(((PKSMULTIPLE_DATA_PROP)pSrb->CommandData.PropertyInfo->Property)->MultipleItem);

	//
	// NOTE: same goes for this one as above.
	//

	PKS_AMVPSIZE pdim = 
		&(((PKSVPSIZE_PROP)pSrb->CommandData.PropertyInfo->Property)->Size);

	if( pSrb->CommandData.PropertyInfo->PropertySetID ) {
		TRAP;
		pSrb->Status = STATUS_NO_MATCH;
		return;
	}

	dwInputBufferSize = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;

	pSrb->Status = STATUS_SUCCESS;

	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  case KSPROPERTY_VPCONFIG_NUMCONNECTINFO:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_NUMCONNECTINFO\r\n") );

		// check that the size of the output buffer is correct
		ASSERT(dwInputBufferSize >= sizeof(DWORD));

		pSrb->ActualBytesTransferred = sizeof(DWORD);

		*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
					= dwNumConnectInfo;
		break;

	  case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT\r\n") );

		// check that the size of the output buffer is correct
		ASSERT(dwInputBufferSize >= sizeof(DWORD));

		pSrb->ActualBytesTransferred = sizeof(DWORD);

		*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
				= dwNumVideoFormat;

		break;

	  case KSPROPERTY_VPCONFIG_GETCONNECTINFO:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_GETCONNECTINFO\r\n") );

		if (pmulitem->Count > dwNumConnectInfo ||
			pmulitem->Size != sizeof (DDVIDEOPORTCONNECT) ||
			dwOutputBufferSize < 
			(pmulitem->Count * sizeof (DDVIDEOPORTCONNECT)))

		{
			DebugPrint(( DebugLevelTrace, "DVDTS:      pmulitem->Count %d\r\n", pmulitem->Count ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      pmulitem->Size %d\r\n", pmulitem->Size ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      dwOutputBufferSize %d\r\n", dwOutputBufferSize ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      sizeof(DDVIDEOPORTCONNECT) %d\r\n", sizeof(DDVIDEOPORTCONNECT) ));

			TRAP;

			//
			// buffer size is invalid, so error the call
			//

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}


		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDVIDEOPORTCONNECT);

		pConnectInfo = (LPDDVIDEOPORTCONNECT)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		// S3
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_S3Guid;
		pConnectInfo->dwFlags = 0x3F;
		pConnectInfo->dwReserved1 = 0;

		pConnectInfo++;

		// ATI
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;

		break;

	  case KSPROPERTY_VPCONFIG_VPDATAINFO:
		DebugPrint(( DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_VPDATAINFO\r\n" ));

		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);

		//
		// cast the buffer to the porper type
		//
		pVpdata = (PKS_AMVPDATAINFO)pSrb->CommandData.PropertyInfo->PropertyInfo;

		*pVpdata = pHwDevExt->VPFmt;
		pVpdata->dwSize = sizeof (KS_AMVPDATAINFO);

		pVpdata->dwMicrosecondsPerField	= 17;

		ASSERT( pVpdata->dwNumLinesInVREF == 0 );

		pVpdata->dwNumLinesInVREF		= 0;

		if( decGetVideoPort( pHwDevExt ) == 4 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:      Set for S3 LPB\r\n" ));
			// S3 LPB
			pVpdata->bEnableDoubleClock		= FALSE;
			pVpdata->bEnableVACT			= FALSE;
			pVpdata->bDataIsInterlaced		= TRUE;
			pVpdata->lHalfLinesOdd  		= 0;
			pVpdata->lHalfLinesEven  		= 0;
			pVpdata->bFieldPolarityInverted	= FALSE;

			pVpdata->amvpDimInfo.dwFieldWidth	= 720 + 158/2;
			pVpdata->amvpDimInfo.dwFieldHeight	= 240 + 1;

			pVpdata->amvpDimInfo.rcValidRegion.left		= 158/2;
			pVpdata->amvpDimInfo.rcValidRegion.top		= 1;
			pVpdata->amvpDimInfo.rcValidRegion.right	= 720 + 158/2 - 4;
			pVpdata->amvpDimInfo.rcValidRegion.bottom	= 240 + 1;

            pVpdata->amvpDimInfo.dwVBIWidth     = pVpdata->amvpDimInfo.dwFieldWidth;
			pVpdata->amvpDimInfo.dwVBIHeight    = pVpdata->amvpDimInfo.rcValidRegion.top;
		}
		else if( decGetVideoPort( pHwDevExt ) == 7 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:      Set for ATI AMC\r\n" ));
			// ATI AMC
			pVpdata->bEnableDoubleClock		= FALSE;
			pVpdata->bEnableVACT			= FALSE;
			pVpdata->bDataIsInterlaced		= TRUE;
			pVpdata->lHalfLinesOdd  		= 1;
			pVpdata->lHalfLinesEven  		= 0;
			pVpdata->bFieldPolarityInverted	= FALSE;

			pVpdata->amvpDimInfo.dwFieldWidth	= 720;
			pVpdata->amvpDimInfo.dwFieldHeight	= 240 + 2;

			pVpdata->amvpDimInfo.rcValidRegion.left		= 0;
			pVpdata->amvpDimInfo.rcValidRegion.top		= 2;
			pVpdata->amvpDimInfo.rcValidRegion.right	= 720 - 8;
			pVpdata->amvpDimInfo.rcValidRegion.bottom	= 240 + 2;

            pVpdata->amvpDimInfo.dwVBIWidth     = pVpdata->amvpDimInfo.dwFieldWidth;
			pVpdata->amvpDimInfo.dwVBIHeight    = pVpdata->amvpDimInfo.rcValidRegion.top;
		}
		else
			TRAP;

		break ;

	  case KSPROPERTY_VPCONFIG_MAXPIXELRATE:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_MAXPIXELRATE\r\n") );

		//
		// NOTE:
		// this property is special.  And has another different
		// input property!
		//

		if (dwInputBufferSize < sizeof (KSVPSIZE_PROP))
		{
			TRAP;

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}

		pSrb->ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);

		// cast the buffer to the porper type
		pMaxPixelRate = (PKSVPMAXPIXELRATE)pSrb->CommandData.PropertyInfo->PropertyInfo;

		// tell the app that the pixel rate is valid for these dimensions
		pMaxPixelRate->Size.dwWidth  	= dwFieldWidth;
		pMaxPixelRate->Size.dwHeight 	= dwFieldHeight;
		pMaxPixelRate->MaxPixelsPerSecond	= 1300;

		break;

	  case KSPROPERTY_VPCONFIG_INFORMVPINPUT:

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break ;

	  case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT:
		DebugPrint(( DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_GETVIDEOFORMAT\r\n" ));

		//
		// check that the size of the output buffer is correct
		//

		if (pmulitem->Count > dwNumConnectInfo ||
			pmulitem->Size != sizeof (DDPIXELFORMAT) ||
			dwOutputBufferSize < 
			(pmulitem->Count * sizeof (DDPIXELFORMAT)))

		{
			DebugPrint(( DebugLevelTrace, "DVDTS:      pmulitem->Count %d\r\n", pmulitem->Count ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      pmulitem->Size %d\r\n", pmulitem->Size ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      dwOutputBufferSize %d\r\n", dwOutputBufferSize ));
			DebugPrint(( DebugLevelTrace, "DVDTS:      sizeof(DDPIXELFORMAT) %d\r\n", sizeof(DDPIXELFORMAT) ));

			TRAP;

			//
			// buffer size is invalid, so error the call
			//

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}


		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDPIXELFORMAT);

		pVideoFormat = (LPDDPIXELFORMAT)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		if( decGetVideoPort( pHwDevExt ) == 4 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:      Set for S3 LPB\r\n" ));
			// S3 LPB
			pVideoFormat->dwSize= sizeof (DDPIXELFORMAT);
			pVideoFormat->dwFlags = DDPF_FOURCC;
			pVideoFormat->dwFourCC = MKFOURCC( 'Y', 'U', 'Y', '2' );
			pVideoFormat->dwYUVBitCount = 16;
		}
		else if( decGetVideoPort( pHwDevExt ) == 7 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:      Set for ATI AMC\r\n" ));
			// ATI AMC
			pVideoFormat->dwSize= sizeof (DDPIXELFORMAT);
			pVideoFormat->dwFlags = DDPF_FOURCC;
			pVideoFormat->dwYUVBitCount = 16;
			pVideoFormat->dwFourCC = MKFOURCC( 'U', 'Y', 'V', 'Y' );
			// Not needed?
			pVideoFormat->dwYBitMask = (DWORD)0xFF00FF00;
			pVideoFormat->dwUBitMask = (DWORD)0x000000FF;
			pVideoFormat->dwVBitMask = (DWORD)0x00FF0000;
		}
		else
			TRAP;

		break;

	  case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY:

		//
		// indicate that we can decimate anything, especially if it's late.
		//

		pSrb->ActualBytesTransferred = sizeof (BOOL);
		*((PBOOL)pSrb->CommandData.PropertyInfo->PropertyInfo) = TRUE;

		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
		TRAP;

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;
	}
}

void SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
	DWORD *lpdwOutputBufferSize;

	ULONG index;

	PKS_AMVPSIZE pDim;

	if( pSrb->CommandData.PropertyInfo->PropertySetID ) {
		TRAP;
		pSrb->Status = STATUS_NO_MATCH;
		return;
	}

	dwInputBufferSize  = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;
	lpdwOutputBufferSize = &(pSrb->ActualBytesTransferred);

	pSrb->Status = STATUS_SUCCESS;

	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  case KSPROPERTY_VPCONFIG_SETCONNECTINFO:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_SETCONNECTINFO\r\n") );

		//
		// pSrb->CommandData.PropertInfo->PropertyInfo
		// points to a ULONG which is an index into the array of
		// connectinfo structs returned to the caller from the
		// Get call to ConnectInfo.
		//
		// Since the sample only supports one connection type right
		// now, we will ensure that the requested index is 0.
		//

		//
		// at this point, we would program the hardware to use
		// the right connection information for the videoport.
		// since we are only supporting one connection, we don't
		// need to do anything, so we will just indicate success
		//

		index = *((ULONG *)(pSrb->CommandData.PropertyInfo->PropertyInfo));

		DebugPrint(( DebugLevelTrace, "DVDTS:      %d\r\n", index ));

		if( index == 0 ) {
			decSetVideoPort( pHwDevExt , 4);	// S3 LPB
		}
		else if( index == 1 ) {
			decSetVideoPort( pHwDevExt ,7);	// ATI AMC
		}
		else
			TRAP;

		break;

	  case KSPROPERTY_VPCONFIG_DDRAWHANDLE:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_DDRAWHANDLE\r\n") );

		pHwDevExt->ddrawHandle =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_VIDEOPORTID:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_VIDEOPORTID\r\n") );

		pHwDevExt->VidPortID =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE\r\n") );

		pHwDevExt->SurfaceHandle =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT:
		DebugPrint(( DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_SETVIDEOFORMAT\r\n" ));

		//
		// pSrb->CommandData.PropertInfo->PropertyInfo
		// points to a ULONG which is an index into the array of
		// VIDEOFORMAT structs returned to the caller from the
		// Get call to FORMATINFO
		//
		// Since the sample only supports one FORMAT type right
		// now, we will ensure that the requested index is 0.
		//

		//
		// at this point, we would program the hardware to use
		// the right connection information for the videoport.
		// since we are only supporting one connection, we don't
		// need to do anything, so we will just indicate success
		//

		index = *((ULONG *)(pSrb->CommandData.PropertyInfo->PropertyInfo));

		DebugPrint(( DebugLevelTrace, "DVDTS:      %d\r\n", index ));

		break;

	  case KSPROPERTY_VPCONFIG_INFORMVPINPUT:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_INFORMVPINPUT\r\n") );

		//
		// These are the preferred formats for the VPE client
		//
		// they are multiple properties passed in, return success
		//

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;

	  case KSPROPERTY_VPCONFIG_INVERTPOLARITY:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_INVERTPOLARITY\r\n") );

		//
		// Toggles the global polarity flag, telling the output
		// of the VPE port to be inverted.  Since this hardware
		// does not support this feature, we will just return
		// success for now, although this should be returning not
		// implemented
		//

		break;

	  case KSPROPERTY_VPCONFIG_SCALEFACTOR:
		DebugPrint( (DebugLevelTrace, "DVDTS:    KSPROPERTY_VPCONFIG_SCALEFACTOR\r\n") );

		//
		// the sizes for the scaling factor are passed in, and the
		// image dimensions should be scaled appropriately
		//

		//
		// if there is a horizontal scaling available, do it here.
		//

		TRAP;

		pDim =(PKS_AMVPSIZE)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  default:
		DebugPrint( (DebugLevelTrace, "DVDTS:    PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
		TRAP;

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;
	}
}

void GetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PKSALLOCATOR_FRAMING pfrm;
	PKSSTATE State;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	if( pSrb->CommandData.PropertyInfo->PropertySetID ) {
		TRAP;
		pSrb->Status = STATUS_NO_MATCH;
		return;
	}

	pfrm = (PKSALLOCATOR_FRAMING)
				pSrb->CommandData.PropertyInfo->PropertyInfo;


	pSrb->Status = STATUS_SUCCESS;

	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
		DebugPrint(( DebugLevelTrace, "DVDTS:    KSPROPERTY_CONNECTION_ALLOCATORFRAMING\r\n" ));

		pfrm->OptionsFlags = 0;
		pfrm->PoolType = NonPagedPool;
		pfrm->Frames = 10;
		pfrm->FrameSize = 200;
		pfrm->FileAlignment = 0;
		pfrm->Reserved = 0;

		pSrb->ActualBytesTransferred = sizeof( KSALLOCATOR_FRAMING );

		break;

	  case KSPROPERTY_CONNECTION_STATE:
		DebugPrint(( DebugLevelTrace, "DVDTS:    KSPROPERTY_CONNECTION_STATE\r\n" ));

		State = (PKSSTATE) pSrb->CommandData.PropertyInfo->PropertyInfo;

		pSrb->ActualBytesTransferred = sizeof( State );

		// A very odd rule:
		// When transitioning from stop to pause, DShow tries to preroll
		// the graph.  Capture sources can't preroll, and indicate this
		// by returning VFW_S_CANT_CUE in user mode.  To indicate this
		// condition from drivers, they must return ERROR_NO_DATA_DETECTED

		*State = ((PSTREAMEX)(pHwDevExt->pstroCC->HwStreamExtension))->state;

		if( ((PSTREAMEX)pHwDevExt->pstroCC->HwStreamExtension)->state == KSSTATE_PAUSE ) {
			//
			// wierd stuff for capture type state change.  When you transition
			// from stop to pause, we need to indicate that this device cannot
			// preroll, and has no data to send.
			//

			pSrb->Status = STATUS_NO_DATA_DETECTED;
		}
		break;

	  default:
		DebugPrint(( DebugLevelTrace, "DVDTS:    PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ));
		TRAP;

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;
	}
}

void SetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	TRAP;
	pSrb->Status = STATUS_NOT_IMPLEMENTED;
	return;
}

void GetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb, LONG strm )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	BOOLEAN	bStatus;
	DWORD *lpdwOutputBufferSize;

	DebugPrint( (DebugLevelTrace, "DVDTS:    GetCppProperty\r\n") );


	lpdwOutputBufferSize = &(pSrb->ActualBytesTransferred);

	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
		case KSPROPERTY_DVDCOPY_CHLG_KEY:
			{
			PKS_DVDCOPY_CHLGKEY pChlgKey;
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_CHLG_KEY\r\n") );


			pChlgKey = (PKS_DVDCOPY_CHLGKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			bStatus = decCpp_decoder_challenge( pHwDevExt, pChlgKey );
			if( !bStatus ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:        CPro Status Error!!\r\n") );
				TRAP;
			}
			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
				pChlgKey->ChlgKey[0], pChlgKey->ChlgKey[1], pChlgKey->ChlgKey[2], pChlgKey->ChlgKey[3], pChlgKey->ChlgKey[4],
				pChlgKey->ChlgKey[5], pChlgKey->ChlgKey[6], pChlgKey->ChlgKey[7], pChlgKey->ChlgKey[8], pChlgKey->ChlgKey[9]
			) );

			*lpdwOutputBufferSize = sizeof(KS_DVDCOPY_CHLGKEY);
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DVD_KEY1:
			{
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DVD_KEY1\r\n") );
			TRAP;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DEC_KEY2:
			{

			PKS_DVDCOPY_BUSKEY pBusKey;
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DEC_KEY2\r\n") );

			pBusKey = (PKS_DVDCOPY_BUSKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			bStatus = decCpp_decoder_bus( pHwDevExt, pBusKey );
			if( !bStatus ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:        CPro Status Error!!\r\n") );
				TRAP;
			}
			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x %02x %02x %02x %02x\r\n",
				pBusKey->BusKey[0], pBusKey->BusKey[1], pBusKey->BusKey[2], pBusKey->BusKey[3], pBusKey->BusKey[4]
			) );

			*lpdwOutputBufferSize = sizeof(KS_DVDCOPY_BUSKEY);
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_TITLE_KEY:
			{
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_TITLE_KEY\r\n") );
			TRAP;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DISC_KEY:
			{
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DISC_KEY\r\n") );
			TRAP;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_SET_COPY_STATE:

			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_SET_COPY_STATE\r\n") );

			if( pHwDevExt->lCPPStrm == -1 || pHwDevExt->lCPPStrm == strm ) {
				pHwDevExt->lCPPStrm = strm;

				DebugPrint(( DebugLevelTrace, "DVDTS:        return REQUIRED\r\n" ));

				((PKS_DVDCOPY_SET_COPY_STATE)(pSrb->CommandData.PropertyInfo->PropertyInfo))->DVDCopyState
					= KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED;
			}
			else {
				DebugPrint(( DebugLevelTrace, "DVDTS:        return NOT REQUIRED\r\n" ));

				((PKS_DVDCOPY_SET_COPY_STATE)(pSrb->CommandData.PropertyInfo->PropertyInfo))->DVDCopyState
					= KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED;
			}

			pSrb->ActualBytesTransferred = sizeof( KS_DVDCOPY_SET_COPY_STATE );
			pSrb->Status = STATUS_SUCCESS;

			break;

//		case KSPROPERTY_DVDCOPY_REGION:
//
//			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_REGION\r\n") );
//
//			//
//			// indicate region 1 for US content
//			//
//
//			((PKS_DVDCOPY_REGION)(pSrb->CommandData.PropertyInfo->PropertyInfo))->RegionData
//				= 0x1;
//
//			pSrb->ActualBytesTransferred = sizeof (KS_DVDCOPY_REGION);
//			pSrb->Status = STATUS_SUCCESS;
//
//			break;

		default:
			{
			DebugPrint( (DebugLevelTrace, "DVDTS:      PropertySetID 1 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
			TRAP;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;
		}
}

void SetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	BOOLEAN	bStatus;

	DebugPrint( (DebugLevelTrace, "DVDTS:    SetCppProperty\r\n") );

	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
		case KSPROPERTY_DVDCOPY_CHLG_KEY:
			{

			PKS_DVDCOPY_CHLGKEY pChlgKey;
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_CHLG_KEY\r\n") );

			pChlgKey = (PKS_DVDCOPY_CHLGKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
				pChlgKey->ChlgKey[0], pChlgKey->ChlgKey[1], pChlgKey->ChlgKey[2], pChlgKey->ChlgKey[3], pChlgKey->ChlgKey[4],
				pChlgKey->ChlgKey[5], pChlgKey->ChlgKey[6], pChlgKey->ChlgKey[7], pChlgKey->ChlgKey[8], pChlgKey->ChlgKey[9]
			) );

			bStatus = decCpp_drive_challenge( pHwDevExt, pChlgKey );

			ASSERTMSG( "\r\n...CPro Status Error!!( drive_challenge )", bStatus );

			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DVD_KEY1:
			{

			PKS_DVDCOPY_BUSKEY pBusKey;

			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DVD_KEY1\r\n") );
			pBusKey = (PKS_DVDCOPY_BUSKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x %02x %02x %02x %02x\r\n",
				pBusKey->BusKey[0], pBusKey->BusKey[1], pBusKey->BusKey[2], pBusKey->BusKey[3], pBusKey->BusKey[4]
			) );

			bStatus = decCpp_drive_bus( pHwDevExt, pBusKey );

			ASSERTMSG( "\r\n...CPro Status Error!!( drive_bus )", bStatus );

			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DEC_KEY2:
			{
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DEC_KEY2\r\n") );
			TRAP;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_TITLE_KEY:
			{

			PKS_DVDCOPY_TITLEKEY pTitleKey;

			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_TITLE_KEY\r\n") );
			pTitleKey = (PKS_DVDCOPY_TITLEKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x, %02x %02x %02x %02x %02x\r\n",
				pTitleKey->KeyFlags, pTitleKey->TitleKey[0], pTitleKey->TitleKey[1], pTitleKey->TitleKey[2], pTitleKey->TitleKey[3], pTitleKey->TitleKey[4]
			) );

			// Set CGMS for Digital Audio Copy Guard & NTSC Analog Copy Guard
			decDvdTitleCopyKey(  pHwDevExt, pTitleKey );
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KSPROPERTY_DVDCOPY_DISC_KEY:
			{

			PKS_DVDCOPY_DISCKEY pDiscKey;
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_DISC_KEY\r\n") );

			pDiscKey = (PKS_DVDCOPY_DISCKEY)pSrb->CommandData.PropertyInfo->PropertyInfo;

			bStatus = decCpp_DiscKeyStart( pHwDevExt );

			ASSERTMSG( "\r\n...CPro Status Error!!( DiscKeyStart )", bStatus );

			DebugPrint( (DebugLevelTrace, "DVDTS:        %02x %02x %02x %02x %02x %02x %02x %02x ...\r\n",
				pDiscKey->DiscKey[0], pDiscKey->DiscKey[1], pDiscKey->DiscKey[2], pDiscKey->DiscKey[3],
				pDiscKey->DiscKey[4], pDiscKey->DiscKey[5], pDiscKey->DiscKey[6], pDiscKey->DiscKey[7]
			) );

			DMAxferKeyData(
				pHwDevExt,
				pSrb,
				pDiscKey->DiscKey,
				2048,
				(PHW_TIMER_ROUTINE)EndKeyData );

			}
			pSrb->Status = STATUS_PENDING;
			break;

		case KSPROPERTY_DVDCOPY_SET_COPY_STATE:
			{

			PKS_DVDCOPY_SET_COPY_STATE pCopyState;
			DebugPrint( (DebugLevelTrace, "DVDTS:      KSPROPERTY_DVDCOPY_SET_COPY_STATE\r\n") );

			pCopyState = (PKS_DVDCOPY_SET_COPY_STATE)pSrb->CommandData.PropertyInfo->PropertyInfo;

			if( pCopyState->DVDCopyState == KS_DVDCOPYSTATE_INITIALIZE ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:        KS_DVDCOPYSTATE_INITIALIZE\r\n") );

				ASSERT( !pHwDevExt->pSrbCpp );

				pHwDevExt->pSrbCpp = pSrb;
				pHwDevExt->bCppReset = TRUE;

				pHwDevExt->CppFlagCount++;
				DebugPrint(( DebugLevelTrace, "DVDTS:  CppFlagCount=%ld\r\n", pHwDevExt->CppFlagCount ));
				if( pHwDevExt->CppFlagCount >= pHwDevExt->cOpenInputStream + 1 )
					SetCppFlag( pHwDevExt );

				pSrb->Status = STATUS_PENDING;
			}
			else if( pCopyState->DVDCopyState == KS_DVDCOPYSTATE_INITIALIZE_TITLE ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:        KS_DVDCOPYSTATE_INITIALIZE_TITLE\r\n" ));

				pHwDevExt->CppFlagCount++;

				if( pHwDevExt->CppFlagCount > pHwDevExt->cOpenInputStream + 1 ) {
					pSrb->Status = STATUS_SUCCESS;
				}
				else {
					ASSERT( !pHwDevExt->pSrbCpp );

					pHwDevExt->pSrbCpp = pSrb;
					pHwDevExt->bCppReset = FALSE;

					DebugPrint(( DebugLevelTrace, "DVDTS:  CppFlagCount=%ld\r\n", pHwDevExt->CppFlagCount ));
					if( pHwDevExt->CppFlagCount >= pHwDevExt->cOpenInputStream + 1 )
						SetCppFlag( pHwDevExt );

					pSrb->Status = STATUS_PENDING;
				}
			}
			else {
				DebugPrint( (DebugLevelTrace, "DVDTS:        DVDCOPYSTATE_DONE\r\n") );

				pHwDevExt->CppFlagCount = 0;

				pSrb->Status = STATUS_SUCCESS;
			}
			}
			break;

		default:
			DebugPrint( (DebugLevelTrace, "DVDTS:      PropertySetID 1 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
			TRAP;
			pSrb->Status = STATUS_SUCCESS;
			break;
		}
}

VOID STREAMAPI StreamClockRtn( IN PHW_TIME_CONTEXT TimeContext )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)TimeContext->HwDeviceExtension;
	ULONGLONG sysTime = GetSystemTime();
	ULONG foo;

//	DebugPrint( (DebugLevelTrace, "DVDTS:StreamClockRtn\r\n") );

	if( TimeContext->Function != TIME_GET_STREAM_TIME ) {
		TRAP;

		//
		// should handle set onboard, and read onboard clock here.
		// 

//		return FALSE;
		return;
	}

	if (fClkPause) {
		if( fProgrammed ) {
			foo = decGetVideoSTCA( pHwDevExt );
			LastStamp = ConvertPTStoStrm( foo );
			if( decGetVideoRunMode( pHwDevExt ) == PLAY_MODE_FAST ) {
				REFERENCE_TIME tmp;
				tmp = (REFERENCE_TIME)pHwDevExt->dwSTCinPause * 1000 / 9;
				if( tmp > pHwDevExt->StartTime ) {
					LastStamp = (tmp - pHwDevExt->StartTime) * 10000/pHwDevExt->Rate + pHwDevExt->StartTime;
				}
			}
			LastSys = LastSysTime = sysTime;
			fValid = TRUE;
		}
		else {
			LastStamp = 0;
			LastSys = LastSysTime = sysTime;
		}

		TimeContext->Time = LastStamp;
		TimeContext->SystemTime = sysTime;

		DebugPrint(( DebugLevelTrace, "DVDTS:Clk pause: 0x%x( 0x%s(100ns) )\r\n", ConvertStrmtoPTS(TimeContext->Time), DebugLLConvtoStr( TimeContext->Time, 16 ) ));

//		return( TRUE );
		return;
	}

	//
	// update the clock 4 times a second, or once every 2500000 100 ns ticks
	//

	if( TRUE || (sysTime - LastSysTime) > 2500000 ) {
		if( fProgrammed ) {
			foo = decGetVideoSTCA( pHwDevExt );
			LastStamp = ConvertPTStoStrm( foo );
			if( decGetVideoRunMode( pHwDevExt ) == PLAY_MODE_FAST ) {
				REFERENCE_TIME tmp;
				tmp = (REFERENCE_TIME)foo * 1000 / 9;
				if( tmp > pHwDevExt->StartTime ) {
					LastStamp = (tmp - pHwDevExt->StartTime) * 10000/pHwDevExt->Rate + pHwDevExt->StartTime;
				}
			}
		}
		else {
			LastStamp = ( sysTime - StartSys );
		}

		LastSys = LastSysTime = sysTime;
		fValid = TRUE;
	}

	TimeContext->Time = LastStamp + ( sysTime - LastSysTime );
	TimeContext->SystemTime = sysTime;
	DebugPrint(( DebugLevelTrace, "DVDTS:Clk      : 0x%x( 0x%s(100ns) )\r\n", ConvertStrmtoPTS(TimeContext->Time), DebugLLConvtoStr( TimeContext->Time, 16 ) ));

	return;
}


ULONGLONG GetSystemTime()
{
	ULONGLONG ticks;
	ULONGLONG rate;

	ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

	//
	// convert from ticks to 100ns clock
	//

	ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
			(ticks & 0xFFFFFFFF) * 10000000 / rate;

	return(ticks);

}

ULONGLONG ConvertPTStoStrm(ULONG pts)
{
	ULONGLONG strm;

	strm = (ULONGLONG)pts;
	strm = ( strm * 10000 + 45 ) / 90;

	return (strm);
}

ULONG ConvertStrmtoPTS(ULONGLONG strm)
{
	ULONGLONG pts;

	pts = ( strm * 9 + 500 ) / 1000;
	return ( (ULONG)pts );
}

void TimerCppReset( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	BOOLEAN	bStatus;
	BOOL bQueStatus = FALSE;

// Temporary
	if( pHwDevExt->pSrbCpp == NULL ) {
		DebugPrint(( DebugLevelTrace, "DVDTS: pSrbCpp is NULL!\r\n" ));
		return;
	}

	if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST || decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_SLOW ) {
		bQueStatus = DeviceQueue_isEmpty( pHwDevExt );
		if( bQueStatus == FALSE ) {
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				100000,
				(PHW_TIMER_ROUTINE)TimerCppReset,
				pSrb
				);
			DebugPrint( (DebugLevelTrace, "DVDTS:Schedule TimerCppReset\r\n") );
			return;
		}
	}
	else if( pHwDevExt->DecodeStart ) {
		StreamClassScheduleTimer(
			NULL,
			pHwDevExt,
			100000,
			(PHW_TIMER_ROUTINE)TimerCppReset,
			pSrb
			);
		DebugPrint( (DebugLevelTrace, "DVDTS:Schedule TimerCppReset\r\n") );
		return;
	}

	DebugPrint( (DebugLevelTrace, "DVDTS:TimerCppReset\r\n") );

	// cpp initialize
	if( pHwDevExt->bCppReset ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:CPro Reset !!!!!!!!!!!! CPro Reset !!!!!!!!!!!! CPro Reset !!!!!!!!!!!!\r\n") );

		bStatus = decCpp_reset( pHwDevExt, GUARD );
		ASSERTMSG( "\r\n...CPro Status Error!!( reset )", bStatus );
	}
	else {	// TitleKey


		// must be wait underflow!

		decStopData( pHwDevExt, TRUE );
		pHwDevExt->XferStartCount = 0;
		pHwDevExt->DecodeStart = FALSE;
		pHwDevExt->SendFirst = FALSE;

		StreamClassScheduleTimer(
			pHwDevExt->pstroVid,
			pHwDevExt,
			0,
			(PHW_TIMER_ROUTINE)TimerDecodeStart,
			pHwDevExt
			);
	}

	pHwDevExt->pSrbCpp = NULL;
	pHwDevExt->bCppReset = FALSE;

	pSrb->Status = STATUS_SUCCESS;

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );

	DebugPrint( (DebugLevelTrace, "DVDTS:  Success return\r\n") );

	return;
}

void SetPlayMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode )
{
	BOOL bDecode;

	bDecode = decVIDEO_GET_DECODE_STATE( pHwDevExt );

	if( !bDecode ) {
		decVIDEO_PRSO_PS1( pHwDevExt );
		if( mode != PLAY_MODE_FREEZE )
			decSetVideoPlayMode( pHwDevExt, mode );
	}
	else {
		if( mode == PLAY_MODE_NORMAL ) {
			if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST ) {
				decFastNormal( pHwDevExt );
				UnderflowStopData( pHwDevExt );
			}
			else {
				decGenericNormal( pHwDevExt );
				StreamClassScheduleTimer(
					NULL,
					pHwDevExt,
					1,
					(PHW_TIMER_ROUTINE)TimerAudioMuteOff,
					pHwDevExt
					);
			}
			decSetVideoPlayMode( pHwDevExt, PLAY_MODE_NORMAL );
			decSetVideoRunMode( pHwDevExt, PLAY_MODE_NORMAL );

		}
		else if( mode == PLAY_MODE_SLOW ) {
			if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST ) {
				decFastSlow( pHwDevExt );
				UnderflowStopData( pHwDevExt );
			}
			else {
				decGenericSlow( pHwDevExt );
			}
			decSetVideoPlayMode( pHwDevExt, PLAY_MODE_SLOW );
			decSetVideoRunMode( pHwDevExt, PLAY_MODE_SLOW );
		}
		else if( mode == PLAY_MODE_FREEZE ) {
			if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FAST ) {
				decFastFreeze( pHwDevExt );
			}
			else {
				decGenericFreeze( pHwDevExt );
			}
			decSetVideoPlayMode( pHwDevExt, PLAY_MODE_FREEZE );
			// Doesn't change RunMode. Because RunMode indicates the next play mode.
		}
		else if( mode == PLAY_MODE_FAST ) {
			if( decGetVideoPlayMode( pHwDevExt ) == PLAY_MODE_FREEZE ) {
				decFreezeFast( pHwDevExt );
				decSetVideoPlayMode( pHwDevExt, PLAY_MODE_FAST );
				if( pHwDevExt->pSrbDMA0 == NULL && pHwDevExt->pSrbDMA1 == NULL ) {
					DebugPrint( (DebugLevelTrace, "DVDTS:  <<<< kick >>>>\r\n") );
					PreDMAxfer( pHwDevExt );
				}
			}
			else {
				decStopForFast( pHwDevExt );
				ForcedStopData( pHwDevExt, 0x04 );
			}
			decSetVideoPlayMode( pHwDevExt, PLAY_MODE_FAST );
			decSetVideoRunMode( pHwDevExt, PLAY_MODE_FAST );
		}
		else
			TRAP;
	}
}


void StopData( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK pSrbTmp;
	ULONG	index;
	BOOLEAN	fSrbDMAlast;

	pHwDevExt->SendFirst = FALSE;
	pHwDevExt->DecodeStart = FALSE;
	pHwDevExt->XferStartCount = 0;
	pHwDevExt->CppFlagCount = 0;

	StreamClassScheduleTimer(
		pHwDevExt->pstroVid,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)TimerDecodeStart,
		pHwDevExt
		);

	StreamClassScheduleTimer(
		pHwDevExt->pstroAud,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
		pHwDevExt
	);

	if( pHwDevExt->pSrbDMA0 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:      pSrbDMA0 = 0x%x exist\r\n", pHwDevExt->pSrbDMA0 ));

		if( pHwDevExt->fSrbDMA0last ) {
			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(StopData) srb = 0x%x\r\n", pHwDevExt->pSrbDMA0 ));
				if( pHwDevExt->pSrbDMA0 == pHwDevExt->pSrbDMA1 || pHwDevExt->pSrbDMA1 == NULL ) {
					DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(StopData)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
						1,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->parmSrb
						);
				}
			}

			pHwDevExt->pSrbDMA0->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pHwDevExt->pSrbDMA0->StreamObject,
											pHwDevExt->pSrbDMA0 );
		}
		pHwDevExt->pSrbDMA0 = NULL;
		pHwDevExt->fSrbDMA0last = FALSE;
	}
	if( pHwDevExt->pSrbDMA1 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:      pSrbDMA1 = 0x%x exist\r\n", pHwDevExt->pSrbDMA1 ));

		if( pHwDevExt->fSrbDMA1last ) {
			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(StopData) srb = 0x%x\r\n", pHwDevExt->pSrbDMA1 ));
				if( pHwDevExt->pSrbDMA0 == NULL ) {
					DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(StopData)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
						1,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->parmSrb
						);
				}
			}

			pHwDevExt->pSrbDMA1->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pHwDevExt->pSrbDMA1->StreamObject,
											pHwDevExt->pSrbDMA1 );
		}
		pHwDevExt->pSrbDMA1 = NULL;
		pHwDevExt->fSrbDMA1last = FALSE;
	}


	for( ; ; ) {
		pSrbTmp = DeviceQueue_get( pHwDevExt,&index, &fSrbDMAlast );
		if( pSrbTmp == NULL )
			break;
		if( fSrbDMAlast ) {
			DebugPrint(( DebugLevelVerbose, "DVDTS:  pSrb = 0x%x\r\n", pSrbTmp ));

			if( ((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(StopData) srb = 0x%x\r\n", pSrbTmp ));
				DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(StopData)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
						1,
						((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->parmSrb
						);
			}

			pSrbTmp->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pSrbTmp->StreamObject,
											pSrbTmp );
		}
	}

	decSetVideoRunMode ( pHwDevExt, PLAY_MODE_NORMAL);	// PlayMode after STOP is Normal Mode;
	fProgrammed = fStarted = FALSE;
	fClkPause = FALSE;

	decStopData( pHwDevExt, FALSE );

}

void CheckAudioUnderflow( PHW_DEVICE_EXTENSION pHwDevExt )
{

	NTSTATUS status;
	ULONG buffStatus;

	DebugPrint(( DebugLevelTrace, "DVDTS:CheckAudioUnderflow\r\n" ));

	status = decAUDIO_ZR38521_BFST( pHwDevExt, &buffStatus );
	if( status == STATUS_UNSUCCESSFUL ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  decAUDIO_ZR38521_BFST Unsuccessful\r\n" ));
		TRAP;
	}
	if( decVIDEO_GET_STD_CODE( pHwDevExt ) >= 1024 /* Underflow Size of Video */ ) {
		// cancel ScheduleTimer
		StreamClassScheduleTimer(
			pHwDevExt->pstroAud,
			pHwDevExt,
			0,
			(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
			pHwDevExt
		);
		return;
	}
	if( (buffStatus & 0x0700)!=0x0700 && (buffStatus & 0x0001)!=0x0001 ) {
		// reschedule
		StreamClassScheduleTimer(
			pHwDevExt->pstroAud,
			pHwDevExt,
			500000,
			(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
			pHwDevExt
		);
		return;
	}
	UnderflowStopData( pHwDevExt );
}

void UnderflowStopData( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:UnderflowStopData fCauseOfStop = %d\r\n", pHwDevExt->fCauseOfStop ));
	ClearTimeDiscontinuity( pHwDevExt );

	pHwDevExt->SendFirst = FALSE;
	pHwDevExt->DecodeStart = FALSE;
//	pHwDevExt->XferStartCount = 0;
//	pHwDevExt->CppFlagCount = 0;

	StreamClassScheduleTimer(
		pHwDevExt->pstroVid,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)TimerDecodeStart,
		pHwDevExt
		);

	StreamClassScheduleTimer(
		pHwDevExt->pstroAud,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
		pHwDevExt
	);

	pHwDevExt->bDMAstop = TRUE;

	pHwDevExt->fCauseOfStop = 0x00;


	StopDequeue( pHwDevExt );


	fClkPause = FALSE;


}

void ForcedStopData( PHW_DEVICE_EXTENSION pHwDevExt, ULONG flag )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:ForcedStopData\r\n" ));

	decVIDEO_UFLOW_INT_OFF( pHwDevExt );
	decVIDEO_DECODE_STOP( pHwDevExt );
	decAUDIO_ZR38521_STOP( pHwDevExt );
	decSUBP_STC_OFF( pHwDevExt );
	pHwDevExt->bDMAstop = TRUE;

	pHwDevExt->fCauseOfStop = flag;

	StreamClassScheduleTimer(
		pHwDevExt->pstroAud,
		pHwDevExt,
		0,
		(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
		pHwDevExt
	);

	StopDequeue( pHwDevExt );

}

void StopDequeue( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK pSrbTmp;
	ULONG	index;
	BOOLEAN	fSrbDMAlast;

	DebugPrint(( DebugLevelTrace, "DVDTS:StopDequeue\r\n" ));

	if( pHwDevExt->pSrbDMA0 != NULL || pHwDevExt->pSrbDMA1 != NULL ) {
		StreamClassScheduleTimer(
			NULL,
			pHwDevExt,
			100000,
			(PHW_TIMER_ROUTINE)StopDequeue,
			pHwDevExt
		);
		DebugPrint(( DebugLevelTrace, "DVDTS:Schedule StopDequeue\r\n" ));
		return;
	}


	for( ; ; ) {
		pSrbTmp = DeviceQueue_get( pHwDevExt, &index, &fSrbDMAlast );
		if( pSrbTmp == NULL )
			break;
		if( fSrbDMAlast ) {
			DebugPrint(( DebugLevelVerbose, "DVDTS:  pSrb = 0x%x\r\n", pSrbTmp ));

			if( ((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(StopDequeue) srb = 0x%x\r\n", pSrbTmp ));
				DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(StopDequeue)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
						1,
						((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pSrbTmp->SRBExtension))->parmSrb
						);
			}

			pSrbTmp->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pSrbTmp->StreamObject,
											pSrbTmp );
		}
	}
	pHwDevExt->bDMAstop = FALSE;

	// 0x04: NORMAL to F.F. or F.F. to F.F.
	if( pHwDevExt->fCauseOfStop == 0x04 ) {
		decResumeForFast( pHwDevExt );
	}
}

void SetAudioID( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc )
{
	MYAUDIOFORMAT fmt;
	ULONG	strID;

	strID = (ULONG)GetStreamID(pStruc->Data);

	// AC-3
	if( (strID & 0xF8)==0x80 ) {
		if( decSUBP_GET_AUDIO_CH( pHwDevExt ) != strID ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:AC-3 0x%x\r\n", strID ));


			fmt.dwMode = AUDIO_TYPE_AC3;
			fmt.dwFreq = AUDIO_FS_48;

			ProcessAudioFormat2( &fmt, pHwDevExt );

			decSUBP_SET_AUDIO_CH(pHwDevExt, strID);
		}
	}
	// LPCM
	else if( (strID & 0xF8)==0xA0 ) {
		if( decSUBP_GET_AUDIO_CH( pHwDevExt ) != strID ) {
			MYAUDIOFORMAT fmt;
			DebugPrint(( DebugLevelTrace, "DVDTS:LPCM 0x%x\r\n", strID ));

			fmt.dwMode = AUDIO_TYPE_PCM;
			decGetLPCMInfo( pStruc->Data, &fmt );

			ProcessAudioFormat2( &fmt, pHwDevExt );

			decSUBP_SET_AUDIO_CH(pHwDevExt,strID);
		}
	}

}

void SetSubpicID( PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc )
{
	ULONG strID;
	ULONG stc;

	strID = (ULONG)GetStreamID(pStruc->Data);

	if( (strID & 0xE0)==0x20 ) {
		if( decSUBP_GET_SUBP_CH( pHwDevExt ) != strID ) {
			decSUBP_SET_SUBP_CH( pHwDevExt, strID );
			stc = decGetVideoSTCA(pHwDevExt);
			decSUBP_SET_STC( pHwDevExt,stc );
			decSUBP_STC_ON(pHwDevExt);
		}
	}
}

void SetCppFlag( PHW_DEVICE_EXTENSION pHwDevExt )
{

	BOOL bSet;
	DebugPrint(( DebugLevelTrace, "DVDTS:SetCppFlag()\r\n" ));

//	pHwDevExt->CppFlagCount = 0;

	ASSERT( pHwDevExt->pSrbCpp );

	bSet = DeviceQueue_setEndAddress( pHwDevExt, (PHW_TIMER_ROUTINE)TimerCppReset, pHwDevExt->pSrbCpp );

	DebugPrint(( DebugLevelTrace, "DVDTS:  bSet %d\r\n", bSet ));

	if( !bSet ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:    pSrbDMA0 0x%x, pSrbDMA1 0x%x\r\n", pHwDevExt->pSrbDMA0, pHwDevExt->pSrbDMA1 ));

		if( pHwDevExt->pSrbDMA0 == NULL && pHwDevExt->pSrbDMA1 == NULL ) {
			StreamClassScheduleTimer(
				NULL,
				pHwDevExt,
				1,
				(PHW_TIMER_ROUTINE)TimerCppReset,
				pHwDevExt->pSrbCpp
				);
			return;
		}

		if( pHwDevExt->pSrbDMA0 ) {
			((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb = (PHW_TIMER_ROUTINE)TimerCppReset;
			((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->parmSrb = pHwDevExt->pSrbCpp;
		}
		if( pHwDevExt->pSrbDMA1 ) {
			((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb = (PHW_TIMER_ROUTINE)TimerCppReset;
			((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->parmSrb = pHwDevExt->pSrbCpp;
		}
	}
	return;
}

void AudioQueryAccept( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:AudioQueryAccept\r\n" ));
   
	pSrb->Status = STATUS_SUCCESS;
}

void ProcessAudioFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:ProcessAudioFormat\r\n" ));

	if( ( IsEqualGUID2( &pfmt->MajorFormat, &KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK ) &&
			IsEqualGUID2( &pfmt->SubFormat, &KSDATAFORMAT_SUBTYPE_AC3_AUDIO ) ) ) {
		// AC-3
		DebugPrint(( DebugLevelTrace, "DVDTS:  AC-3\r\n" ));

		decSetAudioFreq( pHwDevExt, AUDIO_FS_48 );

      /* If the audio type is not already set to AC3 in the decoder, set it to AC3 now */
		if( decGetAudioMode(  pHwDevExt ) != AUDIO_TYPE_AC3 ) {

			decSetAudioAC3(  pHwDevExt ); // set audio mode AC3
		}
	}
	else if( ( IsEqualGUID2( &pfmt->MajorFormat, &KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK ) &&
			IsEqualGUID2( &pfmt->SubFormat, &KSDATAFORMAT_SUBTYPE_LPCM_AUDIO ) ) ) {

		ULONGLONG tptr = (ULONGLONG) pfmt + sizeof  (KSDATAFORMAT);

		// LPCM
		WAVEFORMATEX *pblock;
		DebugPrint(( DebugLevelTrace, "DVDTS:  LPCM\r\n" ));


		pblock = (WAVEFORMATEX *)tptr;

		DebugPrint(( DebugLevelTrace, "DVDTS:    wFormatTag      %d\r\n", (DWORD)(pblock->wFormatTag) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    nChannels       %d\r\n", (DWORD)(pblock->nChannels) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    nSamplesPerSec  %d\r\n", (DWORD)(pblock->nSamplesPerSec) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    nAvgBytesPerSec %d\r\n", (DWORD)(pblock->nAvgBytesPerSec) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    nBlockAlign     %d\r\n", (DWORD)(pblock->nBlockAlign) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    wBitsPerSample  %d\r\n", (DWORD)(pblock->wBitsPerSample) ));
		DebugPrint(( DebugLevelTrace, "DVDTS:    cbSize          %d\r\n", (DWORD)(pblock->cbSize) ));


      /* If the audio type is not already set to LPCM in the decoder, set it to LPCM now */
		if( decGetAudioMode(  pHwDevExt ) != AUDIO_TYPE_PCM ) {

			decSetAudioPCM(  pHwDevExt ); // set audio mode PCM
		}
	}
	else {
		DebugPrint(( DebugLevelTrace, "DVDTS:  Unsupported audio type\r\n" ));

		DebugPrint(( DebugLevelTrace, "DVDTS:  Major  %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\r\n",
			pfmt->MajorFormat.Data1,
			pfmt->MajorFormat.Data2,
			pfmt->MajorFormat.Data3,
			pfmt->MajorFormat.Data4[0],
			pfmt->MajorFormat.Data4[1],
			pfmt->MajorFormat.Data4[2],
			pfmt->MajorFormat.Data4[3],
			pfmt->MajorFormat.Data4[4],
			pfmt->MajorFormat.Data4[5],
			pfmt->MajorFormat.Data4[6],
			pfmt->MajorFormat.Data4[7]
			));
		DebugPrint(( DebugLevelTrace, "DVDTS:  Sub    %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\r\n",
			pfmt->SubFormat.Data1,
			pfmt->SubFormat.Data2,
			pfmt->SubFormat.Data3,
			pfmt->SubFormat.Data4[0],
			pfmt->SubFormat.Data4[1],
			pfmt->SubFormat.Data4[2],
			pfmt->SubFormat.Data4[3],
			pfmt->SubFormat.Data4[4],
			pfmt->SubFormat.Data4[5],
			pfmt->SubFormat.Data4[6],
			pfmt->SubFormat.Data4[7]
			));
		DebugPrint(( DebugLevelTrace, "DVDTS:  Format %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\r\n",
			pfmt->Specifier.Data1,
			pfmt->Specifier.Data2,
			pfmt->Specifier.Data3,
			pfmt->Specifier.Data4[0],
			pfmt->Specifier.Data4[1],
			pfmt->Specifier.Data4[2],
			pfmt->Specifier.Data4[3],
			pfmt->Specifier.Data4[4],
			pfmt->Specifier.Data4[5],
			pfmt->Specifier.Data4[6],
			pfmt->Specifier.Data4[7]
			));

		TRAP;

		return;
	}


	decInitAudioAfterNewFormat(pHwDevExt);

}

void ProcessAudioFormat2( PMYAUDIOFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:ProcessAudioFormat2()\r\n" ));

	if( pfmt->dwMode == AUDIO_TYPE_AC3 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  AC-3\r\n" ));

		decSetAudioFreq(  pHwDevExt, pfmt->dwFreq );

		if( decGetAudioMode(  pHwDevExt ) != AUDIO_TYPE_AC3 ) {

			decSetAudioAC3(  pHwDevExt ); // set audio mode AC3
		}
	}
	else if( pfmt->dwMode == AUDIO_TYPE_PCM ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  LPCM\r\n" ));

		decSetAudioFreq(  pHwDevExt, pfmt->dwFreq );

		if( decGetAudioMode(  pHwDevExt ) != AUDIO_TYPE_PCM ) {

			decSetAudioPCM(  pHwDevExt ); // set audio mode PCM
		}
	}
	else {
		TRAP;
		return;
	}

	decInitAudioAfterNewFormat(pHwDevExt);


	DebugPrint(( DebugLevelTrace, "DVDTS:  return\r\n" ));
}


void SetVideoRateDefault( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->VideoStartTime = 0;
	pHwDevExt->VideoInterceptTime = 0;
	pHwDevExt->VideoRate = 1 * 10000;
	pHwDevExt->StartTime = 0;
	pHwDevExt->InterceptTime = 0;
	pHwDevExt->Rate = 1 * 10000;
	pHwDevExt->ChangeFlag = 0;
}

void SetAudioRateDefault( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->AudioStartTime = 0;
	pHwDevExt->AudioInterceptTime = 0;
	pHwDevExt->AudioRate = 1 * 10000;
}

void SetSubpicRateDefault( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->SubpicStartTime = 0;
	pHwDevExt->SubpicInterceptTime = 0;
	pHwDevExt->SubpicRate = 1 * 10000;
}

void SetRateChange( PHW_DEVICE_EXTENSION pHwDevExt, LONG strm )
{
	// strm = 1:video, 2:audio, 4:subpic
	pHwDevExt->ChangeFlag = strm;

	// When video stream rate is changed, rate change is enable... Is this OK?
	if( (pHwDevExt->ChangeFlag & 0x01)==0x01 ) {
		pHwDevExt->ChangeFlag = 0;

		// Maybe buggy? use video rate, start time and intercept time
		pHwDevExt->StartTime = pHwDevExt->VideoStartTime;
		pHwDevExt->InterceptTime = pHwDevExt->VideoInterceptTime;
		pHwDevExt->Rate = pHwDevExt->VideoRate;

		DebugPrint( (DebugLevelTrace, "DVDTS:    Calculated Data\r\n" ) );
		DebugPrint( (DebugLevelTrace, "DVDTS:      InterceptTime = 0x%08x\r\n", pHwDevExt->VideoInterceptTime ) );
		DebugPrint( (DebugLevelTrace, "DVDTS:      StartTime     = 0x%08x\r\n", pHwDevExt->VideoStartTime ) );
		DebugPrint( (DebugLevelTrace, "DVDTS:      Rate          = 0x%08x\r\n", pHwDevExt->VideoRate ) );

		if( pHwDevExt->Rate == 10000 ) {
			SetPlayMode( pHwDevExt, PLAY_MODE_NORMAL );
		}
		else if( pHwDevExt->Rate < 10000 ) {
			SetPlayMode( pHwDevExt, PLAY_MODE_FAST );
		}
		else {
//--- debug
{
	ULONG dwSTC = decGetVideoSTCA( pHwDevExt );
	DebugPrint( (DebugLevelTrace, "DVDTS:  STC in SLOW = %lx (100ns)\r\n", dwSTC * 1000/9 ) );
}
//---
			SetPlayMode( pHwDevExt, PLAY_MODE_SLOW );
		}
	}
}

void SetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  SetVideoRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;
				PHW_DEVICE_EXTENSION pHwDevExt;
				REFERENCE_TIME NewStartTime;
				LONG NewRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
				NewStartTime = pRateChange->StartTime;
				NewRate = ( pRateChange->Rate < 0 ) ? -pRateChange->Rate : pRateChange->Rate;

				DebugPrint( (DebugLevelTrace, "DVDTS:    Received Data\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      StartTime     = 0x%08x\r\n", NewStartTime ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      Rate          = 0x%08x\r\n", NewRate) );

				DebugPrint( (DebugLevelTrace, "DVDTS:    Current Data\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      InterceptTime = 0x%08x\r\n", pHwDevExt->VideoInterceptTime ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      StartTime     = 0x%08x\r\n", pHwDevExt->VideoStartTime ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      Rate          = 0x%08x\r\n", pHwDevExt->VideoRate ) );

//				pHwDevExt->VideoInterceptTime
//					= (pHwDevExt->VideoInterceptTime - NewStartTime)
//					* pHwDevExt->VideoRate
//					/ NewRate
//					+ NewStartTime;

				pHwDevExt->VideoRate = NewRate;
				if( NewRate == 10000 ) {
					pHwDevExt->VideoInterceptTime = 0;
					pHwDevExt->VideoStartTime = 0;
				}
				else {
					pHwDevExt->VideoInterceptTime = (-NewStartTime) * 10000 / NewRate + NewStartTime;
					pHwDevExt->VideoStartTime = NewStartTime;
				}

				SetRateChange( pHwDevExt, 0x01 );
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}

void SetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  SetAudioRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;
				PHW_DEVICE_EXTENSION pHwDevExt;
				REFERENCE_TIME NewStartTime;
				LONG NewRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
				NewStartTime = pRateChange->StartTime;
				NewRate = ( pRateChange->Rate < 0 ) ? -pRateChange->Rate : pRateChange->Rate;

				DebugPrint( (DebugLevelTrace, "DVDTS:    Received Data\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      StartTime     = 0x%08x\r\n", NewStartTime ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      Rate          = 0x%08x\r\n", NewRate) );

//				pHwDevExt->AudioInterceptTime
//					= (pHwDevExt->AudioInterceptTime - NewStartTime)
//					* pHwDevExt->AudioRate
//					/ NewRate
//					+ NewStartTime;

				pHwDevExt->AudioRate = NewRate;
				if( NewRate == 10000 ) {
					pHwDevExt->AudioInterceptTime = 0;
					pHwDevExt->AudioStartTime = 0;
				}
				else {
					pHwDevExt->AudioInterceptTime = (-NewStartTime) * 10000 / NewRate + NewStartTime;
					pHwDevExt->AudioStartTime = NewStartTime;
				}

				SetRateChange( pHwDevExt, 0x02 );
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}

void SetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  SetSubpicRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;
				PHW_DEVICE_EXTENSION pHwDevExt;
				REFERENCE_TIME NewStartTime;
				LONG NewRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
				NewStartTime = pRateChange->StartTime;
				NewRate = ( pRateChange->Rate < 0 ) ? -pRateChange->Rate : pRateChange->Rate;

				DebugPrint( (DebugLevelTrace, "DVDTS:    Received Data\r\n" ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      StartTime     = 0x%08x\r\n", NewStartTime ) );
				DebugPrint( (DebugLevelTrace, "DVDTS:      Rate          = 0x%08x\r\n", NewRate) );

//				pHwDevExt->SubpicInterceptTime
//					= (pHwDevExt->SubpicInterceptTime - NewStartTime)
//					* pHwDevExt->SubpicRate
//					/ NewRate
//					+ NewStartTime;

				pHwDevExt->SubpicRate = NewRate;
				if( NewRate == 10000 ) {
					pHwDevExt->SubpicInterceptTime = 0;
					pHwDevExt->SubpicStartTime = 0;
				}
				else {
					pHwDevExt->SubpicInterceptTime = (-NewStartTime) * 10000 / NewRate + NewStartTime;
					pHwDevExt->SubpicStartTime = NewStartTime;
				}

				SetRateChange( pHwDevExt, 0x04 );
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}

void GetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:  GetVideoRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_SimpleRateChange);
				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pRateChange->StartTime = pHwDevExt->VideoStartTime;
				pRateChange->Rate = pHwDevExt->VideoRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			{
				KS_AM_MaxFullDataRate* pMaxRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_MaxFullDataRate\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_MaxFullDataRate);
				pMaxRate = (KS_AM_MaxFullDataRate*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				*pMaxRate = pHwDevExt->VideoMaxFullRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}

void GetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:  GetAudioRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_SimpleRateChange);
				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pRateChange->StartTime = pHwDevExt->AudioStartTime;
				pRateChange->Rate = pHwDevExt->AudioRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			{
				KS_AM_MaxFullDataRate* pMaxRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_MaxFullDataRate\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_MaxFullDataRate);
				pMaxRate = (KS_AM_MaxFullDataRate*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				*pMaxRate = pHwDevExt->AudioMaxFullRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}

void GetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelTrace, "DVDTS:  GetSubpicRateChange\r\n") );
	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {

		case KS_AM_RATE_SimpleRateChange :
			{
				KS_AM_SimpleRateChange* pRateChange;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_SimpleRateChange\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_SimpleRateChange);
				pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				pRateChange->StartTime = pHwDevExt->SubpicStartTime;
				pRateChange->Rate = pHwDevExt->SubpicRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_ExactRateChange :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case KS_AM_RATE_MaxFullDataRate :
			{
				KS_AM_MaxFullDataRate* pMaxRate;

				DebugPrint( (DebugLevelTrace, "DVDTS:  KS_AM_RATE_MaxFullDataRate\r\n") );

				pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_MaxFullDataRate);
				pMaxRate = (KS_AM_MaxFullDataRate*)pSrb->CommandData.PropertyInfo->PropertyInfo;
				*pMaxRate = pHwDevExt->SubpicMaxFullRate;
			}
			pSrb->Status = STATUS_SUCCESS;
			break;

		case KS_AM_RATE_Step :
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdtdcod.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    DvdTDCod.H

Abstract:

    API definitions for Master Decoder HW routines library "DvdTDcod.lib"
    
	DvdTDCod.lib itself is provided by Microsoft in binary form only

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
#ifndef __DVDCOD_H__
#define __DVDCOD_H__

// allocate decoder data area and put 'blind' ptr to it in our device ext
PVOID decAllocateDecoderInfo( PHW_DEVICE_EXTENSION pHwDevExt );

// initialize the mpeg hw
void decInitMPEG( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC );

void decVsyncOn( PHW_DEVICE_EXTENSION pHwDevExt ); // vert sync on

void decClosedCaptionOn( PHW_DEVICE_EXTENSION pHwDevExt ); //turn on/off closed caption
void decClosedCaptionOff( PHW_DEVICE_EXTENSION pHwDevExt );

// get MPEG decoder interrupt status
UCHAR decGetMPegIntStatus( PHW_DEVICE_EXTENSION pHwDevExt );

UCHAR decGetPciIntStatus( PHW_DEVICE_EXTENSION pHwDevExt );

//DMA routines
void decSetDma0Size( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize );
void decSetDma1Size( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize );
void decSetDma0Addr( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr );
void decSetDma1Addr( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr );
void decSetDma0Start( PHW_DEVICE_EXTENSION pHwDevExt );
void decSetDma1Start( PHW_DEVICE_EXTENSION pHwDevExt );

ULONG decGetVideoSTCA( PHW_DEVICE_EXTENSION pHwDevExt );

void decGetLPCMInfo( void *pBuf, PMYAUDIOFORMAT pfmt );

void decInitAudioAfterNewFormat( PHW_DEVICE_EXTENSION pHwDevExtpHwDevExt );

//hardware reg mode setting
BOOLEAN decSetStreamMode( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb ); // set stream modes on HW
void decSetDisplayMode( PHW_DEVICE_EXTENSION pHwDevExt ); // set display mode on HW

void decSetAudioMode( PHW_DEVICE_EXTENSION pHwDevExt ); // set audio mode on HW
void decSetAudioAC3( PHW_DEVICE_EXTENSION pHwDevExt ); // set audio mode AC3
void decSetAudioPCM( PHW_DEVICE_EXTENSION pHwDevExt ); // set audio mode PCM
ULONG decGetAudioMode( PHW_DEVICE_EXTENSION pHwDevExt ); // get audio mode from HW
void decSetAudioFreq( PHW_DEVICE_EXTENSION pHwDevExt, ULONG freq ); // set audio freq 

void decSetCopyGuard( PHW_DEVICE_EXTENSION pHwDevExt ); // set copy protection on HW

// video play speed/mode
void decSetVideoPlayMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode ); // set video play speed/mode
ULONG decGetVideoPlayMode( PHW_DEVICE_EXTENSION pHwDevExt ); // get video play speed/mode
void decSetVideoRunMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode ); // set video run speed/mode
ULONG decGetVideoRunMode( PHW_DEVICE_EXTENSION pHwDevExt ); // get video run speed/mode

UCHAR decGetVideoPort( PHW_DEVICE_EXTENSION pHwDevExt ); // get video port
void decSetVideoPort( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR port ); // set video port

// interrupt handlers
void decHwIntVideo( PHW_DEVICE_EXTENSION pHwDevExt );
void decHwIntVSync( PHW_DEVICE_EXTENSION pHwDevExt );

// access/control composite picture
BOOLEAN decGetSubpicMute( PHW_DEVICE_EXTENSION pHwDevExt );
void decSetSubpicMute( PHW_DEVICE_EXTENSION pHwDevExt, BOOLEAN flag );

// Set CGMS for Digital Audio Copy Guard & NTSC Analog Copy Guard
void decDvdTitleCopyKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY pTitleKey );
BOOLEAN decCpp_reset( PHW_DEVICE_EXTENSION pHwDevExt, CPPMODE mode );
BOOLEAN decCpp_decoder_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r1 );
BOOLEAN decCpp_drive_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr1 );
BOOLEAN decCpp_drive_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r2 );
BOOLEAN decCpp_decoder_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr2 );
BOOLEAN decCpp_DiscKeyStart(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN decCpp_DiscKeyEnd(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN decCpp_TitleKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY tk );

// actual start video decoding at various speeds
void decDecodeStartNormal( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC );
void decDecodeStartFast( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC );
void decDecodeStartSlow( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC );

void decStopData( PHW_DEVICE_EXTENSION pHwDevExt, BOOL bKeep );
void decHighlight( PHW_DEVICE_EXTENSION pHwDevExt, PKSPROPERTY_SPHLI phli );
void decDisableInt( PHW_DEVICE_EXTENSION pHwDevExt );
void decGenericNormal( PHW_DEVICE_EXTENSION pHwDevExt );
void decGenericFreeze( PHW_DEVICE_EXTENSION pHwDevExt );
void decGenericSlow( PHW_DEVICE_EXTENSION pHwDevExt );
void decStopForFast( PHW_DEVICE_EXTENSION pHwDevExt );
void decResumeForFast( PHW_DEVICE_EXTENSION pHwDevExt );
void decFastNormal( PHW_DEVICE_EXTENSION pHwDevExt );
void decFastSlow( PHW_DEVICE_EXTENSION pHwDevExt );
void decFastFreeze( PHW_DEVICE_EXTENSION pHwDevExt );
void decFreezeFast( PHW_DEVICE_EXTENSION pHwDevExt );

// misc HW routines used by dvdcmd.c
void  decSUBP_STC_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void  decSUBP_STC_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void  decVPRO_SUBP_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt ,PUCHAR pPalData );
void  decSUBP_SET_AUDIO_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch );
ULONG decSUBP_GET_AUDIO_CH( PHW_DEVICE_EXTENSION pHwDevExt );
void  decSUBP_SET_SUBP_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch );
ULONG decSUBP_GET_SUBP_CH( PHW_DEVICE_EXTENSION pHwDevExt );
void  decSUBP_SET_STC(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc );
void decCGuard_CPGD_SET_ASPECT( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect );
void decCGuard_CPGD_SUBP_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pPalData );
NTSTATUS decAUDIO_ZR38521_STAT( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pDiff );
NTSTATUS decAUDIO_ZR38521_MUTE_OFF(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS decAUDIO_ZR38521_BFST( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pErrCode );
NTSTATUS decAUDIO_ZR38521_STOP(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS decAUDIO_ZR38521_VDSCR_ON( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc );
void decVIDEO_SET_STCA( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stca );
ULONG decVIDEO_GET_STD_CODE( PHW_DEVICE_EXTENSION pHwDevExt );
BOOL decVIDEO_GET_DECODE_STATE( PHW_DEVICE_EXTENSION pHwDevExt );
NTSTATUS decVIDEO_DECODE_STOP( PHW_DEVICE_EXTENSION pHwDevExt );
void decVIDEO_UFLOW_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void decVIDEO_PRSO_PS1( PHW_DEVICE_EXTENSION pHwDevExt );


	
			



		



#endif // __DVDCOD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdinit.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dvdinit.h

Abstract:

    Device Extension and other definitions for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/

#ifndef __DVDINIT_H__
#define __DVDINIT_H__

// a few minimal hardware defs from regs.h
#define	DMASIZE		(2*1024)

#define	IFLG_CNTL	0x00	// PCI I/F control
#define	IFLG_INT	0x04	// Interrupt flags

#define	PLAY_MODE_NORMAL	0x01 //enums for video play modes
#define	PLAY_MODE_FAST		0x02
#define	PLAY_MODE_SLOW		0x03
#define	PLAY_MODE_FREEZE	0x04
#define	PLAY_MODE_STILL		0x05

#define	AUDIO_TYPE_AC3		0x01
#define	AUDIO_TYPE_PCM		0x04

#define	AUDIO_FS_48		0x03

// end, a few minimal hardware defs from regs.h


typedef enum tagStreamType {
    strmVideo = 0,
    strmAudio,
    strmSubpicture,
    strmYUVVideo,
	strmCCOut,
	STREAMNUM
} STREAMTYPES;

typedef enum
{
	Video,
	Audio,
	SubPicture
} StreamType;

typedef enum
{
	NO_GUARD,
	GUARD
} CPPMODE;

typedef struct _DeviceQueue
{

	ULONG count;						// srb count in this queue
	PHW_STREAM_REQUEST_BLOCK top;
	PHW_STREAM_REQUEST_BLOCK bottom;
	PHW_STREAM_REQUEST_BLOCK video;
	PHW_STREAM_REQUEST_BLOCK audio;
	PHW_STREAM_REQUEST_BLOCK subpic;
	PVOID top_addr;						// buffer address of the first srb
	PVOID bottom_addr;					// buffer address of the bottom srb
	BOOLEAN v_first;
	BOOLEAN a_first;
	BOOLEAN s_first;
	ULONG v_count;
	ULONG a_count;
	ULONG s_count;


} DeviceQueue, *PDeviceQueue;

typedef struct _CCQueue
{

	ULONG count;						// srb count in this queue
	PHW_STREAM_REQUEST_BLOCK top;
	PHW_STREAM_REQUEST_BLOCK bottom;


} CCQueue, *PCCQueue;




typedef struct _HW_DEVICE_EXTENSION {


	PCI_COMMON_CONFIG	PciConfigSpace;

	PUCHAR			ioBaseLocal;	// board base address
	ULONG			Irq;		// irq level
	ULONG			RevID;		// Revision ID


	BOOL			fTimeOut;

	PHW_STREAM_REQUEST_BLOCK	pSrbDMA0;
	PHW_STREAM_REQUEST_BLOCK	pSrbDMA1;
	BOOLEAN	fSrbDMA0last;
	BOOLEAN	fSrbDMA1last;

	BOOL	SendFirst;
	BOOL	DecodeStart;
	DWORD	TimeDiscontFlagCount;
	DWORD	DataDiscontFlagCount;
	DWORD	SendFirstTime;
	ULONG	XferStartCount;

	BOOL	bKeyDataXfer;
	PHW_TIMER_ROUTINE	pfnEndKeyData;
	DWORD	CppFlagCount;
	PHW_STREAM_REQUEST_BLOCK	pSrbCpp;
	BOOL	bCppReset;
	LONG	lCPPStrm;

	DWORD	cOpenInputStream;	// count opened input stream

	DeviceQueue DevQue;
	CCQueue CCQue;

	PVOID		DecoderInfo;  // pointer to decoder and other hardware  data, 
							  // opaque to us and  handled by DvdTDCod.lib

	PHW_STREAM_OBJECT pstroVid;
	PHW_STREAM_OBJECT pstroAud;
	PHW_STREAM_OBJECT pstroSP;
	PHW_STREAM_OBJECT pstroYUV;
	PHW_STREAM_OBJECT pstroCC;

	ULONG	ddrawHandle;
	ULONG	VidPortID;
	ULONG	SurfaceHandle;

	DWORD	dwSTCInit;
	DWORD	dwSTCtemp;
	DWORD	dwSTCinPause;	// is used to keep STC only from Fast to Pause
							// because in this case STC doesn't STOP !! (why?)
	BOOL	bSTCvalid;
	BOOL	bDMAscheduled;
	UCHAR	fDMA;
	UCHAR	bDMAstop;
	ULONG	fCauseOfStop;
	BOOL	bVideoQueue;
	BOOL	bAudioQueue;
	BOOL	bSubpicQueue;
	REFERENCE_TIME	VideoStartTime;
	REFERENCE_TIME	VideoInterceptTime;
	LONG			VideoRate;
	REFERENCE_TIME	AudioStartTime;
	REFERENCE_TIME	AudioInterceptTime;
	LONG			AudioRate;
	REFERENCE_TIME	SubpicStartTime;
	REFERENCE_TIME	SubpicInterceptTime;
	LONG			SubpicRate;

	REFERENCE_TIME	StartTime;
	REFERENCE_TIME	InterceptTime;
	LONG			Rate;

	LONG			VideoMaxFullRate;
	LONG			AudioMaxFullRate;
	LONG			SubpicMaxFullRate;

	LONG			ChangeFlag;

	PUCHAR	pDmaBuf;
	STREAM_PHYSICAL_ADDRESS	addr;

	KSPROPERTY_SPHLI	hli;

	KS_AMVPDATAINFO	VPFmt;

	BOOL	bStopCC;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef struct _STREAMEX {

	DWORD EventCount;
	KSSTATE	state;

} STREAMEX, *PSTREAMEX;

typedef struct _SRB_EXTENSION {

	StreamType Type;
	ULONG Index;

	PHW_TIMER_ROUTINE	pfnEndSrb;
	PHW_STREAM_REQUEST_BLOCK	parmSrb;

} SRB_EXTENSION, * PSRB_EXTENSION;

typedef struct _MYTIME {
	KSEVENT_TIME_INTERVAL tim;
	LONGLONG LastTime;
} MYTIME, *PMYTIME;

typedef struct _MYAUDIOFORMAT {
	DWORD	dwMode;
	DWORD	dwFreq;
	DWORD	dwQuant;
} MYAUDIOFORMAT, *PMYAUDIOFORMAT;



/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath );
NTSTATUS HwInitialize (IN PHW_STREAM_REQUEST_BLOCK pSrb);
void GetPCIConfigSpace(IN PHW_STREAM_REQUEST_BLOCK pSrb);
void InitializationEntry(IN PHW_STREAM_REQUEST_BLOCK pSrb);

// unit = ms
static DWORD GetCurrentTime_ms() 
{ 
	LARGE_INTEGER time, rate; 
	time = KeQueryPerformanceCounter( &rate ); 
	return( (DWORD)( ( time.QuadPart * 1000 ) / rate.QuadPart  ) ); 
}



#endif //__DVDINIT_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdirq.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dvdirq.c

Abstract:

    Device interrupt logic for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
#include "strmini.h"
#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "dvdcmd.h"
#include "DvdTDCod.h" // header for DvdTDCod.lib routines hiding proprietary HW stuff


void HwIntDMA( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR val );


/*
** HwInterrupt()
*/
BOOLEAN STREAMAPI HwInterrupt( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR	val;
	BOOLEAN	fInterrupt = TRUE;


	// interrupt may be shared; see if its ours and exactly which of ours it is
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_INT );

//	DebugPrint( (DebugLevelVerbose, "DVDTS:HwInterrupt 0x%x\r\n", (DWORD)val ) );

	if( val & 0x03 ) {
		HwIntDMA( pHwDevExt, (UCHAR)(val & 0x03) );
	}
	else if( val & 0x08 ) {
		decHwIntVideo( pHwDevExt );  //routine in dvdtdcod.lib to hide propriotary  stuff
	}
	else if( val & 0x10 ) {
		decHwIntVSync( pHwDevExt ); ////routine in dvdtdcod.lib to hide propriotary  stuff
	}
	else if( val != 0 ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:Interrupt! Not impliment\r\n") );
		TRAP;
	}
	else {
//    this can happen for a shared  interrupt
//		DebugPrint( (DebugLevelTrace, "DVDTS:Other Board Interrupt ??\r\n") );
//		TRAP;
		fInterrupt = FALSE;
	}



	return( fInterrupt );
}

void HwIntDMA( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR val )
{
	if( pHwDevExt->bKeyDataXfer ) {

		if( val & 0x01 )
			WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_INT, 0x01 );
		else
			TRAP;

		pHwDevExt->pfnEndKeyData( pHwDevExt );

		return;
	}

	if( val & 0x01 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_INT, 0x01 );

		if( pHwDevExt->pSrbDMA0 == NULL ) {
			DebugPrint( (DebugLevelTrace, "DVDTS:  Bad Status! DMA0 HwIntDMA\r\n") );
//			TRAP;
			return;
		}

// error check for debug
		{
		UCHAR val;
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_CNTL );
		if( val & 0x01 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:  Bad Irq? DMA0\r\n" ));
			return;
		}
		}


		if( pHwDevExt->fSrbDMA0last ) {
			DebugPrint(( DebugLevelVerbose, "DVDTS:HWInt SrbDMA0 0x%x\r\n", pHwDevExt->pSrbDMA0 ) );

			// must fix!
			// other place that call StreamRequestComplete() does not clear pHwDevExt->bEndCpp;

			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(HWint0) srb = 0x%x\r\n", pHwDevExt->pSrbDMA0 ));
				if( pHwDevExt->pSrbDMA0 == pHwDevExt->pSrbDMA1 || pHwDevExt->pSrbDMA1 == NULL ) {
					DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(HWint0)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
// BUG - must fix
// need wait underflow?
						500000,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA0->SRBExtension))->parmSrb
						);
				}
			}

			pHwDevExt->pSrbDMA0->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pHwDevExt->pSrbDMA0->StreamObject,
											pHwDevExt->pSrbDMA0 );

		}

		// Next DMA
		pHwDevExt->pSrbDMA0 = NULL;
		pHwDevExt->fSrbDMA0last = FALSE;
	}

	if( val & 0x02 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_INT, 0x02 );

		if( pHwDevExt->pSrbDMA1 == NULL ) {
			DebugPrint( (DebugLevelTrace, "DVDTS:  Bad Status! DMA1 HwIntDMA\r\n") );
//			TRAP;
			return;
		}

// error check for debug
		{
		UCHAR val;
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_CNTL );
		if( val & 0x02 ) {
			DebugPrint(( DebugLevelTrace, "DVDTS:  Bad Irq? DMA1\r\n" ));
			return;
		}
		}


		if( pHwDevExt->fSrbDMA1last ) {
			DebugPrint(( DebugLevelVerbose, "DVDTS:HWInt SrbDMA1 0x%x\r\n", pHwDevExt->pSrbDMA1 ) );

			// must fix!
			// other place that call StreamRequestComplete() does not clear pHwDevExt->bEndCpp;

			if( ((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb ) {
				DebugPrint(( DebugLevelTrace, "DVDTS:exist pfnEndSrb(HWint1) srb = 0x%x\r\n", pHwDevExt->pSrbDMA1 ));
				if( pHwDevExt->pSrbDMA0 == NULL ) {
					DebugPrint(( DebugLevelTrace, "DVDTS:Call TimerCppReset(HWint1)\r\n" ));
					StreamClassScheduleTimer(
						NULL,
						pHwDevExt,
						1,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->pfnEndSrb,
						((PSRB_EXTENSION)(pHwDevExt->pSrbDMA1->SRBExtension))->parmSrb
						);
				}
			}

			pHwDevExt->pSrbDMA1->Status = STATUS_SUCCESS;
			StreamClassStreamNotification( StreamRequestComplete,
											pHwDevExt->pSrbDMA1->StreamObject,
											pHwDevExt->pSrbDMA1 );
		}

		// Next DMA
		pHwDevExt->pSrbDMA1 = NULL;
		pHwDevExt->fSrbDMA1last = FALSE;
	}

	PreDMAxfer( pHwDevExt/*, val & 0x03 */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\dvdinit.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dvdinit.c

Abstract:

    Device initialization for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/

#include "strmini.h"
#include "ks.h"
#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "que.h"
#include "dvdcmd.h"
#include "DvdTDCod.h" // header for DvdTDCod.lib routines hiding proprietary HW stuff


BOOLEAN STREAMAPI HwInterrupt( IN PHW_DEVICE_EXTENSION pHwDevExt );


NTSTATUS DriverEntry( 
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath 
	)
/*++

Routine Description:

   Initial load entry point into the driver.  Initializes the key
   entry points to the mini driver.  The driver
   should then call the StreamClassRegisterAdapter function to register with
   the stream class driver.

Arguments:


   DriverObject and RegistryPath, corresponding to the Context1 and Context2 arguments
   passed from the stream class driver
   The arguments point to private plug and play structures    
   used by the stream class driver to find the resources for this
   adapter                                                       


Return Value:

   The NT_STATUS result of the registration call with the Stream Class driver
   This in turn will be the return from the SRB_INITIALIZE_DEVICE function
   call into the AdapterReceivePacket routine

   If a value other than STATUS_SUCCESS is returned, the
   minidriver will be unloaded.

--*/
{
	HW_INITIALIZATION_DATA HwInitData;
	NTSTATUS ntStatus;

	DebugPrint( (DebugLevelTrace, "DVDTS:DriverEntry\r\n") );

	RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

	HwInitData.HwInitializationDataSize = sizeof(HwInitData);
//
//
// Entry points for the mini Driver.  All entry routines will be called
// at High priority.  If the driver has a task that requires a large amount
// of time to accomplish (e.g. double buffer copying of large amounts of
// data) The driver should request a callback at lower priority to perform the
// desired function.  See the Syncronization comment for issues on re-entrancy
//
//
	HwInitData.HwInterrupt = (PHW_INTERRUPT)HwInterrupt; // ISR  routine

//
// The HwReceivePacket field describes the entry point for receiving an SRB
// Request from the stream class driver that is a request to the adapter, as
// opposed to the stream based request handlers that are initialised in the
// OpenStream function
//
	HwInitData.HwReceivePacket = AdapterReceivePacket;

//
// The HwCancelPacket entry is used to cancel any packet the minidriver may
// currently have outstanding.  This could be a stream, or an adapter based
// request.  This routine will only be called under extreme circumstances, when
// an upper layer is attempting to recover and packets are considered lost
//
	HwInitData.HwCancelPacket = AdapterCancelPacket;

//
// The HwRequestTimeoutHandler entry is used when a packet times out.  Again,
// This could be a packet for the device, or a stream based packet.  This is
// not necessarily an error, and it is up to the minidriver to determine what
// to do with the packet that has timed out.
//
	HwInitData.HwRequestTimeoutHandler = AdapterTimeoutPacket;

//
// Sizes for data structure extensions.  See mpinit.h for definitions
//
	HwInitData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
	HwInitData.PerRequestExtensionSize = sizeof(SRB_EXTENSION);
	HwInitData.PerStreamExtensionSize = sizeof(STREAMEX);
	HwInitData.FilterInstanceExtensionSize = 0;


//
// The BusMasterDMA field indicates to the system that the memory pointers passed
// in to the mini driver in the data packets may be used for direct Bus Master DMA
// access.  If the mini driver uses a translation buffer (to ensure minimum DMA
// size, or correct buffer alignment), this BOOLEAN should be set to FALSE.
//
	HwInitData.BusMasterDMA = TRUE;

//
// The Ddma24BitAddresses field indicates a device that uses DMA that only can
// access the lower 24bits of the 32 bit address space.  Again, this should only
// be set to true if the minidriver is going to be doing DMA directly to the buffer
// passed in the data packets, and not through a double buffer scenario.
//
	HwInitData.Dma24BitAddresses = FALSE;
	HwInitData.BufferAlignment = 4;
//
// If the TurnOffSynchronization field is set to FALSE, the mini driver may never
// be re-entered. Under these conditions, if the mini-driver uses a DISPATCH or lower priority
// callback routine, the miniDriver must disable any interrupts that it might
// receive.  If an interrupt controlled by the driver is received while code in
// the mini driver is running at DISPATCH or lower priority, the interrupt will
// be LOST.  If an interrupt is received while at HIGH priority, it will be queued
// until the code in the driver is finished.
//
// If the TurnOffSynchronization field is set to TRUE, the mini-driver must be
// fully capable of handling multi-processor and single processor re-entrancy
//
	HwInitData.TurnOffSynchronization = FALSE;

//
// The DmaBufferSize specifies the size of the single contiguous region of
// physical memory that the driver needs at hardware intialization time.  The
// memory will be returned to the driver when the driver makes the
// StreamClassGetDmaBuffer call.  It is important to use as little physical
// buffer as possible here, as this will be locked physical memory that is
// unavailable to the sytem, even when the streaming class mini driver is not
// in use
//
	HwInitData.DmaBufferSize = DMASIZE;

    //
    // attempt to register with the streaming class driver.  Note, this will
    // result in calls to the HW_INITIALIZE routine.
    //
	ntStatus = (
		StreamClassRegisterMinidriver(
			(PVOID)DriverObject,
			(PVOID)RegistryPath,
			&HwInitData )
	);

	if ( !NT_SUCCESS( ntStatus ) ) {
		ASSERT( 0 );

	}
	return ntStatus;
}

void GetPCIConfigSpace(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;


	if( StreamClassReadWriteConfig(

			pSrb->HwDeviceExtension,

			TRUE,						// indicates a READ (FALSE means a WRITE)

			(PVOID)&pHwDevExt->PciConfigSpace,

			0,							// this is the offset into the PCI space,
										// change this to whatever you need to read

			64							// this is the # of bytes to read.  Changer
										// it to the correct #.
		)) {

		//
		// process the config info your read here.
		//
		{
			ULONG i, j;

			DebugPrint( (DebugLevelTrace, "DVDTS:PCI Config Space\r\n" ) );

			for( i=0; i<64; ) {
				DebugPrint( (DebugLevelTrace, "DVDTS:  " ) );
				for( j=0; j<8 && i<64; j++, i++ ) {
					DebugPrint( (DebugLevelTrace, "0x%02x ", (UCHAR)*(((PUCHAR)&pHwDevExt->PciConfigSpace) + i) ) );
				}
				DebugPrint( (DebugLevelTrace, "\r\n" ) );
			}
		}
		//
		// note that the PCI_COMMON_CONFIG structure in WDM.H can be used
		// for referencing the PCI data.
		//

	}

	//
	// now return to high priority to complete initialization
	//

	StreamClassCallAtNewPriority(
		NULL,
		pSrb->HwDeviceExtension,
		LowToHigh,
		(PHW_PRIORITY_ROUTINE) InitializationEntry,
		pSrb
	);
	return;
}

void InitializationEntry(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DWORD st, et;

	st = GetCurrentTime_ms();

	HwInitialize( pSrb );

	et = GetCurrentTime_ms();
	DebugPrint( (DebugLevelTrace, "DVDTS:init %dms\r\n", et - st ) );

	StreamClassDeviceNotification( ReadyForNextDeviceRequest,
									pSrb->HwDeviceExtension );
	StreamClassDeviceNotification( DeviceRequestComplete,
									pSrb->HwDeviceExtension,
									pSrb );
}

/*
** HwInitialize()
*/
NTSTATUS HwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt =
			(PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;
	STREAM_PHYSICAL_ADDRESS	adr;
	ULONG	Size;
	PUCHAR	pDmaBuf;
	NTSTATUS Stat;
	PUCHAR	ioBase;
	BOOLEAN	bStatus;
	PVOID DecoderInfo;


	DebugPrint( (DebugLevelTrace, "DVDTS:HwInitialize()\r\n") );
	DebugPrint( (DebugLevelTrace, "DVDTS:  pHwDevExt = 0x%x\r\n", pHwDevExt ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  pSrb->HwDeviceExtension = 0x%x\r\n", pSrb->HwDeviceExtension ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  NumberOfAccessRanges = %d\r\n", ConfigInfo->NumberOfAccessRanges ) );

	if ( ConfigInfo->NumberOfAccessRanges < 1 ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:illegal config info") );
		pSrb->Status = STATUS_NO_SUCH_DEVICE;
		return( STATUS_NO_SUCH_DEVICE );
	}

	// Debug Dump ConfigInfo
	DebugPrint( (DebugLevelTrace, "DVDTS:  Port = 0x%x\r\n", ConfigInfo->AccessRanges[0].RangeStart.LowPart ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  Length = 0x%x\r\n", ConfigInfo->AccessRanges[0].RangeLength ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  IRQ = 0x%x\r\n", ConfigInfo->BusInterruptLevel ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  Vector = 0x%x\r\n", ConfigInfo->BusInterruptVector ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  DMA = 0x%x\r\n", ConfigInfo->DmaChannel ) );

	// initialize the size of stream descriptor information.
	ConfigInfo->StreamDescriptorSize =
		STREAMNUM * sizeof(HW_STREAM_INFORMATION) +
		sizeof(HW_STREAM_HEADER);

	// allocate decoder data area and put 'blind' ptr to it in our device ext
	DecoderInfo = decAllocateDecoderInfo( pHwDevExt );
	if ( !DecoderInfo ) {
		DebugPrint( (DebugLevelTrace, "DVDTS: failed to allocate decoder info buffer") );
		pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
		return( STATUS_INSUFFICIENT_RESOURCES );
	}


	// pick up the I/O windows for the card.
	pHwDevExt->ioBaseLocal =
			(PUCHAR)ConfigInfo->AccessRanges[0].RangeStart.LowPart;

	// pick up the Interrupt level
	pHwDevExt->Irq =
			ConfigInfo->BusInterruptLevel;

	// pick up the Revision id
	pHwDevExt->RevID =
			(ULONG)pHwDevExt->PciConfigSpace.RevisionID;


	pDmaBuf = (PUCHAR)StreamClassGetDmaBuffer( pHwDevExt );
	pHwDevExt->pDmaBuf = pDmaBuf;

	DebugPrint( (DebugLevelTrace, "DVDTS:  DMA Buffer Logical  Addr = 0x%x\r\n", pDmaBuf ) );

	adr = StreamClassGetPhysicalAddress( pHwDevExt, NULL, pDmaBuf, DmaBuffer, &Size) ;
	pHwDevExt->addr = adr;

	DebugPrint( (DebugLevelTrace, "DVDTS:  DMA Buffer Physical Addr = 0x%x\r\n", adr.LowPart ) );
	DebugPrint( (DebugLevelTrace, "DVDTS:  DMA Buffer Size = %d\r\n", Size ) );

	ioBase = pHwDevExt->ioBaseLocal;


	// initialize the hardware settings

	pHwDevExt->pSrbDMA0 = NULL;
	pHwDevExt->pSrbDMA1 = NULL;
	pHwDevExt->SendFirst = FALSE;
	pHwDevExt->DecodeStart = FALSE;
	pHwDevExt->TimeDiscontFlagCount = 0;

	pHwDevExt->DataDiscontFlagCount = 0;


	pHwDevExt->bKeyDataXfer = FALSE;

	pHwDevExt->CppFlagCount = 0;
	pHwDevExt->pSrbCpp = NULL;
	pHwDevExt->bCppReset = FALSE;

	pHwDevExt->XferStartCount = 0;


	pHwDevExt->dwSTCInit = 0;
	pHwDevExt->bDMAscheduled = FALSE;
	pHwDevExt->fCauseOfStop = 0;
	pHwDevExt->bDMAstop = FALSE;
	pHwDevExt->bVideoQueue = FALSE;
	pHwDevExt->bAudioQueue = FALSE;
	pHwDevExt->bSubpicQueue = FALSE;

	pHwDevExt->VideoMaxFullRate = 1 * 10000;
	pHwDevExt->AudioMaxFullRate = 1 * 10000;
	pHwDevExt->SubpicMaxFullRate = 1 * 10000;


	pHwDevExt->cOpenInputStream = 0;

	pHwDevExt->pstroVid = NULL;
	pHwDevExt->pstroAud = NULL;
	pHwDevExt->pstroSP = NULL;
	pHwDevExt->pstroYUV = NULL;
	pHwDevExt->pstroCC = NULL;



// Set Stream Mode

	if ( !decSetStreamMode( pHwDevExt, pSrb )) //tell dvdtdcod.lib to set stream modes on HW
		return FALSE; // will also set error in srb

// Set Display Mode
	decSetDisplayMode( pHwDevExt ); // set display mode on HW


// Set Audio Mode
	decSetAudioMode( pHwDevExt ); // set audio mode on HW



	// NTSC Copy Gaurd
	decSetCopyGuard( pHwDevExt ); // set copy protection on HW


	DebugPrint( (DebugLevelTrace, "DVDTS:HwInitialize() exit\r\n") );

	pSrb->Status = STATUS_SUCCESS;
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\que.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    que.h 

Abstract:

    que routines for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/
#ifndef __QUE_H__
#define __QUE_H__

#define SRBIndex(srb)	(((PSRB_EXTENSION)(srb->SRBExtension))->Index)
#define SRBpfnEndSrb(srb)	(((PSRB_EXTENSION)(srb->SRBExtension))->pfnEndSrb)
#define SRBparamSrb(srb)	(((PSRB_EXTENSION)(srb->SRBExtension))->parmSrb)

#define BLOCK_SIZE 2048

void DeviceQueue_put( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pOrigin, PHW_STREAM_REQUEST_BLOCK pSrb );

void DeviceQueue_init( PHW_DEVICE_EXTENSION pHwDevExt );
void DeviceQueue_put_video( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
void DeviceQueue_put_audio( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
void DeviceQueue_put_subpic( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
PHW_STREAM_REQUEST_BLOCK DeviceQueue_get( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last );
PHW_STREAM_REQUEST_BLOCK DeviceQueue_refer1st( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last );
PHW_STREAM_REQUEST_BLOCK DeviceQueue_refer2nd( PHW_DEVICE_EXTENSION pHwDevExt, PULONG index, PBOOLEAN last );
void DeviceQueue_remove( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL DeviceQueue_setEndAddress( PHW_DEVICE_EXTENSION pHwDevExt, PHW_TIMER_ROUTINE pfn, PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL DeviceQueue_isEmpty( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG DeviceQueue_getCount( PHW_DEVICE_EXTENSION pHwDevExt );




void CCQueue_init( PHW_DEVICE_EXTENSION pHwDevExt );
void CCQueue_put( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
PHW_STREAM_REQUEST_BLOCK CCQueue_get( PHW_DEVICE_EXTENSION pHwDevExt );
void CCQueue_remove( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL CCQueue_isEmpty( PHW_DEVICE_EXTENSION pHwDevExt );

#endif	// __QUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\driver\strmid.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    strmid.h

Abstract:

    sream descriptors and other definitions for DVDTS    

Environment:

    Kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

  Some portions adapted with permission from code Copyright (c) 1997-1998 Toshiba Corporation

Revision History:

	5/1/98: created

--*/

#include "ksmedia.h"	// Definition ?



GUID g_S3Guid = {DDVPTYPE_E_HREFL_VREFL};
GUID g_ATIGuid = {0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8};	// DDVPTYPE_BROOKTREE

// define this macro to facilitate giving the pixel format
#define MKFOURCC(ch0, ch1, ch2, ch3)    ((DWORD)(BYTE)(ch0) |           \
					((DWORD)(BYTE)(ch1) << 8) |     \
					((DWORD)(BYTE)(ch2) << 16) |    \
					((DWORD)(BYTE)(ch3) << 24 ))


/*****************************************************************************

                define the data formats used by the pins in this minidriver

*****************************************************************************/

/*

 Define the Mpeg2Video format that the minidriver supports

 */

KSDATAFORMAT hwfmtiMpeg2Vid
     = {

	sizeof (KSDATAFORMAT),
	0,
	0,
	0,

	//
	// specify media type, subtype, and format from mpeg2 video
	//

    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
	STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO,
	STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO

	};

/*

 Define the supported AC3 audio format

 */

KSDATAFORMAT_WAVEFORMATEX Mpeg2AudioFormat = {
   {
      sizeof (KSDATAFORMAT_WAVEFORMATEX),
      0,
      1,
      0,
      STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
      STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO,
      STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
   },
   {
      0,	// WAVE_FORMAT_UNKNOWN
      6,	// channels
      48000,  // sampling rate
      0,  // byte rate
      768,	// align
      0,	// resolution
      0	// extra
   }
};

/*

Define the supported LPCM audio format.

*/

KSDATAFORMAT_WAVEFORMATEX LPCMAudioFormat = {
   {
      sizeof (KSDATAFORMAT_WAVEFORMATEX),
      0,
      1,
      0,
      STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
      STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO,
      STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
   },
   {
      WAVE_FORMAT_PCM,
      2,	// channels
      48000,  // sampling rate
      192000,  // byte rate
      4,	// alignment
      16,	// bit resolution
      0	// extra
   }
};


/*

 Define the supported Sub picture format

 */

KSDATAFORMAT hwfmtiMpeg2Subpic = {
	sizeof (KSDATAFORMAT),
	0,
	0,
	0,

	//
	// specify media type, subtype
	//

    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
//	STATIC_KSDATAFORMAT_TYPE_MPEG2_PES,
	STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE,
//	STATIC_KSDATAFORMAT_FORMAT_NONE
//	STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
//	STATIC_KSDATAFORMAT_FORMAT_MPEG2_VIDEO
	STATIC_GUID_NULL
};


KSDATAFORMAT hwfmtiVPEOut
    = {
	sizeof (KSDATAFORMAT),
    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_VIDEO,
    STATIC_KSDATAFORMAT_SUBTYPE_VPVideo,
//  STATIC_KSDATAFORMAT_TYPE_VIDEO,
    STATIC_KSDATAFORMAT_SPECIFIER_NONE
//  STATIC_KSDATAFORMAT_TYPE_VIDEO
    };

KSDATAFORMAT hwfmtiCCOut
    = {
	sizeof(KSDATAFORMAT),
    0,
	200,
	0,
    STATIC_KSDATAFORMAT_TYPE_AUXLine21Data,
    STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket,
//    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    STATIC_KSDATAFORMAT_SPECIFIER_NONE
    };


//
// this array indicates that stream 0 (as constructed in sscmd.c) supports
// the MPEG 2 video format.  If stream zero supported more formats, the 
// addresses of these formats would be additional elements in this array.
//

PKSDATAFORMAT Mpeg2VidInfo[] = {
    &hwfmtiMpeg2Vid  // pointer to the MPEG 2 video format block
};

//
// this structure indicates that the audio stream supports two
// formats: AC3 (Mpeg2) and Linear PCM, as constructed above.
//

PKSDATAFORMAT AudioFormatBlocks[] = {
	(PKSDATAFORMAT) &Mpeg2AudioFormat, // pointer to the Mpeg2 format
	(PKSDATAFORMAT) &LPCMAudioFormat   // pointer to the LPCM format
};


// Sub-pic

PKSDATAFORMAT Mpeg2SubpicInfo[] = {
	&hwfmtiMpeg2Subpic  // pointer to the MPEG 2 subpic format block
};


PKSDATAFORMAT VPEInfo[] = {
    &hwfmtiVPEOut
};

PKSDATAFORMAT CCInfo[] = {   // CC output formats array
    &hwfmtiCCOut
};


/*****************************************************************************

                define the Individual property items for the video property sets

*****************************************************************************/

// Video

static const KSPROPERTY_ITEM mpegVidPropItm[]={
	{KSPROPERTY_DVDSUBPIC_PALETTE,
	FALSE,
	sizeof(KSPROPERTY),
	sizeof(KSPROPERTY_SPPAL),
	(PFNKSHANDLER) FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	}};

// Audio

static const KSPROPERTY_ITEM audPropItm[] = {

    {KSPROPERTY_AUDDECOUT_MODES,// available audio decoder output formats
        // property
        (PFNKSHANDLER) TRUE,    // get available modes is supported
        sizeof(KSPROPERTY),
        sizeof(ULONG),          // minimum size of data requested
        (PFNKSHANDLER) FALSE,   // set available modes is not supported
        NULL,
        0,
        NULL,
        NULL,
        0
    },

    {KSPROPERTY_AUDDECOUT_CUR_MODE, // current audio decoder output format
        // property
        (PFNKSHANDLER) TRUE,    // get current mode is supported
        sizeof(KSPROPERTY),
        sizeof(ULONG),          // minimum size of data requested
        (PFNKSHANDLER) TRUE,    // set current modes is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    }
};

// Sub-pic

static const KSPROPERTY_ITEM spPropItm[]={

	{KSPROPERTY_DVDSUBPIC_PALETTE,
	FALSE,
	sizeof (KSPROPERTY),
	sizeof (KSPROPERTY_SPPAL),
	(PFNKSHANDLER) TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},


	{KSPROPERTY_DVDSUBPIC_HLI,
	FALSE,
	sizeof (KSPROPERTY),
	sizeof (KSPROPERTY_SPHLI),
	(PFNKSHANDLER)TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},


	{KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,
	FALSE,
	sizeof (KSPROPERTY),
	sizeof (KSPROPERTY_COMPOSIT_ON),
	(PFNKSHANDLER)TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	}

	};

// NTSC

static const KSPROPERTY_ITEM MacroVisionPropItm[] = {
	{
		KSPROPERTY_COPY_MACROVISION,		// support for setting macrovision level
		(PFNKSHANDLER) FALSE, 		// get not supported
		sizeof (KSPROPERTY),
		sizeof (KS_COPY_MACROVISION),
		(PFNKSHANDLER) TRUE,		// set MACROVISION level supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

// VPE

static /* const */ KSPROPERTY_ITEM VideoPortPropItm[]={
	{
		KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
		(PFNKSHANDLER) TRUE,
		sizeof(KSPROPERTY),
		sizeof(ULONG),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
		(PFNKSHANDLER) TRUE,
		sizeof(KSPROPERTY),
		sizeof(ULONG),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_GETCONNECTINFO,
		(PFNKSHANDLER) TRUE,
		sizeof (KSMULTIPLE_DATA_PROP),  // minimum property input size
		sizeof (ULONG),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_SETCONNECTINFO,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),  			// minimum property input size
		sizeof (ULONG),					// minimum buffer size
		(PFNKSHANDLER)TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_VPDATAINFO,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AMVPDATAINFO),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_MAXPIXELRATE,
		(PFNKSHANDLER) TRUE,
		sizeof (KSVPSIZE_PROP),
		sizeof (KSVPMAXPIXELRATE),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_INFORMVPINPUT,
		(PFNKSHANDLER) TRUE,
		sizeof (PKSPROPERTY),
		sizeof (DDPIXELFORMAT),	// could be 0 too
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_DDRAWHANDLE,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_VIDEOPORTID,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
		(PFNKSHANDLER) TRUE,
		sizeof (KSMULTIPLE_DATA_PROP), 		// for _GET; KSPROPERTY for _SET
		sizeof (ULONG),				// could be 4 or more
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),  			// minimum property input size
		sizeof (ULONG),					// minimum buffer size
		(PFNKSHANDLER)TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_INVERTPOLARITY,
		(PFNKSHANDLER)TRUE,
		sizeof (KSPROPERTY),
		0,
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
		(PFNKSHANDLER)TRUE,
		sizeof (KSPROPERTY),
		sizeof (BOOL),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_VPCONFIG_SCALEFACTOR,
		(PFNKSHANDLER)TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AMVPSIZE),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

// CC

static /* const */ KSPROPERTY_ITEM CCPropItm[] = {
	{
		KSPROPERTY_CONNECTION_ALLOCATORFRAMING,	// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSALLOCATOR_FRAMING),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_CONNECTION_STATE,			// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSSTATE),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

// Copy Protect

static const KSPROPERTY_ITEM cppPropItm[]={

	{
		KSPROPERTY_DVDCOPY_CHLG_KEY,
		(PFNKSHANDLER) TRUE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_CHLGKEY ),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_DVDCOPY_DVD_KEY1,
		FALSE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_BUSKEY ),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_DVDCOPY_DEC_KEY2,
		(PFNKSHANDLER) TRUE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_BUSKEY ),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_DVDCOPY_TITLE_KEY,
		FALSE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_TITLEKEY ),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_DVDCOPY_DISC_KEY,
		FALSE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_DISCKEY ),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_DVDCOPY_SET_COPY_STATE,
		(PFNKSHANDLER)TRUE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_SET_COPY_STATE ),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

//	{KSPROPERTY_DVDCOPY_REGION,  // DVD region request
//								 // the minidriver shall fit in exactly
//								 // one region bit, corresponding to the region
//   								 // that the decoder is currently in
//        (PFNKSHANDLER)TRUE,
//        sizeof(KSPROPERTY),
//        sizeof(KS_DVDCOPY_REGION),	 // minimum size of data requested
//        (PFNKSHANDLER)FALSE,     // set key is not valid
//        NULL,
//        0,
//        NULL,
//        NULL,
//        0
//    },
};

// Rate Change

static const KSPROPERTY_ITEM RateChangePropItm[]={

	{
		KS_AM_RATE_SimpleRateChange,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_SimpleRateChange),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},


	{
		KS_AM_RATE_ExactRateChange,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_ExactRateChange),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},


	{
		KS_AM_RATE_MaxFullDataRate,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_MaxFullDataRate),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},


	{
		KS_AM_RATE_Step,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_Step),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	}
};

/*****************************************************************************

				define the array of video property sets supported

*****************************************************************************/

//GUID Mpeg2Vid = {STATIC_KSPROPSETID_Mpeg2Vid};

// original is const
// modify for except warning
static /* const*/ KSPROPERTY_SET mpegVidPropSet[] = {
	{
		&KSPROPSETID_Mpeg2Vid,
		SIZEOF_ARRAY(mpegVidPropItm),
		(PKSPROPERTY_ITEM)mpegVidPropItm
	},
	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(cppPropItm),
		(PKSPROPERTY_ITEM)cppPropItm
	},
	{
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm
	},

//    {
//    	&KSPROPSETID_CopyProt,
//    	SIZEOF_ARRAY(MacroVisionPropItm),
//    	(PKSPROPERTY_ITEM) MacroVisionPropItm
//    }
};

static /* const*/ KSPROPERTY_SET mpegAudioPropSet[] = {
	{
		&KSPROPSETID_AudioDecoderOut,
		SIZEOF_ARRAY(audPropItm),
		(PKSPROPERTY_ITEM) audPropItm
	},
	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(cppPropItm),
		(PKSPROPERTY_ITEM)cppPropItm
	},
	{
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm
	}
};

static KSPROPERTY_SET SPPropSet[] = {
	{
		&KSPROPSETID_DvdSubPic,
		SIZEOF_ARRAY(spPropItm),
		(PKSPROPERTY_ITEM)spPropItm
	},
	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(cppPropItm),
		(PKSPROPERTY_ITEM)cppPropItm
	},
	{
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm
	}
};

GUID vpePropSetid = {STATIC_KSPROPSETID_VPConfig};

static /* const */ KSPROPERTY_SET VideoPortPropSet[] = {
	&vpePropSetid,
	SIZEOF_ARRAY(VideoPortPropItm),
	(PKSPROPERTY_ITEM)VideoPortPropItm
};

static /* const */ KSPROPERTY_SET CCPropSet[] = {
	&KSPROPSETID_Connection,
	SIZEOF_ARRAY(CCPropItm),
	(PKSPROPERTY_ITEM) CCPropItm
};

/*****************************************************************************

				other

*****************************************************************************/

static const KSTOPOLOGY_CONNECTION Connections[] = {
/*  FromNode   FromPin           ToNode   ToPin          */
   {(ULONG)-1,        strmVideo,        (ULONG)-1,      strmCCOut},
   {(ULONG)-1,        strmVideo,        (ULONG)-1,      strmYUVVideo},
   {(ULONG)-1,        strmSubpicture,   (ULONG)-1,      strmYUVVideo}
};

static const KSTOPOLOGY Topology = {
	1,
	(GUID *) & KSCATEGORY_DATADECOMPRESSOR,
	0,
	NULL,
   SIZEOF_ARRAY (Connections),
   Connections
};

KSEVENT_ITEM VPEventItm[] =
{
	{
		KSEVENT_VPNOTIFY_FORMATCHANGE,
		0,
		0,
		NULL,
		NULL,
		NULL
	}
};

GUID MY_KSEVENTSETID_VPNOTIFY = {STATIC_KSEVENTSETID_VPNotify};

KSEVENT_SET VPEventSet[] =
{
	{
		&MY_KSEVENTSETID_VPNOTIFY,
		SIZEOF_ARRAY(VPEventItm),
		VPEventItm,
	}
};

KSEVENT_ITEM ClockEventItm[] =
{
	{
        KSEVENT_CLOCK_POSITION_MARK,		// position mark event supported
		sizeof (KSEVENT_TIME_MARK),			// requires this data as input
		sizeof (KSEVENT_TIME_MARK),			// allocate space to copy the data
		NULL,
		NULL,
		NULL
	},
	{
		KSEVENT_CLOCK_INTERVAL_MARK,		// interval mark event supported
		sizeof (KSEVENT_TIME_INTERVAL),		// requires interval data as input
		sizeof (MYTIME),					// we use an additional workspace of
											// size longlong for processing
											// this event
		NULL,
		NULL,
		NULL
	}
};

KSEVENT_SET ClockEventSet[] =
{
	{
		&KSEVENTSETID_Clock,
		SIZEOF_ARRAY(ClockEventItm),
		ClockEventItm,
	}
};


// device property

typedef struct _DevPropData {
	DWORD	data;
} DEVPROPDATA, *PDEVPROPDATA;

static const KSPROPERTY_ITEM devicePropItm[]={
	{0,
	(PFNKSHANDLER)TRUE,
	sizeof(KSPROPERTY),
	sizeof(DEVPROPDATA),
	(PFNKSHANDLER)TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	}};

static /* const*/ KSPROPERTY_SET devicePropSet[] = {
	&GUID_NULL,
	SIZEOF_ARRAY(devicePropItm),
	(PKSPROPERTY_ITEM)devicePropItm
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cadec.h ===
//***************************************************************************
//	Audio decoder header
//
//***************************************************************************

#ifndef __CADEC_H__
#define __CADEC_H__


UCHAR INVERSE_BYTE( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR uc );


// ***************************************************************************
//        T C 6 8 0 0 A F
// ***************************************************************************

void AUDIO_TC6800_INIT_PCM(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_TC6800_INIT_AC3(PHW_DEVICE_EXTENSION pHwDevExt );
void AUDIO_TC6800_INIT_MPEG(PHW_DEVICE_EXTENSION pHwDevExt );
void AUDIO_TC6800_DATA_OFF(PHW_DEVICE_EXTENSION pHwDevExt );

// ***************************************************************************
//        Z R 3 8 5 2 1 
// ***************************************************************************

void AUDIO_ZR385_OUT( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR val );
void AUDIO_ZR385_DOWNLOAD( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pData, ULONG size );
void AUDIO_ZR38521_BOOT_AC3(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_ZR38521_BOOT_MPEG(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_ZR38521_BOOT_PCM(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_CFG(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_PCMX(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_AC3(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_MPEG1(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_PLAY(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_MUTE_OFF(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_MUTE_ON(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_STOP(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_STOPF(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_STCR(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_VDSCR_ON( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc );
NTSTATUS AUDIO_ZR38521_VDSCR_OFF( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc );
NTSTATUS AUDIO_ZR38521_AVSYNC_OFF( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc );
NTSTATUS AUDIO_ZR38521_AVSYNC_ON( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc );
NTSTATUS AUDIO_ZR38521_STAT( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pDiff );
NTSTATUS AUDIO_ZR38521_KCOEF(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_ZR38521_REPEAT_02(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_ZR38521_REPEAT_16(PHW_DEVICE_EXTENSION pHwDevExt);
NTSTATUS AUDIO_ZR38521_BFST( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pErrCode );

// ***************************************************************************
//        T C 9 4 2 5 F
// ***************************************************************************

void AUDIO_TC9425_INIT_DIGITAL(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_TC9425_INIT_ANALOG(PHW_DEVICE_EXTENSION pHwDevExt);
void AUDIO_TC9425_SET_VOLUME( PHW_DEVICE_EXTENSION pHwDevExt, ULONG vol );

#endif	// __CADEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cadec.c ===
//***************************************************************************
//	Audio decoder process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "cadec.h"
#include "zrnpch6.h"
#include "cdack.h"





// ***************************************************************************
//        T C 6 8 0 0 A F
// ***************************************************************************

void AUDIO_TC6800_INIT_PCM(PHW_DEVICE_EXTENSION pHwDevExt)
{
	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0xa0 );

	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x80 );
}

void AUDIO_TC6800_INIT_AC3(PHW_DEVICE_EXTENSION pHwDevExt)
{
	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x20 );

	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );
}

void AUDIO_TC6800_INIT_MPEG(PHW_DEVICE_EXTENSION pHwDevExt)
{
	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x20 );

	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );
}

void AUDIO_TC6800_DATA_OFF(PHW_DEVICE_EXTENSION pHwDevExt)
{
	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x66 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x60 );
}

// ***************************************************************************
//        Z R 3 8 5 2 1 
// ***************************************************************************

void AUDIO_ZR385_OUT( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR val )
{
	PCIF_CHECK_SERIAL(pHwDevExt);

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x08 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, val );

// necessary?
	PCIF_CHECK_SERIAL(pHwDevExt);
}

void AUDIO_ZR385_DOWNLOAD( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pData, ULONG size )
{
	ULONG i;

	for( i = 0; i < size; i++ )
		AUDIO_ZR385_OUT( pHwDevExt, *pData++ );
}

void AUDIO_ZR38521_BOOT_AC3(PHW_DEVICE_EXTENSION pHwDevExt)
{
	AUDIO_ZR385_DOWNLOAD( pHwDevExt, ZRN_AC3_DEC, sizeof(ZRN_AC3_DEC) );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioType == AUDIO_OUT_DIGITAL )
		AUDIO_ZR385_DOWNLOAD( pHwDevExt, ZRN_AC3_SPD, sizeof(ZRN_AC3_SPD) );
}

void AUDIO_ZR38521_BOOT_MPEG(PHW_DEVICE_EXTENSION pHwDevExt)
{

// not support!

}



void AUDIO_ZR38521_BOOT_PCM(PHW_DEVICE_EXTENSION pHwDevExt)
{
	AUDIO_ZR385_DOWNLOAD( pHwDevExt, ZRN_PCM, sizeof(ZRN_PCM) );
}





NTSTATUS AUDIO_ZR38521_CFG(PHW_DEVICE_EXTENSION pHwDevExt)
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x82 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x50 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x40 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x09 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x09 );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioType == AUDIO_OUT_DIGITAL )
		AUDIO_ZR385_OUT( pHwDevExt, 0x70 );
	else
		AUDIO_ZR385_OUT( pHwDevExt, 0x50 );

	AUDIO_ZR385_OUT( pHwDevExt, 0x02 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x02 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x04 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}




NTSTATUS AUDIO_ZR38521_PCMX( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x88 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x81 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x82 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0xff );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_AC3( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x85 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x08 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0x11 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0xff );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_MPEG1( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x87 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0xff );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_PLAY( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x8a );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x89 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x8b );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_STOP( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x8c );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_STOPF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x8d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_STCR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x94 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x03 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xf6 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_VDSCR_ON(  PHW_DEVICE_EXTENSION pHwDevExt ,ULONG stc )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x93 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x03 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xf4 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x02 );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 25 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 17 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 9 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 1 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0xfb );
	AUDIO_ZR385_OUT( pHwDevExt,0xc8 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_VDSCR_OFF(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x93 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x03 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xf4 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x02 );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 25 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 17 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 9 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 1 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0xfb );
	AUDIO_ZR385_OUT( pHwDevExt,0xc8 );
	AUDIO_ZR385_OUT( pHwDevExt,0x80 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_AVSYNC_OFF(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt,0x93 );
	AUDIO_ZR385_OUT( pHwDevExt,0x0d );
	AUDIO_ZR385_OUT( pHwDevExt,0x03 );
	AUDIO_ZR385_OUT( pHwDevExt,0xf4 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x02 );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 25 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 17 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 9 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 1 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0xfb );
	AUDIO_ZR385_OUT( pHwDevExt,0xc8 );
	AUDIO_ZR385_OUT( pHwDevExt,0xc0 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_AVSYNC_ON(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt,0x93 );
	AUDIO_ZR385_OUT( pHwDevExt,0x0d );
	AUDIO_ZR385_OUT( pHwDevExt,0x03 );
	AUDIO_ZR385_OUT( pHwDevExt,0xf4 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x02 );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 25 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 17 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 9 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,(UCHAR)( ( stc >> 1 ) & 0xff ) );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0xfb );
	AUDIO_ZR385_OUT( pHwDevExt,0xc8 );
	AUDIO_ZR385_OUT( pHwDevExt,0x40 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_STAT(  PHW_DEVICE_EXTENSION pHwDevExt , PULONG pDiff )
{
	UCHAR val;

	if( pDiff == NULL )
		return STATUS_UNSUCCESSFUL;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 ) {
		*pDiff = 0x0908;
		return STATUS_UNSUCCESSFUL;
	}

	*pDiff = 0;

	AUDIO_ZR385_OUT( pHwDevExt,0x8e );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );
	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

// Check DIFTH
	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );
	*pDiff |= (ULONG)val << 8;

	AUDIO_ZR385_OUT( pHwDevExt,0x00 );

// Check DIFTL
	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );
	*pDiff |= val & 0xff;

	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

NTSTATUS AUDIO_ZR38521_KCOEF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 )
		return STATUS_UNSUCCESSFUL;

	AUDIO_ZR385_OUT( pHwDevExt, 0x93 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x03 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xf0 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x03 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x59 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x7f );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x59 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

void AUDIO_ZR38521_REPEAT_02( PHW_DEVICE_EXTENSION pHwDevExt )
{

	AUDIO_ZR385_OUT( pHwDevExt, 0x93 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xc3 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x13 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xfb );
	AUDIO_ZR385_OUT( pHwDevExt, 0xd0 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x44 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
}

void AUDIO_ZR38521_REPEAT_16( PHW_DEVICE_EXTENSION pHwDevExt )
{

	AUDIO_ZR385_OUT( pHwDevExt, 0x93 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x0d );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xc3 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x01 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x13 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xfb );
	AUDIO_ZR385_OUT( pHwDevExt, 0xd3 );
	AUDIO_ZR385_OUT( pHwDevExt, 0xc4 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
}

NTSTATUS AUDIO_ZR38521_BFST(  PHW_DEVICE_EXTENSION pHwDevExt , PULONG pErrCode )
{
	UCHAR val;

	if( pErrCode == NULL )
		return STATUS_UNSUCCESSFUL;

	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );

	if( val != 0x80 ) {
		*pErrCode = 0x0908;
		return STATUS_UNSUCCESSFUL;
	}

	*pErrCode = 0;

	AUDIO_ZR385_OUT( pHwDevExt, 0x8e );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

// Check IST
	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );
	val &= 0x07;
	*pErrCode |= (ULONG)val << 8;

	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

// Check BFST
	PCIF_CHECK_SERIAL(pHwDevExt);

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SR );
	val &= 0x07;
	*pErrCode |= val;

	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );
	AUDIO_ZR385_OUT( pHwDevExt, 0x00 );

	return STATUS_SUCCESS;
}

// ***************************************************************************
//        T C 9 4 2 5 F
// ***************************************************************************

void AUDIO_TC9425_INIT_DIGITAL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = 0;

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioType != AUDIO_OUT_ANALOG )
		if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_AC3 )
			val |= 0x40;
	if( (((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioCgms & 0x02) == 0x00 ) {
		val |= 0x20;	// Copying is permitted without restriction
		DebugPrint( ( DebugLevelTrace, "DVDTS:  AUDIO Copy OK\r\n" ) );
	}
	else {
		val &= 0xDF;	// Basically no copying is permitted (depend on L-Bit below)
		DebugPrint( ( DebugLevelTrace, "DVDTS:  AUDIO Copy NG\r\n" ) );
	}

//  COPY, EMPH
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, val );

	if( (((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioCgms & 0x01) == 0x00 ) {
		val = 0x98;		// L-Bit==0; One generation of copies may be made
		DebugPrint( ( DebugLevelTrace, "DVDTS:  AUDIO 1 Time Copy OK\r\n" ) );
	}
	else {
		val = 0x99;		// L-Bit==1; No copying is permitted
		DebugPrint( ( DebugLevelTrace, "DVDTS:  AUDIO 1 Time Copy NG\r\n" ) );
	}

// Category Code, LBIT
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, val );

// Channel Num
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq == AUDIO_FS_32 )
		val = 0xc0;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq == AUDIO_FS_44 )
		val = 0x00;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq == AUDIO_FS_48 )
		val = 0x40;
	else
		val = 0x40;

// FS1, FS2, CKA1, CKA2
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, val );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x72 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );
}

void AUDIO_TC9425_INIT_ANALOG( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

// MONO, CHS, EM, EMP
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x72 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0xc0 );

//
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioType == AUDIO_OUT_DIGITAL )
		val = 0x79;
	else
		val = 0x69;
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq == AUDIO_FS_96 )
		val |= 0x04;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq == AUDIO_FS_48 )
		val |= 0x04;

// BIT, DOIN, DOSEL, IFSEL, RLS
	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, val );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x72 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0xc0 );

	AUDIO_TC9425_SET_VOLUME(   pHwDevExt ,((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioVolume );
}

void AUDIO_TC9425_SET_VOLUME(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG vol )
{
	UCHAR ucvol;

	((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioVolume = vol;

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x00 );

	ucvol = (UCHAR)vol;
	ucvol = INVERSE_BYTE( pHwDevExt, ucvol );
	ucvol = (UCHAR)( ucvol >> 1 );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x38 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, ucvol );

	PCIF_CHECK_SERIAL( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT, 0x72 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SW, 0x40 );
}

UCHAR INVERSE_BYTE(  PHW_DEVICE_EXTENSION pHwDevExt,  UCHAR uc )
{
	ULONG i;
	UCHAR retch = 0;

	for( i = 0; i < 8; i++ )
		retch |= ( uc & 0x01 ) << ( 7 - i );

	return retch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\ccap.c ===
//***************************************************************************
//	Closed Caption process
//
//***************************************************************************

#include "common.h"


#include "regs.h"


static BOOL USCC_Wait( PHW_DEVICE_EXTENSION pHwDevExt );
//--- for Debug
//static void USCC_Test( void );
//
//--- End.
void USCC_discont( PHW_DEVICE_EXTENSION pHwDevExt );

extern ULONGLONG ConvertPTStoStrm(ULONG pts);

#define USCC_BuffSize 0x200
static UCHAR USCCF[USCC_BuffSize];
static UCHAR USCC1[USCC_BuffSize];
static UCHAR USCC2[USCC_BuffSize];
WORD wUsccSize = 0;
WORD wUsccWptr = 0;
WORD wUsccRptr = 0;

void USCC_on( PHW_DEVICE_EXTENSION pHwDevExt )
{
	// User Data Interrupt Enable
	VIDEO_UDSC_INT_ON( pHwDevExt );
	// Set Read Mode (from GOP Layer, channel 0)
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x08 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_UDATA );
	VPRO_CC_ON( pHwDevExt );
	CGuard_CPGD_CC_ON( pHwDevExt );
	wUsccSize = 0;
	wUsccRptr = 0;
	wUsccWptr = 0;

//--- for Debug
//	USCC_Test( pHwDevExt );
//--- End.

}

void USCC_off( PHW_DEVICE_EXTENSION pHwDevExt )
{
	VIDEO_UDSC_INT_OFF( pHwDevExt );
	VPRO_CC_OFF( pHwDevExt );
	CGuard_CPGD_CC_OFF( pHwDevExt );
}

void USCC_get( PHW_DEVICE_EXTENSION pHwDevExt )
{
	static UCHAR ccbuff[USCC_BuffSize];
	LONG cp;
	UCHAR channels;
	UCHAR cnumber;
	UCHAR fieldFlg;
	UCHAR fieldNum;
	UCHAR field;
	UCHAR marker;
	UCHAR fswitch;
	UCHAR cc1, cc2;
	UCHAR uscc_or, uscc_and;
	LONG i;
	PHW_STREAM_REQUEST_BLOCK pSrb;
	PUCHAR pDest;
	PKSSTREAM_HEADER pPacket;
	DWORD dwSTC;

	cp = 0;

	uscc_or = 0x00;
	uscc_and = 0xFF;

	// Sometimes bad Data Come, chip bug ?
	do {
		// Check ready to read next CC data
		if( USCC_Wait( pHwDevExt )==FALSE ) {
		}
		channels = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
//		DebugPrint(( DebugLevelTrace, "DVDTS:  CC channels = 0x%x\r\n", channels ) );
	} while( channels==0x43 );

	ccbuff[cp++] = 0x43;				// 0x43 ?
	ccbuff[cp++] = 0x43;				// 0x43 ?
	ccbuff[cp++] = channels;

	// Check ready to read next CC data
	if( USCC_Wait( pHwDevExt )==FALSE ) {
	}
	cnumber = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
//	DebugPrint(( DebugLevelTrace, "DVDTS:  CC cnumber = 0x%x\r\n", cnumber ) );

	ccbuff[cp++] = (UCHAR)(cnumber | 0xF8);

	// Check ready to read next CC data
	if( USCC_Wait( pHwDevExt )==FALSE ) {
	}
	fieldFlg = fieldNum = field = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
//	DebugPrint(( DebugLevelTrace, "DVDTS:  CC field = 0x%x\r\n", field ) );

	ccbuff[cp++] = field;

	fieldFlg &= 0x80;
	fieldNum &= 0x3F;

	for( i=0; i<fieldNum; i++ ) {

		// Check ready to read next CC data
		if( USCC_Wait( pHwDevExt )==FALSE ) {
		}
		marker = fswitch = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
//		DebugPrint(( DebugLevelTrace, "DVDTS:  CC mk & sw = 0x%x", marker ) );

		ccbuff[cp++] = marker;
		
		marker &= 0xFE;
		if( marker != 0xFE ) {
//			DebugPrint(( DebugLevelTrace, "DVDTS:  CC marker is Bad = 0x%x\r\n", marker ) );
		}
		fswitch &= 0x01;

		// Check ready to read next CC data
		if( USCC_Wait( pHwDevExt )==FALSE ) {
		}
		cc1 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );

		ccbuff[cp++] = cc1;

		// Check ready to read next CC data
		if( USCC_Wait( pHwDevExt )==FALSE ) {
		}
		cc2 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );

		ccbuff[cp++] = cc2;

		if( fswitch==0x01 ) {
			USCCF[wUsccWptr] = fieldFlg;
			USCC1[wUsccWptr] = cc1;
			USCC2[wUsccWptr] = cc2;
			wUsccWptr++;
			if( wUsccWptr>=USCC_BuffSize )
				wUsccWptr = 0;
			wUsccSize++;
		}

//		DebugPrint(( DebugLevelTrace, " 0x%02x 0x%02x", cc1, cc2 ) );
		if( fswitch==0x01 ) {
			uscc_or |= (cc1 | cc2);
			uscc_and &= (cc1 & cc2);
		}
//		DebugPrint(( DebugLevelTrace, " \r\n" ) );
	}
//	DebugPrint(( DebugLevelTrace, " \r\n" ) );

	do {
		if( (READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 ) & 0x08)==0x00 )
			break;
		// Check ready to read next CC data
		if( USCC_Wait( pHwDevExt )==FALSE ) {
		}
		READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
	} while( 1 );

	//------------------------------------------------

   if (pHwDevExt->bStopCC)
   {
      return;
   }

	pSrb = CCQueue_get( pHwDevExt );

//	DebugPrint(( DebugLevelTrace, "DVDTS:  get queue CC pSrb = 0x%x\r\n", pSrb ));

	cp = 0;
	if( pSrb != NULL ) {

		if (pSrb->CommandData.DataBufferArray->FrameExtent < sizeof(KSGOP_USERDATA))
		{
			TRAP

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			pSrb->ActualBytesTransferred = 0;

			StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);

			return;
		}
		pDest = (PUCHAR)(pSrb->CommandData.DataBufferArray->Data);

		*(PULONG)pDest = 0xB2010000;
		pDest += 4;

		*pDest++ = ccbuff[cp++];
		*pDest++ = ccbuff[cp++];
		*pDest++ = ccbuff[cp++];
		*pDest++ = ccbuff[cp++];

		field = *pDest++= ccbuff[cp++];
		DebugPrint(( DebugLevelTrace, "DVDTS:CC field %d\r\n", field ));
		field &= 0x3F;

		if (pSrb->CommandData.DataBufferArray->FrameExtent <
					(field -1) * 3 + sizeof (KSGOP_USERDATA))
		{
			TRAP

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			pSrb->ActualBytesTransferred = 0;

			StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);

			return;
		}

		pSrb->CommandData.DataBufferArray->DataUsed =
			pSrb->ActualBytesTransferred =
				(field -1 ) * 3 + sizeof (KSGOP_USERDATA);

		//
		// copy the bits
		//

		for( ;field; field-- ) {

			*pDest++ = ccbuff[cp++];
			*pDest++ = ccbuff[cp++];
			*pDest++ = ccbuff[cp++];

		}

		pSrb->Status = STATUS_SUCCESS;


		pPacket = pSrb->CommandData.DataBufferArray;

		pPacket->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
					KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
		pSrb->NumberOfBuffers = 1;

		dwSTC = VIDEO_GET_STCA( pHwDevExt );
		pPacket->PresentationTime.Time = ConvertPTStoStrm( dwSTC );
		pPacket->Duration = 1000;

		DebugPrint(( DebugLevelTrace, "DVDTS:CC Notify 0x%x(0x%x(90kHz))\r\n", (DWORD)(pPacket->PresentationTime.Time), dwSTC ));

		StreamClassStreamNotification(StreamRequestComplete,
				pSrb->StreamObject,
				pSrb);

		return;
	}
	else {
//		DebugPrint(( DebugLevelTrace, "DVDTS:CCQue.get( pHwDevExt ) == NULL\r\n" ));
//		TRAP
	}

	//------------------------------------------------

}

void USCC_put( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR var;
	static LONG debCounter = 0;

	// Using later VPRO, possibly you have to add codes ( ex. subp command register )

	if( wUsccSize==0 ) {
//--- for Debug
//		USCC_Test( pHwDevExt );
//--- End.
		return;
	}

//	debCounter++;
//	if( debCounter==100 ) {
//		debCounter = 0;
//		DebugPrint(( DebugLevelTrace, "DVDTS:  USCC_put\r\n" ) );
//	}

	// Top field ; output to register CC1
	if( USCCF[wUsccRptr] == 0x80 ) {
		var = USCC1[wUsccRptr];
//		DebugPrint(( DebugLevelTrace, "DVDTS:  TOP USCC1 = %x\r\n", var ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC1, var );
		var = USCC2[wUsccRptr];
//		DebugPrint(( DebugLevelTrace, "DVDTS:  TOP USCC2 = %x\r\n", var ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC1, var );
	}
	// Bottom field ; output to register CC2
	else {
		var = USCC1[wUsccRptr];
//		DebugPrint(( DebugLevelTrace, "DVDTS:  BTM USCC1 = %x\r\n", var ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC2, var );
		var = USCC2[wUsccRptr];
//		DebugPrint(( DebugLevelTrace, "DVDTS:  BTM USCC2 = %x\r\n", var ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC2, var );

	wUsccRptr++;
	if( wUsccRptr>=USCC_BuffSize )
		wUsccRptr = 0;

	wUsccSize--;

	}

#if 0
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC1, 0x2C );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_CC1, 0x94 );
#endif
	
}

static BOOL USCC_Wait( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;
	LONG i;

	for( i=0; i<10; i++ ) {
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if( val & 0x08 )
			return( TRUE );
	}
	return( FALSE );
}

//--- for Debug
//static void USCC_Test( void )
//{
//	wUsccSize = 0;
//	wUsccWptr = 0;
//	wUsccRptr = 0;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x20;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x20;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x54;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x54;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x20;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x20;
//	wUsccWptr++;
//	wUsccSize++;
//
//	wUsccWptr++;
//
//	USCC1[wUsccWptr] = 0x5B;
//	USCC2[wUsccWptr] = 0xD0;
//	wUsccWptr++;
//	wUsccSize++;
//
//	wUsccWptr++;
//
//	USCC1[wUsccWptr] = 0x4F;
//	USCC2[wUsccWptr] = 0x4C;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x49;
//	USCC2[wUsccWptr] = 0x43;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x45;
//	USCC2[wUsccWptr] = 0x20;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x4F;
//	USCC2[wUsccWptr] = 0x46;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x46;
//	USCC2[wUsccWptr] = 0x49;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x43;
//	USCC2[wUsccWptr] = 0x45;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x52;
//	USCC2[wUsccWptr] = 0x5D;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x97;
//	USCC2[wUsccWptr] = 0x76;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x76;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x76;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0xC2;
//	USCC2[wUsccWptr] = 0xC1;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x43;
//	USCC2[wUsccWptr] = 0xCB;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0xD0;
//	USCC2[wUsccWptr] = 0xA1;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x2C;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x2C;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x2F;
//	wUsccWptr++;
//	wUsccSize++;
//
//	USCC1[wUsccWptr] = 0x94;
//	USCC2[wUsccWptr] = 0x2F;
//	wUsccWptr++;
//	wUsccSize++;
//
//}
//--- End.

void USCC_discont( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK pSrb;
	PKSSTREAM_HEADER pPacket;

	DebugPrint(( DebugLevelTrace, "DVDTS:USCC_discont( pHwDevExt )\r\n" ));

	if( pHwDevExt->pstroCC && ((PSTREAMEX)(pHwDevExt->pstroCC->HwStreamExtension))->state == KSSTATE_RUN ) {
		pSrb = CCQueue_get( pHwDevExt );
		if( pSrb ) {
			//
			// we have a request, send a discontinuity
			//

//			DebugPrint(( DebugLevelTrace, "DVDTS:  get queue CC pSrb = 0x%x\r\n", pSrb ));

			pSrb->Status = STATUS_SUCCESS;
			pPacket = pSrb->CommandData.DataBufferArray;

			pPacket->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY |
				KSSTREAM_HEADER_OPTIONSF_TIMEVALID | KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
			pPacket->DataUsed = 0;
			pSrb->NumberOfBuffers = 0;

// BUG!
// it must set PTS of packet ?
			pPacket->PresentationTime.Time = ConvertPTStoStrm( VIDEO_GET_STCA( pHwDevExt ) );
			pPacket->Duration = 1000;

			DebugPrint(( DebugLevelTrace, "DVDTS:  CC Notify %d\r\n", (DWORD)pPacket->PresentationTime.Time ));

			StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);
		}
		else
		{
			TRAP;
		}
	}
	else {
		DebugPrint(( DebugLevelTrace, "DVDTS:  CC stream not RUN\r\n" ));

	}
}

// CCQueue

void CCQueue_init( PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->CCQue.count = 0;
	pHwDevExt->CCQue.top = pHwDevExt->CCQue.bottom = NULL;
}

void CCQueue_put( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	pSrb->NextSRB = NULL;
	if ( pHwDevExt->CCQue.top == NULL ) {
		pHwDevExt->CCQue.top = pHwDevExt->CCQue.bottom = pSrb;
		pHwDevExt->CCQue.count++;
		return;
	}

	pHwDevExt->CCQue.bottom->NextSRB = pSrb;
	pHwDevExt->CCQue.bottom = pSrb;
	pHwDevExt->CCQue.count++;

	return;
}

PHW_STREAM_REQUEST_BLOCK CCQueue_get( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK srb;

	if ( pHwDevExt->CCQue.top == NULL )
		return NULL;

	srb = pHwDevExt->CCQue.top;

	pHwDevExt->CCQue.top = pHwDevExt->CCQue.top->NextSRB;

	pHwDevExt->CCQue.count--;
	if ( pHwDevExt->CCQue.count == 0 )
		pHwDevExt->CCQue.top = pHwDevExt->CCQue.bottom = NULL;

	return srb;
}

void CCQueue_remove( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_STREAM_REQUEST_BLOCK srbPrev;
	PHW_STREAM_REQUEST_BLOCK srb;

	if ( pHwDevExt->CCQue.top == NULL )
		return;

	if( pHwDevExt->CCQue.top == pSrb ) {
		pHwDevExt->CCQue.top = pHwDevExt->CCQue.top->NextSRB;
		pHwDevExt->CCQue.count--;
		if ( pHwDevExt->CCQue.count == 0 )
			pHwDevExt->CCQue.top = pHwDevExt->CCQue.bottom = NULL;

		DebugPrint(( DebugLevelTrace, "DVDTS:CCQueue_remove srb = 0x%x\r\n", pSrb ));

		return;
	}


	srbPrev = pHwDevExt->CCQue.top;
	srb = srbPrev->NextSRB;

	while ( srb != NULL ) {
		if( srb == pSrb ) {
			srbPrev->NextSRB = srb->NextSRB;
			if( srbPrev->NextSRB == pHwDevExt->CCQue.bottom )
				pHwDevExt->CCQue.bottom = srbPrev;
			pHwDevExt->CCQue.count--;

			DebugPrint(( DebugLevelTrace, "DVDTS:CCQueue_remove srb = 0x%x\r\n", pSrb ));

			break;
		}
		srbPrev = srb;
		srb = srbPrev->NextSRB;
	}
}

BOOL CCQueue_isEmpty( PHW_DEVICE_EXTENSION pHwDevExt )
{
	if( pHwDevExt->CCQue.top == NULL )
		return TRUE;
	else
		return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\ccpgd.c ===
//***************************************************************************
//	Analog Copy protection Processor process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "ccpgd.h"


//=================================================//
//  Burst Inverse line data( Color stripe off )    //
//=================================================//
ULONG CPGD_BSTLNOFF_SIZE = 0x1A;

WORD CPGD_BSTLNOFF_DATA[] = {
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000
};

//=================================================//
//  Burst Inverse line data( Color stripe 2 line)  //
//=================================================//
ULONG CPGD_BSTLN2_SIZE = 0x1A;

WORD CPGD_BSTLN2_DATA[] = {
	0x001D, 0x002E, 0x003F, 0x0050,
    0x0061, 0x0072, 0x0083, 0x0094,
    0x00A5, 0x00B6, 0x00C7, 0x00D8,
    0x00E9, 0x012C, 0x013D, 0x014E,
    0x015F, 0x0170, 0x0181, 0x0192,
    0x01A3, 0x01B4, 0x01C5, 0x01D6,
    0x01E7, 0x01F8
};

//=================================================//
//  Burst Inverse line data( Color stripe 4 line)  //
//=================================================//
ULONG CPGD_BSTLN4_SIZE = 0x1A;

WORD CPGD_BSTLN4_DATA[] = {
	0x0017, 0x002C, 0x0041, 0x0056,
    0x006B, 0x0080, 0x0095, 0x00AA,
    0x00BF, 0x00D4, 0x00E9, 0x0000,
    0x0000, 0x0128, 0x013D, 0x0152,
    0x0167, 0x017C, 0x0191, 0x01A6,
    0x01BB, 0x01D0, 0x01E5, 0x01FA,
    0x0000, 0x0000
};

//=================================================//
//  AGC data (for Y of S input)                    //
//=================================================//
WORD CPGD_AGC_Y_TBL[] = {
	0x03E7, 0x03E2, 0x03DE, 0x03D9, 0x03D5, 0x03D0, 0x03CC, 0x03C7,
	0x03C3, 0x03BE, 0x03BA, 0x03B5, 0x03B1, 0x03AC, 0x03A8, 0x03A3,
	0x039E, 0x039A, 0x0395, 0x0391, 0x038C, 0x0388, 0x0383, 0x037F,
	0x037A, 0x0376, 0x0371, 0x036D, 0x0368, 0x0363, 0x035F, 0x035A,
	0x0356, 0x0351, 0x034D, 0x0348, 0x0344, 0x033F, 0x033B, 0x0336,
	0x0332, 0x032D, 0x0329, 0x0324, 0x031F, 0x031B, 0x0316, 0x0312,
	0x030D, 0x0309, 0x0304, 0x0300, 0x02FB, 0x02F7, 0x02F2, 0x02EE,
	0x02E9, 0x02E4, 0x02E0, 0x02DB, 0x02D7, 0x02D2, 0x02CE, 0x02C9,
	0x02C5, 0x02C0, 0x02BC, 0x02B7, 0x02B3, 0x02AE, 0x02AA, 0x02A5,
	0x02A0, 0x029C, 0x0297, 0x0293, 0x028E, 0x028A, 0x0285, 0x0281,
	0x027C, 0x0278, 0x0273, 0x026F, 0x026A, 0x0265, 0x0261, 0x025C,
	0x0258, 0x0253, 0x024F, 0x024A, 0x0246, 0x0241, 0x023D, 0x0238,
	0x0234, 0x022F, 0x022B, 0x0226, 0x0221, 0x021D, 0x0218, 0x0214,
	0x020F, 0x020B, 0x0206, 0x0202, 0x01FD, 0x01F9, 0x01F4, 0x01F0,
	0x01EB, 0x01E6, 0x01E2, 0x01DD, 0x01D9, 0x01D4, 0x01D0, 0x01CB,
	0x01C7, 0x01C2, 0x01BE, 0x01B9, 0x01B5, 0x01B0, 0x01AC, 0x01A7,
	0x01A2, 0x019E, 0x0199, 0x0195, 0x0190, 0x018C, 0x0187, 0x0183,
	0x017E, 0x017A, 0x0175, 0x0171, 0x016C, 0x0167, 0x0163, 0x015E,
	0x015A, 0x0155, 0x0151, 0x014C, 0x0148, 0x0143, 0x013F, 0x013A,
	0x0136, 0x0131, 0x012D, 0x0128
};

//=================================================//
//  AGC data (for Composit input)                  //
//=================================================//
WORD CPGD_AGC_C_TBL[] = {
	0x0382, 0x037E, 0x037A, 0x0375, 0x0371, 0x036D, 0x0369, 0x0364,
	0x0360, 0x035C, 0x0358, 0x0353, 0x034F, 0x034B, 0x0347, 0x0342,
	0x033E, 0x033A, 0x0336, 0x0331, 0x032D, 0x0329, 0x0325, 0x0320,
	0x031C, 0x0318, 0x0314, 0x030F, 0x030B, 0x0307, 0x0303, 0x02FE,
	0x02FA, 0x02F6, 0x02F2, 0x02ED, 0x02E9, 0x02E5, 0x02E1, 0x02DC,
	0x02D8, 0x02D4, 0x02D0, 0x02CB, 0x02C7, 0x02C3, 0x02BF, 0x02BA,
	0x02B6, 0x02B2, 0x02AE, 0x02A9, 0x02A5, 0x02A1, 0x029D, 0x0299,
	0x0294, 0x0290, 0x028C, 0x0288, 0x0283, 0x027F, 0x027B, 0x0277,
	0x0272, 0x026E, 0x026A, 0x0266, 0x0261, 0x025D, 0x0259, 0x0255,
	0x0250, 0x024C, 0x0248, 0x0244, 0x023F, 0x023B, 0x0237, 0x0233,
	0x022E, 0x022A, 0x0226, 0x0222, 0x021D, 0x0219, 0x0215, 0x0211,
	0x020C, 0x0208, 0x0204, 0x0200, 0x01FB, 0x01F7, 0x01F3, 0x01EF,
	0x01EA, 0x01E6, 0x01E2, 0x01DE, 0x01D9, 0x01D5, 0x01D1, 0x01CD,
	0x01C9, 0x01C4, 0x01C0, 0x01BC, 0x01B8, 0x01B3, 0x01AF, 0x01AB,
	0x01A7, 0x01A2, 0x019E, 0x019A, 0x0196, 0x0191, 0x018D, 0x0189,
	0x0185, 0x0180, 0x017C, 0x0178, 0x0174, 0x016F, 0x016B, 0x0167,
	0x0163, 0x015E, 0x015A, 0x0156, 0x0152, 0x014E, 0x0149, 0x0145,
	0x0141, 0x013C, 0x0138, 0x0134, 0x0130, 0x012B, 0x0127, 0x0123,
	0x011F, 0x011A, 0x0116, 0x0112, 0x010E, 0x0109, 0x0105, 0x0101,
	0x00FD, 0x00F8, 0x00F4, 0x00F0
};


 

void CGuard_CPGD_RESET_FUNC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_RESET, 0 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_RESET, 0x80 );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG = 0x80;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG = 0;	// ? ? ?
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproAVM_REG = 0;	// ? ? ?
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount = 0;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CGMSnCPGDvalid = FALSE;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag = 0x0000;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag = 0x0000; 
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag = 0x0000;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag = 0x0000;
}

void CGuard_CPGD_VIDEO_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{

	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_RESET, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG );
}

void CGuard_CPGD_VIDEO_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
// debug
//	if ( !(((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG & 0x80) )
//		Error;
// debug

	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_RESET, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproRESET_REG );
}

void CGuard_CPGD_INIT_NTSC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG &= 0x7f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproAVM_REG &= 0x5f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_AVM, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproAVM_REG );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_DVEN, 0xc0 );
}

void CGuard_CPGD_INIT_PAL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG |= 0x80;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproAVM_REG &= 0x5f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_AVM, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproAVM_REG );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_DVEN, 0x80 );
}

void CGuard_CPGD_CC_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
//	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG &= 0xbf;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG );
}

void CGuard_CPGD_CC_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
//	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG |= 0x40;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.VproVMODE_REG );
}

void CGuard_CPGD_SUBP_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pPalData )
{
	ULONG i;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0x80 );

	for( i = 0; i < 48; i++ )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSP, *pPalData++ );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0x40 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0 );
}

void CGuard_CPGD_OSD_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pPalData )
{
	int i;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0x20 );

	for( i = 0; i < 48; i++ )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSP, *pPalData++ );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPSET, 0 );
}

BOOL CGuard_CPGD_SET_AGC_CHIP(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG rev )
{
	switch( rev ) {

		case 0x02:
		case 0x03:
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip = TC6802;
			DebugPrint( ( DebugLevelTrace, "DVDTS:  ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip: TC6802\r\n" ) );
			break;

		case 0x04:
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip = TC6814;
			DebugPrint( ( DebugLevelTrace, "DVDTS:  ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip: TC6814\r\n" ) );
			break;

		case 0x05:
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip = TC6818;
			DebugPrint( ( DebugLevelTrace, "DVDTS:  ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip: TC6818\r\n" ) );
			break;

		default :
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip = TC6818;
			DebugPrint( ( DebugLevelTrace, "DVDTS:  ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip: UNKNOWN, use parameter for TC6818\r\n" ) );
			break;

	}

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip == NO_ACG )
		return( FALSE );
	else
		return( TRUE );
}

void CGuard_CPGD_SET_ASPECT(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG aspect )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		CGuard_CPGD_SET_CGMSnCPGD( pHwDevExt, aspect, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag );
	}
}

void CGuard_CPGD_SET_LETTER(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG letter )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		CGuard_CPGD_SET_CGMSnCPGD( pHwDevExt, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag, letter, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag );
	}
}

void CGuard_CPGD_SET_CGMS(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG cgms )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		CGuard_CPGD_SET_CGMSnCPGD( pHwDevExt, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag, cgms, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag );
	}
}

void CGuard_CPGD_SET_CPGD(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG cpgd )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		CGuard_CPGD_SET_CGMSnCPGD( pHwDevExt, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag, ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag, cpgd );
	}
}

void CGuard_CPGD_SET_CGMSnCPGD(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG aspect, ULONG letter, ULONG cgms, ULONG cpgd )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip == NO_ACG ) {
		return;
	}
	else {
		// Clear unnecessary bits
		aspect &= 0x01;
		letter &= 0x01;
		cgms &= 0x03;
		cpgd &= 0x03;

		// When ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag is changed or all flags are not initialized,
		if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CGMSnCPGDvalid==FALSE || ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag!=cpgd) {
			DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSnCPGD(1)\r\n" ) );
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag = aspect;
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag = letter;
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag = cgms;
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag = cpgd;
			CGuard_CPGD_SET_CGMSparameter(pHwDevExt);
			CGuard_CPGD_SET_CPGDparameter(pHwDevExt);
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CGMSnCPGDvalid = TRUE;
		}

		// When one of Flags except ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag is changed, 
		else if ( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag!=aspect || ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag!=letter || ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag!=cgms ) {
			DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSnCPGD(2)\r\n" ) );
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag = aspect;
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag = letter;
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag = cgms;
			CGuard_CPGD_SET_CGMSparameter(pHwDevExt);
		}

		// When no flags are changed,
		else
			DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSnCPGD(3)\r\n" ) );

	}
}

void CGuard_CPGD_UPDATE_AGC(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	WORD Cval, Yval;

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount == 0 ) {
			Cval = CPGD_AGC_C_TBL[0];
			Yval = CPGD_AGC_Y_TBL[0];
			CGuard_CPGD_SET_AGC( pHwDevExt , Cval, Yval );
//			DebugPrint( ( DebugLevelTrace, "DVDTS:  AGC_C %x, AGC_Y %x\r\n", Cval, Yval ) );
		}
		else if( 720<=((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount && ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount<=875 ) {
			Cval = CPGD_AGC_C_TBL[((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount- 720];
			Yval = CPGD_AGC_Y_TBL[((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount- 720];
			CGuard_CPGD_SET_AGC( pHwDevExt , Cval, Yval );
//			DebugPrint( ( DebugLevelTrace, "DVDTS:  AGC_C %x, AGC_Y %x\r\n", Cval, Yval ) );
		}
		else if( 1044<=((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount && ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount<=1199 ) {
			Cval = CPGD_AGC_C_TBL[1199-((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount];
			Yval = CPGD_AGC_Y_TBL[1199-((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount];
			CGuard_CPGD_SET_AGC( pHwDevExt, Cval, Yval );
//			DebugPrint( ( DebugLevelTrace, "DVDTS:  AGC_C %x, AGC_Y %x\r\n", Cval, Yval ) );
		}
		((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount++;
		if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount>=1200 )
			((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdVsyncCount = 0;
	}
}

void CGuard_CPGD_SET_CGMSparameter(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	ULONG tmp;
	ULONG crc;

	tmp = ( 0x8000 | (((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.AspectFlag<<13) | (((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.LetterFlag<<12) | (((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CgmsFlag<<6) | (((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag<<4) );
	crc = CGuard_CPGD_CALC_CRC( pHwDevExt, tmp ) << 2;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAL, (UCHAR)(tmp >> 8) );
	DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAL%x\r\n", (UCHAR)(tmp>>8) ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAM, (UCHAR)(tmp & 0xFF) );
	DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAM%x\r\n", (UCHAR)(tmp&0xFF) ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAH, (UCHAR)(crc & 0xFF) );
	DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAH%x\r\n", (crc & 0xFF) ) );
}

void CGuard_CPGD_SET_CPGDparameter( PHW_DEVICE_EXTENSION pHwDevExt  )
{
	switch( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.CpgdFlag ) {
		case 0x00 :
			CGuard_CPGD_SET_CLR_STRIPE_OFF(pHwDevExt);
			CGuard_CPGD_SET_CPGD_0(pHwDevExt);
			break;
		case 0x01 :
			CGuard_CPGD_SET_CLR_STRIPE_OFF(pHwDevExt);
			CGuard_CPGD_SET_CPGD_1(pHwDevExt);
			break;
		case 0x02 :
			CGuard_CPGD_SET_CLR_STRIPE_2(pHwDevExt);
			CGuard_CPGD_SET_CPGD_2(pHwDevExt);
			break;
		case 0x03 :
			CGuard_CPGD_SET_CLR_STRIPE_4(pHwDevExt);
			CGuard_CPGD_SET_CPGD_3(pHwDevExt);
			break;
		default   :
			TRAP;
			break;
	}
}

void CGuard_CPGD_SET_CGMS_A_0(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG aspect, ULONG letter )
{
	ULONG temp = 0x8000;
	ULONG crc;

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		if( letter!=0 )
			temp |= 0x1000;
		if( aspect!=0 )
			temp |= 0x2000;
		temp |= 0xC0;
		crc = CGuard_CPGD_CALC_CRC( pHwDevExt ,temp ) << 2;
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAL, (UCHAR)(temp >> 8) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAL%x\r\n", (UCHAR)(temp>>8) ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAM, (UCHAR)(temp & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAM%x\r\n", (UCHAR)(temp&0xFF) ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAH, (UCHAR)(crc & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAH%x\r\n", (crc & 0xFF) ) );
	}
}

void CGuard_CPGD_SET_CGMS_A_1(  PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect, ULONG letter )
{
	ULONG temp = 0x8000;
	ULONG crc;

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		if( letter!=0 )
			temp |= 0x1000;
		if( aspect!=0 )
			temp |= 0x2000;
		temp |= 0xD0;
		crc = CGuard_CPGD_CALC_CRC( pHwDevExt ,temp ) << 2;
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAL, (UCHAR)(temp >> 8) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAL%x\r\n", (UCHAR)(temp>>8) ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAM, (UCHAR)(temp & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAM%x\r\n", (UCHAR)(temp&0xFF) ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAH, (UCHAR)(crc & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSAH%x\r\n", (crc & 0xFF) ) );
	}
}

void CGuard_CPGD_SET_CGMS_A_2(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG aspect, ULONG letter )
{
	ULONG temp = 0x8000;
	ULONG crc;
	
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		if( letter!=0 )
			temp |= 0x1000;
		if( aspect!=0 )
			temp |= 0x2000;
		temp |= 0xE0;
		crc = CGuard_CPGD_CALC_CRC( pHwDevExt, temp ) << 2;
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAL, (UCHAR)(temp >> 8) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA L = %x\r\n", temp>>8 ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAM, (UCHAR)(temp & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA M = %x\r\n", temp & 0xFF ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAH, (UCHAR)(crc & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA H = %x\r\n", crc & 0xFF ) );
	}
}

void CGuard_CPGD_SET_CGMS_A_3(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG aspect, ULONG letter )
{
	ULONG temp = 0x8000;
	ULONG crc;
	
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		if( letter!=0 )
			temp |= 0x1000;
		if( aspect!=0 )
			temp |= 0x2000;
		temp |= 0xF0;
		crc = CGuard_CPGD_CALC_CRC( pHwDevExt,temp ) << 2;
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAL, (UCHAR)(temp >> 8) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA L = %x\r\n", temp>>8 ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAM, (UCHAR)(temp & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA M = %x\r\n", temp & 0xFF ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CGMSAH, (UCHAR)(crc & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  CGMSA H = %x\r\n", crc & 0xFF ) );
	}
}

void CGuard_CPGD_SET_CLR_STRIPE_OFF(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	// notes:	*1 are unnecessary originally (if TC6802 is on board).
	//			But I have to use TC6802 parameters when TC6814/TC6818 is on board for beta 3
	//			because I can't get RevID ( I can't know which ACG chip is ).
	//			These codes make safe when TC6814/TC6818 is, of cource TC6802 is, NO PROBLEM.

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6802 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );		// *1
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );		// *1
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_OFF for TC6802\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6814 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		CGuard_CPGD_SET_BURST( pHwDevExt, CPGD_BSTLNOFF_DATA, CPGD_BSTLNOFF_SIZE );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_OFF for TC6814\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6818 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0x04 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x80 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_OFF for TC6818\r\n" ) );
	}
}

void CGuard_CPGD_SET_CLR_STRIPE_2(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6802 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAA );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_2 for TC6802\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6814 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAE );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_2 for TC6814\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6818 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0x04 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x80 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAE );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_2 for TC6818\r\n" ) );
	}
	CGuard_CPGD_SET_BURST( pHwDevExt, CPGD_BSTLN2_DATA, CPGD_BSTLN2_SIZE );
}

void CGuard_CPGD_SET_CLR_STRIPE_4(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6802 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAA );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_4 for TC6802\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6814 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xFE );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x00 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAE );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_4 for TC6814\r\n" ) );
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==TC6818 ) {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0xB1 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTINT, 0x04 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTONY, 0x80 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0x84 );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTSE, 0xAE );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CLR_STRIPE_4 for TC6818\r\n" ) );
	}
	CGuard_CPGD_SET_BURST( pHwDevExt, CPGD_BSTLN4_DATA, CPGD_BSTLN4_SIZE );
}

void CGuard_CPGD_SET_CPGD_0(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPG, 0x00 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CPGD_0\r\n" ) );
	}
}

void CGuard_CPGD_SET_CPGD_1(  PHW_DEVICE_EXTENSION pHwDevExt )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPG, 0xE8 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CPGD_1\r\n" ) );
	}
}

void CGuard_CPGD_SET_CPGD_2(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPG, 0xF8 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CPGD_2\r\n" ) );
	}
}

void CGuard_CPGD_SET_CPGD_3(  PHW_DEVICE_EXTENSION pHwDevExt  )
{
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->CPgd.ACGchip==NO_ACG ) {
		return;
	}
	else {
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CPG, 0xF8 );
		DebugPrint( ( DebugLevelTrace, "DVDTS:  SET_CPGD_3\r\n" ) );
	}
}

void CGuard_CPGD_SET_BURST(  PHW_DEVICE_EXTENSION pHwDevExt , PWORD data, ULONG size )
{
	ULONG i;
	WORD temp;

	for( i=0; i<size; i++ ) {
		temp = (WORD)((*(data+i)) & 0x3FF);
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTLSL, (UCHAR)(temp & 0xFF) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  BURST L %x\r\n", temp & 0xFF ) );
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_BSTLSH, (UCHAR)(temp >> 8) );
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  BURST H %x\r\n", temp >> 8 ) );
	}
}

void CGuard_CPGD_SET_AGC(  PHW_DEVICE_EXTENSION pHwDevExt , WORD Cval, WORD Yval )
{
	WORD	Lval;

	Lval = (WORD)(((Yval & 0x03) << 4) + ((Cval & 0x03) << 6));
	Cval >>= 2;
	Yval >>= 2;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_CAGC, (UCHAR)Cval );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_YAGC, (UCHAR)Yval );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + CPGD_LAGC, (UCHAR)Lval );
}

ULONG CGuard_CPGD_CALC_CRC(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG val )
{
	ULONG crc = 0;
	ULONG i, j;

	crc = (val & 0x3FFF) << 6;

	i = 0x80000000;
	j = 0x86000000;					// 100001100....00(b)

	do {
//		DebugPrint( ( DebugLevelTrace, "DVDTS:  i=%x, j=%x, crc=%x\r\n", i, j, crc ) );
		if( (crc & i)==0 ) {
			i >>= 1;
			j >>= 1;
			if( i<=0x20 )
				break;
		}
		else {
			crc ^= j;
		}
	} while( 1 );

	return( crc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\ccpgd.h ===
//***************************************************************************
//	Analog Copy protection Processor header
//
//***************************************************************************

#ifndef __CCPGD_H__
#define __CCPGD_H__



void CGuard_CPGD_SET_CGMSparameter( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CPGDparameter( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_BURST( PHW_DEVICE_EXTENSION pHwDevExt,PWORD data, ULONG size );
void CGuard_CPGD_SET_AGC( PHW_DEVICE_EXTENSION pHwDevExt, WORD Cval, WORD Yval );
ULONG CGuard_CPGD_CALC_CRC( PHW_DEVICE_EXTENSION pHwDevExt, ULONG val );
void CGuard_CPGD_SET_CGMS_A_0( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect, ULONG letter );
void CGuard_CPGD_SET_CGMS_A_1( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect, ULONG letter );
void CGuard_CPGD_SET_CGMS_A_2( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect, ULONG letter );
void CGuard_CPGD_SET_CGMS_A_3( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect, ULONG letter );
void CGuard_CPGD_SET_CLR_STRIPE_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CLR_STRIPE_2( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CLR_STRIPE_4( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CPGD_0( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CPGD_1( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CPGD_2( PHW_DEVICE_EXTENSION pHwDevExt );
void CGuard_CPGD_SET_CPGD_3( PHW_DEVICE_EXTENSION pHwDevExt );

void CGuard_CPGD_RESET_FUNC(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_VIDEO_MUTE_ON(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_VIDEO_MUTE_OFF(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_INIT_NTSC(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_INIT_PAL(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_CC_ON(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_CC_OFF(PHW_DEVICE_EXTENSION pHwDevExt);
void CGuard_CPGD_SUBP_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pPalData );
void CGuard_CPGD_OSD_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pPalData );
BOOL CGuard_CPGD_SET_AGC_CHIP( PHW_DEVICE_EXTENSION pHwDevExt, ULONG rev );
void CGuard_CPGD_SET_ASPECT( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect );
void CGuard_CPGD_SET_LETTER( PHW_DEVICE_EXTENSION pHwDevExt, ULONG letter );
void CGuard_CPGD_SET_CGMS( PHW_DEVICE_EXTENSION pHwDevExt,ULONG cgms );
void CGuard_CPGD_SET_CPGD( PHW_DEVICE_EXTENSION pHwDevExt,ULONG cpgd );
void CGuard_CPGD_SET_CGMSnCPGD( PHW_DEVICE_EXTENSION pHwDevExt,ULONG aspect, ULONG letter, ULONG cgms, ULONG cpgd);
void CGuard_CPGD_UPDATE_AGC( PHW_DEVICE_EXTENSION pHwDevExt );


#endif  // __CCPGD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\ccpp.c ===
//***************************************************************************
//	Copy protect process
//
//***************************************************************************

#include "common.h"
#include "ccpp.h"

void Cpp_outp( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR index, UCHAR data )
{
	WRITE_PORT_UCHAR( (PUCHAR)( pHwDevExt->ioBaseLocal + CG_INDEX ), (UCHAR)index );
	WRITE_PORT_UCHAR( (PUCHAR)( pHwDevExt->ioBaseLocal + CG_DATA ),  data );
}

UCHAR Cpp_inp( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR index )
{
	WRITE_PORT_UCHAR( (PUCHAR)( pHwDevExt->ioBaseLocal + CG_INDEX ), (UCHAR)index );
	return READ_PORT_UCHAR( (PUCHAR)( pHwDevExt->ioBaseLocal + CG_DATA ) );
}

void Cpp_wait( PHW_DEVICE_EXTENSION pHwDevExt, ULONG msec )
{
	DWORD st, et;
	st = GetCurrentTime_ms();
	for( ; ; ) {
		KeStallExecutionProcessor( 1 );
		et = GetCurrentTime_ms();
		if( st + msec * 10 < et )
			break;
	}
}

BOOLEAN Cpp_cmd_wait_loop( PHW_DEVICE_EXTENSION pHwDevExt )
{
	int i;

	for ( i = 0; i < 100; i++ )
	{
		if ( ( Cpp_inp( pHwDevExt, COM ) & 0xc0 ) != 0 )
			break;
		Cpp_wait( pHwDevExt, 1 );
	}
	if ( ( Cpp_inp( pHwDevExt, COM ) & 0x40 ) == 0x40 )
		return FALSE;
	else
		return TRUE;
}

BOOLEAN Cpp_decoder_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r1 )
{
	int i;

	Cpp_outp( pHwDevExt, COM, CMD_DEC_RAND );
	for ( i = 0; i < 10; i++ )
		r1->ChlgKey[i] = Cpp_inp( pHwDevExt, (UCHAR)(CHGG1 + i) );
	r1->Reserved[0] = r1->Reserved[1] = 0;
	return TRUE;
}

BOOLEAN Cpp_drive_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr1 )
{
	int i;
	Cpp_outp( pHwDevExt, COM, CMD_NOP );
	for ( i = 0; i < 5; i++ )
		Cpp_outp( pHwDevExt, (UCHAR)(RSPG1 + i), fsr1->BusKey[i] );
	Cpp_outp( pHwDevExt, COM, CMD_DRV_AUTH );
	return Cpp_cmd_wait_loop(pHwDevExt );
}

BOOLEAN Cpp_drive_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r2 )
{
	int i;

	for ( i = 0; i < 10; i++ )
		Cpp_outp( pHwDevExt, (UCHAR)(CHGG1 + i), r2->ChlgKey[i] );
	Cpp_outp( pHwDevExt, COM, CMD_DEC_AUTH );
	return Cpp_cmd_wait_loop(pHwDevExt);
}

BOOLEAN Cpp_decoder_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr2 )
{
	int i;

	for ( i = 0; i < 5; i++ )
		fsr2->BusKey[i] = Cpp_inp( pHwDevExt, (UCHAR)(RSPG1 + i) );
	return TRUE;
}

BOOLEAN Cpp_DiscKeyStart(PHW_DEVICE_EXTENSION pHwDevExt)
{
	Cpp_outp( pHwDevExt, COM, CMD_DEC_DKY );
	return TRUE;
}

BOOLEAN Cpp_DiscKeyEnd(PHW_DEVICE_EXTENSION pHwDevExt)
{
	return Cpp_cmd_wait_loop(pHwDevExt);
}

BOOLEAN Cpp_TitleKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY tk )
{
	int i;
	BOOLEAN stat;

	Cpp_outp( pHwDevExt, ETKG1 + 0, (UCHAR)(tk->KeyFlags) );
	for ( i = 1; i < 6; i++ )
		Cpp_outp( pHwDevExt, (UCHAR)(ETKG1 + i), tk->TitleKey[i-1] );
	Cpp_outp( pHwDevExt, COM, CMD_NOP );
	Cpp_outp( pHwDevExt, COM, CMD_DEC_DTK );
	stat = Cpp_cmd_wait_loop(pHwDevExt);
	Cpp_outp( pHwDevExt, COM, CMD_NOP );
	Cpp_outp( pHwDevExt, COM, CMD_DEC_DT );

	return stat;
}



BOOLEAN Cpp_reset( PHW_DEVICE_EXTENSION pHwDevExt, CPPMODE mode )
{
	UCHAR val;

// Reset TC6808AF
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + 0x27 );
	val |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + 0x27, val );
	Cpp_wait( pHwDevExt, 10 );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + 0x27 );
	val &= 0xef;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + 0x27, val );

//	_outp( (WORD)( pIO_Base + 0x27 ), _inp( (WORD)( pIO_Base + 0x27 ) ) | 0x10 );
//	dcg_wait( 10 );
//	_outp( (WORD)( pIO_Base + 0x27 ), _inp( (WORD)( pIO_Base + 0x27 ) ) & 0xef );


// Set Registers
	Cpp_outp( pHwDevExt, CNT_1, 0xe3 );	// ???????????????
	if ( mode == NO_GUARD )
		Cpp_outp( pHwDevExt, CNT_2, CNT2_DEFAULT + 0x01 );
	else
		Cpp_outp( pHwDevExt, CNT_2, CNT2_DEFAULT );
	Cpp_outp( pHwDevExt, DETP_L, 0x00 );
	Cpp_outp( pHwDevExt, DETP_M, 0x00 );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cdack.c ===
//***************************************************************************
//	PCI Interface(DACK) process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "cdack.h"

extern DWORD GetCurrentTime_ms( void );


NTSTATUS PCIF_RESET( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DWORD st, et;
	UCHAR val;
	UCHAR	initpaldata[256];
	int	i;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, 0x80 );
	((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.DigitalOutMode = 0x00;

	st = GetCurrentTime_ms();
	for( ; ; ) {
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
		if( ( val & 0x80 ) != 0x80 )
			break;

		et = GetCurrentTime_ms();
		if( st + 10000 < et ) {
			TRAP;
			return STATUS_UNSUCCESSFUL;
		}
	}


	for( i = 0; i < 256; i++ )
		initpaldata[i] = (UCHAR)i;

	PCIF_SET_PALETTE( pHwDevExt, PALETTE_Y, initpaldata );
	PCIF_SET_PALETTE( pHwDevExt, PALETTE_Cb, initpaldata );
	PCIF_SET_PALETTE( pHwDevExt, PALETTE_Cr, initpaldata );

	return STATUS_SUCCESS;
}

void PCIF_AMUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_AMUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_AMUTE2_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val |= 0x20;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_AMUTE2_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xdf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_VSYNC_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_VSYNC_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xef;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_PACK_START_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_PSCNT, 0x04 );
}

void PCIF_PACK_START_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_PSCNT, 0x00 );
}

void PCIF_SET_DIGITAL_OUT( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR mode )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.DigitalOutMode = mode;

	PCIF_SET_PALETTE( pHwDevExt,PALETTE_Y, ((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.paldata[PALETTE_Y-1] );
	PCIF_SET_PALETTE( pHwDevExt,PALETTE_Cb, ((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.paldata[PALETTE_Cb-1] );
	PCIF_SET_PALETTE( pHwDevExt,PALETTE_Cr, ((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.paldata[PALETTE_Cr-1] );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_VMODE, mode );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_HSCNT, 0x70 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_VSCNT, 0x0b );
	if ( mode == 0x04 )	// S3 LPB
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_HSVS, 0x00 );
	else
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_HSVS, 0x00 );
}

void PCIF_SET_DMA0_SIZE( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize )
{
	UCHAR val;

	if ( dmaSize == 0 )
		return;

	dmaSize--;

	// select MTC-0
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xf8;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );

	// write DMA size
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCLL, (UCHAR)( dmaSize & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCLH, (UCHAR)( ( dmaSize >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCHL, (UCHAR)( ( dmaSize >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCHH, (UCHAR)( ( dmaSize >> 24 ) & 0xff ) );
}

void PCIF_SET_DMA1_SIZE( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize )
{
	UCHAR val;

	if ( dmaSize == 0 )
		return;

	dmaSize--;

	// select MTC-1
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xf8;
	val |= 0x04;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );

	// write DMA size
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCLL, (UCHAR)( dmaSize & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCLH, (UCHAR)( ( dmaSize >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCHL, (UCHAR)( ( dmaSize >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MTCHH, (UCHAR)( ( dmaSize >> 24 ) & 0xff ) );
}

void PCIF_SET_DMA0_ADDR( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr )
{
	UCHAR val;

	// select MTC-0
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xf8;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );

	// write DMA0 address
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRLL, (UCHAR)( dmaAddr & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRLH, (UCHAR)( ( dmaAddr >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRHL, (UCHAR)( ( dmaAddr >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRHH, (UCHAR)( ( dmaAddr >> 24 ) & 0xff ) );
}

void PCIF_SET_DMA1_ADDR( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr )
{
	UCHAR val;

	// select MTC-1
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xf8;
	val |= 0x04;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );

	// write DMA1 address
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRLL, (UCHAR)( dmaAddr & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRLH, (UCHAR)( ( dmaAddr >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRHL, (UCHAR)( ( dmaAddr >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_MADRHH, (UCHAR)( ( dmaAddr >> 24 ) & 0xff ) );
}

void PCIF_DMA0_START( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xfc;
	val |= 0x01;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_DMA1_START( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL );
	val &= 0xfc;
	val |= 0x02;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CNTL, val );
}

void PCIF_SET_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR select, PUCHAR pPalette )
{
	int i;
	UCHAR val;

	ASSERT( PALETTE_Y <= select && select <= PALETTE_Cr );

	for ( i = 0; i < 256; i++ )
		((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.paldata[select-1][i] = pPalette[i];

	val = (UCHAR)( ( READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPCNT ) & 0xFC ) | select | 0x04 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPCNT, val );	// clear color palette pointer

	for ( i = 0; i < 256; i++ ) {
		// DACK bug recovery. Use value from 0x07 to 0xFD in AMC mode and setting Palette Y.
		if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->DAck.DigitalOutMode == 0x07 ) {
			if( select == PALETTE_Y ) {
				// convert 0x00 to 0xFF --> 0x07 to 0xFD
				//     round up numbers of five and above and drop anything under five
				val = (UCHAR)(((LONG)pPalette[i] * 246 * 2 + 255) / (255 * 2) + 7);
			}
			else {
				if( pPalette[i] > 253 )
					val = 253;
				else
					val = pPalette[i];
			}
		}
		else
			val = pPalette[i];

		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPLT, val );
	}
}

void PCIF_GET_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR select, PUCHAR pPalette )
{
	int i;
	UCHAR val;

	val = (UCHAR)( ( READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPCNT ) & 0xFC ) | select | 0x04 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPCNT, val );	// clear color palette pointer
	for ( i = 0; i < 256; i++ )
		pPalette[i] = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_CPLT );
}

void PCIF_CHECK_SERIAL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DWORD st, et;
	UCHAR val;

	st = GetCurrentTime_ms();
	for( ; ; ) {
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_SCNT );
		if( ( val & 0x80 ) != 0x80 )
			break;

		et = GetCurrentTime_ms();
		if( st + 10000 < et ) {
			TRAP;
			break;
		}
	}
}

void PCIF_DMA_ABORT( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_INTF, 0x04 );
}

void PCIF_ALL_IFLAG_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_INTF );
	val |= 0x23;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_INTF, val );
}

void PCIF_ASPECT_0403( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_TEST );
	val |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_TEST, val );
}

void PCIF_ASPECT_1609( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_TEST );
	val &= 0xef;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + PCIF_TEST, val );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\common.h ===
//***************************************************************************
//	Common header
//
//***************************************************************************

#ifndef __COMMON_H
#define __COMMON_H
#endif


#include "strmini.h"
#include "ks.h"
#include "ksmedia.h"

#include "debug.h"
#include "dvdinit.h"
#include "que.h"
#include "dvdtdcod.h"

#include "decoder.h"
#include "cdack.h"
#include "cvdec.h"
#include "cadec.h"
#include "cvpro.h"
#include "ccpgd.h"
#include "ccpp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\ccpp.h ===
//***************************************************************************
//	Copy protect header
//
//***************************************************************************

#ifndef __CCPP_H__
#define __CCPP_H__

#include "ksmedia.h"

#define	CG_INDEX		0xc0
#define	CG_DATA			0xc1

#define COM				0x00
#define CNT_1			0x01
#define CNT_2			0x02
#define SD_STS			0x03
#define DETP_L			0x04
#define DETP_M			0x05

#define VER				0x0f

#define ETKG1			0x10
#define ETKG2			0x11
#define ETKG3			0x12
#define ETKG4			0x13
#define ETKG5			0x14
#define ETKG6			0x15

#define ACC				0x20

#define CHGG1			0x30
#define CHGG2			0x31
#define CHGG3			0x32
#define CHGG4			0x33
#define CHGG5			0x34
#define CHGG6			0x35
#define CHGG7			0x36
#define CHGG8			0x37
#define CHGG9			0x38
#define CHGG10			0x39

#define RSPG1			0x40
#define RSPG2			0x41
#define RSPG3			0x42
#define RSPG4			0x43
#define RSPG5			0x44

#define CMD_NOP			0x00
#define CMD_DEC_RAND	0x12
#define CMD_DEC_DKY		0x15
#define CMD_DRV_AUTH	0x17
#define CMD_DEC_AUTH	0x18
#define CMD_DEC_DTK		0x25
#define CMD_DEC_DT		0x23

#define	CNT2_DEFAULT	0xf2

void USCC_on( PHW_DEVICE_EXTENSION pHwDevExt );
void USCC_off( PHW_DEVICE_EXTENSION pHwDevExt );
void USCC_get( PHW_DEVICE_EXTENSION pHwDevExt );
void USCC_put( PHW_DEVICE_EXTENSION pHwDevExt );
void USCC_discont( PHW_DEVICE_EXTENSION pHwDevExt );


void Cpp_outp( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR index, UCHAR data );
UCHAR Cpp_inp( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR index );
void Cpp_wait( PHW_DEVICE_EXTENSION pHwDevExt, ULONG msec );
BOOLEAN Cpp_cmd_wait_loop( PHW_DEVICE_EXTENSION pHwDevExt );

BOOLEAN Cpp_reset( PHW_DEVICE_EXTENSION pHwDevExt, CPPMODE mode );
BOOLEAN Cpp_decoder_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r1 );
BOOLEAN Cpp_drive_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr1 );
BOOLEAN Cpp_drive_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r2 );
BOOLEAN Cpp_decoder_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr2 );
BOOLEAN Cpp_DiscKeyStart(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN Cpp_DiscKeyEnd(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN Cpp_TitleKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY tk );

#endif	// __CCPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cvdec.h ===
//***************************************************************************
//	Video decoder header
//
//***************************************************************************

#ifndef __CVDEC_H__
#define __CVDEC_H__


void VIDEO_RESET( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_MODE_DVD( PHW_DEVICE_EXTENSION pHwDevExt );
void VDVD_VIDEO_MODE_PS( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PRSO_PS1( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PRSO_NON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_OUT_NTSC( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_ALL_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SCR_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SCR_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_VERR_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_VERR_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UFLOW_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UFLOW_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_DECODE_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_DECODE_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_USER_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_USER_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UDSC_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UDSC_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_ALL_IFLAG_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SET_STCA( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stca );
void VIDEO_SET_STCS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stcs );
ULONG VIDEO_GET_STCA( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_GET_STCS( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SYSTEM_START( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SYSTEM_STOP( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_GET_STD_CODE( PHW_DEVICE_EXTENSION pHwDevExt );
BOOL VIDEO_GET_DECODE_STATE( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_DECODE_START( PHW_DEVICE_EXTENSION pHwDevExt );
NTSTATUS VIDEO_DECODE_STOP( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_STD_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_USER_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PVSIN_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PVSIN_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SET_DTS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dts );
ULONG VIDEO_GET_DTS( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SET_PTS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG pts );
ULONG VIDEO_GET_PTS( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_GET_SCR( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_GET_STCC( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SEEMLESS_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_SEEMLESS_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_VIDEOCD_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
NTSTATUS VIDEO_GET_UDATA( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pudata );
void VIDEO_PLAY_NORMAL( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PLAY_FAST( PHW_DEVICE_EXTENSION pHwDevExt, ULONG flag );
void VIDEO_PLAY_SLOW( PHW_DEVICE_EXTENSION pHwDevExt, ULONG speed );
void VIDEO_PLAY_FREEZE( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PLAY_STILL( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_LBOX_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_LBOX_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PANSCAN_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_PANSCAN_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UFLOW_CURB_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_UFLOW_CURB_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_USER_DWORD( PHW_DEVICE_EXTENSION pHwDevExt, ULONG offset );
void VIDEO_UDAT_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG VIDEO_GET_TRICK_MODE( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_PRE_SEARCH_01( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_PRE_SEARCH_02( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_PRE_SEARCH_03( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_PRE_SEARCH_04( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_PRE_SEARCH_05( PHW_DEVICE_EXTENSION pHwDevExt );
void VIDEO_BUG_SLIDE_01( PHW_DEVICE_EXTENSION pHwDevExt );
//	void VIDEO_DEBUG_SET_UF( PHW_DEVICE_EXTENSION pHwDevExt ); // for debug
//	void VIDEO_DEBUG_CLR_UF( PHW_DEVICE_EXTENSION pHwDevExt ); // for debug

#endif	// __CVDEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cdack.h ===
//***************************************************************************
//	PCI Interface(DACK) header
//
//***************************************************************************

#ifndef __CDACK_H__
#define __CDACK_H__

#include "decoder.h" // HACK?

#define PALETTE_Y	0x01
#define PALETTE_Cb	0x02
#define PALETTE_Cr	0x03


NTSTATUS PCIF_RESET( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_AMUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_AMUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_AMUTE2_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_AMUTE2_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_VSYNC_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_VSYNC_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_PACK_START_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_PACK_START_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_SET_DIGITAL_OUT( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR mode );
void PCIF_SET_DMA0_SIZE( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize );
void PCIF_SET_DMA1_SIZE( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize );
void PCIF_SET_DMA0_ADDR( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr );
void PCIF_SET_DMA1_ADDR( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr );
void PCIF_DMA0_START( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_DMA1_START( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_SET_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR select, PUCHAR pPalette );
void PCIF_GET_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR select, PUCHAR pPalette );
void PCIF_CHECK_SERIAL( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_DMA_ABORT( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_ALL_IFLAG_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_ASPECT_0403( PHW_DEVICE_EXTENSION pHwDevExt );
void PCIF_ASPECT_1609( PHW_DEVICE_EXTENSION pHwDevExt );

#endif	// __CACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cvdec.c ===
//***************************************************************************
//	Video decoder process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "cvdec.h"

extern BOOLEAN fProgrammed;


void VIDEO_RESET( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_RESET );
	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if ( ( val & 0x01 ) != 0x01 )
			break;
		// wait !!
	}
	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if ( ( val & 0x10 ) != 0x10 )
			break;
		// wait !!
	}

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x05 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x13 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x14 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x05 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x13 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x34 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_RESET );
	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if ( ( val & 0x01 ) != 0x01 )
			break;
		// wait !!
	}
	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if ( ( val & 0x10 ) != 0x10 )
			break;
		// wait !!
	}
}

void VIDEO_MODE_DVD( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DEC_MODE );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xe0 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_INT_ID );

	VIDEO_PRSO_PS1( pHwDevExt );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xbf );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_USER_ID );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DMODE );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DSPL, 0x1f );

	VIDEO_VIDEOCD_OFF( pHwDevExt );
}

void VDVD_VIDEO_MODE_PS( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xbd );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PRSO_ID );
}

void VIDEO_PRSO_PS1( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xbd );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PRSO_ID );
}

void VIDEO_PRSO_NON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PRSO_ID );
}

void VIDEO_OUT_NTSC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	// set video frame size mode to NTSC
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_VFMODE );

	// set STD buffer size
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x40 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x11 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_STD_SIZE );

	// set USER1/2 area size
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xf7 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_USER_SIZE );

	// set ext. memory mapping
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_MEM_MAP );
	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
		if ( ( val & 0x10 ) != 0x10 )
			break;
		// wait !!! & timeout !!!
	}

	// set underflow/overflow size
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_UOF_SIZE );

	// default RHOS
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_HOFFSET );

	// default RVOS
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_VOFFSET );
}

void VIDEO_ALL_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEM, 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEM, 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERM, 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOM, 0xff );
}

void VIDEO_SCR_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xfd;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_SCR_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x02;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_VERR_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xef;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERM, 0x00 );
}

void VIDEO_VERR_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERM, 0x7f );
}

void VIDEO_UFLOW_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOM );
	val &= 0xfe;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_UFLOW_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOM );
	val |= 0x01;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOM, val );
}

void VIDEO_DECODE_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEM );
	val &= 0xfb;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xfb;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_DECODE_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x04;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEM );
	val |= 0x04;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEM, val );
}

void VIDEO_USER_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEM );
	val &= 0xfe;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xf7;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_USER_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x08;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEM );
	val |= 0x01;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEM, val );
}

//--- 97.09.23 K.Chujo
void VIDEO_UDSC_INT_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	// user data start code interrupt on
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val &= 0xFE;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}

void VIDEO_UDSC_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	// user data start code interrput off
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val |= 0x01;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, val );
}
//--- End.

void VIDEO_ALL_IFLAG_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOF );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERF );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_WEF );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DEF );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRF );
}

void VIDEO_SET_STCA( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stca )
{
	UCHAR val;

	val = (UCHAR)( stca & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, val );
	val = (UCHAR)( ( stca >> 8 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, val );
	val = (UCHAR)( ( stca >> 16 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5, val );
	val = (UCHAR)( ( stca >> 24 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6, val );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA7, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_STCA );
}

void VIDEO_SET_STCS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stcs )
{
	UCHAR val;

	val = (UCHAR)( stcs & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, val );
	val = (UCHAR)( ( stcs >> 8 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, val );
	val = (UCHAR)( ( stcs >> 16 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5, val );
	val = (UCHAR)( ( stcs >> 24 ) & 0xff );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6, val );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA7, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_STCS );
}

ULONG VIDEO_GET_STCA( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval = 0, val;

   if (fProgrammed)
   {

      WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_STCA );
   
      rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
      val <<= 8;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5 );
      val <<= 16;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6 );
      val <<= 24;
      rval += val;
   
   }

	return rval;
}

ULONG VIDEO_GET_STCS( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval = 0, val;

   if (fProgrammed)
   {

      WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_STCS );
      
      rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
      val <<= 8;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5 );
      val <<= 16;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6 );
      val <<= 24;
      rval += val;

   }
	return rval;
}

void VIDEO_SYSTEM_START( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x07 );	// video buffer flow control
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_SYS );
}

void VIDEO_SYSTEM_STOP( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_SYS );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	val &= 0xfe;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, val );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_SYS );
}

ULONG VIDEO_GET_STD_CODE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval, val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_STD_CODE );
	rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
	val <<= 8;
	rval += val;
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
	val <<= 16;
	rval += val;

	rval <<= 2;
	return rval;
}

BOOL VIDEO_GET_DECODE_STATE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_DECODE );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	if ( ( val & 0x01 ) == 0x01 )
		return TRUE;	// Decode
	else
		return FALSE;	// Non Decode
}

void VIDEO_DECODE_START( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	for ( ; ; )
	{
		val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT2 );
		if ( ( val & 0x01 ) != 0x01 )
			break;
	}
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x05 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DECODE );
}

NTSTATUS VIDEO_DECODE_STOP( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT2 );
	if ( ( val & 0x01 ) == 0x01 )
		return (NTSTATUS)-1;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_DECODE );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	val &= 0x0e;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, val );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DECODE );

	return 0;
}

void VIDEO_STD_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_STD_CLEAR );
}

void VIDEO_USER_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_USER1_CLEAR );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_USER2_CLEAR );
}

void VIDEO_PVSIN_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PVSIN );
}

void VIDEO_PVSIN_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PVSIN );
}

void VIDEO_SET_DTS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dts )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, (UCHAR)( dts & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, (UCHAR)( ( dts >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, (UCHAR)( ( dts >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, (UCHAR)( ( dts >> 24 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5, 0 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DTS );
}

ULONG VIDEO_GET_DTS( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval, val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_DTS );
	rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
	val <<= 8;
	rval += val;
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
	val <<= 16;
	rval += val;
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
	val <<= 24;
	rval += val;

	return rval;
}

void VIDEO_SET_PTS( PHW_DEVICE_EXTENSION pHwDevExt, ULONG pts )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, (UCHAR)( pts & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, (UCHAR)( ( pts >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, (UCHAR)( ( pts >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, (UCHAR)( ( pts >> 24 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_PTS );
}

ULONG VIDEO_GET_PTS( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval, val;

   if (fProgrammed)
   {

      WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_PTS );
      rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
      val <<= 8;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
      val <<= 16;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
      val <<= 24;
      rval += val;
   }
   else
   {
      rval = 0;
   }


	return rval;
}

ULONG VIDEO_GET_SCR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval =0, val;

   if (fProgrammed)
   {

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_SCR );
	rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
	val <<= 8;
	rval += val;
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5 );
	val <<= 16;
	rval += val;
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6 );
	val <<= 24;
	rval += val;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_STCR_END );

   }
	return rval;
}

ULONG VIDEO_GET_STCC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG rval=0, val;

   if (fProgrammed)
   {

      WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_STCC );
      rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
      val <<= 8;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA5 );
      val <<= 16;
      rval += val;
      val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA6 );
      val <<= 24;
      rval += val;
      WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_STCR_END );
   }

	return rval;
}

void VIDEO_SEEMLESS_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_SEEMLES );
}

void VIDEO_SEEMLESS_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_SEEMLES );
}

void VIDEO_VIDEOCD_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_VCD );
}

NTSTATUS VIDEO_GET_UDATA( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pudata )
{
	if ( ( READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 ) & 0x80 ) != 0x80 )
		return (NTSTATUS)-1;	// no user data

	*pudata = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
	return 0;
}

void VIDEO_PLAY_NORMAL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_TRICK_NORMAL );
}

void VIDEO_PLAY_FAST( PHW_DEVICE_EXTENSION pHwDevExt, ULONG flag )
{
	if ( flag == FAST_ONLYI )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	else if ( flag == FAST_IANDP )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x07 );
	else
		return;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_TRICK_FAST );
}

void VIDEO_PLAY_SLOW( PHW_DEVICE_EXTENSION pHwDevExt, ULONG speed )
{
	if ( speed == 0 || speed > 31 )
		return;

	speed <<= 2;
	speed |= 3;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, (UCHAR)speed );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_TRICK_SLOW );
}

void VIDEO_PLAY_FREEZE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_TRICK_FREEZE );
}

void VIDEO_PLAY_STILL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_TRICK_STILL );
}

void VIDEO_LBOX_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DSPL );
	val &= 0xf7;
	val |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DSPL, val );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x3e );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_VOFFSET );
}

void VIDEO_LBOX_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DSPL );
	val |= 0x18;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DSPL, val );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x04 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_VOFFSET );
}

void VIDEO_PANSCAN_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DMODE );
}

void VIDEO_PANSCAN_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x1b );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_DMODE );
}

void VIDEO_UFLOW_CURB_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_UF_CURB );
}

void VIDEO_UFLOW_CURB_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_UF_CURB );
}

ULONG VIDEO_USER_DWORD( PHW_DEVICE_EXTENSION pHwDevExt, ULONG offset )
{
	ULONG rval, val;

	for ( ; ; )
	{
		val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT2 );
		if ( ( val & 0x01 ) != 0x01 )
			break;
	}

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, (UCHAR)( offset & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3, (UCHAR)( ( offset >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4, (UCHAR)( ( offset >> 16 ) & 0x07 ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_SET_WRITE_MEM );

	for ( ; ; )
	{
		val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT2 );
		if ( ( val & 0x01 ) != 0x01 )
			break;
	}

	rval = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
	rval <<= 8;
	rval += (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
	rval <<= 8;
	rval += (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
	rval <<= 8;
	rval += (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	rval <<= 8;

	return rval;
}

void VIDEO_UDAT_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	for ( ; ; )
	{
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );
	if ( ( val & 0x08 ) != 0x08 )
		break;
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UDAT );
	}
}

ULONG VIDEO_GET_TRICK_MODE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	ULONG val;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, V_GET_TRICK );
	val = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
	val &= 0x07;

	return val;
}

void VIDEO_BUG_PRE_SEARCH_01( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x25 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x52 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x11 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x02 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x5d );
}

void VIDEO_BUG_PRE_SEARCH_02( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x02 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x1b );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x8f );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x8f );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x42 );
}

void VIDEO_BUG_PRE_SEARCH_03( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xc1 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x52 );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xb8 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x52 );
}

void VIDEO_BUG_PRE_SEARCH_04( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x1b );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x8f );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x03 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x8f );
}

void VIDEO_BUG_PRE_SEARCH_05( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x5d );
}


// NEEDED TO BE DEBUGGED !!!
void VIDEO_BUG_SLIDE_01( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;
	ULONG ul;

	// check whether vdec hanged-up
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x7d );
	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
//	if( UF_FLAG == TRUE ) {
//		DebugPrint(( DebugLevelTrace, "DVDTS:  DECODER STATUS = %x\r\n", val ));
//	}
	if ( ( val & 0x30 ) == 0x00 )
	{
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x72 );
		ul = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
		ul <<= 8;
		ul += (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
//		if( UF_FLAG == TRUE ) {
//			DebugPrint(( DebugLevelTrace, "DVDTS:  DECODER PC(1) = %x\r\n", ul ));
//		}
		if ( ul == 0x1a5 )
		{
			WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0xb8 );
			WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
			WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x52 );
			DebugPrint(( DebugLevelTrace, "DVDTS:  <<RE-ORDER(1)>>\r\n" ));
			// uf
		} else {
			WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0xb0 );
			ul = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA4 );
			ul <<= 8;
			val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA3 );
			ul += (ULONG)val;
			ul <<= 8;
			val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
			ul += (ULONG)val;
			ul <<= 8;
			val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
			ul += (ULONG)val;

//			if( UF_FLAG == TRUE ) {
//				DebugPrint(( DebugLevelTrace, "DVDTS:  DECODER DTS = %x\r\n", ul ));
//			}
			if ( ( VIDEO_GET_STCA( pHwDevExt ) - 2 ) > ul )
			{
				ul = VIDEO_GET_STD_CODE( pHwDevExt );
//				if( UF_FLAG == TRUE ) {
//					DebugPrint(( DebugLevelTrace, "DVDTS:  DECODER STD = %x\r\n", ul ));
//				}
				if ( ul >= 0x200 )
				{
					WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x72 );
					ul = (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2 );
					ul <<= 8;
					ul += (ULONG)READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1 );
//					if( UF_FLAG == TRUE ) {
//						DebugPrint(( DebugLevelTrace, "DVDTS:  DECODER PC(2) = %x\r\n", ul ));
//					}
					if ( ul >= 0x404 && ul <= 0x409 )
					{
						WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x18 );
						WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x04 );
						WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x52 );
						DebugPrint(( DebugLevelTrace, "DVDTS:  <<RE-ORDER(2)>>\r\n" ));
						// uf
					}
				}
			}
		}
	}
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA1, 0x00 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_DATA2, 0x01 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_CMDR1, 0x5d );
}
//
//void VIDEO_DEBUG_SET_UF( PHW_DEVICE_EXTENSION pHwDevExt )
//{
//	UF_FLAG = TRUE;
//}
//
//void VIDEO_DEBUG_CLR_UF( PHW_DEVICE_EXTENSION pHwDevExt )
//{
//	UF_FLAG = FALSE;
//}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cvpro.c ===
//***************************************************************************
//	Video Processor(V-PRO) process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "cvpro.h"





void VPRO_RESET_FUNC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_RESET, 0 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_RESET, 0x80 );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG = 0x80;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG = 0;	// ? ? ?
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproAVM_REG = 0;	// ? ? ?
}

void VPRO_VIDEO_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
// debug
//	if ( !(((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG & 0x80) )
//		Error;
// debug

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_RESET, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG );
}

void VPRO_VIDEO_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
// debug
//	if ( !(((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG & 0x80) )
//		Error;
// debug

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_RESET, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproRESET_REG );
}

void VPRO_INIT_NTSC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG &= 0x7f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproAVM_REG &= 0x5f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_AVM, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproAVM_REG );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_DVEN, 0xc0 );
}

void VPRO_INIT_PAL( PHW_DEVICE_EXTENSION pHwDevExt )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG |= 0x80;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG );

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproAVM_REG &= 0x5f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_AVM, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproAVM_REG );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_DVEN, 0x80 );
}

void VPRO_CC_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
//	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG &= 0xbf;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG );
}

void VPRO_CC_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
//	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG |= 0x40;
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_VMODE, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproVMODE_REG );
}

void VPRO_SUBP_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pPalData )
{
	ULONG i;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0x80 );

	for( i = 0; i < 48; i++ )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSP, *pPalData++ );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0x40 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0 );
}

void VPRO_OSD_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pPalData )
{
	int i;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0x20 );

	for( i = 0; i < 48; i++ )
		WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSP, *pPalData++ );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0x10 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + VPRO_CPSET, 0 );
}

void SUBP_RESET_INIT( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR	ch;

	SUBP_RESET_FUNC( pHwDevExt );

// Interrupt Mask.
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STSINT, 0xf0 );

// select Audio Stream.
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_AC3 || ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_PCM )
		SUBP_SELECT_AUDIO_SSID( pHwDevExt );
	else
		SUBP_SELECT_AUDIO_STID( pHwDevExt );

	SUBP_STC_OFF( pHwDevExt );

// Audio channel
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_AC3 )
		ch = SUB_STRMID_AC3;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_MPEG_F1 )
		ch = STRMID_MPEG_AUDIO;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_MPEG_F2 )
		ch = STRMID_MPEG_AUDIO;
	else
		ch = SUB_STRMID_PCM;

	ch = (UCHAR)SUBP_GET_AUDIO_CH( pHwDevExt );
	SUBP_SET_AUDIO_CH( pHwDevExt, ch );

// Sub-Pic Channel
	SUBP_SET_SUBP_CH( pHwDevExt,0 );

// Sub-Pic MUTE ON/OFF.
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute )
		SUBP_MUTE_ON( pHwDevExt );
	else
		SUBP_MUTE_OFF( pHwDevExt );
	SUBP_BUFF_CLEAR( pHwDevExt );
}

void SUBP_RESET_FUNC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_RESET, 0x80 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_RESET, 0 );

	// set or restore COMMAND REGISTER
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG );
}

void SUBP_RESET_STC( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_RESET, 0x40 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_RESET, 0 );
}

void SUBP_BUFF_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt )
{

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG |= 0x10;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG);

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG &= 0xef;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG);

//--- End.
}

void SUBP_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:SUBP_MUTE_ON( pHwDevExt )\r\n" ));


	// new below
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG |= 0x80;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG );


	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute = TRUE;
}

void SUBP_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:SUBP_MUTE_OFF( pHwDevExt )\r\n" ));


	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG &= 0x7f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG );


	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute = FALSE;
}

void SUBP_HLITE_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG |= 0x40;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG );

}

void SUBP_HLITE_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{

	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG &= 0xbf;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_COMMAND, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.VproCOMMAND_REG );

}

void SUBP_SET_STC(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc )
{
	SUBP_STC_OFF( pHwDevExt );

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCLL, (UCHAR)( stc & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCLH, (UCHAR)( ( stc >> 8 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCHL, (UCHAR)( ( stc >> 16 ) & 0xff ) );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCHH, (UCHAR)( ( stc >> 24 ) & 0xff ) );

//	SUBP_STC_ON( pHwDevExt );
}

void SUBP_SET_LNCTLI(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_LCINFLL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_LCINFLH, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_LCINFHL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_LCINFHH, *pData++ );
}

void SUBP_SET_PXCTLIS(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSLL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSLH, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSML, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSMH, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSHL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFSHH, *pData++ );
}

void SUBP_SET_PXCTLIE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFELL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFELH, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFEML, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFEMH, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFEHL, *pData++ );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_PCINFEHH, *pData++ );
}

void SUBP_STC_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCCNT );

	val |= 0x80;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCCNT, val );
}

void SUBP_STC_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCCNT );

	val &= 0x7f;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STCCNT, val );
}

void SUBP_SET_SUBP_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch )
{
	UCHAR ucch;

	ucch = (UCHAR)( ch & 0x1f );
	ucch |= 0x20;


	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicID = ucch;

#if 1
	// VPRO (early TC90A09F) has a bug. When change subpic ID, subpic disappears somtimes.
	// You should reset SUBPIC part to change subpic ID safely.

	// reset SUBPIC part
	SUBP_RESET_FUNC( pHwDevExt );

	// Interrupt Mask.
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_STSINT, 0xf0 );

	// select Audio Stream.
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_AC3 || ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_PCM )
		SUBP_SELECT_AUDIO_SSID( pHwDevExt );
	else
		SUBP_SELECT_AUDIO_STID( pHwDevExt );

//	SUBP_STC_OFF( pHwDevExt );

	// Audio channel
	SUBP_SET_AUDIO_CH( pHwDevExt, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioID );
	DebugPrint(( DebugLevelTrace, "DVDTS:  <<< New Audio ID = %x >>>\r\n", ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioID ));

	// Sub-Pic Channel
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_SPID, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicID );
	DebugPrint(( DebugLevelTrace, "DVDTS:  <<< New Subpic ID = %x >>>\r\n", ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicID ));

	// Sub-Pic MUTE ON/OFF.
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute ) //HACK NEXT RESETREG SEE DVDINIT>H VPRO HACK
		SUBP_MUTE_ON( pHwDevExt );
	else
		SUBP_MUTE_OFF( pHwDevExt );
//	SUBP_BUFF_CLEAR( pHwDevExt );

#else
	// Maybe VPRO works only next one code if later version (ex. Timpani).

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_SPID, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicID );

#endif

//--- End.
}

ULONG SUBP_GET_SUBP_CH( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_SPID );

	return val;
}

void SUBP_SET_AUDIO_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch )
{
	UCHAR ucch;

	ucch = (UCHAR)( ch & 0x7 );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_AC3 )
		ucch |= 0x80;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_PCM )
		ucch |= 0xa0;
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioMode == AUDIO_TYPE_MPEG_F1 )
		ucch |= 0xc0;
	else
		ucch |= 0xd0;

//--- 97.09.14 K.Chujo
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioID = ucch;
//--- End.
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_AAID, ucch );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_ABID, 0 );
}

void SUBP_SET_AUDIO_NON( PHW_DEVICE_EXTENSION pHwDevExt )
{
//--- 97.09.14 K.Chujo
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.AudioID = 0;
//--- End.
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_AAID, 0 );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_ABID, 0 );
}

ULONG SUBP_GET_AUDIO_CH( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR val;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_AAID );

	return (ULONG)val;
}
//--- End.

void SUBP_SELECT_AUDIO_STID( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_ASEL, 0 );
}

void SUBP_SELECT_AUDIO_SSID( PHW_DEVICE_EXTENSION pHwDevExt )
{
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + SUBP_ASEL, 3 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\cvpro.h ===
//***************************************************************************
//	Video Processor(V-PRO) header
//
//***************************************************************************

#ifndef __CVPRO_H__
#define __CVPRO_H__


void VPRO_RESET_FUNC( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_VIDEO_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_VIDEO_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_INIT_NTSC( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_INIT_PAL( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_CC_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_CC_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void VPRO_SUBP_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt ,PUCHAR pPalData );
void VPRO_OSD_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt ,PUCHAR pPalData );

void SUBP_RESET_INIT( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_RESET_FUNC( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_RESET_STC( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_BUFF_CLEAR( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_MUTE_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_MUTE_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_HLITE_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_HLITE_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_SET_STC(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc );
void SUBP_SET_LNCTLI(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData );
void SUBP_SET_PXCTLIS(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData );
void SUBP_SET_PXCTLIE(  PHW_DEVICE_EXTENSION pHwDevExt , PUCHAR pData );
void SUBP_STC_ON( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_STC_OFF( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_SET_SUBP_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch );
ULONG SUBP_GET_SUBP_CH( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_SET_AUDIO_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch );
void SUBP_SET_AUDIO_NON( PHW_DEVICE_EXTENSION pHwDevExt );
ULONG SUBP_GET_AUDIO_CH( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_SELECT_AUDIO_STID( PHW_DEVICE_EXTENSION pHwDevExt );
void SUBP_SELECT_AUDIO_SSID( PHW_DEVICE_EXTENSION pHwDevExt );


#endif	// __CVPRO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\decoder.h ===
//***************************************************************************
//	Decoder header
//
//***************************************************************************
#ifndef __CDVPRO_H__
#define __CDVPRO_H__




enum {
	NO_ACG,
	TC6802,
	TC6814,
	TC6818
};


typedef struct _VProcessor {

	ULONG	AudioMode;	// AC3, PCM, ...
	BOOL	SubpicMute;

	UCHAR	VproRESET_REG;
	UCHAR	VproVMODE_REG;
	UCHAR	VproAVM_REG;
	UCHAR	VproCOMMAND_REG;
	UCHAR	AudioID;
	UCHAR	SubpicID;

} VProcessor, *PVProcessor;





typedef struct _CGuard {

	UCHAR	VproRESET_REG;
	UCHAR	VproVMODE_REG;
	UCHAR	VproAVM_REG;
	ULONG	CpgdVsyncCount;
	ULONG	ACGchip;
	BOOL	CGMSnCPGDvalid;
	ULONG	AspectFlag;		// Aspect Ratio
							//    0: 4:3
							//    1: 16:9
	ULONG	LetterFlag;		// Letter Box
							//    0: Letter Box OFF
							//    1: Letter Box ON
	ULONG	CgmsFlag;		// NTSC Anolog CGMS
							//    0: Copying is permitted without restriction
							//    1: Condition is not be used
							//    2: One generation of copies may be made
							//    3: No copying is permitted
	ULONG	CpgdFlag;		// APS
							//    0: AGC pulse OFF, Burst inv OFF
							//    1: AGC pulse ON , Burst inv OFF
							//    2: AGC pulse ON , Burst inv ON (2line)
							//    3: AGC pulse ON , Burst inv ON (4line)


} CGuard, *PCGuard;


typedef struct _Dack
{

	UCHAR DigitalOutMode;
	UCHAR paldata[3][256];

} Dack, *PDack;




typedef struct _ADecoder {

	ULONG	AudioMode;	// AC3, PCM, ...
	ULONG	AudioFreq;	// audio frequency
	ULONG	AudioType;	// audio type - analog, digital, ...
	ULONG	AudioCgms;	// audio cgms
						//    3:No copying is permitted
						//    2:One generation of copies may be made
						//    1:Condition is not be used
						//    0:Copying is permitted without restriction

	ULONG	AudioVolume;
	Dack	*pDack;


} ADecoder, *PADecoder;


// overall decoder info
typedef struct _MasterDecoder {


	// hardware settings
	ULONG			StreamType;	// stream type - DVD, MPEG2, ...
	ULONG			TVType;		// TV type - NTCS, PAL, ...
	ULONG			PlayMode;	// playback mode - normal, FF, ...
	ULONG			RunMode;	// 3modes; Normal, Fast, Slow
	BOOL			VideoMute;	//
	BOOL			AudioMute;	//
	BOOL			OSDMute;	//
	BOOL			LetterBox;	//
	BOOL			PanScan;	//
	ULONG			VideoAspect;	// - 4:3, 16:9
	ULONG			AudioVolume;	// audio volume
	BOOL			SubpicHilite;	// subpicture hilight
	UCHAR			VideoPort;	// degital video output type

	Dack		DAck;
	ADecoder	ADec;
	VProcessor	VPro;
	CGuard		CPgd;

} MasterDecoder, *PMasterDecoder;



#endif // included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\decoder.c ===
//***************************************************************************
//	Decoder process
//
//***************************************************************************

#include "common.h"
#include "regs.h"
#include "dvdcmd.h"

// allocate decoder data area and put 'blind' ptr to it in our device ext
PVOID decAllocateDecoderInfo( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PMasterDecoder pDec = (PMasterDecoder) ExAllocatePool(NonPagedPool,
                         sizeof(MasterDecoder));

	ASSERT( pDec );
   if (!pDec)
      return NULL;
	
	pDec->StreamType = STREAM_MODE_DVD;
	pDec->TVType = DISPLAY_MODE_NTSC;
	pDec->VideoAspect = ASPECT_04_03;
	pDec->LetterBox = FALSE;
	pDec->PanScan = FALSE;

	pDec->ADec.AudioMode = AUDIO_TYPE_AC3;
	pDec->VPro.AudioMode = pDec->ADec.AudioMode;

	pDec->ADec.AudioType = AUDIO_OUT_ANALOG;
	pDec->AudioVolume = 0x7f;
	// ?? No copying is permitted
	pDec->ADec.AudioCgms = AUDIO_CGMS_03; // ( 0<=aCgms && aCgms<=3 ) ? aCgms : 3;

	pDec->ADec.AudioFreq = AUDIO_FS_48;

	pDec->VideoMute = FALSE;
	pDec->AudioMute = FALSE;
	pDec->VPro.SubpicMute = FALSE;
	pDec->OSDMute = TRUE;
	pDec->SubpicHilite = FALSE;

	pDec->PlayMode = PLAY_MODE_NORMAL;
	pDec->RunMode = PLAY_MODE_NORMAL;	// PlayMode after BOOT is Normal Mode;
	pDec->CPgd.ACGchip = NO_ACG;

	pDec->ADec.pDack = &(pDec->DAck);


	if( pDec->VPro.SubpicMute )
		pDec->VPro.VproCOMMAND_REG = 0xA0;			// see specifications (date 96.09.26 spec)
	else
		pDec->VPro.VproCOMMAND_REG = 0x20;			// see specifications (date 96.09.26 spec)

	pHwDevExt->DecoderInfo = pDec;  //set back-pointer to this info in dev ext
	return  (PVOID ) pDec;
}

void decVsyncOn( PHW_DEVICE_EXTENSION pHwDevExt )
{
	PCIF_VSYNC_ON( pHwDevExt );
}

void decClosedCaptionOn( PHW_DEVICE_EXTENSION pHwDevExt ) //turn on/off closed caption
{
	USCC_on( pHwDevExt );
}
void decClosedCaptionOff( PHW_DEVICE_EXTENSION pHwDevExt )
{
	USCC_discont( pHwDevExt );
}


ULONG decGetVideoSTCA( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return VIDEO_GET_STCA( pHwDevExt );
}


//DMA routines
void decSetDma0Size( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize )
{
     PCIF_SET_DMA0_SIZE(  pHwDevExt,  dmaSize );
}
void decSetDma1Size( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaSize )
{
     PCIF_SET_DMA1_SIZE(  pHwDevExt,  dmaSize );
}
void decSetDma0Addr( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr )
{
     PCIF_SET_DMA0_ADDR(  pHwDevExt,  dmaAddr );
}
void decSetDma1Addr( PHW_DEVICE_EXTENSION pHwDevExt, ULONG dmaAddr )
{
     PCIF_SET_DMA1_ADDR(  pHwDevExt,  dmaAddr );
}
void decSetDma0Start( PHW_DEVICE_EXTENSION pHwDevExt )
{
     PCIF_DMA0_START(  pHwDevExt );
}
void decSetDma1Start( PHW_DEVICE_EXTENSION pHwDevExt )
{
     PCIF_DMA1_START(  pHwDevExt );
}

// actual start video decoding at various speeds
void decDecodeStartNormal( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC )
{
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );

	VIDEO_PRSO_PS1( pHwDevExt );
	VIDEO_PLAY_NORMAL( pHwDevExt );
	decSetVideoPlayMode( pHwDevExt, PLAY_MODE_NORMAL);
	decSetVideoRunMode( pHwDevExt, PLAY_MODE_NORMAL);
	VIDEO_SET_STCS( pHwDevExt,dwSTC );
	AUDIO_ZR38521_VDSCR_ON( pHwDevExt,dwSTC );

	if( decGetSubpicMute(pHwDevExt ) == TRUE )
		SUBP_MUTE_ON( pHwDevExt );
	else
		SUBP_MUTE_OFF( pHwDevExt );

	if( pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG ) {
		// when decode new data
		SUBP_SET_STC( pHwDevExt, dwSTC );
	}
	else {
		// when recover underflow
		//    Don't set stc, because sub stc is reset.
	}
	SUBP_STC_ON( pHwDevExt );

	decHighlight( pHwDevExt, &(pHwDevExt->hli) );

	VIDEO_UFLOW_INT_ON( pHwDevExt );
	VIDEO_BUG_PRE_SEARCH_04( pHwDevExt );
	VIDEO_DECODE_START( pHwDevExt );
	AUDIO_ZR38521_PLAY( pHwDevExt );
	VPRO_VIDEO_MUTE_OFF( pHwDevExt );
	CGuard_CPGD_VIDEO_MUTE_OFF( pHwDevExt );

//	VIDEO_SEEMLESS_ON( pHwDevExt );
}
void decDecodeStartFast( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC )
{

	VIDEO_PRSO_NON( pHwDevExt );
	VIDEO_PLAY_NORMAL( pHwDevExt );
	VIDEO_UFLOW_INT_OFF( pHwDevExt );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );
	VIDEO_BUG_PRE_SEARCH_04( pHwDevExt );
	VIDEO_DECODE_START( pHwDevExt );
	VIDEO_SYSTEM_STOP( pHwDevExt );
	VIDEO_PLAY_FAST( pHwDevExt, FAST_ONLYI );
	VIDEO_SYSTEM_START( pHwDevExt );

	AUDIO_ZR38521_PLAY( pHwDevExt );
	dwSTC = decGetVideoSTCA(pHwDevExt );
	DebugPrint( (DebugLevelTrace, "DVDTS:  dwSTC = %lx\r\n", dwSTC) );
}

void decDecodeStartSlow( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC )
{
	VIDEO_PRSO_PS1( pHwDevExt );
	SUBP_SET_AUDIO_NON( pHwDevExt );
	VIDEO_PLAY_SLOW( pHwDevExt, (UCHAR)(pHwDevExt->Rate/10000) );

	VIDEO_SET_STCS( pHwDevExt, dwSTC );
	AUDIO_ZR38521_STOP( pHwDevExt );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );
	if( decGetSubpicMute(pHwDevExt ) == TRUE )
		SUBP_MUTE_ON( pHwDevExt );
	else
		SUBP_MUTE_OFF( pHwDevExt );

	if( pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG ) {
		// when decode new data
		SUBP_SET_STC( pHwDevExt, dwSTC );
	}
	else {
		// when recover underflow
		//    Don't set stc, because sub stc is reset.
	}
	SUBP_STC_ON( pHwDevExt );
	VIDEO_UFLOW_INT_ON( pHwDevExt );
	VIDEO_BUG_PRE_SEARCH_04( pHwDevExt );
	VIDEO_DECODE_START( pHwDevExt );
	VPRO_VIDEO_MUTE_OFF( pHwDevExt );
	CGuard_CPGD_VIDEO_MUTE_OFF( pHwDevExt );

}


// Set CGMS for Digital Audio Copy Guard & NTSC Analog Copy Guard
void decDvdTitleCopyKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY pTitleKey )
{
	ULONG cgms;
	BOOLEAN bStatus = Cpp_TitleKey( pHwDevExt, pTitleKey );

	ASSERTMSG( "\r\n...CPro Status Error!!( TitleKey )", bStatus );

	cgms = (pTitleKey->KeyFlags & 0x30) >> 4;

	// for Digital Audio Copy Guard
	((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioCgms =
		( 0<=cgms && cgms<=3 ) ? cgms : 3;


	AUDIO_ZR38521_REPEAT_16( pHwDevExt );
	AUDIO_TC9425_INIT_DIGITAL( pHwDevExt );
	AUDIO_TC9425_INIT_ANALOG( pHwDevExt );

	// for NTSC Analog Copy Guard
	CGuard_CPGD_SET_CGMS( pHwDevExt, cgms );

}

BOOLEAN decCpp_reset( PHW_DEVICE_EXTENSION pHwDevExt, CPPMODE mode )
{
	return Cpp_reset(  pHwDevExt,  mode );
}

BOOLEAN decCpp_decoder_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r1 )
{
	return Cpp_decoder_challenge(  pHwDevExt,  r1 ) ;
}

BOOLEAN decCpp_drive_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr1 )
{
	return Cpp_drive_bus(  pHwDevExt,  fsr1 );
}

BOOLEAN decCpp_drive_challenge( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_CHLGKEY r2 )
{
	return Cpp_drive_challenge(  pHwDevExt,  r2 );
}

BOOLEAN decCpp_decoder_bus( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_BUSKEY fsr2 )
{
	return Cpp_decoder_bus(  pHwDevExt,  fsr2 );
}

BOOLEAN decCpp_DiscKeyStart(PHW_DEVICE_EXTENSION pHwDevExt)
{
	return Cpp_DiscKeyStart( pHwDevExt);
}

BOOLEAN decCpp_DiscKeyEnd(PHW_DEVICE_EXTENSION pHwDevExt)
{
	return Cpp_DiscKeyEnd( pHwDevExt);
}

BOOLEAN decCpp_TitleKey( PHW_DEVICE_EXTENSION pHwDevExt, PKS_DVDCOPY_TITLEKEY tk )
{
	return Cpp_TitleKey(  pHwDevExt, tk );
}




// access/control composite picture
BOOLEAN decGetSubpicMute( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return ((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute != 0;
}

void decSetSubpicMute( PHW_DEVICE_EXTENSION pHwDevExt, BOOLEAN flag )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VPro.SubpicMute = flag;
	if ( flag )
		SUBP_MUTE_ON( pHwDevExt );
	else
		SUBP_MUTE_OFF( pHwDevExt );
}


// initialize the mpeg hw
void decInitMPEG( PHW_DEVICE_EXTENSION pHwDevExt, DWORD dwSTC )
{
	DWORD st, et;
	UCHAR mvar;

	//DebugPrint(( DebugLevelTrace, "DVDTS:InitFirstTime\r\n" ));
	//DebugPrint(( DebugLevelTrace, "DVDTS:  STC 0x%x( 0x%s(100ns) )\r\n", dwSTC, DebugLLConvtoStr( ConvertPTStoStrm(dwSTC), 16 ) ));
// for debug
	mvar = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	mvar &= 0xEF;
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM, mvar );
	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERM, 0 );
//
	st = GetCurrentTime_ms();

	// TC81201F bug recovery
	VIDEO_PLAY_STILL(pHwDevExt);
	BadWait( 200 );

	// normal process
	VIDEO_SYSTEM_STOP(pHwDevExt);
	VIDEO_DECODE_STOP(pHwDevExt);
	AUDIO_ZR38521_STOP(pHwDevExt);
	SUBP_STC_OFF(pHwDevExt);

	// TC81201F bug recovery
	VIDEO_BUG_PRE_SEARCH_01(pHwDevExt);

	// normal process
	VIDEO_STD_CLEAR(pHwDevExt);
	VIDEO_USER_CLEAR(pHwDevExt);
	VIDEO_UDAT_CLEAR(pHwDevExt);
	AUDIO_ZR38521_STOPF(pHwDevExt);
	if( pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG ) {
		// when decode new data
		SUBP_RESET_INIT(pHwDevExt);
		SUBP_BUFF_CLEAR(pHwDevExt);
	}
	else {
		// when recover underflow
		//     Don't reset and clear buffer.
	}
	VIDEO_UFLOW_INT_OFF(pHwDevExt);
	VIDEO_ALL_IFLAG_CLEAR(pHwDevExt);
	PCIF_ALL_IFLAG_CLEAR(pHwDevExt);
	PCIF_PACK_START_ON(pHwDevExt);

	VIDEO_SYSTEM_START(pHwDevExt);

	// TC81201F bug recovery
	//     Accoding to TOSHIBA MM lab. Hisatomi-san,
	//     BLACK DATA or SKIP DATA should be set from host bus.
	//     However the VxD is not implemented and work good,
	//     so the minidriver is not implemented too.
	//     If you need, insert code here.

	// TC81201F bug recovery
	VIDEO_PVSIN_OFF( pHwDevExt );
	VIDEO_BUG_PRE_SEARCH_02( pHwDevExt );

	// TC81201F bug recovery
	BadWait( 200 );
//	VIDEO_BUG_PRE_SEARCH_03( pHwDevExt );
//	/* error check */ VIDEO_DECODE_STOP( pHwDevExt );

	// TC81201F bug recovery
	VIDEO_PVSIN_ON( pHwDevExt );
	VIDEO_BUG_PRE_SEARCH_05( pHwDevExt );

//	VIDEO_DECODE_INT_ON( pHwDevExt );	// Not Use ?

	VIDEO_SET_STCS( pHwDevExt,dwSTC );	// ? ? ? ?
	AUDIO_ZR38521_VDSCR_ON( pHwDevExt, dwSTC );

	if( pHwDevExt->DataDiscontFlagCount & VIDEO_DISCONT_FLAG ) {
		// when decode new data
		SUBP_SET_STC( pHwDevExt, /* dwSTC */ 0 );
		SUBP_BUFF_CLEAR( pHwDevExt );
	}
	else {
		// when recover underflow
		//    Don't set stc, because sub stc is reset.
	}

	SUBP_MUTE_ON( pHwDevExt );

	pHwDevExt->fCauseOfStop = 0;

	et = GetCurrentTime_ms();
	DebugPrint( (DebugLevelTrace, "DVDTS:init first time %dms\r\n", et - st ) );
}



BOOLEAN decSetStreamMode( PHW_DEVICE_EXTENSION pHwDevExt, PHW_STREAM_REQUEST_BLOCK pSrb ) // set stream modes on HW
{
	// initialize decoder
	NTSTATUS Stat = PCIF_RESET(pHwDevExt);

	if( Stat != STATUS_SUCCESS ) {
		DebugPrint( (DebugLevelTrace, "DVDTS:illegal config info") );
		pSrb->Status = STATUS_IO_DEVICE_ERROR;
		return FALSE;
	}
	VIDEO_RESET(pHwDevExt);
	VPRO_RESET_FUNC(pHwDevExt);
	SUBP_RESET_FUNC(pHwDevExt);

	CGuard_CPGD_RESET_FUNC(pHwDevExt);


	VIDEO_ALL_INT_OFF(pHwDevExt);
	PCIF_VSYNC_ON(pHwDevExt);
	VIDEO_MODE_DVD(pHwDevExt );
	PCIF_PACK_START_ON(pHwDevExt);
	return TRUE;
}

void decSetDisplayMode( PHW_DEVICE_EXTENSION pHwDevExt ) // set display mode on HW
{

	BOOLEAN bStatus;

	VIDEO_OUT_NTSC(pHwDevExt);
	VPRO_INIT_NTSC(pHwDevExt);
	CGuard_CPGD_INIT_NTSC(pHwDevExt);
	PCIF_ASPECT_0403(pHwDevExt);
	VPRO_VIDEO_MUTE_OFF(pHwDevExt);
	CGuard_CPGD_VIDEO_MUTE_OFF(pHwDevExt);

// Set Digital Out
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VideoPort = 0;	// Disable
	PCIF_SET_DIGITAL_OUT( pHwDevExt, ((PMasterDecoder)pHwDevExt->DecoderInfo)->VideoPort );


	bStatus = Cpp_reset( pHwDevExt, NO_GUARD );

	ASSERTMSG( "\r\n...CPro Status Error!!( reset )", bStatus );

}

ULONG decGetAudioMode( PHW_DEVICE_EXTENSION pHwDevExt ) // get audio mode from HW
{
	return ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode;
}

void decSetAudioFreq( PHW_DEVICE_EXTENSION pHwDevExt, ULONG freq ) // set audio freq
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioFreq = freq;
}

void decSetAudioMode( PHW_DEVICE_EXTENSION pHwDevExt ) // set audio mode on HW
{

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_AC3 ) {
		decSetAudioAC3(pHwDevExt);
	}
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_PCM ) {
		decSetAudioPCM(pHwDevExt);
	}
	else
		TRAP;

	AUDIO_ZR38521_REPEAT_16(pHwDevExt);
	AUDIO_TC9425_INIT_DIGITAL(pHwDevExt);
	AUDIO_TC9425_INIT_ANALOG(pHwDevExt);
	AUDIO_ZR38521_MUTE_OFF(pHwDevExt);

	// AudioType Analog
	PCIF_AMUTE2_OFF(pHwDevExt);
	PCIF_AMUTE_OFF(pHwDevExt);
}

void decSetAudioPCM( PHW_DEVICE_EXTENSION pHwDevExt ) // set audio mode PCM
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode = AUDIO_TYPE_PCM;

	VIDEO_PRSO_PS1( pHwDevExt );
	AUDIO_ZR38521_BOOT_PCM( pHwDevExt );

	AUDIO_ZR38521_CFG( pHwDevExt );
	AUDIO_ZR38521_PCMX( pHwDevExt );
	AUDIO_TC6800_INIT_PCM( pHwDevExt );
	SUBP_SELECT_AUDIO_SSID( pHwDevExt );

}

void decSetAudioAC3( PHW_DEVICE_EXTENSION pHwDevExt ) // set audio mode AC3
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode = AUDIO_TYPE_AC3;

	VIDEO_PRSO_PS1( pHwDevExt );
	AUDIO_ZR38521_BOOT_AC3( pHwDevExt );

	AUDIO_ZR38521_CFG( pHwDevExt );
	AUDIO_ZR38521_AC3( pHwDevExt );
	AUDIO_ZR38521_KCOEF( pHwDevExt );
	AUDIO_TC6800_INIT_AC3( pHwDevExt );
	SUBP_SELECT_AUDIO_SSID( pHwDevExt );
}


// video play speed/mode
void decSetVideoPlayMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode ) // set video playspeed/mode
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->PlayMode = mode;
}

ULONG decGetVideoPlayMode( PHW_DEVICE_EXTENSION pHwDevExt ) // get video pla speed/mode
{
	return ((PMasterDecoder)pHwDevExt->DecoderInfo)->PlayMode;
}

void decSetVideoRunMode( PHW_DEVICE_EXTENSION pHwDevExt, ULONG mode )
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->RunMode = mode;
}

ULONG decGetVideoRunMode( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return ((PMasterDecoder)pHwDevExt->DecoderInfo)->RunMode;
}

UCHAR decGetVideoPort( PHW_DEVICE_EXTENSION pHwDevExt ) // get video port
{
	return ((PMasterDecoder)pHwDevExt->DecoderInfo)->VideoPort;

}

void decSetVideoPort( PHW_DEVICE_EXTENSION pHwDevExt, UCHAR port ) // set video port
{
	((PMasterDecoder)pHwDevExt->DecoderInfo)->VideoPort = port;
    PCIF_SET_DIGITAL_OUT( pHwDevExt, port );

}




void decSetCopyGuard( PHW_DEVICE_EXTENSION pHwDevExt ) // set copy protection on HW
{

	BOOL ACGstatus;

	ACGstatus = CGuard_CPGD_SET_AGC_CHIP( pHwDevExt, pHwDevExt->RevID );

	ASSERTMSG( "\r\n...Analog Copy Guard Error!!", ACGstatus );

	// NTSC Analog Copy Guard Default Setting for Windows98 Beta 3
	//    Aspect Ratio  4:3
	//    Letter Box    OFF
	//    CGMS          3 ( No Copying is permitted )
	//    APS           2 ( AGC pulse ON, Burst Inv ON (2line) )
	CGuard_CPGD_SET_CGMSnCPGD( pHwDevExt, 0, 0, 3, 2 );


	USCC_on( pHwDevExt );


}


// get MPEG decoder interrupt status
UCHAR decGetMPegIntStatus( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR	val;
	UCHAR	val2;

	val = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRM );
	val2 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_IRF );
	val ^= val2;
	val2 &= val;
	return val2;
}

UCHAR decGetPciIntStatus( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR res = 0;

	return res;
}

void decHwIntVideo( PHW_DEVICE_EXTENSION pHwDevExt )
{
	UCHAR	val2;

//	DebugPrint( (DebugLevelTrace, "DVDTS:HwIntVideo\r\n") );


	// get MPEG decoder interrupt status
	val2 = decGetMPegIntStatus( pHwDevExt );


	if( val2 & 0x01 ) {
//		DebugPrint( (DebugLevelTrace, "DVDTS:  UDSC\r\n") );
		USCC_get( pHwDevExt );
	}
	if( val2 & 0x02 )
		DebugPrint( (DebugLevelTrace, "DVDTS:  Scr\r\n") );
	if( val2 & 0x04 )
		DebugPrint( (DebugLevelTrace, "DVDTS:  I-PIC\r\n") );
	if( val2 & 0x08 )
		DebugPrint( (DebugLevelTrace, "DVDTS:  User\r\n") );
	if( val2 & 0x10 ) {
		UCHAR val3;
		DebugPrint( (DebugLevelTrace, "DVDTS:  Error\r\n") );
		val3 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_ERF );
		DebugPrint( (DebugLevelTrace, "DVDTS:      Error %x\r\n", val3 ) );
	}
	if( val2 & 0x40 ) {
		int i;
		DebugPrint( (DebugLevelTrace, "DVDTS:  Underflow\r\n") );

		for( i = 0; i < 0xffff ; i++ )
			val2 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_STT1 );

		val2 = READ_PORT_UCHAR( pHwDevExt->ioBaseLocal + TC812_UOF );
		pHwDevExt->dwSTCtemp = VIDEO_GET_STCA( pHwDevExt );

		// Check Audio Underflow
		StreamClassScheduleTimer(
			pHwDevExt->pstroAud,
			pHwDevExt,
			0,
			(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
			pHwDevExt
		);

		StreamClassScheduleTimer(
			pHwDevExt->pstroAud,
			pHwDevExt,
			10000,
			(PHW_TIMER_ROUTINE)CheckAudioUnderflow,
			pHwDevExt
		);
	}
}

void decHwIntVSync( PHW_DEVICE_EXTENSION pHwDevExt )
{
	static v_count = 0;
	static v_count2 = 0;
	static v_count3 = 0;
//	ULONG	TrickMode;

	WRITE_PORT_UCHAR( pHwDevExt->ioBaseLocal + IFLG_INT, 0x10 );

	CGuard_CPGD_UPDATE_AGC(pHwDevExt);

	USCC_put( pHwDevExt );

	if( ++v_count < 3 )
		return;

	v_count = 0;

// 20 / 1s

	// notes: You have to call VIDEO_BUG_SLIDE_01 to recover MPEG2 chip bug
	//        when trick mode isn't FREEZE mode.
	//        But don't use VIDEO_GET_TRICK_MODE to get current trick mode.
	//        Because MPEG2 chip returns wrong value sometimes.

	//	TrickMode = pHwDevExt->VDec.VIDEO_GET_TRICK_MODE();
//	if( TrickMode != 0x02 ) {
	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->PlayMode != PLAY_MODE_FREEZE /*&& pHwDevExt->DecodeStart == TRUE*/ ) {
		VIDEO_BUG_SLIDE_01( pHwDevExt );
	}

	if( ++v_count2 < 4 )
		return;

	v_count2 = 0;

// 5 / 1s ???
	ClockEvents( pHwDevExt );

// debug

	if( ++v_count3 < 50 )
		return;

	v_count3 = 0;

// 1 / 60s
//	DebugPrint((
//		DebugLevelTrace,
//		"DVDTS:  VSync 10s (0x%s(100ns))\r\n",
//		DebugLLConvtoStr( ConvertPTStoStrm( VIDEO_GET_STCA(pHwDevExt) ), 16 )
//		));
}



void decStopData( PHW_DEVICE_EXTENSION pHwDevExt, BOOL bKeep )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:decStopData()\r\n" ));

	AUDIO_ZR38521_STOPF( pHwDevExt );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );

	if( !bKeep ) {
		VPRO_VIDEO_MUTE_ON( pHwDevExt );
		CGuard_CPGD_VIDEO_MUTE_ON( pHwDevExt );
	}

	VIDEO_DECODE_STOP( pHwDevExt );
	VIDEO_SYSTEM_STOP( pHwDevExt );
	SUBP_STC_OFF( pHwDevExt );

//	pHwDevExt->DAck.PCIF_DMA_ABORT( pHwDevExt );

	VIDEO_STD_CLEAR( pHwDevExt );
	SUBP_BUFF_CLEAR( pHwDevExt );
	VIDEO_SYSTEM_STOP( pHwDevExt );
	VIDEO_DECODE_INT_OFF( pHwDevExt );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_AC3 )
		AUDIO_TC6800_INIT_AC3( pHwDevExt );
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_PCM )
		AUDIO_TC6800_INIT_PCM( pHwDevExt );
	else
		TRAP;
}

void decHighlight( PHW_DEVICE_EXTENSION pHwDevExt, PKSPROPERTY_SPHLI phli )
{
//h	DebugPrint(( DebugLevelTrace, "DVDTS:decHighlight\r\n" ));

	UCHAR ln_ctli[4];
	UCHAR px_ctlis[6];
	UCHAR px_ctlie[6];

	if( phli->StartX == phli->StopX && phli->StartY == phli->StopY ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  Highlight Off\r\n" ));
		SUBP_HLITE_OFF( pHwDevExt );
	}
	else {
		SUBP_HLITE_ON( pHwDevExt );
		ln_ctli[3] = (UCHAR)(( phli->StartY >> 8 ) & 0x03);
		ln_ctli[2] = (UCHAR)(phli->StartY & 0xff);
		ln_ctli[1] = (UCHAR)(( phli->StopY >> 8 ) & 0x03 | 0x20);
		ln_ctli[0] = (UCHAR)(phli->StopY & 0xff);

		px_ctlis[5] = (UCHAR)(( phli->StartX >> 8 ) & 0x03);
		px_ctlis[4] = (UCHAR)(phli->StartX & 0xff);
		px_ctlis[3] = (UCHAR)(phli->ColCon.emph2col << 4 | phli->ColCon.emph1col);
		px_ctlis[2] = (UCHAR)(phli->ColCon.patcol   << 4 | phli->ColCon.backcol);
		px_ctlis[1] = (UCHAR)(phli->ColCon.emph2con << 4 | phli->ColCon.emph1con);
		px_ctlis[0] = (UCHAR)(phli->ColCon.patcon   << 4 | phli->ColCon.backcon);

		px_ctlie[5] = (UCHAR)(( phli->StopX >> 8 ) & 0x03 | 0x08);
		px_ctlie[4] = (UCHAR)(phli->StopX & 0xff);
		px_ctlie[3] = 0;
		px_ctlie[2] = 0;
		px_ctlie[1] = 0;
		px_ctlie[0] = 0;

//h		DebugPrint( (DebugLevelTrace, "DVDTS:  %d, %d - %d, %d : %02x%02x%02x%02x\r\n",
//h			phli->StartX, phli->StartY, phli->StopX, phli->StopY,
//h			px_ctlis[3], px_ctlis[2], px_ctlis[1], px_ctlis[0]
//h			) );

		SUBP_SET_PXCTLIE( pHwDevExt, px_ctlie );
		SUBP_SET_PXCTLIS( pHwDevExt, px_ctlis );
		SUBP_SET_LNCTLI( pHwDevExt, ln_ctli );
	}
}

void decDisableInt( PHW_DEVICE_EXTENSION pHwDevExt )
{
	VIDEO_ALL_INT_OFF( pHwDevExt );
	PCIF_VSYNC_OFF( pHwDevExt );
}

void decGenericNormal( PHW_DEVICE_EXTENSION pHwDevExt )
{

	DWORD st, et;
	ULONG	TrickMode;
	ULONG	dwSTC;

	DebugPrint( (DebugLevelTrace, "DVDTS:  decGenericNormal\r\n") );

	if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_AC3 )
		AUDIO_TC6800_INIT_AC3( pHwDevExt );
	else if( ((PMasterDecoder)pHwDevExt->DecoderInfo)->ADec.AudioMode == AUDIO_TYPE_PCM )
		AUDIO_TC6800_INIT_PCM( pHwDevExt );
	else
		TRAP;

	AUDIO_ZR38521_STOPF( pHwDevExt );
	VIDEO_PRSO_PS1( pHwDevExt );
	VIDEO_PLAY_NORMAL( pHwDevExt );

// Bad loop !!

	st = GetCurrentTime_ms();
	for( ; ; ) {
		KeStallExecutionProcessor( 1 );
		et = GetCurrentTime_ms();

		TrickMode = VIDEO_GET_TRICK_MODE( pHwDevExt );
		if( TrickMode == 0x07 )
			break;

		if( st + 2000 < et ) {
			TRAP;
			break;
		}
	}
	DebugPrint( (DebugLevelTrace, "DVDTS:  wait %dms\r\n", et - st ) );

	dwSTC = VIDEO_GET_STCA( pHwDevExt );
	AUDIO_ZR38521_VDSCR_ON( pHwDevExt, dwSTC );
	AUDIO_ZR38521_PLAY( pHwDevExt );
	VIDEO_UFLOW_INT_ON( pHwDevExt );

	DebugPrint(( DebugLevelTrace, "DVDTS:  STC 0x%x( %d )\r\n", dwSTC, dwSTC ));
}

void decGenericFreeze( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:  decGenericFreeze\r\n" ));
	VIDEO_PLAY_FREEZE( pHwDevExt );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );
	AUDIO_ZR38521_STOP( pHwDevExt );
}

void decGenericSlow( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  decGenericSlow\r\n") );
	VIDEO_PRSO_PS1( pHwDevExt );
	SUBP_SET_AUDIO_NON( pHwDevExt );
	VIDEO_PLAY_SLOW( pHwDevExt, (UCHAR)(pHwDevExt->Rate/10000) );
	AUDIO_ZR38521_STOP( pHwDevExt );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );
	VIDEO_UFLOW_INT_ON( pHwDevExt );
}

void decStopForFast( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:  decGenericFast\r\n" ));
	VIDEO_UFLOW_INT_OFF( pHwDevExt );
	VIDEO_SET_STCA( pHwDevExt, (ULONG)(pHwDevExt->StartTime / 1000 * 9) );
	VIDEO_PRSO_NON( pHwDevExt );
	VIDEO_PLAY_FAST( pHwDevExt, FAST_ONLYI );
	AUDIO_ZR38521_MUTE_ON( pHwDevExt );
	AUDIO_ZR38521_STOP( pHwDevExt );
	SUBP_MUTE_ON( pHwDevExt );
	SUBP_STC_OFF( pHwDevExt );
	VIDEO_DECODE_STOP( pHwDevExt );
}

void decResumeForFast( PHW_DEVICE_EXTENSION pHwDevExt )
{
	VIDEO_STD_CLEAR( pHwDevExt );
	AUDIO_ZR38521_STOPF( pHwDevExt );
	SUBP_BUFF_CLEAR( pHwDevExt );
	VIDEO_DECODE_START( pHwDevExt );
}

void decFastNormal( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  decFastNormal\r\n") );
	VIDEO_PRSO_PS1( pHwDevExt );
	pHwDevExt->dwSTCtemp = VIDEO_GET_STCA( pHwDevExt );
}

void decFastSlow( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint( (DebugLevelTrace, "DVDTS:  decFastSlow\r\n") );
	VIDEO_PRSO_PS1( pHwDevExt );
	SUBP_SET_AUDIO_NON( pHwDevExt );
	pHwDevExt->dwSTCtemp = VIDEO_GET_STCA( pHwDevExt );
}

void decFastFreeze( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:  decFastFreeze\r\n" ));

	pHwDevExt->dwSTCinPause = VIDEO_GET_STCA( pHwDevExt );
	VIDEO_PLAY_FREEZE( pHwDevExt );
}

void decFreezeFast( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DebugPrint(( DebugLevelTrace, "DVDTS:  decFreezeFast\r\n" ));
	VIDEO_SET_STCA( pHwDevExt, pHwDevExt->dwSTCinPause );
	VIDEO_PLAY_FAST( pHwDevExt, FAST_ONLYI );
}



void decInitAudioAfterNewFormat( PHW_DEVICE_EXTENSION pHwDevExt )
{
	AUDIO_ZR38521_REPEAT_16( pHwDevExt );
	AUDIO_TC9425_INIT_DIGITAL( pHwDevExt );
	AUDIO_TC9425_INIT_ANALOG( pHwDevExt );
}


void decGetLPCMInfo( void *pBuf, PMYAUDIOFORMAT pfmt )
{
	PUCHAR  pDat = (PUCHAR)pBuf;
	UCHAR	headlen;
	UCHAR	val;

	pDat += 14;

	ASSERT( *( pDat + 3 ) == 0xBD );

	headlen = *( pDat + 8 );

	ASSERT( ( *( pDat + 9 + headlen ) & 0xF8 ) == 0xA0 );

	val = (UCHAR)(( *( pDat + 9 + headlen + 5 ) & 0xC0 ) >> 6);

	if( val == 0x00 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  16bits\r\n" ));
		pfmt->dwQuant = AUDIO_QUANT_16;
	}
	else if( val == 0x01 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  20bits\r\n" ));
		pfmt->dwQuant = AUDIO_QUANT_20;
	}
	else if( val == 0x10 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  24bits\r\n" ));
		pfmt->dwQuant = AUDIO_QUANT_24;
	}
	else
		TRAP;

	val = (UCHAR)(( *( pDat + 9 + headlen + 5 ) & 0x30 ) >> 4);

	if( val == 0x00 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  48kHz\r\n" ));
		pfmt->dwFreq = AUDIO_FS_48;
	}
	else if( val == 0x01 ) {
		DebugPrint(( DebugLevelTrace, "DVDTS:  96kHz\r\n" ));
		pfmt->dwFreq = AUDIO_FS_96;
	}
	else
		TRAP;

	return;
}

// misc HW routines used by dvdcmd.c
void  decSUBP_STC_ON( PHW_DEVICE_EXTENSION pHwDevExt )
{
	SUBP_STC_ON( pHwDevExt );
}

void  decSUBP_STC_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	SUBP_STC_OFF( pHwDevExt );
}

void  decVPRO_SUBP_PALETTE(  PHW_DEVICE_EXTENSION pHwDevExt ,PUCHAR pPalData )
{
	VPRO_SUBP_PALETTE(   pHwDevExt , pPalData );
}

void  decSUBP_SET_AUDIO_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch )
{
	  SUBP_SET_AUDIO_CH(  pHwDevExt ,  ch );
}

ULONG decSUBP_GET_AUDIO_CH( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return SUBP_GET_AUDIO_CH(  pHwDevExt );
}

void  decSUBP_SET_SUBP_CH(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG ch )
{
	SUBP_SET_SUBP_CH( pHwDevExt ,  ch );
}

ULONG decSUBP_GET_SUBP_CH( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return SUBP_GET_SUBP_CH(  pHwDevExt );
}


void  decSUBP_SET_STC(  PHW_DEVICE_EXTENSION pHwDevExt , ULONG stc )
{
	SUBP_SET_STC(  pHwDevExt ,  stc );
}

void decCGuard_CPGD_SET_ASPECT( PHW_DEVICE_EXTENSION pHwDevExt, ULONG aspect )
{
	CGuard_CPGD_SET_ASPECT( pHwDevExt, aspect );
}

void decCGuard_CPGD_SUBP_PALETTE( PHW_DEVICE_EXTENSION pHwDevExt, PUCHAR pPalData )
{
	CGuard_CPGD_SUBP_PALETTE(  pHwDevExt,  pPalData );
}


NTSTATUS decAUDIO_ZR38521_STAT( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pDiff )
{
	return AUDIO_ZR38521_STAT(  pHwDevExt,  pDiff );
}

NTSTATUS decAUDIO_ZR38521_MUTE_OFF(PHW_DEVICE_EXTENSION pHwDevExt)
{
	return AUDIO_ZR38521_MUTE_OFF( pHwDevExt);
}

NTSTATUS decAUDIO_ZR38521_BFST( PHW_DEVICE_EXTENSION pHwDevExt, PULONG pErrCode )
{
	return AUDIO_ZR38521_BFST(  pHwDevExt,  pErrCode );
}

NTSTATUS decAUDIO_ZR38521_STOP(PHW_DEVICE_EXTENSION pHwDevExt)
{
	return  AUDIO_ZR38521_STOP( pHwDevExt);
}

NTSTATUS decAUDIO_ZR38521_VDSCR_ON( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stc )
{
	return AUDIO_ZR38521_VDSCR_ON(  pHwDevExt,  stc );
}

void decVIDEO_SET_STCA( PHW_DEVICE_EXTENSION pHwDevExt, ULONG stca )
{
	VIDEO_SET_STCA( pHwDevExt,  stca );
}

ULONG decVIDEO_GET_STD_CODE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return VIDEO_GET_STD_CODE(  pHwDevExt );
}

BOOL decVIDEO_GET_DECODE_STATE( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return VIDEO_GET_DECODE_STATE(  pHwDevExt );
}

NTSTATUS decVIDEO_DECODE_STOP( PHW_DEVICE_EXTENSION pHwDevExt )
{
	return VIDEO_DECODE_STOP(  pHwDevExt );
}

void decVIDEO_UFLOW_INT_OFF( PHW_DEVICE_EXTENSION pHwDevExt )
{
	VIDEO_UFLOW_INT_OFF(  pHwDevExt );
}

void decVIDEO_PRSO_PS1( PHW_DEVICE_EXTENSION pHwDevExt )
{
	VIDEO_PRSO_PS1(  pHwDevExt );
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\regs.h ===
//***************************************************************************
//	Decoder board register header
//
//***************************************************************************

//===========================================================================
//   PCI I/F REGISTERS
//===========================================================================
#define	PCIF_CNTL	0x00	// PCI I/F control
#define	PCIF_INTF	0x04	// Interrupt flags
#define	PCIF_MADRLL	0x08	// DMA address low-low
#define	PCIF_MADRLH	0x09	// DMA address low-high
#define	PCIF_MADRHL	0x0a	// DMA address high-low
#define	PCIF_MADRHH	0x0b	// DMA address high-high
#define	PCIF_MTCLL	0x0c	// DMA counter low-low
#define	PCIF_MTCLH	0x0d	// DMA counter low-high
#define	PCIF_MTCHL	0x0e	// DMA counter high-low
#define	PCIF_MTCHH	0x0f	// DMA counter high-high

#define	PCIF_CPLT	0x10	// Color palette
#define	PCIF_CPCNT	0x11	// Color palette control

#define	PCIF_VMODE	0x14	// video mode
#define	PCIF_HSCNT	0x15	// HSYNC count
#define	PCIF_VSCNT	0x16	// VSYNC count
#define	PCIF_HSVS	0x17	// HS/VS porarity

#define	PCIF_EEPROM	0x20	// EEPROM access

#define	PCIF_PSCNT	0x22	// PS coontrol
#define	PCIF_TEST	0x23	// test control
#define	PCIF_SCNT	0x24	// serial access control
#define	PCIF_SW		0x25	// serial write
#define	PCIF_SR		0x26	// serial read

#define	PCIF_SNOLL	0x28	// board serial # LL
#define	PCIF_SNOLH	0x29	// board serial # LH
#define	PCIF_SNOMM	0x2a	// board serial # MM
#define	PCIF_SNOHL	0x2b	// board serial # HL
#define	PCIF_SNOHH	0x2c	// board serail # HH

//===========================================================================
//   MPEG DECODER(TC81201F) REGISTERS
//===========================================================================
#define	TC812_DATA1	0x80	// data1
#define	TC812_DATA2	0x81	// data2
#define	TC812_DATA3	0x82	// data3
#define	TC812_DATA4	0x83	// data4
#define	TC812_DATA5	0x84	// data5
#define	TC812_DATA6	0x85	// data6
#define	TC812_DATA7	0x86	// data7
#define	TC812_CMDR1	0x87	// command1
//#define	TC812_CMDR2	0x88	// command2

#define	TC812_DSPL	0x8b	// filter

#define	TC812_STT1	0x8e	// status1
#define	TC812_STT2	0x8f	// status2
#define	TC812_IRF	0x90	// interrupt flags
#define	TC812_IRM	0x91	// interrupt masks
#define	TC812_DEF	0x92	// decode end flag
#define	TC812_WEF	0x93	// packet end flag
#define	TC812_ERF	0x94	// error interrupt flag

#define	TC812_UOF	0x96	// under/over flow flag

#define	TC812_DEM	0x97	// Decode end mask (R/W)
#define	TC812_WEM	0x98	// Packet end mask (R/W)
#define	TC812_ERM	0x99	// Error interrupt mask (R/W)

#define	TC812_UOM	0x9B	// Under/Over flow mask (R/W)
#define	TC812_UDAT	0x9C	// User data read (R)
#define	TC812_BST	0x9D	// Bit stream write (R/W)
#define	TC812_UAR	0x9E	// User area data read (R)
#define	TC812_IVEC	0x9F	// Interrupt vector (R/W)

//======= Command Definitions (values for CMDR1 register) =============
#define	V_SET_SYS	0x01	// Set System decode mode
#define	V_GET_SYS	0x21	// Get System decode mode

#define	V_SET_DEC_MODE	0x02	// Set decode mode
#define	V_GET_DEC_MODE	0x22	// Get decode mode

#define	V_SET_INT_ID	0x03	// Set internal decode stream id
#define	V_GET_INT_ID	0x23	// Get internal decode stream id

#define	V_SET_PRSO_ID	0x04	// Set PRSO stream id
#define	V_GET_PRSO_ID	0x24	// Get PRSO stream id

#define	V_SET_USER_ID	0x06	// Set USER1/2 stream id
#define	V_GET_USER_ID	0x26	// Get USER1/2 stream id

#define	V_SET_UOF_SIZE	0x07	// Set under/overflow size
#define	V_GET_UOF_SIZE	0x27	// Get under/overflow size

#define	V_GET_STD_CODE	0x29	// Get STD buffer size

#define	V_SET_STCA	0x0B	// Set STCA value
#define	V_GET_STCA	0x2B	// Get STCA value

#define	V_SET_STCS	0x0C	// Set STCS value
#define	V_GET_STCS	0x2C	// Get STCS value

#define	V_GET_STCC	0x2D	// Get STCC value

#define	V_GET_SCR	0x2E	// Get SCR value

#define	V_SET_STCR_END	0x0D	// Set STC/SCR read end

#define	V_USER1_CLEAR	0x0F	// USER1 area clear
#define	V_USER2_CLEAR	0x10	// USER2 area clear

#define	V_SET_PVSIN	0x11	// Set PVSIN enable
#define	V_GET_PVSIN	0x31	// Get PVSIN state

#define	V_SET_WRITE_MEM	0x13	// Set write mem mode
#define	V_WRITE_MEMORY	0x14	// Write memory
#define	V_READ_MEMORY	0x34	// Read memory
#define	V_STOP_MEMORY	0x15	// Stop memory access

#define	V_SET_DECODE	0x41	// Start decode
#define	V_GET_DECODE	0x61	// Stop decode

#define	V_TRICK_NORMAL	0x42	// Play normal mode
#define	V_TRICK_FAST	0x43	// Play fast mode
#define	V_TRICK_SLOW	0x44	// Play slow mode
#define	V_TRICK_FREEZE	0x45	// Play freeze mode
#define	V_TRICK_STILL	0X46	// Play still mode

#define	V_GET_TRICK	0x67	// Get trick mode

#define	V_STD_CLEAR	0x48	// STD buffer clear

#define	V_SET_UDATA	0x4F	// Set USER data mode
#define	V_GET_UDATA	0x6F	// Get USER data mode

#define	V_SET_DTS	0x50	// Set DTS
#define	V_GET_DTS	0x70	// Get DTS

#define	V_SET_PTS	0x51	// Set PTS
#define	V_GET_PTS	0x71	// Get PTS

#define	V_SET_SEEMLES	0x55	// Set seemless mode

#define	V_SET_VFMODE	0x58	// Set video frame mode

#define	V_SET_STD_SIZE	0x59	// Set STD buffer size
#define	V_GET_STD_SIZE	0x79	// Get STD buffer size
#define	V_SET_USER_SIZE	0x5B	// Set USER area size
#define	V_GET_USER_SIZE	0x7B	// Get USER area size
#define	V_SET_MEM_MAP	0x5F	// Set memory mapping

#define	V_SET_VCD	0x5C	// Set Video-CD static mode

#define	V_CHK_DEC_STATE	0x5D	// Check decode state
#define	V_GET_DEC_STATE	0x7D	// Get Decoding state

#define	V_UF_CURB	0x5E	// Under-flow curb mode

#define	V_SET_DMODE	0x81	// Set display mode
#define	V_GET_DMODE	0xA1	// Get display mode

#define	V_SET_HOFFSET	0x82	// Set horizontal offset
#define	V_GET_HOFFSET	0xA2	// Get horizontal offset

#define	V_SET_VOFFSET	0x83	// Set virtical offset
#define	V_GET_VOFFSET	0xA3	// Get virtical offset

#define	V_SET_HAREA	0x84	// Set horizontal area
#define	V_GET_HAREA	0xA4	// Get horizontal area

#define	V_SET_VAREA	0x85	// Set horizontal area
#define	V_GET_VAREA	0xA5	// Get horizontal area

#define	V_GET_V_DTS	0xB0	// Get decoding DTS value

#define	V_RESET		0xC1	// Reset & set default mode

//===========================================================================
//   VIDEO PROCESSOR(TC90A09F) REGISTERS
//===========================================================================
#define	SUBP_RESET	0x40	// Sub-Pic Reset
#define	SUBP_COMMAND	0x41	// Command
#define	SUBP_STSINT	0x42	// Status & Interrupt mask
//#define	SUBP_OFFSET	0x43	// Offset
#define	SUBP_STCHH	0x44	// STC 32:25
#define	SUBP_STCHL	0x45	// STC 24:17
#define	SUBP_STCLH	0x46	// STC 16:09
#define	SUBP_STCLL	0x47	// STC 08:01
#define	SUBP_LCINFHH	0x48	// LCINF 32:25
#define	SUBP_LCINFHL	0x49	// LCINF 24:17
#define	SUBP_LCINFLH	0x4A	// LCINF 16:09
#define	SUBP_LCINFLL	0x4B	// LCINF 08:01
#define	SUBP_PCINFSHH	0x4C	// PCINFS 47:40
#define	SUBP_PCINFSHL	0x4D	// PCINFS 39:32
#define	SUBP_PCINFSMH	0x4E	// PCINFS 31:24
#define	SUBP_PCINFSML	0x4F	// PCINFS 23:16
#define	SUBP_PCINFSLH	0x50	// PCINFS 15:08
#define	SUBP_PCINFSLL	0x51	// PCINFS 07:01
#define	SUBP_PCINFEHH	0x52	// PCINFE 47:40
#define	SUBP_PCINFEHL	0x53	// PCINFE 39:32
#define	SUBP_PCINFEMH	0x54	// PCINFE 31:24
#define	SUBP_PCINFEML	0x55	// PCINFE 23:16
#define	SUBP_PCINFELH	0x56	// PCINFE 15:08
#define	SUBP_PCINFELL	0x57	// PCINFE 07:01
#define	SUBP_MODE	0x58	// Audio word alignment
#define	SUBP_STCCNT	0x59	// STC Count
#define	SUBP_SPID	0x5A	// Sub-Pic sub-stream id
#define	SUBP_ASEL	0x5B	// Audio select(sub/stream id?)
#define	SUBP_CC1	0x5C	// Closed caption data1
#define	SUBP_CC2	0x5D	// Closed caption data2
#define	SUBP_AAID	0x5E	// Audio-A (sub)stream id
#define	SUBP_ABID	0x5F	// Audio-B (sub)stream id

#define	VPRO_RESET	0x60	// V-PRO Reset
#define	VPRO_VMODE	0x61	// Video mode & US caption
#define	VPRO_CPSET	0x62	// Color palette setting
#define	VPRO_CPSP	0x63	// Color palette (Sub-pic)
#define	VPRO_AVM	0x64	// Analog video mode
#define	VPRO_DVEN	0x65	// Digital output
#define	VPRO_CPG	0x66	// Copy guard
#define	VPRO_CAGC	0x68	// AGC puls(Composit)
#define	VPRO_YAGC	0x69	// AGC puls(Y)
#define	VPRO_LAGC	0x6A	// AGC low-bit
#define	VPRO_CPOSD	0x6B	// Color palette (OSD)

//===========================================================================
//   VIDEO ANALOG COPY GUARD PROCESSOR(TC6802AF) REGISTERS
//===========================================================================
#define	CPGD_RESET	0xA0	// Reset
#define	CPGD_VMODE	0xA1	// Video mode
#define	CPGD_CPSET	0xA2	// Color palette setteing
#define	CPGD_CPSP	0xA3	// Color palette
#define	CPGD_AVM	0xA4	// Analog video mode
#define	CPGD_DVEN	0xA5	// Digital output
#define	CPGD_CPG	0xA6	// Copy guard setting

#define	CPGD_CAGC	0xA8	// AGC(Composit)
#define	CPGD_YAGC	0xA9	// AGC(Y)
#define	CPGD_LAGC	0xAA	// AGC(low bit)
#define	CPGD_CDG	0xAB	// CDG
#define	CPGD_BSTLN	0xAC	// Burst Inv number
#define	CPGD_BSTSE	0xAD	// Burst Inv timing
#define	CPGD_BSTLSL	0xAE	// Burst Inv line(Low)
#define	CPGD_BSTLSH	0xAF	// Burst Inv line(High)
#define	CPGD_CGMSAL	0xB0	// CGMS-A(Low)
#define	CPGD_CGMSAM	0xB1	// CGMS-A(Middle)
#define	CPGD_CGMSAH	0xB2	// CGMS-A(High)
#define	CPGD_BSTINT	0xB3	// Color burst interval
#define	CPGD_BSTONY	0xB4	// Burst(Y)

//***************************************************************************
//              M I S S I O L I N O U S   D E F I N I T I O N S
//***************************************************************************
//===========================================================================
//   MPEG (SUB-)STREAM ID
//===========================================================================
#define	STRMID_MPEG_AUDIO	0xc0
#define	STRMID_MPEG_VIDEO	0xe0
#define	STRMID_PRIVATE_1	0xbd
#define	STRMID_PRIVATE_2	0xbf

#define	SUB_STRMID_SUBP		0x20
#define	SUB_STRMID_VBI		0x48
#define	SUB_STRMID_AC3		0x80
#define	SUB_STRMID_SRSV_DTS	0x88
#define	SUB_STRMID_SRSV_SDDS	0x90
#define	SUB_STRMID_PCM		0xa0

#define	SUB_STRMID_PCI		0x00
#define	SUB_STRMID_DSI		0x01

//===========================================================================
//   STREAM MODE
//===========================================================================
#define	STREAM_MODE_VELS	0x01
#define	STREAM_MODE_PES		0x03
#define	STREAM_MODE_PS		0x07
#define	STREAM_MODE_DVD		0x0F
#define	STREAM_MODE_VCD		0x10


//===========================================================================
//   PLAY STOP STATE
//===========================================================================
#define	STOP_KEEP	0x01
#define	STOP_FLASH	0x02

//===========================================================================
//   UFLOW EVENT STATE
//===========================================================================
#define	EVENT_FATAL_UFLOW	0x01
#define	EVENT_NORMAL_UFLOW	0x02

//===========================================================================
//   AUDIO MUTE STATE
//===========================================================================
#define	AUDIO_MUTE_ON	0x00
#define	AUDIO_MUTE_OFF	0x01

//===========================================================================
//   AUDIO OUT MODE
//===========================================================================
#define	AUDIO_OUT_DIGITAL	0x00
#define	AUDIO_OUT_ANALOG	0x01

//===========================================================================
//   AUDIO COPY PROTECT
//===========================================================================
#define	AUDIO_COPY_ON	0x00
#define	AUDIO_COPY_OFF	0x01

//===========================================================================
//   SUBPIC MUTE STATE
//===========================================================================
#define	SUBPIC_MUTE_ON	0x00
#define	SUBPIC_MUTE_OFF	0x01

//===========================================================================
//   SUBPIC Hi-LITE STATE
//===========================================================================
#define	SUBPIC_HLITE_ON		0x00
#define	SUBPIC_HLITE_OFF	0x01

//===========================================================================
//   OSD MUTE STATE
//===========================================================================
#define	OSD_MUTE_ON	0x00
#define	OSD_MUTE_OFF	0x01

//===========================================================================
//   OSD BLINK STATE
//===========================================================================
#define	OSD_BLINK_ON	0x00
#define	OSD_BLINK_OFF	0x01

//===========================================================================
//   OSD REVERSE STATE
//===========================================================================
#define	OSD_REVERSE_ON	0x00
#define	OSD_REVERSE_OFF	0x01

//===========================================================================
//   VIDEO MUTE STATE
//===========================================================================
#define	VIDEO_MUTE_ON	0x00
#define	VIDEO_MUTE_OFF	0x01

//===========================================================================
//   LETTER BOX STATE
//===========================================================================
#define	LETTER_BOX_ON	0x00
#define	LETTER_BOX_OFF	0x01

//===========================================================================
//   PAN-SCAN STATE
//===========================================================================
#define	PANSCAN_ON	0x00
#define	PANSCAN_OFF	0x01

//===========================================================================
//   DECODE FALSE STATE
//===========================================================================
#define	VIDEO_NO_DATA	0x01

//===========================================================================
//   COLOR PALTTE SELECTION
//===========================================================================
#define	PALETTE_Y	0x01
#define	PALETTE_CB	0x02
#define	PALETTE_CR	0x03

//===========================================================================
//   ANALOG IMAGE COPY GURAD MODE 
//===========================================================================
#define	APS_TYPE_OFF	0x00
#define	APS_TYPE_1	0x01
#define	APS_TYPE_2	0x02
#define	APS_TYPE_3	0x03

//===========================================================================
//   FREEZE COUNTER STATE 
//===========================================================================
#define	FREEZE_ONCE	0x00
#define	FREEZE_PLURAL	0x01

//===========================================================================
//   I-PICTURE INTERRUPT SWITCH
//===========================================================================
#define	IPIC_SW_ON	0x00
#define	IPIC_SW_OFF	0x01

//===========================================================================
//   FLAG for CATCH_IPIC return OK or not
//===========================================================================
#define	IPIC_RET_ON	0x00
#define	IPIC_RET_OFF	0x01

//***************************************************************************
// non-hardware-register-related hardware state defines
//***************************************************************************
//===========================================================================
//   AUDIO_MODE NON-REGISTER-RELATED HARDWARE MODE DEFINITIONS
//===========================================================================
#define	AUDIO_TYPE_AC3		0x01
#define	AUDIO_TYPE_MPEG_F1	0x02
#define	AUDIO_TYPE_MPEG_F2	0x03
#define	AUDIO_TYPE_PCM		0x04

#define	AUDIO_FS_32		0x01
#define	AUDIO_FS_44		0x02
#define	AUDIO_FS_48		0x03
#define	AUDIO_FS_96		0x04

#define	AUDIO_QUANT_16		0x01
#define	AUDIO_QUANT_20		0x02
#define	AUDIO_QUANT_24		0x03

#define	AUDIO_CGMS_03	0x03	// No Copying is permitted.
#define	AUDIO_CGMS_02	0x02	// One generation of copies may be made
#define AUDIO_CGMS_00	0x00	// Copying is permitted without restriction

//===========================================================================
//   VIDEO PLAY_MODE NON-REGISTER-RELATED HARDWARE MODE DEFINITIONS
//===========================================================================

#define	PLAY_MODE_NORMAL	0x01
#define	PLAY_MODE_FAST		0x02
#define	PLAY_MODE_SLOW		0x03
#define	PLAY_MODE_FREEZE	0x04
#define	PLAY_MODE_STILL		0x05

#define	FAST_ONLYI		0x01
#define	FAST_IANDP		0x02

//===========================================================================
//   SUBP_HLITE NON-REGISTER-RELATED HARDWARE MODE DEFINITIONS
//===========================================================================

#define	SUBPIC_HLITE_ON		0x00
#define	SUBPIC_HLITE_OFF	0x01

//===========================================================================
//   DISPLAY_MODE NON-REGISTER-RELATED HARDWARE MODE DEFINITIONS
//===========================================================================

#define	DISPLAY_MODE_NTSC	0x01
#define	DISPLAY_MODE_PAL	0x02

#define	ASPECT_04_03		0x00
#define	ASPECT_16_09		0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\adapter.c ===
/******************************************************************************\
*                                                                              *
*      ADAPTER.C  -     Adapter control related code.                          *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996 - 1999                                 *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/


#include "Headers.h"

#pragma hdrstop
#include "vidstrm.h"
#include "audstrm.h"
#include "sbpstrm.h"
#include "ccaption.h"

#ifdef ENCORE
#include "avwinwdm.h"
#include "anlgstrm.h"
#else
#include "vpestrm.h"
#include "dataXfer.h"
#endif

#include "zivaguid.h"
#include "boardio.h"
#include "bmaster.h"
#include "cl6100.h"

#include "Hwif.h"

static VOID HwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID HwUninitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID AdapterOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID AdapterCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID AdapterStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID AdapterGetDataIntersection( PHW_STREAM_REQUEST_BLOCK pSrb );

static VOID BeginHwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID HighPriorityInit( IN PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID PassiveInit( IN PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID HighPriorityInit( IN PHW_STREAM_REQUEST_BLOCK pSrb );

VOID STREAMAPI AdapterReleaseCurrentSrb( PHW_STREAM_REQUEST_BLOCK pSrb );

#pragma alloc_text( page, HwInitialize )
#pragma alloc_text( page, HwUninitialize )


#if 0
static void STREAMAPI CreateFile(PHW_STREAM_REQUEST_BLOCK pSrb );
OBJECT_ATTRIBUTES	InitializedAttributes;
IO_STATUS_BLOCK		IOStatusBlock;
HANDLE	Handle;
WCHAR		wPath[] = L"ohm.dat";
UNICODE_STRING		pathUnicodeString;
LARGE_INTEGER		AllocSize ;
long dwCountTotal=0;
#endif

PHW_DEVICE_EXTENSION pDevEx;


/******************************************************************************

                   Adapter Based Request Handling Routines

******************************************************************************/

/*
** AdapterReceivePacket()
**
**   Main entry point for receiving adapter based request SRBs.  This routine
**   will always be called at High Priority.
**
**   Note: This is an asyncronous entry point.  The request does not complete
**         on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{	
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->CommandData.ConfigInfo->HwDeviceExtension;
	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterReceivePacket->" ));

#ifdef DEBUG
	if( KeGetCurrentIrql() <= DISPATCH_LEVEL )
	{
		DebugPrint(( DebugLevelError, "IRQL is screwed!\n" ));
		ASSERT( FALSE );
		MonoOutSetBlink( TRUE );
		MonoOutStr( "IRQL" );
		MonoOutSetBlink( FALSE );
	}
#endif

	switch( pSrb->Command )
	{
	case SRB_INITIALIZE_DEVICE:
		DebugPrint(( DebugLevelVerbose, "SRB_INITIALIZE_DEVICE\n" ));
	
//		HwInitialize( pSrb );
//		break;
		BeginHwInitialize( pSrb ); //MS update
		return;


	case SRB_UNINITIALIZE_DEVICE:
		DebugPrint(( DebugLevelVerbose, "SRB_UNINITIALIZE_DEVICE\n" ));
		HwUninitialize( pSrb );
		break;

	case SRB_OPEN_STREAM:
		DebugPrint(( DebugLevelVerbose, "SRB_OPEN_STREAM\n" ));
		AdapterOpenStream( pSrb );
		break;

	case SRB_CLOSE_STREAM:
		DebugPrint(( DebugLevelVerbose, "SRB_CLOSE_STREAM\n" ));
		AdapterCloseStream( pSrb );
		break;

	case SRB_GET_STREAM_INFO:
		DebugPrint(( DebugLevelVerbose, "SRB_GET_STREAM_INFO\n" ));
		AdapterStreamInfo( pSrb );
		break;

	case SRB_GET_DATA_INTERSECTION:
		DebugPrint(( DebugLevelVerbose, "SRB_GET_DATA_INTERSECTION\n" ));
		AdapterGetDataIntersection( pSrb );
		break;


	case SRB_GET_DEVICE_PROPERTY:
		AdapterGetProperty( pSrb );
		MonoOutStr("SRB_GET_DEVICE_PROPERTY");
		break;

	case SRB_SET_DEVICE_PROPERTY:
		AdapterSetProperty( pSrb );
		MonoOutStr("SRB_SET_DEVICE_PROPERTY");
		break;



	case SRB_CHANGE_POWER_STATE:
		DebugPrint(( DebugLevelVerbose, "SRB_CHANGE_POWER_STATE\n" ));
#if defined(DECODER_DVDPC)
    if (pSrb->CommandData.DeviceState == PowerDeviceD0)
    {
        //
        // bugbug - need to turn power back on here.
        //
		// Vinod.
//sri		ZivaHw_Initialize(pHwDevExt);
//		Commented for bug fix on GateWay Chameleon

    }
    else
    {
        //
        // bugbug - need to turn power off here, as well as disabling
        // interrupts.
        //
        //DisableIT();
    }
#endif
		pSrb->Status = STATUS_SUCCESS;
		break;

	case SRB_PAGING_OUT_DRIVER:
		DebugPrint(( DebugLevelVerbose, "SRB_PAGING_OUT_DRIVER\n" ));
		//TRAP
		//DisableIT();
		pSrb->Status = STATUS_SUCCESS;
		break;


	default:
		DebugPrint(( DebugLevelInfo, "!!!! UNKNOWN COMMAND !!!! :::> %X\n", pSrb->Command ));
		// This is a request that we do not understand. Indicate invalid
		// command and complete the request
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}
	
	AdapterReleaseRequest( pSrb );
	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterReceivePacket\n" ));
}

/******************************************************************************/
/*******************  Adapter Initialization Section  *************************/
/******************************************************************************/



/*
** BeginHwInitialize()
**
** Stub for the init sequence
**
** Arguments:
**
**   pSRB - pointer to the request packet for the initialise command
**
**    ->ConfigInfo - provides the I/O port, memory windows, IRQ, and DMA levels
**                that should be used to access this instance of the device
**
** Returns:
**
**
**
** Side Effects:  none
*/
static VOID BeginHwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: BeginHwInitialize()\n" ));
   StreamClassCallAtNewPriority(NULL, pHwDevExt, Low, PassiveInit, pSrb);
	return;
   
}
/*
** PassiveInit()
**
** Passive level callback for the init sequence
**
** Arguments:
**
**   pSRB - pointer to the request packet for the initialise command
**
**    ->ConfigInfo - provides the I/O port, memory windows, IRQ, and DMA levels
**                that should be used to access this instance of the device
**
** Returns:
**
**
**
** Side Effects:  none
*/
static VOID PassiveInit( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

	InitializeHost(pSrb);
   StreamClassCallAtNewPriority(NULL, pHwDevExt, LowToHigh, HighPriorityInit, pSrb);
   return;
}


/*
** HighPriorityInit()
**
** High priority callback for the init sequence
**
** Arguments:
**
**   pSRB - pointer to the request packet for the initialise command
**
**    ->ConfigInfo - provides the I/O port, memory windows, IRQ, and DMA levels
**                that should be used to access this instance of the device
**
** Returns:
**
**
**
** Side Effects:  none
*/
static VOID HighPriorityInit( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{

   HwInitialize(pSrb);
   
	AdapterReleaseRequest( pSrb );
}




/*
** HwInitialize()
**
**   Initializes an adapter accessed through the information provided in the
**   ConfigInfo structure
**
** Arguments:
**
**   pSRB - pointer to the request packet for the initialise command
**
**    ->ConfigInfo - provides the I/O port, memory windows, IRQ, and DMA levels
**                that should be used to access this instance of the device
**
** Returns:
**
**       STATUS_SUCCESS - if the card initializes correctly
**       STATUS_NO_SUCH_DEVICE - or other if the card is not found, or does
**                               not initialize correctly.
**
**
** Side Effects:  none
*/
static VOID HwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;
	ULONG dwSize;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin HwInitialize()\n" ));
	
//	InitializeHost(pSrb);

	pHwDevExt->bVideoStreamOpened			= FALSE;
	pHwDevExt->bAudioStreamOpened			= FALSE;
	pHwDevExt->bSubPictureStreamOpened		= FALSE;
	pHwDevExt->bOverlayInitialized			= FALSE;
	pHwDevExt->nAnalogStreamOpened			= 0;
	pHwDevExt->iTotalOpenedStreams			= 0;

	pHwDevExt->bVideoCanAuthenticate		= FALSE;
	pHwDevExt->bAudioCanAuthenticate		= FALSE;
	pHwDevExt->bSubPictureCanAuthenticate	= FALSE;
	pHwDevExt->iStreamToAuthenticateOn		= -1;

	pHwDevExt->bValidSPU					= FALSE;
	pHwDevExt->hli.StartPTM					= 0;

	pHwDevExt->pCurrentVideoSrb				= NULL;
	pHwDevExt->dwCurrentVideoSample			= 0;
	pHwDevExt->pCurrentAudioSrb				= NULL;
	pHwDevExt->dwCurrentAudioSample			= 0;
	pHwDevExt->pCurrentSubPictureSrb		= NULL;
	pHwDevExt->dwCurrentSubPictureSample	= 0;
	pHwDevExt->CurrentlySentStream			= ZivaNumberOfStreams;	// Just make sure it is none of them
	pHwDevExt->wNextSrbOrderNumber			= 0;
	pHwDevExt->bInterruptPending			= FALSE;
	pHwDevExt->bPlayCommandPending			= FALSE;
	pHwDevExt->bScanCommandPending			= FALSE;
	pHwDevExt->bSlowCommandPending			= FALSE;

	pHwDevExt->nStopCount					= 0;
	pHwDevExt->nPauseCount					= 0;
	pHwDevExt->nPlayCount					= 0;
	pHwDevExt->nTimeoutCount				= AUTHENTICATION_TIMEOUT_COUNT;

	pHwDevExt->NewRate						= 10000;
	pHwDevExt->bToBeDiscontinued			= FALSE;
	pHwDevExt->bDiscontinued				= FALSE;
	pHwDevExt->bAbortAtPause				= FALSE;
	pHwDevExt->bRateChangeFromSlowMotion	= FALSE;
	pHwDevExt->dwVideoDataUsed				=0;
	pHwDevExt->dwAudioDataUsed				=0;
	pHwDevExt->dwSubPictureDataUsed			=0;
	
	pHwDevExt->bEndFlush					= FALSE;
	pHwDevExt->bTimerScheduled				= FALSE;
	
	pHwDevExt->dwCurrentVideoPage			= 0;
	pHwDevExt->dwCurrentAudioPage			= 0;
	pHwDevExt->dwCurrentSubPicturePage		= 0;

	pHwDevExt->bStreamNumberCouldBeChanged	= FALSE;
	pHwDevExt->wCurrentStreamNumber			= -1;

	pHwDevExt->bSwitchDecryptionOn			= FALSE;
	pHwDevExt->zInitialState				= ZIVA_STATE_STOP;
	
	pHwDevExt->bHliPending					= FALSE;
		

	pHwDevExt->gdwCount						= 0;

	pHwDevExt->dwFirstVideoOrdNum			= -1;
	pHwDevExt->dwFirstAudioOrdNum			= -1;
	pHwDevExt->dwFirstSbpOrdNum				= -1;

	pHwDevExt->dwVSyncCount					=0;
	pHwDevExt->nApsMode						= -1;
	pHwDevExt->VidSystem					= -1;
	pHwDevExt->ulLevel						=0;
	pHwDevExt->fAtleastOne					= TRUE;
	
	pHwDevExt->dwPrevSTC					= 0;
	pHwDevExt->bTrickModeToPlay				=FALSE;
	pHwDevExt->prevStrm						=0;
	pHwDevExt->fFirstSTC					= FALSE;


	pHwDevExt->cCCRec=0;
	pHwDevExt->cCCDeq=0;
	pHwDevExt->cCCCB=0;
	pHwDevExt->cCCQ=0;
	pHwDevExt->pstroCC = NULL;
   
	
	pHwDevExt->dwUserDataSize=0;
	pHwDevExt->fReSync = FALSE;

	pHwDevExt->bInitialized = TRUE;

	pDevEx = pHwDevExt ;

	

	pHwDevExt->pPhysicalDeviceObj			= ConfigInfo->PhysicalDeviceObject;
	pHwDevExt->pDiscKeyBufferLinear			= (PUCHAR)StreamClassGetDmaBuffer( pHwDevExt );
	pHwDevExt->pDiscKeyBufferPhysical		= StreamClassGetPhysicalAddress(
															pHwDevExt,
															NULL,
															pHwDevExt->pDiscKeyBufferLinear,
															DmaBuffer,
															&dwSize );

	// Indicate the size of the structure necessary to describe all streams
	// that are supported by this hardware
	ConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER )+	// Stream header and
			ZivaNumberOfStreams * sizeof( HW_STREAM_INFORMATION );	// stream descriptors

	
	pHwDevExt->pCCDevEx = pHwDevExt;
	pSrb->Status = STATUS_SUCCESS;
#if defined (LOAD_UCODE_FROM_FILE)
	// Do nothing.
#else
	if( !ZivaHw_Initialize( pHwDevExt ) || !InitializeOutputStream( pSrb ))
		pSrb->Status = STATUS_IO_DEVICE_ERROR;
#endif

	DebugPrint(( DebugLevelVerbose, "ZiVA: End HwInitialize()\n" ));
}


/*
** HwUninitialize()
**
**   Release all resources and clean up the hardware
**
** Arguments:
**
**      DeviceExtension - pointer to the deviceextension structure for the
**                       the device to be free'd
**
** Returns:
**
** Side Effects:  none
*/
static VOID HwUninitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin HwUninitialize()\n" ));
#ifdef ENCORE
	AnalogUninitialize( pSrb );
#else
	pSrb->Status = STATUS_SUCCESS;
#endif
	DebugPrint(( DebugLevelVerbose, "ZiVA: End HwUninitialize()\n" ));
}

/*
** AdapterOpenStream()
**
**   This routine is called when an OpenStream SRB request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/
static VOID AdapterOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	int i;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterOpenStream\n" ));
	pSrb->Status = STATUS_TOO_MANY_NODES;

	for( i = 0; i < SIZEOF_ARRAY( infoStreams ); i++ )
	{
		if( infoStreams[i].hwStreamObject.StreamNumber == pSrb->StreamObject->StreamNumber )
		{	// This is the stream we're interested in.
			// Then copy stream object structure into passed buffer
			PVOID pHwStreamExtension = pSrb->StreamObject->HwStreamExtension;
			*(pSrb->StreamObject) = infoStreams[i].hwStreamObject;
			pSrb->StreamObject->HwStreamExtension = pHwStreamExtension;
			pSrb->StreamObject->HwDeviceExtension = pHwDevExt;
			pSrb->Status = STATUS_SUCCESS;
			break;
		}
	}

	if( pSrb->Status == STATUS_SUCCESS )
	{
		++pHwDevExt->iTotalOpenedStreams;
		++pHwDevExt->nStopCount;
		++pHwDevExt->nPauseCount;
		++pHwDevExt->nPlayCount;
		
		switch( pSrb->StreamObject->StreamNumber )
		{
		case ZivaVideo:
			pHwDevExt->bVideoStreamOpened = TRUE;
#if defined(DECODER_DVDPC) || defined(EZDVD)
			ProcessVideoFormat( pSrb->CommandData.OpenFormat, pHwDevExt );
#endif
			
			
			break;

		case ZivaAudio:
			pHwDevExt->bAudioStreamOpened = TRUE;
			pHwDevExt->pstroAud = pSrb->StreamObject;
			break;

		case ZivaSubpicture:
			pHwDevExt->bSubPictureStreamOpened = TRUE;
			break;

#ifdef ENCORE
		case ZivaAnalog:
			++pHwDevExt->nAnalogStreamOpened;
			AnalogOpenStream( pSrb );

			break;
#endif			

#if defined(DECODER_DVDPC) || defined(EZDVD)
		case ZivaYUV:
			pHwDevExt->pstroYUV = pSrb->StreamObject;
			pSrb->StreamObject->HwEventRoutine = (PHW_EVENT_ROUTINE) CycEvent;
			break;
#endif

		case ZivaCCOut:
			pHwDevExt->pstroCC = pSrb->StreamObject;
			break;

		default:
			ASSERT( FALSE );
		}
	}
	else
		DebugPrint(( DebugLevelWarning, "ZiVA: !!! Strange Stream Number\n" ));
	
	if ( pHwDevExt->iTotalOpenedStreams == 1 )
	{
		pHwDevExt->dwVideoDataUsed				= 0;
		pHwDevExt->dwAudioDataUsed				= 0;
		pHwDevExt->dwSubPictureDataUsed			= 0;
		pHwDevExt->bStreamNumberCouldBeChanged	= FALSE;
		pHwDevExt->wCurrentStreamNumber			= -1;
		pHwDevExt->bSwitchDecryptionOn			= FALSE;
		pHwDevExt->zInitialState				= ZIVA_STATE_STOP;
	
		
		pHwDevExt->bEndFlush					= FALSE;
		pHwDevExt->bTimerScheduled = FALSE;

		if ( !ZivaHw_Initialize( pHwDevExt ) )
		{
			DebugPrint((DebugLevelFatal,"ZiVA: Could not Initialize the HW on first Stream Open\n"));
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
		}
		
	 }


	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterOpenStream\n" ));
}


/*
** AdapterCloseStream()
**
**   Close the requested data stream
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

static VOID AdapterCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterCloseStream\n" ));
	pSrb->Status = STATUS_SUCCESS;

	ASSERT( pHwDevExt->nStopCount == pHwDevExt->iTotalOpenedStreams );
	ASSERT( pHwDevExt->nPauseCount == pHwDevExt->iTotalOpenedStreams );
	ASSERT( pHwDevExt->nPlayCount == pHwDevExt->iTotalOpenedStreams );
	--pHwDevExt->iTotalOpenedStreams;
	--pHwDevExt->nStopCount;
	--pHwDevExt->nPauseCount;
	--pHwDevExt->nPlayCount;
	// Determine which stream number is being closed. This number indicates
	// the offset into the array of streaminfo structures that was filled out
	// in the AdapterStreamInfo call.
	switch( pSrb->StreamObject->StreamNumber )
	{
	case ZivaVideo:
		pHwDevExt->bVideoStreamOpened = FALSE;
		break;

	case ZivaAudio:
		pHwDevExt->bAudioStreamOpened = FALSE;
		pHwDevExt->pstroAud = NULL;
		break;

	case ZivaSubpicture:
		pHwDevExt->bSubPictureStreamOpened = FALSE;
		break;
#ifdef ENCORE
	case ZivaAnalog:
		--pHwDevExt->nAnalogStreamOpened;
		AnalogCloseStream( pSrb );
		break;
#endif
#if defined(DECODER_DVDPC) || defined(EZDVD)
	case ZivaYUV:
		pHwDevExt->pstroYUV = NULL;
        pHwDevExt->VideoPort = 0;   // Disable
		break;
#endif


	case ZivaCCOut:
		CleanCCQueue(pHwDevExt);
		pHwDevExt->pstroCC = NULL;

		break;

	default:
		++pHwDevExt->iTotalOpenedStreams;
		++pHwDevExt->nStopCount;
		++pHwDevExt->nPauseCount;
		++pHwDevExt->nPlayCount;
		DebugPrint(( DebugLevelWarning, "ZiVA: !!! Strange Stream Number\n" ));
		ASSERT( FALSE );
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		//TRAP
	}

	//
	// Reset the Authenticated Stream if anyone is being closed
	//
	pHwDevExt->iStreamToAuthenticateOn = -1;

	//
	// Reset the HW on last Stream Close
	//
	if( pHwDevExt->iTotalOpenedStreams == 0 )
	{
		pHwDevExt->wNextSrbOrderNumber = 0;
		// Make sure next Authentication request will be postponed
		// until "last packet" flag has come on each stream.
		AdapterClearAuthenticationStatus( pHwDevExt );


		// Clean up the hardware
		if( !ZivaHw_Reset() )
		{
			DebugPrint(( DebugLevelError, "ZiVA: Could not Reset the HW on last Stream Closed\n" ));
			pSrb->Status = STATUS_IO_DEVICE_ERROR;
		}
#if defined(ENCORE)
		else
			AnalogCloseStream( pSrb );
#endif
	}
#ifdef DEBUG
	if( pHwDevExt->iTotalOpenedStreams < 0 )
		DebugPrint(( DebugLevelWarning, "ZiVA: !!!!!!!!!!!!!!!!!! Open/Close streams mismatch !!!!!!!!!!!!!!!!\n" ));
#endif

	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterCloseStream\n" ));
}

void AdapterInitLocals(PHW_DEVICE_EXTENSION pHwDevExt)
{
	pHwDevExt->pCurrentVideoSrb				= NULL;
	pHwDevExt->dwCurrentVideoSample			= 0;

	pHwDevExt->pCurrentAudioSrb				= NULL;
	pHwDevExt->dwCurrentAudioSample			= 0;

	pHwDevExt->pCurrentSubPictureSrb		= NULL;
	pHwDevExt->dwCurrentSubPictureSample	= 0;
	pHwDevExt->CurrentlySentStream			= ZivaNumberOfStreams;  // Just make sure it is none of them
	pHwDevExt->bInterruptPending			= FALSE;
	pHwDevExt->bPlayCommandPending			= FALSE;
	pHwDevExt->bScanCommandPending			= FALSE;
	pHwDevExt->bSlowCommandPending			= FALSE;
	pHwDevExt->bHliPending					= FALSE;
	pHwDevExt->NewRate						= 10000;

	pHwDevExt->dwVideoDataUsed				= 0;

	pHwDevExt->dwCurrentVideoPage			= 0;
	pHwDevExt->dwCurrentAudioPage			= 0;
	pHwDevExt->dwCurrentSubPicturePage		= 0;

	pHwDevExt->dwAudioDataUsed				= 0;
	pHwDevExt->dwSubPictureDataUsed			= 0;

	pHwDevExt->bToBeDiscontinued			= FALSE;
	pHwDevExt->bDiscontinued				= FALSE;
	pHwDevExt->bAbortAtPause				= FALSE;
	pHwDevExt->bRateChangeFromSlowMotion	= FALSE;

	pHwDevExt->gdwCount = 0;
	pHwDevExt->dwFirstVideoOrdNum			= -1;
	pHwDevExt->dwFirstAudioOrdNum			= -1;
	pHwDevExt->dwFirstSbpOrdNum				= -1;
	pHwDevExt->dwVSyncCount					=0;
	pHwDevExt->nApsMode						= -1;
	pHwDevExt->VidSystem					= -1;
	pHwDevExt->ulLevel						=0;
	pHwDevExt->fAtleastOne					= TRUE;

//temp 	pHwDevExt->dwPrevSTC					= 0;
	pHwDevExt->bTrickModeToPlay				=FALSE;
	pHwDevExt->prevStrm						=0;
	pHwDevExt->fFirstSTC					= TRUE;

	pHwDevExt->cCCRec=0;
	pHwDevExt->cCCDeq=0;
	pHwDevExt->cCCCB=0;
	pHwDevExt->cCCQ=0;
   
//	pHwDevExt->pstroCC = NULL;
//	pHwDevExt->dwUserDataBuffer[]={0};
	pHwDevExt->dwUserDataSize=0;
	pHwDevExt->fReSync = FALSE;
	CleanCCQueue(pHwDevExt);


#ifdef EZDVD
	ZivaHw_Initialize(pHwDevExt);
#endif

}



/*
** AdapterStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**   pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/
static VOID AdapterStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	int i;
	PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PHW_STREAM_HEADER pStrHdr = &(pSrb->CommandData.StreamBuffer->StreamHeader);
	PHW_STREAM_INFORMATION pstrinfo = &(pSrb->CommandData.StreamBuffer->StreamInfo);

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterStreamInfo\n" ));

	// Fill stream header structure
	pStrHdr->NumberOfStreams = ZivaNumberOfStreams;
	pStrHdr->SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION );
	pStrHdr->Topology = (PKSTOPOLOGY)&Topology;
#ifdef ENCORE
	pStrHdr->NumDevPropArrayEntries	= SIZEOF_ARRAY( psEncore );
	pStrHdr->DevicePropertiesArray	= (PKSPROPERTY_SET)psEncore;
#else
	pStrHdr->NumDevPropArrayEntries	= 0;
	pStrHdr->DevicePropertiesArray	= NULL;
#endif

	for( i = 0; i < SIZEOF_ARRAY( infoStreams ); i++, pstrinfo++ )
	{	// Copy stream information structure into passed buffer
		*pstrinfo = infoStreams[i].hwStreamInfo;
	}

	pSrb->Status = STATUS_SUCCESS;
	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterStreamInfo\n" ));

}





/*
** AdapterGetDataIntersection()
**
**
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/
static VOID AdapterGetDataIntersection( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PSTREAM_DATA_INTERSECT_INFO	IntersectInfo = pSrb->CommandData.IntersectInfo;
	PKSDATARANGE				DataRange = IntersectInfo->DataRange;
	PKSDATAFORMAT*				pFormat;
	ULONG						i, formatSize;

	if( IntersectInfo->StreamNumber >= ZivaNumberOfStreams )
	{	// Incorrect stream number
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		return;
	}

	pSrb->Status = STATUS_NO_MATCH;
#if defined (ENCORE)
	if( IntersectInfo->StreamNumber == ZivaAnalog )
	{
		PKSDATAFORMAT pFrmt = (PKSDATAFORMAT)&ZivaFormatAnalogOverlayOut;
		pFormat = &pFrmt;
	}



/*	else if(IntersectInfo->StreamNumber == ZivaCCOut)
	{
//		*pFormat = &hwfmtiCCOut;
//		formatSize = sizeof hwfmtiCCOut;
		MonoOutStr("CCOut");
		pFormat = infoStreams[IntersectInfo->StreamNumber].hwStreamInfo.StreamFormatsArray;
	}*/
	else
#endif
		pFormat = infoStreams[IntersectInfo->StreamNumber].hwStreamInfo.StreamFormatsArray;

	for( i = 0; i < infoStreams[IntersectInfo->StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
			pFormat++, i++ )
	{	// Check format
		formatSize = (*pFormat)->FormatSize;
#if defined (ENCORE)
		if( IntersectInfo->StreamNumber != ZivaAnalog && DataRange->FormatSize != formatSize )
			continue;
#endif
		if( IsEqualGUID( &DataRange->MajorFormat, &((*pFormat)->MajorFormat) ) &&
			IsEqualGUID( &DataRange->SubFormat, &((*pFormat)->SubFormat) ) &&
			IsEqualGUID( &DataRange->Specifier, &((*pFormat)->Specifier) ) )
		{
			pSrb->Status = STATUS_SUCCESS;
			break;
		}
	}
	if( pSrb->Status != STATUS_SUCCESS )
		return;

	// Check to see if the size of the passed in buffer is a ULONG.
	// if so, this indicates that we are to return only the size
	// needed, and not return the actual data.
	if( IntersectInfo->SizeOfDataFormatBuffer != sizeof( ULONG ) )
	{	//
		// we are to copy the data, not just return the size
		//
		if( IntersectInfo->SizeOfDataFormatBuffer < formatSize )
			pSrb->Status = STATUS_BUFFER_TOO_SMALL;
		else
		{
			RtlCopyMemory( IntersectInfo->DataFormatBuffer,  *pFormat, formatSize );
			pSrb->ActualBytesTransferred = formatSize;
			pSrb->Status = STATUS_SUCCESS;
		}
	}
	else	// if sizeof ULONG specified
	{
		// Caller wants just the size of the buffer. Get that.
		*(PULONG)IntersectInfo->DataFormatBuffer = formatSize;
		pSrb->ActualBytesTransferred = sizeof( ULONG );
	}	// if sizeof ULONG
}


VOID STREAMAPI adapterUpdateNextSrbOrderNumberOnDiscardSrb( PHW_STREAM_REQUEST_BLOCK pSrb )
{
  PHW_DEVICE_EXTENSION  pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
  ULONG  ulSample;
  KSSTREAM_HEADER * pHeader;
  WORD wMaxDiscardedOrderNumber = 0;

  for( ulSample = 0; ulSample < pSrb->NumberOfBuffers; ulSample++ )
  {
    pHeader    = ((PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray) + ulSample;
    wMaxDiscardedOrderNumber = max( (WORD)((pHeader->TypeSpecificFlags) >> 16), wMaxDiscardedOrderNumber );
  }

  if ( wMaxDiscardedOrderNumber >= pHwDevExt->wNextSrbOrderNumber )
  {
    pHwDevExt->wNextSrbOrderNumber = wMaxDiscardedOrderNumber + 1;
    MonoOutStr( "<<< Updating NextSrbOrderNumber to " );
    MonoOutULong( pHwDevExt->wNextSrbOrderNumber );
    MonoOutStr( " >>>" );
  }

  return ;
}


/*
** MoveToNextSample()
**
**  This routine is being called when there is a need to move
**  to the next Sample(buffer) in the current Srb.
**
** Arguments:
**    pSrb - the request block to advance Sample Number.
**
** Returns:
**    TRUE  - Successfuly moved to next Sample
**    FALSE - There was no more samples and current Srb was released
**
** Side Effects:  unknown
*/
BOOLEAN STREAMAPI MoveToNextSample( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DWORD* pdwCurrentSrbSample;
	DWORD* pdwCurrentSrbPage;

	switch( pSrb->StreamObject->StreamNumber )
	{
	case ZivaVideo:
		pdwCurrentSrbSample = &pHwDevExt->dwCurrentVideoSample;
		pdwCurrentSrbPage = &pHwDevExt->dwCurrentVideoPage;
		break;
	case ZivaAudio:
		pdwCurrentSrbSample = &pHwDevExt->dwCurrentAudioSample;
		pdwCurrentSrbPage = &pHwDevExt->dwCurrentAudioPage;
		break;
	case ZivaSubpicture:
		pdwCurrentSrbSample = &pHwDevExt->dwCurrentSubPictureSample;
		pdwCurrentSrbPage = &pHwDevExt->dwCurrentSubPicturePage;
		break;
	default:
		MonoOutStr( "!!!!!!!!!!!!!!!!!!! WRONG STREAM # IN MoveToNextSample ROUTINE !!!!!!!!!!!!!!!!!!!!!!!!!!!" );
		return FALSE;
	}
//	if(dwDataUsed == 0)
//	{
		(*pdwCurrentSrbSample)++;
//		pHwDevExt->wNextSrbOrderNumber++;
//	}
	(*pdwCurrentSrbPage)++;
	if( *pdwCurrentSrbSample >= pSrb->NumberOfBuffers)
	{
		if( *pdwCurrentSrbSample > pSrb->NumberOfBuffers )
		{
			MonoOutSetBlink( TRUE );
			MonoOutStr( "<<< Current sample number is higher than the number of buffers >>>" );
			MonoOutSetBlink( FALSE );
		}
//		MonoOutStr("MoveToNextSample()::RSRB");
		AdapterReleaseCurrentSrb( pSrb );
		return FALSE;
	}

	return TRUE;
}




VOID CancelPacket( PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bCancel )
{
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	ULONG					ulSample;
	PKSSTREAM_HEADER		pHeader;
	WORD					wMaxOrder = 0, wMinOrder = 0xFFFF;
#ifdef DEBUG
	LPSTR					pszFuncString, pszPacketString = NULL;

	pszFuncString = bCancel ? "Cancel" : "Timeout";
	DebugPrint(( DebugLevelVerbose,"ZiVA: Adapter%sPacket ->", pszFuncString ));
	MonoOutSetUnderscore( TRUE );
	MonoOutChar( ' ' );
	MonoOutStr( pszFuncString );
	MonoOutStr( "->" );
#endif

	if( !(pSrb->Flags & SRB_HW_FLAGS_DATA_TRANSFER) )
	{
		DebugPrint(( DebugLevelVerbose," As a Control\n" ));
		MonoOutStr( "(Control or Device)" );
		AdapterReleaseRequest( pSrb );
		return;
	}


	// We need to find this packet, pull it off our queues, and cancel it
	// Try to find this Srb in the Pending List. If it's there just
	// empty the slot
	if(bCancel)
	{
		if( pHwDevExt->pCurrentVideoSrb == pSrb )
		{
#ifdef DEBUG
			pszPacketString = "Video";
#endif
			pHwDevExt->pCurrentVideoSrb = NULL;
			pHwDevExt->dwCurrentVideoSample = 0;
			pHwDevExt->dwCurrentVideoPage = 0;
			pHwDevExt->dwVideoDataUsed	=0;
		}
		else if( pHwDevExt->pCurrentAudioSrb == pSrb )
		{
#ifdef DEBUG
			pszPacketString = "Audio";
#endif
			pHwDevExt->pCurrentAudioSrb = NULL;
			pHwDevExt->dwCurrentAudioSample = 0;
			pHwDevExt->dwCurrentAudioPage = 0;
			pHwDevExt->dwAudioDataUsed = 0;
		
		
		}
		else if( pHwDevExt->pCurrentSubPictureSrb == pSrb )
		{
#ifdef DEBUG
			pszPacketString = "Subpicture";
#endif
			pHwDevExt->pCurrentSubPictureSrb = NULL;
			pHwDevExt->dwCurrentSubPictureSample = 0;
			pHwDevExt->dwCurrentSubPicturePage = 0;
			pHwDevExt->dwSubPictureDataUsed = 0;
		}
	}
	else	//added 11/6/98
	{
		if( pHwDevExt->bInterruptPending )
			MoveToNextSample( pSrb );
	}

#ifdef DEBUG
	if( pszPacketString )
	{
		DebugPrint(( DebugLevelVerbose, pszPacketString ));
		MonoOutStr( pszPacketString );
	}
#endif

	// Reset the HW if it was the currently sending Srb.
	// It usually means that hardware messed up so we'll schedule "play",
	// "slow motion" or "scan" commands if one of them was in effect, reset
	// hardware and cancel this packet

	if( pHwDevExt->CurrentlySentStream == (ZIVA_STREAM)pSrb->StreamObject->StreamNumber )
	{
		ZIVA_STATE zState;

		DebugPrint(( DebugLevelVerbose, "Current" ));
		MonoOutStr( " Current Strm# " );
		MonoOutInt( pSrb->StreamObject->StreamNumber );

		// This request is in a middle of a Bus Master transferring and most likely
		// that the interrupt is pending. If so we have to reset the
		// Bus Master device.
		if( pHwDevExt->bInterruptPending )
		{
			pHwDevExt->bInterruptPending = FALSE;
			MonoOutStr( " Cancel pending interrupt" );
		}

		// Lets do a clean start (Abort->Play) for the upcoming stream
		zState = ZivaHw_GetState();
		if( zState != ZIVA_STATE_STOP )
		{
			MonoOutStr( " Aborting" );
			
			if( !ZivaHw_Abort() )
				ZivaHw_Reset();
			
			pHwDevExt->bInterruptPending = FALSE;

			pHwDevExt->bScanCommandPending = TRUE;
			
		}

		// Clean the CurrentlySentStream
		pHwDevExt->CurrentlySentStream = ZivaNumberOfStreams;
	}




	if(bCancel)
		pSrb->Status = STATUS_CANCELLED;
	
	// It is necessary to call the request back correctly.  Determine which type of
	// command it is and then find all stream commands, and do stream notifications
	switch( pSrb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST) )
	{
	case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:
		DebugPrint(( DebugLevelVerbose," As a Data\n" ));
		MonoOutStr( "(Data)" );

		// Find the smallest and the biggest discarded order number in this packet
		for( ulSample = 0; ulSample < pSrb->NumberOfBuffers; ulSample++ )
		{
			pHeader = (PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray + ulSample;
			wMaxOrder = max( (WORD)(pHeader->TypeSpecificFlags >> 16), wMaxOrder );
			wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
		}
		MonoOutStr( " Min:" );
		MonoOutInt( wMinOrder );
		MonoOutStr( " Max:" );
		MonoOutInt( wMaxOrder );
		MonoOutStr( " Curr:" );
		MonoOutInt( pHwDevExt->wNextSrbOrderNumber );
		if(bCancel)
		{
			if( /*wMinOrder <= pHwDevExt->wNextSrbOrderNumber &&*/
				wMaxOrder >= pHwDevExt->wNextSrbOrderNumber )
			{
				pHwDevExt->wNextSrbOrderNumber = wMaxOrder + 1;
				MonoOutStr( "<<< Updating NextSrbOrderNumber to " );
				MonoOutULong( pHwDevExt->wNextSrbOrderNumber );
				MonoOutStr( " >>>" );
			}
			else
				MonoOutChar( ' ' );
			MonoOutStr("Cancel::ARR");
			AdapterReleaseRequest( pSrb );
		}
		else
		{

			if(pHwDevExt->pCurrentSubPictureSrb)
			{
				pHeader = (PKSSTREAM_HEADER)pHwDevExt->pCurrentSubPictureSrb->CommandData.DataBufferArray ;
				pHeader += pHwDevExt->dwCurrentSubPictureSample;
				wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
			}
			if(pHwDevExt->pCurrentVideoSrb)
			{
				pHeader = (PKSSTREAM_HEADER)pHwDevExt->pCurrentVideoSrb->CommandData.DataBufferArray ;
				pHeader += pHwDevExt->dwCurrentVideoSample;
				wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
			}
			if(pHwDevExt->pCurrentAudioSrb)
			{
				pHeader = (PKSSTREAM_HEADER)pHwDevExt->pCurrentAudioSrb->CommandData.DataBufferArray ;
				pHeader += pHwDevExt->dwCurrentAudioSample;
				wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
			}

			pHwDevExt->wNextSrbOrderNumber = wMinOrder ;
			AdapterSendData(pHwDevExt);
		}


		MonoOutStr( "(Current->" );
		if( pHwDevExt->pCurrentVideoSrb )
			MonoOutStr( "V" );
		if( pHwDevExt->pCurrentAudioSrb )
			MonoOutStr( "A" );
		if( pHwDevExt->pCurrentSubPictureSrb )
			MonoOutStr( "S" );
		if( !pHwDevExt->pCurrentVideoSrb && !pHwDevExt->pCurrentAudioSrb && !pHwDevExt->pCurrentSubPictureSrb )
			MonoOutStr( "Queue empty" );
		MonoOutStr( ")" );


		break;

	case SRB_HW_FLAGS_STREAM_REQUEST:
		DebugPrint(( DebugLevelVerbose," As a Control\n" ));
		MonoOutStr( "(Control)" );
		AdapterReleaseRequest( pSrb );
		break;

	default:
		// this must be a device request.  Use device notifications
		DebugPrint(( DebugLevelVerbose," As a Device\n" ));
		MonoOutStr( "(Device)" );
		AdapterReleaseRequest( pSrb );
	}
	
	MonoOutSetUnderscore( FALSE );
	DebugPrint(( DebugLevelVerbose, "ZiVA: End Adapter%sPacket\n", pszFuncString ));
}


/*** AdapterCancelPacket()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterCancelPacket( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	CancelPacket( pSrb, TRUE );
}

/*
** AdapterTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The adapter must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterTimeoutPacket( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	// If this is a data request, and the device is paused (we probably have run out of
	// data buffer) or busy with overlay calibration we need more time, so just reset the
	// timer, and let the packet continue
	if( ZivaHw_GetState() == ZIVA_STATE_PAUSE 
#ifdef ENCORE
		|| pHwDevExt->nVGAMode != AP_KNOWNMODE
#endif
		)
	{
		DebugPrint(( DebugLevelVerbose, "Timeout: Stream is PAUSED\n" ));

				// reset the timeout counter, and continue
		pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
		return;
	}

	CleanCCQueue(pHwDevExt);	

	CancelPacket( pSrb, FALSE );
}

void FinishCurrentPacketAndSendNextOne( PHW_DEVICE_EXTENSION pHwDevExt )
{
	DWORD dwSample;
	PHW_STREAM_REQUEST_BLOCK pSrb = NULL;
	DWORD dwCurBuf=0;
	
	switch( pHwDevExt->CurrentlySentStream )
	{
	case ZivaVideo:
		pSrb = pHwDevExt->pCurrentVideoSrb;
		++pHwDevExt->dwCurrentVideoPage;
		if(pHwDevExt->dwVideoDataUsed <= 0)
		{
			pHwDevExt->wNextSrbOrderNumber++;
			++pHwDevExt->dwCurrentVideoSample;
			dwCurBuf = pHwDevExt->dwCurrentVideoSample;

		}
		dwSample = pHwDevExt->dwCurrentVideoPage;
		break;

	case ZivaAudio:
		pSrb = pHwDevExt->pCurrentAudioSrb;
		++pHwDevExt->dwCurrentAudioPage;
		if(pHwDevExt->dwAudioDataUsed <= 0)
		{
			pHwDevExt->wNextSrbOrderNumber++;
			++pHwDevExt->dwCurrentAudioSample;
			dwCurBuf = pHwDevExt->dwCurrentAudioSample;
		}
		dwSample = pHwDevExt->dwCurrentAudioPage;

		
		break;

	case ZivaSubpicture:
		pSrb = pHwDevExt->pCurrentSubPictureSrb;
		++pHwDevExt->dwCurrentSubPicturePage;
		if(pHwDevExt->dwSubPictureDataUsed <= 0)
		{
			pHwDevExt->wNextSrbOrderNumber++;
			++pHwDevExt->dwCurrentSubPictureSample;
			dwCurBuf = pHwDevExt->dwCurrentSubPictureSample;
		}
		
		dwSample = pHwDevExt->dwCurrentSubPicturePage;
		
		break;
	}
	if( pSrb )
	{
		if( ( dwSample >= pSrb->NumberOfPhysicalPages) || (dwCurBuf >= pSrb->NumberOfBuffers))
		{
			if( dwSample > pSrb->NumberOfPhysicalPages)
			{
				MonoOutSetBlink( TRUE );
				MonoOutStr( "<<< Current sample number is higher than the number of buffers >>>" );
				MonoOutSetBlink( FALSE );
			}

//tmp			MonoOutStr("RSRB");
			AdapterReleaseCurrentSrb( pSrb );
		}
		// Clean the CurrentlySentStream
		pHwDevExt->CurrentlySentStream = ZivaNumberOfStreams;
		// Send next chunk of data
		AdapterSendData( pHwDevExt );
	}
}


UINT AdapterPrepareDataForSending( PHW_DEVICE_EXTENSION pHwDevExt,
									PHW_STREAM_REQUEST_BLOCK pCurrentStreamSrb,
									DWORD dwCurrentStreamSample,
									PHW_STREAM_REQUEST_BLOCK* ppSrb, DWORD* pdwSample,
									DWORD* dwCurrentSample,DWORD dwCurrentPage,
									LONG* pdwDataUsed)
{
	PKSSTREAM_HEADER pHeader;
	static DWORD wPrevOrderNumber=0xfff;

	// Check if this guy has any data to send
	pHeader = (PKSSTREAM_HEADER)pCurrentStreamSrb->CommandData.DataBufferArray+dwCurrentStreamSample;

	if(pHeader == NULL)
	{
		MonoOutStr("PHeader NULL");
		MoveToNextSample( pCurrentStreamSrb );
		pHwDevExt->wNextSrbOrderNumber++;
		// Sorry, but we have to start all over again...
		return TRUE;
	}


	if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED )
	{
		MonoOutStr( "!!!! Skipping TYPECHANGED buffer !!!!" );
		MoveToNextSample( pCurrentStreamSrb );
		// Sorry, but we have to start all over again...
		return TRUE;
	}
	if( (WORD)(pHeader->TypeSpecificFlags >> 16) == pHwDevExt->wNextSrbOrderNumber )
	{
		
		if( !pHeader->DataUsed )
		{
			MonoOutStr( "!!!! DataUsed is 0 !!!!" );
			MoveToNextSample( pCurrentStreamSrb );
			pHwDevExt->wNextSrbOrderNumber++;
			// Sorry, but we have to start all over again...
			return TRUE;
		}
		// Found our SRB
		if((*pdwDataUsed <= 0))
		{
			*pdwDataUsed += pHeader->DataUsed;
			if(*pdwDataUsed == 0)
			{
				MoveToNextSample(pCurrentStreamSrb);
				pHwDevExt->wNextSrbOrderNumber++;
				return TRUE;
			}
		}
		if(pHeader->PresentationTime.Time)
			pHwDevExt->VideoSTC = pHeader->PresentationTime.Time;
		*ppSrb		= pCurrentStreamSrb;
		*pdwSample	= dwCurrentPage;
		*dwCurrentSample = dwCurrentStreamSample;
	}

	return FALSE;
}

UpdateOrdinalNumber(IN PHW_DEVICE_EXTENSION pHwDevExt)
{
	if(( (pHwDevExt->pCurrentVideoSrb) || (pHwDevExt->pCurrentAudioSrb) || (pHwDevExt->pCurrentSubPictureSrb)) )
	{
		PKSSTREAM_HEADER pHeader;
		WORD wMinOrder = 0xFFFF;
		if( pHwDevExt->pCurrentVideoSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentVideoSrb->CommandData.DataBufferArray)+
			pHwDevExt->dwCurrentVideoSample;
			wMinOrder = (WORD)(pHeader->TypeSpecificFlags >> 16);
		}
		if( pHwDevExt->pCurrentAudioSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentAudioSrb->CommandData.DataBufferArray)+
			pHwDevExt->dwCurrentAudioSample;
			wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
		}
		if( pHwDevExt->pCurrentSubPictureSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentSubPictureSrb->CommandData.DataBufferArray)+
			pHwDevExt->dwCurrentSubPictureSample;
			wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
		}	

		ASSERT( wMinOrder != 0xFFFF );
		pHwDevExt->wNextSrbOrderNumber = wMinOrder;
		MonoOutSetBlink( TRUE );
		MonoOutStr( "<<< Self recovering NextSrbOrderNumber to " );
		MonoOutULong( pHwDevExt->wNextSrbOrderNumber );
		MonoOutStr( " >>>" );
		MonoOutSetBlink( FALSE );
		
	}
	
}
BOOLEAN  CanUpdateOrdinalNumber(IN PHW_DEVICE_EXTENSION pHwDevExt)
{
	BOOLEAN bReturn = FALSE;	
	if(pHwDevExt->bScanCommandPending)
	{
		if((pHwDevExt->NewRate == 10000) ||  (pHwDevExt->bRateChangeFromSlowMotion) )
		{

			pHwDevExt->bRateChangeFromSlowMotion = FALSE;
			if(pHwDevExt->bDiscontinued)
			{
				pHwDevExt->bDiscontinued = FALSE;
				UpdateOrdinalNumber(pHwDevExt);
				bReturn = TRUE;
			}
		}
	}
	return bReturn;
}
void IssuePendingCommands(PHW_DEVICE_EXTENSION pHwDevExt)
{
	pHwDevExt->bEndFlush = FALSE;
	pHwDevExt->bTimerScheduled = FALSE;
	DisableThresholdInt();
	if( pHwDevExt->bPlayCommandPending == TRUE )
	{	// If "Play" command is pending - it's time to fire it
		pHwDevExt->bPlayCommandPending = FALSE;
		ZivaHw_FlushBuffers( );
		pHwDevExt->bInterruptPending = FALSE;
		if( !ZivaHw_Play() )
			DebugPrint(( DebugLevelInfo, "ZiVA: !!!!!!!!! Play command did not succeed !!!!!!!!!\n" ));
	}
	if( pHwDevExt->bScanCommandPending == TRUE )
	{
		pHwDevExt->bScanCommandPending = FALSE;
		if(pHwDevExt->NewRate == 10000)
		{
			ZivaHw_Abort();//sri
			pHwDevExt->bInterruptPending = FALSE;
			ZivaHw_Play();
		}
		else if(pHwDevExt->NewRate < 10000)
		{
			ZivaHw_Abort();//sri
			pHwDevExt->bInterruptPending = FALSE;
			ZivaHw_Scan();
		}
		else
		{
		
			ZivaHw_Abort();//sri
			pHwDevExt->bInterruptPending = FALSE;
			ZivaHw_SlowMotion( 8 );
		}
	}

}


void CallAdapterSendAtALaterTime( PHW_DEVICE_EXTENSION pHwDevExt )
{

//	UpdateOrdinalNumber(pHwDevExt);
	MonoOutStr("CallAdapterSendAtALaterTime");
	if(pHwDevExt->bTimerScheduled)
	{
		pHwDevExt->bTimerScheduled = FALSE;
		MonoOutStr("CallAdapterSend");
		UpdateOrdinalNumber(pHwDevExt);
		AdapterSendData(pHwDevExt);
	}

}


BOOL UpdateOrdNum_MinOfAllThree(PHW_DEVICE_EXTENSION pHwDevExt)
{
	if( ((!pHwDevExt->bVideoStreamOpened || pHwDevExt->pCurrentVideoSrb) &&
		(!pHwDevExt->bAudioStreamOpened || pHwDevExt->pCurrentAudioSrb) &&
		(!pHwDevExt->bSubPictureStreamOpened || pHwDevExt->pCurrentSubPictureSrb))
		 )
	{
		PKSSTREAM_HEADER pHeader;
		WORD wMinOrder = 0xFFFF;
		
		
		if( pHwDevExt->pCurrentVideoSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentVideoSrb->CommandData.DataBufferArray)+
						pHwDevExt->dwCurrentVideoSample;
			wMinOrder = (WORD)(pHeader->TypeSpecificFlags >> 16);
		}
		if( pHwDevExt->pCurrentAudioSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentAudioSrb->CommandData.DataBufferArray)+
						pHwDevExt->dwCurrentAudioSample;
			wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
		}
		if( pHwDevExt->pCurrentSubPictureSrb )
		{
			pHeader = (PKSSTREAM_HEADER)(pHwDevExt->pCurrentSubPictureSrb->CommandData.DataBufferArray)+
						pHwDevExt->dwCurrentSubPictureSample;
			wMinOrder = min( (WORD)(pHeader->TypeSpecificFlags >> 16), wMinOrder );
		}

		ASSERT( wMinOrder != 0xFFFF );
		pHwDevExt->wNextSrbOrderNumber = wMinOrder;
		MonoOutSetBlink( TRUE );
		MonoOutStr( "<<< Self recovering NextSrbOrderNumber to " );
		MonoOutULong( pHwDevExt->wNextSrbOrderNumber );
		MonoOutStr( " >>>" );
		MonoOutSetBlink( FALSE );
		return TRUE;
	}
	else
		return FALSE;
}


/*BOOL StartUpDiscontinue(PHW_DEVICE_EXTENSION pHwDevExt)
{
	if(pHwDevExt->dwFirstVideoOrdNum != -1)
		wMinOrder = min( (WORD)pHwDevExt->dwFirstVideoOrdNum, wMinOrder );
	if(pHwDevExt->dwFirstAudioOrdNum != -1)
		wMinOrder = min( (WORD)pHwDevExt->dwFirstAudioOrdNum, wMinOrder );
	if(pHwDevExt->dwFirstSbpOrdNum != -1)
		wMinOrder = min( (WORD)pHwDevExt->dwFirstSbpOrdNum, wMinOrder );
	if((wMinOrder != -1) && (wMinOrder > pHwDevExt->wNextSrbOrderNumber) )
	{
		pHwDevExt->wNextSrbOrderNumber = wMinOrder ;
		return TRUE;
	}
	else
		return FALSE;
}*/

/*
** AdapterSendData()
**
**  This routine is being scheduled by the either one of the input
**  streams when it receives data or by the ISR when sending of the
**  previos block is completed and there still Srbs pending.
**
** Arguments:
**
**  pHwDevExt - the hardware device extension.
**
** Returns: none
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterSendData( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	PHW_STREAM_REQUEST_BLOCK	pSrb;
	DWORD						dwPageToSend;
	DWORD						dwCurrentSample;
#ifndef DECODER_DVDPC
	if(pHwDevExt->bAbortAtPause)
		return;
#endif
	// Check if HW is not busy and there is something to send
	if( pHwDevExt->bInterruptPending ||
		(pHwDevExt->pCurrentVideoSrb == NULL &&
		 pHwDevExt->pCurrentAudioSrb == NULL && pHwDevExt->pCurrentSubPictureSrb == NULL) )
		return;

	// Find the next Sample by the order number
	for( ;; )
	{
		pSrb = NULL;

		if( pHwDevExt->pCurrentVideoSrb &&
			AdapterPrepareDataForSending( pHwDevExt, pHwDevExt->pCurrentVideoSrb,
							pHwDevExt->dwCurrentVideoSample, &pSrb, &dwPageToSend,&dwCurrentSample,
							pHwDevExt->dwCurrentVideoPage,&pHwDevExt->dwVideoDataUsed) )
			continue;
		if( pHwDevExt->pCurrentAudioSrb && pSrb == NULL &&
			AdapterPrepareDataForSending( pHwDevExt, pHwDevExt->pCurrentAudioSrb,
							pHwDevExt->dwCurrentAudioSample, &pSrb, &dwPageToSend,&dwCurrentSample,
							pHwDevExt->dwCurrentAudioPage,&pHwDevExt->dwAudioDataUsed) )
			continue;
		if( pHwDevExt->pCurrentSubPictureSrb && pSrb == NULL &&
			AdapterPrepareDataForSending( pHwDevExt, pHwDevExt->pCurrentSubPictureSrb,
							pHwDevExt->dwCurrentSubPictureSample, &pSrb, &dwPageToSend,&dwCurrentSample,
							pHwDevExt->dwCurrentSubPicturePage,&pHwDevExt->dwSubPictureDataUsed) )
			continue;

		if( pSrb != NULL )		// Found the right SRB
		{
			pHwDevExt->CurrentlySentStream = pSrb->StreamObject->StreamNumber;
			break;
		}

		if(CanUpdateOrdinalNumber(pHwDevExt))
		{
			UpdateOrdinalNumber(pHwDevExt);
			continue;
		}
    
		if(pHwDevExt->bEndFlush)
		{
			pHwDevExt->bEndFlush = FALSE;
			MonoOutStr("Timer Scheduled for AdapterSendData");
			StreamClassScheduleTimer( NULL, pHwDevExt,
                                400000,
                                (PHW_TIMER_ROUTINE)CallAdapterSendAtALaterTime,
                                pHwDevExt );
			pHwDevExt->bTimerScheduled = TRUE;

			
		}
		
		if(UpdateOrdNum_MinOfAllThree(pHwDevExt))
			continue;
//		if(StartUpDiscontinue(pHwDevExt))
//			continue;

		MonoOutStr( "!! CD !!" );
		//MonoOutStr( "!!!!!!!!!!!!!!! COUNTER DISCONTINUITY !!!!!!!!!!!!!!!!!!!" );

		// Clean the CurrentlySentStream
		pHwDevExt->CurrentlySentStream = ZivaNumberOfStreams;
		
		return;
	}
	
	XferData(pSrb,pHwDevExt,dwPageToSend,dwCurrentSample);
}




/*
** AdapterReleaseCurrentSrb()
**
**   This routine is called by the AdapterSendData() and HWInterrupt() functions
**   when there is no more data in the Currently processing Srb.
**
** Arguments:
**
**  pSrb - the request block to release.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReleaseCurrentSrb( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PKSSTREAM_HEADER pHeader;

	pSrb->Status = STATUS_SUCCESS;

	// Clear the CurrentSrb and Sample count for this Srb
	switch( pSrb->StreamObject->StreamNumber )
	{
	case ZivaVideo:
		pHwDevExt->pCurrentVideoSrb = NULL;
		pHwDevExt->dwCurrentVideoSample = 0;
		pHwDevExt->dwCurrentVideoPage = 0;
		pHwDevExt->dwVideoDataUsed=0;
		break;
	case ZivaAudio:
		pHwDevExt->pCurrentAudioSrb = NULL;
		pHwDevExt->dwCurrentAudioSample = 0;
		pHwDevExt->dwCurrentAudioPage = 0;
		pHwDevExt->dwAudioDataUsed=0;
		break;
	case ZivaSubpicture:
		pHwDevExt->pCurrentSubPictureSrb = NULL;
		pHwDevExt->dwCurrentSubPictureSample = 0;
		pHwDevExt->dwCurrentSubPicturePage = 0;
		pHwDevExt->dwSubPictureDataUsed=0;
		break;
	default:
		MonoOutStr( "!!!!!!!! Releasing Srb for UNKNOWN stream !!!!!!!!" );
	}

	// Check if this is the last Srb for current title
	pHeader = (PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray+pSrb->NumberOfBuffers-1;
	if( pHeader->TypeSpecificFlags & KS_AM_UseNewCSSKey )
	{
		switch( pSrb->StreamObject->StreamNumber )
		{
		case ZivaVideo:
			MonoOutStr( "!!! Last video Srb !!!" );
			pHwDevExt->bVideoCanAuthenticate = TRUE;
			break;

		case ZivaAudio:
			MonoOutStr( "!!! Last audio Srb !!!" );
			pHwDevExt->bAudioCanAuthenticate = TRUE;
			break;

		case ZivaSubpicture:
			MonoOutStr( "!!! Last SP Srb !!!" );
			pHwDevExt->bSubPictureCanAuthenticate = TRUE;
			break;

		default:
			MonoOutStr( "!!!!!!!! Last Srb for UNKNOWN stream !!!!!!!!" );
		}
	}
	
	AdapterReleaseRequest( pSrb );
}


/*
** AdapterReleaseRequest()
**
**   This routine is called when any of the open pins (streams) wants
**   to dispose an used request block.
**
** Arguments:
**
**  pSrb - the request block to release.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReleaseRequest( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	if( pSrb->Status == STATUS_PENDING )
		MonoOutStr( " !!! Srb is PENDING - not releasing !!! " );
	else
	{
		if( pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST )
		{
			if( pSrb->Flags & SRB_HW_FLAGS_DATA_TRANSFER )
			{
				StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSrb->StreamObject );
//				MonoOutStr(" Release D");
			}
			else
			{
				StreamClassStreamNotification( ReadyForNextStreamControlRequest, pSrb->StreamObject );
//				MonoOutStr(" Release C");
			}
			StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
		}
		else
		{
			StreamClassDeviceNotification( ReadyForNextDeviceRequest, pSrb->HwDeviceExtension );
			StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb );
		}
	}
}


/*
** AdapterCanAuthenticateNow()
**
**   This routine is called when Authentication request was made by the
**   Class Driver.
**
** Arguments:
**
**  pHwDevExt - hardware device extension.
**
** Returns:
**
**   TRUE if Authentication is allowed at this moment, FALSE otherwise.
**
** Side Effects:  none
*/
BOOL STREAMAPI AdapterCanAuthenticateNow( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	if( (pHwDevExt->bVideoStreamOpened == FALSE ||
		 (pHwDevExt->bVideoStreamOpened == TRUE && pHwDevExt->bVideoCanAuthenticate == TRUE)) &&
		(pHwDevExt->bAudioStreamOpened == FALSE ||
		 (pHwDevExt->bAudioStreamOpened == TRUE && pHwDevExt->bAudioCanAuthenticate == TRUE)) &&
		(pHwDevExt->bSubPictureStreamOpened == FALSE ||
		 (pHwDevExt->bSubPictureStreamOpened == TRUE && pHwDevExt->bSubPictureCanAuthenticate == TRUE)) )
		return TRUE;

	return FALSE;
}

/*
** AdapterClearAuthenticationStatus()
**
**   This routine is called when Authentication and key exchange was
**   completed.
**
** Arguments:
**
**  pHwDevExt - hardware device extension.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterClearAuthenticationStatus( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	pHwDevExt->bVideoCanAuthenticate		= FALSE;
	pHwDevExt->bAudioCanAuthenticate		= FALSE;
	pHwDevExt->bSubPictureCanAuthenticate	= FALSE;
}


/*
** AdapterSetState()
**
**    Sets the current state
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/
BOOL AdapterSetState( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PHW_STREAM_EXTENSION pStreamExt = (PHW_STREAM_EXTENSION)pSrb->StreamObject->HwStreamExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: AdapterSetState() -> " ));
	pSrb->Status = STATUS_SUCCESS;

	// Execute appropriate command only when it comes for every stream
	switch( pSrb->CommandData.StreamState )
	{
	case KSSTATE_STOP:
		pStreamExt->ksState = pSrb->CommandData.StreamState;
#ifdef ENCORE
		if( pSrb->StreamObject->StreamNumber == ZivaAnalog && pHwDevExt->nAnalogStreamOpened > 1 )
			pHwDevExt->nStopCount -= pHwDevExt->nAnalogStreamOpened-1;
#endif
		if( --pHwDevExt->nStopCount == 0 )
		{
//			ZwClose(Handle);
			pHwDevExt->nStopCount = pHwDevExt->iTotalOpenedStreams;
			DebugPrint(( DebugLevelVerbose, "Stop" ));
			if( !ZivaHw_Abort() )
				pSrb->Status = STATUS_IO_DEVICE_ERROR;
			else
				pHwDevExt->bInterruptPending = FALSE;
			AdapterInitLocals(pHwDevExt);
		}
		break;

	case KSSTATE_PAUSE:
		pStreamExt->ksState = pSrb->CommandData.StreamState;
		pStreamExt->bCanBeRun = TRUE;
		if( (ZivaHw_GetState( ) == ZIVA_STATE_SCAN) || (ZivaHw_GetState( ) ==ZIVA_STATE_SLOWMOTION) )//sri
			pHwDevExt->bAbortAtPause = TRUE;

#ifdef ENCORE
		if( pSrb->StreamObject->StreamNumber == ZivaAnalog && pHwDevExt->nAnalogStreamOpened > 1 )
			pHwDevExt->nPauseCount -= pHwDevExt->nAnalogStreamOpened-1;
#endif
		if( --pHwDevExt->nPauseCount == 0 )
		{

			pHwDevExt->nPauseCount = pHwDevExt->iTotalOpenedStreams;
			DebugPrint(( DebugLevelVerbose, "Pause" ));
			
			if( !ZivaHw_Pause() )
			{
				MonoOutStr("Pause Failed");
				pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
			
		}
		break;

	case KSSTATE_RUN:
		pStreamExt->ksState = pSrb->CommandData.StreamState;
#ifdef ENCORE
		if( pSrb->StreamObject->StreamNumber == ZivaAnalog && pHwDevExt->nAnalogStreamOpened > 1 )
			pHwDevExt->nPlayCount -= pHwDevExt->nAnalogStreamOpened-1;
#endif
		if( --pHwDevExt->nPlayCount == 0 )
		{

			pHwDevExt->nPlayCount = pHwDevExt->iTotalOpenedStreams;
			DebugPrint(( DebugLevelVerbose, "Run" ));
			// We could be resuming playback here after Pause mode
			if(pHwDevExt->bAbortAtPause)
			{
				pHwDevExt->bAbortAtPause = FALSE;

				ZivaHw_Abort();

#ifdef DECODER_DVDPC
				
				if( !ZivaHw_Play() )			// Just run the hardware
					pSrb->Status = STATUS_IO_DEVICE_ERROR;
//				pHwDevExt->bPlayCommandPending = TRUE;
//				AdapterSendData(pHwDevExt);
#endif

#ifndef DECODER_DVDPC
				pHwDevExt->bInterruptPending = FALSE;
				pHwDevExt->bPlayCommandPending = TRUE;
				FinishCurrentPacketAndSendNextOne( pHwDevExt );
				AdapterSendData(pHwDevExt);
#endif
				

			}
			else
			{

				if( pHwDevExt->bInterruptPending )
				{
					if( !ZivaHw_Play() )			// Just run the hardware
						pSrb->Status = STATUS_IO_DEVICE_ERROR;
				}
				else
				{
				// Since Authentication and Key Exchange comes in between
				// "Run" command and actual data sending and ZiVA Microcode
				// cannot sustain it - postpone issuing Play command to ZiVA
				// until first packet of the data arrives.
					pHwDevExt->bPlayCommandPending = TRUE;
				// Kick the Adapter to start transferring data
					AdapterSendData( pHwDevExt );
				}
			}

			EnableVideo(pSrb);
		}
		break;
	}

	DebugPrint(( DebugLevelVerbose, "\nZiVA: End AdapterSetState()\n" ));

        return TRUE;
}

/*
** AdapterReleaseControlRequest()
**
**   This routine is called when any of the open pins (streams) wants
**   to dispose an used control request block.
**
** Arguments:
**
**  pSrb - the request block to release.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReleaseControlRequest( PHW_STREAM_REQUEST_BLOCK pSrb )
{
  if ( pSrb->Status == STATUS_PENDING )
  {
    MonoOutStr( " !!! Srb is PENDING - not releasing !!! " );
  }
  else
  {
    StreamClassStreamNotification( ReadyForNextStreamControlRequest,
                                   pSrb->StreamObject);

    StreamClassStreamNotification( StreamRequestComplete,
                                   pSrb->StreamObject,
                                   pSrb);
//	MonoOutStr(" Release ");
  }
}

/*
** AdapterReleaseDataRequest()
**
**   This routine is called when any of the open pins (streams) wants
**   to dispose an used data request block.
**
** Arguments:
**
**  pSrb - the request block to release.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReleaseDataRequest( PHW_STREAM_REQUEST_BLOCK pSrb )
{
  if ( pSrb->Status == STATUS_PENDING )
  {
    MonoOutStr( " !!! Srb is PENDING - not releasing !!! " );
  }
  else
  {
    StreamClassStreamNotification( ReadyForNextStreamDataRequest,
                                   pSrb->StreamObject);

    StreamClassStreamNotification( StreamRequestComplete,
                                   pSrb->StreamObject,
                                   pSrb);
//	MonoOutStr(" ReleaseData ");
  }
}

/*
** AdapterReleaseDeviceRequest()
**
**   This routine is called when any of the open pins (streams) wants
**   to dispose an used device request block.
**
** Arguments:
**
**  pSrb - the request block to release.
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI AdapterReleaseDeviceRequest( PHW_STREAM_REQUEST_BLOCK pSrb )
{
  StreamClassDeviceNotification( ReadyForNextDeviceRequest,
                                 pSrb->HwDeviceExtension);

  StreamClassDeviceNotification( DeviceRequestComplete,
                                 pSrb->HwDeviceExtension,
                                 pSrb);
}

VOID STREAMAPI AdapterReleaseCtrlDataSrb( PHW_STREAM_REQUEST_BLOCK pSrb )
 {
  PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
  KSSTREAM_HEADER *pHeader;

  //
  // Clear the CurrentSrb and Sample count for this Srb
  //


  

  
  pSrb->Status = STATUS_SUCCESS;

  //
  // Check if this is the last Srb for current title
  //

  pHeader = ((KSSTREAM_HEADER *)(pSrb->CommandData.DataBufferArray)) ;

  if ( pHeader->TypeSpecificFlags & KS_AM_UseNewCSSKey )
  {
     switch ( pSrb->StreamObject->StreamNumber )
    {
		case ZivaVideo:
			pHwDevExt->bVideoCanAuthenticate = TRUE;
			break;

		case ZivaAudio:
		  pHwDevExt->bAudioCanAuthenticate = TRUE;
		  break;

		case ZivaSubpicture:
			pHwDevExt->bSubPictureCanAuthenticate = TRUE;
			break;

		default:
			MonoOutStr( "!!!!!!!! Last Srb for UNKNOWN stream !!!!!!!!" );
    }
  }

  AdapterReleaseDataRequest( pSrb );
}


BOOL CheckAndReleaseIfCtrlPkt(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	KSSTREAM_HEADER *pHeader;
    pHeader    = ((PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray);

	if (pHeader->TypeSpecificFlags & KS_AM_UseNewCSSKey)
	{
		if (pSrb->NumberOfBuffers == 0)
		{
			AdapterReleaseCtrlDataSrb(pSrb);
			return TRUE;
		}
		else if (pSrb->NumberOfBuffers == 1)
		{
			BYTE   *pData;
			DWORD  dwDataUsed;

			pData      = pHeader->Data;
			dwDataUsed = pHeader->DataUsed;

			if ((dwDataUsed == 0) ||
				(pData &&  *((DWORD*)pData) != 0xBA010000)) 
			{
				AdapterReleaseCtrlDataSrb(pSrb);
				return TRUE;;
			}

		}
		
	}

	return FALSE;
}



#if 0
static void STREAMAPI CreateFile(PHW_STREAM_REQUEST_BLOCK pSrb )
{

	NTSTATUS ntStatus;

	ASSERT( pSrb->Status == STATUS_PENDING );
			
	RtlInitUnicodeString (&pathUnicodeString,wPath);
                              


	InitializeObjectAttributes(&InitializedAttributes,&pathUnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);
//	InitializedAttributes.Length = 2048;
//	AllocSize.QuadPart=0xffff;
//	ntStatus = ZwCreateFile(&Handle,FILE_WRITE_DATA,
//										&InitializedAttributes,&IOStatusBlock,
//										0,FILE_ATTRIBUTE_NORMAL,0,FILE_SUPERSEDE,
//										FILE_NO_INTERMEDIATE_BUFFERING,NULL,0);
	ntStatus = ZwCreateFile( &Handle,
                             GENERIC_WRITE,
                            &InitializedAttributes,
                            &IOStatusBlock,
                            NULL,                          // alloc size = none
                            FILE_ATTRIBUTE_NORMAL,
                            0,
                            FILE_CREATE,
                            FILE_WRITE_THROUGH,
                            NULL,  // eabuffer
                            0 );   // ealength

	if(NT_SUCCESS(ntStatus))
		MonoOutStr("File Creation success");
	
	MonoOutULong(IOStatusBlock.Information);
	
	if( (IOStatusBlock.Information == FILE_CREATED) || (IOStatusBlock.Information == FILE_OPENED) )
		MonoOutStr("File Creation success");
	else
		MonoOutStr("File Creation failed");

	pSrb->Status = STATUS_SUCCESS;

	StreamClassCallAtNewPriority( pSrb->StreamObject, pSrb->HwDeviceExtension, LowToHigh,
									(PHW_PRIORITY_ROUTINE)AdapterReleaseRequest, pSrb );
}

#endif



/*WriteFile()
{
	if(STATUS_SUCCESS != ZwWriteFile(Handle,NULL,NULL,NULL,&IOStatusBlock,pdwPhysAddress ,dwCount,NULL,NULL))
			MonoOutStr("WriteOperationFailed");
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\52xhlp.cpp ===
/******************************************************************************
*
*	$RCSfile: 52xHlp.cpp $
*	$Source: u:/si/VXP/Wdm/Encore/52x/52xHlp.cpp $
*	$Author: Max $
*	$Date: 1999/02/19 00:10:31 $
*	$Revision: 1.6 $
*
*	Written by:		Max Paklin
*	Purpose:		Helper functions for 52x analog overlay hardware
*
*******************************************************************************
*
*	Copyright  1998-99, AuraVision Corporation. All rights reserved.
*
*	AuraVision Corporation makes no warranty of any kind, express or implied,
*	with regard to this software. In no event shall AuraVision Corporation
*	be liable for incidental or consequential damages in connection with or
*	arising from the furnishing, performance, or use of this software.
*
*	Tab step is to be set to 4 to achive the best readability for this code.
*
*******************************************************************************/
#include "Comwdm.h"
#pragma hdrstop
#include "Avwinwdm.h"
extern "C"
{
/******************************************************************************/
/*** Macrovision handler interface routines ***********************************/
// The next two functions are actually sort of "exported" from here for Macrovision handler.
// They provide I2C service that Macrovision license code can use to access I2C registers
int __stdcall SetI2CRegister( unsigned int uID, unsigned int uIndex, unsigned int uData )
{
	if( HW_SetExternalRegister( 2, (WORD)uID, (WORD)uIndex, (WORD)uData ) == 0 )
		return TRUE;
	return FALSE;
}
unsigned int __stdcall GetI2CRegister( unsigned int uID, unsigned int uIndex )
{
	return HW_GetExternalRegister( 2, (WORD)uID, (WORD)uIndex );
}
/*** Macrovision handler interface routines ***********************************/
/******************************************************************************/
}			// extern "C"


/******************************************************************************/
/*** Functions to be used by AvWin ********************************************/
static PVOID			s_hHandle		= NULL;
static PDEVICE_OBJECT	s_pDeviceObject	= NULL;
extern "C" void APIENTRY AV_SetContextHandle( PVOID hHandle, PVOID pDeviceObject )
{
	s_hHandle = hHandle;
	s_pDeviceObject = (PDEVICE_OBJECT)pDeviceObject;
}
extern "C" SINT APIENTRY AV_GetProfileString
							(
								LPCWSTR	pwszSection,
								LPCWSTR	pwszEntry,
								LPCWSTR	pwszDefault,
								LPWSTR	pwszBufferReturn,
								int		nBufferReturn
							)
{
	if( s_hHandle == NULL && s_pDeviceObject == NULL )
		return 0;
	CKsRegKey regKey( pwszSection, s_pDeviceObject, s_hHandle );
 	if( !regKey.GetValue( pwszEntry, pwszBufferReturn, (USHORT)nBufferReturn, pwszDefault ) )
		wcsncpy( pwszBufferReturn, pwszDefault, nBufferReturn/sizeof( WCHAR ) );

	return wcslen( pwszBufferReturn );
}

extern "C" UINT APIENTRY AV_GetProfileInt( LPCWSTR pwszSection, LPCWSTR pwszEntry, int nDefault )
{
	if( s_hHandle == NULL && s_pDeviceObject == NULL )
		return nDefault;
	CKsRegKey	regKey( pwszSection, s_pDeviceObject, s_hHandle );
	int			nValue;
	if( !regKey.GetValue( pwszEntry, nValue, nDefault ) )
		nValue = nDefault;
	return (UINT)nValue;
}

extern "C" BOOL APIENTRY AV_WriteProfileString
							(
								LPCWSTR pwszSection,
								LPCWSTR pwszEntry,
								LPCWSTR pwszString
							)
{
	if( s_hHandle == NULL && s_pDeviceObject == NULL )
		return FALSE;
	CKsRegKey regKey( pwszSection, s_pDeviceObject, s_hHandle );
 	return regKey.SetValue( pwszEntry, pwszString );
}
extern "C" BOOL APIENTRY AV_WriteProfileInt
							(
								LPCWSTR pwszSection,
								LPCWSTR pwszEntry,
								SINT Value
							)
{
	if( s_hHandle == NULL && s_pDeviceObject == NULL )
		return FALSE;
	CKsRegKey regKey( pwszSection, s_pDeviceObject, s_hHandle );
 	return regKey.SetValue( pwszEntry, (int)Value );
}
/*** Functions to be used by AvWin ********************************************/
/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\adapter.h ===
/******************************************************************************\
*                                                                              *
*      ADAPTER.H  -     Adapter control related code header file.              *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _ADAPTER_H_
#define _ADAPTER_H_

NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath );

VOID STREAMAPI AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AdapterCancelPacket( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AdapterTimeoutPacket( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AdapterSendData( IN PHW_DEVICE_EXTENSION pHwDevEx );
BOOLEAN STREAMAPI HwInterrupt ( IN PHW_DEVICE_EXTENSION  pHwDevEx );
VOID STREAMAPI AdapterReleaseRequest( PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL STREAMAPI AdapterCanAuthenticateNow( IN PHW_DEVICE_EXTENSION pHwDevExt );
VOID STREAMAPI AdapterClearAuthenticationStatus( IN PHW_DEVICE_EXTENSION pHwDevExt );

VOID STREAMAPI adapterUpdateNextSrbOrderNumberOnDiscardSrb( PHW_STREAM_REQUEST_BLOCK pSrb );

// These functions are used to set or get adapter property. They mostly
// set or get analog chip properties
VOID AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

BOOL AdapterSetState( PHW_STREAM_REQUEST_BLOCK pSrb );

void IssuePendingCommands(PHW_DEVICE_EXTENSION pHwDevExt);
VOID STREAMAPI AdapterReleaseCurrentSrb( PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL CheckAndReleaseIfCtrlPkt(PHW_STREAM_REQUEST_BLOCK pSrb);

#endif  // _ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dvdts\lib\zrnpch6.h ===
//***************************************************************************
//	Zoran download code header
//
//***************************************************************************

// ===========================================================================
//                  Dolby AC-3 Decod-Out
// ===========================================================================
UCHAR ZRN_AC3_DEC[] = {
	0x91, 0x3A, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0x3A, 0x65, 0x82, 0x89, 0x00, 0x00, 0x00, 0x90,
	0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8,
	0x00, 0x00, 0x00, 0x01, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x1D, 0x03, 0xD2, 0x00, 0x00, 0xB0, 0x3C,
	0x00, 0x00, 0xB8, 0x0C, 0x38, 0x0D, 0x00, 0x19,
	0x32, 0x10, 0x0F, 0xF5, 0x3B, 0x80, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xFB, 0x00, 0x03, 0xCD, 0x82,
	0x38, 0x8D, 0x00, 0x00, 0x3A, 0x80, 0x03, 0xB8,
	0x3A, 0xAD, 0x00, 0x0E, 0x00, 0x03, 0xF0, 0x85,
	0x1B, 0x5B, 0xCD, 0x86, 0x1B, 0x93, 0xF0, 0x85,
	0x3B, 0x80, 0x00, 0x01, 0x36, 0xDE, 0x00, 0x42,
	0x00, 0x03, 0xC0, 0xB6, 0x30, 0x3D, 0x03, 0xFB,
	0x2F, 0x2F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x2F,
	0x00, 0x2F, 0x21, 0x00, 0x00, 0x03, 0x04, 0x01,
	0x09, 0x0A, 0x07, 0x0E, 0x0F, 0x10, 0x0D, 0x11,
	0x34, 0x20, 0x0F, 0xFA, 0x30, 0x2D, 0x03, 0xEE,
	0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x6B,
	0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x30, 0x00, 0x07,
	0x38, 0x00, 0x00, 0x02, 0x32, 0x1D, 0x03, 0xEE,
	0x34, 0x0D, 0x03, 0xD4, 0x2C, 0x10, 0x00, 0x40,
	0x30, 0x0D, 0x03, 0xD4, 0x2C, 0xB0, 0x00, 0x01,
	0x3C, 0x6D, 0x00, 0x32, 0x00, 0x00, 0xCC, 0x4B,
	0x00, 0x00, 0xCC, 0x0B, 0x3A, 0xDE, 0x16, 0x12,
	0x3A, 0xFD, 0x00, 0x2B, 0x00, 0x03, 0xEB, 0xC1,
	0x38, 0x00, 0x05, 0x40, 0x32, 0x1D, 0x03, 0xD4,
	0x38, 0xBD, 0x00, 0x13, 0x38, 0xCD, 0x03, 0xF0,
	0x3E, 0x00, 0x00, 0x03, 0x00, 0x06, 0x56, 0xE3,
	0x3A, 0xDD, 0x00, 0x36, 0x38, 0x00, 0x00, 0x02,
	0x32, 0x10, 0x0F, 0xFA, 0x2C, 0xB0, 0x00, 0x02,
	0x3C, 0x1D, 0x00, 0x6F, 0x34, 0x20, 0x0F, 0xC5,
	0x2C, 0x80, 0x00, 0x07, 0x2E, 0xB0, 0x00, 0x00,
	0x38, 0x8E, 0x2B, 0xE2, 0x00, 0x03, 0xC0, 0x98,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x02,
	0x34, 0x00, 0x0F, 0xE5, 0x2C, 0x00, 0x03, 0x03,
	0x2E, 0x30, 0x00, 0x00, 0x18, 0x80, 0x00, 0x00,
	0x34, 0x20, 0x0F, 0xE5, 0x2C, 0x80, 0x0C, 0x00,
	0x2E, 0xB0, 0x00, 0x02, 0x18, 0x10, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x02, 0x3C, 0x1D, 0x00, 0x4D,
	0x38, 0x0D, 0x03, 0x63, 0x32, 0x10, 0x0F, 0xF9,
	0x38, 0x0D, 0x03, 0x67, 0x32, 0x10, 0x0F, 0xF9,
	0x00, 0x00, 0xC0, 0x02, 0x00, 0x00, 0xB0, 0x42,
	0x30, 0x20, 0x0D, 0xF1, 0x38, 0x3E, 0x2B, 0xD1,
	0x38, 0x4E, 0x2B, 0xA9, 0x3A, 0xDE, 0x16, 0x68,
	0x3A, 0xFD, 0x00, 0x53, 0x00, 0x03, 0xEB, 0xC1,
	0xB0, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x03, 0xCC,
	0x30, 0x0D, 0x03, 0xC9, 0x30, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF6,
	0x32, 0x1D, 0x03, 0xE5, 0x32, 0x1D, 0x03, 0xE6,
	0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00, 0x08, 0x00,
	0x3C, 0x1D, 0x00, 0x68, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0F, 0x8D, 0x38, 0x0D, 0x03, 0x14,
	0x32, 0x1D, 0x03, 0xCF, 0x38, 0x0D, 0x02, 0xB9,
	0x32, 0x10, 0x0F, 0xF8, 0x00, 0x00, 0xB8, 0x0C,
	0x00, 0x00, 0xB0, 0x3C, 0x38, 0x00, 0x03, 0x80,
	0x32, 0x10, 0x0D, 0xCB, 0x3A, 0xDD, 0x01, 0x5D,
	0x38, 0x00, 0x00, 0x02, 0x32, 0x10, 0x0F, 0xFA,
	0x3C, 0x6D, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xCA,
	0x34, 0x00, 0x0D, 0xCA, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x00, 0xBA, 0x00, 0x00, 0xBC, 0x4B,
	0x00, 0x00, 0xBC, 0x0B, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x10, 0x0D, 0xC4, 0x34, 0x2D, 0x03, 0xEE,
	0x2C, 0xB0, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x7D,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xB3, 0x87,
	0x3A, 0xDD, 0x00, 0x81, 0x00, 0x00, 0xC3, 0x87,
	0x30, 0x7D, 0x03, 0xCC, 0x3A, 0xDD, 0x02, 0x26,
	0x3A, 0xFD, 0x00, 0x81, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDE, 0x19, 0x7E, 0x3A, 0xFD, 0x00, 0x84,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xE5,
	0x3A, 0xFD, 0x00, 0x87, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0xFB, 0x3A, 0xFD, 0x00, 0x8A,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0xE7,
	0x3A, 0xFD, 0x00, 0x8D, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0x60, 0x3A, 0xFD, 0x00, 0x90,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x88,
	0x3A, 0xFD, 0x00, 0x93, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0x9C, 0x3A, 0xFD, 0x00, 0x96,
	0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xC4,
	0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xF5,
	0x34, 0x10, 0x0D, 0xCB, 0x34, 0x00, 0x0D, 0xC9,
	0x34, 0x80, 0x0D, 0xC1, 0x35, 0x00, 0x0D, 0xFD,
	0x32, 0x10, 0x0D, 0xDA, 0xB0, 0x50, 0x60, 0x00,
	0x30, 0x80, 0x0D, 0xD6, 0x14, 0x90, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x18, 0x30, 0x20, 0x0D, 0xC9,
	0x00, 0x00, 0x80, 0x00, 0x30, 0x80, 0x0D, 0xC8,
	0x39, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x06,
	0x32, 0x10, 0x0D, 0xD5, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xD7, 0x34, 0x00, 0x0D, 0xFD,
	0x32, 0x10, 0x0D, 0xD8, 0x34, 0x00, 0x0D, 0xF2,
	0x32, 0x10, 0x0D, 0xD9, 0xB0, 0x03, 0xD0, 0x81,
	0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 0x00, 0x41,
	0x3A, 0xFD, 0x00, 0xB3, 0x00, 0x03, 0xEB, 0xC1,
	0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF5,
	0x30, 0x00, 0x0D, 0xC7, 0x34, 0x20, 0x0D, 0xC4,
	0x3A, 0xDD, 0x00, 0xF5, 0x00, 0x00, 0xB0, 0x82,
	0x30, 0x20, 0x0D, 0xC4, 0x3A, 0xDE, 0x18, 0xE5,
	0x3A, 0xFD, 0x00, 0xBD, 0x00, 0x03, 0xEB, 0xC1,
	0x3A, 0xDD, 0x01, 0xE7, 0x3A, 0xFD, 0x00, 0xC0,
	0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x60,
	0x3A, 0xFD, 0x00, 0xC3, 0x00, 0x03, 0xEB, 0xC1,
	0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x02,
	0x04, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xE3,
	0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x05,
	0x04, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF5,
	0x00, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x01,
	0x3C, 0x1D, 0x00, 0xD8, 0x38, 0x23, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xCC, 0x00, 0x00, 0xD4, 0x43,
	0x3C, 0x6D, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x30, 0x00, 0x04, 0x3C, 0x1D, 0x00, 0xD8,
	0x00, 0x00, 0x00, 0x00, 0x38, 0x22, 0x55, 0x55,
	0x38, 0x22, 0xAA, 0xAB, 0x00, 0x00, 0xD3, 0x83,
	0x3C, 0x1D, 0x00, 0xF5, 0x34, 0x00, 0x0D, 0xCB,
	0x44, 0x00, 0x00, 0x00, 0x34, 0x10, 0x0F, 0x8D,
	0xA2, 0x00, 0x00, 0x00, 0x3C, 0x4D, 0x00, 0xF5,
	0x00, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0F, 0x8D,
	0x3A, 0xDD, 0x00, 0xF5, 0x00, 0x00, 0xC0, 0x3C,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x00, 0xF5, 0x34, 0x00, 0x0D, 0xC8,
	0x32, 0x10, 0x0D, 0xD6, 0x34, 0x00, 0x0D, 0xC9,
	0x32, 0x10, 0x0D, 0xDA, 0x34, 0x00, 0x0D, 0xC7,
	0x38, 0x10, 0x00, 0x02, 0x38, 0x80, 0x0D, 0xD5,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x00, 0xF0,
	0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x1D, 0x00, 0xF5, 0x34, 0x20, 0x0D, 0xC4,
	0x00, 0x00, 0xB0, 0xC2, 0x30, 0x20, 0x0D, 0xC4,
	0x38, 0x00, 0x00, 0x0F, 0x32, 0x10, 0x0D, 0xDB,
	0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xDE,
	0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF,
	0x34, 0x00, 0x0D, 0xF3, 0x2C, 0x00, 0x00, 0x0F,
	0x32, 0x10, 0x0D, 0xE8, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0D, 0xE9, 0x38, 0x00, 0x0D, 0xCF,
	0x32, 0x10, 0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE,
	0x32, 0x10, 0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xFF,
	0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF1,
	0x32, 0x10, 0x0D, 0xE3, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xDD, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0D, 0xF4,
	0x32, 0x10, 0x0D, 0xE7, 0x34, 0x00, 0x0D, 0xCA,
	0x32, 0x10, 0x0D, 0xE4, 0x34, 0x00, 0x0D, 0xCC,
	0x32, 0x10, 0x0D, 0xE5, 0x34, 0x00, 0x0D, 0xCD,
	0x32, 0x10, 0x0D, 0xE6, 0x34, 0x20, 0x0D, 0xF1,
	0x2C, 0x80, 0x3F, 0x02, 0x30, 0x20, 0x0D, 0xE3,
	0x38, 0x0E, 0x2B, 0xA9, 0x32, 0x10, 0x0D, 0xE0,
	0x38, 0x0E, 0x2B, 0xAF, 0x32, 0x10, 0x0D, 0xE1,
	0x38, 0x0E, 0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xE2,
	0x34, 0x00, 0x0D, 0xE8, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x01, 0x23, 0x34, 0x00, 0x0D, 0xC4,
	0x38, 0x80, 0x0D, 0xDB, 0x06, 0x00, 0x00, 0x00,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0x87,
	0x3C, 0x1D, 0x01, 0x2A, 0x34, 0x10, 0x0F, 0xFC,
	0x00, 0x48, 0x00, 0x00, 0x3C, 0x6D, 0x01, 0x2C,
	0x00, 0x00, 0x00, 0x00, 0x38, 0x10, 0x00, 0x03,
	0x38, 0x0F, 0xFF, 0xFF, 0x3A, 0xDD, 0x03, 0x77,
	0x3A, 0xFD, 0x01, 0x2F, 0x00, 0x03, 0xEB, 0xC1,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0x32,
	0x00, 0x03, 0xEB, 0xC1, 0x30, 0x00, 0x0D, 0xC5,
	0x3A, 0xDE, 0x19, 0x40, 0x3A, 0xFD, 0x01, 0x36,
	0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xCA,
	0x2C, 0x30, 0x00, 0x05, 0x3C, 0x5D, 0x01, 0x3C,
	0x12, 0x03, 0xD0, 0x01, 0x30, 0x00, 0x0D, 0xCA,
	0x30, 0x10, 0x0D, 0xCA, 0x38, 0x00, 0x00, 0x08,
	0x32, 0x1D, 0x03, 0xD3, 0x34, 0x0D, 0x03, 0xEE,
	0x2C, 0x30, 0x00, 0x00, 0x3C, 0x1D, 0x01, 0x44,
	0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x10, 0x05, 0x00,
	0x2C, 0x10, 0x00, 0x40, 0x34, 0x20, 0x0D, 0xC5,
	0x34, 0x10, 0x0D, 0xC4, 0x00, 0x4B, 0xD0, 0xC1,
	0x3C, 0x1D, 0x01, 0x4B, 0x0C, 0x50, 0x00, 0x00,
	0x18, 0x80, 0x00, 0x00, 0x2C, 0x10, 0x40, 0x00,
	0x32, 0x1D, 0x03, 0xD4, 0x38, 0x0D, 0x03, 0xD3,
	0x32, 0x10, 0x0F, 0xFB, 0x34, 0x00, 0x0F, 0xC5,
	0x2C, 0x00, 0x10, 0x00, 0x3C, 0x1D, 0x01, 0x5D,
	0x34, 0x7D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0x47,
	0x3C, 0x1D, 0x01, 0x57, 0x00, 0x00, 0xC8, 0x4C,
	0x00, 0x00, 0xC0, 0xBC, 0x00, 0x00, 0xB0, 0xBC,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0x5D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xFC, 0x00, 0x00, 0xB0, 0xFC,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x01, 0x64, 0x34, 0x3D, 0x03, 0xD2,
	0x30, 0x0D, 0x03, 0xD2, 0x00, 0x58, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0x85, 0x34, 0x0D, 0x03, 0xCC,
	0x00, 0x00, 0xD3, 0xA1, 0x3C, 0x1D, 0x01, 0x85,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3B, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x0D, 0x03, 0xF5, 0x00, 0x00, 0xD0, 0x20,
	0x00, 0x00, 0xB0, 0x20, 0x32, 0x0D, 0x03, 0xF5,
	0x3C, 0x6D, 0x01, 0x85, 0x3B, 0x80, 0x00, 0x01,
	0x00, 0x03, 0xCD, 0xA1, 0x00, 0x00, 0xD1, 0xE0,
	0x3C, 0x6D, 0x01, 0x79, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xC3, 0xC5, 0x00, 0x00, 0xB3, 0xC5,
	0x30, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xD1, 0xA0,
	0x3C, 0x6D, 0x01, 0x85, 0x2E, 0x2F, 0xFF, 0xFC,
	0x00, 0x03, 0xC8, 0x02, 0x2C, 0x8F, 0xFF, 0xF0,
	0x2E, 0xAF, 0xFF, 0xFC, 0x30, 0x2D, 0x03, 0xCE,
	0x3A, 0xDD, 0x01, 0x84, 0x36, 0x0D, 0x03, 0xF4,
	0x33, 0x6D, 0x03, 0xC9, 0x32, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xD4, 0xC5, 0x3C, 0x1D, 0x01, 0x98,
	0x34, 0x0D, 0x03, 0xC7, 0x36, 0x0D, 0x03, 0xC8,
	0x2C, 0x00, 0xFF, 0xFF, 0x2E, 0x20, 0x00, 0x07,
	0x00, 0x03, 0xC8, 0x83, 0x2E, 0x20, 0x00, 0x01,
	0x00, 0x03, 0xC0, 0xE2, 0x2E, 0x2F, 0xFF, 0xFC,
	0x2E, 0x3F, 0xFF, 0xFF, 0x2E, 0x2F, 0xFF, 0xFA,
	0x3A, 0xDD, 0x01, 0x98, 0x00, 0x03, 0xC8, 0x76,
	0x32, 0x0D, 0x03, 0xF7, 0x00, 0x00, 0xC4, 0xC5,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0xC4, 0x45,
	0x30, 0x5D, 0x03, 0xCC, 0xB0, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x01, 0xA0, 0x36, 0x0D, 0x03, 0xF7,
	0x00, 0x03, 0xCD, 0xA1, 0x34, 0x1D, 0x03, 0xC9,
	0x36, 0x4D, 0x03, 0xCA, 0xB2, 0x00, 0x00, 0x00,
	0x34, 0x1D, 0x03, 0xCE, 0x2E, 0x6F, 0xFF, 0xEC,
	0xB2, 0x03, 0xD0, 0x42, 0x38, 0x38, 0x00, 0x00,
	0x3C, 0x5D, 0x01, 0xAC, 0x0A, 0x83, 0xC8, 0x02,
	0x2C, 0x2F, 0xFF, 0xFF, 0x2C, 0x2F, 0xFF, 0xFF,
	0x38, 0x37, 0xFF, 0xFF, 0x3C, 0x1D, 0x01, 0xB0,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x2D, 0x03, 0xCD,
	0x30, 0x3D, 0x03, 0xCD, 0x34, 0x7D, 0x03, 0xCC,
	0x00, 0x00, 0xC3, 0x47, 0x30, 0x7D, 0x03, 0xCC,
	0x34, 0x30, 0x0F, 0xC5, 0x2C, 0xC0, 0x00, 0x40,
	0x3C, 0x1D, 0x01, 0xDE, 0x36, 0x4D, 0x03, 0xF7,
	0x00, 0x03, 0xCD, 0xA5, 0x00, 0x00, 0xD3, 0x87,
	0x3C, 0x1D, 0x01, 0xDE, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xD2, 0xC7, 0x3C, 0x1D, 0x01, 0xDE,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x01, 0xDE, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xD3, 0xC7, 0x3C, 0x1D, 0x01, 0xDE,
	0x13, 0xFB, 0xD3, 0xC4, 0x2D, 0xCF, 0xFF, 0xEF,
	0x30, 0x7D, 0x03, 0xCC, 0x17, 0xE0, 0x00, 0x00,
	0x3C, 0x1D, 0x01, 0xDE, 0x34, 0x4D, 0x03, 0xCD,
	0x2D, 0x30, 0x01, 0xE0, 0x3C, 0x2D, 0x01, 0xD6,
	0x00, 0x00, 0x00, 0x00, 0x2D, 0x3F, 0xFB, 0x50,
	0x3C, 0x3D, 0x01, 0xDE, 0x34, 0x30, 0x0D, 0xCB,
	0x3A, 0x00, 0x05, 0xA0, 0x30, 0x3D, 0x03, 0xD1,
	0xA0, 0x48, 0x00, 0x00, 0x34, 0x5D, 0x03, 0xCC,
	0x3A, 0xDD, 0x01, 0xDC, 0x38, 0x0D, 0x03, 0x17,
	0x32, 0x1D, 0x03, 0xCF, 0x3A, 0x00, 0x05, 0xA0,
	0xB0, 0x48, 0x00, 0x00, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xC0, 0x34, 0x5D, 0x03, 0xCC,
	0x00, 0x00, 0xB4, 0x45, 0x00, 0x00, 0xB3, 0x45,
	0x30, 0x5D, 0x03, 0xCC, 0x34, 0x4D, 0x03, 0xCD,
	0x2F, 0x20, 0x00, 0x04, 0x2F, 0x3F, 0xFF, 0xFC,
	0xB6, 0xDB, 0xD0, 0x36, 0x30, 0x4D, 0x03, 0xD6,
	0x30, 0x3D, 0x03, 0xD5, 0x00, 0x03, 0xF0, 0x2D,
	0x00, 0x03, 0xC9, 0x76, 0x32, 0x4D, 0x03, 0xF7,
	0x34, 0x0D, 0x03, 0xCC, 0x00, 0x00, 0xD3, 0xA1,
	0x3C, 0x1D, 0x01, 0xED, 0x00, 0x00, 0x00, 0x00,
	0xB2, 0x48, 0x00, 0x00, 0x3A, 0x40, 0x00, 0xF0,
	0x34, 0x0D, 0x03, 0xC9, 0x36, 0x0D, 0x03, 0xCA,
	0xA2, 0x00, 0x00, 0x00, 0x32, 0x1D, 0x03, 0xC9,
	0x3B, 0x80, 0x00, 0x00, 0x32, 0x0D, 0x03, 0xCA,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF6,
	0x36, 0x0D, 0x03, 0xF7, 0x00, 0x03, 0xCD, 0xA1,
	0xA2, 0x03, 0xD0, 0x78, 0x00, 0x03, 0xF0, 0x2D,
	0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF7,
	0x34, 0x00, 0x0F, 0xC5, 0x00, 0x00, 0xD1, 0x61,
	0x3C, 0x1D, 0x02, 0x23, 0x34, 0x7D, 0x03, 0xCC,
	0x00, 0x00, 0xD3, 0x87, 0x00, 0x00, 0xB3, 0x07,
	0x3C, 0x1D, 0x02, 0x0B, 0x34, 0x00, 0x0F, 0xFC,
	0x00, 0x00, 0xD0, 0x21, 0x3C, 0x1D, 0x02, 0x0B,
	0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00,
	0x3C, 0x6D, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x07,
	0x30, 0x7D, 0x03, 0xCC, 0x34, 0x0D, 0x03, 0xD8,
	0x2C, 0x00, 0x07, 0x00, 0x2E, 0x30, 0x00, 0x04,
	0x2C, 0x10, 0x00, 0x10, 0x32, 0x1D, 0x03, 0xE9,
	0x34, 0x00, 0x0D, 0xC1, 0x32, 0x1D, 0x03, 0xEC,
	0x34, 0x30, 0x0D, 0xCB, 0x30, 0x3D, 0x03, 0xEA,
	0x38, 0x20, 0x0B, 0xFC, 0xB6, 0x90, 0x00, 0x00,
	0x30, 0x2D, 0x03, 0xEB, 0x2E, 0xCF, 0xFA, 0x06,
	0x2E, 0xDA, 0xAA, 0xAB, 0x3B, 0x80, 0x00, 0x00,
	0x2C, 0xCF, 0xFF, 0xFE, 0x00, 0x00, 0xD0, 0x0F,
	0x3C, 0x1D, 0x02, 0x21, 0x38, 0x0D, 0x03, 0x7A,
	0x32, 0x10, 0x0F, 0xF9, 0x14, 0xD8, 0x00, 0x00,
	0x3B, 0x80, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xED,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0F, 0x8D,
	0x00, 0x43, 0xC3, 0xC0, 0x3C, 0x4D, 0x02, 0x30,
	0x34, 0x10, 0x0D, 0xC2, 0x04, 0x08, 0x00, 0x00,
	0x3C, 0x6D, 0x02, 0x26, 0x38, 0x00, 0x00, 0x07,
	0x32, 0x10, 0x0D, 0xC6, 0x3A, 0xDD, 0x02, 0x91,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0D, 0xC0,
	0x3A, 0xDD, 0x02, 0xAE, 0x3A, 0xFD, 0x02, 0x34,
	0x00, 0x03, 0xEB, 0xC1, 0x2E, 0x0F, 0xFF, 0xF6,
	0x3C, 0x3D, 0x02, 0x3B, 0x38, 0x10, 0x00, 0x01,
	0x38, 0x20, 0x01, 0x18, 0x3A, 0xDD, 0x02, 0x91,
	0x30, 0x20, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C,
	0x20, 0x40, 0x00, 0x00, 0x30, 0x00, 0x0D, 0xE1,
	0x34, 0x00, 0x0D, 0xC0, 0x32, 0x10, 0x0D, 0xDC,
	0x34, 0x00, 0x0F, 0x88, 0x32, 0x10, 0x0D, 0xDD,
	0x31, 0x60, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2,
	0x32, 0x10, 0x0D, 0xDF, 0x38, 0x00, 0x00, 0x00,
	0x32, 0x10, 0x0D, 0xE0, 0x38, 0x80, 0x0D, 0xDB,
	0xB0, 0x03, 0xD2, 0x01, 0x3A, 0xDE, 0x19, 0x92,
	0x3A, 0xFD, 0x02, 0x4B, 0x00, 0x03, 0xEB, 0xC1,
	0x00, 0x43, 0xC5, 0x91, 0x34, 0x90, 0x0F, 0x87,
	0x3C, 0x6D, 0x02, 0x8E, 0x38, 0x00, 0x00, 0x01,
	0x32, 0x10, 0x0D, 0xC6, 0x30, 0x90, 0x0D, 0xC1,
	0x38, 0x00, 0x00, 0x05, 0x32, 0x10, 0x0D, 0xDB,
	0x30, 0x90, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88,
	0x32, 0x10, 0x0D, 0xDD, 0x31, 0x60, 0x0D, 0xDE,
	0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF,
	0x38, 0x80, 0x0D, 0xDB, 0xB0, 0x03, 0xD0, 0x41,
	0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x02, 0x5E,
	0x00, 0x03, 0xEB, 0xC1, 0x39, 0x80, 0x00, 0x02,
	0x30, 0x00, 0x0D, 0xC6, 0x00, 0x43, 0x60, 0x02,
	0x3C, 0x6D, 0x02, 0x8B, 0x39, 0x80, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x01,
	0x30, 0x20, 0x0D, 0xCB, 0x30, 0x10, 0x0D, 0xC9,
	0x39, 0x10, 0x00, 0x00, 0x39, 0x80, 0x00, 0x04,
	0x00, 0x02, 0xA0, 0x07, 0x30, 0x7D, 0x03, 0xD7,
	0x00, 0x00, 0x80, 0x00, 0x38, 0x9D, 0x03, 0xD8,
	0x3E, 0x00, 0x00, 0x04, 0x00, 0x06, 0x51, 0xCF,
	0x34, 0x00, 0x0D, 0xFD, 0x22, 0x13, 0xC5, 0x91,
	0x34, 0x90, 0x0D, 0xC1, 0x00, 0x03, 0xC0, 0x99,
	0x38, 0x15, 0x00, 0x00, 0x34, 0x20, 0x0D, 0xCB,
	0x42, 0x98, 0x80, 0x08, 0x2E, 0xC0, 0x00, 0x08,
	0x30, 0x90, 0x0D, 0xC0, 0x34, 0x00, 0x0D, 0xC1,
	0x3A, 0xDD, 0x02, 0xAE, 0x3A, 0xFD, 0x02, 0x7C,
	0x00, 0x03, 0xEB, 0xC1, 0xB0, 0xC0, 0x00, 0x00,
	0x2C, 0x30, 0x00, 0x04, 0x3C, 0x4D, 0x02, 0x84,
	0x30, 0x00, 0x0F, 0x8D, 0x38, 0x00, 0x00, 0x07,
	0x3A, 0xDD, 0x02, 0x91, 0x30, 0x00, 0x0D, 0xC6,
	0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDD, 0x02, 0x95,
	0x3A, 0xFD, 0x02, 0x87, 0x00, 0x03, 0xEB, 0xC1,
	0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0x31, 0x10, 0x0D, 0xC4, 0x30, 0xF0, 0x0D, 0xC3,
	0x3A, 0xDD, 0x02, 0x8F, 0x34, 0x00, 0x0D, 0xC1,
	0x32, 0x10, 0x0D, 0xC0, 0x30, 0x90, 0x0D, 0xC0,
	0x38, 0x00, 0x03, 0x80, 0x32, 0x10, 0x0D, 0xCB,
	0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0x38, 0x00, 0x00, 0x01, 0x32, 0x10, 0x0D, 0xC4,
	0x3A, 0xDD, 0x02, 0x98, 0x34, 0x3D, 0x03, 0xE3,
	0x34, 0x4D, 0x03, 0xE4, 0x2E, 0xF0, 0x00, 0x04,
	0x2C, 0xC0, 0xFF, 0x00, 0x2F, 0x3F, 0xFF, 0xF4,
	0x19, 0x18, 0x00, 0x00, 0x34, 0x4D, 0x03, 0xE5,
	0xA8, 0xD8, 0x00, 0x00, 0x14, 0xDB, 0xC5, 0x91,
	0x2E, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0xC0, 0xD9,
	0x34, 0x9D, 0x03, 0xCB, 0x34, 0x40, 0x0D, 0xC1,
	0x00, 0x00, 0x80, 0x08, 0x00, 0x03, 0xC2, 0x43,
	0x04, 0xE0, 0x00, 0x00, 0x3C, 0x6D, 0x02, 0xAB,
	0x34, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xC4, 0xC5,
	0x00, 0x00, 0xB4, 0xC5, 0x00, 0x00, 0xB2, 0xC5,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x5D, 0x03, 0xCC, 0x00, 0x00, 0xCC, 0x4B,
	0x00, 0x03, 0xC3, 0x81, 0x34, 0x20, 0x0F, 0x8D,
	0xB0, 0x40, 0xBC, 0x4B, 0x3C, 0x2D, 0x02, 0xB6,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC5, 0x81,
	0xA2, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D,
	0xA0, 0x90, 0x00, 0x00, 0xB0, 0x48, 0x00, 0x00,
	0x00, 0x00, 0xD4, 0xFA, 0x3C, 0x1D, 0x03, 0x5F,
	0x38, 0x3D, 0x03, 0xE0, 0x30, 0x30, 0x0F, 0x8F,
	0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00,
	0x3B, 0x70, 0x00, 0x00, 0x00, 0x03, 0xCC, 0x04,
	0x30, 0x4D, 0x03, 0xDF, 0x2F, 0x3F, 0xFF, 0xFC,
	0x2D, 0x00, 0x07, 0xFF, 0x3C, 0x1D, 0x03, 0x5E,
	0x30, 0x40, 0x0F, 0x8E, 0x00, 0x03, 0xF0, 0x2C,
	0x2F, 0x0F, 0xFF, 0xF7, 0x30, 0x4D, 0x03, 0xC6,
	0x3A, 0xDD, 0x03, 0x5E, 0x38, 0x3D, 0x02, 0xCC,
	0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03, 0xCC, 0x03,
	0x2C, 0xCF, 0x00, 0x00, 0x2C, 0xF2, 0x00, 0x00,
	0x38, 0x3D, 0x02, 0xE5, 0x30, 0x30, 0x0F, 0xF8,
	0x38, 0x30, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xE8,
	0x3C, 0x1D, 0x02, 0xE5, 0x34, 0x3D, 0x03, 0xE5,
	0x30, 0x3D, 0x03, 0xE7, 0x2C, 0xE0, 0x00, 0x01,
	0x30, 0x3D, 0x03, 0xE7, 0x34, 0x40, 0x0F, 0x8E,
	0x00, 0x00, 0xD0, 0x04, 0x3C, 0x1D, 0x02, 0xDE,
	0x2F, 0x0F, 0xFF, 0xFC, 0x33, 0x8D, 0x03, 0xE8,
	0x2F, 0x00, 0x00, 0x02, 0x30, 0x4D, 0x03, 0xC6,
	0x3A, 0xDD, 0x03, 0x5E, 0x38, 0x3D, 0x02, 0xE2,
	0x30, 0x30, 0x0F, 0xF8, 0x3A, 0xDD, 0x03, 0x5F,
	0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8,
	0x00, 0x03, 0xE2, 0xC1, 0x00, 0x03, 0xEB, 0x01,
	0x3B, 0x50, 0x00, 0x00, 0x3B, 0x70, 0x00, 0x00,
	0x00, 0x03, 0xCC, 0x04, 0x34, 0x30, 0x0F, 0x8F,
	0x2C, 0xFD, 0x03, 0xE4, 0x3C, 0x5D, 0x03, 0x0D,
	0x12, 0xDB, 0xC0, 0xCB, 0x30, 0x30, 0x0F, 0x8F,
	0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8,
	0x34, 0x3D, 0x03, 0xE5, 0x00, 0x5B, 0xFD, 0x03,
	0x3C, 0x1D, 0x03, 0x01, 0x00, 0x03, 0xEC, 0x34,
	0x30, 0xED, 0x03, 0xCB, 0x34, 0x4D, 0x03, 0xE6,
	0x0D, 0x1B, 0xCC, 0x04, 0x2C, 0xCF, 0xF0, 0x00,
	0x2D, 0x00, 0x0F, 0xF0, 0x18, 0xE0, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xCF, 0x2C, 0xFD, 0x03, 0x26,
	0x3C, 0x6D, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xE1, 0x32, 0x00, 0x00, 0x70, 0x30,
	0x34, 0x3D, 0x03, 0xE2, 0x2E, 0xFF, 0xFF, 0xF4,
	0x34, 0x4D, 0x03, 0xE1, 0x2F, 0x30, 0x00, 0x04,
	0x19, 0x18, 0x00, 0x00, 0x30, 0x3D, 0x03, 0xC8,
	0x34, 0x3D, 0x03, 0xE1, 0x2E, 0xFF, 0xFF, 0xF0,
	0x34, 0x4D, 0x03, 0xE0, 0x19, 0x1B, 0xCC, 0x04,
	0x30, 0x3D, 0x03, 0xC7, 0x2D, 0x0F, 0xF0, 0x00,
	0x00, 0x03, 0xE1, 0x1C, 0x3A, 0xDD, 0x03, 0x5E,
	0x00, 0x03, 0xF0, 0x2C, 0x00, 0x03, 0xF0, 0x0B,
	0x36, 0xDD, 0x03, 0xCF, 0x00, 0x03, 0xEB, 0x01,
	0xB6, 0xDB, 0xD0, 0x35, 0x3A, 0xDD, 0x03, 0x2E,
	0x38, 0x4D, 0x03, 0x2E, 0x30, 0x4D, 0x03, 0xCF,
	0x38, 0x4D, 0x03, 0x19, 0x30, 0x4D, 0x03, 0xCF,
	0x00, 0x03, 0xC3, 0x84, 0x34, 0x30, 0x0D, 0xC0,
	0x04, 0xE3, 0xD0, 0x37, 0x3C, 0x6D, 0x03, 0x2F,
	0x34, 0x3D, 0x03, 0xE7, 0x00, 0x5B, 0xFD, 0x04,
	0x3C, 0x1D, 0x03, 0x23, 0x38, 0x3D, 0x03, 0x26,
	0x2F, 0x30, 0x00, 0x08, 0x00, 0x03, 0xCC, 0x04,
	0x2D, 0x10, 0x0F, 0xF0, 0x00, 0x03, 0xE1, 0x32,
	0x30, 0x3D, 0x03, 0xCF, 0x34, 0x3D, 0x03, 0xD1,
	0x14, 0xD8, 0x00, 0x00, 0x3C, 0x3D, 0x03, 0x3F,
	0x30, 0x3D, 0x03, 0xD1, 0x00, 0x03, 0xEC, 0x34,
	0x3A, 0xDD, 0x03, 0x3F, 0x38, 0x3D, 0x03, 0x2E,
	0x30, 0x3D, 0x03, 0xCF, 0x3B, 0x70, 0x00, 0x00,
	0x34, 0x3D, 0x03, 0xE7, 0x00, 0x5B, 0xFD, 0x03,
	0x3C, 0x1D, 0x03, 0x36, 0x00, 0x03, 0xCC, 0x04,
	0x2F, 0x3F, 0xFF, 0xF8, 0x3A, 0xDD, 0x03, 0x39,
	0x00, 0x03, 0xEC, 0x32, 0x2E, 0xF0, 0x00, 0x08,
	0x19, 0x1B, 0xCC, 0x04, 0x00, 0x04, 0x4C, 0xF4,
	0x34, 0x30, 0x0F, 0x8D, 0x14, 0xD8, 0x00, 0x00,
	0x3C, 0x3D, 0x03, 0x3F, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x30, 0x0F, 0x8D, 0x00, 0x00, 0xB0, 0x3C,
	0x34, 0x3D, 0x03, 0xC6, 0x2E, 0xCF, 0xFF, 0xFE,
	0x2C, 0xF0, 0x00, 0x01, 0x3C, 0x3D, 0x03, 0x5D,
	0x30, 0x3D, 0x03, 0xC6, 0x34, 0x4D, 0x03, 0xE5,
	0x1B, 0x1B, 0xE1, 0x41, 0x30, 0x3D, 0x03, 0xE5,
	0x3C, 0x1D, 0x03, 0x5C, 0x38, 0x3D, 0x02, 0xB9,
	0x30, 0x30, 0x0F, 0xF8, 0x34, 0x3D, 0x03, 0xE8,
	0x17, 0x1B, 0xC0, 0xC5, 0x19, 0x2B, 0xC0, 0xDE,
	0x3C, 0x6D, 0x03, 0x53, 0x2D, 0x20, 0x00, 0x01,
	0x00, 0x02, 0xEC, 0x33, 0x2E, 0xFF, 0xFF, 0xF8,
	0x00, 0x01, 0x5C, 0x33, 0x39, 0xE0, 0x00, 0x01,
	0x34, 0x3D, 0x03, 0xCF, 0x2C, 0xFD, 0x03, 0x26,
	0x3C, 0x6D, 0x03, 0x59, 0x34, 0x3D, 0x03, 0xD1,
	0xB8, 0xD8, 0x90, 0x30, 0x00, 0x00, 0x80, 0x30,
	0x30, 0x3D, 0x03, 0xD1, 0x2F, 0x30, 0x00, 0x03,
	0x30, 0x4D, 0x03, 0xE6, 0x00, 0x03, 0xF0, 0x05,
	0x00, 0x03, 0xF0, 0x2C, 0x34, 0x40, 0x0F, 0xCD,
	0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D,
	0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC,
	0x00, 0x03, 0xEB, 0x01, 0x3A, 0xDD, 0x03, 0x6D,
	0xB6, 0xDB, 0xD0, 0x35, 0x00, 0x06, 0x1F, 0x3B,
	0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00,
	0x00, 0x07, 0x6E, 0xFC, 0x2E, 0xEF, 0xFF, 0xFF,
	0x2F, 0x2F, 0xFF, 0xFF, 0xA7, 0x23, 0xED, 0x7A,
	0x34, 0x30, 0x0F, 0xC8, 0x0C, 0xE0, 0xD0, 0x7C,
	0x3C, 0x6D, 0x03, 0x5E, 0xB6, 0xDB, 0xC1, 0x31,
	0x12, 0xDB, 0xF0, 0x2C, 0x3A, 0xDD, 0x03, 0x5F,
	0x30, 0x3D, 0x03, 0xD2, 0x34, 0x40, 0x0F, 0xCD,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3A, 0xDD, 0x03, 0x7D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD, 0x03, 0x63,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x34, 0x30, 0x0D, 0xF3, 0x00, 0x00, 0xD1, 0x03,
	0x3C, 0x1D, 0x03, 0xB5, 0x34, 0x2D, 0x03, 0xD8,
	0x2C, 0x80, 0x07, 0x00, 0x2C, 0xB0, 0x07, 0x00,
	0x3C, 0x6D, 0x03, 0xB5, 0x34, 0x2D, 0x03, 0xD7,
	0x2C, 0x80, 0x00, 0x07, 0x2C, 0xB0, 0x00, 0x02,
	0x3C, 0x5D, 0x03, 0xB5, 0x34, 0x3D, 0x03, 0xF2,
	0x00, 0x00, 0xD0, 0x03, 0x3C, 0x6D, 0x03, 0x94,
	0x38, 0x20, 0x0F, 0x3B, 0x30, 0x20, 0x0D, 0xE9,
	0x00, 0x00, 0xB0, 0x03, 0x30, 0x3D, 0x03, 0xF2,
	0x30, 0x3D, 0x03, 0xDE, 0x34, 0x2D, 0x03, 0xF1,
	0x30, 0x2D, 0x03, 0xDD, 0x34, 0x2D, 0x03, 0xF0,
	0x30, 0x2D, 0x03, 0xDC, 0x00, 0x03, 0xE0, 0x01,
	0x38, 0xB0, 0x0F, 0x3B, 0x3A, 0x80, 0x00, 0x12,
	0x3A, 0xAD, 0x03, 0x9A, 0xB6, 0xDB, 0xE0, 0x41,
	0x00, 0x03, 0xE0, 0xDA, 0x00, 0x03, 0xE0, 0xDA,
	0x38, 0xAD, 0x03, 0xDC, 0x38, 0xCD, 0x00, 0x16,
	0x3A, 0x80, 0x00, 0x03, 0x3A, 0xAD, 0x03, 0xB1,
	0x38, 0xB0, 0x0F, 0x3B, 0x3A, 0xDD, 0x03, 0xA3,
	0x00, 0x03, 0xF8, 0xA4, 0x00, 0x03, 0xCD, 0xA5,
	0x3A, 0xDD, 0x03, 0xA6, 0x00, 0x03, 0xF4, 0xA0,
	0x00, 0x03, 0xCD, 0xA1, 0x3A, 0x80, 0x00, 0x04,
	0x3A, 0xAD, 0x03, 0xB0, 0x38, 0x4F, 0xF0, 0x00,
	0x38, 0x70, 0x00, 0x08, 0x0B, 0xC8, 0x00, 0x00,
	0x0B, 0xC3, 0xC9, 0x45, 0x17, 0x2B, 0xC8, 0x43,
	0x2F, 0x7F, 0xFF, 0xF4, 0xBB, 0x6B, 0xC1, 0x5B,
	0x17, 0x18, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1B,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1D,
	0x00, 0x03, 0xF0, 0x01, 0x00, 0x03, 0xF0, 0x00,
	0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x03, 0xF4,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x91, 0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 0xC0,
	0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00,
};

// ===========================================================================
// 		Dolby	AC-3	SP/DIF-Out
// ===========================================================================

UCHAR ZRN_AC3_SPD[] = {
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0xAC, 0x76, 0x64, 0x0C, 0x00, 0x00, 0x00, 0x93,
	0x0D, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x3A,
	0x80, 0x03, 0xC5, 0x00, 0x00, 0x00, 0x90, 0x00,
	0x0D, 0x03, 0x75, 0x00, 0x00, 0x00, 0x50, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A,
	0xDD, 0x03, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x34, 0x3D, 0x03, 0xED, 0x2E,
	0xCF, 0xFF, 0xFF, 0x3C, 0x3D, 0x03, 0xC1, 0x30,
	0x3D, 0x03, 0xED, 0xB9, 0x20, 0x00, 0x00, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x85, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x4F, 0x87, 0x20, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x89, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x44, 0xE1, 0xF0, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x8D, 0x30,
	0x30, 0x0F, 0xF9, 0x34, 0x4D, 0x03, 0xCC, 0x00,
	0x00, 0xD3, 0x04, 0x34, 0x4D, 0x03, 0xE9, 0x3C,
	0x1D, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x9D, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x40, 0x10, 0x30, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x97, 0x30,
	0x30, 0x0F, 0xF9, 0x38, 0x30, 0x0B, 0xFC, 0x30,
	0x3D, 0x03, 0xED, 0x38, 0x40, 0x02, 0x00, 0x3A,
	0xDD, 0x03, 0xC1, 0x38, 0x3D, 0x03, 0x7D, 0x30,
	0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x34,
	0x30, 0x0F, 0x88, 0x00, 0x5B, 0xD0, 0x35, 0x38,
	0x3D, 0x03, 0xA8, 0x3C, 0x1D, 0x03, 0xA5, 0x34,
	0x4D, 0x03, 0xEA, 0x30, 0x4D, 0x03, 0xED, 0x38,
	0x3D, 0x03, 0xAF, 0x3A, 0xDD, 0x03, 0xC2, 0x30,
	0x30, 0x0F, 0xF9, 0x2F, 0x30, 0x00, 0x08, 0xB6,
	0xDB, 0xE3, 0x81, 0x34, 0xED, 0x03, 0xEC, 0x34,
	0x3D, 0x03, 0xED, 0x14, 0xDB, 0xFC, 0x84, 0x3A,
	0xDD, 0x03, 0xBB, 0x30, 0xED, 0x03, 0xEC, 0x00,
	0x03, 0xF0, 0x0E, 0x00, 0x03, 0xE3, 0x81, 0x34,
	0xED, 0x03, 0xEC, 0x00, 0x03, 0xEB, 0x01, 0xB6,
	0xDB, 0xD0, 0x35, 0x00, 0x07, 0x4C, 0xF4, 0x30,
	0xED, 0x03, 0xEC, 0x2E, 0xF0, 0x00, 0x08, 0x2C,
	0xCF, 0xF0, 0x00, 0x2F, 0x3F, 0xFF, 0xF8, 0x18,
	0xE3, 0xF0, 0x2C, 0x34, 0x3D, 0x03, 0xED, 0x14,
	0xDB, 0xF0, 0x0E, 0x3C, 0x3D, 0x03, 0xC1, 0x30,
	0x3D, 0x03, 0xED, 0x34, 0x3D, 0x03, 0xEB, 0x30,
	0x3D, 0x03, 0xED, 0x38, 0x3D, 0x03, 0x7D, 0x30,
	0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x3A,
	0xDD, 0x03, 0x6D, 0x3B, 0x50, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x38, 0x00, 0x0D, 0x03, 0xF4, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x91,
	0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 0xC0, 0x00,
	0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
	0x00, 0x00,
};

// ===========================================================================
// 		Linear	PCM	Out
// ===========================================================================

UCHAR ZRN_PCM[] = {
	0x91, 0x3A, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x93, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01,
	0x89, 0x0B, 0x67, 0x40, 0x00, 0x00, 0x00, 0x93,
	0x00, 0x0A, 0x00, 0x00, 0x00, 0x02, 0xC7, 0x00,
	0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x07, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00,
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xC8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x01, 0x2C, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x01, 0x90, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x02, 0x58, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x06, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x01, 0xE0, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x02, 0x58, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFC, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x0A, 0x00, 0x00,
	0x00, 0x0A, 0x0B, 0x00, 0x00, 0x0A, 0x16, 0x00,
	0x00, 0x0A, 0x21, 0x00, 0x00, 0x0A, 0x2C, 0x00,
	0x00, 0x0A, 0x37, 0x00, 0x00, 0x0A, 0x42, 0x00,
	0x00, 0x0A, 0x4D, 0x00, 0x00, 0x0A, 0x58, 0x00,
	0x00, 0x0A, 0x6B, 0x00, 0x00, 0x0A, 0x86, 0x00,
	0x00, 0x0A, 0xA9, 0x00, 0x00, 0x0A, 0xD4, 0x00,
	0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x42, 0x00,
	0x00, 0x0B, 0x55, 0x00, 0x00, 0x0B, 0x70, 0x00,
	0x00, 0x0B, 0x93, 0x00, 0x00, 0x0B, 0xBE, 0x00,
	0x00, 0x0B, 0xF1, 0x00, 0x00, 0x0B, 0xF9, 0x00,
	0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00,
	0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00,
	0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x12, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0C, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0C, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xFF, 0xCE, 0x00, 0x0F, 0xFE, 0xAC, 0x00,
	0x0F, 0xFC, 0xBE, 0x00, 0x0F, 0xFC, 0x8C, 0x00,
	0x00, 0x00, 0x8D, 0x00, 0x00, 0x05, 0x46, 0x00,
	0x00, 0x02, 0xC6, 0x00, 0x0F, 0xF9, 0x6F, 0x00,
	0x0F, 0xF7, 0x58, 0x00, 0x00, 0x04, 0xD9, 0x00,
	0x00, 0x10, 0x36, 0x00, 0x00, 0x02, 0x1E, 0x00,
	0x0F, 0xE9, 0x06, 0x00, 0x0F, 0xF0, 0x28, 0x00,
	0x00, 0x19, 0x04, 0x00, 0x00, 0x24, 0x66, 0x00,
	0x0F, 0xEE, 0xD9, 0x00, 0x0F, 0xC1, 0xF5, 0x00,
	0x0F, 0xF8, 0xDD, 0x00, 0x00, 0x59, 0x4E, 0x00,
	0x00, 0x3A, 0x78, 0x00, 0x0F, 0x8E, 0x61, 0x00,
	0x0F, 0x56, 0x9F, 0x00, 0x00, 0x82, 0x76, 0x00,
	0x02, 0x7B, 0x12, 0x00, 0x03, 0x77, 0x86, 0x00,
	0x02, 0x7B, 0x12, 0x00, 0x00, 0x82, 0x76, 0x00,
	0x0F, 0x56, 0x9F, 0x00, 0x0F, 0x8E, 0x61, 0x00,
	0x00, 0x3A, 0x78, 0x00, 0x00, 0x59, 0x4E, 0x00,
	0x0F, 0xF8, 0xDD, 0x00, 0x0F, 0xC1, 0xF5, 0x00,
	0x0F, 0xEE, 0xD9, 0x00, 0x00, 0x24, 0x66, 0x00,
	0x00, 0x19, 0x04, 0x00, 0x0F, 0xF0, 0x28, 0x00,
	0x0F, 0xE9, 0x06, 0x00, 0x00, 0x02, 0x1E, 0x00,
	0x00, 0x10, 0x36, 0x00, 0x00, 0x04, 0xD9, 0x00,
	0x0F, 0xF7, 0x58, 0x00, 0x0F, 0xF9, 0x6F, 0x00,
	0x00, 0x02, 0xC6, 0x00, 0x00, 0x05, 0x46, 0x00,
	0x00, 0x00, 0x8D, 0x00, 0x0F, 0xFC, 0x8C, 0x00,
	0x0F, 0xFC, 0xBE, 0x00, 0x0F, 0xFE, 0xAC, 0x00,
	0x0F, 0xFF, 0xCE, 0x00, 0x03, 0x96, 0x9F, 0x00,
	0x0F, 0x29, 0x5B, 0x00, 0x0A, 0xC0, 0x3F, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x08, 0x2B, 0xE2, 0x00,
	0x08, 0x56, 0xD4, 0x00, 0x08, 0x80, 0xDA, 0x00,
	0x08, 0xA9, 0xFA, 0x00, 0x08, 0xD2, 0x38, 0x00,
	0x08, 0xF9, 0x99, 0x00, 0x09, 0x20, 0x22, 0x00,
	0x09, 0x45, 0xD8, 0x00, 0x09, 0x6A, 0xBF, 0x00,
	0x09, 0x8E, 0xDC, 0x00, 0x09, 0xB2, 0x32, 0x00,
	0x09, 0xD4, 0xC7, 0x00, 0x09, 0xF6, 0x9E, 0x00,
	0x0A, 0x17, 0xBB, 0x00, 0x0A, 0x38, 0x23, 0x00,
	0x0A, 0x57, 0xD8, 0x00, 0x0A, 0x76, 0xE0, 0x00,
	0x0A, 0x95, 0x3E, 0x00, 0x0A, 0xB2, 0xF5, 0x00,
	0x0A, 0xD0, 0x09, 0x00, 0x0A, 0xEC, 0x7E, 0x00,
	0x0B, 0x08, 0x56, 0x00, 0x0B, 0x23, 0x96, 0x00,
	0x0B, 0x3E, 0x40, 0x00, 0x0B, 0x58, 0x59, 0x00,
	0x0B, 0x71, 0xE1, 0x00, 0x0B, 0x8A, 0xDE, 0x00,
	0x0B, 0xA3, 0x52, 0x00, 0x0B, 0xBB, 0x40, 0x00,
	0x0B, 0xD2, 0xAA, 0x00, 0x0B, 0xE9, 0x94, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x0A, 0x37, 0x00, 0x00,
	0x06, 0x0F, 0x30, 0x00, 0x0A, 0x02, 0x50, 0x00,
	0x04, 0x97, 0x80, 0x00, 0x0D, 0x9D, 0x50, 0x00,
	0x00, 0xFA, 0x20, 0x00, 0x0F, 0xEC, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x36, 0x00,
	0x00, 0x07, 0x96, 0x00, 0x0F, 0xFA, 0x4A, 0x00,
	0x00, 0x02, 0x5A, 0x00, 0x00, 0x00, 0x93, 0x0D,
	0x03, 0xEF, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
	0x03, 0xE9, 0x00, 0x00, 0x00, 0x01, 0xB4, 0x90,
	0xB8, 0x0C, 0x12, 0x90, 0xB0, 0x3C, 0x30, 0x20,
	0x05, 0xF7, 0x38, 0x0D, 0x01, 0xD2, 0x32, 0x10,
	0x0F, 0xF0, 0x3B, 0x80, 0x00, 0x00, 0x34, 0x3D,
	0x03, 0xFB, 0x00, 0x03, 0xCD, 0x82, 0x38, 0x8D,
	0x00, 0x00, 0x38, 0x40, 0x03, 0xE9, 0x3A, 0xDD,
	0x03, 0xE1, 0x3A, 0xFD, 0x00, 0x0D, 0x00, 0x03,
	0xEB, 0xC1, 0x38, 0x8D, 0x03, 0xEF, 0x38, 0x40,
	0x00, 0x08, 0x3A, 0xDD, 0x03, 0xE1, 0x3A, 0xFD,
	0x00, 0x12, 0x00, 0x03, 0xEB, 0xC1, 0x38, 0x80,
	0x0A, 0x00, 0x38, 0x40, 0x02, 0xC7, 0x3A, 0xDD,
	0x03, 0xE1, 0x3A, 0xFD, 0x00, 0x17, 0x00, 0x03,
	0xEB, 0xC1, 0x3B, 0x80, 0x00, 0x01, 0x36, 0xDE,
	0x00, 0x42, 0x00, 0x03, 0xC0, 0xB6, 0x30, 0x3D,
	0x03, 0xFB, 0x00, 0x00, 0xD4, 0xFA, 0x3C, 0x1D,
	0x00, 0x2B, 0x00, 0x03, 0xCC, 0x03, 0x00, 0x00,
	0xC4, 0xC3, 0x38, 0x40, 0x05, 0xBA, 0x30, 0x40,
	0x05, 0xB8, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50,
	0x00, 0x00, 0x2E, 0xFF, 0xFF, 0xFC, 0x2E, 0xCF,
	0xFF, 0xF4, 0x30, 0x30, 0x05, 0xE9, 0x30, 0x30,
	0x05, 0xEA, 0x38, 0x3D, 0x00, 0x2F, 0x30, 0x30,
	0x0F, 0xF8, 0x00, 0x03, 0xF0, 0x2C, 0x34, 0x40,
	0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03,
	0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30,
	0x0F, 0xCC, 0x00, 0x03, 0xCE, 0x83, 0x2C, 0xC4,
	0x04, 0x00, 0x3C, 0x1D, 0x00, 0x3A, 0x34, 0x30,
	0x05, 0xB8, 0x2C, 0xF0, 0x05, 0xBF, 0x38, 0x3D,
	0x00, 0x1B, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03,
	0xE2, 0xC1, 0x3C, 0x5D, 0x00, 0x4A, 0x12, 0xDB,
	0xC0, 0xCB, 0x30, 0x30, 0x05, 0xB8, 0x38, 0x3D,
	0x00, 0x56, 0x30, 0x30, 0x0F, 0xF8, 0x30, 0xE0,
	0x05, 0xC0, 0x34, 0x30, 0x05, 0xF2, 0x00, 0x00,
	0xB4, 0xC3, 0x30, 0x30, 0x05, 0xF2, 0x00, 0x03,
	0xEC, 0x1C, 0x00, 0x03, 0xF0, 0x0B, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x2C, 0xF0,
	0x05, 0xBB, 0x3C, 0x6D, 0x00, 0x45, 0x00, 0x03,
	0xEC, 0x1C, 0x00, 0x00, 0xD4, 0xF0, 0x3C, 0x1D,
	0x00, 0x52, 0x00, 0x03, 0xF0, 0x0B, 0x38, 0x3D,
	0x00, 0x1B, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x36, 0xD0,
	0x05, 0xF6, 0x34, 0x30, 0x05, 0xE9, 0x2E, 0xCF,
	0xFF, 0xFE, 0x00, 0x03, 0xC3, 0x84, 0x34, 0x30,
	0x05, 0xEC, 0x04, 0xE0, 0x00, 0x00, 0x3C, 0x6D,
	0x00, 0x72, 0x34, 0x30, 0x05, 0xE9, 0x2E, 0xCF,
	0xFF, 0xFE, 0x38, 0x4D, 0x00, 0x61, 0x30, 0x40,
	0x05, 0xF6, 0x3C, 0x3D, 0x00, 0x66, 0x30, 0x30,
	0x05, 0xE9, 0x34, 0x30, 0x05, 0xEB, 0x38, 0x4D,
	0x00, 0x1B, 0x30, 0x40, 0x0F, 0xF8, 0x14, 0xD8,
	0x00, 0x00, 0x3C, 0x3D, 0x00, 0x6E, 0x30, 0x30,
	0x05, 0xEB, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03,
	0xEC, 0x32, 0x00, 0x03, 0xEE, 0xB2, 0x38, 0x3D,
	0x00, 0x72, 0x30, 0x30, 0x05, 0xF6, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03,
	0xEC, 0x32, 0x00, 0x03, 0xEE, 0xB2, 0x3C, 0x3D,
	0x00, 0x79, 0x30, 0x30, 0x05, 0xE9, 0x34, 0x30,
	0x05, 0xE8, 0x38, 0x4D, 0x00, 0x1B, 0x30, 0x40,
	0x0F, 0xF8, 0x14, 0xD8, 0x00, 0x00, 0x3C, 0x2D,
	0x00, 0x7E, 0x30, 0x30, 0x05, 0xE8, 0x34, 0x40,
	0x0F, 0xCD, 0x00, 0x00, 0xB0, 0x3C, 0x00, 0x03,
	0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
	0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x30, 0x40,
	0x05, 0xFE, 0x30, 0x30, 0x05, 0xFF, 0x00, 0x00,
	0xCB, 0xCB, 0x3B, 0x80, 0x00, 0x01, 0x00, 0x03,
	0xEB, 0x01, 0xB6, 0xD8, 0xD0, 0x7C, 0x3C, 0x6D,
	0x00, 0x8C, 0x12, 0xDB, 0xD0, 0x35, 0x34, 0x40,
	0x0F, 0xC8, 0x30, 0x30, 0x05, 0xF7, 0x00, 0x03,
	0xFF, 0x03, 0x00, 0x03, 0xED, 0x7A, 0x0D, 0x1B,
	0xF0, 0x2C, 0x00, 0x03, 0xC0, 0xF1, 0x34, 0x40,
	0x05, 0xFE, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03,
	0xF0, 0x2D, 0x34, 0x30, 0x05, 0xFF, 0x00, 0x00,
	0xBB, 0xCB, 0x35, 0x00, 0x0C, 0x15, 0x35, 0x10,
	0x05, 0xD4, 0x35, 0x20, 0x05, 0xD6, 0x34, 0x80,
	0x0C, 0x14, 0x38, 0xD0, 0x08, 0xB4, 0x3A, 0xDD,
	0x00, 0xF0, 0x3A, 0xFD, 0x00, 0x9D, 0x00, 0x03,
	0xEB, 0xC1, 0x39, 0x00, 0x00, 0x00, 0x34, 0x40,
	0x05, 0xD2, 0x34, 0x50, 0x0C, 0x1E, 0x34, 0x90,
	0x05, 0xD3, 0x34, 0xB0, 0x07, 0x5D, 0x39, 0x30,
	0x00, 0xB4, 0x3A, 0xDD, 0x01, 0x40, 0x3A, 0xFD,
	0x00, 0xA6, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x50,
	0x0C, 0x1D, 0x34, 0x20, 0x05, 0xC9, 0x00, 0x68,
	0x00, 0x00, 0x3C, 0x1D, 0x00, 0xB3, 0x38, 0x78,
	0x00, 0x00, 0x38, 0x60, 0x00, 0x00, 0x2C, 0xB0,
	0x00, 0x80, 0x3C, 0x1D, 0x00, 0xB3, 0x00, 0x03,
	0xC0, 0x83, 0x2C, 0x80, 0x00, 0x1F, 0x3A, 0xDD,
	0x01, 0x7B, 0x3A, 0xFD, 0x00, 0xB3, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x40, 0x05, 0xD7, 0x34, 0x30,
	0x05, 0xCF, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0x20,
	0x05, 0xD8, 0x3A, 0xDD, 0x01, 0x8F, 0x3A, 0xFD,
	0x00, 0xBA, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x60,
	0x05, 0xD1, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0x70,
	0x05, 0xD7, 0x35, 0x80, 0x0C, 0x1A, 0x39, 0xA0,
	0x00, 0x02, 0x00, 0x70, 0x00, 0x00, 0x3C, 0x4D,
	0x00, 0xC9, 0x38, 0xB0, 0x07, 0x5A, 0x38, 0xC0,
	0x0C, 0xBB, 0x3A, 0xDD, 0x01, 0xAE, 0x3A, 0xFD,
	0x00, 0xC6, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD,
	0x00, 0xD2, 0x00, 0x00, 0x24, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0x85, 0x07, 0xB3,
	0xF4, 0x83, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x00, 0xD1, 0x0B, 0x5B, 0xF4, 0x82, 0x0B, 0x98,
	0x00, 0x00, 0x0B, 0x55, 0x50, 0xD3, 0x0B, 0x90,
	0x00, 0x00, 0x0B, 0x5D, 0x50, 0x92, 0x39, 0x00,
	0x00, 0x00, 0x34, 0x20, 0x05, 0xD0, 0x39, 0x30,
	0x00, 0xB4, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D,
	0x00, 0xE0, 0x34, 0xA0, 0x05, 0xD5, 0x34, 0xB0,
	0x07, 0x5D, 0x38, 0xD0, 0x0C, 0x64, 0x3A, 0xDD,
	0x01, 0x59, 0x3A, 0xFD, 0x00, 0xDD, 0x00, 0x03,
	0xEB, 0xC1, 0x3A, 0xDD, 0x00, 0xE5, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0xE8, 0x3A, 0xAD, 0x00, 0xE4, 0x00, 0x00,
	0x26, 0x10, 0x00, 0x06, 0xA6, 0x10, 0x00, 0x06,
	0xA6, 0x10, 0x34, 0x30, 0x05, 0xCE, 0x00, 0x5B,
	0xD0, 0x13, 0x3C, 0x1D, 0x00, 0xED, 0x34, 0xA0,
	0x05, 0xD5, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x01, 0x69, 0x3A, 0xFD, 0x00, 0xED, 0x00, 0x03,
	0xEB, 0xC1, 0x00, 0x03, 0xF0, 0x2D, 0x39, 0x10,
	0x00, 0x00, 0x39, 0x20, 0x00, 0x00, 0x3A, 0x80,
	0x00, 0x0A, 0x3A, 0xAD, 0x01, 0x1C, 0x34, 0x90,
	0x05, 0xD3, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0x1B, 0x34, 0xC0, 0x07, 0x42, 0x38, 0x70,
	0x00, 0x04, 0x00, 0x03, 0xF8, 0x99, 0x00, 0x07,
	0x59, 0x25, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0x08, 0x00, 0x03, 0xF8, 0x86, 0x00, 0x03,
	0xC6, 0x68, 0x3A, 0xAD, 0x01, 0x07, 0x00, 0x03,
	0xF0, 0x82, 0x0D, 0x13, 0xF0, 0x83, 0x0D, 0x1B,
	0xC0, 0x80, 0x0B, 0x43, 0xC0, 0xC1, 0x0B, 0x4B,
	0xF0, 0xA0, 0x0B, 0x83, 0xF1, 0x64, 0x0B, 0x8B,
	0xD0, 0x20, 0x0B, 0xC3, 0xD0, 0x24, 0x0B, 0xCB,
	0xF0, 0x82, 0x00, 0x04, 0x52, 0x29, 0x00, 0x00,
	0x70, 0x00, 0x00, 0x03, 0xF8, 0x82, 0x00, 0x50,
	0x00, 0x00, 0x3C, 0x1D, 0x01, 0x1B, 0x38, 0x60,
	0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x01, 0x1A, 0x00, 0x03,
	0xB2, 0x0B, 0x00, 0x03, 0xF8, 0x98, 0x00, 0x03,
	0xC6, 0x68, 0x3A, 0xAD, 0x01, 0x18, 0x00, 0x07,
	0xD0, 0xE4, 0x0D, 0x1B, 0xF3, 0x02, 0x17, 0x9B,
	0xF8, 0x98, 0x18, 0xD3, 0xF8, 0x84, 0x00, 0x05,
	0x72, 0x83, 0x00, 0x00, 0x28, 0x20, 0x00, 0x00,
	0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0xC0, 0x07, 0x52, 0x38, 0xB0,
	0x07, 0x4A, 0x38, 0xD0, 0x08, 0xB4, 0x34, 0x90,
	0x05, 0xD3, 0x34, 0x20, 0x0C, 0x16, 0x34, 0x60,
	0x0C, 0x17, 0x34, 0x40, 0x05, 0xC8, 0x13, 0x20,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0x1D, 0x00, 0x03,
	0xC1, 0x28, 0x3A, 0xAD, 0x01, 0x3B, 0xB0, 0x03,
	0xC7, 0x59, 0x00, 0x03, 0xE3, 0x41, 0x00, 0x03,
	0xC0, 0xA8, 0x3A, 0xAD, 0x01, 0x38, 0x00, 0x07,
	0x07, 0x63, 0x00, 0x03, 0xFB, 0x87, 0x2D, 0xC4,
	0x04, 0x00, 0x3C, 0x1D, 0x01, 0x37, 0x05, 0x9B,
	0xF3, 0x04, 0x38, 0x30, 0x00, 0x00, 0x3C, 0x2D,
	0x01, 0x37, 0xB9, 0x23, 0xF9, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x12, 0xDB, 0xD0, 0x07, 0x00, 0x03,
	0xC1, 0x44, 0x19, 0xC4, 0x38, 0xCC, 0x00, 0x03,
	0xC1, 0x05, 0x00, 0x03, 0xF0, 0x0D, 0x00, 0x04,
	0x57, 0x23, 0x00, 0x00, 0x12, 0x28, 0x32, 0x10,
	0x05, 0xD8, 0x00, 0x03, 0xF0, 0x2D, 0x34, 0x20,
	0x05, 0xC8, 0x34, 0x30, 0x0C, 0x16, 0x00, 0x68,
	0x00, 0x00, 0x3C, 0x6D, 0x01, 0x49, 0x39, 0xC0,
	0x00, 0x07, 0x2F, 0x20, 0x00, 0x04, 0x00, 0x50,
	0x00, 0x00, 0x3C, 0x1D, 0x01, 0x49, 0x38, 0x50,
	0x0C, 0x34, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x68,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0xE8, 0x3A, 0xAD,
	0x01, 0x54, 0x12, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0x4C, 0xB0, 0x03, 0xD0, 0x01, 0x00, 0x03,
	0xC0, 0xA8, 0x3A, 0xAD, 0x01, 0x52, 0x00, 0x07,
	0x52, 0xE4, 0x67, 0x03, 0x68, 0x24, 0x67, 0x0F,
	0x52, 0xE4, 0x00, 0x04, 0x56, 0x19, 0x00, 0x00,
	0x70, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xF0, 0x2D, 0x30, 0xB0, 0x07, 0x5D, 0x39, 0x30,
	0x00, 0x00, 0x39, 0xB0, 0x00, 0x63, 0x00, 0x03,
	0xC1, 0xE8, 0x3A, 0xAD, 0x01, 0x65, 0x00, 0x00,
	0x80, 0x18, 0x00, 0x00, 0x90, 0x18, 0x38, 0xD0,
	0x0C, 0x64, 0xB0, 0x03, 0xD0, 0x01, 0x3A, 0x80,
	0x00, 0x33, 0x3A, 0xAD, 0x01, 0x64, 0x00, 0x07,
	0x5B, 0x1B, 0x67, 0x03, 0xF6, 0x83, 0x67, 0x0F,
	0x5B, 0x1B, 0x00, 0x04, 0x54, 0x11, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x60, 0x18, 0x30, 0xB0,
	0x07, 0x5D, 0x38, 0xB0, 0x0C, 0x97, 0x39, 0xBF,
	0xFF, 0xFE, 0x38, 0xC0, 0x07, 0x44, 0x00, 0x07,
	0x57, 0x1D, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x01, 0x77, 0x39, 0xCF, 0xFF, 0xFC, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x01, 0x76, 0x00, 0x07,
	0x07, 0x97, 0x49, 0xCE, 0x18, 0xE7, 0x6A, 0xCA,
	0x84, 0x23, 0x7C, 0xCB, 0xF5, 0x47, 0x00, 0x04,
	0x58, 0x51, 0x00, 0x00, 0x80, 0x20, 0x00, 0x03,
	0xF0, 0x2D, 0x39, 0xB0, 0x00, 0x00, 0x00, 0x03,
	0xC6, 0xDC, 0x38, 0x60, 0x04, 0x00, 0xB4, 0xD8,
	0x00, 0x00, 0x2E, 0xF0, 0x00, 0x03, 0x2E, 0xB0,
	0x00, 0x04, 0x2E, 0x94, 0x44, 0x44, 0xB7, 0xB0,
	0x00, 0x00, 0xB5, 0xB0, 0x00, 0x00, 0x2D, 0x50,
	0x0F, 0xFF, 0x4B, 0xB0, 0x00, 0x00, 0x00, 0x03,
	0xC1, 0x87, 0x2F, 0x80, 0x00, 0xFF, 0x2D, 0x8F,
	0xFF, 0x00, 0xBF, 0xB8, 0x00, 0x00, 0x2F, 0xEF,
	0xFF, 0xFD, 0x38, 0x30, 0x0C, 0x9A, 0xA7, 0xF8,
	0x00, 0x00, 0x00, 0x03, 0xC1, 0xCC, 0x00, 0x03,
	0xF0, 0x2D, 0x2F, 0xAF, 0xFF, 0xF8, 0x00, 0x03,
	0xF9, 0x07, 0x34, 0x50, 0x07, 0x48, 0x18, 0x98,
	0x00, 0x00, 0x18, 0xE8, 0x00, 0x00, 0x30, 0x20,
	0x07, 0x48, 0x38, 0xB0, 0x07, 0x49, 0x00, 0x6B,
	0xD0, 0x01, 0x00, 0x03, 0xC1, 0x28, 0x3A, 0xAD,
	0x01, 0xAA, 0x34, 0x40, 0x07, 0x43, 0x3C, 0x6D,
	0x01, 0xA0, 0x38, 0x33, 0xFD, 0xF4, 0x00, 0x03,
	0xF7, 0x02, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x6D,
	0x01, 0xA0, 0x38, 0x34, 0x02, 0x0C, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x10, 0x02, 0x0C, 0x64, 0xCB,
	0xD0, 0x43, 0x09, 0x23, 0xD0, 0x24, 0x0A, 0xCB,
	0xF4, 0x82, 0x23, 0x0B, 0xF5, 0x43, 0x4E, 0x83,
	0xE0, 0x5C, 0x0B, 0x80, 0x00, 0x00, 0x4E, 0xC3,
	0xC0, 0x02, 0x0B, 0x80, 0x00, 0x00, 0x42, 0x93,
	0xC0, 0x03, 0x42, 0xDB, 0xD0, 0x01, 0x00, 0x6C,
	0x54, 0x93, 0x00, 0x03, 0xF0, 0x2D, 0x34, 0x80,
	0x0C, 0x18, 0x35, 0x00, 0x0C, 0x19, 0x34, 0xD0,
	0x07, 0x5C, 0x3A, 0x80, 0x00, 0x02, 0x3A, 0xAD,
	0x01, 0xCD, 0x39, 0x50, 0x00, 0x18, 0x00, 0x03,
	0xE2, 0x01, 0x00, 0x03, 0xC1, 0xE8, 0x3A, 0xAD,
	0x01, 0xCA, 0x00, 0x07, 0x37, 0x10, 0x00, 0x43,
	0xD0, 0x9D, 0x3C, 0x1D, 0x01, 0xBB, 0x13, 0x23,
	0xD0, 0x45, 0x07, 0xB0, 0x00, 0x00, 0xB9, 0x20,
	0x00, 0x00, 0x3A, 0x80, 0x00, 0x06, 0x3A, 0xAD,
	0x01, 0xBF, 0x00, 0x07, 0x78, 0xAB, 0x64, 0xC7,
	0x78, 0xAB, 0x64, 0xC7, 0x78, 0xAB, 0x00, 0x03,
	0xC0, 0x02, 0x0B, 0x90, 0x90, 0x28, 0x07, 0xB0,
	0x00, 0x00, 0x0B, 0x90, 0x00, 0x00, 0xB0, 0x93,
	0xE0, 0x86, 0x2D, 0x30, 0x03, 0xE8, 0x3C, 0x5D,
	0x01, 0xCA, 0x38, 0xC0, 0x0C, 0xBB, 0x0B, 0x50,
	0x90, 0x28, 0xB4, 0x90, 0x00, 0x00, 0x00, 0x05,
	0x3A, 0x90, 0x00, 0x03, 0xF0, 0x08, 0x00, 0x07,
	0x6A, 0x92, 0x00, 0x05, 0x57, 0x02, 0x00, 0x00,
	0x2A, 0x28, 0x00, 0x03, 0xF0, 0x2D, 0x30, 0xD0,
	0x07, 0x5C, 0x39, 0x50, 0x00, 0x00, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D,
	0x02, 0x34, 0x38, 0x90, 0x0F, 0xE6, 0x2C, 0xB0,
	0x00, 0x02, 0x3C, 0x1D, 0x02, 0x2B, 0x38, 0xA0,
	0x0D, 0x00, 0x2C, 0xB0, 0x00, 0x03, 0x3C, 0x1D,
	0x01, 0xE6, 0x39, 0x60, 0x05, 0x00, 0x38, 0x30,
	0x00, 0x02, 0x3E, 0x00, 0x00, 0x06, 0x00, 0x06,
	0x53, 0x14, 0x34, 0x40, 0x0D, 0x05, 0x00, 0x00,
	0xD1, 0xC4, 0x3C, 0x1D, 0x01, 0xE5, 0x00, 0x00,
	0x00, 0x00, 0xB9, 0x20, 0x00, 0x00, 0x38, 0x40,
	0x0D, 0x06, 0x30, 0x40, 0x0C, 0x1E, 0x30, 0x30,
	0x0F, 0xFA, 0xB4, 0x90, 0xC4, 0x6C, 0x00, 0x00,
	0xC4, 0x2C, 0x38, 0x80, 0x00, 0x00, 0x3A, 0x80,
	0x02, 0x80, 0x3A, 0xAD, 0x01, 0xEE, 0x38, 0xE0,
	0x00, 0x00, 0x00, 0x04, 0x50, 0x82, 0x00, 0x04,
	0x50, 0x82, 0x39, 0x70, 0x00, 0xA0, 0x38, 0xF0,
	0x05, 0x00, 0x30, 0xF0, 0x05, 0xCC, 0x38, 0x00,
	0x04, 0x00, 0x32, 0x10, 0x0C, 0x20, 0x38, 0xA0,
	0x08, 0x00, 0x30, 0xA0, 0x07, 0x5D, 0x38, 0xC0,
	0x05, 0xA0, 0x30, 0xC0, 0x07, 0x5C, 0x38, 0x00,
	0x00, 0x04, 0x32, 0x10, 0x0F, 0xCB, 0x3A, 0xDE,
	0x15, 0xED, 0x3A, 0xFD, 0x01, 0xFD, 0x00, 0x03,
	0xEB, 0xC1, 0x38, 0x0D, 0x00, 0x72, 0x32, 0x10,
	0x05, 0xF6, 0x38, 0x0D, 0x00, 0x1B, 0x32, 0x10,
	0x0F, 0xF8, 0x38, 0x0D, 0x00, 0x82, 0x32, 0x10,
	0x0F, 0xF9, 0x38, 0x20, 0x00, 0x50, 0x30, 0x20,
	0x05, 0xE8, 0x34, 0x00, 0x0D, 0x03, 0x32, 0x10,
	0x0C, 0x17, 0x34, 0x30, 0x0D, 0x00, 0x2C, 0xC0,
	0x00, 0x80, 0x2E, 0xF0, 0x00, 0x08, 0x34, 0x20,
	0x0F, 0xC5, 0x2C, 0x80, 0xC0, 0x00, 0x2E, 0xBF,
	0xFF, 0xFE, 0x18, 0x98, 0xB4, 0x6C, 0x34, 0x20,
	0x0F, 0xC5, 0x2C, 0x80, 0x00, 0x06, 0x2E, 0xB0,
	0x00, 0x09, 0x18, 0x98, 0x00, 0x00, 0x34, 0x20,
	0x0D, 0x00, 0x2C, 0x80, 0x00, 0x40, 0x2E, 0xB0,
	0x00, 0x01, 0x18, 0x98, 0x00, 0x00, 0x34, 0x20,
	0x0D, 0x00, 0x2C, 0x80, 0x00, 0x07, 0x18, 0x98,
	0x00, 0x00, 0x30, 0x30, 0x0C, 0x1B, 0x34, 0x30,
	0x0D, 0x01, 0x2E, 0xF0, 0x00, 0x0C, 0x34, 0x20,
	0x0D, 0x02, 0x2E, 0xB0, 0x00, 0x04, 0x18, 0x9B,
	0xD0, 0x44, 0x30, 0x30, 0x0C, 0x1C, 0x34, 0x20,
	0x0D, 0x04, 0x2E, 0xB0, 0x00, 0x0C, 0x30, 0x20,
	0x0C, 0x1D, 0x3A, 0xDD, 0x03, 0xC9, 0x3A, 0xFD,
	0x02, 0x26, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00,
	0x05, 0xFB, 0x32, 0x10, 0x05, 0xED, 0x3A, 0xDD,
	0x03, 0xC0, 0x30, 0x40, 0x05, 0xF8, 0x30, 0x40,
	0x05, 0xCB, 0x00, 0x00, 0xB0, 0x3C, 0xB4, 0x90,
	0xC4, 0x2C, 0x30, 0x20, 0x07, 0x49, 0x30, 0x20,
	0x07, 0x40, 0x30, 0x20, 0x07, 0x41, 0x34, 0x20,
	0x0C, 0x20, 0x3A, 0xDD, 0x03, 0xC0, 0x2C, 0x90,
	0x00, 0x40, 0x30, 0x20, 0x0C, 0x20, 0x34, 0x30,
	0x05, 0xE8, 0x00, 0x58, 0x00, 0x00, 0x3C, 0x4D,
	0x02, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB4, 0x2C, 0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDE,
	0x19, 0x7E, 0x3A, 0xFD, 0x02, 0x3D, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x00, 0x05, 0xCC, 0x00, 0x03,
	0xC3, 0xC1, 0xB2, 0x00, 0x00, 0x00, 0x3C, 0x3D,
	0x02, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC5, 0xC1, 0xA2, 0x00, 0x00, 0x00, 0x34, 0x10,
	0x05, 0xFD, 0x04, 0x40, 0x00, 0x00, 0x3C, 0x3D,
	0x02, 0x3D, 0x34, 0x20, 0x05, 0xED, 0x14, 0x90,
	0x00, 0x00, 0x3C, 0x3D, 0x02, 0x4E, 0xB2, 0x48,
	0xC0, 0xBC, 0x36, 0x40, 0x05, 0xF9, 0x36, 0x40,
	0x05, 0xFA, 0x34, 0x20, 0x05, 0xFB, 0x30, 0x20,
	0x05, 0xED, 0x34, 0x00, 0x05, 0xF0, 0x36, 0x00,
	0x05, 0xF1, 0xA2, 0x00, 0x00, 0x00, 0x32, 0x10,
	0x05, 0xF0, 0x32, 0x00, 0x05, 0xF1, 0x3A, 0xDD,
	0x02, 0x57, 0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D,
	0x03, 0xF6, 0xB0, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x02, 0x5B, 0x34, 0x30, 0x05, 0xF7, 0x30, 0x00,
	0x05, 0xF7, 0x00, 0x58, 0x00, 0x00, 0x3C, 0x1D,
	0x02, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3B, 0x80, 0x00, 0x00, 0x36, 0x0D,
	0x03, 0xF5, 0x00, 0x00, 0xD0, 0x20, 0x00, 0x00,
	0xB0, 0x20, 0x32, 0x0D, 0x03, 0xF5, 0x3C, 0x6D,
	0x02, 0x71, 0x3B, 0x80, 0x00, 0x01, 0x00, 0x03,
	0xCD, 0xA1, 0x00, 0x00, 0xD1, 0xA0, 0x3C, 0x6D,
	0x02, 0x71, 0x2E, 0x2F, 0xFF, 0xFC, 0xB0, 0x03,
	0xC8, 0x02, 0x2E, 0xAF, 0xFF, 0xFC, 0x30, 0x20,
	0x05, 0xF5, 0x3A, 0xDD, 0x02, 0x70, 0x36, 0x0D,
	0x03, 0xF4, 0x33, 0x60, 0x05, 0xF0, 0x32, 0x00,
	0x05, 0xF1, 0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00,
	0x00, 0x40, 0x3C, 0x1D, 0x02, 0xA3, 0x34, 0x0D,
	0x03, 0xF5, 0x2C, 0x00, 0x00, 0x80, 0x3C, 0x6D,
	0x02, 0xA3, 0x34, 0x40, 0x05, 0xF4, 0x2D, 0x30,
	0x01, 0xC2, 0x3C, 0x2D, 0x02, 0x98, 0x38, 0x20,
	0x00, 0x2C, 0x2D, 0x3F, 0xFB, 0x50, 0x3C, 0x4D,
	0x02, 0x84, 0x38, 0x30, 0x00, 0x2C, 0x34, 0x20,
	0x07, 0x41, 0x14, 0x90, 0x00, 0x00, 0x3C, 0x2D,
	0x02, 0x98, 0x34, 0x30, 0x07, 0x40, 0x14, 0xD8,
	0x00, 0x00, 0x3C, 0x5D, 0x02, 0xA3, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0xB0, 0x82, 0x30, 0x20,
	0x0F, 0xFA, 0x38, 0x2F, 0xFF, 0xFF, 0x30, 0x30,
	0x07, 0x40, 0x34, 0x30, 0x05, 0xCD, 0x3A, 0xDD,
	0x03, 0xC3, 0x3A, 0xFD, 0x02, 0x8D, 0x00, 0x03,
	0xEB, 0xC1, 0x0A, 0x98, 0x80, 0x00, 0x0A, 0x9B,
	0xC0, 0xD8, 0x30, 0x30, 0x05, 0xEB, 0x34, 0x30,
	0x05, 0xF9, 0x0C, 0x98, 0xB0, 0xBC, 0xA7, 0x20,
	0x80, 0x00, 0x30, 0x80, 0x05, 0xEC, 0x39, 0x00,
	0x00, 0x00, 0x3A, 0xDD, 0x02, 0xA2, 0x38, 0x0D,
	0x00, 0x59, 0x32, 0x10, 0x05, 0xF6, 0x30, 0x20,
	0x07, 0x41, 0x34, 0x30, 0x05, 0xF3, 0x2C, 0xE0,
	0x00, 0x01, 0x3C, 0x6D, 0x02, 0xA3, 0x30, 0x30,
	0x05, 0xF3, 0x34, 0x20, 0x05, 0xF9, 0xB5, 0x20,
	0xB0, 0xBC, 0x34, 0x50, 0x05, 0xF2, 0x00, 0x00,
	0xB4, 0x45, 0x30, 0x50, 0x05, 0xF2, 0x30, 0x40,
	0x05, 0xF4, 0x34, 0x30, 0x05, 0xF4, 0x2E, 0xE0,
	0x00, 0x04, 0x2E, 0xFF, 0xFF, 0xFC, 0x3A, 0xDD,
	0x02, 0xA9, 0x3B, 0x60, 0x00, 0x00, 0x30, 0x30,
	0x0C, 0x22, 0x34, 0x20, 0x05, 0xE8, 0x00, 0x50,
	0xC0, 0xFC, 0x3C, 0x4D, 0x02, 0xB8, 0xB4, 0x90,
	0x00, 0x00, 0x38, 0x00, 0x44, 0x00, 0x32, 0x10,
	0x0C, 0x20, 0x38, 0x00, 0x01, 0x00, 0x32, 0x10,
	0x0C, 0x21, 0x34, 0x20, 0x05, 0xF8, 0x00, 0x50,
	0xB0, 0xFC, 0x3C, 0x6D, 0x03, 0xB7, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x03, 0x86, 0x38, 0x20, 0x00, 0x01, 0x30, 0x20,
	0x05, 0xF8, 0x34, 0x20, 0x05, 0xF2, 0x00, 0x00,
	0xD4, 0xC2, 0x3C, 0x1D, 0x03, 0x71, 0x00, 0x00,
	0xC4, 0xC2, 0x30, 0x20, 0x05, 0xF2, 0x34, 0x20,
	0x05, 0xBC, 0x2C, 0x80, 0x0F, 0x80, 0x2C, 0xB0,
	0x0A, 0x00, 0x3C, 0x1D, 0x02, 0xC8, 0x38, 0x30,
	0x00, 0x02, 0x38, 0x00, 0x44, 0x00, 0x32, 0x10,
	0x0C, 0x20, 0x3A, 0xDD, 0x03, 0x86, 0x30, 0x30,
	0x0F, 0xFA, 0x00, 0x00, 0xB0, 0xFC, 0x34, 0x30,
	0x05, 0xBC, 0x2E, 0xFF, 0xFF, 0xF4, 0x34, 0x40,
	0x05, 0xBB, 0x2F, 0x30, 0x00, 0x04, 0x19, 0x18,
	0x00, 0x00, 0x30, 0x30, 0x05, 0xEF, 0x34, 0x30,
	0x05, 0xBB, 0x2E, 0xFF, 0xFF, 0xF0, 0x34, 0x40,
	0x05, 0xBA, 0x19, 0x18, 0x00, 0x00, 0x30, 0x30,
	0x05, 0xEE, 0x38, 0x80, 0x05, 0xBC, 0x38, 0x90,
	0x05, 0xC1, 0x38, 0x6F, 0xFF, 0xF4, 0x38, 0x7F,
	0xFF, 0xFC, 0x00, 0x03, 0xF0, 0x82, 0x0D, 0xD3,
	0xDD, 0x85, 0x2C, 0x80, 0x00, 0xFF, 0x00, 0x05,
	0x42, 0x83, 0x0D, 0x9F, 0x40, 0x84, 0x2E, 0xB0,
	0x00, 0x04, 0x2C, 0x80, 0xFF, 0x00, 0x0D, 0xA3,
	0xE0, 0xCA, 0x18, 0xA3, 0xF1, 0x03, 0x0D, 0x5D,
	0x53, 0x02, 0x2C, 0xC0, 0x00, 0x03, 0x0D, 0xD3,
	0xE0, 0xCA, 0x2C, 0x80, 0x00, 0x1F, 0x00, 0x05,
	0x42, 0x83, 0x2E, 0xFF, 0xFF, 0xEE, 0x00, 0x05,
	0x42, 0xC2, 0x2E, 0xBF, 0xFF, 0xF0, 0x2C, 0x80,
	0x00, 0x03, 0x00, 0x05, 0x42, 0x83, 0x0D, 0x9B,
	0xF1, 0x02, 0x2C, 0xC0, 0x00, 0x07, 0x0D, 0xD3,
	0xE0, 0xCA, 0x2C, 0x80, 0x00, 0xFF, 0x00, 0x03,
	0xE0, 0x8A, 0x38, 0x80, 0x05, 0xCE, 0x38, 0x90,
	0x0C, 0x1B, 0x34, 0x30, 0x05, 0xC4, 0x00, 0x03,
	0xF3, 0x02, 0x2E, 0xBF, 0xFF, 0xF2, 0x00, 0x03,
	0xC0, 0x86, 0x16, 0xD0, 0x00, 0x00, 0x2C, 0x80,
	0x00, 0x02, 0x18, 0xF3, 0xE0, 0x82, 0x2D, 0x80,
	0x00, 0x01, 0xBD, 0xB6, 0x12, 0x86, 0x2C, 0x80,
	0x30, 0x00, 0x3C, 0x6D, 0x02, 0xFF, 0x38, 0x30,
	0x00, 0x00, 0x34, 0x70, 0x05, 0xC7, 0x00, 0x03,
	0xC1, 0xC3, 0x34, 0x00, 0x05, 0xC6, 0x00, 0x45,
	0x50, 0xCF, 0x3C, 0x1D, 0x03, 0x11, 0x2D, 0xC0,
	0x0C, 0x80, 0x2D, 0xF0, 0x08, 0x80, 0x3C, 0x1D,
	0x03, 0x11, 0x38, 0x60, 0x00, 0x04, 0x2D, 0xF0,
	0x04, 0x80, 0x3C, 0x1D, 0x03, 0x11, 0x38, 0x60,
	0x00, 0x02, 0x2D, 0xF0, 0x08, 0x00, 0x3C, 0x1D,
	0x03, 0x11, 0x38, 0x6F, 0xFF, 0xFC, 0x2D, 0xF0,
	0x04, 0x00, 0x3C, 0x1D, 0x03, 0x11, 0x38, 0x6F,
	0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x38, 0x60,
	0x00, 0x00, 0x00, 0x07, 0x82, 0x8F, 0x30, 0x20,
	0x07, 0x43, 0x2D, 0xC0, 0x00, 0x0F, 0x00, 0x04,
	0x51, 0x87, 0x38, 0x20, 0x06, 0x00, 0x34, 0x50,
	0x0C, 0x16, 0x34, 0x60, 0x05, 0xC8, 0x13, 0xB3,
	0xD0, 0x07, 0x00, 0xC3, 0xC1, 0xA7, 0xAB, 0xF8,
	0x00, 0x00, 0x00, 0x5B, 0xDF, 0xC6, 0x3C, 0x6D,
	0x03, 0x20, 0x00, 0x04, 0x50, 0x87, 0x38, 0x20,
	0x07, 0x80, 0x2F, 0x60, 0x00, 0x01, 0x0B, 0xAC,
	0x50, 0x85, 0x00, 0x03, 0xE1, 0x44, 0x3A, 0xDD,
	0x03, 0xC9, 0x3A, 0xFD, 0x03, 0x25, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x20, 0x05, 0xBE, 0x2C, 0x80,
	0x0F, 0xF0, 0x2E, 0xB0, 0x00, 0x04, 0x34, 0x30,
	0x05, 0xBF, 0x2C, 0xCF, 0xF0, 0x00, 0x2E, 0xFF,
	0xFF, 0xF4, 0x18, 0x98, 0x00, 0x00, 0x30, 0x30,
	0x0C, 0x23, 0x34, 0x00, 0x05, 0xEE, 0x36, 0x00,
	0x05, 0xEF, 0x2C, 0x00, 0xFF, 0xFF, 0x2E, 0x20,
	0x00, 0x07, 0x00, 0x03, 0xC8, 0x83, 0x2E, 0x20,
	0x00, 0x01, 0x00, 0x03, 0xC0, 0xE2, 0x2E, 0x2F,
	0xFF, 0xFC, 0x2E, 0x3F, 0xFF, 0xFF, 0x2E, 0x2F,
	0xFF, 0xFA, 0x34, 0x10, 0x05, 0xF0, 0x36, 0x40,
	0x05, 0xF1, 0xB2, 0x03, 0xD1, 0x42, 0x34, 0x10,
	0x05, 0xF5, 0x2E, 0x6F, 0xFF, 0xEC, 0xB2, 0x03,
	0xD1, 0x42, 0x38, 0x38, 0x00, 0x00, 0x3C, 0x5D,
	0x03, 0x43, 0x0A, 0x83, 0xC8, 0x02, 0x2C, 0x2F,
	0xFF, 0xFF, 0x2C, 0x2F, 0xFF, 0xFF, 0x38, 0x37,
	0xFF, 0xFF, 0x3C, 0x1D, 0x03, 0x47, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0xC2, 0x30, 0x20, 0x05, 0xF4, 0x34, 0x40,
	0x05, 0xC3, 0x2F, 0x0F, 0xFF, 0xFC, 0x00, 0x03,
	0xC5, 0x90, 0x00, 0x03, 0xC1, 0x18, 0x34, 0x80,
	0x05, 0xC0, 0x34, 0x60, 0x05, 0xFC, 0xB4, 0x90,
	0x80, 0x00, 0x14, 0x93, 0xC2, 0x05, 0x3A, 0xDD,
	0x03, 0xC3, 0x3A, 0xFD, 0x03, 0x53, 0x00, 0x03,
	0xEB, 0xC1, 0x00, 0x03, 0xC6, 0x03, 0x0C, 0x98,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0xD8, 0x00, 0x03,
	0xC2, 0x02, 0x04, 0xA8, 0x00, 0x00, 0x3C, 0x1D,
	0x03, 0x71, 0x00, 0x00, 0x80, 0x00, 0x15, 0xB0,
	0x00, 0x00, 0x3C, 0x3D, 0x03, 0x56, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x70, 0x00, 0x01, 0x30, 0x70,
	0x05, 0xF8, 0x35, 0x80, 0x05, 0xCD, 0x00, 0x03,
	0xC5, 0x90, 0x00, 0x03, 0xC1, 0x48, 0x34, 0x30,
	0x05, 0xCD, 0x00, 0x00, 0x90, 0x00, 0x30, 0x80,
	0x05, 0xCB, 0x34, 0x20, 0x05, 0xEA, 0xB4, 0xDB,
	0xD0, 0x10, 0x34, 0x20, 0x05, 0xC3, 0x2E, 0x8F,
	0xFF, 0xFC, 0xA4, 0xD8, 0xC4, 0x6C, 0x34, 0x20,
	0x05, 0xE9, 0xA4, 0xD8, 0x00, 0x00, 0x2E, 0xEF,
	0xFF, 0xFF, 0x30, 0x30, 0x05, 0xE8, 0x3A, 0xDD,
	0x03, 0xB7, 0x00, 0x00, 0xC0, 0x3C, 0x00, 0x00,
	0xB4, 0x6C, 0x39, 0x00, 0x00, 0x00, 0x34, 0x20,
	0x05, 0xF2, 0x00, 0x00, 0xD4, 0x42, 0x3C, 0x6D,
	0x03, 0x86, 0x00, 0x00, 0xC4, 0x42, 0x30, 0x20,
	0x05, 0xF2, 0x3A, 0xDD, 0x03, 0xC3, 0x3A, 0xFD,
	0x03, 0x7A, 0x00, 0x03, 0xEB, 0xC1, 0x30, 0x80,
	0x05, 0xCB, 0x34, 0x30, 0x05, 0xCD, 0x2E, 0xEF,
	0xFF, 0xFF, 0x00, 0x00, 0xC4, 0x6C, 0x34, 0x20,
	0x05, 0xE8, 0xA6, 0x93, 0xD0, 0x10, 0x30, 0x20,
	0x05, 0xE8, 0x00, 0x00, 0xC0, 0x3C, 0xB4, 0x90,
	0xB4, 0x6C, 0x30, 0x20, 0x0C, 0x21, 0x38, 0x00,
	0x04, 0x00, 0x32, 0x10, 0x0C, 0x20, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x53, 0xD0, 0x02, 0x3C, 0x1D,
	0x03, 0x8D, 0x34, 0x30, 0x0C, 0x1B, 0x34, 0x00,
	0x0F, 0xFC, 0x3A, 0xDD, 0x03, 0xB7, 0x30, 0x20,
	0x07, 0x49, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D,
	0x03, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC3, 0x83, 0x00, 0x00, 0xB3, 0x83, 0x30, 0x30,
	0x0C, 0x1B, 0x38, 0x8D, 0x03, 0xF3, 0x38, 0x9D,
	0x03, 0xFA, 0x34, 0x00, 0x05, 0xCB, 0x32, 0x10,
	0x0C, 0x14, 0x34, 0x00, 0x05, 0xCC, 0x32, 0x10,
	0x0C, 0x18, 0x00, 0x03, 0xF1, 0x02, 0x00, 0x00,
	0xD0, 0x02, 0x3C, 0x6D, 0x03, 0xB4, 0x00, 0x00,
	0xB0, 0x02, 0x00, 0x03, 0xE0, 0x85, 0x00, 0x06,
	0xA0, 0x8A, 0x00, 0x06, 0xA0, 0x8A, 0x00, 0x06,
	0xA0, 0x8A, 0x00, 0x06, 0x00, 0x8A, 0x38, 0x70,
	0x00, 0x08, 0x38, 0x6F, 0xF0, 0x00, 0x3A, 0x80,
	0x00, 0x04, 0x3A, 0xAD, 0x03, 0xB3, 0x38, 0x80,
	0x0D, 0x06, 0x3A, 0xDD, 0x03, 0xAA, 0x00, 0x03,
	0xF2, 0xA0, 0x00, 0x03, 0xCD, 0xA1, 0x3A, 0x80,
	0x00, 0x02, 0x3A, 0xAD, 0x03, 0xB2, 0x0B, 0xC0,
	0x00, 0x00, 0x0B, 0xC3, 0xC8, 0x42, 0x17, 0x93,
	0xC8, 0x43, 0x06, 0x90, 0x00, 0x00, 0x17, 0x9B,
	0xE0, 0x82, 0x06, 0xD8, 0x00, 0x00, 0x0B, 0xC3,
	0xE0, 0xC2, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDD,
	0x00, 0x95, 0x3A, 0xFD, 0x03, 0xB7, 0x00, 0x03,
	0xEB, 0xC1, 0x34, 0x80, 0x05, 0xCC, 0x35, 0x80,
	0x05, 0xFD, 0x00, 0x03, 0xC5, 0xD0, 0x34, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0xC0, 0x82, 0x30, 0x20,
	0x0F, 0xFA, 0x00, 0x00, 0x80, 0x00, 0x30, 0x80,
	0x05, 0xCC, 0x39, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xF0, 0x2D, 0x38, 0x00, 0x0C, 0x1F, 0x32, 0x10,
	0x0F, 0xFB, 0x35, 0x80, 0x05, 0xCD, 0x00, 0x03,
	0xC5, 0x90, 0x34, 0x80, 0x05, 0xCB, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x34, 0x30, 0x05, 0xC6, 0x38, 0x20,
	0x0C, 0x06, 0xA6, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0x88, 0x34, 0x30, 0x05, 0xC8, 0x00, 0x03,
	0xF1, 0x02, 0xA6, 0x90, 0x00, 0x00, 0x00, 0x03,
	0xC0, 0x88, 0x34, 0x30, 0x05, 0xC7, 0x00, 0x03,
	0xF1, 0x02, 0x12, 0x93, 0xC0, 0x88, 0x30, 0x20,
	0x07, 0x42, 0x00, 0x03, 0xF1, 0x02, 0x30, 0x20,
	0x05, 0xCD, 0x2C, 0xF0, 0x00, 0x01, 0x3C, 0x6D,
	0x03, 0xDC, 0x38, 0x90, 0x05, 0xF9, 0x38, 0x80,
	0x0C, 0x09, 0x38, 0x80, 0x0C, 0x0E, 0x3E, 0x00,
	0x00, 0x03, 0x00, 0x06, 0x50, 0xCB, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x06, 0x50, 0xCB, 0x00, 0x06,
	0x50, 0xCB, 0x00, 0x03, 0xC1, 0x28, 0x3A, 0xAD,
	0x03, 0xE5, 0x00, 0x03, 0xF0, 0x85, 0x1B, 0x5B,
	0xCD, 0x86, 0x1B, 0x93, 0xF0, 0x85, 0x00, 0x03,
	0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x60,
	0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x00,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\audiodac.h ===
/******************************************************************************\
*                                                                             *
*      AUDIODAC.H    -     include file for Audio DAC control interface.      *
*                                                                             *
*      Copyright (c) C-Cube Microsystems 1996                                 *
*      All Rights Reserved.                                                   *
*                                                                             *
*      Use of C-Cube Microsystems code is governed by terms and conditions    *
*      stated in the accompanying licensing statement.                        *
*                                                                             *
\******************************************************************************/

#ifndef _AUDIODAC_H_
#define _AUDIODAC_H_

typedef enum _ADAC_SAMPLING_FREQ
{
  ADAC_SAMPLING_FREQ_44,
  ADAC_SAMPLING_FREQ_48,
  ADAC_SAMPLING_FREQ_96
} ADAC_SAMPLING_FREQ;

typedef enum _ADAC_INPUT_RESOLUTION
{
  ADAC_INPUT_RESOLUTION_16,
  ADAC_INPUT_RESOLUTION_20,
  ADAC_INPUT_RESOLUTION_24
} ADAC_INPUT_RESOLUTION;

void ADAC_Init( DWORD dwBaseAddress );
void ADAC_SetSamplingFrequency( ADAC_SAMPLING_FREQ SamplingFrequency );
void ADAC_SetInputResolution( ADAC_INPUT_RESOLUTION InputResolution );
void ADAC_Mute( BOOL Mute );

#endif  // _AUDIODAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\anlgprop.c ===
/******************************************************************************
*
*	$RCSfile: AnlgProp.c $
*	$Source: u:/si/VXP/Wdm/Encore/AnlgProp.c $
*	$Author: Max $
*	$Date: 1998/08/28 00:53:07 $
*	$Revision: 1.3 $
*
*	Written by:		Max Paklin
*	Purpose:		Implementation of analog stream for WDM driver
*
*******************************************************************************
*
*	Copyright  1996-98, AuraVision Corporation. All rights reserved.
*
*	AuraVision Corporation makes no warranty of any kind, express or implied,
*	with regard to this software. In no event shall AuraVision Corporation
*	be liable for incidental or consequential damages in connection with or
*	arising from the furnishing, performance, or use of this software.
*
*******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "adapter.h"
#include "zivawdm.h"
#include "monovxd.h"
#ifdef ENCORE
#include "avwinwdm.h"
#include "anlgstrm.h"
#include "AvInt.h"
#include "MVStub.h"


const GUID AVKSPROPSETID_Align	= { STATIC_AVKSPROPSETID_Align };
const GUID AVKSPROPSETID_Key	= { STATIC_AVKSPROPSETID_Key };
const GUID AVKSPROPSETID_Dove	= { STATIC_AVKSPROPSETID_Dove };
const GUID AVKSPROPSETID_Misc	= { STATIC_AVKSPROPSETID_Misc };

extern void STREAMAPI RunAutoSetup( PHW_STREAM_REQUEST_BLOCK pSrb );


VOID AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	ULONG uId = pSPD->Property->Id;
	UINT uIndex = (UINT)(-1), uSize;
	PUINT pValue;
	BOOL bDove = FALSE;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterGetProperty()\n" ));
	pSrb->Status = STATUS_NOT_IMPLEMENTED;

	if( IsEqualGUID( &AVKSPROPSETID_Align, &pSPD->Property->Set ) )
	{
		pValue = (PULONG)pSPD->PropertyInfo;
		uSize = sizeof( ULONG );
		ASSERT( pSPD->PropertyInputSize >= uSize );

		switch( uId )
		{
		case AVKSPROPERTY_ALIGN_XPOSITION:
			uIndex = AVXPOSITION;
			break;
		case AVKSPROPERTY_ALIGN_YPOSITION:
			uIndex = AVYPOSITION;
			break;
		case AVKSPROPERTY_ALIGN_INPUTDELAY:
			uIndex = AVINALIGN;
			break;
		case AVKSPROPERTY_ALIGN_WIDTHRATIO:
			uIndex = WIDTH_RATIO;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_ALIGN_CLOCKDELAY:
			uIndex = CLOCK_DELAY;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_ALIGN_CROPLEFT:
			uIndex = AVCROPLEFTOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPTOP:
			uIndex = AVCROPTOPOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPRIGHT:
			uIndex = AVCROPRIGHTOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPBOTTOM:
			uIndex = AVCROPBOTTOMOFFSET;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Key, &pSPD->Property->Set ) )
	{
		switch( uId )
		{
		case AVKSPROPERTY_KEY_MODE:
			if( pSPD->PropertyInputSize < sizeof( ULONG ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				UINT uMode = AV_GetKeyMode();
				if( uMode == KEY_NONE )
				{
					AV_SetKeyMode( KEY_COLOR, FALSE );
					uMode = AV_GetKeyMode();
				}
				*((PULONG)pSPD->PropertyInfo) = uMode;
				pSrb->Status = STATUS_SUCCESS;
				pSrb->ActualBytesTransferred = sizeof( ULONG );
			}
			break;
		case AVKSPROPERTY_KEY_KEYCOLORS:
			if( pSPD->PropertyOutputSize < sizeof( AVKSPROPERTY_KEYCOLORS_S ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				UINT uMode = AV_GetKeyMode();
				PAVKSPROPERTY_KEYCOLORS_S pColors = (PAVKSPROPERTY_KEYCOLORS_S)pSPD->PropertyInfo;
				switch( uMode )
				{
				case AVKSPROPERTY_KEYMODE_COLOR:
					pColors->lohiRed.lLow	= DOVE_GetParam( DOVEREDLOW );
					pColors->lohiRed.lHigh	= DOVE_GetParam( DOVEREDHIGH );
					pColors->lohiGreen.lLow	= DOVE_GetParam( DOVEGREENLOW );
					pColors->lohiGreen.lHigh= DOVE_GetParam( DOVEGREENHIGH );
					pColors->lohiBlue.lLow	= DOVE_GetParam( DOVEBLUELOW );
					pColors->lohiBlue.lHigh	= DOVE_GetParam( DOVEBLUEHIGH );
				case AVKSPROPERTY_KEYMODE_CHROMA:
					if( uMode == AVKSPROPERTY_KEYMODE_CHROMA )
					{
						pColors->lohiRed.lLow	= AV_GetParameter( AVREDLOW );
						pColors->lohiRed.lHigh	= AV_GetParameter( AVREDHIGH );
						pColors->lohiGreen.lLow	= AV_GetParameter( AVGREENLOW );
						pColors->lohiGreen.lHigh= AV_GetParameter( AVGREENHIGH );
						pColors->lohiBlue.lLow	= AV_GetParameter( AVBLUELOW );
						pColors->lohiBlue.lHigh	= AV_GetParameter( AVBLUEHIGH );
					}
					pColors->lohiRed.lDefault =
					pColors->lohiGreen.lDefault = pColors->lohiBlue.lDefault = 0;
					pColors->lohiRed.lMin = pColors->lohiGreen.lMin = pColors->lohiBlue.lMin = 0;
					pColors->lohiRed.lMax = pColors->lohiGreen.lMax = pColors->lohiBlue.lMax = 255;
					pSrb->ActualBytesTransferred = sizeof( *pColors );
					pSrb->Status = STATUS_SUCCESS;
					break;
				default:
					pSrb->Status = STATUS_NOT_IMPLEMENTED;
					break;
				}
			}
			break;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Dove, &pSPD->Property->Set ) )
	{
		pValue = (PULONG)pSPD->PropertyInfo;
		uSize = sizeof( ULONG );
		ASSERT( pSPD->PropertyInputSize >= uSize );

		switch( uId )
		{
		case AVKSPROPERTY_DOVE_VERSION:
			*pValue = TRUE;			// Creative board only uses Anp82
			pSrb->Status = STATUS_SUCCESS;
			pSrb->ActualBytesTransferred = sizeof( ULONG );
			break;
		case AVKSPROPERTY_DOVE_DAC:
			if( pSPD->PropertyOutputSize < sizeof( AVKSPROPERTY_DOVEDAC_S ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				PAVKSPROPERTY_DOVEDAC_S pDac = (PAVKSPROPERTY_DOVEDAC_S)pSPD->PropertyInfo;
				pDac->valRed.lValue			= DOVE_GetParam( DACRED );
				pDac->valGreen.lValue		= DOVE_GetParam( DACGREEN );
				pDac->valBlue.lValue		= DOVE_GetParam( DACBLUE );
				pDac->valCommonGain.lValue	= DOVE_GetParam( COMMONGAIN );
				pDac->valRed.lMin		= pDac->valRed.lDefault			=
				pDac->valGreen.lMin		= pDac->valGreen.lDefault		=
				pDac->valBlue.lMin		= pDac->valBlue.lDefault		=
				pDac->valCommonGain.lMin= pDac->valCommonGain.lDefault	= 0;
				pDac->valRed.lMax = pDac->valGreen.lMax = pDac->valBlue.lMax = 15;
				pDac->valCommonGain.lMax = 63;
				pSrb->Status = STATUS_SUCCESS;
				pSrb->ActualBytesTransferred = sizeof( *pDac );
			}
			break;
		case AVKSPROPERTY_DOVE_ALPHAMIXING:
			uIndex = ALPHA;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_DOVE_FADINGTIME:
			uIndex = AVFADING;
			bDove = TRUE;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Misc, &pSPD->Property->Set ) )
	{
		pValue = (PULONG)pSPD->PropertyInfo;
		uSize = sizeof( ULONG );
		ASSERT( pSPD->PropertyInputSize >= sizeof( ULONG ) );

		switch( uId )
		{
		case AVKSPROPERTY_MISC_SKEWRISE:
			uIndex = AVSKEWRISE;
			break;
		case AVKSPROPERTY_MISC_FILTER:
			*pValue = AV_SetTScaleMode( -1 );
			pSrb->Status = STATUS_SUCCESS;
			pSrb->ActualBytesTransferred = sizeof( *pValue );
			break;
		case AVKSPROPERTY_MISC_NEGATIVE:
			uIndex = AVNEGATIVE;
			break;
		}
	}
	else if( IsEqualGUID( &PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set ) )
	{
		PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S)pSPD->PropertyInfo;
		if( pSPD->PropertyInputSize == sizeof( ULONG ) )
		{
			pValue = (PULONG)pSPD->PropertyInfo;
			uSize = sizeof( ULONG );
		}
		else
		{
			pValue = &pS->Value;
			uSize = sizeof( KSPROPERTY_VIDEOPROCAMP_S );
			ASSERT( pSPD->PropertyInputSize >= uSize );
		}

		switch( uId )
		{
		case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			uIndex = AVBRIGHTNESS;
			break;
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			uIndex = AVCONTRAST;
			break;
		case KSPROPERTY_VIDEOPROCAMP_SATURATION:
			uIndex = AVSATURATION;
			break;
		case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:
			uIndex = AVSHARP;
			break;
		case KSPROPERTY_VIDEOPROCAMP_GAMMA:
			uIndex = AVGAMMA;
			break;
		case KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION:
			uIndex = AVSOLARIZATION;
			break;
		}

		if( uIndex != (UINT)(-1) && uSize == sizeof( KSPROPERTY_VIDEOPROCAMP_S ) )
		{
			pS->Property.Set	= pSPD->Property->Set;
			pS->Property.Id		= uId;
			pS->Property.Flags	= KSPROPERTY_TYPE_GET;
			pS->Flags			= KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
			pS->Capabilities	= KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
		}
	}
	else if( IsEqualGUID( &KSPROPSETID_Pin, &pSPD->Property->Set ) )
	{
		if( uId == KSPROPERTY_PIN_CINSTANCES )
		{
			PKSP_PIN pPin = (PKSP_PIN)pSPD->PropertyInfo;
			PKSPIN_CINSTANCES pksPinInstances = (PKSPIN_CINSTANCES)(pSPD->PropertyInfo);
			ASSERT( pSPD->PropertyInputSize >= sizeof( *pPin ) );
			if( pSPD->PropertyOutputSize < sizeof( *pksPinInstances ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				pksPinInstances->PossibleCount	= 1;
				pksPinInstances->CurrentCount	= 0;
				pSrb->ActualBytesTransferred = sizeof( *pksPinInstances );
				pSrb->Status = STATUS_SUCCESS;
			}
		}
	}

	if( uIndex != (UINT)(-1) )
	{
#ifndef DEBUG
		if( pSPD->PropertyInputSize < uSize )
			pSrb->Status = STATUS_BUFFER_TOO_SMALL;
		else
#endif
		{
			*pValue = bDove ? DOVE_GetParam( (WORD)uIndex ) : AV_GetParameter( uIndex );
			pSrb->Status = STATUS_SUCCESS;
			pSrb->ActualBytesTransferred = uSize;
		}
	}
	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterGetProperty()\n" ));
}


VOID AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
	ULONG uId = pSPD->Property->Id;
	UINT uIndex = (UINT)(-1), uValue;
	BOOL bDove = FALSE;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin AdapterSetProperty()\n" ));
	pSrb->Status = STATUS_NOT_IMPLEMENTED;

	if( IsEqualGUID( &AVKSPROPSETID_Align, &pSPD->Property->Set ) )
	{
		ASSERT( pSPD->PropertyOutputSize >= sizeof( ULONG ) );
		uValue = *((PULONG)pSPD->PropertyInfo);

		switch( uId )
		{
		case AVKSPROPERTY_ALIGN_XPOSITION:
			uIndex = AVXPOSITION;
			break;
		case AVKSPROPERTY_ALIGN_YPOSITION:
			uIndex = AVYPOSITION;
			break;
		case AVKSPROPERTY_ALIGN_INPUTDELAY:
			uIndex = AVINALIGN;
			break;
		case AVKSPROPERTY_ALIGN_WIDTHRATIO:
			uIndex = WIDTH_RATIO;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_ALIGN_CLOCKDELAY:
			uIndex = CLOCK_DELAY;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_ALIGN_CROPLEFT:
			uIndex = AVCROPLEFTOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPTOP:
			uIndex = AVCROPTOPOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPRIGHT:
			uIndex = AVCROPRIGHTOFFSET;
			break;
		case AVKSPROPERTY_ALIGN_CROPBOTTOM:
			uIndex = AVCROPBOTTOMOFFSET;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Key, &pSPD->Property->Set ) )
	{
		switch( uId )
		{
		case AVKSPROPERTY_KEY_MODE:
			if( pSPD->PropertyOutputSize < sizeof( ULONG ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				AV_SetKeyMode( *((PULONG)pSPD->PropertyInfo), TRUE );
				pSrb->Status = STATUS_SUCCESS;
			}
			break;
		case AVKSPROPERTY_KEY_KEYCOLORS:
			if( pSPD->PropertyOutputSize < sizeof( AVKSPROPERTY_KEYCOLORS_S ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				PAVKSPROPERTY_KEYCOLORS_S pColors = (PAVKSPROPERTY_KEYCOLORS_S)pSPD->PropertyInfo;
				switch( AV_GetKeyMode() )
				{
				case AVKSPROPERTY_KEYMODE_COLOR:
					DoveSetColorRange( (WORD)pColors->lohiRed.lHigh, (WORD)pColors->lohiRed.lLow,
										(WORD)pColors->lohiGreen.lHigh, (WORD)pColors->lohiGreen.lLow,
										(WORD)pColors->lohiBlue.lHigh, (WORD)pColors->lohiBlue.lLow );
					pSrb->Status = STATUS_SUCCESS;
					break;
				case AVKSPROPERTY_KEYMODE_CHROMA:
					AV_SetChromaRange( pColors->lohiRed.lLow, pColors->lohiRed.lHigh,
										pColors->lohiGreen.lLow, pColors->lohiGreen.lHigh,
										pColors->lohiBlue.lLow, pColors->lohiBlue.lHigh );
					pSrb->Status = STATUS_SUCCESS;
					break;
				default:
					pSrb->Status = STATUS_NOT_IMPLEMENTED;
					break;
				}
			}
			break;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Dove, &pSPD->Property->Set ) )
	{
		ASSERT( pSPD->PropertyOutputSize >= sizeof( ULONG ) );
		uValue = *((PULONG)pSPD->PropertyInfo);

		switch( uId )
		{
		case AVKSPROPERTY_DOVE_DAC:
			if( pSPD->PropertyOutputSize < sizeof( AVKSPROPERTY_DOVEDAC_S ) )
				pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			else
			{
				PAVKSPROPERTY_DOVEDAC_S pDac = (PAVKSPROPERTY_DOVEDAC_S)pSPD->PropertyInfo;
				DoveSetDAC( (WORD)pDac->valRed.lValue, (WORD)pDac->valGreen.lValue,
							(WORD)pDac->valBlue.lValue, (WORD)pDac->valCommonGain.lValue );
				pSrb->Status = STATUS_SUCCESS;
			}
			break;
		case AVKSPROPERTY_DOVE_ALPHAMIXING:
			DoveSetAlphaMix( (WORD)uValue );
			pSrb->Status = STATUS_SUCCESS;
			break;
		case AVKSPROPERTY_DOVE_FADINGTIME:
			uIndex = AVFADING;
			bDove = TRUE;
			break;
		case AVKSPROPERTY_DOVE_FADEIN:
			DoveFadeIn( DOVE_GetParam( AVFADING ) );
			pSrb->Status = STATUS_SUCCESS;
			break;
		case AVKSPROPERTY_DOVE_FADEOUT:
			DoveFadeOut( DOVE_GetParam( AVFADING ) );
			pSrb->Status = STATUS_SUCCESS;
			break;
		case AVKSPROPERTY_DOVE_AUTO:
			switch( uValue )
			{
			case AVKSPROPERTY_DOVEAUTO_REFERENCE1:
				pSrb->Status = STATUS_PENDING;
				pHwDevExt->nVGAMode = AP_NEWVGAAFTERFIRSTSTEP;
				break;
			case AVKSPROPERTY_DOVEAUTO_REFERENCE2:
				pSrb->Status = STATUS_PENDING;
				pHwDevExt->nVGAMode = AP_NEWVGAAFTERSECONDSTEP;
				break;
			case AVKSPROPERTY_DOVEAUTO_ALIGN:
				pSrb->Status = STATUS_PENDING;
				pHwDevExt->nVGAMode = AP_NEWMODEAFTERFIRSTSTEP;
				break;
			case AVKSPROPERTY_DOVEAUTO_COLORKEY:
				pSrb->Status = STATUS_PENDING;
				pHwDevExt->nVGAMode = AP_NEWMODEAFTERSECONDSTEP;
			}

			if( pSrb->Status == STATUS_PENDING )
				StreamClassCallAtNewPriority( pSrb->StreamObject, pSrb->HwDeviceExtension,
												Low, (PHW_PRIORITY_ROUTINE)RunAutoSetup, pSrb );
			break;
		}
	}
	else if( IsEqualGUID( &AVKSPROPSETID_Misc, &pSPD->Property->Set ) )
	{
		ASSERT( pSPD->PropertyOutputSize >= sizeof( ULONG ) );
		uValue = *((PULONG)pSPD->PropertyInfo);

		switch( uId )
		{
		case AVKSPROPERTY_MISC_SKEWRISE:
			uIndex = AVSKEWRISE;
			break;
		case AVKSPROPERTY_MISC_FILTER:
			AV_SetTScaleMode( uValue );
			pSrb->Status = STATUS_SUCCESS;
			break;
		case AVKSPROPERTY_MISC_NEGATIVE:
			uIndex = AVNEGATIVE;
			break;
		}
	}
	else if( IsEqualGUID( &PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set ) )
	{
		if( pSPD->PropertyOutputSize == sizeof( ULONG ) )
			uValue = *((PULONG)pSPD->PropertyInfo);
		else
		{
			uValue = ((PKSPROPERTY_VIDEOPROCAMP_S)pSPD->PropertyInfo)->Value;
			ASSERT( pSPD->PropertyOutputSize >= sizeof( KSPROPERTY_VIDEOPROCAMP_S ) );
		}

		switch( uId )
		{
		case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			uIndex = AVBRIGHTNESS;
			break;
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			uIndex = AVCONTRAST;
			break;
		case KSPROPERTY_VIDEOPROCAMP_SATURATION:
			uIndex = AVSATURATION;
			break;
		case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:
			uIndex = AVSHARP;
			break;
		case KSPROPERTY_VIDEOPROCAMP_GAMMA:
			uIndex = AVGAMMA;
			break;
		case KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION:
			uIndex = AVSOLARIZATION;
			break;
		}
	}
	else if( IsEqualGUID( &KSPROPSETID_CopyProt, &pSPD->Property->Set ) )
	{
		if( uId == KSPROPERTY_COPY_MACROVISION )
		{
			BOOL bSystem = pHwDevExt->VidSystem == PAL ? FALSE:TRUE;
			pHwDevExt->ulLevel = ((PKS_COPY_MACROVISION)pSrb->CommandData.PropertyInfo->PropertyInfo)->MACROVISIONLevel;
			MonoOutStr( "Set MV level->" );
			MonoOutULong( pHwDevExt->ulLevel );
			MonoOutChar( ' ' );
			
			if( !SetMacroVisionLevel( bSystem, pHwDevExt->ulLevel ) )
			{
				MonoOutSetBlink( TRUE );
				MonoOutSetUnderscore( TRUE );
				MonoOutStr( "Set MV level->FAILED!" );
				MonoOutSetBlink( FALSE );
				MonoOutSetUnderscore( FALSE );
				DebugPrint(( DebugLevelWarning, "Set Macrovision level to %d FAILED!\n", pHwDevExt->ulLevel ));
				pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
			else
				pSrb->Status = STATUS_SUCCESS;
		}
	}

	if( uIndex != (UINT)(-1) )
	{
		UINT uOldParam = AV_GetParameter( uIndex );
		pSrb->Status = STATUS_SUCCESS;
		if( uOldParam != uValue )
		{
			if( bDove )
			{
				DOVE_SetParam( (WORD)uIndex, (WORD)uValue );
				AV_UpdateVideo();
			}
			else
			{
				UINT uResult = AV_SetParameter( uIndex, uValue );
				if( uResult & 0x01 )
				{
					if( uResult & 0x02 )
						AV_UpdateVideo();
				}
				else
					pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
		}
	}

	DebugPrint(( DebugLevelVerbose, "ZiVA: End AdapterSetProperty()\n" ));
}
#endif			// #ifdef ENCORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\anlgstrm.h ===
/******************************************************************************
*
*	$RCSfile: AnlgStrm.h $
*	$Source: u:/si/VXP/Wdm/Encore/AnlgStrm.h $
*	$Author: Max $
*	$Date: 1998/08/18 19:39:56 $
*	$Revision: 1.2 $
*
*	Written by:		Max Paklin
*	Purpose:		Definition of analog stream functions for WDM driver
*
*******************************************************************************
*
*	Copyright  1996-97, AuraVision Corporation. All rights reserved.
*
*	AuraVision Corporation makes no warranty of any kind, express or implied,
*	with regard to this software. In no event shall AuraVision Corporation
*	be liable for incidental or consequential damages in connection with or
*	arising from the furnishing, performance, or use of this software.
*
*******************************************************************************/

#ifndef _ANLGSTRM_H_
#define _ANLGSTRM_H_


VOID STREAMAPI AnalogReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI AnalogReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL AnalogInitialize( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AnalogUninitialize( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AnalogOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AnalogCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb );

#endif			// #ifndef _ANLGSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\anlgstrm.c ===
/******************************************************************************
*
*	$RCSfile: AnlgStrm.c $
*	$Source: u:/si/VXP/Wdm/Encore/AnlgStrm.c $
*	$Author: Max $
*	$Date: 1998/09/24 02:23:06 $
*	$Revision: 1.4 $
*
*	Written by:		Max Paklin
*	Purpose:		Implementation of analog stream for WDM driver
*
*******************************************************************************
*
*	Copyright  1996-98, AuraVision Corporation. All rights reserved.
*
*	AuraVision Corporation makes no warranty of any kind, express or implied,
*	with regard to this software. In no event shall AuraVision Corporation
*	be liable for incidental or consequential damages in connection with or
*	arising from the furnishing, performance, or use of this software.
*
*******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "adapter.h"
#include "zivawdm.h"
#include "monovxd.h"
#ifdef ENCORE
#include "wingdi.h"
#include "avwinwdm.h"
#include "anlgstrm.h"
#include "AvInt.h"


void STREAMAPI RunAutoSetup( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	ASSERT( pSrb->Status == STATUS_PENDING );
	pSrb->Status = STATUS_SUCCESS;
	if( pHwDevExt->nVGAMode == AP_NEWVGAAFTERFIRSTSTEP )
	{
		if( AV_DWSetColorKey( DEFCOLOR_REFERENCE1 ) )
			DoveGetReferenceStep1();
		pHwDevExt->nVGAMode = AP