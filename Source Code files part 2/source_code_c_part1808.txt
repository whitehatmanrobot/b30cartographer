]))
        {
            DebugMsg(DM_TRACE, TEXT("DefExtIcon::_Extract handling '*' for backup"));

            HIMAGELIST himlLarge, himlSmall;
            Shell_GetImageLists(&himlLarge, &himlSmall);
        
            if (phiconLarge)
                *phiconLarge = ImageList_GetIcon(himlLarge, nIconIndex, 0);

            if (phiconSmall)
                *phiconSmall = ImageList_GetIcon(himlSmall, nIconIndex,
                0);

            hr = S_OK;
        }

        //  this is the case where nIconIndex is a unique id for the
        //  file.  always get the first icon.

        nIconIndex = 0;
    }

    if (S_FALSE == hr)
    {
        hr = SHDefExtractIcon(pszFile, nIconIndex, _uFlags, phiconLarge, phiconSmall, nIconSize);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drawpie.c ===
#include "shellprv.h"
#pragma  hdrstop

int IntSqrt(unsigned long dwNum)
{
	// We will keep shifting dwNum left and look at the top two bits.

	// initialize sqrt and remainder to 0.
	DWORD dwSqrt = 0, dwRemain = 0, dwTry;
	int i;

	// We iterate 16 times, once for each pair of bits.
	for (i=0; i<16; ++i)
	{
		// Mask off the top two bits of dwNum and rotate them into the
		// bottom of the remainder
		dwRemain = (dwRemain<<2) | (dwNum>>30);

		// Now we shift the sqrt left; next we'll determine whether the
		// new bit is a 1 or a 0.
		dwSqrt <<= 1;

		// This is where we double what we already have, and try a 1 in
		// the lowest bit.
		dwTry = dwSqrt*2 + 1;

		if (dwRemain >= dwTry)
		{
			// The remainder was big enough, so subtract dwTry from
			// the remainder and tack a 1 onto the sqrt.
			dwRemain -= dwTry;
			dwSqrt |= 0x01;
		}

		// Shift dwNum to the left by 2 so we can work on the next few
		// bits.
		dwNum <<= 2;
	}

	return(dwSqrt);
}

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT lprcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors)
{
	int cx, cy, rx, ry, x, y;
	int uQPctX10;
	RECT rcItem;
	HRGN hEllRect, hEllipticRgn, hRectRgn;
	HBRUSH hBrush, hOldBrush;
	HPEN hPen, hOldPen;
    DWORD dwOldLayout;

	rcItem = *lprcItem;
	rcItem.left = lprcItem->left;
	rcItem.top = lprcItem->top;
	rcItem.right = lprcItem->right - rcItem.left;
	rcItem.bottom = lprcItem->bottom - rcItem.top - uOffset;

	rx = rcItem.right / 2;
	cx = rcItem.left + rx - 1;
	ry = rcItem.bottom / 2;
	cy = rcItem.top + ry - 1;
	if (rx<=10 || ry<=10)
	{
		return;
	}

    dwOldLayout = SET_DC_LAYOUT(hDC, 0);

	rcItem.right = rcItem.left+2*rx;
	rcItem.bottom = rcItem.top+2*ry;

	if (uPctX10 > 1000)
	{
		uPctX10 = 1000;
	}

	/* Translate to first quadrant of a Cartesian system
	*/
	uQPctX10 = (uPctX10 % 500) - 250;
	if (uQPctX10 < 0)
	{
		uQPctX10 = -uQPctX10;
	}

	/* Calc x and y.  I am trying to make the area be the right percentage.
	** I don't know how to calculate the area of a pie slice exactly, so I
	** approximate it by using the triangle area instead.
	*/
	if (uQPctX10 < 120)
	{
		x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
	}
	else
	{
		y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
	}

	/* Switch on the actual quadrant
	*/
	switch (uPctX10 / 250)
	{
	case 1:
		y = -y;
		break;

	case 2:
		break;

	case 3:
		x = -x;
		break;

	default: // case 0 and case 4
		x = -x;
		y = -y;
		break;
	}

	/* Now adjust for the center.
	*/
	x += cx;
	y += cy;

        // Hack to get around bug in NTGDI

        x = x < 0 ? 0 : x;

	/* Draw the shadows using regions (to reduce flicker).
	*/
	hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
	OffsetRgn(hEllipticRgn, 0, uOffset);
	hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+uOffset);
	hRectRgn = CreateRectRgn(0, 0, 0, 0);
	CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
	OffsetRgn(hEllipticRgn, 0, -(int)uOffset);
	CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

	/* Always draw the whole area in the free shadow/
	*/
	hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
	if (hBrush)
	{
		FillRgn(hDC, hEllRect, hBrush);
		DeleteObject(hBrush);
	}

	/* Draw the used shadow only if the disk is at least half used.
	*/
	if (uPctX10>500 && (hBrush=CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
	{
		DeleteObject(hRectRgn);
		hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprcItem->bottom);
		CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
		FillRgn(hDC, hEllipticRgn, hBrush);
		DeleteObject(hBrush);
	}

	DeleteObject(hRectRgn);
	DeleteObject(hEllipticRgn);
	DeleteObject(hEllRect);

	hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
	hOldPen = SelectObject(hDC, hPen);

	if((uPctX10 < 100) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 0))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else if((uPctX10 > (1000 - 100)) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 1000))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);

	    Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
	    SelectObject(hDC, hOldBrush);
	    DeleteObject(hBrush);

	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
		    rcItem.left, cy, x, y);
	}
	SelectObject(hDC, hOldBrush);
	DeleteObject(hBrush);

	/* Do not draw the lines if the %age is truely 0 or 100 (completely
	** empty disk or completly full disk)
	*/
	if((TrueZr100 == FALSE) || ((uPctX10 != 0) && (uPctX10 != 1000)))
	{
	    Arc(hDC, rcItem.left, rcItem.top+uOffset, rcItem.right, rcItem.bottom+uOffset,
		    rcItem.left, cy+uOffset, rcItem.right, cy+uOffset-1);
	    MoveToEx(hDC, rcItem.left, cy, NULL);
	    LineTo(hDC, rcItem.left, cy+uOffset);
	    MoveToEx(hDC, rcItem.right-1, cy, NULL);
	    LineTo(hDC, rcItem.right-1, cy+uOffset);

	    if (uPctX10 > 500)
	    {
		    MoveToEx(hDC, x, y, NULL);
		    LineTo(hDC, x, y+uOffset);
	    }
	}
	SelectObject(hDC, hOldPen);
	DeleteObject(hPen);
    SET_DC_LAYOUT(hDC, dwOldLayout);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dlglogic.h ===
#ifndef DLGLOGIC_H
#define DLGLOGIC_H

#include "hwcmmn.h"

#include <dpa.h>

// DL: Data Logic

class CDataImpl : public CRefCounted
{
public:
    CDataImpl();
    virtual ~CDataImpl();

    void _SetDirty(BOOL fDirty);
    BOOL IsDirty();

    void SetDeleted(BOOL fDeleted);
    BOOL IsDeleted();
    void SetNew(BOOL fNew);
    BOOL IsNew();

    // This will be called by clients just before "IsDirty" is called.  The
    // implementation should call _SetDirty with the appropriate dirty status.
    virtual void UpdateDirty() PURE;

    // This should also reset the state of the object to a non-dirty state
    virtual HRESULT CommitChangesToStorage();

    virtual HRESULT AddToStorage();
    virtual HRESULT DeleteFromStorage();

private:
    BOOL                _fDirty;
    BOOL                _fDeleted;
    BOOL                _fNew;
};

// TData is usually derived from CDataImpl
template<typename TData>
class CDLUIData
{
public:
    HRESULT InitData(TData* pdata);
    TData* GetData();

    CDLUIData();
    virtual ~CDLUIData();

private:
    TData*              _pdata;
};

template<typename TData>
class CDLManager
{
public:
    ~CDLManager();
    
    HRESULT AddDataObject(TData* pdata);

    virtual HRESULT Commit();

    BOOL IsDirty();

protected:
    CDPA<TData>*        _pdpaData;
};

// Implementations

template<typename TData>
HRESULT CDLUIData<TData>::InitData(TData* pdata)
{
    ASSERT(pdata);

    pdata->AddRef();

    _pdata = pdata;

    return S_OK;
}

template<typename TData>
TData* CDLUIData<TData>::GetData()
{
    ASSERT(_pdata);

    _pdata->AddRef();

    return _pdata;
}

template<typename TData>
CDLManager<TData>::~CDLManager()
{
    if (_pdpaData)
    {
        _pdpaData->Destroy();

        delete _pdpaData;
    }
}

template<typename TData>
HRESULT CDLManager<TData>::AddDataObject(TData* pdata)
{
    HRESULT hr = S_OK;

    if (!_pdpaData)
    {
        _pdpaData = new CDPA<TData>(DPA_Create(4));

        if (!_pdpaData)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (-1 == _pdpaData->AppendPtr(pdata))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
CDLUIData<TData>::CDLUIData()
{}

template<typename TData>
CDLUIData<TData>::~CDLUIData()
{
    if (_pdata)
    {
        _pdata->Release();
    }
}

template<typename TData>
HRESULT CDLManager<TData>::Commit()
{
    HRESULT hr = S_FALSE;

    if (_pdpaData)
    {
        int c = _pdpaData->GetPtrCount();

        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            TData* pdata = _pdpaData->GetPtr(i);

            if (pdata)
            {
                pdata->UpdateDirty();

                if (pdata->IsDeleted())
                {
                    hr = pdata->DeleteFromStorage();
                }
                else
                {
                    if (pdata->IsNew())
                    {
                        hr = pdata->AddToStorage();
                    }
                    else
                    {
                        if (pdata->IsDirty())
                        {
                            hr = pdata->CommitChangesToStorage();
                        }
                    }
                }
            }
        }
    }

    return hr;
}


template<typename TData>
BOOL CDLManager<TData>::IsDirty()
{
    BOOL fDirty = FALSE;

    if (_pdpaData)
    {
        int c = _pdpaData->GetPtrCount();

        for (int i = 0; !fDirty && (i < c); ++i)
        {
            TData* pdata = _pdpaData->GetPtr(i);

            if (pdata)
            {
                pdata->UpdateDirty();

                if (pdata->IsDirty())
                {
                    fDirty = TRUE;
                }
            }
        }
    }

    return fDirty;
}

#endif //DLGLOGIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drawpie.h ===
int IntSqrt(unsigned long dwNum);

#define DP_USEDCOLOR  0
#define DP_FREECOLOR  1
#define DP_USEDSHADOW 2
#define DP_FREESHADOW 3

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT prcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drives.h ===
#ifndef _DRIVES_H_
#define _DRIVES_H_

// "Public" exports from drivex.c
STDAPI_(UINT) CDrives_GetDriveType(int iDrive);
STDAPI_(DWORD) CDrives_GetKeys(PCSTR pszDrive, HKEY *keys, UINT ckeys);

STDAPI_(void) CDrives_Terminate(void);
STDAPI CDrives_DFMCallBackBG(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg,  WPARAM wParam, LPARAM lParam);
STDAPI CDrives_DFMCallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg,  WPARAM wParam, LPARAM lParam);

#define MAX_LABEL_NTFS      32  // not including the NULL
#define MAX_LABEL_FAT       11  // not including the NULL

STDAPI_(UINT) GetMountedVolumeIcon(LPCTSTR pszMountPoint, LPTSTR pszModule, DWORD cchModule);
STDAPI SetDriveLabel(HWND hwnd, IUnknown* punkEnableModless, int iDrive, LPCTSTR pszDriveLabel);
STDAPI GetDriveComment(int iDrive, LPTSTR pszComment, int cchComment);
STDAPI_(BOOL) IsUnavailableNetDrive(int iDrive);
STDAPI_(BOOL) DriveIOCTL(LPTSTR pszDrive, int cmd, void *pvIn, DWORD dwIn, void *pvOut, DWORD dwOut);
STDAPI_(BOOL) ShowMountedVolumeProperties(LPCTSTR pszMountedVolume, HWND hwndParent);

STDAPI SHCreateDrvExtIcon(LPCWSTR pszDrive, REFIID riid, void** ppvOut);

// Globals from drivesx.c

EXTERN_C const ICONMAP c_aicmpDrive[];
EXTERN_C const int c_nicmpDrives;

#endif // _DRIVES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dll.cpp ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions 
 *
 ***************************************************************************/

#include "shellprv.h"

#include <ntpsapi.h>        // for NtQuery
#include <ntverp.h>
#include <advpub.h>         // For REGINSTALL
#include "fstreex.h"
#include "ids.h"
#include "filefldr.h"
#include "uemapp.h"
#include <xpsp1res.h>

#define DECL_CRTFREE
#include <crtfree.h>

#define INSTALL_MSI 1
#include <msi.h>            // For MSI_Install()
void MSI_Install(LPTSTR pszMSIFile);

void DoFusion();
STDAPI_(void) Control_FillCache_RunDLL( HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow );
BOOL    CopyRegistryValues (HKEY hKeyBaseSource, LPCTSTR pszSource, HKEY hKeyBaseTarget, LPCTSTR pszTarget);

// DllGetVersion - New for IE 4.0 shell integrated mode
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            char szShdocvwPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "SHDOCVW_PATH", szShdocvwPath },
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            // Get the location of shdocvw.dll
            lstrcpyA(szShdocvwPath, "%SystemRoot%\\system32");
            PathAppendA(szShdocvwPath, "shdocvw.dll");
          
            hr = pfnri(g_hinst, szSection, &stReg);
        }
        // since we only do this from DllInstall() don't load and unload advpack over and over
        // FreeLibrary(hinstAdvPack);
    }
    return hr;
}

BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL f = FALSE;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) 
    {
        f = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return f;
}

HRESULT Shell32RegTypeLib(void)
{
    TCHAR szPath[MAX_PATH];
    WCHAR wszPath[MAX_PATH];

    // Load and register our type library.
    //
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    SHTCharToUnicode(szPath, wszPath, ARRAYSIZE(wszPath));

    ITypeLib *pTypeLib;
    HRESULT hr = LoadTypeLib(wszPath, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_Shell32);
        hr = RegisterTypeLib(pTypeLib, wszPath, NULL);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "SHELL32: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "SHELL32: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}

STDAPI CreateShowDesktopOnQuickLaunch()
{
    // delete the "_Current Item" key used for tip rotation in welcome.exe on every upgrade
    HKEY hkey;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\Welcome"), 0, MAXIMUM_ALLOWED, &hkey ) )
    {
       RegDeleteValue(hkey, TEXT("_Current Item"));
       RegCloseKey(hkey);
    }

    // create the "Show Desktop" icon in the quick launch tray
    TCHAR szPath[MAX_PATH];
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE) )
    {
        TCHAR szQuickLaunch[MAX_PATH];
        LoadString(g_hinst, IDS_QUICKLAUNCH, szQuickLaunch, ARRAYSIZE(szQuickLaunch));

        if ( PathAppend( szPath, szQuickLaunch ) )
        {
            WritePrivateProfileSection( TEXT("Shell"), TEXT("Command=2\0IconFile=explorer.exe,3\0"), szPath );
            WritePrivateProfileSection( TEXT("Taskbar"), TEXT("Command=ToggleDesktop\0"), szPath );

            return S_OK;
        }
    }

    return E_FAIL;
}

void _DoMyDocsPerUserInit(void)
{
    // mydocs!PerUserInit is invoked to setup the desktop.ini and do all the other work
    // required to make this correct.
    HINSTANCE hInstMyDocs = LoadLibrary(TEXT("mydocs.dll"));
    if (hInstMyDocs != NULL)
    {
        typedef void (*PFNPerUserInit)(void);
        PFNPerUserInit pfnPerUserInit = (PFNPerUserInit)GetProcAddress(hInstMyDocs, "PerUserInit");
        if (pfnPerUserInit)
        {
            pfnPerUserInit();
        }
        FreeLibrary(hInstMyDocs);
    }
}

void _NoDriveAutorunTweak()
{
    HKEY hkey;
    DWORD dwDisp;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisp))
    {
        DWORD dwRest;
        DWORD cbSize = sizeof(dwRest);

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, TEXT("NoDriveTypeAutoRun"), NULL, NULL,
            (PBYTE)&dwRest, &cbSize))
        {
            dwRest = 0;
        }

        if ((0x95 == dwRest) || (0 == dwRest))
        {
            // Did not change or is not there, let's put 0x91

            dwRest = 0x91;

            RegSetValueEx(hkey, TEXT("NoDriveTypeAutoRun"), 0, REG_DWORD, (PBYTE)&dwRest, sizeof(dwRest));
        }
        else
        {
            // Did change, leave it as is
        }

        RegCloseKey(hkey);
    }
}

// code moved from grpconv.exe

// we'd much rather have new firm links than old floppy ones
// clear out any old ones made by previous runs of setup
void _DeleteOldFloppyLinks(LPITEMIDLIST pidlSendTo, IPersistFile *ppf, IShellLink *psl)
{
    IShellFolder *psfSendTo;
    if (SUCCEEDED(SHBindToObjectEx(NULL, pidlSendTo, NULL, IID_PPV_ARG(IShellFolder, &psfSendTo))))
    {
        IEnumIDList *penum;
        if (SUCCEEDED(psfSendTo->EnumObjects(NULL, SHCONTF_NONFOLDERS, &penum)))
        {
            LPITEMIDLIST pidl;
            ULONG celt;
            while (penum->Next(1, &pidl, &celt) == S_OK)
            {
                // is it a link???
                if (SHGetAttributes(psfSendTo, pidl, SFGAO_LINK))
                {
                    // get the target
                    LPITEMIDLIST pidlFullPath = ILCombine(pidlSendTo, pidl);
                    if (pidlFullPath)
                    {
                        WCHAR szPath[MAX_PATH];
                        if (SHGetPathFromIDList(pidlFullPath, szPath) &&
                            SUCCEEDED(ppf->Load(szPath, 0)))
                        {
                            LPITEMIDLIST pidlTarget;
                            if (SUCCEEDED(psl->GetIDList(&pidlTarget)))
                            {
                                TCHAR szTargetPath[MAX_PATH];
                                // its possible for the old drive letters to have changed.  for example if you
                                // move a removable drive from M:\ to N:\, the shortcut will be invalid, so
                                // we check against DRIVE_NO_ROOT_DIR.
                                // unfortunately we can't tell if we should remove it if they used to have a zip
                                // drive on D:\, and then upgraded and it turned into a hard drive on D:\.  the
                                // shortcut will resolve as DRIVE_FIXED and we dont remove it because they might
                                // have created a shortcut to the fixed drive before the upgrade.
                                if (SHGetPathFromIDList(pidlTarget, szTargetPath) &&
                                    PathIsRoot(szTargetPath) &&
                                    ((DriveType(PathGetDriveNumber(szTargetPath)) == DRIVE_REMOVABLE) ||
                                     (DriveType(PathGetDriveNumber(szTargetPath)) == DRIVE_NO_ROOT_DIR)))
                                {
                                    Win32DeleteFile(szPath);
                                }
                                ILFree(pidlTarget);
                            }
                        }
                        ILFree(pidlFullPath);
                    }
                }
                ILFree(pidl);
            }
            penum->Release();
        }
        psfSendTo->Release();
    }
}

void _DeleteOldRemovableLinks()
{
    IShellLink *psl;
    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl))))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))) )
        {
            LPITEMIDLIST pidlSendTo = SHCloneSpecialIDList(NULL, CSIDL_SENDTO, TRUE);
            if (pidlSendTo)
            {
                // we no longer build a list of removable drives here, since that's done on the fly
                // by the sendto menu.  just delete any links that we owned before.
                _DeleteOldFloppyLinks(pidlSendTo, ppf, psl);
                ILFree(pidlSendTo);
            }
            ppf->Release();
        }
        psl->Release();
    }
}

static const struct
{
    PCWSTR pszExt;
}
_DeleteSendToList[] =
{
    // make sure these extensions are definitely owned by us, since we're deleting all of them.
    { L".cdburn" },          // clean up after XP beta2 upgrade
    { L".publishwizard" }    // clean up after XP beta1 upgrade
};

void _DeleteSendToEntries()
{
    TCHAR szSendTo[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_SENDTO, NULL, 0, szSendTo)))
    {
        for (int i = 0; i < ARRAYSIZE(_DeleteSendToList); i++)
        {
            TCHAR szSearch[MAX_PATH];
            StrCpyN(szSearch, szSendTo, ARRAYSIZE(szSearch));
            PathAppend(szSearch, TEXT("*"));
            StrCatBuff(szSearch, _DeleteSendToList[i].pszExt, ARRAYSIZE(szSearch));

            WIN32_FIND_DATA fd;
            HANDLE hfind = FindFirstFile(szSearch, &fd);
            if (hfind != INVALID_HANDLE_VALUE)
            {
                do
                {
                    TCHAR szFile[MAX_PATH];
                    StrCpyN(szFile, szSendTo, ARRAYSIZE(szFile));
                    PathAppend(szFile, fd.cFileName);
                    DeleteFile(szFile);
                } while (FindNextFile(hfind, &fd));
                FindClose(hfind);
            }
        }
    }

    // next kill old removable drives
    _DeleteOldRemovableLinks();
}

DWORD _GetProcessorSpeed()  // in MHz
{
    static DWORD s_dwSpeed = 0;
    if (s_dwSpeed == 0)
    {
        DWORD cb = sizeof(s_dwSpeed);
        SHGetValue(HKEY_LOCAL_MACHINE, TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
                    TEXT("~MHz"), NULL, &s_dwSpeed, &cb);
        s_dwSpeed += 1; // fudge factor, my 400 Mhz machine reports 399
    }
    return s_dwSpeed;
}

DWORD _GetPhysicalMemory() // in MBs
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION    BasicInfo;

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
             );

    if (NT_SUCCESS(Status))
    {
        return ((BasicInfo.NumberOfPhysicalPages * BasicInfo.PageSize) / (1024 * 1024)) + 1; // fudge factor, my 256 Meg machine reports 255
    }
    else
    {
        return 64;      // Default to 64 Meg (something lame, so that we turn a bunch of stuff off)
    }
}

const TCHAR g_cszLetters[] = TEXT("The Quick Brown Fox Jumped Over The Lazy Dog");

BOOL _PerfTestSmoothFonts(void)
{
    int cchLength = lstrlen(g_cszLetters);
    HDC hdc;
    LOGFONT lf;
    HFONT hfont;
    HFONT hfontOld;
    int bkmodeOld;
    int iIter;
    int iIter2;
    int iIter3;
    LARGE_INTEGER liFrequency;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liStop;
    LARGE_INTEGER liTotal;
    COLORREF colorref;
    SIZE size;
    DOUBLE eTime[2];
    BYTE lfQuality[2];

    HDC hdcScreen = GetDC(NULL);
    hdc = CreateCompatibleDC(hdcScreen);
    HBITMAP hbm = CreateCompatibleBitmap(hdcScreen,200,20);
    HBITMAP hbmOld = (HBITMAP)SelectObject(hdc,hbm);
    ReleaseDC(NULL,hdcScreen);

    bkmodeOld = SetBkMode(hdc, TRANSPARENT);

    QueryPerformanceFrequency( &liFrequency );

    lfQuality[0] = NONANTIALIASED_QUALITY;
    lfQuality[1] = ANTIALIASED_QUALITY;

    memset(&lf,0,sizeof(lf));
    lstrcpy(lf.lfFaceName,TEXT("Arial"));
    lf.lfWeight = FW_BOLD;

    for (iIter3 = 0; iIter3 < 2; iIter3++)
    {
        liTotal.QuadPart = 0;

        for (iIter2 = 0; iIter2 < 5; iIter2++)
        {
            //
            // First, Flush the constructed font cache
            //
            for (iIter = 0; iIter < 64; iIter++)
            {
                lf.lfHeight = -14-iIter;      // 10+ pt
                lf.lfQuality = NONANTIALIASED_QUALITY;

                hfont = CreateFontIndirect(&lf);
                hfontOld = (HFONT)SelectObject(hdc, hfont);

                TextOut(hdc, 0, 0, g_cszLetters, cchLength);

                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
            }
            GdiFlush();
            colorref = GetPixel(hdc,0,0);

            //
            // Now measure how long it takes to construct and use a this font
            //
            lf.lfHeight = -13;             // 10 pt
            lf.lfQuality = lfQuality[iIter3];

            QueryPerformanceCounter( &liStart );
            hfont = CreateFontIndirect(&lf);
            hfontOld = (HFONT)SelectObject(hdc, hfont);

            for (iIter = 0; iIter < 10; iIter++)
            {
                TextOut(hdc, 0, 0, g_cszLetters, cchLength);
            }

            GdiFlush();
            colorref = GetPixel(hdc,0,0);

            QueryPerformanceCounter( &liStop );
            liTotal.QuadPart += liStop.QuadPart - liStart.QuadPart;

            GetTextExtentPoint(hdc, g_cszLetters, cchLength, &size);

            SelectObject(hdc, hfontOld);
            DeleteObject(hfont);

        }

        eTime[iIter3] = (double)liTotal.QuadPart / (double)liFrequency.QuadPart;
    }

    SetBkMode(hdc, bkmodeOld);

    SelectObject(hdc,hbmOld);
    DeleteObject(hbm);
    DeleteDC(hdc);

    return (eTime[1]/eTime[0] <= 4.0);
}

BOOL _PerfTestAlphaLayer(void)
{
    DOUBLE eTime = 100.0;         // 100 is too large to enable features
    int cx = 200;
    int cy = 500;

    LARGE_INTEGER liFrequency;
    QueryPerformanceFrequency( &liFrequency );

    BITMAPINFO bmi;
    memset(&bmi, 0, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    //
    // Create the image we want to alpha blend onto the screen
    //
    HDC hdcScreen = GetDC(NULL);
    HDC hdcImage = CreateCompatibleDC(NULL);
    if (hdcImage != NULL)
    {
        PVOID pbits;
        HBITMAP hbmImage = CreateDIBSection(hdcImage, &bmi, DIB_RGB_COLORS,
                                     &pbits, NULL, NULL);
        if (hbmImage != NULL)
        {
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcImage, hbmImage);

            BitBlt(hdcImage, 0, 0, cx, cy, hdcScreen, 0, 0, SRCCOPY);

            if (pbits != NULL)
            {
                RGBQUAD *prgb = (RGBQUAD *)pbits;
                for (int y = 0; y < cy; y++)
                {
                    for (int x = 0; x < cx; x++)
                    {
                        BYTE color_r;
                        BYTE color_g;
                        BYTE color_b;

                        color_r = prgb->rgbRed;
                        color_g = prgb->rgbBlue;
                        color_b = prgb->rgbGreen;

                        color_r = color_r / 2;
                        color_g = color_g / 2;
                        color_b = color_b / 2;

                        prgb->rgbRed   = color_r;
                        prgb->rgbBlue  = color_g;
                        prgb->rgbGreen = color_b;
                        prgb->rgbReserved = 0x80;

                        prgb++;
                    }
                }
            }

            HWND hwnd1 = CreateWindowEx( WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW,
                    TEXT("Button"),
                    TEXT("Windows XP"),
                    WS_POPUPWINDOW,
                    0, 0,
                    cx, cy,
                    NULL, NULL,
                    0,
                    NULL);

            HWND hwnd2 = CreateWindowEx( WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW,
                    TEXT("Button"),
                    TEXT("Windows XP"),
                    WS_POPUPWINDOW,
                    0, 0,
                    cx, cy,
                    NULL, NULL,
                    0,
                    NULL);

            if (hwnd1 != NULL && hwnd2 != NULL)
            {
                SetWindowPos(hwnd1, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
                SetWindowPos(hwnd2, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);

                BLENDFUNCTION blend;
                blend.BlendOp = AC_SRC_OVER;
                blend.BlendFlags = 0;
                blend.SourceConstantAlpha = 0xFF;
                blend.AlphaFormat = AC_SRC_ALPHA;

                HDC hdc1 = GetDC(hwnd1);
                HDC hdc2 = GetDC(hwnd2);
                POINT ptSrc;
                SIZE size;
                ptSrc.x = 0;
                ptSrc.y = 0;
                size.cx = cx;
                size.cy = cy;

                COLORREF colorref;
                LARGE_INTEGER liStart;
                LARGE_INTEGER liStop;
                LARGE_INTEGER liTotal;

                GdiFlush();
                colorref = GetPixel(hdc1,0,0);
                colorref = GetPixel(hdc2,0,0);
                colorref = GetPixel(hdcScreen,0,0);
                QueryPerformanceCounter( &liStart );

                for (int iIter = 0; iIter < 10; iIter++)
                {
                    UpdateLayeredWindow(hwnd1, hdc1, NULL, &size,
                                              hdcImage, &ptSrc, 0,
                                              &blend, ULW_ALPHA);
                    UpdateLayeredWindow(hwnd2, hdc2, NULL, &size,
                                              hdcImage, &ptSrc, 0,
                                              &blend, ULW_ALPHA);
                }

                GdiFlush();
                colorref = GetPixel(hdc1,0,0);
                colorref = GetPixel(hdc2,0,0);
                colorref = GetPixel(hdcScreen,0,0);
                QueryPerformanceCounter( &liStop );
                liTotal.QuadPart = liStop.QuadPart - liStart.QuadPart;

                eTime = ((DOUBLE)liTotal.QuadPart * 1000.0) / (DOUBLE)liFrequency.QuadPart;
                eTime = eTime / 10.0;

                ReleaseDC(hwnd1, hdc1);
                ReleaseDC(hwnd2, hdc2);

            }

            if (hwnd1)
            {
                DestroyWindow(hwnd1);
            }
            if (hwnd2)
            {
                DestroyWindow(hwnd2);
            }

            SelectObject(hdcImage,hbmOld);
            DeleteObject(hbmImage);
        }
        DeleteDC(hdcImage);
    }

    ReleaseDC(NULL, hdcScreen);

    return (eTime <= 75.0);
}

BOOL g_fPerfFont = FALSE;
BOOL g_fPerfAlpha = FALSE;

#define VISUALEFFECTS_KEY      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects")

#define VISUALEFFECTS_CHECK     TEXT("CheckedValue")
#define VISUALEFFECTS_UNCHECK   TEXT("UncheckedValue")
#define VISUALEFFECTS_DEFAULT   TEXT("DefaultValue")
#define VISUALEFFECTS_APPLIED   TEXT("DefaultApplied")
#define VISUALEFFECTS_MINCPU    TEXT("MinimumCPU")
#define VISUALEFFECTS_MINMEM    TEXT("MinimumMEM")
#define VISUALEFFECTS_FONT      TEXT("DefaultByFontTest")
#define VISUALEFFECTS_ALPHA     TEXT("DefaultByAlphaTest")

#define VISUALEFFECTS_VER   1

void _ApplyDefaultVisualEffect(HKEY hkey,HKEY hkeyUser)
{
    //
    // blow this off completely on TS client to avoid stepping
    // on TS client's toes
    //
    if (!IsOS(OS_TERMINALCLIENT))
    {
        DWORD cb;
        DWORD dwDefaultApplied = 0;

        if (0 != hkeyUser)
        {
            cb = sizeof(dwDefaultApplied);
            RegQueryValueEx(hkeyUser, VISUALEFFECTS_APPLIED, NULL, NULL, (LPBYTE)&dwDefaultApplied, &cb);
        }

        //
        // Apply defaults only if the version number is old
        //
        if (VISUALEFFECTS_VER > dwDefaultApplied)
        {
            LPTSTR pszValue = NULL;     // use the default value
            DWORD dwMinimumCPU = 0;
            DWORD dwMinimumMEM = 0;
            BOOL fFontTestDefault = FALSE;
            BOOL fAlphaTestDefault = FALSE;

            //
            // see if a minimum physical memory value is specified
            //
            cb = sizeof(dwMinimumMEM);
            RegQueryValueEx(hkey, VISUALEFFECTS_MINMEM, NULL, NULL, (LPBYTE)&dwMinimumMEM, &cb);

            //
            // see if a minimum CPU speed is specified
            //
            cb = sizeof(dwMinimumCPU);
            RegQueryValueEx(hkey, VISUALEFFECTS_MINCPU, NULL, NULL, (LPBYTE)&dwMinimumCPU, &cb);

            //
            // see if the font performance test value is needed
            //
            cb = sizeof(fFontTestDefault);
            RegQueryValueEx(hkey, VISUALEFFECTS_FONT, NULL, NULL, (LPBYTE)&fFontTestDefault, &cb);

            //
            // see if the alpha performance test value is needed
            //
            cb = sizeof(fAlphaTestDefault);
            RegQueryValueEx(hkey, VISUALEFFECTS_ALPHA, NULL, NULL, (LPBYTE)&fAlphaTestDefault, &cb);


            if (   dwMinimumCPU > 0
                || dwMinimumMEM > 0
                || fFontTestDefault
                || fAlphaTestDefault)
            {
                pszValue = VISUALEFFECTS_CHECK;

                if (_GetProcessorSpeed() < dwMinimumCPU)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (_GetPhysicalMemory() < dwMinimumMEM)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (fFontTestDefault && !g_fPerfFont)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (fAlphaTestDefault && !g_fPerfAlpha)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
            }

            if (IsOS(OS_ANYSERVER))
            {
                //
                // on server, we default to best performance (*everything* off)
                //
                pszValue = VISUALEFFECTS_UNCHECK;
            }

            DWORD dwValue = 0;
            cb = sizeof(dwValue);

            if (pszValue)
            {
                //
                // set the default according to the chosen value
                //
                RegQueryValueEx(hkey, pszValue, NULL, NULL, (LPBYTE)&dwValue, &cb);

                //
                // when figuring out settings that need to adjust the default
                // value the VISUALEFFECTS_DEFAULT value must be re-applied
                // to the per-user key.
                //
                if (0 != hkeyUser)
                {
                    RegSetValueEx(hkeyUser, VISUALEFFECTS_DEFAULT, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
                }
            }
            else
            {
                //
                // read in the default value
                //
                RegQueryValueEx(hkey, VISUALEFFECTS_DEFAULT, NULL, NULL, (LPBYTE)&dwValue, &cb);
            }

            //
            // how do we apply this setting?
            //
            DWORD uiAction;
            TCHAR szBuf[MAX_PATH];

            if (cb = sizeof(szBuf),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CLSID"), NULL, NULL, (LPBYTE)&szBuf, &cb))
            {
                //
                // by CLSID
                //
                CLSID clsid;
                GUIDFromString(szBuf, &clsid);

                IRegTreeItem* pti;
                if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IRegTreeItem, &pti))))
                {
                    pti->SetCheckState(dwValue);
                    pti->Release();
                }
            }
            else if (cb = sizeof(uiAction),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("SPIActionSet"), NULL, NULL, (LPBYTE)&uiAction, &cb))
            {
                //
                // by SPI
                //
                SHBoolSystemParametersInfo(uiAction, &dwValue);
            }
            else if (cb = sizeof(szBuf),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("RegPath"), NULL, NULL, (LPBYTE)&szBuf, &cb))
            {
                //
                // by reg key
                //
                TCHAR szValueName[96];
                cb = sizeof(szValueName);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("ValueName"), NULL, NULL, (LPBYTE)&szValueName, &cb))
                {
                    SHSetValue(HKEY_CURRENT_USER, szBuf, szValueName, REG_DWORD, &dwValue, sizeof(dwValue));
                }
            }

            if (0 != hkeyUser)
            {
                dwDefaultApplied = VISUALEFFECTS_VER;
                RegSetValueEx(hkeyUser, VISUALEFFECTS_APPLIED, 0, REG_DWORD, (LPBYTE)&dwDefaultApplied, sizeof(dwDefaultApplied));
            }
        }
    }
}

void _DefaultVisualEffects(void)
{
    HKEY hkeyUser;
    DWORD dw;

    g_fPerfFont = _PerfTestSmoothFonts();
    g_fPerfAlpha = _PerfTestAlphaLayer();

    if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, VISUALEFFECTS_KEY, 0, TEXTW(""), 0, KEY_SET_VALUE,
                        NULL, &hkeyUser, &dw))
    {
        HKEY hkey;
        REGSAM samDesired = KEY_READ;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, VISUALEFFECTS_KEY, 0, samDesired, &hkey))
        {
            TCHAR szName[96];
            for (int i = 0; ERROR_SUCCESS == RegEnumKey(hkey, i, szName, ARRAYSIZE(szName)); i++)
            {
                HKEY hkeyUserItem;

                if (ERROR_SUCCESS == RegCreateKeyExW(hkeyUser, szName, 0, TEXTW(""), 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
                                    NULL, &hkeyUserItem, &dw))
                {
                    HKEY hkeyItem;
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, samDesired, &hkeyItem))
                    {
                        // only apply the default for the setting if the "NoApplyDefault" reg value is NOT present
                        if (RegQueryValueEx(hkeyItem, TEXT("NoApplyDefault"), NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                        {
                            _ApplyDefaultVisualEffect(hkeyItem, hkeyUserItem);
                        }

                        RegCloseKey(hkeyItem);
                    }

                    RegCloseKey(hkeyUserItem);
                }
            }
            RegCloseKey(hkey);
        }
        RegCloseKey(hkeyUser);
    }
}

STDAPI CDeskHtmlProp_RegUnReg(BOOL bInstall);
STDAPI_(BOOL) ApplyRegistrySecurity();
STDAPI_(void) FixPlusIcons();
STDAPI_(void) CleanupFileSystem();
STDAPI_(void) InitializeSharedDocs(BOOL fOnWow64);

#define KEEP_FAILURE(hrSum, hrLast) if (FAILED(hrLast)) hrSum = hrLast;

#ifdef _WIN64
// On IA64 machines we need to copy the EULA file (eula.txt) from %SytemRoot%\System32, to
// %SystemRoot%\SysWOW64. This is needed because when you do help|about on a 32-bit app running
// under wow64 it will look in the syswow64 directory for the file.
//
// Why is shell32.dll doing this and not setup you might ask? The EULA has to be installed by textmode
// since it is unsigned (and changes for every sku). Since txtmode setup does a MOVE instead of a copy, we
// cannot have it installed into two places. Thus the easies thing to do is to simply copy the file
// from the System32 directory to the SysWOW64 directory here. Sigh.

BOOL CopyEULAForWow6432()
{
    BOOL bRet = FALSE;
    TCHAR szEULAPath[MAX_PATH];
    TCHAR szWow6432EULAPath[MAX_PATH];

    if (GetSystemWindowsDirectory(szEULAPath, ARRAYSIZE(szEULAPath)))
    {
        lstrcpyn(szWow6432EULAPath, szEULAPath, ARRAYSIZE(szWow6432EULAPath));
        
        if (PathAppend(szEULAPath, TEXT("System32\\eula.txt")) &&
            PathAppend(szWow6432EULAPath, TEXT("SysWOW64\\eula.txt")))
        {
            // now we have the source (%SystemRoot%\System32\eula.txt) and dest (%SystemRoot%\SysWOW64\eula.txt)
            // paths, lets do the copy!
            
            bRet = CopyFile(szEULAPath, szWow6432EULAPath, FALSE);
        }
    }

    return bRet;
}
#endif  // _WIN64    


//
// Upgrades from Win9x are internally handled by setup as "clean" installs followed by some
// migration of settings. So, the following function does the job of truly detecting a win9x
// upgrade.
// The way it detects: Look in %windir%\system32\$winnt$.inf in the section [Data] 
// for Win9xUpgrade=Yes if it is a Win9x upgrade.
//
BOOL IsUpgradeFromWin9x()
{
    TCHAR szFilePath[MAX_PATH];
    TCHAR szYesOrNo[10];
    
    GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath));
    PathAppend(szFilePath, TEXT("$WINNT$.INF"));

    GetPrivateProfileString(TEXT("Data"),           // Section name.
                            TEXT("Win9xUpgrade"),   // Key name.
                            TEXT("No"),             // Default string, if key is missing.
                            szYesOrNo, 
                            ARRAYSIZE(szYesOrNo), 
                            szFilePath);            // Full path to "$winnt$.inf" file.

    return (0 == lstrcmpi(szYesOrNo, TEXT("Yes")));
}

BOOL IsCleanInstallInProgress()
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   HKEY hKeySetup;
   BOOL fCleanInstall = FALSE;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) 
   {
        DWORD dwSize;
        LONG lResult;
        DWORD dwSystemSetupInProgress = 0;
        
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  NULL, (LPBYTE) &dwSystemSetupInProgress, &dwSize);

        if (lResult == ERROR_SUCCESS) 
        {
            DWORD dwMiniSetupInProgress = 0; 
            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKeySetup, TEXT("MiniSetupInProgress"), NULL,
                                      NULL, (LPBYTE) &dwMiniSetupInProgress, &dwSize);
                                      
            if(dwSystemSetupInProgress && !dwMiniSetupInProgress)
            {
                DWORD dwUpgradeInProgress = 0;
                dwSize = sizeof(DWORD);
                //Setup is in progress and MiniSetup is NOT in progress.
                //That means that we are in the GUI mode of setup!

                //On clean installs, this value won't be there and the following call will fail.
                RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                          NULL, (LPBYTE) &dwUpgradeInProgress, &dwSize);

                fCleanInstall = !dwUpgradeInProgress;
            }
        }
        RegCloseKey (hKeySetup);
    }

    if(fCleanInstall)
    {
        // Caution: An upgrade from Win9x is internally done by setup as a "clean" install.
        // So, we need to figure out if this is really a clean install or an upgrade from 
        // win9x.
        
        fCleanInstall = !IsUpgradeFromWin9x();
    }
    
    return fCleanInstall ;
}

//
//  Set the default MFU to be picked up when each user logs on for the
//  first time.  The string block must be 16 strings long (_0 through _15).
//
STDAPI SetDefaultMFU(UINT ids)
{
    HKEY hkMFU;
    LONG lRc = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SMDEn"),
                              0, NULL, 0, KEY_WRITE, NULL, &hkMFU, NULL);
    if (lRc == ERROR_SUCCESS)
    {
        for (int i = 0; lRc == ERROR_SUCCESS && i < 16; i++)
        {
            TCHAR szValue[80];
            TCHAR szData[80];
            wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("Link%d"), i);
            wnsprintf(szData, ARRAYSIZE(szData), TEXT("@xpsp1res.dll,-%d"), ids + i);
            DWORD cbData = (lstrlen(szData) + 1) * sizeof(TCHAR);
            lRc = RegSetValueEx(hkMFU, szValue, 0, REG_SZ, (LPBYTE)szData, cbData);
        }
        RegCloseKey(hkMFU);
    }
    return HRESULT_FROM_WIN32(lRc);
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hrTemp, hr = S_OK;

    // 99/05/03 vtan: If you're reading this section then you are considering
    // adding code to the registration/installation of shell32.dll. There are
    // now 3 schemes to accomplish this task:

    // 1. IE4UINIT.EXE
    //      Check HKLM\Software\Microsoft\Active Setup\Installed Components\{89820200-ECBD-11cf-8B85-00AA005B4383}
    //      This says that if there is a new version of IE5 to launch ie4uinit.exe.
    //      You can add code to this executable if you wish. You need to enlist in
    //      the setup project on \\trango\slmadd using "ieenlist setup"

    // 2. REGSVR32.EXE /n /i:U shell32.dll
    //      Check HKLM\Software\Microsoft\Active Setup\Installed Components\{89820200-ECBD-11cf-8B85-00AA005B4340}
    //      This is executed using the same scheme as IE4UINIT.EXE except that the
    //      executable used is regsvr32.exe with a command line passed to
    //      shell32!DllInstall. Add your code in the section for "U" below.
    //      If you put the code in the section which is NOT "U" then your
    //      code is executed at GUI setup and any changes you make to HKCU
    //      go into the default user (template). Be careful when putting
    //      things here as winlogon.exe (or some other process) may put
    //      your changes into a user profile unconditionally.

    // 3. HIVEUSD.INX
    //      Checks NT build numbers and does command based on the previous build
    //      number and the current build number only executing the changes between
    //      the builds. If you wish to add something using this method, currently
    //      you have to enlist in the setup project on \\rastaman\ntwin using
    //      "enlist -fgs \\rastaman\ntwin -p setup". To find hiveusd.inx go to
    //      nt\private\setup\inf\win4\inf. Add the build number which the delta
    //      is required and a command to launch %SystemRoot%\System32\shmgrate.exe
    //      with one or two parameters. The first parameter tells what command to
    //      execute. The second parameter is optional. shmgrate.exe then finds
    //      shell32.dll and calls shell32!FirstUserLogon. Code here is for upgrading
    //      HKCU user profiles from one NT build to another NT build.
    //      Code is executed in the process context shmgrate.exe and is executed
    //      at a time where no UI is possible. Always use HKLM\Software\Microsoft
    //      \Windows NT\CurrentVersion\Image File Execution Options\Debugger with
    //      "-d".

    // Schemes 1 and 2 work on either Win9x or WinNT but have the sometimes
    // unwanted side effect of ALWAYS getting executed on version upgrades.
    // Scheme 3 only gets executed on build number deltas. Because schemes 1
    // and 2 are always executed, if a user changes (or deletes) that setting
    // it will always get put back. Not so with scheme 3.

    // Ideally, the best solution is have an internal shell32 build number
    // delta scheme which determines the from build and the to build and does
    // a similar mechanism to what hiveusd.inx and shmgrate.exe do. This
    // would probably involve either a common installation function (such as
    // FirstUserLogon()) which is called differently from Win9x and WinNT or
    // common functions to do the upgrade and two entry points (such as
    // FirstUserLogonNT() and FirstUserLogonWin9X().
    
    if (bInstall)
    {
        NT_PRODUCT_TYPE type = NtProductWinNt;
        RtlGetNtProductType(&type);

        // "U" means it's the per user install call
        BOOL fPerUser = pszCmdLine && (StrCmpIW(pszCmdLine, L"U") == 0);
        if (fPerUser)
        {
            // NOTE: Code in this segment get run during first login.  We want first
            // login to be as quick as possible so try to minimize this section.

            // Put per-user install stuff here.  Any HKCU registration
            // done here is suspect.  (If you are setting defaults, do
            // so in HKLM and use the SHRegXXXUSValue functions.)

            // WARNING: we get called by the ie4unit.exe (ieunit.inf) scheme:
            //      %11%\shell32.dll,NI,U
            // this happens per user, to test this code "regsvr32 /n /i:U shell32.dll"

            // Some of this stuff we don't want to do on all upgrades (in particular XP Gold -> XP SPn)
            BOOL fUpgradeUserSettings = TRUE;
            WCHAR szVersion[50]; // plenty big for aaaa,bbbb,cccc,dddd
            DWORD cbVersion = sizeof(szVersion);
            if (ERROR_SUCCESS==SHGetValueW(HKEY_CURRENT_USER,
                    L"Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4340}",L"Version", // guid is Shell32's Active Setup
                    NULL, szVersion, &cbVersion))
            {
                __int64 nverUpgradeFrom;
                __int64 nverWinXP;
                if (SUCCEEDED(GetVersionFromString64(szVersion, &nverUpgradeFrom)) &&
                    SUCCEEDED(GetVersionFromString64(L"6,0,2600,0000", &nverWinXP)))
                {
                    fUpgradeUserSettings = nverUpgradeFrom < nverWinXP;
                }
            }
            

#ifdef INSTALL_MSI
            // Install the Office WebFolders shell namespace extension per user.
            MSI_Install(TEXT("webfldrs.msi"));
#endif

            hrTemp = CreateShowDesktopOnQuickLaunch();
            KEEP_FAILURE(hrTemp, hr);

            //  upgrade the recent folder.
            WCHAR sz[MAX_PATH];
            SHGetFolderPath(NULL, CSIDL_RECENT | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, sz);
            SHGetFolderPath(NULL, CSIDL_FAVORITES | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, sz);

            //  torch this value on upgrade.
            //  insuring the warning that they will see the ugly desktop.ini files
            if (fUpgradeUserSettings)
            {
                SKDeleteValue(SHELLKEY_HKCU_EXPLORER, L"Advanced", L"ShowSuperHidden");
            }

            HKEY hk = SHGetShellKey(SHELLKEY_HKCULM_MUICACHE, NULL, FALSE);
            if (hk)
            {
                SHDeleteKeyA(hk, NULL);
                RegCloseKey(hk);
            }

            // delete old sendto entries we dont want any more
            _DeleteSendToEntries();

            // handle the per user init for this guy
            _DoMyDocsPerUserInit();

            _DefaultVisualEffects();

            // handle the per user change of value for NoDriveAutoRun
            if (!IsOS(OS_ANYSERVER))
            {
                _NoDriveAutorunTweak();
            }
        }
        else
        {
            // Delete any old registration entries, then add the new ones.
            // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
            // (The inf engine doesn't guarantee DelReg/AddReg order, that's
            // why we explicitly unreg and reg here.)
            //
            hrTemp = CallRegInstall("RegDll");
            KEEP_FAILURE(hrTemp, hr);

            // I suppose we should call out NT-only registrations, just in case
            // we ever have to ship a win9x based shell again
            hrTemp = CallRegInstall("RegDllNT");
            KEEP_FAILURE(hrTemp, hr);

            // If we are on NT server, do additional stuff
            if (type != NtProductWinNt)
            {
                hrTemp = CallRegInstall("RegDllNTServer");
                KEEP_FAILURE(hrTemp, hr);
            }
            else // workstation
            {
                if (!IsOS(OS_PERSONAL))
                {
                    hrTemp = CallRegInstall("RegDllNTPro");
                    KEEP_FAILURE(hrTemp, hr);

                    //
                    // NTRAID#NTBUG9-418621-2001/06/27-jeffreys
                    //
                    // If the ForceGuest value is unset, e.g. on upgrade
                    // from Win2k, set the SimpleSharing/DefaultValue to 0.
                    //
                    DWORD dwForceGuest;
                    DWORD cb = sizeof(dwForceGuest);
                    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\Lsa"), TEXT("ForceGuest"), NULL, &dwForceGuest, &cb))
                    {
                        dwForceGuest = 0;
                        SHSetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\SimpleSharing"), TEXT("DefaultValue"), REG_DWORD, &dwForceGuest, sizeof(dwForceGuest));
                    }
                }

                // Service Pack is not allowed to change selfreg.inf
                // so we need to do this manually.  Must do this after
                // RegDll so we can overwrite his settings.
#ifdef _WIN64
                hrTemp = SetDefaultMFU(IDS_SHELL32_PROMFU64_0);
#else
                hrTemp = SetDefaultMFU(IDS_SHELL32_PROMFU32_0);
#endif
                KEEP_FAILURE(hrTemp, hr);
            }

            //
            // If this is clean install, then hide some desktop icons.
            //
            if(IsCleanInstallInProgress())
            {
                hrTemp = CallRegInstall("RegHideDeskIcons");
                KEEP_FAILURE(hrTemp, hr);
            }

            // This is apparently the only way to get setup to remove all the registry backup
            // for old names no longer in use...
            hrTemp = CallRegInstall("CleanupOldRollback1");
            KEEP_FAILURE(hrTemp, hr);

            hrTemp = CallRegInstall("CleanupOldRollback2");
            KEEP_FAILURE(hrTemp, hr);

            // REVIEW (ToddB): Move this to DllRegisterServer.
            hrTemp = Shell32RegTypeLib();
            KEEP_FAILURE(hrTemp, hr);
            ApplyRegistrySecurity();
            FixPlusIcons();

            // Filesystem stuff should be done only on the native platform
            // (don't do it when in the emulator) since there is only one
            // filesystem. Otherwise the 32-bit version writes 32-bit goo
            // into the filesystem that the 64-bit shell32 can't handle
            if (!IsOS(OS_WOW6432))
            {
                CleanupFileSystem();
            }

#ifdef _WIN64
            // this will copy eula.txt to the %SystemRoot%\SysWOW64 directory for 
            // 32-bit apps running on IA64 under emulation
            CopyEULAForWow6432();
#endif        
            // Initialize the shared documents objects
            InitializeSharedDocs(IsOS(OS_WOW6432));

            DoFusion();
        }
    }
    else
    {
        // We only need one unreg call since all our sections share
        // the same backup information
        hrTemp = CallRegInstall("UnregDll");
        KEEP_FAILURE(hrTemp, hr);
        UnregisterTypeLibrary(&LIBID_Shell32);
    }

    CDeskHtmlProp_RegUnReg(bInstall);
    
    return hr;
}


STDAPI DllRegisterServer(void)
{
    // NT5 setup calls this so it is now safe to put code here.
    return S_OK;
}


STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


BOOL CopyRegistryValues (HKEY hKeyBaseSource, LPCTSTR pszSource, HKEY hKeyBaseTarget, LPCTSTR pszTarget)
{
    DWORD   dwDisposition, dwMaxValueNameSize, dwMaxValueDataSize;
    HKEY    hKeySource, hKeyTarget;
    BOOL    fSuccess = FALSE; //Assume error!

    hKeySource = hKeyTarget = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyBaseSource,
                                       pszSource,
                                       0,
                                       KEY_READ,
                                       &hKeySource)) &&
        (ERROR_SUCCESS == RegCreateKeyEx(hKeyBaseTarget,
                                         pszTarget,
                                         0,
                                         TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hKeyTarget,
                                         &dwDisposition)) &&
        (ERROR_SUCCESS == RegQueryInfoKey(hKeySource,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &dwMaxValueNameSize,
                                          &dwMaxValueDataSize,
                                          NULL,
                                          NULL)))
    {
        TCHAR   *pszValueName;
        void    *pValueData;

        pszValueName = reinterpret_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, ++dwMaxValueNameSize * sizeof(TCHAR)));
        if (pszValueName != NULL)
        {
            pValueData = LocalAlloc(LMEM_FIXED, dwMaxValueDataSize);
            if (pValueData != NULL)
            {
                DWORD   dwIndex, dwType, dwValueNameSize, dwValueDataSize;

                dwIndex = 0;
                dwValueNameSize = dwMaxValueNameSize;
                dwValueDataSize = dwMaxValueDataSize;
                while (ERROR_SUCCESS == RegEnumValue(hKeySource,
                                                     dwIndex,
                                                     pszValueName,
                                                     &dwValueNameSize,
                                                     NULL,
                                                     &dwType,
                                                     reinterpret_cast<LPBYTE>(pValueData),
                                                     &dwValueDataSize))
                {
                    RegSetValueEx(hKeyTarget,
                                  pszValueName,
                                  0,
                                  dwType,
                                  reinterpret_cast<LPBYTE>(pValueData),
                                  dwValueDataSize);
                    ++dwIndex;
                    dwValueNameSize = dwMaxValueNameSize;
                    dwValueDataSize = dwMaxValueDataSize;
                }
                LocalFree(pValueData);
                fSuccess = TRUE; //Succeeded!
            }
            LocalFree(pszValueName);
        }
    }
    if(hKeySource)
        RegCloseKey(hKeySource);
    if(hKeyTarget)
        RegCloseKey(hKeyTarget);

    return fSuccess;
}

STDAPI MergeDesktopAndNormalStreams(void)
{
    static  const   TCHAR   scszBaseRegistryLocation[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer");
    static  const   int     sciMaximumStreams = 128;
    static  const   TCHAR   sccOldMRUListBase = TEXT('a');

    // Upgrade from NT4 (classic shell) to Windows 2000 (integrated shell)

    // This involves TWO major changes and one minor change:
    //    1. Merging DesktopStreamMRU and StreamMRU
    //    2. Upgrading the MRUList to MRUListEx
    //    3. Leaving the old settings alone for the roaming user profile scenario

    // This also involves special casing the users desktop PIDL because this is
    // stored as an absolute path PIDL in DesktopStream and needs to be stored
    // in Streams\Desktop instead.

    // The conversion is performed in-situ and simultaneously.

    // 1. Open all the keys we are going to need to do the conversion.

    HKEY    hKeyBase, hKeyDesktopStreamMRU, hKeyDesktopStreams, hKeyStreamMRU, hKeyStreams;

    hKeyBase = hKeyDesktopStreamMRU = hKeyDesktopStreams = hKeyStreamMRU = hKeyStreams = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                       scszBaseRegistryLocation,
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyBase)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("DesktopStreamMRU"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyDesktopStreamMRU)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("DesktopStreams"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyDesktopStreams)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("StreamMRU"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyStreamMRU)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("Streams"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyStreams)) &&

    // 2. Determine whether this upgrade is needed at all. If the presence of
    // StreamMRU\MRUListEx is detected then stop.

        (ERROR_SUCCESS != RegQueryValueEx(hKeyStreamMRU,
                                         TEXT("MRUListEx"),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL)))
    {
        DWORD   *pdwMRUListEx, *pdwMRUListExBase;

        pdwMRUListExBase = pdwMRUListEx = reinterpret_cast<DWORD*>(LocalAlloc(LPTR, sciMaximumStreams * sizeof(DWORD) * 2));
        if (pdwMRUListEx != NULL)
        {
            DWORD   dwLastFreeSlot, dwMRUListSize, dwType;
            TCHAR   *pszMRUList, szMRUList[sciMaximumStreams];

            // 3. Read the StreamMRU\MRUList, iterate thru this list
            // and convert as we go.

            dwLastFreeSlot = 0;
            dwMRUListSize = sizeof(szMRUList);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                 TEXT("MRUList"),
                                                 NULL,
                                                 &dwType,
                                                 reinterpret_cast<LPBYTE>(szMRUList),
                                                 &dwMRUListSize))
            {
                pszMRUList = szMRUList;
                while (*pszMRUList != TEXT('\0'))
                {
                    DWORD   dwValueDataSize;
                    TCHAR   szValue[16];

                    // Read the PIDL information based on the letter in
                    // the MRUList.

                    szValue[0] = *pszMRUList++;
                    szValue[1] = TEXT('\0');
                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                         szValue,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &dwValueDataSize))
                    {
                        DWORD   dwValueType;
                        void    *pValueData;

                        pValueData = LocalAlloc(LMEM_FIXED, dwValueDataSize);
                        if ((pValueData != NULL) &&
                            (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                              szValue,
                                                              NULL,
                                                              &dwValueType,
                                                              reinterpret_cast<LPBYTE>(pValueData),
                                                              &dwValueDataSize)))
                        {

                            // Allocate a new number in the MRUListEx for the PIDL.

                            *pdwMRUListEx = szValue[0] - sccOldMRUListBase;
                            wsprintf(szValue, TEXT("%d"), *pdwMRUListEx++);
                            ++dwLastFreeSlot;
                            RegSetValueEx(hKeyStreamMRU,
                                          szValue,
                                          NULL,
                                          dwValueType,
                                          reinterpret_cast<LPBYTE>(pValueData),
                                          dwValueDataSize);
                            LocalFree(pValueData);
                        }
                    }
                }
            }

            // 4. Read the DesktopStreamMRU\MRUList, iterate thru this
            // this and append to the new MRUListEx that is being
            // created as well as copying both the PIDL in DesktopStreamMRU
            // and the view information in DesktopStreams.

            dwMRUListSize = sizeof(szMRUList);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                 TEXT("MRUList"),
                                                 NULL,
                                                 &dwType,
                                                 reinterpret_cast<LPBYTE>(szMRUList),
                                                 &dwMRUListSize))
            {
                bool    fConvertedEmptyPIDL;
                TCHAR   szDesktopDirectoryPath[MAX_PATH];

                fConvertedEmptyPIDL = false;
                SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szDesktopDirectoryPath);
                pszMRUList = szMRUList;
                while (*pszMRUList != TEXT('\0'))
                {
                    DWORD   dwValueDataSize;
                    TCHAR   szSource[16];

                    // Read the PIDL information based on the letter in
                    // the MRUList.

                    szSource[0] = *pszMRUList++;
                    szSource[1] = TEXT('\0');
                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                         szSource,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &dwValueDataSize))
                    {
                        DWORD   dwValueType;
                        void    *pValueData;

                        pValueData = LocalAlloc(LMEM_FIXED, dwValueDataSize);
                        if ((pValueData != NULL) &&
                            (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                              szSource,
                                                              NULL,
                                                              &dwValueType,
                                                              reinterpret_cast<LPBYTE>(pValueData),
                                                              &dwValueDataSize)))
                        {
                            TCHAR   szTarget[16], szStreamPath[MAX_PATH];

                            if ((SHGetPathFromIDList(reinterpret_cast<LPCITEMIDLIST>(pValueData), szStreamPath) != 0) &&
                                (0 == lstrcmpi(szStreamPath, szDesktopDirectoryPath)))
                            {
                                if (!fConvertedEmptyPIDL)
                                {

                                    // 99/05/24 #343721 vtan: Prefer the desktop relative PIDL
                                    // (empty PIDL) when given a choice of two PIDLs that refer
                                    // to the desktop. The old absolute PIDL is from SP3 and
                                    // earlier days. The new relative PIDL is from SP4 and
                                    // later days. An upgraded SP3 -> SP4 -> SPx -> Windows
                                    // 2000 system will possibly have old absolute PIDLs.
                                    // Check for the empty PIDL. If this is encountered already
                                    // then don't process this stream.

                                    fConvertedEmptyPIDL = ILIsEmpty(reinterpret_cast<LPCITEMIDLIST>(pValueData));
                                    wsprintf(szSource, TEXT("%d"), szSource[0] - sccOldMRUListBase);
                                    CopyRegistryValues(hKeyDesktopStreams, szSource, hKeyStreams, TEXT("Desktop"));
                                }
                            }
                            else
                            {

                                // Allocate a new number in the MRUListEx for the PIDL.

                                *pdwMRUListEx++ = dwLastFreeSlot;
                                wsprintf(szTarget, TEXT("%d"), dwLastFreeSlot++);
                                if (ERROR_SUCCESS == RegSetValueEx(hKeyStreamMRU,
                                                                   szTarget,
                                                                   NULL,
                                                                   dwValueType,
                                                                   reinterpret_cast<LPBYTE>(pValueData),
                                                                   dwValueDataSize))
                                {

                                    // Copy the view information from DesktopStreams to Streams

                                    wsprintf(szSource, TEXT("%d"), szSource[0] - sccOldMRUListBase);
                                    CopyRegistryValues(hKeyDesktopStreams, szSource, hKeyStreams, szTarget);
                                }
                            }
                            LocalFree(pValueData);
                        }
                    }
                }
            }
            *pdwMRUListEx++ = static_cast<DWORD>(-1);
            RegSetValueEx(hKeyStreamMRU,
                          TEXT("MRUListEx"),
                          NULL,
                          REG_BINARY,
                          reinterpret_cast<LPCBYTE>(pdwMRUListExBase),
                          ++dwLastFreeSlot * sizeof(DWORD));
            LocalFree(reinterpret_cast<HLOCAL>(pdwMRUListExBase));
        }
    }
    if (hKeyStreams != NULL)
        RegCloseKey(hKeyStreams);
    if (hKeyStreamMRU != NULL)
        RegCloseKey(hKeyStreamMRU);
    if (hKeyDesktopStreams != NULL)
        RegCloseKey(hKeyDesktopStreams);
    if (hKeyDesktopStreamMRU != NULL)
        RegCloseKey(hKeyDesktopStreamMRU);
    if (hKeyBase != NULL)
        RegCloseKey(hKeyBase);
    return(S_OK);
}

static  const   int     s_ciMaximumNumericString = 32;

int GetRegistryStringValueAsInteger (HKEY hKey, LPCTSTR pszValue, int iDefaultValue)

{
    int     iResult;
    DWORD   dwType, dwStringSize;
    TCHAR   szString[s_ciMaximumNumericString];

    dwStringSize = sizeof(szString);
    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                         pszValue,
                                         NULL,
                                         &dwType,
                                         reinterpret_cast<LPBYTE>(szString),
                                         &dwStringSize) && (dwType == REG_SZ))
    {
        iResult = StrToInt(szString);
    }
    else
    {
        iResult = iDefaultValue;
    }
    return(iResult);
}

void SetRegistryIntegerAsStringValue (HKEY hKey, LPCTSTR pszValue, int iValue)

{
    TCHAR   szString[s_ciMaximumNumericString];

    wnsprintf(szString, ARRAYSIZE(szString), TEXT("%d"), iValue);
    TW32(RegSetValueEx(hKey,
                       pszValue,
                       0,
                       REG_SZ,
                       reinterpret_cast<LPBYTE>(szString),
                       (lstrlen(szString) + sizeof('\0')) * sizeof(TCHAR)));
}

STDAPI MoveAndAdjustIconMetrics(void)
{
    // 99/06/06 #309198 vtan: The following comes from hiveusd.inx which is
    // where this functionality used to be executed. It used to consist of
    // simple registry deletion and addition. This doesn't work on upgrade
    // when the user has large icons (Shell Icon Size == 48).

    // In this case that metric must be moved and the new values adjusted
    // so that the metric is preserved should the user then decide to turn
    // off large icons.

    // To restore old functionality, remove the entry in hiveusd.inx at
    // build 1500 which is where this function is invoked and copy the
    // old text back in.

/*
    HKR,"1508\Hive\2","Action",0x00010001,3
    HKR,"1508\Hive\2","KeyName",0000000000,"Control Panel\Desktop\WindowMetrics"
    HKR,"1508\Hive\2","Value",0000000000,"75"
    HKR,"1508\Hive\2","ValueName",0000000000,"IconSpacing"
    HKR,"1508\Hive\3","Action",0x00010001,3
    HKR,"1508\Hive\3","KeyName",0000000000,"Control Panel\Desktop\WindowMetrics"
    HKR,"1508\Hive\3","Value",0000000000,"1"
    HKR,"1508\Hive\3","ValueName",0000000000,"IconTitleWrap"
*/

    // Icon metric keys have moved from HKCU\Control Panel\Desktop\Icon*
    // to HKCU\Control Panel\Desktop\WindowMetrics\Icon* but only 3 values
    // should be moved. These are "IconSpacing", "IconTitleWrap" and
    // "IconVerticalSpacing". This code is executed before the deletion
    // entry in hiveusd.inx so that it can get the values before they
    // are deleted. The addition section has been remove (it's above).

    static  const   TCHAR   s_cszIconSpacing[] = TEXT("IconSpacing");
    static  const   TCHAR   s_cszIconTitleWrap[] = TEXT("IconTitleWrap");
    static  const   TCHAR   s_cszIconVerticalSpacing[] = TEXT("IconVerticalSpacing");

    static  const   int     s_ciStandardOldIconSpacing = 75;
    static  const   int     s_ciStandardNewIconSpacing = -1125;

    HKEY    hKeyDesktop, hKeyWindowMetrics;

    hKeyDesktop = hKeyWindowMetrics = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                       TEXT("Control Panel\\Desktop"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyDesktop)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyDesktop,
                                       TEXT("WindowMetrics"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyWindowMetrics)))
    {
        int     iIconSpacing, iIconTitleWrap, iIconVerticalSpacing;

        // 1. Read the values that we wish the move and adjust.

        iIconSpacing = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconSpacing, s_ciStandardOldIconSpacing);
        iIconTitleWrap = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconTitleWrap, 1);
        iIconVerticalSpacing = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconVerticalSpacing, s_ciStandardOldIconSpacing);

        // 2. Perform the adjustment.

        iIconSpacing = s_ciStandardNewIconSpacing * iIconSpacing / s_ciStandardOldIconSpacing;
        iIconVerticalSpacing = s_ciStandardNewIconSpacing * iIconVerticalSpacing / s_ciStandardOldIconSpacing;

        // 3. Write the values back out in the new (moved) location.

        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconSpacing, iIconSpacing);
        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconTitleWrap, iIconTitleWrap);
        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconVerticalSpacing, iIconVerticalSpacing);

        // 4. Let winlogon continue processing hiveusd.inx and delete the
        // old entries in the process. We already created the new entries
        // and that has been removed from hiveusd.inx.

    }
    if (hKeyWindowMetrics != NULL)
        TW32(RegCloseKey(hKeyWindowMetrics));
    if (hKeyDesktop != NULL)
        TW32(RegCloseKey(hKeyDesktop));
    return(S_OK);
}

STDAPI FirstUserLogon(LPCSTR pcszCommand, LPCSTR pcszOptionalArguments)
{
    const struct
    {
        LPCSTR  pcszCommand;
        HRESULT (WINAPI *pfn)();
    }  
    sCommands[] =
    {
        { "MergeDesktopAndNormalStreams",   MergeDesktopAndNormalStreams   },
        { "MoveAndAdjustIconMetrics",       MoveAndAdjustIconMetrics       },
    };

    HRESULT hr = E_FAIL;
    // Match what shmgrate.exe passed us and execute the command.
    // Only use the optional argument if required. Note this is
    // done ANSI because the original command line is ANSI from
    // shmgrate.exe.

    for (int i = 0; i < ARRAYSIZE(sCommands); ++i)
    {
        if (lstrcmpA(pcszCommand, sCommands[i].pcszCommand) == 0)
        {
            hr = sCommands[i].pfn();
            break;
        }
    }
    return hr;
}

#ifdef INSTALL_MSI
//
// WebFolders namespace extension installation.
// This is the code that initially installs the Office WebFolders 
// shell namespace extension on the computer.  Code in shmgrate.exe
// (see private\windows\shell\migrate) performs per-user
// web folders registration duties.
//
typedef UINT (WINAPI * PFNMSIINSTALLPRODUCT)(LPCTSTR, LPCTSTR);
typedef INSTALLUILEVEL (WINAPI * PFNMSISETINTERNALUI)(INSTALLUILEVEL, HWND *);

#define GETPROC(var, hmod, ptype, fn)  ptype var = (ptype)GetProcAddress(hmod, fn)

#define API_MSISETINTERNALUI  "MsiSetInternalUI"
#ifdef UNICODE
#   define API_MSIINSTALLPRODUCT "MsiInstallProductW"
#else
#   define API_MSIINSTALLPRODUCT "MsiInstallProductA"
#endif

void MSI_Install(LPTSTR pszMSIFile)
{
    HMODULE hmod = LoadLibrary(TEXT("msi.dll"));
    if (hmod)
    {
        BOOL bFreeLib = FALSE;
        GETPROC(pfnMsiSetInternalUI,  hmod, PFNMSISETINTERNALUI,  API_MSISETINTERNALUI);
        GETPROC(pfnMsiInstallProduct, hmod, PFNMSIINSTALLPRODUCT, API_MSIINSTALLPRODUCT);

        if (pfnMsiSetInternalUI && pfnMsiInstallProduct)
        {
            TCHAR szPath[MAX_PATH];
            GetSystemDirectory(szPath, ARRAYSIZE(szPath));
            PathAppend(szPath, pszMSIFile);

            //
            // Use "silent" install mode.  No UI.
            //
            INSTALLUILEVEL oldUILevel = pfnMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

            // Install the MSI package.
            // Old code did this polling loop on a background thread, but that doesn't
            // work since we're called at DllInstall time, and the process will
            // go away before the install completes.  Must do it all on this thread.
            // Wait a little bit before re-trying.
            UINT uRet = 0;
            do {
                uRet = pfnMsiInstallProduct(szPath, TEXT(""));
            } while ((uRet == ERROR_INSTALL_ALREADY_RUNNING) && (Sleep(100),TRUE));
 
            pfnMsiSetInternalUI(oldUILevel, NULL);
        }

        if (bFreeLib)
            FreeLibrary(hmod);
    }
}

#endif // INSTALL_MSI


// now is the time on sprockets when we lock down the registry
STDAPI_(BOOL) ApplyRegistrySecurity()
{
    BOOL fSuccess = FALSE;      // assume failure
    SHELL_USER_PERMISSION supEveryone;
    SHELL_USER_PERMISSION supSystem;
    SHELL_USER_PERMISSION supAdministrators;
    PSHELL_USER_PERMISSION aPerms[3] = {&supEveryone, &supSystem, &supAdministrators};

    // we want the "Everyone" to have read access
    supEveryone.susID = susEveryone;
    supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supEveryone.dwAccessMask = KEY_READ;
    supEveryone.fInherit = TRUE;
    supEveryone.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supEveryone.dwInheritAccessMask = GENERIC_READ;

    // we want the "SYSTEM" to have full control
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = KEY_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the "Administrators" to have full control
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = KEY_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    SECURITY_DESCRIPTOR* psd = GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
    if (psd)
    {
        HKEY hkLMBitBucket;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BitBucket"), 0, KEY_ALL_ACCESS, &hkLMBitBucket) == ERROR_SUCCESS)
        {
            if (RegSetKeySecurity(hkLMBitBucket, DACL_SECURITY_INFORMATION, psd) == ERROR_SUCCESS)
            {
                // victory is mine!
                fSuccess = TRUE;
            }

            RegCloseKey(hkLMBitBucket);
        }

        LocalFree(psd);
    }

    return fSuccess;
}

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    // nothing in here, use clsobj.c class table instead
END_OBJECT_MAP()

// ATL DllMain, needed to support our ATL classes that depend on _Module
// REVIEW: confirm that _Module is really needed

STDAPI_(BOOL) ATL_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

#define FUSION_FLAG_SYSTEM32        0
#define FUSION_FLAG_WINDOWS         1
#define FUSION_FLAG_PROGRAMFILES    2
#define FUSION_ENTRY(x, z)  {L#x, NULL, z},
#define FUSION_ENTRY_DEST(x, y, z)  {L#x, L#y, z},

struct
{
    PWSTR pszAppName;
    PWSTR pszDestination;
    DWORD dwFlags;
} 
g_FusionizedApps[] = 
{
    FUSION_ENTRY(ncpa.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(nwc.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(sapi.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(wuaucpl.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(cdplayer.exe, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY_DEST(msimn.exe, "OutLook Express", FUSION_FLAG_PROGRAMFILES)
    // WARNING: Do NOT add iexplorer or Explorer.exe! This will cause all apps to get fusioned; which is bad, mkay?
};



void DoFusion()
{
    TCHAR szManifest[MAX_PATH];

    // We will however generate a manifest for other apps
    for (int i = 0; i < ARRAYSIZE(g_FusionizedApps); i++)
    {
        switch(g_FusionizedApps[i].dwFlags)
        {
        case FUSION_FLAG_SYSTEM32:
            GetSystemDirectory(szManifest, ARRAYSIZE(szManifest));
            break;

        case FUSION_FLAG_WINDOWS:
            GetWindowsDirectory(szManifest, ARRAYSIZE(szManifest));
            break;

        case FUSION_FLAG_PROGRAMFILES:
            SHGetSpecialFolderPath(NULL, szManifest, CSIDL_PROGRAM_FILES, FALSE);
            PathCombine(szManifest, szManifest, g_FusionizedApps[i].pszDestination);
            break;
        }

        PathCombine(szManifest, szManifest, g_FusionizedApps[i].pszAppName);
        StrCatBuff(szManifest, TEXT(".manifest"), ARRAYSIZE(szManifest));
        SHSquirtManifest(HINST_THISDLL, IDS_EXPLORERMANIFEST, szManifest);
    }

    SHGetManifest(szManifest, ARRAYSIZE(szManifest));
    SHSquirtManifest(HINST_THISDLL, IDS_EXPLORERMANIFEST, szManifest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drvx.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <hwtab.h>
#include "fstreex.h"
#include "views.h"
#include "drives.h"
#include "propsht.h"
#include "infotip.h"
#include "datautil.h"
#include "netview.h"
#include "bitbuck.h"
#include "drawpie.h"
#include "shitemid.h"
#include "devguid.h"
#include "ids.h"
#include "idldrop.h"
#include "util.h"
#include "shcombox.h"
#include "hwcmmn.h"
#include "prop.h"

#include "mtpt.h"
#include "ftascstr.h"   // for CFTAssocStore
#include "ascstr.h"     // for IAssocInfo class
#include "apdlg.h"
#include "cdburn.h"

#define REL_KEY_DEFRAG TEXT("MyComputer\\defragpath")
#define REL_KEY_BACKUP TEXT("MyComputer\\backuppath")

///////////////////////////////////////////////////////////////////////////////
// Begin: Old C fct required externally
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet)
{
    int iType = DRIVE_NO_ROOT_DIR;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive, TRUE, fOKToHitNet);

    if (pMtPt)
    {
        WCHAR szDrive[4];

        iType = GetDriveType(PathBuildRoot(szDrive, iDrive));
        iType |= pMtPt->GetDriveFlags();
        iType |= pMtPt->GetVolumeFlags();
        pMtPt->Release();
    }

    return iType;    
}

STDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet)
{
    WCHAR szDrive[4];

    return GetDriveType(PathBuildRoot(szDrive, iDrive)) & DRIVE_TYPE;    
}

STDAPI_(int) DriveType(int iDrive)
{
    return RealDriveType(iDrive, TRUE);
}

STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath)
{
    static TCHAR s_szRoot[MAX_PATH] = {'\0'};
    static int   s_nszRootLen = 0;
    static DWORD s_dwSize = 0;

    DWORD dwSize = 0;

    // Do we have a cache hit?  No need to hit the net if we can avoid it...
    if (s_nszRootLen)
    {
        ENTERCRITICAL;
        if (wcsncmp(pszPath, s_szRoot, s_nszRootLen) == 0)
        {
            dwSize = s_dwSize;
        }
        LEAVECRITICAL;
    }

    if (0 == dwSize)
    {
        TCHAR szRoot[MAX_PATH];

        lstrcpy(szRoot, pszPath);
        PathStripToRoot(szRoot);

        if (PathIsUNC(szRoot))
        {
            DWORD dwSecPerClus, dwBytesPerSec, dwClusters, dwTemp;

            PathAddBackslash(szRoot);

            if (GetDiskFreeSpace(szRoot, &dwSecPerClus, &dwBytesPerSec, &dwTemp, &dwClusters))
            {
                dwSize = dwSecPerClus * dwBytesPerSec;
            }
        }
        else
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(pszPath);

            if (pMtPt)
            {
                dwSize = pMtPt->GetClusterSize();
                pMtPt->Release();
            }
        }

        // Sometimes on Millennium, we get 0 as the cluster size.
        // Reason unknown.  Sanitize the value so we don't go insane.
        if (dwSize == 0)
            dwSize = 512;

        // Remember this for later - chances are we'll be queried for the same drive again
        ENTERCRITICAL;
        StrCpyN(s_szRoot, szRoot, ARRAYSIZE(s_szRoot));
        s_nszRootLen = lstrlen(s_szRoot);
        s_dwSize = dwSize;
        LEAVECRITICAL;
    }

    return dwSize;
}

STDAPI_(UINT) GetMountedVolumeIcon(LPCTSTR pszMountPoint, LPTSTR pszModule, DWORD cchModule)
{
    UINT iIcon = II_FOLDER;

    // zero-init string
    if (pszModule)
        *pszModule = 0;

    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pszMountPoint);
    if (pMtPt)
    {
        iIcon = pMtPt->GetIcon(pszModule, cchModule);
        pMtPt->Release();
    }
    return iIcon;
}


STDAPI_(BOOL) IsDisconnectedNetDrive(int iDrive)
{
    BOOL fDisc = 0;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        fDisc = pMtPt->IsDisconnectedNetDrive();
        pMtPt->Release();
    }
    return fDisc;
}

STDAPI_(BOOL) IsUnavailableNetDrive(int iDrive)
{
    BOOL fUnAvail = 0;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        fUnAvail = pMtPt->IsUnavailableNetDrive();
        pMtPt->Release();
    }

    return fUnAvail;

}

STDMETHODIMP SetDriveLabel(HWND hwnd, IUnknown* punkEnableModless, int iDrive, LPCTSTR pszDriveLabel)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        hr = pMtPt->SetDriveLabel(hwnd, pszDriveLabel);
        pMtPt->Release();
    }

    return hr;
}

STDMETHODIMP GetDriveComment(int iDrive, LPTSTR pszComment, int cchComment)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        hr = pMtPt->GetComment(pszComment, cchComment);
        pMtPt->Release();
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// End:   Old C fct required externally
///////////////////////////////////////////////////////////////////////////////

//
// fDoIt -- TRUE, if we make connections; FALSE, if just querying.
//
BOOL _MakeConnection(IDataObject *pDataObj, BOOL fDoIt)
{
    STGMEDIUM medium;
    FORMATETC fmte = {g_cfNetResource, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BOOL fAnyConnectable = FALSE;

    if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
    {
        LPNETRESOURCE pnr = (LPNETRESOURCE)LocalAlloc(LPTR, 1024);
        if (pnr)
        {
            UINT iItem, cItems = SHGetNetResource(medium.hGlobal, (UINT)-1, NULL, 0);
            for (iItem = 0; iItem < cItems; iItem++)
            {
                if (SHGetNetResource(medium.hGlobal, iItem, pnr, 1024) &&
                    pnr->dwUsage & RESOURCEUSAGE_CONNECTABLE &&
                    !(pnr->dwType & RESOURCETYPE_PRINT))
                {
                    fAnyConnectable = TRUE;
                    if (fDoIt)
                    {
                        SHNetConnectionDialog(NULL, pnr->lpRemoteName, pnr->dwType);
                        SHChangeNotifyHandleEvents();
                    }
                    else
                    {
                        break;  // We are just querying.
                    }
                }
            }
            LocalFree(pnr);
        }
        ReleaseStgMedium(&medium);
    }

    return fAnyConnectable;
}

//
// the entry of "make connection thread"
//
DWORD WINAPI MakeConnectionThreadProc(void *pv)
{
    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream((IStream *)pv, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        _MakeConnection(pdtobj, TRUE);
        pdtobj->Release();
    }

    return 0;
}

STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

class CDrivesDropTarget : public CIDLDropTarget
{
friend HRESULT CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CDrivesDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };
    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
};


STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CDrivesDropTarget *pCIDLDT = new CDrivesDropTarget(hwnd);
    if (pCIDLDT)
    {
        hr = pCIDLDT->_Init(pidl);
        if (SUCCEEDED(hr))
            pCIDLDT->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        pCIDLDT->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

//
// puts DROPEFFECT_LINK in *pdwEffect, only if the data object
// contains one or more net resource.
//
STDMETHODIMP CDrivesDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Call the base class first.
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    *pdwEffect &= _MakeConnection(pDataObj, FALSE) ? DROPEFFECT_LINK : DROPEFFECT_NONE;

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;     // Notes: we should NOT return hr as it.
}

//
// creates a connection to a dropped net resource object.
//
STDMETHODIMP CDrivesDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;

    if (m_dwData & DTID_NETRES)
    {
        *pdwEffect = DROPEFFECT_LINK;

        hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pDataObj,
            pt, pdwEffect, NULL, NULL, POPUP_DRIVES_NONDEFAULTDD, grfKeyState);

        if (hr == S_FALSE)
        {
            // we create another thread to avoid blocking the source thread.
            IStream *pstm;
            if (S_OK == CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pDataObj, &pstm))
            {
                if (SHCreateThread(MakeConnectionThreadProc, pstm, CTF_COINIT, NULL))
                {
                    hr = S_OK;
                }
                else
                {
                    pstm->Release();
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        //
        // Because QueryGetData() failed, we don't call CIDLDropTarget_
        // DragDropMenu(). Therefore, we must call this explicitly.
        //
        DAD_DragLeave();
        hr = E_FAIL;
    }

    CIDLDropTarget::DragLeave();

    return hr;
}

STDAPI_(DWORD) DrivesPropertiesThreadProc(void *pv)
{
    PROPSTUFF *pps = (PROPSTUFF *)pv;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    BOOL bDidActivate = FALSE;
    
    //
    // This __try/__finally block is to ensure that the activation context gets
    // removed, even if there's an assertion elsewhere in this code.  A missing
    // DeactivateActCtx will lead to a very strange-looking assertion in one of
    // the RtlpDeactivateActCtx-variant functions from the caller.  Old code
    // was missing the deactivate in all circumstances.
    //
    // (jonwis) 1/2/2001
    //
    __try
    {
        bDidActivate = ActivateActCtx(NULL, &dwCookie);
   
        LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);

        BOOL bMountedDriveInfo = FALSE;

        // Were we able to get data for a HIDA?
        if (!pida)
        {
            // No, pida is first choice, but if not present check for mounteddrive info
            FORMATETC fmte;

            fmte.cfFormat = g_cfMountedVolume;
            fmte.ptd = NULL;
            fmte.dwAspect = DVASPECT_CONTENT;
            fmte.lindex = -1;
            fmte.tymed = TYMED_HGLOBAL;

            // Is data available for the MountedVolume format?
            if (SUCCEEDED(pps->pdtobj->GetData(&fmte, &medium)))
                // Yes
                bMountedDriveInfo = TRUE;
        }

        // Do we have data for a HIDA or a mountedvolume?
        if (pida || bMountedDriveInfo)
        {
            // Yes
            TCHAR szCaption[MAX_PATH];
            LPTSTR pszCaption = NULL;

            if (pida)
            {
                pszCaption = SHGetCaption(medium.hGlobal);
            }
            else
            {
                TCHAR szMountPoint[MAX_PATH];
                TCHAR szVolumeGUID[MAX_PATH];

                DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint));
            
                GetVolumeNameForVolumeMountPoint(szMountPoint, szVolumeGUID, ARRAYSIZE(szVolumeGUID));
                szCaption[0] = 0;
                GetVolumeInformation(szVolumeGUID, szCaption, ARRAYSIZE(szCaption), NULL, NULL, NULL, NULL, 0);

                if (!(*szCaption))
                    LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szCaption, ARRAYSIZE(szCaption));        

                PathRemoveBackslash(szMountPoint);

                // Fix 330388
                // If the szMountPoint is not a valid local path, do not
                // display it in the properties dialog title:
                if (-1 != PathGetDriveNumber(szMountPoint))
                {
                    int nCaptionLength = lstrlen(szCaption) ;
                    wnsprintf(szCaption + nCaptionLength, ARRAYSIZE(szCaption) - nCaptionLength, TEXT(" (%s)"), szMountPoint);
                }
                pszCaption = szCaption;
            }

            //  NOTE - if we pass the name of the drive then we can get a lot more keys...
            HKEY rgk[MAX_ASSOC_KEYS];
            DWORD ck = CDrives_GetKeys(NULL, rgk, ARRAYSIZE(rgk));

            SHOpenPropSheet(pszCaption, rgk, ck,
                            &CLSID_ShellDrvDefExt, pps->pdtobj, NULL, pps->pStartPage);

            SHRegCloseKeys(rgk, ck);

            if (pida && pszCaption)
                SHFree(pszCaption);

            if (pida)
                HIDA_ReleaseStgMedium(pida, &medium);
            else
                ReleaseStgMedium(&medium);

        }
        else
        {
            TraceMsg(DM_TRACE, "no HIDA in data obj nor Mounted drive info");
        }
    }
    __finally
    {
        if ( bDidActivate )
        {
            DeactivateActCtx( 0, dwCookie );
        }
    }

    return 0;
}

//
// To be called back from within CDefFolderMenu
//
STDAPI CDrives_DFMCallBack(IShellFolder *psf, HWND hwnd,
                           IDataObject *pdtobj, UINT uMsg, 
                           WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (pdtobj)
        {
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

            // Check if only file system objects are selected.
            if (pdtobj->QueryGetData(&fmte) == S_OK)
            {
                #define pqcm ((LPQCMINFO)lParam)

                STGMEDIUM medium;
                // Yes, only file system objects are selected.
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, 0);

                    if (pidd)
                    {
                        int iDrive = DRIVEID(pidd->cName);
                        UINT idCmdBase = pqcm->idCmdFirst;   // store it away

                        BOOL fIsEjectable = FALSE;

                        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DRIVES_ITEM, 0, pqcm);

                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

                        if (pmtpt)
                        {
                            if (!pmtpt->IsRemote() ||
                                SHRestricted( REST_NONETCONNECTDISCONNECT ))
                            {
                                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_DISCONNECT, MF_BYCOMMAND);
                            }

                            if ((pida->cidl != 1) ||
                                (!pmtpt->IsFormattable()))
                            {
                                // Don't even try to format more than one disk
                                // Or a net drive, or a CD-ROM, or a RAM drive ...
                                // Note we are going to show the Format command on the
                                // boot drive, Windows drive, System drive, compressed
                                // drives, etc.  An appropriate error should be shown
                                // after the user chooses this command
                                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_FORMAT, MF_BYCOMMAND);
                            }

                            if (pmtpt->IsEjectable())
                                fIsEjectable = TRUE;

                            pmtpt->Release();
                        }

                        if ((pida->cidl != 1) || (iDrive < 0) || !fIsEjectable)
                            DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_EJECT, MF_BYCOMMAND);

                    }

                    HIDA_ReleaseStgMedium(pida, &medium);    
                }

                #undef pqcm
            }
        }
        // Note that we always return S_OK from this function so that
        // default processing of menu items will occur
        ASSERT(hr == S_OK);
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_MAPCOMMANDNAME:
        if (lstrcmpi((LPCTSTR)lParam, TEXT("eject")) == 0)
            *(int *)wParam = FSIDM_EJECT;
        else if (lstrcmpi((LPCTSTR)lParam, TEXT("format")) == 0)
            *(int *)wParam = FSIDM_FORMAT;
        else
            hr = E_FAIL;  // command not found
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case DFM_CMD_PROPERTIES:
            // lParam contains the page name to open
            hr = SHLaunchPropSheet(DrivesPropertiesThreadProc, pdtobj, (LPCTSTR)lParam, NULL, NULL);
            break;

        case FSIDM_EJECT:
        case FSIDM_FORMAT:
        {
            STGMEDIUM medium;

            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

            ASSERT(HIDA_GetCount(medium.hGlobal) == 1);

            LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, 0);
            if (pidd)
            {
                UINT iDrive = DRIVEID(pidd->cName);

                ASSERT((int)iDrive >= 0);

                switch (wParam)
                {
                case FSIDM_FORMAT:
                    SHFormatDriveAsync(hwnd, iDrive, SHFMT_ID_DEFAULT, 0);
                    break;

                case FSIDM_EJECT:
                    {
                        CDBurn_OnEject(hwnd, iDrive);
                        CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);
                        if (pMtPt)
                        {
                            pMtPt->Eject(hwnd);
                            pMtPt->Release();
                        }
                        break;
                    }
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
            break;
        }

        case FSIDM_DISCONNECT:

            if (pdtobj)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    DISCDLGSTRUCT discd = {
                        sizeof(discd),          // cbStructure
                        hwnd,                   // hwndOwner
                        NULL,                   // lpLocalName
                        NULL,                   // lpRemoteName
                        DISC_UPDATE_PROFILE     // dwFlags
                    };
                    for (UINT iidl = 0; iidl < pida->cidl; iidl++)
                    {
                        LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, iidl);

                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

                        if (pmtpt)
                        {
                            if (pmtpt->IsRemote())
                            {
                                TCHAR szPath[4], szDrive[4];
                                BOOL fUnavailable = pmtpt->IsUnavailableNetDrive();

                                SHAnsiToTChar(pidd->cName, szPath,  ARRAYSIZE(szPath));
                                SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));
                                szDrive[2] = 0; // remove slash
                                discd.lpLocalName = szDrive;

                                if (SHWNetDisconnectDialog1(&discd) == WN_SUCCESS)
                                {
                                    // If it is a unavailable drive we get no
                                    // file system notification and as such
                                    // the drive will not disappear, so lets
                                    // set up to do it ourself...
                                    if (fUnavailable)
                                    {
                                        CMountPoint::NotifyUnavailableNetDriveGone(szPath);

                                        // Do we need this if we have the above?
                                        SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_PATH, szPath, NULL);
                                    }
                                }
                            }

                            pmtpt->Release();
                        }
                    }

                    // flush them altogether
                    SHChangeNotifyHandleEvents();
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
            }
            break;

        case FSIDM_CONNECT_PRN:
            SHNetConnectionDialog(hwnd, NULL, RESOURCETYPE_PRINT);
            break;

        case FSIDM_DISCONNECT_PRN:
            WNetDisconnectDialog(hwnd, RESOURCETYPE_PRINT);
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

#define REGSTR_LASTUNCHASH  TEXT("LastUNCHash")

STDMETHODIMP GetUNCPathHash(HKEY hkDrives, LPCTSTR pszUNCPath, LPTSTR pszUNCPathHash, int cchUNCPathHash)
{
    HRESULT hr = E_FAIL;
    DWORD dwLastUNCHash = 0;
    SHQueryValueEx(hkDrives, REGSTR_LASTUNCHASH, NULL, NULL, (BYTE *)&dwLastUNCHash, NULL);
    dwLastUNCHash++;
    if (RegSetValueEx(hkDrives, REGSTR_LASTUNCHASH, 0, REG_DWORD, (LPCBYTE)&dwLastUNCHash, sizeof(dwLastUNCHash)) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    wnsprintf(pszUNCPathHash, cchUNCPathHash, TEXT("%lu"), (ULONG)dwLastUNCHash);
    return hr;
}

void _DrvPrshtSetSpaceValues(DRIVEPROPSHEETPAGE *pdpsp)
{
    LPITEMIDLIST pidl;
    TCHAR szFormat[30];
    TCHAR szTemp[30];
    TCHAR szBuffer[64]; // needs to be big enough to hold "99,999,999,999,999 bytes" + room for localization

    // reset the total/free values to start with
    pdpsp->qwTot = pdpsp->qwFree = 0;

    // lets try to ask the shellfolder for this information!
    HRESULT hr = SHILCreateFromPath(pdpsp->szDrive, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        IShellFolder2 *psf2;
        LPCITEMIDLIST pidlLast;

        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
        if (SUCCEEDED(hr))
        {
            ULONGLONG ullFree;

            hr = GetLongProperty(psf2, pidlLast, &SCID_FREESPACE, &ullFree);
            if (SUCCEEDED(hr))
            {
                ULONGLONG ullTotal;

                hr = GetLongProperty(psf2, pidlLast, &SCID_CAPACITY, &ullTotal);
                if (SUCCEEDED(hr))
                {
                    pdpsp->qwTot = ullTotal;
                    pdpsp->qwFree = ullFree;
                }
            }
            psf2->Release();
        }
        ILFree(pidl);
    }

    // we want to use the IShellFolder stuff above so cdrom burning will be happy. However, the
    // above code fails for removable drives that have no media, so we need a fallback
    if (FAILED(hr))
    {
        ULARGE_INTEGER qwFreeUser;
        ULARGE_INTEGER qwTotal;
        ULARGE_INTEGER qwTotalFree;

        if (SHGetDiskFreeSpaceEx(pdpsp->szDrive, &qwFreeUser, &qwTotal, &qwTotalFree))
        {
            // Save away to use when drawing the pie
            pdpsp->qwTot = qwTotal.QuadPart;
            pdpsp->qwFree = qwFreeUser.QuadPart;
        }
    }
    
    LoadString(HINST_THISDLL, IDS_BYTES, szFormat, ARRAYSIZE(szFormat));

    // NT must be able to display 64-bit numbers; at least as much
    // as is realistic.  We've made the decision
    // that volumes up to 100 Terrabytes will display the byte value
    // and the short-format value.  Volumes of greater size will display
    // "---" in the byte field and the short-format value.  Note that the
    // short format is always displayed.
    const _int64 MaxDisplayNumber = 99999999999999; // 100TB - 1.

    if ((pdpsp->qwTot - pdpsp->qwFree) <= MaxDisplayNumber)
    {
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwTot - pdpsp->qwFree, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDBYTES, szBuffer);
    }

    if (pdpsp->qwFree <= MaxDisplayNumber)
    {
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwFree, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEBYTES, szBuffer);
    }

    if (pdpsp->qwTot <= MaxDisplayNumber)
    {
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwTot, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTBYTES, szBuffer);
    }

    ShortSizeFormat64(pdpsp->qwTot-pdpsp->qwFree, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDMB, szBuffer);

    ShortSizeFormat64(pdpsp->qwFree, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEMB, szBuffer);

    ShortSizeFormat64(pdpsp->qwTot, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTMB, szBuffer);
}

void _DrvPrshtGetPieShadowHeight(DRIVEPROPSHEETPAGE* pdpsp)
{
    SIZE size;
    HDC hDC = GetDC(pdpsp->hDlg);

    // some bizzare black magic calculation for the pie size...
    GetTextExtentPoint(hDC, TEXT("W"), 1, &size);
    pdpsp->dwPieShadowHgt = size.cy * 2 / 3;
    ReleaseDC(pdpsp->hDlg, hDC);
}

void _DrvPrshtSetDriveIcon(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szModule[MAX_PATH];

    if (pMtPt)
    {
        UINT uIcon = pMtPt->GetIcon(szModule, ARRAYSIZE(szModule));

        if (uIcon)
        {
            HIMAGELIST hIL = NULL;

            Shell_GetImageLists(&hIL, NULL);

            if (hIL)
            {
                int iIndex = Shell_GetCachedImageIndex(szModule[0] ? szModule : c_szShell32Dll, uIcon, 0);
                HICON hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIndex);

                if (hIcon)
                {
                    ReplaceDlgIcon(pdpsp->hDlg, IDC_DRV_ICON, hIcon);
                }
            }
        }
    }

}

void _DrvPrshtSetDriveAttributes(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    if (pMtPt)    
    {
        if (pMtPt->IsCompressible())
        {
            // file-based compression is supported (must be NTFS)
            pdpsp->fIsCompressionAvailable = TRUE;
        
            if (pMtPt->IsCompressed())
            {
                // the volume root is compressed
                pdpsp->asInitial.fCompress = TRUE;

                // if its compressed, compression better be available
                ASSERT(pdpsp->fIsCompressionAvailable);
            }
        }

        //
        // HACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we 
        // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
        // appeared first on NTFS5 volumes, at the same time sparse file support 
        // was implemented.
        //
        if (pMtPt->IsSupportingSparseFile())
        {
            // yup, we are on NTFS 5 or greater
            pdpsp->fIsIndexAvailable = TRUE;

            if (pMtPt->IsContentIndexed())
            {
                pdpsp->asInitial.fIndex = TRUE;
            }
        }
    }
    else
    {
        // if we don't have a mount point, we just leave everything alone
    }

    // Set the inital state of the compression / content index checkboxes
    if (!pdpsp->fIsCompressionAvailable)
    {
        // file-based compression is not supported
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDD_COMPRESS));
    }
    else
    {
        CheckDlgButton(pdpsp->hDlg, IDD_COMPRESS, pdpsp->asInitial.fCompress);
    }

    if (!pdpsp->fIsIndexAvailable)
    {
        // content index is only supported on NTFS 5 volumes
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDD_INDEX));
    }
    else
    {
        CheckDlgButton(pdpsp->hDlg, IDD_INDEX, pdpsp->asInitial.fIndex);
    }
}

void _DrvPrshtSetFileSystem(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szFileSystem[64];

    szFileSystem[0] = TEXT('\0');

    if (pMtPt)
    {
        if (!pMtPt->GetFileSystemName(szFileSystem, ARRAYSIZE(szFileSystem)) ||
            (*szFileSystem == TEXT('\0')))
        {
            if ((pMtPt->IsStrictRemovable() || pMtPt->IsFloppy() || pMtPt->IsCDROM()) &&
                !pMtPt->HasMedia())
            {
                // if this drive has removable media and it is empty, then fall back to "Unknown"
                LoadString(HINST_THISDLL, IDS_FMT_MEDIA0, szFileSystem, ARRAYSIZE(szFileSystem));
            }
            else
            {
                // for fixed drives, leave the text as "RAW" (set by default in dlg template)
                szFileSystem[0] = TEXT('\0');
            }
        }
    }

    if (*szFileSystem)
    {
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_FS, szFileSystem);
    }    
}

void _DrvPrshtSetVolumeLabel(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szLabel[MAX_LABEL_NTFS + 1];
    UINT cchLabel = MAX_LABEL_FAT;  // assume the drive is FAT
    HWND hwndLabel = GetDlgItem(pdpsp->hDlg, IDC_DRV_LABEL);
    BOOL bAllowRename = TRUE;
    HRESULT hr = E_FAIL;

    szLabel[0] = TEXT('\0');

    if (pMtPt)
    {
        hr = pMtPt->GetLabelNoFancy(szLabel, ARRAYSIZE(szLabel));

        if (pMtPt->IsRemote() || 
            (pMtPt->IsCDROM() && !pMtPt->IsDVDRAMMedia()))
        {
            // ISSUE-2000/10/30-StephStm We probably want to distinguish between diff types of cdrom drives
            bAllowRename = FALSE;
        }
        
        if ( !bAllowRename && pMtPt->IsCDROM( ) )
        {
            //
            //  Check to see if it is CDFS, if not, make no assumptions about
            //  writing the label.
            //

            WCHAR szFS[ 10 ];   // random - just more than "CDFS\0"
            BOOL b = pMtPt->GetFileSystemName( szFS, ARRAYSIZE(szFS) );
            if (b && lstrcmpi(szFS, L"CDFS") != 0 ) 
            {
                //  Re-enable the label as we don't know if the FS doesn't support this
                //  until we actually try it.
                bAllowRename = TRUE;
            }
        }

        if (pMtPt->IsNTFS())
        {
            cchLabel = MAX_LABEL_NTFS;
        }
    }
    
    SetWindowText(hwndLabel, szLabel);

    if (FAILED(hr) || !bAllowRename)
    {
        Edit_SetReadOnly(hwndLabel, TRUE);
    }
    
    // limit the "Label" edit box based on the filesystem
    Edit_LimitText(hwndLabel, cchLabel);
    
    // make sure we don't recieve an EN_CHANGED message for the volume edit box
    // because we set it above
    Edit_SetModify(hwndLabel, FALSE);
}

void _DrvPrshtSetDriveType(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szDriveType[80];

    szDriveType[0] = TEXT('\0');

    if (pMtPt)
    {
        if (pMtPt->IsUnavailableNetDrive())
        {
            LoadString(HINST_THISDLL, IDS_DRIVES_NETUNAVAIL, szDriveType, ARRAYSIZE(szDriveType));
        }
        else
        {
            pMtPt->GetTypeString(szDriveType, ARRAYSIZE(szDriveType));
        }
    }

    SetDlgItemText(pdpsp->hDlg, IDC_DRV_TYPE, szDriveType);
}

void _DrvPrshtSetDriveLetter(DRIVEPROPSHEETPAGE* pdpsp)
{
    TCHAR szDriveLetterText[80];
    TCHAR szFormat[80];

    if (pdpsp->fMountedDrive)
    {
        TCHAR szLabel[MAX_LABEL_NTFS + 1];

        if (GetDlgItemText(pdpsp->hDlg, IDC_DRV_LABEL, szLabel, ARRAYSIZE(szLabel)))
        {
            LoadString(HINST_THISDLL, IDS_VOLUMELABEL, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szDriveLetterText, ARRAYSIZE(szDriveLetterText), szFormat, szLabel);
            SetDlgItemText(pdpsp->hDlg, IDC_DRV_LETTER, szDriveLetterText);
        }
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_DRIVELETTER, szFormat, ARRAYSIZE(szFormat));
        wnsprintf(szDriveLetterText, ARRAYSIZE(szDriveLetterText), szFormat, pdpsp->iDrive + TEXT('A'));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_LETTER, szDriveLetterText);
    }
}

void _DrvPrshtSetDiskCleanup(DRIVEPROPSHEETPAGE* pdpsp)
{
    // if we have a cleanup path in the registry, turn on the Disk Cleanup button on
    // NOTE: disk cleanup and mounted volumes don't get along to well, so disable it for now.
    if (!pdpsp->fMountedDrive && GetDiskCleanupPath(NULL, 0) && IsBitBucketableDrive(pdpsp->iDrive))
    {
        ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), SW_SHOW);
        EnableWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), TRUE);
    }
    else
    {
        ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), SW_HIDE);
        EnableWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), FALSE);
    }
}

void _DrvPrshtInit(DRIVEPROPSHEETPAGE* pdpsp)
{
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get the MountPoint object for this drive
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);
    if ( !pMtPt )
    {
        pMtPt = CMountPoint::GetSimulatedMountPointFromVolumeGuid( pdpsp->szDrive );
    }

    _DrvPrshtGetPieShadowHeight(pdpsp);
    _DrvPrshtSetDriveIcon(pdpsp, pMtPt);
    _DrvPrshtSetDriveAttributes(pdpsp, pMtPt);
    _DrvPrshtSetFileSystem(pdpsp, pMtPt);
    _DrvPrshtSetVolumeLabel(pdpsp, pMtPt);
    _DrvPrshtSetDriveType(pdpsp, pMtPt);
    _DrvPrshtSetSpaceValues(pdpsp);
    _DrvPrshtSetDriveLetter(pdpsp);
    _DrvPrshtSetDiskCleanup(pdpsp);

    SetCursor(hcurOld);

    if (pMtPt)
    {
        pMtPt->Release();
    }
}

void _DrvPrshtUpdateInfo(DRIVEPROPSHEETPAGE* pdpsp)
{
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);

    _DrvPrshtSetSpaceValues(pdpsp);
    _DrvPrshtSetDriveType(pdpsp, pMtPt);

    if (pMtPt)
    {
        pMtPt->Release();
    }
}

const COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),      // Blue
    RGB(255,   0, 255),      // Red-Blue
    RGB(  0,   0, 128),      // 1/2 Blue
    RGB(128,   0, 128),      // 1/2 Red-Blue
};

STDAPI Draw3dPie(HDC hdc, RECT *prc, DWORD dwPer1000, const COLORREF *lpColors);
        
void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc)
{
    HBRUSH hbDraw = CreateSolidBrush(crDraw);
    if (hbDraw)
    {
        HBRUSH hbOld = (HBRUSH)SelectObject(hdc, hbDraw);
        if (hbOld)
        {
            PatBlt(hdc, prc->left, prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                PATCOPY);
            
            SelectObject(hdc, hbOld);
        }
        
        DeleteObject(hbDraw);
    }
}

void _DrvPrshtDrawItem(DRIVEPROPSHEETPAGE *pdpsp, const DRAWITEMSTRUCT * lpdi)
{
    switch (lpdi->CtlID)
    {
    case IDC_DRV_PIE:
        {
            DWORD dwPctX10 = pdpsp->qwTot ?
                (DWORD)((__int64)1000 * (pdpsp->qwTot - pdpsp->qwFree) / pdpsp->qwTot) : 
                1000;
#if 1
            DrawPie(lpdi->hDC, &lpdi->rcItem,
                dwPctX10, pdpsp->qwFree==0 || pdpsp->qwFree==pdpsp->qwTot,
                pdpsp->dwPieShadowHgt, c_crPieColors);
#else
            {
                RECT rcTemp = lpdi->rcItem;
                Draw3dPie(lpdi->hDC, &rcTemp, dwPctX10, c_crPieColors);
            }
#endif
        }
        break;
        
    case IDC_DRV_USEDCOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_USEDCOLOR], &lpdi->rcItem);
        break;
        
    case IDC_DRV_FREECOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_FREECOLOR], &lpdi->rcItem);
        break;
        
    default:
        break;
    }
}

BOOL_PTR CALLBACK DriveAttribsDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE* pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlgRecurse, DWLP_USER);
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        {
            TCHAR szTemp[MAX_PATH];
            TCHAR szAttribsToApply[MAX_PATH];
            TCHAR szDriveText[MAX_PATH];
            TCHAR szFormatString[MAX_PATH];
            TCHAR szDlgText[MAX_PATH];
            int iLength;

            SetWindowLongPtr(hDlgRecurse, DWLP_USER, lParam);
            pdpsp = (DRIVEPROPSHEETPAGE *)lParam;

            // set the initial state of the radio button
            CheckDlgButton(hDlgRecurse, IDD_RECURSIVE, TRUE);
        
            szAttribsToApply[0] = 0;

            // set the IDD_ATTRIBSTOAPPLY based on what attribs we are applying
            if (pdpsp->asInitial.fIndex != pdpsp->asCurrent.fIndex)
            {
                if (pdpsp->asCurrent.fIndex)
                    LoadString(HINST_THISDLL, IDS_INDEX, szTemp, ARRAYSIZE(szTemp)); 
                else
                    LoadString(HINST_THISDLL, IDS_DISABLEINDEX, szTemp, ARRAYSIZE(szTemp)); 

                lstrcatn(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
            }

            if (pdpsp->asInitial.fCompress != pdpsp->asCurrent.fCompress)
            {
                if (pdpsp->asCurrent.fCompress)
                    LoadString(HINST_THISDLL, IDS_COMPRESS, szTemp, ARRAYSIZE(szTemp)); 
                else
                    LoadString(HINST_THISDLL, IDS_UNCOMPRESS, szTemp, ARRAYSIZE(szTemp)); 

                lstrcatn(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
            }

            // remove the trailing ", "
            iLength = lstrlen(szAttribsToApply);
            ASSERT(iLength >= 3);
            szAttribsToApply[iLength - 2] = 0;

            SetDlgItemText(hDlgRecurse, IDD_ATTRIBSTOAPPLY, szAttribsToApply);

            // this dialog was only designed for nice short paths like "c:\" not "\\?\Volume{GUID}\" paths
            if (lstrlen(pdpsp->szDrive) > 3)
            {
                // get the default string
                LoadString(HINST_THISDLL, IDS_THISVOLUME, szDriveText, ARRAYSIZE(szDriveText));
            }
            else
            {
                // Create the string "C:\"
                lstrcpyn(szDriveText, pdpsp->szDrive, ARRAYSIZE(szDriveText));
                PathAddBackslash(szDriveText);

                // sanity check; this better be a drive root!
                ASSERT(PathIsRoot(szDriveText));
            }
        
            // set the IDD_RECURSIVE_TXT text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szFormatString, ARRAYSIZE(szFormatString));
            wnsprintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szDlgText);

            // set the IDD_NOTRECURSIVE raido button text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            wnsprintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szDlgText);

            // set the IDD_RECURSIVE raido button text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            wnsprintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szDlgText);
        }
        break;

    case WM_COMMAND:
        {
            UINT uID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uID)
            {
            case IDOK:
                pdpsp->fRecursive = (IsDlgButtonChecked(hDlgRecurse, IDD_RECURSIVE) == BST_CHECKED);
                // fall through
            case IDCANCEL:
                EndDialog(hDlgRecurse, (uID == IDCANCEL) ? FALSE : TRUE);
                break;
            }
        }

    default:
        return FALSE;
    }
    return TRUE;
}


BOOL _DrvPrshtApply(DRIVEPROPSHEETPAGE* pdpsp)
{
    BOOL bFctRet;
    HWND hCtl;

    // take care of compression / content indexing first
    pdpsp->asCurrent.fCompress = (IsDlgButtonChecked(pdpsp->hDlg, IDD_COMPRESS) == BST_CHECKED);
    pdpsp->asCurrent.fIndex = (IsDlgButtonChecked(pdpsp->hDlg, IDD_INDEX) == BST_CHECKED);
    pdpsp->asCurrent.fRecordingEnabled = (IsDlgButtonChecked(pdpsp->hDlg, IDC_RECORD_ENABLE) == BST_CHECKED);

    // check to see if something has changed before applying attribs
    if (memcmp(&pdpsp->asInitial, &pdpsp->asCurrent, sizeof(pdpsp->asInitial)) != 0)
    {
        // the user toggled the attributes, so ask them if they want to recurse
        BOOL_PTR bRet = DialogBoxParam(HINST_THISDLL, 
                              MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                              pdpsp->hDlg,
                              DriveAttribsDlgProc,
                              (LPARAM)pdpsp);
        if (bRet)
        {
            FILEPROPSHEETPAGE fpsp = {0};

            fpsp.pfci = Create_FolderContentsInfo();
            if (fpsp.pfci)
            {
                // we cook up a fpsp and call ApplySingleFileAttributes instead of 
                // rewriting the apply attributes code
                if (pdpsp->fMountedDrive)
                {
                    GetVolumeNameForVolumeMountPoint(pdpsp->szDrive, fpsp.szPath, ARRAYSIZE(fpsp.szPath));
                }
                else
                {
                    lstrcpyn(fpsp.szPath, pdpsp->szDrive, ARRAYSIZE(fpsp.szPath));
                }

                fpsp.hDlg = pdpsp->hDlg;
                fpsp.asInitial = pdpsp->asInitial;
                fpsp.asCurrent = pdpsp->asCurrent;
                fpsp.pfci->fIsCompressionAvailable = pdpsp->fIsCompressionAvailable;
                fpsp.pfci->ulTotalNumberOfBytes.QuadPart = pdpsp->qwTot - pdpsp->qwFree; // for progress calculations
                fpsp.fIsIndexAvailable = pdpsp->fIsIndexAvailable;
                fpsp.fRecursive = pdpsp->fRecursive;
                fpsp.fIsDirectory = TRUE;
            
                bRet = ApplySingleFileAttributes(&fpsp);

                Release_FolderContentsInfo(fpsp.pfci);
                fpsp.pfci = NULL;

                // update the free/used space after applying attribs because something could
                // have changed (eg compression frees up space)
                _DrvPrshtUpdateInfo(pdpsp);

                // update the initial attributes to reflect the ones we just applied, regardless
                // if the operation was sucessful or not. If they hit cancel, then the volume
                // root was most likely still changed so we need to update.
                pdpsp->asInitial = pdpsp->asCurrent;
            }
            else
            {
                bRet = FALSE;
            }
        }

        if (!bRet)
        {
            // the user hit cancel somewhere
            return FALSE;
        }
    }

    hCtl = GetDlgItem(pdpsp->hDlg, IDC_DRV_LABEL);

    bFctRet = TRUE;

    if (Edit_GetModify(hCtl))
    {
        bFctRet = FALSE;    // assume we fail to set the label

        TCHAR szLabel[MAX_LABEL_NTFS + 1];
        GetWindowText(hCtl, szLabel, ARRAYSIZE(szLabel));

        CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);

        if ( !pMtPt )
        {
            pMtPt = CMountPoint::GetSimulatedMountPointFromVolumeGuid( pdpsp->szDrive );
        }

        if (pMtPt)
        {
            if (SUCCEEDED(pMtPt->SetLabel(GetParent(pdpsp->hDlg), szLabel)))
                bFctRet = TRUE;

            pMtPt->Release();
        }
    }

    return bFctRet;
}

const static DWORD aDrvPrshtHelpIDs[] = {  // Context Help IDs
    IDC_DRV_ICON,          IDH_FCAB_DRV_ICON,
    IDC_DRV_LABEL,         IDH_FCAB_DRV_LABEL,
    IDC_DRV_TYPE_TXT,      IDH_FCAB_DRV_TYPE,
    IDC_DRV_TYPE,          IDH_FCAB_DRV_TYPE,
    IDC_DRV_FS_TXT,        IDH_FCAB_DRV_FS,
    IDC_DRV_FS,            IDH_FCAB_DRV_FS,
    IDC_DRV_USEDCOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREECOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_TOTSEP,        NO_HELP,
    IDC_DRV_TOTBYTES_TXT,  IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTBYTES,      IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTMB,         IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_PIE,           IDH_FCAB_DRV_PIE,
    IDC_DRV_LETTER,        IDH_FCAB_DRV_LETTER,
    IDC_DRV_CLEANUP,       IDH_FCAB_DRV_CLEANUP,
    IDD_COMPRESS,          IDH_FCAB_DRV_COMPRESS,
    IDD_INDEX,             IDH_FCAB_DRV_INDEX,
    0, 0
};

//
// Descriptions:
//   This is the dialog procedure for the "general" page of a property sheet.
//
BOOL_PTR CALLBACK _DrvGeneralDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) 
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdpsp = (DRIVEPROPSHEETPAGE *)lParam;
        pdpsp->hDlg = hDlg;
        _DrvPrshtInit(pdpsp);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(hDlg, IDC_DRV_ICON, NULL);   // free the icon
        break;

    case WM_ACTIVATE:
        if (GET_WM_ACTIVATE_STATE(wParam, lParam) != WA_INACTIVE && pdpsp)
            _DrvPrshtUpdateInfo(pdpsp);
        return FALSE;   // Let DefDlgProc know we did not handle this

    case WM_DRAWITEM:
        _DrvPrshtDrawItem(pdpsp, (DRAWITEMSTRUCT *)lParam);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aDrvPrshtHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aDrvPrshtHelpIDs);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DRV_LABEL:
            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE)
                break;
            // else, fall through
        case IDD_COMPRESS:
        case IDD_INDEX:
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        // handle disk cleanup button      
        case IDC_DRV_CLEANUP:
            LaunchDiskCleanup(hDlg, pdpsp->iDrive, DISKCLEANUP_NOFLAG);
            break;

        default:
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            if (!_DrvPrshtApply(pdpsp))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


void _DiskToolsPrshtInit(DRIVEPROPSHEETPAGE * pdpsp)
{
    TCHAR szFmt[MAX_PATH + 20];
    DWORD cbLen = sizeof(szFmt);

    BOOL bFoundBackup = SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, REL_KEY_BACKUP, NULL, NULL, szFmt, &cbLen));
    // If no backup utility is installed, then remove everything in the backup groupbox
    if (!bFoundBackup)
    {
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPNOW));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPICON));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPDAYS));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPTXT));
    }

    cbLen = sizeof(szFmt);
    BOOL bFoundFmt = SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, REL_KEY_DEFRAG, NULL, NULL, szFmt, &cbLen)) && szFmt[0];
    // If no defrag utility is installed, replace the default defrag text with
    // the "No defrag installed" message.  Also grey out the "defrag now" button.
    if (!bFoundFmt)
    {
        TCHAR szMessage[50];  // WARNING:  IDS_DRIVES_NOOPTINSTALLED is currently 47
        //           characters long.  Resize this buffer if
        //           the string resource is lengthened.
        
        LoadString(HINST_THISDLL, IDS_DRIVES_NOOPTINSTALLED, szMessage, ARRAYSIZE(szMessage));
        SetDlgItemText(pdpsp->hDlg, IDC_DISKTOOLS_OPTDAYS, szMessage);
        Button_Enable(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_OPTNOW), FALSE);
    }
}

const static DWORD aDiskToolsHelpIDs[] = {  // Context Help IDs
    IDC_DISKTOOLS_TRLIGHT,    IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_CHKDAYS,    IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_CHKNOW,     IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_BKPTXT,     IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_BKPDAYS,    IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_BKPNOW,     IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_OPTDAYS,    IDH_FCAB_DISKTOOLS_OPTNOW,
    IDC_DISKTOOLS_OPTNOW,     IDH_FCAB_DISKTOOLS_OPTNOW,

    0, 0
};

BOOL _DiskToolsCommand(DRIVEPROPSHEETPAGE * pdpsp, WPARAM wParam, LPARAM lParam)
{
    // Add 20 for extra formatting
    TCHAR szFmt[MAX_PATH + 20];
    TCHAR szCmd[MAX_PATH + 20];
    LPCTSTR pszRegName, pszDefFmt;
    int nErrMsg = 0;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_DISKTOOLS_CHKNOW:
            SHChkDskDriveEx(pdpsp->hDlg, pdpsp->szDrive);
            return FALSE;

        case IDC_DISKTOOLS_OPTNOW:
            pszRegName = REL_KEY_DEFRAG;
            if (pdpsp->fMountedDrive)
            {
                pszDefFmt = TEXT("defrag.exe");
            }
            else
            {
                pszDefFmt = TEXT("defrag.exe %c:");
            }
            nErrMsg =  IDS_NO_OPTIMISE_APP;
            break;

        case IDC_DISKTOOLS_BKPNOW:
            pszRegName = REL_KEY_BACKUP;
            pszDefFmt = TEXT("ntbackup.exe");
            nErrMsg = IDS_NO_BACKUP_APP;
            break;

        default:
            return FALSE;
    }

    DWORD cbLen = sizeof(szFmt);
    if (FAILED(SKGetValue(SHELLKEY_HKLM_EXPLORER, pszRegName, NULL, NULL, szFmt, &cbLen)))
    {
        // failed to read out the reg value, just use the default
        lstrcpy(szFmt, pszDefFmt);
    }

    // some apps write REG_SZ keys to the registry even though they have env variables in them
    ExpandEnvironmentStrings(szFmt, szCmd, ARRAYSIZE(szCmd));
    lstrcpyn(szFmt, szCmd, ARRAYSIZE(szFmt));

    // Plug in the drive letter in case they want it
    wnsprintf(szCmd, ARRAYSIZE(szCmd), szFmt, pdpsp->iDrive + TEXT('A'));

    if (!ShellExecCmdLine(pdpsp->hDlg,
                          szCmd,
                          NULL,
                          SW_SHOWNORMAL,
                          NULL,
                          SECL_USEFULLPATHDIR | SECL_NO_UI))
    {
        // Something went wrong - app's probably not installed.
        if (nErrMsg)
        {
            ShellMessageBox(HINST_THISDLL,
                            pdpsp->hDlg,
                            MAKEINTRESOURCE(nErrMsg), NULL,
                            MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        }
        return FALSE;
    }

    return TRUE;
}

//
// Descriptions:
//   This is the dialog procedure for the "Tools" page of a property sheet.
//
BOOL_PTR CALLBACK _DiskToolsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) 
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdpsp = (DRIVEPROPSHEETPAGE *)lParam;
        pdpsp->hDlg = hDlg;

        _DiskToolsPrshtInit(pdpsp);
        break;

    case WM_ACTIVATE:
        if (GET_WM_ACTIVATE_STATE(wParam, lParam) != WA_INACTIVE && pdpsp)
        {
            _DiskToolsPrshtInit(pdpsp);
        }
        return FALSE;   // Let DefDlgProc know we did not handle this

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aDiskToolsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aDiskToolsHelpIDs);
        break;

    case WM_COMMAND:
        return _DiskToolsCommand(pdpsp, wParam, lParam);

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            return TRUE;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
// This is the dialog procedure for the "Hardware" page.
//

const GUID c_rgguidDevMgr[] = 
{
    { 0x4d36e967, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_DISKDRIVE
    { 0x4d36e980, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_FLOPPYDISK
    { 0x4d36e965, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_CDROM
};

BOOL_PTR CALLBACK _DriveHWDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage) 
    {
    case WM_INITDIALOG:
        {
            DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)lParam;

            HWND hwndHW = DeviceCreateHardwarePageEx(hDlg, c_rgguidDevMgr, ARRAYSIZE(c_rgguidDevMgr), HWTAB_LARGELIST);
            if (hwndHW) 
            {
                TCHAR szBuf[MAX_PATH];
                LoadString(HINST_THISDLL, IDS_DRIVETSHOOT, szBuf, ARRAYSIZE(szBuf));
                SetWindowText(hwndHW, szBuf);

                LoadString(HINST_THISDLL, IDS_THESEDRIVES, szBuf, ARRAYSIZE(szBuf));
                SetDlgItemText(hwndHW, IDC_HWTAB_LVSTATIC, szBuf);
            } 
            else 
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }
    return FALSE;
}



BOOL CDrives_AddPage(LPPROPSHEETPAGE ppsp, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    BOOL fSuccess;
    HPROPSHEETPAGE hpage = CreatePropertySheetPage(ppsp);
    if (hpage)
    {
        fSuccess = pfnAddPage(hpage, lParam);
        if (!fSuccess)
        {   // Couldn't add page
            DestroyPropertySheetPage(hpage);
            fSuccess = FALSE;
        }
    }
    else
    {   // Couldn't create page
        fSuccess = FALSE;
    }
    return fSuccess;
}


HRESULT CDrives_AddPagesHelper(DRIVEPROPSHEETPAGE* pdpsp, int iType,
                               LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    if ((iType == DRIVE_NO_ROOT_DIR) ||
        (iType == DRIVE_REMOTE))
    {
        return S_OK;
    }
    
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);
    if (pMtPt)
    {
        if (IsShellServiceRunning())
        {
            if (pMtPt->IsStrictRemovable() || pMtPt->IsCDROM() ||
                (pMtPt->IsFixedDisk() && pMtPt->IsRemovableDevice()))
            {
                CAutoPlayDlg* papdlg = new CAutoPlayDlg();

                if (papdlg)
                {
                    // Autoplay
                    pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_AUTOPLAY);
                    pdpsp->psp.pfnDlgProc  = CAutoPlayDlg::BaseDlgWndProc;
                    pdpsp->psp.pfnCallback = CBaseDlg::BaseDlgPropSheetCallback;
                    pdpsp->psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

                    papdlg->Init(pdpsp->szDrive, iType);
                    // for now
                    pdpsp->psp.lParam = (LPARAM)(CBaseDlg*)papdlg;

                    if (CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam))
                    {
                        papdlg->AddRef();
                    }

                    pdpsp->psp.lParam = NULL;
                    pdpsp->psp.pfnCallback = NULL;
                    pdpsp->psp.dwFlags = NULL;

                    papdlg->Release();
                }
            }
        }

        if ((iType != DRIVE_CDROM) || pMtPt->IsDVDRAMMedia())
        {
            // we add the tools page for non-cdrom and DVD-RAM disks
            pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_DISKTOOLS);
            pdpsp->psp.pfnDlgProc  = _DiskToolsDlgProc;

            CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam);
        }

        pMtPt->Release();
    }

    if (!SHRestricted(REST_NOHARDWARETAB))
    {           
        pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_HWTAB);
        pdpsp->psp.pfnDlgProc  = _DriveHWDlgProc;
        CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam);
    }

    return S_OK;
}

//
// We check if any of the IDList's points to a drive root.  If so, we use the
// drives property page.
// Note that drives should not be mixed with folders and files, even in a
// search window.
//
STDAPI CDrives_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        TCHAR szPath[MAX_PATH];
        int i, cItems = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);

        for (i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
        {
            DRIVEPROPSHEETPAGE dpsp = {0};
            TCHAR szTitle[80];

            if (lstrlen(szPath) > 3)
                continue;               // can't be a drive letter
            
            dpsp.psp.dwSize      = sizeof(dpsp);    // extra data
            dpsp.psp.dwFlags     = PSP_DEFAULT;
            dpsp.psp.hInstance   = HINST_THISDLL;
            dpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_GENERAL);
            dpsp.psp.pfnDlgProc  = _DrvGeneralDlgProc,
            lstrcpyn(dpsp.szDrive, szPath, ARRAYSIZE(dpsp.szDrive));
            dpsp.iDrive          = DRIVEID(szPath);

            // if more than one drive selected give each tab the title of the drive
            // otherwise use "General"

            if (cItems > 1)
            {
                CMountPoint* pMtPt = CMountPoint::GetMountPoint(dpsp.iDrive);
                if (pMtPt)
                {
                    dpsp.psp.dwFlags = PSP_USETITLE;
                    dpsp.psp.pszTitle = szTitle;

                    pMtPt->GetDisplayName(szTitle, ARRAYSIZE(szTitle));

                    pMtPt->Release();
                }
            }

            if (!CDrives_AddPage(&dpsp.psp, pfnAddPage, lParam))
                break;

            // if only one property page added add the disk tools
            // and Hardware tab too...
            if (cItems == 1)
            {
                CDrives_AddPagesHelper(&dpsp,
                                       RealDriveType(dpsp.iDrive, FALSE /* fOKToHitNet */),
                                       pfnAddPage,
                                       lParam);
            }
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        // try mounteddrive
        fmte.cfFormat = g_cfMountedVolume;

        // Can we retrieve the MountedVolume format?
        if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
        {
            // Yes
            DRIVEPROPSHEETPAGE dpsp = {0};
            HPROPSHEETPAGE hpage;
            TCHAR szMountPoint[MAX_PATH];

            dpsp.psp.dwSize      = sizeof(dpsp);    // extra data
            dpsp.psp.dwFlags     = PSP_DEFAULT;
            dpsp.psp.hInstance   = HINST_THISDLL;
            dpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_GENERAL);
            dpsp.psp.pfnDlgProc  = _DrvGeneralDlgProc,
            dpsp.iDrive          = -1;
            dpsp.fMountedDrive   = TRUE;

            DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint));

            lstrcpyn(dpsp.szDrive, szMountPoint, ARRAYSIZE(dpsp.szDrive));

            hpage = CreatePropertySheetPage(&dpsp.psp);
            if (hpage)
            {
                if (!pfnAddPage(hpage, lParam))
                {
                    DestroyPropertySheetPage(hpage);
                }
            }

            // Disk tools page
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(szMountPoint);
            if (pMtPt)
            {
                CDrives_AddPagesHelper(&dpsp, GetDriveType(szMountPoint),
                               pfnAddPage, lParam);
                pMtPt->Release();
            }

            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drivxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "pidl.h"
#include "ids.h"
#include "drives.h"
#include "mtpt.h"
#include "shitemid.h"
#include "xiconwrap.h"
#include "hwcmmn.h"

// From drivfldr.cpp
int _GetSHID(int iDrive);

class CDrvExtIconBase : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    HRESULT _Init(LPCWSTR pszDrive)
    {
        _pszDrive = StrDup(pszDrive);
        return _pszDrive ? S_OK : E_OUTOFMEMORY;
    }

    CDrvExtIconBase() : CExtractIconBase(), _pszDrive(NULL) {}

protected:
    ~CDrvExtIconBase();

private:
    LPWSTR _pszDrive;
};

CDrvExtIconBase::~CDrvExtIconBase()
{
    LocalFree((HLOCAL)_pszDrive);   // accepts NULL
}


STDAPI SHCreateDrvExtIcon(LPCWSTR pszDrive, REFIID riid, void **ppv)
{
    HRESULT hr;
    CDrvExtIconBase* pdeib = new CDrvExtIconBase();
    if (pdeib)
    {
        hr = pdeib->_Init(pszDrive);
        if (SUCCEEDED(hr))
            hr = pdeib->QueryInterface(riid, ppv);
        pdeib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDrvExtIconBase::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
    UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_OK;
    pszIconFile[0] = 0;

    if (uFlags & GIL_DEFAULTICON)
    {
        *piIndex = CMountPoint::GetSuperPlainDriveIcon(_pszDrive,
            GetDriveType(_pszDrive));

        lstrcpyn(pszIconFile, TEXT("shell32.dll"), cchMax);

        *pwFlags = GIL_PERCLASS;

        // Make sure our default icon makes it to the cache
        Shell_GetCachedImageIndex(c_szShell32Dll, *piIndex, *pwFlags);
    }
    else
    {
        if (!(uFlags & GIL_ASYNC))
        {
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(_pszDrive);

            if (pmtpt)
            {
                *piIndex = pmtpt->GetIcon(pszIconFile, cchMax);

                if (!*pszIconFile)
                {
                    GetModuleFileName(HINST_THISDLL, pszIconFile, cchMax);
                }

                pmtpt->StoreIconForUpdateImage(Shell_GetCachedImageIndex(
                    pszIconFile, *piIndex, 0));

                pmtpt->Release();
            }
            else
            {
                *piIndex = CMountPoint::GetSuperPlainDriveIcon(_pszDrive,
                    GetDriveType(_pszDrive));

                lstrcpyn(pszIconFile, TEXT("shell32.dll"), cchMax);
            }

            *pwFlags = GIL_PERCLASS;
        }
        else
        {
            hr = E_PENDING;
        }
    }

    return hr;
}

HRESULT CDrvExtIconBase::_ExtractW(LPCWSTR pszFile, UINT nIconIndex,
    HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    return SHDefExtractIcon(pszFile, nIconIndex, GIL_PERCLASS, phiconLarge,
            phiconSmall, nIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duidrag.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duidrag.h"


CDUIDropTarget::CDUIDropTarget()
{
    _cRef = 1;
    _pDT = NULL;
    _pNextDT = NULL;
}

CDUIDropTarget::~CDUIDropTarget()
{
    _Cleanup();
}

HRESULT CDUIDropTarget::QueryInterface (REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CDUIDropTarget, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

ULONG CDUIDropTarget::AddRef (void)
{
    return ++_cRef;
}

ULONG CDUIDropTarget::Release (void)
{
    if (--_cRef == 0) {
        delete this;
        return 0;
    }

    return _cRef;
}


// Called by duser / directui to get the IDropTarget interface for the element
// the mouse just moved over.  It is important to understand the sequencing
// calls.  Initialize is called BEFORE DragLeave is called on the previous element's
// IDropTarget, so we can't switch out _pDT right away.  Instead, we'll store the
// new IDropTarget in _pNextDT and then in DragEnter, we'll move it over to _pDT.
//
// The sequence looks like this:
//
//    Initialize()    for first element (bumps ref count to 2)
//    DragEnter
//    DragMove

//    Initialize()    for second element (bumps ref count to 3)
//    DragLeave       for first element
//    Release         for first element  (decrements ref count to 2)

//    DragEnter       for second element

HRESULT CDUIDropTarget::Initialize (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt)
{
    ASSERT(_pNextDT == NULL);

    if (pidl)
    {
        SHGetUIObjectFromFullPIDL(pidl, hWnd, IID_PPV_ARG(IDropTarget, &_pNextDT));
    }

    QueryInterface (IID_PPV_ARG(IDropTarget, pdt));

    return S_OK;
}

VOID CDUIDropTarget::_Cleanup ()
{
    if (_pDT)
    {
        _pDT->Release();
        _pDT = NULL;
    }
}

STDMETHODIMP CDUIDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if ((_pDT != _pNextDT) || (_cRef == 2))
    {
        _pDT = _pNextDT;
        _pNextDT = NULL;

        if (_pDT)
        {
            _pDT->DragEnter (pDataObj, grfKeyState, ptl, pdwEffect);
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }

        POINT pt;
        GetCursorPos(&pt);
        DAD_DragEnterEx2 (NULL, pt, pDataObj);
    }

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (_pDT)
    {
        _pDT->DragOver (grfKeyState, ptl, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    POINT pt;
    GetCursorPos(&pt);
    DAD_DragMove (pt);

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::DragLeave(void)
{
    if (_pDT || (_cRef == 2))
    {
        if (_pDT)
        {
            _pDT->DragLeave ();
        }

        DAD_DragLeave();
        _Cleanup();
    }

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    POINT pt = {ptl.x, ptl.y};
    HRESULT hr = S_OK;

    if (_pDT)
    {
        hr = _pDT->Drop (pDataObj, grfKeyState, ptl, pdwEffect);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\drivfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "drives.h"
#include "netview.h"
#include "propsht.h"
#include "infotip.h"
#include "mtpt.h"
#include "prop.h"
#include "defcm.h"

#include "basefvcb.h"
#include "fstreex.h"
#include "ovrlaymn.h"

#include "shitemid.h"
#include "clsobj.h"

#include "deskfldr.h"
#include "datautil.h"

#include <ntddcdrm.h>
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN
#include "ole2dup.h"

#include "category.h"
#define  EXCLUDE_COMPPROPSHEET
#include "unicpp\dcomp.h"
#undef   EXCLUDE_COMPPROPSHEET

#include "enumidlist.h"
#include <enumt.h>

#define ShowDriveInfo(_iDrive)  (!IsRemovableDrive(_iDrive))

#define CDRIVES_REGITEM_CONTROL 0
#define IDLIST_DRIVES           ((LPCITEMIDLIST)&c_idlDrives)

// These are the sort order for items in MyComputer
#define CONTROLS_SORT_INDEX             30
#define CDRIVES_REGITEM_CONTROL          0

REQREGITEM g_asDrivesReqItems[] =
{
    { &CLSID_ControlPanel, IDS_CONTROLPANEL, c_szShell32Dll, -IDI_CPLFLD, CONTROLS_SORT_INDEX, SFGAO_FOLDER | SFGAO_HASSUBFOLDER, NULL},
};


STDAPI CDriveExtractImage_Create(LPCIDDRIVE pidd, REFIID riid, void **ppvObj);


class CDrivesViewCallback;
class CDrivesFolderEnum;

class CDrivesBackgroundMenuCB : public IContextMenuCB
{
public:
    CDrivesBackgroundMenuCB(LPITEMIDLIST pidlFolder);
    ~CDrivesBackgroundMenuCB();
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    // IContextMenuCB
    STDMETHOD(CallBack) (IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    STDMETHOD(_GetHelpText) (UINT offset, BOOL bWide, LPARAM lParam, UINT cch);
    LPITEMIDLIST _pidlFolder;
    LONG         _cRef;
};

class CDrivesFolder : public CAggregatedUnknown, IShellFolder2, IPersistFolder2, IShellIconOverlay
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) 
                { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void** ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void** ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int* pIconIndex);

    STDMETHODIMP GetMaxNameLength(LPCITEMIDLIST pidlItem, UINT *pcchMax);

protected:
    CDrivesFolder(IUnknown* punkOuter);
    ~CDrivesFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    BOOL v_HandleDelete(PLONG pcRef);
    
    STDMETHODIMP CompareItemIDs(LPCIDDRIVE pidd1, LPCIDDRIVE pidd2);
    static BOOL _GetFreeSpace(LPCIDDRIVE pidd, ULONGLONG *pSize, ULONGLONG *pFree);
    static HRESULT _OnChangeNotify(LPARAM lNotification, LPCITEMIDLIST *ppidl);
    static HRESULT _GetCLSIDFromPidl(LPCIDDRIVE pidd, CLSID *pclsid);
    static HRESULT _CheckDriveType(int iDrive, LPCTSTR pszCLSID);
    static HRESULT _FindExtCLSID(int iDrive, CLSID *pclsid);
    static HRESULT _FillIDDrive(DRIVE_IDLIST *piddl, int iDrive, BOOL fNoCLSID, IBindCtx* pbc);
    static LPCIDDRIVE _IsValidID(LPCITEMIDLIST pidl);
    static HRESULT _GetDisplayNameStrRet(LPCIDDRIVE pidd, STRRET *pStrRet);
    static HRESULT _GetDisplayName(LPCIDDRIVE pidd, LPTSTR pszName, UINT cchMax);
    static HRESULT _CreateFSFolderObj(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv);
    static HRESULT _CreateFSFolder(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv);
    static HRESULT _GetEditTextStrRet(LPCIDDRIVE pidd, STRRET *pstr);
    static BOOL _IsReg(LPCIDDRIVE pidd) { return pidd->bFlags == SHID_COMPUTER_REGITEM; }
    static HRESULT _GetIconOverlayInfo(LPCIDDRIVE pidd, int *pIndex, DWORD dwFlags);

    static CDrivesFolder* _spThis;
    
private:
    friend HRESULT CDrives_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
    friend void CDrives_Terminate(void);

    friend CDrivesViewCallback;
    friend class CDrivesFolderEnum;

    IUnknown* _punkReg;
};  

#define DRIVES_EVENTS \
    SHCNE_DRIVEADD | \
    SHCNE_DRIVEREMOVED | \
    SHCNE_MEDIAINSERTED | \
    SHCNE_MEDIAREMOVED | \
    SHCNE_NETSHARE | \
    SHCNE_NETUNSHARE | \
    SHCNE_CREATE | \
    SHCNE_DELETE | \
    SHCNE_RENAMEITEM | \
    SHCNE_RENAMEFOLDER | \
    SHCNE_UPDATEITEM


// return S_OK if non NULL CLSID copied out

HRESULT CDrivesFolder::_GetCLSIDFromPidl(LPCIDDRIVE pidd, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;

    if ((pidd->cb >= sizeof(IDDRIVE)) &&
        ((pidd->wSig & IDDRIVE_ORDINAL_MASK) == IDDRIVE_ORDINAL_DRIVEEXT) &&
        (pidd->wSig & IDDRIVE_FLAGS_DRIVEEXT_HASCLSID))
    {
        *pclsid = pidd->clsid;
        return S_OK;
    }
    return S_FALSE;     // does not have a CLSID
}

HRESULT CDrivesFolder::GetMaxNameLength(LPCITEMIDLIST pidlItem, UINT *pcchMax)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidlItem);
    if (pidd)
    {
        if (pidd->bFlags == SHID_COMPUTER_REGITEM)
        {
            // this is bogus, we are handling stuff for regfldr
            *pcchMax = MAX_REGITEMCCH;
            hr = S_OK;
        }
        else
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
            if (pMtPt)
            {
                TCHAR szLabel[MAX_LABEL_NTFS + 1];
                hr = pMtPt->GetLabel(szLabel, ARRAYSIZE(szLabel));
                if (SUCCEEDED(hr))
                {
                    if (pMtPt->IsNTFS())
                        *pcchMax = MAX_LABEL_NTFS;
                    else
                        *pcchMax = MAX_LABEL_FAT;
                }
                pMtPt->Release();
            }
        }
    }
    return hr;
}

class CDrivesViewCallback : public CBaseShellFolderViewCB, public IFolderFilter
{
public:
    CDrivesViewCallback(CDrivesFolder *pfolder);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return CBaseShellFolderViewCB::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CBaseShellFolderViewCB::Release(); };

    // IFolderFilter
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);

private:
    ~CDrivesViewCallback();

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP)
    {
        return S_OK;
    }

    HRESULT OnInsertItem(DWORD pv, LPCITEMIDLIST wP)
    {
        LPIDDRIVE pidd = (LPIDDRIVE)wP;
        if (pidd && pidd->bFlags != SHID_COMPUTER_REGITEM)
        {
            // clear the size info
            pidd->qwSize = pidd->qwFree = 0;
        }
        return S_OK;
    }

    HRESULT OnWindowCreated(DWORD pv, HWND wP)
    {
        InitializeStatus(_punkSite);
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
    {
        if (PANE_ZONE == dwPaneID)
            *pdwPane = 2;
        return S_OK;
    }

    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pfvm)
    {
        *pfvm = FVM_TILE;
        return S_OK;
    }

    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);

    HRESULT OnUpdateStatusBar(DWORD pv, BOOL fIniting)
    {
        // Ask DefView to set the default text but not initialize
        // since we did the initialization in our OnSize handler.
        return SFVUSB_INITED;
    }

    HRESULT OnFSNotify(DWORD pv, LPCITEMIDLIST*wP, LPARAM lP)
    {
        return CDrivesFolder::_OnChangeNotify(lP, wP);
    }

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return S_OK;
    }

    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax)
    {
        return _pfolder->GetMaxNameLength(pidlItem, pcchMax);
    }

    CDrivesFolder *_pfolder;
    LONG _cRef;

public:
    // Web View Task implementations
    static HRESULT _CanEject(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSysProperties(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _OnSystemProperties(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnEject(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CDrivesViewCallback::CDrivesViewCallback(CDrivesFolder *pfolder) : 
    CBaseShellFolderViewCB((LPCITEMIDLIST)&c_idlDrives, DRIVES_EVENTS), _pfolder(pfolder), _cRef(1)
{ 
    _pfolder->AddRef();
}

CDrivesViewCallback::~CDrivesViewCallback()
{ 
    _pfolder->Release();
}


STDMETHODIMP CDrivesViewCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_INSERTITEM, OnInsertItem);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNotify);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);

    default:
        return E_FAIL;
    }

    return S_OK;
}

HRESULT CDrivesViewCallback::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = CBaseShellFolderViewCB::QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        static const QITAB qit[] = {
            QITABENT(CDrivesViewCallback, IFolderFilter),
            { 0 },
        };
        hr = QISearch(this, qit, riid, ppv);
    }
    return hr;
}

STDMETHODIMP CDrivesViewCallback::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr = S_OK;  //Assume that this item should be shown!
    
    if (SHRestricted(REST_NOMYCOMPUTERICON)) // this policy means hide my computer everywhere AND hide the contents if the user is sneaky and gets in anyway
    {
        hr = S_FALSE;
    }
    else
    {
        IShellFolder2 *psf2;
        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            // Get the GUID in the pidl, which requires IShellFolder2.
            CLSID guidItem;
            if (SUCCEEDED(GetItemCLSID(psf2, pidlItem, &guidItem)))
            {
                //Convert the guid to a string
                TCHAR   szGuidValue[MAX_GUID_STRING_LEN];
            
                SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));

                //See if this item is turned off in the registry.
                if (SHRegGetBoolUSValue(REGSTR_PATH_HIDDEN_MYCOMP_ICONS, szGuidValue, FALSE, /* default */FALSE))
                    hr = S_FALSE; //They want to hide it; So, return S_FALSE.
            }
            psf2->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDrivesViewCallback::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    return E_NOTIMPL;
}

HRESULT CDrivesViewCallback::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_DETAILS;
    return S_OK;
}


HRESULT CDrivesViewCallback::_CanAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = (SHRestricted(REST_ARP_NOARP)) ? UIS_DISABLED : UIS_ENABLED;
    return S_OK;
}
    
// Note:
//  This method is NOT designed to handle multi-select cases.  If you enhance
//  the task list and wish to multi-eject (?why?), make sure you fix this up!
//
HRESULT CDrivesViewCallback::_CanEject(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;
    IDataObject *pdo;

    // should just use the ShellItemArray directly 

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo))))
    {

        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pdo, &medium);
        if (pida)
        {
            ASSERT(pida->cidl == 1); // Only allow eject if a single item is selected.

            LPCIDDRIVE pidd = CDrivesFolder::_IsValidID(IDA_GetIDListPtr(pida, 0));
            if (pidd)
            {
                CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
                if (pmtpt)
                {
                    if (pmtpt->IsEjectable())
                        *puisState = UIS_ENABLED;
                    pmtpt->Release();
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
        }

        pdo->Release();
    }


    return S_OK;
}

HRESULT CDrivesViewCallback::_CanSysProperties(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = SHRestricted(REST_MYCOMPNOPROP) ? UIS_DISABLED : UIS_ENABLED;

    return S_OK;
}

HRESULT CDrivesViewCallback::_OnSystemProperties(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;

    return SHInvokeCommandOnPidl(pThis->_hwndMain, NULL, pThis->_pidl, 0, "properties");
}
HRESULT CDrivesViewCallback::_OnAddRemovePrograms(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    BOOL fRet = SHRunControlPanel(L"appwiz.cpl", NULL);

    return (fRet) ? S_OK : E_FAIL;
}

HRESULT CDrivesViewCallback::_CanChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = SHRestricted(REST_NOCONTROLPANEL) ? UIS_DISABLED : UIS_ENABLED;

    return S_OK;
}

HRESULT CDrivesViewCallback::_OnChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;

    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(pThis->_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_CONTROLS, NULL, 0, &pidl); 
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidl, 0);
            ILFree(pidl);
        }
        psb->Release();
    }

    return hr;

}

HRESULT CDrivesViewCallback::_OnEject(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = E_FAIL;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo))))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "eject");
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_MyComputerTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MYCOMPUTER, IDS_HEADER_MYCOMPUTER_TT);
const WVTASKITEM c_MyComputerTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL,              L"shell32.dll",  IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES, IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES_TT, IDI_TASK_PROPERTIES,CDrivesViewCallback::_CanSysProperties, CDrivesViewCallback::_OnSystemProperties),
    WVTI_ENTRY_ALL(UICID_AddRemovePrograms, L"shell32.dll",  IDS_TASK_ARP,                         IDS_TASK_ARP_TT,                         IDI_CPCAT_ARP,      CDrivesViewCallback::_CanAddRemovePrograms,   CDrivesViewCallback::_OnAddRemovePrograms),
    WVTI_ENTRY_ALL(CLSID_NULL,              L"shell32.dll",  IDS_TASK_CHANGESETTINGS,              IDS_TASK_CHANGESETTINGS_TT,              IDI_CPLFLD,         CDrivesViewCallback::_CanChangeSettings,CDrivesViewCallback::_OnChangeSettings),
    WVTI_ENTRY_TITLE(CLSID_NULL,            L"shell32.dll",  0, IDS_TASK_EJECTDISK, 0,             IDS_TASK_EJECTDISK_TT,                   IDI_STEJECT,        CDrivesViewCallback::_CanEject,         CDrivesViewCallback::_OnEject),
};

HRESULT CDrivesViewCallback::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_MyComputerTaskHeader, &(pData->pFolderTaskHeader));

    // My Computer wants a different order than the default,
    // and it doesn't want to expose "Desktop" as a place to go
    LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_NETWORK), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_CONTROLS) };
    CreateIEnumIDListOnCSIDLs(NULL, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CDrivesViewCallback::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_MyComputerTaskList, ARRAYSIZE(c_MyComputerTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}


STDAPI_(IShellFolderViewCB*) CDrives_CreateSFVCB(CDrivesFolder *pfolder)
{
    return new CDrivesViewCallback(pfolder);
}

typedef struct
{
    DWORD       dwDrivesMask;
    int         nLastFoundDrive;
    DWORD       dwRestricted;
    DWORD       dwSavedErrorMode;
    DWORD       grfFlags;
} EnumDrives;

typedef enum
{
    DRIVES_ICOL_NAME = 0,
    DRIVES_ICOL_TYPE,
    DRIVES_ICOL_CAPACITY,
    DRIVES_ICOL_FREE,
    DRIVES_ICOL_FILESYSTEM,
    DRIVES_ICOL_COMMENT,
};

const COLUMN_INFO c_drives_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             20, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,             25, IDS_TYPE_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_CAPACITY,            IDS_DRIVES_CAPACITY),
    DEFINE_COL_SIZE_ENTRY(SCID_FREESPACE,           IDS_DRIVES_FREE),
    DEFINE_COL_STR_MENU_ENTRY(SCID_FILESYSTEM,  15, IDS_DRIVES_FILESYSTEM),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          20, IDS_EXCOL_COMMENT),
};

CDrivesFolder* CDrivesFolder::_spThis = NULL;

HRESULT CDrives_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr;
    ASSERT(NULL != ppv);
    
    ENTERCRITICAL;
    if (NULL != CDrivesFolder::_spThis)
    {
        hr = CDrivesFolder::_spThis->QueryInterface(riid, ppv);
        LEAVECRITICAL;
    }
    else
    {
        LEAVECRITICAL;
        CDrivesFolder* pDF = new CDrivesFolder(punkOuter);
        if (NULL != pDF)
        {
            ASSERT(NULL == pDF->_punkReg);

            if (SHRestricted(REST_NOCONTROLPANEL) || SHRestricted(REST_NOSETFOLDERS))
                g_asDrivesReqItems[CDRIVES_REGITEM_CONTROL].dwAttributes |= SFGAO_NONENUMERATED;

            REGITEMSINFO sDrivesRegInfo =
            {
                REGSTR_PATH_EXPLORER TEXT("\\MyComputer\\NameSpace"),
                NULL,
                TEXT(':'),
                SHID_COMPUTER_REGITEM,
                -1,
                SFGAO_CANLINK,
                ARRAYSIZE(g_asDrivesReqItems),
                g_asDrivesReqItems,
                RIISA_ORIGINAL,
                NULL,
                0,
                0,
            };

            CRegFolder_CreateInstance(&sDrivesRegInfo,
                                      (IUnknown*)(IShellFolder2*) pDF,
                                      IID_PPV_ARG(IUnknown, &pDF->_punkReg));

            if (SHInterlockedCompareExchange((void**) &CDrivesFolder::_spThis, pDF, NULL))
            {
                // Someone else snuck in and initialized a CDrivesFolder first,
                // so release our object and then recurse so we should get the other instance
                pDF->Release();
                hr = CDrives_CreateInstance(punkOuter, riid, ppv);
            }
            else
            {
                hr = pDF->QueryInterface(riid, ppv);

                // release the self-reference, but keep _spThis intact
                // (it will be reset to NULL in the destructor)
                pDF->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppv = NULL;
        }
    }
    return hr;
}

// This should only be called during process detach
void CDrives_Terminate(void)
{
    if (NULL != CDrivesFolder::_spThis)
    {
        delete CDrivesFolder::_spThis;
    }
}

CDrivesFolder::CDrivesFolder(IUnknown* punkOuter) : 
    CAggregatedUnknown      (punkOuter),
    _punkReg                (NULL)
{
    DllAddRef();
}

CDrivesFolder::~CDrivesFolder()
{
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    SHInterlockedCompareExchange((void**) &CDrivesFolder::_spThis, NULL, this);
    DllRelease();
}

HRESULT CDrivesFolder::v_InternalQueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDrivesFolder, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CDrivesFolder, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CDrivesFolder, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CDrivesFolder, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENTMULTI(CDrivesFolder, IPersist, IPersistFolder2),       // IID_IPersist
        QITABENTMULTI2(CDrivesFolder, IID_IPersistFreeThreadedObject, IPersist), // IID_IPersistFreeThreadedObject
        QITABENT(CDrivesFolder, IShellIconOverlay),                    // IID_IShellIconOverlay
        { 0 },
    };
    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

BOOL CDrivesFolder::v_HandleDelete(PLONG pcRef)
{
    ASSERT(NULL != pcRef);
    ENTERCRITICAL;

    //
    //  The same bad thing can happen here as in
    //  CNetRootFolder::v_HandleDelete.  See that function for gory details.
    //
    if (this == _spThis && 0 == *pcRef)
    {
        *pcRef = 1000; // protect against cached pointers bumping us up then down
        delete this;
    }
    LEAVECRITICAL;
    // return TRUE to indicate that we've implemented this function
    // (regardless of whether or not this object was actually deleted)
    return TRUE;
}


HRESULT CDrivesFolder::_GetDisplayName(LPCIDDRIVE pidd, LPTSTR pszName, UINT cchMax)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        hr = pMtPt->GetDisplayName(pszName, cchMax);
        pMtPt->Release();
    }
    return hr;
}

HRESULT CDrivesFolder::_GetDisplayNameStrRet(LPCIDDRIVE pidd, STRRET *pStrRet)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        TCHAR szName[MAX_DISPLAYNAME];

        hr = pMtPt->GetDisplayName(szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
            hr = StringToStrRet(szName, pStrRet);

        pMtPt->Release();
    }
    return hr;
}

#define REGKEY_DRIVE_FOLDEREXT L"Drive\\shellex\\FolderExtensions"

HRESULT CDrivesFolder::_CheckDriveType(int iDrive, LPCTSTR pszCLSID)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAX_PATH];
    StrCpyN(szKey, REGKEY_DRIVE_FOLDEREXT L"\\", ARRAYSIZE(szKey));
    StrCatBuff(szKey, pszCLSID, ARRAYSIZE(szKey));

    DWORD dwDriveMask;
    DWORD cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szKey, L"DriveMask", NULL, &dwDriveMask, &cb))
    {
        TCHAR szDrive[4];
        if (PathBuildRoot(szDrive, iDrive))
        {
            int iType = GetDriveType(szDrive);
            // its possible that we're asked to parse a drive that's no longer mounted,
            // so GetDriveType will fail with DRIVE_NO_ROOT_DIR.
            // in that case, pass it on down to the handler anyway.
            // let's say it's the handler's job to remember the last drive it matched on.
            if ((DRIVE_NO_ROOT_DIR == iType) || ((1 << iType) & dwDriveMask))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CDrivesFolder::_FindExtCLSID(int iDrive, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;
    HRESULT hr = E_FAIL;

    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, REGKEY_DRIVE_FOLDEREXT, &hk))
    {
        TCHAR szCLSID[MAX_GUID_STRING_LEN];
        for (int i = 0; FAILED(hr) && (ERROR_SUCCESS == RegEnumKey(hk, i, szCLSID, ARRAYSIZE(szCLSID))); i++) 
        {
            IDriveFolderExt *pdfe;
            if (SUCCEEDED(_CheckDriveType(iDrive, szCLSID)) &&
                SUCCEEDED(SHExtCoCreateInstance(szCLSID, NULL, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe)))) 
            {
                if (SUCCEEDED(pdfe->DriveMatches(iDrive)))
                {
                    SHCLSIDFromString(szCLSID, pclsid);
                }
                pdfe->Release();
            }

            // if we successfully matched one, break out.
            if (!IsEqualCLSID(*pclsid, CLSID_NULL))
                hr = S_OK;
        }
        RegCloseKey(hk);
    }
    return hr;
}

// this is called from parse and enum, both times passing a stack var into piddl.
// we reset the cb manually and then the callers will do ILClone to allocate the correct amount
// of memory.
HRESULT CDrivesFolder::_FillIDDrive(DRIVE_IDLIST *piddl, int iDrive, BOOL fNoCLSID, IBindCtx* pbc)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    BOOL fDoIt = FALSE;
    
    ZeroMemory(piddl, sizeof(*piddl));

    PathBuildRootA(piddl->idd.cName, iDrive);

    if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
    {
        fDoIt = TRUE;
    }
    else
    {
        if (BindCtx_GetMode(pbc, 0) & STGM_CREATE)
        {
            fDoIt = TRUE;
        }
        else
        {
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

            if (pmtpt)
            {
                fDoIt = TRUE;
                pmtpt->Release();
            }
        }
    }

    if (fDoIt)
    {
        // start the cb as the IDDRIVE less the clsid at the end
        // this is so that in the usual case when we dont have a clsid, the pidl will look
        // just like all our pidls on win2k.
        piddl->idd.cb = FIELD_OFFSET(IDDRIVE, clsid);
        piddl->idd.bFlags = SHID_COMPUTER_MISC;

        if (!fNoCLSID)
        {
            CLSID clsid;

            if (SUCCEEDED(_FindExtCLSID(iDrive, &clsid)))
            {
                piddl->idd.clsid = clsid;
                // boost the cb to include the whole thing
                piddl->idd.cb = sizeof(IDDRIVE);
                // mark the flags of the pidl to say "hey im a drive extension with a clsid"
                piddl->idd.wSig = IDDRIVE_ORDINAL_DRIVEEXT | IDDRIVE_FLAGS_DRIVEEXT_HASCLSID;
            }
        }

        hr = S_OK;
    }

    ASSERT(piddl->cbNext == 0);
    return hr;
}

STDMETHODIMP CDrivesFolder::ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pwzDisplayName, 
                                             ULONG* pchEaten, LPITEMIDLIST* ppidlOut, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
    if (ppidlOut)
    {
        *ppidlOut = NULL;   // assume error

        if (pwzDisplayName && pwzDisplayName[0] && 
            pwzDisplayName[1] == TEXT(':') && pwzDisplayName[2] == TEXT('\\'))
        {
            DRIVE_IDLIST idlDrive;

            if (InRange(*pwzDisplayName, 'a', 'z') ||
                InRange(*pwzDisplayName, 'A', 'Z'))
            {
                hr = _FillIDDrive(&idlDrive, DRIVEID(pwzDisplayName), SHSkipJunctionBinding(pbc, NULL), pbc);
            }

            if (SUCCEEDED(hr))
            {
                // Check if there are any subdirs
                if (pwzDisplayName[3])
                {
                    IShellFolder *psfDrive;
                    hr = BindToObject((LPITEMIDLIST)&idlDrive, pbc, IID_PPV_ARG(IShellFolder, &psfDrive));
                    if (SUCCEEDED(hr))
                    {
                        ULONG chEaten;
                        LPITEMIDLIST pidlDir;
                        hr = psfDrive->ParseDisplayName(hwnd, pbc, pwzDisplayName + 3,
                                                        &chEaten, &pidlDir, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILCombine((LPCITEMIDLIST)&idlDrive, pidlDir, ppidlOut);
                            SHFree(pidlDir);
                        }
                        psfDrive->Release();
                    }
                }
                else
                {
                    hr = SHILClone((LPITEMIDLIST)&idlDrive, ppidlOut);
                    if (pdwAttributes && *pdwAttributes)
                        GetAttributesOf(1, (LPCITEMIDLIST *)ppidlOut, pdwAttributes);
                }
            }
        }
#if 0
        else if (0 == StrCmpNI(TEXT("\\\\?\\Volume{"), pwzDisplayName, ARRAYSIZE(TEXT("\\\\?\\Volume{"))))
        {
            //check if dealing with mounteddrive
            //something like: "\\?\Volume{9e2df3f5-c7f1-11d1-84d5-000000000000}\" (without quotes)
        }
#endif
    }

    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CDrivesFolder::ParseDisplayName(), hr:%x %ls", hr, pwzDisplayName);

    return hr;
}

BOOL IsShareable(int iDrive)
{
    return !IsRemoteDrive(iDrive);
}

class CDrivesFolderEnum : public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    
private:
    CDrivesFolderEnum(CDrivesFolder *psf, DWORD grfFlags);
    ~CDrivesFolderEnum();
    friend HRESULT Create_DrivesFolderEnum(CDrivesFolder* psf, DWORD grfFlags, IEnumIDList** ppenum);
    
    CDrivesFolder *_pdsf;     // CDrivesFolder object we're enumerating
    DWORD       _dwDrivesMask;
    int         _nLastFoundDrive;
    DWORD       _dwRestricted;
    DWORD       _dwSavedErrorMode;
    DWORD       _grfFlags;
};

CDrivesFolderEnum::CDrivesFolderEnum(CDrivesFolder *pdsf, DWORD grfFlags) : CEnumIDListBase()
{
    _pdsf = pdsf;
    _pdsf->AddRef();

    _dwDrivesMask = CMountPoint::GetDrivesMask();
    _nLastFoundDrive = -1;
    _dwRestricted = SHRestricted(REST_NODRIVES);
    _dwSavedErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    _grfFlags = grfFlags;
}

HRESULT Create_DrivesFolderEnum(CDrivesFolder *psf, DWORD grfFlags, IEnumIDList** ppenum)
{
    HRESULT hr;
    CDrivesFolderEnum* p= new CDrivesFolderEnum(psf, grfFlags);
    if (p)
    {
        hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}

CDrivesFolderEnum::~CDrivesFolderEnum()
{
    _pdsf->Release();              // release the "this" ptr we have
}

STDMETHODIMP CDrivesFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE; // assume "no more element"
    LPITEMIDLIST pidl = NULL;

    for (int iDrive = _nLastFoundDrive + 1; iDrive < 26; iDrive++)
    {
        if (_dwRestricted & (1 << iDrive))
        {
            TraceMsg(DM_TRACE, "s.cd_ecb: Drive %d restricted.", iDrive);
        }
        else if ((_dwDrivesMask & (1 << iDrive)) || IsUnavailableNetDrive(iDrive))
        {
            if (!(SHCONTF_SHAREABLE & _grfFlags) || IsShareable(iDrive))
            {
                DRIVE_IDLIST iddrive;
                hr = _pdsf->_FillIDDrive(&iddrive, iDrive, FALSE, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = SHILClone((LPITEMIDLIST)&iddrive, &pidl);
                    if (SUCCEEDED(hr))
                    {
                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);
                        if (pmtpt)
                        {
                            pmtpt->ChangeNotifyRegisterAlias();
                            pmtpt->Release();
                        }

                        _nLastFoundDrive = iDrive;                        
                    }
                    break;
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    }

    *ppidl = pidl;
    if (pceltFetched)
        *pceltFetched = (S_OK == hr) ? 1 : 0;

    return hr;
}

STDMETHODIMP CDrivesFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenum)
{
    return Create_DrivesFolderEnum(this, grfFlags, ppenum);
}

LPCIDDRIVE CDrivesFolder::_IsValidID(LPCITEMIDLIST pidl)
{
    if (pidl && (SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_COMPUTER)
        return (LPCIDDRIVE)pidl;
    return NULL;
}

HRESULT CDrivesFolder::_CreateFSFolderObj(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv)
{
    PERSIST_FOLDER_TARGET_INFO pfti = {0};

    pfti.pidlTargetFolder = (LPITEMIDLIST)pidlDrive;
    SHAnsiToUnicode(pidd->cName, pfti.szTargetParsingName, ARRAYSIZE(pfti.szTargetParsingName));
    pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
    pfti.csidl = -1;

    return CFSFolder_CreateFolder(NULL, pbc, pidlDrive, &pfti, riid, ppv);
}


HRESULT CDrivesFolder::_CreateFSFolder(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLSID clsid;
    if (S_OK == _GetCLSIDFromPidl(pidd, &clsid) && (!SHSkipJunctionBinding(pbc, NULL)))
    {
        IDriveFolderExt *pdfe;
        // SHExtCoCreateInstance since this shell extension needs to go through approval
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe));
        if (SUCCEEDED(hr))
        {
            hr = pdfe->Bind(pidlDrive, pbc, riid, ppv);
            pdfe->Release();
        }
    }
    else
    {
        hr = _CreateFSFolderObj(pbc, pidlDrive, pidd, riid, ppv);
    }
    return hr;
}


STDMETHODIMP CDrivesFolder::BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        LPCITEMIDLIST pidlNext = _ILNext(pidl);
        LPITEMIDLIST pidlDrive = ILCombineParentAndFirst(IDLIST_DRIVES, pidl, pidlNext);
        if (pidlDrive)
        {
            //  we only try ask for the riid at the end of the pidl binding.
            if (ILIsEmpty(pidlNext))
            {
                hr = _CreateFSFolder(pbc, pidlDrive, pidd, riid, ppv);
            }
            else
            {
                //  now we need to get the subfolder from which to grab our goodies
                IShellFolder *psfDrive;
                hr = _CreateFSFolder(pbc, pidlDrive, pidd, IID_PPV_ARG(IShellFolder, &psfDrive));
                if (SUCCEEDED(hr))
                {
                    //  this means that there is more to bind to, we must pass it on...
                    hr = psfDrive->BindToObject(pidlNext, pbc, riid, ppv);
                    psfDrive->Release();
                }
            }
            ILFree(pidlDrive);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CDrivesFolder::BindToObject(), bad PIDL %s", DumpPidl(pidl));
    }

    return hr;
}

STDMETHODIMP CDrivesFolder::BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

BOOL CDrivesFolder::_GetFreeSpace(LPCIDDRIVE pidd, ULONGLONG *pSize, ULONGLONG *pFree)
{
    BOOL bRet = FALSE;
    CLSID clsid;
    if (S_OK == _GetCLSIDFromPidl(pidd, &clsid))
    {
        IDriveFolderExt *pdfe;
        // SHExtCoCreateInstance since this shell extension needs to go through approval
        if (SUCCEEDED(SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe))))
        {
            bRet = SUCCEEDED(pdfe->GetSpace(pSize, pFree));
            pdfe->Release();
        }
    }

    if (!bRet && !_IsReg(pidd) && ShowDriveInfo(DRIVEID(pidd->cName)))
    {
        if (pidd->qwSize || pidd->qwFree)
        {
            *pSize = pidd->qwSize;      // cache hit
            *pFree = pidd->qwFree;
            bRet = TRUE;
        }
        else
        {
            int iDrive = DRIVEID(pidd->cName);
            // Don't wake up sleeping net connections
            if (!IsRemoteDrive(iDrive) || !IsDisconnectedNetDrive(iDrive))
            {
                // Call our helper function Who understands
                // OSR2 and NT as well as old W95...
                ULARGE_INTEGER qwFreeUser, qwTotal, qwTotalFree;
                bRet = SHGetDiskFreeSpaceExA(pidd->cName, &qwFreeUser, &qwTotal, &qwTotalFree);
                if (bRet)
                {
                    *pSize = qwTotal.QuadPart;
                    *pFree = qwFreeUser.QuadPart;
                }
            }
        }
    }
    return bRet;
}

STDMETHODIMP CDrivesFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDDRIVE pidd1 = _IsValidID(pidl1);
    LPCIDDRIVE pidd2 = _IsValidID(pidl2);

    if (!pidd1 || !pidd2)
    {
        TraceMsg(TF_WARNING, "CDrivesFolder::CompareIDs(), bad(s) pidl11:%s, pidl2:%s", DumpPidl(pidl1), DumpPidl(pidl2));
        return E_INVALIDARG;
    }

    //  For any column other than DRIVES_ICOL_NAME, we force an
    //  all-fields comparison to break ties.
    if ((iCol & SHCIDS_COLUMNMASK) != DRIVES_ICOL_NAME) 
        iCol |= SHCIDS_ALLFIELDS;

    HRESULT hr;
    switch (iCol & SHCIDS_COLUMNMASK) 
    {
        default:                    // If asking for unknown column, just use name
        case DRIVES_ICOL_NAME:
            hr = ResultFromShort(StrCmpICA(pidd1->cName, pidd2->cName));
            break;

        case DRIVES_ICOL_TYPE:
        {
            TCHAR szName1[80], szName2[80];

            if (SHID_COMPUTER_REGITEM != pidd1->bFlags)
            {
                CMountPoint::GetTypeString(DRIVEID(pidd1->cName), szName1, ARRAYSIZE(szName1));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szName1, ARRAYSIZE(szName1));
            }

            if (SHID_COMPUTER_REGITEM != pidd1->bFlags)
            {
                CMountPoint::GetTypeString(DRIVEID(pidd2->cName), szName2, ARRAYSIZE(szName2));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szName2, ARRAYSIZE(szName2));
            }

            hr = ResultFromShort(ustrcmpi(szName1, szName2));
            break;
        }

        case DRIVES_ICOL_CAPACITY:
        case DRIVES_ICOL_FREE:
        {
            ULONGLONG qwSize1, qwFree1;
            ULONGLONG qwSize2, qwFree2;

            BOOL fGotInfo1 = _GetFreeSpace(pidd1, &qwSize1, &qwFree1);
            BOOL fGotInfo2 = _GetFreeSpace(pidd2, &qwSize2, &qwFree2);

            if (fGotInfo1 && fGotInfo2) 
            {
                ULONGLONG i1, i2;  // this is a "guess" at the disk size and free space

                if ((iCol & SHCIDS_COLUMNMASK) == DRIVES_ICOL_CAPACITY)
                {
                    i1 = qwSize1;
                    i2 = qwSize2;
                } 
                else 
                {
                    i1 = qwFree1;
                    i2 = qwFree2;
                }

                if (i1 == i2)
                    hr = ResultFromShort(0);
                else if (i1 < i2)
                    hr = ResultFromShort(-1);
                else
                    hr = ResultFromShort(1);
            } 
            else if (!fGotInfo1 && !fGotInfo2) 
            {
                hr = ResultFromShort(0);
            } 
            else 
            {
                hr = ResultFromShort(fGotInfo1 - fGotInfo2);
            }
            break;
        }
    }

    if (0 == HRESULT_CODE(hr))
    {
        // check if clsids are equivalent, if they're different then we're done.
        // duh... this should be checked AFTER the other checks so sort order is preserved.
        CLSID clsid1, clsid2;
        _GetCLSIDFromPidl(pidd1, &clsid1);
        _GetCLSIDFromPidl(pidd2, &clsid2);
        hr = ResultFromShort(memcmp(&clsid1, &clsid2, sizeof(CLSID)));
    }

    // if they were the same so far, and we forcing an all-fields
    // comparison, then use the all-fields comparison to break ties.
    if ((0 == HRESULT_CODE(hr)) && (iCol & SHCIDS_ALLFIELDS))
    {
        hr = CompareItemIDs(pidd1, pidd2);
    }

    //  If the items are still the same, then ask ILCompareRelIDs
    //  to walk recursively to the next ids.
    if (0 == HRESULT_CODE(hr))
    {
        hr = ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, iCol);
    }

    return hr;
}

STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

STDMETHODIMP CDrivesFolder::CreateViewObject(HWND hwnd, REFIID riid, void** ppv)
{
    // We should not get here unless we have initialized properly
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.psvOuter = NULL;
        sSFV.psfvcb   = CDrives_CreateSFVCB(this);

        QueryInterface(IID_PPV_ARG(IShellFolder, &sSFV.pshf));   // in case we are agregated

        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

        if (sSFV.pshf)
            sSFV.pshf->Release();

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CDrivesDropTarget_Create(hwnd, IDLIST_DRIVES, (IDropTarget **)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        LPITEMIDLIST pidlFolder;
        if (SUCCEEDED(GetCurFolder(&pidlFolder)))
        {
            IContextMenuCB *pcmcb = new CDrivesBackgroundMenuCB(pidlFolder);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(IDLIST_DRIVES, hwnd, 0, NULL, SAFECAST(this, IShellFolder*), pcmcb, 
                                              0, NULL, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            ILFree(pidlFolder);
        }
    }
    else if (IsEqualIID(riid, IID_ICategoryProvider))
    {
        HKEY hk = NULL;

        BEGIN_CATEGORY_LIST(s_DriveCategories)
        CATEGORY_ENTRY_SCIDMAP(SCID_CAPACITY, CLSID_DriveSizeCategorizer)
        CATEGORY_ENTRY_SCIDMAP(SCID_TYPE, CLSID_DriveTypeCategorizer)
        CATEGORY_ENTRY_SCIDMAP(SCID_FREESPACE, CLSID_FreeSpaceCategorizer)
        END_CATEGORY_LIST()

        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Drive\\shellex\\Category"), &hk);
        hr = CCategoryProvider_Create(&CLSID_DetailCategorizer, &SCID_TYPE, hk, s_DriveCategories, this, riid, ppv);
        if (hk)
            RegCloseKey(hk);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    UINT rgfOut = SFGAO_HASSUBFOLDER | SFGAO_CANLINK | SFGAO_CANCOPY | 
                  SFGAO_DROPTARGET | SFGAO_HASPROPSHEET | SFGAO_FOLDER | SFGAO_STORAGE | 
                  SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;

    if (cidl == 0)
    {
        // We are getting the attributes for the "MyComputer" folder itself.
        rgfOut = (*prgfInOut & g_asDesktopReqItems[CDESKTOP_REGITEM_DRIVES].dwAttributes);
    }
    else if (cidl == 1)
    {
        TCHAR szDrive[MAX_PATH];
        LPCIDDRIVE pidd = _IsValidID(apidl[0]);

        if (!pidd)
            return E_INVALIDARG;

        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

        if (pmtpt)
        {
            SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));

            if (*prgfInOut & SFGAO_VALIDATE)
            {
                // (tybeam) todo: make this extensible to validate through the clsid object
                // ill do this when i break everything out into IDriveFolderExt or whatever
                CLSID clsid;
                if (S_OK != _GetCLSIDFromPidl(pidd, &clsid))
                {
                    DWORD dwAttribs;
                    if (!PathFileExistsAndAttributes(szDrive, &dwAttribs))
                        return E_FAIL;
                }
            }

            // If caller wants compression status, we need to ask the filesystem

            if (*prgfInOut & SFGAO_COMPRESSED)
            {
                // Don't wake up sleeping net connections
                if (!pmtpt->IsRemote() || !pmtpt->IsDisconnectedNetDrive())
                {
                    if (pmtpt->IsCompressed())
                    {
                        rgfOut |= SFGAO_COMPRESSED;
                    }
                }
            }

            if (*prgfInOut & SFGAO_SHARE)
            {
                if (!pmtpt->IsRemote())
                {
                    if (IsShared(szDrive, FALSE))
                        rgfOut |= SFGAO_SHARE;
                }

            }

            if ((*prgfInOut & SFGAO_REMOVABLE) &&
                (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy() ||
                pmtpt->IsCDROM()))
            {
                rgfOut |= SFGAO_REMOVABLE;
            }

            // we need to also handle the SFGAO_READONLY bit.
            if (*prgfInOut & SFGAO_READONLY)
            {
                DWORD dwAttributes = pmtpt->GetAttributes();
        
                if (dwAttributes != -1 && dwAttributes & FILE_ATTRIBUTE_READONLY)
                    rgfOut |= SFGAO_READONLY;
            }

            // Should we add the write protect stuff and readonly?
            if ((*prgfInOut & SFGAO_CANRENAME) &&
                (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy() ||
                pmtpt->IsFixedDisk() || pmtpt->IsRemote()) ||
                pmtpt->IsDVDRAMMedia())
            {
                rgfOut |= SFGAO_CANRENAME;
            }

            // Is a restriction causing this drive to not be enumerated?
            if (*prgfInOut & SFGAO_NONENUMERATED)
            {
                DWORD dwRestricted = SHRestricted(REST_NODRIVES);
                if (dwRestricted)
                {
                    if (((1 << DRIVEID(pidd->cName)) & dwRestricted))
                    {
                        rgfOut |= SFGAO_NONENUMERATED;
                    }
                }
            }

            // We want to allow moving volumes for bulk copy from some media
            // such as dragging pictures from a compact flash to the my pictures
            // folder.
            if (*prgfInOut & SFGAO_CANMOVE)
            {
                if (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy())
                    rgfOut |= SFGAO_CANMOVE;
            }

            pmtpt->Release();
        }
    }

    *prgfInOut = rgfOut;
    return S_OK;
}

HRESULT CDrivesFolder::_GetEditTextStrRet(LPCIDDRIVE pidd, STRRET *pstr)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        TCHAR szEdit[MAX_PATH];
        hr = pMtPt->GetLabel(szEdit, ARRAYSIZE(szEdit));
        if (SUCCEEDED(hr))
            hr = StringToStrRet(szEdit, pstr);
        pMtPt->Release();
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET* pStrRet)
{
    HRESULT hr;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        TCHAR szDrive[ARRAYSIZE(pidd->cName)];
        LPCITEMIDLIST pidlNext = _ILNext(pidl); // Check if pidl contains more than one ID

        SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));

        if (ILIsEmpty(pidlNext))
        {
            if (uFlags & SHGDN_FORPARSING)
            {
                hr = StringToStrRet(szDrive, pStrRet);
            }
            else if (uFlags & SHGDN_FOREDITING)
            {
                hr = _GetEditTextStrRet(pidd, pStrRet);
            }
            else
                hr = _GetDisplayNameStrRet(pidd, pStrRet);
        }
        else
        {
            LPITEMIDLIST pidlDrive = ILCombineParentAndFirst(IDLIST_DRIVES, pidl, pidlNext);
            if (pidlDrive)
            {
                //  now we need to get the subfolder from which to grab our goodies
                IShellFolder *psfDrive;
                hr = _CreateFSFolder(NULL, pidlDrive, pidd, IID_PPV_ARG(IShellFolder, &psfDrive));
                if (SUCCEEDED(hr))
                {
                    hr = psfDrive->GetDisplayNameOf(pidlNext, uFlags, pStrRet);
                    psfDrive->Release();
                }
                ILFree(pidlDrive);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CDrivesFolder::GetDisplayNameOf() bad PIDL %s", DumpPidl(pidl));
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                                      LPCWSTR pszName, DWORD dwReserved, LPITEMIDLIST* ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = SetDriveLabel(hwnd, NULL, DRIVEID(pidd->cName), pszName);
        if (SUCCEEDED(hr) && ppidlOut)
        {
            *ppidlOut = ILClone(pidl);
        }
    }
    return hr;
}


class CDriveAssocEnumData : public CEnumAssociationElements 
{
public:
    CDriveAssocEnumData(int iDrive) : _iDrive(iDrive) {}
 
private:
    virtual BOOL _Next(IAssociationElement **ppae);
    
    int _iDrive;
    DWORD _dwChecked;
};

enum 
{
    DAED_CHECK_KEY      = 0x0001,
    DAED_CHECK_CDORDVD  = 0x0002,
    DAED_CHECK_TYPE     = 0x0004,
};

BOOL CDriveAssocEnumData::_Next(IAssociationElement **ppae)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(_iDrive);
    if (pmtpt)
    {
        if (!(_dwChecked & DAED_CHECK_KEY))
        {
            HKEY hk = pmtpt->GetRegKey();
            if (hk)
            {
                hr = AssocElemCreateForKey(&CLSID_AssocShellElement, hk, ppae);
                RegCloseKey(hk);
            }
            _dwChecked |= DAED_CHECK_KEY;
        }

        if (FAILED(hr) && !(_dwChecked & DAED_CHECK_CDORDVD))
        {
            PCWSTR psz = NULL;
            if (pmtpt->IsAudioCD())
                psz = L"AudioCD";
            else if (pmtpt->IsDVD())
                psz = L"DVD";

            if (psz)
            {
                hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, psz, ppae);
            }
            _dwChecked |= DAED_CHECK_CDORDVD;
        }

        if (FAILED(hr) && !(_dwChecked & DAED_CHECK_TYPE))
        {
            hr = pmtpt->GetAssocSystemElement(ppae);
            _dwChecked |= DAED_CHECK_TYPE;
        }
        
        pmtpt->Release();
    }

    return SUCCEEDED(hr);
}

STDAPI_(BOOL) TBCContainsObject(LPCWSTR pszKey)
{
    IUnknown *punk;
    if (SUCCEEDED(TBCGetObjectParam(pszKey, IID_PPV_ARG(IUnknown, &punk))))
    {
        punk->Release();
        return TRUE;
    }
    return FALSE;
}

HRESULT CDrives_AssocCreate(PCSTR pszName, REFIID riid, void **ppv)
{
    *ppv = NULL;
    IAssociationArrayInitialize *paai;
    HRESULT hr = ::AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paai));
    if (SUCCEEDED(hr))
    {
        hr = paai->InitClassElements(ASSOCELEM_BASEIS_FOLDER, L"Drive");
        if (SUCCEEDED(hr) && pszName && !TBCContainsObject(L"ShellExec SHGetAssociations"))
        {
            IEnumAssociationElements *penum = new CDriveAssocEnumData(DRIVEID(pszName));
            if (penum)
            {
                paai->InsertElements(ASSOCELEM_DATA, penum);
                penum->Release();
            }
        }

        if (SUCCEEDED(hr))
            hr = paai->QueryInterface(riid, ppv);

        paai->Release();
    }

    return hr;
}

STDAPI_(DWORD) CDrives_GetKeys(PCSTR pszName, HKEY *rgk, UINT ck)
{
    IAssociationArray *paa;
    HRESULT hr = CDrives_AssocCreate(pszName, IID_PPV_ARG(IAssociationArray, &paa));
    if (SUCCEEDED(hr))
    {
        ck = SHGetAssocKeysEx(paa, -1, rgk, ck);
        paa->Release();
    }
    else
        ck = 0;
    return ck;
}

STDMETHODIMP CDrivesFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                          REFIID riid, UINT* prgfInOut, void** ppv)
{
    HRESULT hr;
    LPCIDDRIVE pidd = (cidl && apidl) ? _IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if (!pidd)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW) && pidd)
    {
        WCHAR szDrive[MAX_PATH];

        SHAnsiToUnicode(pidd->cName, szDrive, ARRAYSIZE(szDrive));

        hr = SHCreateDrvExtIcon(szDrive, riid, ppv);
    }
    else
    {
        if (IsEqualIID(riid, IID_IContextMenu))
        {
            HKEY rgk[MAX_ASSOC_KEYS];
            DWORD ck = CDrives_GetKeys(pidd->cName, rgk, ARRAYSIZE(rgk));
            hr = CDefFolderMenu_Create2(IDLIST_DRIVES, hwnd, cidl, apidl, 
                SAFECAST(this, IShellFolder *), CDrives_DFMCallBack, ck, rgk, (IContextMenu **)ppv);

            SHRegCloseKeys(rgk, ck);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            hr = SHCreateFileDataObject(IDLIST_DRIVES, cidl, apidl, NULL, (IDataObject **)ppv);
        }
        else if (IsEqualIID(riid, IID_IDropTarget))
        {
            IShellFolder *psfT;
            hr = BindToObject((LPCITEMIDLIST)pidd, NULL, IID_PPV_ARG(IShellFolder, &psfT));
            if (SUCCEEDED(hr))
            {
                hr = psfT->CreateViewObject(hwnd, IID_IDropTarget, ppv);
                psfT->Release();
            }
        }
        else if (IsEqualIID(riid, IID_IQueryInfo))
        {
            // REVIEW: Shouldn't we use IQA to determine the "prop" string dynamically??? (ZekeL / BuzzR)
            hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2 *), (LPCITEMIDLIST)pidd, L"prop:FreeSpace;Capacity", riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IQueryAssociations)
               || IsEqualIID(riid, IID_IAssociationArray))
        {
            hr = CDrives_AssocCreate(pidd->cName, riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IExtractImage))
        {
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

            hr = E_NOINTERFACE;

            if (pmtpt)
            {
                if (pmtpt->IsFixedDisk() || pmtpt->IsRAMDisk())
                {
                    hr = CDriveExtractImage_Create(pidd, riid, ppv);
                }

                pmtpt->Release();
            }
        }
        else 
        {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP CDrivesFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return DefaultSearchGUID(pGuid);
}

STDMETHODIMP CDrivesFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDrivesFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDrivesFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    HRESULT hr;

    if (iColumn < ARRAYSIZE(c_drives_cols))
    {
        *pdwState = c_drives_cols[iColumn].csFlags;
        if (iColumn == DRIVES_ICOL_COMMENT)
        {
            *pdwState |= SHCOLSTATE_SLOW; // It takes a long time to extract the comment from drives
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
        {
            SHDESCRIPTIONID did;
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

            if (pmtpt)
            {
                did.dwDescriptionId = pmtpt->GetShellDescriptionID();

                pmtpt->Release();
            }
            else
            {
                did.dwDescriptionId = SHDID_COMPUTER_OTHER;
            }

            did.clsid = CLSID_NULL;
            hr = InitVariantFromBuffer(pv, &did, sizeof(did));
        }
        else if (IsEqualSCID(*pscid, SCID_DetailsProperties))
        {
            // DUI webview properties
            // shouldnt we use IQA??? - ZekeL
            hr = InitVariantFromStr(pv, TEXT("prop:Name;Type;FileSystem;FreeSpace;Capacity"));
        }
        else
        {
            int iCol = FindSCID(c_drives_cols, ARRAYSIZE(c_drives_cols), pscid);
            if (iCol >= 0)
            {
                switch (iCol)
                {
                case DRIVES_ICOL_CAPACITY:
                case DRIVES_ICOL_FREE:
                    {
                        ULONGLONG ullSize, ullFree;
                        hr = E_FAIL;
                        if (_GetFreeSpace(pidd, &ullSize, &ullFree))
                        {
                            pv->vt = VT_UI8;
                            pv->ullVal = iCol == DRIVES_ICOL_CAPACITY ? ullSize : ullFree;
                            hr = S_OK;
                        }
                    }
                    break;

                default:
                    {
                        SHELLDETAILS sd;

                        hr = GetDetailsOf(pidl, iCol, &sd);
                        if (SUCCEEDED(hr))
                        {
                            hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                        }
                    }
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    TCHAR szTemp[INFOTIPSIZE];
    szTemp[0] = 0;
    
    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;
    
    if (!pidl)
    {
        return GetDetailsOfInfo(c_drives_cols, ARRAYSIZE(c_drives_cols), iColumn, pDetails);
    }

    LPCIDDRIVE pidd = _IsValidID(pidl);
    ASSERTMSG(pidd != NULL, "someone passed us a bad pidl");
    if (!pidd)
        return E_FAIL;  // protect faulting code below
    
    switch (iColumn)
    {
    case DRIVES_ICOL_NAME:
        _GetDisplayName(pidd, szTemp, ARRAYSIZE(szTemp));
        break;
        
    case DRIVES_ICOL_TYPE:
        CMountPoint::GetTypeString(DRIVEID(pidd->cName), szTemp, ARRAYSIZE(szTemp));
        break;
        
    case DRIVES_ICOL_COMMENT:
        GetDriveComment(DRIVEID(pidd->cName), szTemp, ARRAYSIZE(szTemp));
        break;

    case DRIVES_ICOL_CAPACITY:
    case DRIVES_ICOL_FREE:
        {
            ULONGLONG ullSize, ullFree;

            if (_GetFreeSpace(pidd, &ullSize, &ullFree))
            {
                StrFormatByteSize64((iColumn == DRIVES_ICOL_CAPACITY) ? ullSize : ullFree, szTemp, ARRAYSIZE(szTemp));
            }
        }
        break;
    case DRIVES_ICOL_FILESYSTEM:
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
            if (pMtPt)
            {
                WCHAR szFileSysName[MAX_FILESYSNAME];
                // GetFileSystemName hits the disk for floppies so disable it.
                // since this is a perf win for defview but disables some functionality, it means
                // do NOT rely on the namespace for getting filesystem information, go direct to
                // the mountpoint instead.  if filefldr ever supports SCID_FILESYSTEM like
                // SCID_FREESPACE then this should be munged around.
                if (!pMtPt->IsFloppy() && pMtPt->GetFileSystemName(szFileSysName, ARRAYSIZE(szFileSysName)))
                {
                    StrCpyN(szTemp, szFileSysName, min(ARRAYSIZE(szTemp),ARRAYSIZE(szFileSysName)));
                }
                pMtPt->Release();
            }
        }
        break;

    }
    return StringToStrRet(szTemp, &pDetails->str);
}

HRESULT CDrivesFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_drives_cols, ARRAYSIZE(c_drives_cols), iColumn, pscid);
}

STDMETHODIMP CDrivesFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_MyComputer;
    return S_OK;
}

STDMETHODIMP CDrivesFolder::Initialize(LPCITEMIDLIST pidl)
{
    // Only allow the Drives root on the desktop
    ASSERT(AssertIsIDListInNameSpace(pidl, &CLSID_MyComputer) && ILIsEmpty(_ILNext(pidl)));
    return S_OK;
}

STDMETHODIMP CDrivesFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(IDLIST_DRIVES, ppidl);
}

STDMETHODIMP CDrivesFolder::_GetIconOverlayInfo(LPCIDDRIVE pidd, int *pIndex, DWORD dwFlags)
{
    IShellIconOverlayManager *psiom;
    HRESULT hr = GetIconOverlayManager(&psiom);
    if (SUCCEEDED(hr))
    {
        WCHAR wszDrive[10];
        SHAnsiToUnicode(pidd->cName, wszDrive, ARRAYSIZE(wszDrive));
        if (IsShared(wszDrive, FALSE))
        {
            hr = psiom->GetReservedOverlayInfo(wszDrive, 0, pIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_SHARED);
        }
        else
        {
            hr = psiom->GetFileOverlayInfo(wszDrive, 0, pIndex, dwFlags);
        }            
        psiom->Release();
    }
    return hr;
}    

STDMETHODIMP CDrivesFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = _GetIconOverlayInfo(pidd, pIndex, SIOM_OVERLAYINDEX);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = _GetIconOverlayInfo(pidd, pIndex, SIOM_ICONINDEX);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::CompareItemIDs(LPCIDDRIVE pidd1, LPCIDDRIVE pidd2)
{
    // Compare the drive letter for sorting purpose.
    int iRes = StrCmpICA(pidd1->cName, pidd2->cName);   // don't need local goo

    // then, compare pidl sizes
    if (iRes == 0)
    {
        iRes = pidd1->cb - pidd2->cb;
    }

    // still equal, compare clsids if both pidls are big and have them
    if ((iRes == 0) && (pidd1->cb >= sizeof(IDDRIVE)))
    {
        iRes = memcmp(&pidd1->clsid, &pidd2->clsid, sizeof(CLSID));
    }

    // still equal, compare on bFlags
    if (iRes == 0)
    {
        iRes = pidd1->bFlags - pidd2->bFlags;
    }
    return ResultFromShort(iRes);
}

HRESULT CDrivesFolder::_OnChangeNotify(LPARAM lNotification, LPCITEMIDLIST *ppidl)
{
    // Get to the last part of this id list...
    if ((lNotification != SHCNE_DRIVEADD) || (ppidl == NULL) || (*ppidl == NULL))
        return S_OK;

    DWORD dwRestricted = SHRestricted(REST_NODRIVES);
    if (dwRestricted == 0)
        return S_OK;   // no drives restricted... (majority case)

    LPCIDDRIVE pidd = (LPCIDDRIVE)ILFindLastID(*ppidl);

    if (((1 << DRIVEID(pidd->cName)) & dwRestricted))
    {
        TraceMsg(DM_TRACE, "Drive not added due to restrictions or Drivespace says it should be hidden");
        return S_FALSE;
    }
    return S_OK;
}

CDrivesBackgroundMenuCB::CDrivesBackgroundMenuCB(LPITEMIDLIST pidlFolder) : _cRef(1)
{
    _pidlFolder = ILClone(pidlFolder);
}

CDrivesBackgroundMenuCB::~CDrivesBackgroundMenuCB()
{
    ILFree(_pidlFolder);
}

STDMETHODIMP CDrivesBackgroundMenuCB::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDrivesBackgroundMenuCB, IContextMenuCB), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDrivesBackgroundMenuCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDrivesBackgroundMenuCB::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDrivesBackgroundMenuCB::_GetHelpText(UINT offset, BOOL bWide, LPARAM lParam, UINT cch)
{
    UINT idRes = IDS_MH_FSIDM_FIRST + offset;
    if (bWide)
        LoadStringW(HINST_THISDLL, idRes, (LPWSTR)lParam, cch);
    else
        LoadStringA(HINST_THISDLL, idRes, (LPSTR)lParam, cch);

    return S_OK;
}


STDMETHODIMP CDrivesBackgroundMenuCB::CallBack (IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            DWORD dwAttr = SFGAO_HASPROPSHEET;
            if (FAILED(SHGetAttributesOf(_pidlFolder, &dwAttr)) ||
                SFGAO_HASPROPSHEET & dwAttr)
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
            }
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        hr = _GetHelpText(LOWORD(wParam), uMsg == DFM_GETHELPTEXTW, lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            SHRunControlPanel(TEXT("SYSDM.CPL"), hwndOwner);
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

class CDriveExtractImage : public IExtractImage,
                           public IPersist
{
public:
    CDriveExtractImage();
    
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IExtractImage/IExtractLogo
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags);
    STDMETHOD (Extract)(HBITMAP * phBmpThumbnail);

    // IPersist
    STDMETHOD(GetClassID)(LPCLSID lpClassID);

    STDMETHOD(Init)(LPCIDDRIVE pidd);
private:
    ~CDriveExtractImage();

    long            _cRef;
    SIZE            _size;
    TCHAR           _szPath[4];

    DWORDLONG _dwlFreeSpace;
    DWORDLONG _dwlUsedSpace;
    DWORDLONG _dwlTotalSpace;
    DWORD _dwUsedSpacePer1000;     // amount of used space /1000

    // root drive
    enum
    {
        PIE_USEDCOLOR = 0,
        PIE_FREECOLOR,
        PIE_USEDSHADOW,
        PIE_FREESHADOW,
        PIE_NUM     // keep track of number of PIE_ values
    };
    COLORREF _acrChartColors[PIE_NUM];         // color scheme

    STDMETHOD(_CreateRenderingDC)(HDC* phdc, HBITMAP* phBmpThumbnail, HBITMAP* phbmpOld, int cx, int cy);
    void _DestroyRenderingDC(HDC hdc, HBITMAP hbmpOld);
    STDMETHOD(_RenderToDC)(HDC hdc);

    STDMETHOD(ComputeFreeSpace)(LPTSTR pszFileName);
    DWORD IntSqrt(DWORD dwNum);
    STDMETHOD(Draw3dPie)(HDC hdc, LPRECT lprc, DWORD dwPer1000, const COLORREF *lpColors);
};

STDAPI CDriveExtractImage_Create(LPCIDDRIVE pidd, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
#if 0
    CDriveExtractImage * pObj = new CDriveExtractImage;
    if (pObj)
    {
        hr = pObj->Init(pidd);
        if (SUCCEEDED(hr))
            hr = pObj->QueryInterface(riid, ppvObj);
        pObj->Release();
    }
#endif
    return hr;
}

CDriveExtractImage::CDriveExtractImage() : _cRef (1)
{
}

CDriveExtractImage::~CDriveExtractImage()
{
}

STDMETHODIMP CDriveExtractImage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDriveExtractImage, IExtractImage),
        QITABENTMULTI2(CDriveExtractImage, IID_IExtractLogo, IExtractImage),
        QITABENT(CDriveExtractImage, IPersist),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDriveExtractImage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDriveExtractImage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDriveExtractImage::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                              DWORD * pdwPriority, const SIZE * prgSize,
                                              DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    // Sets the size of the thumbnail
    _size = *prgSize;

    SHTCharToUnicode(_szPath, pszPathBuffer, sizeof(_szPath));

    *pdwFlags &= ~IEIFLAG_CACHE;
    *pdwFlags |= IEIFLAG_ASYNC | IEIFLAG_NOBORDER;

    return S_OK;
}

STDMETHODIMP CDriveExtractImage::_CreateRenderingDC(HDC* phdc, HBITMAP* phBmpThumbnail, HBITMAP* phbmpOld, int cx, int cy)
{
    HRESULT hr = E_OUTOFMEMORY;
    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        *phdc = CreateCompatibleDC(hdc);
        if (*phdc)
        {
            *phBmpThumbnail = CreateCompatibleBitmap (hdc, cx, cy);
            if (*phBmpThumbnail)
            {
                *phbmpOld = (HBITMAP) SelectObject(*phdc, *phBmpThumbnail);
                hr = S_OK;
            }
        }

        ReleaseDC(NULL, hdc);
    }

    return hr;
}

void CDriveExtractImage::_DestroyRenderingDC(HDC hdc, HBITMAP hbmpOld)               // Unselects the bitmap, and deletes the Dc
{
    if (hbmpOld)
        SelectObject (hdc, hbmpOld);
    DeleteDC(hdc);
}

STDMETHODIMP CDriveExtractImage::_RenderToDC(HDC hdc)   // Does a generic render of child pidl
{
    RECT rc = { 0, 0, (long)_size.cx, (long)_size.cy };

    HBRUSH hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    if (hbr)
    {
        FillRect (hdc, (const RECT*) &rc, hbr);
        DeleteObject(hbr);
    }
    
    if (SUCCEEDED(ComputeFreeSpace(_szPath)))
    {
        _acrChartColors[PIE_USEDCOLOR] = GetSysColor(COLOR_3DFACE);
        _acrChartColors[PIE_FREECOLOR] = GetSysColor(COLOR_3DHILIGHT);
        _acrChartColors[PIE_USEDSHADOW] = GetSysColor(COLOR_3DSHADOW);
        _acrChartColors[PIE_FREESHADOW] = GetSysColor(COLOR_3DFACE);

        rc.top += 10;
        rc.left += 10;
        rc.bottom -= 10;
        rc.right -= 10;

        Draw3dPie(hdc, &rc, _dwUsedSpacePer1000, _acrChartColors);
    }
    
    return S_OK;
}

STDMETHODIMP CDriveExtractImage::Extract(HBITMAP * phBmpThumbnail)
{
    HDC hdc;
    HBITMAP hbmpOld;

    // Creates the rendering DC based on the screen
    HRESULT hr = _CreateRenderingDC(&hdc, phBmpThumbnail, &hbmpOld, _size.cx, _size.cy);
    if (SUCCEEDED(hr))
    {
        // Does a generic render of child pidl
        hr = _RenderToDC(hdc);

        // Unselects the bitmap, restores the old bitmap and deletes the DC
        _DestroyRenderingDC(hdc, hbmpOld);
    }

    if (FAILED(hr) && *phBmpThumbnail)
    {
        DeleteObject(*phBmpThumbnail);
        *phBmpThumbnail = NULL;
    }

    return hr;
}

STDMETHODIMP CDriveExtractImage::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDriveExtractImage::Init(LPCIDDRIVE pidd)
{
    SHAnsiToTChar(pidd->cName, _szPath, ARRAYSIZE(_szPath));
    return S_OK;
}

// Pie Chart functions
STDMETHODIMP CDriveExtractImage::ComputeFreeSpace(LPTSTR pszFileName)
{
    ULARGE_INTEGER qwFreeCaller;        // use this for free space -- this will take into account disk quotas and such on NT
    ULARGE_INTEGER qwTotal;
    ULARGE_INTEGER qwFree;      // unused

    // Compute free & total space and check for valid results
    // if have a fn pointer call SHGetDiskFreeSpaceA
    if (SHGetDiskFreeSpaceEx(pszFileName, &qwFreeCaller, &qwTotal, &qwFree))
    {
        _dwlFreeSpace = qwFreeCaller.QuadPart;
        _dwlTotalSpace = qwTotal.QuadPart;
        _dwlUsedSpace = _dwlTotalSpace - _dwlFreeSpace;


        if (EVAL(_dwlTotalSpace > 0 && _dwlFreeSpace <= _dwlTotalSpace))
        {
            // some special cases require interesting treatment
            if (_dwlTotalSpace == 0 || _dwlFreeSpace == _dwlTotalSpace)
            {
                _dwUsedSpacePer1000 = 0;
            }
            else if (_dwlFreeSpace == 0)
            {
                _dwUsedSpacePer1000 = 1000;
            }
            else
            {
                // not completely full or empty
                _dwUsedSpacePer1000 = (DWORD)(_dwlUsedSpace * 1000 / _dwlTotalSpace);

                // Trick: if user has extremely little free space, the user expects to still see
                // a tiny free slice -- not a full drive.  Similarly for almost free drive.
                if (_dwUsedSpacePer1000 == 0)
                {
                    _dwUsedSpacePer1000 = 1;
                }
                else if (_dwUsedSpacePer1000 == 1000)
                {
                    _dwUsedSpacePer1000 = 999;
                }
            }
            return S_OK;
        }
    }
    return E_FAIL;
}

DWORD CDriveExtractImage::IntSqrt(DWORD dwNum)
{
    // This code came from "drawpie.c"
    DWORD dwSqrt = 0;
    DWORD dwRemain = 0;
    DWORD dwTry = 0;

    for (int i=0; i<16; ++i) 
    {
        dwRemain = (dwRemain<<2) | (dwNum>>30);
        dwSqrt <<= 1;
        dwTry = dwSqrt*2 + 1;

        if (dwRemain >= dwTry) 
        {
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }
        dwNum <<= 2;
    }
    return dwSqrt;
}   // IntSqrt


STDMETHODIMP CDriveExtractImage::Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, const COLORREF *lpColors)
{
    ASSERT(lprc != NULL && lpColors != NULL);

    enum
    {
        COLOR_UP = 0,
        COLOR_DN,
        COLOR_UPSHADOW,
        COLOR_DNSHADOW,
        COLOR_NUM       // #of entries
    };

    // The majority of this code came from "drawpie.c"
    const LONG c_lShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_lAspectRatio = 2;      // ratio of width : height of ellipse

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle
    // Stabilize the aspect ratio now...
    LONG lHeight = lprc->bottom - lprc->top;
    LONG lWidth = lprc->right - lprc->left;
    LONG lTargetHeight = (lHeight * c_lAspectRatio <= lWidth? lHeight: lWidth / c_lAspectRatio);
    LONG lTargetWidth = lTargetHeight * c_lAspectRatio;     // need to adjust because w/c * c isn't always == w

    // Shrink the rectangle on both sides to the correct size
    lprc->top += (lHeight - lTargetHeight) / 2;
    lprc->bottom = lprc->top + lTargetHeight;
    lprc->left += (lWidth - lTargetWidth) / 2;
    lprc->right = lprc->left + lTargetWidth;

    // Compute a shadow depth based on height of the image
    LONG lShadowDepth = lTargetHeight / c_lShadowScale;

    // check dwPer1000 to ensure within bounds
    if (dwPer1000 > 1000)
        dwPer1000 = 1000;

    // Now the drawing function
    int cx, cy, rx, ry, x, y;
    int uQPctX10;
    RECT rcItem;
    HRGN hEllRect, hEllipticRgn, hRectRgn;
    HBRUSH hBrush, hOldBrush;
    HPEN hPen, hOldPen;

    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - lShadowDepth;

    rx = rcItem.right / 2;
    cx = rcItem.left + rx - 1;
    ry = rcItem.bottom / 2;
    cy = rcItem.top + ry - 1;
    if (rx<=10 || ry<=10)
    {
        return S_FALSE;
    }

    rcItem.right = rcItem.left+2*rx;
    rcItem.bottom = rcItem.top+2*ry;

    /* Translate to first quadrant of a Cartesian system
    */
    uQPctX10 = (dwPer1000 % 500) - 250;
    if (uQPctX10 < 0)
    {
        uQPctX10 = -uQPctX10;
    }

    /* Calc x and y.  I am trying to make the area be the right percentage.
    ** I don't know how to calculate the area of a pie slice exactly, so I
    ** approximate it by using the triangle area instead.
    */

    // NOTE-- *** in response to the above comment ***
    // Calculating the area of a pie slice exactly is actually very
    // easy by conceptually rescaling into a circle but the complications
    // introduced by having to work in fixed-point arithmetic makes it
    // unworthwhile to code this-- CemP
    
    if (uQPctX10 < 120)
    {
        x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    /* Switch on the actual quadrant
    */
    switch (dwPer1000 / 250)
    {
    case 1:
        y = -y;
        break;

    case 2:
        break;

    case 3:
        x = -x;
        break;

    default: // case 0 and case 4
        x = -x;
        y = -y;
        break;
    }

    /* Now adjust for the center.
    */
    x += cx;
    y += cy;

    //
    // Hack to get around bug in NTGDI

    x = x < 0 ? 0 : x;

    /* Draw the shadows using regions (to reduce flicker).
    */
    hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
    OffsetRgn(hEllipticRgn, 0, lShadowDepth);
    hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+lShadowDepth);
    hRectRgn = CreateRectRgn(0, 0, 0, 0);
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)lShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    /* Always draw the whole area in the free shadow/
    */
    hBrush = CreateSolidBrush(lpColors[COLOR_DNSHADOW]);
    if (hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    /* Draw the used shadow only if the disk is at least half used.
    */
    if (dwPer1000>500 && (hBrush = CreateSolidBrush(lpColors[COLOR_UPSHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // if per1000 is 0 or 1000, draw full elipse, otherwise, also draw a pie section.
    // we might have a situation where per1000 isn't 0 or 1000 but y == cy due to approx error,
    // so make sure to draw the ellipse the correct color, and draw a line (with Pie()) to
    // indicate not completely full or empty pie.
    hBrush = CreateSolidBrush(lpColors[dwPer1000 < 500 && y == cy && x < cx? COLOR_DN: COLOR_UP]);
    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    if (dwPer1000 != 0 && dwPer1000 != 1000)
    {
        // display small sub-section of ellipse for smaller part
        hBrush = CreateSolidBrush(lpColors[COLOR_DN]);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        Pie(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, y);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);
    }

    Arc(hdc, rcItem.left, rcItem.top+lShadowDepth, rcItem.right - 1, rcItem.bottom+lShadowDepth - 1,
        rcItem.left, cy+lShadowDepth, rcItem.right, cy+lShadowDepth-1);
    MoveToEx(hdc, rcItem.left, cy, NULL);
    LineTo(hdc, rcItem.left, cy+lShadowDepth);
    MoveToEx(hdc, rcItem.right-1, cy, NULL);
    LineTo(hdc, rcItem.right-1, cy+lShadowDepth);
    if (dwPer1000 > 500 && dwPer1000 < 1000)
    {
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x, y+lShadowDepth);
    }
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);

    return S_OK;    // Everything worked fine
}   // Draw3dPie
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duidrag.h ===
class CDUIDropTarget:
    public IDropTarget
{

protected:
    ULONG         _cRef;
    IDropTarget * _pDT;
    IDropTarget * _pNextDT;

public:
    CDUIDropTarget();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget methods
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);

    HRESULT Initialize (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt);

private:
    ~CDUIDropTarget();

    VOID _Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duihost.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duihost.h"


// DUIAxHost Initialization

HRESULT DUIAxHost::Create(UINT nCreate, UINT nActive, OUT DUIAxHost** ppElement)
{
    *ppElement = NULL;

    DUIAxHost* pe = HNewAndZero<DUIAxHost>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nCreate, nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
    }
    else
    {
        *ppElement = pe;
    }

    return hr;
}

HWND DUIAxHost::CreateHWND(HWND hwndParent)
{
    return CreateWindowEx(0, CAxWindow::GetWndClassName(), NULL,
                          WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                          0, 0, 0, 0, hwndParent, NULL, NULL, NULL);
}


HRESULT DUIAxHost::SetSite(IUnknown* punkSite)
{
    CComPtr<IUnknown> spHost;
    HRESULT hr = AtlAxGetHost(GetHWND(), &spHost);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(spHost, punkSite);
    }
    return hr;
}

void DUIAxHost::OnDestroy()
{
    SetSite(NULL);
    HWNDHost::OnDestroy();
    ATOMICRELEASE(_pOleObject);
}

bool DUIAxHost::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg) 
    {
    case WM_DESTROY:
        SetSite(NULL);
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

HRESULT DUIAxHost::AttachControl(IUnknown* punkObject)
{
    if (NULL == GetHWND())
        return E_UNEXPECTED;

    if (NULL == punkObject)
        return E_INVALIDARG;

    ATOMICRELEASE(_pOleObject);

    HRESULT hr = punkObject->QueryInterface(IID_PPV_ARG(IOleObject, &_pOleObject));
    if (SUCCEEDED(hr))
    {
        CComPtr<IUnknown> spUnk;
        hr = AtlAxGetHost(GetHWND(), &spUnk);
        if (SUCCEEDED(hr))
        {
            CComPtr<IAxWinHostWindow> spDUIAxHostWindow;
            hr = spUnk->QueryInterface(&spDUIAxHostWindow);
            if (SUCCEEDED(hr))
            {
                hr = spDUIAxHostWindow->AttachControl(punkObject, GetHWND());
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////
// DUIAxHost Rendering

SIZE DUIAxHost::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    SIZE size = { 0, 0 };

    // Ask the attached ActiveX control for its preferred size
    if (NULL != _pOleObject)
    {
        SIZEL sizeT;
        if (SUCCEEDED(_pOleObject->GetExtent(DVASPECT_CONTENT, &sizeT)))
        {
            int dpiX;
            int dpiY;

            switch (psrf->GetType())
            {
            case Surface::stDC:
                {
                    HDC hDC = CastHDC(psrf);
                    dpiX = GetDeviceCaps(hDC, LOGPIXELSX);
                    dpiY = GetDeviceCaps(hDC, LOGPIXELSX);
                }
                break;

#ifdef GADGET_ENABLE_GDIPLUS
            case Surface::stGdiPlus:
                {
                    Gdiplus::Graphics * pgpgr = CastGraphics(psrf);
                    dpiX = (int)pgpgr->GetDpiX();
                    dpiY = (int)pgpgr->GetDpiY();
                }
                break;
#endif
            default:
                dpiX = dpiY = 96;
                break;
            }

            // Convert from HIMETRIC to pixels
            size.cx = (MAXLONG == sizeT.cx) ? MAXLONG : MulDiv(sizeT.cx, dpiX, 2540);
            size.cy = (MAXLONG == sizeT.cy) ? MAXLONG : MulDiv(sizeT.cy, dpiY, 2540);

            if (-1 != dConstW && size.cx > dConstW) size.cx = dConstW;
            if (-1 != dConstH && size.cy > dConstH) size.cy = dConstH;
        }
    }

    return size;
}

////////////////////////////////////////////////////////
// DUIAxHost Keyboard navigation

void DUIAxHost::SetKeyFocus()
{
    FakeTabEvent();

    // No matter what, we should continue with standard DUI operations.
    Element::SetKeyFocus();
}

void DUIAxHost::OnEvent(Event* pEvent)
{
    bool fHandled = false;

    if (pEvent->nStage == GMF_DIRECT && pEvent->uidType == Element::KeyboardNavigate) {
        int iNavDir = ((KeyboardNavigateEvent*) pEvent)->iNavDir;
        if (((iNavDir & NAV_NEXT) == NAV_NEXT) || ((iNavDir & NAV_PREV) == NAV_PREV)) {
            fHandled = FakeTabEvent();
         } else {
             // Handle other types of navigation here... (home/end/etc)
         }
    }

    // Continue with standard DUI operation if the navigation event wasn't handled
    // by our contained ActiveX control.
    if (!fHandled) {
        Element::OnEvent(pEvent);
    }
}

bool DUIAxHost::FakeTabEvent()
{
    bool fHandled = false;

    MSG msg;

    ZeroMemory(&msg, sizeof(msg));
    msg.message = WM_KEYDOWN;
    msg.wParam = VK_TAB;
    msg.lParam = 1;

    // Note: we probably should do something to respect navoigating forward
    // or backwards.  The ActiveX control needs to know if it should activate
    // the first or last tab stop.  For now it will only reliably
    // activate the first one.  If it checks the keyboard Shift state
    // it will probably get it right, but not 100% guaranteed.

    if(SendMessage(GetHWND(), WM_FORWARDMSG, 0, (LPARAM)&msg)) {
        fHandled = true;
    }
            
    return fHandled;
}

// Define class info with type and base type, set static class pointer
IClassInfo* DUIAxHost::Class = NULL;
HRESULT DUIAxHost::Register()
{
    return ClassInfo<DUIAxHost,HWNDHost>::Register(L"DUIAxHost", NULL, 0);
}

HRESULT DUIAxHost::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    return CreateStdAccessibleObject(GetHWND(), OBJID_CLIENT, IID_PPV_ARG(IAccessible, ppAccessible));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duihost.h ===
class DUIAxHost : public HWNDHost
{
public:
    static HRESULT Create(Element**) { return E_NOTIMPL; } // Required for ClassInfo
    static HRESULT Create(OUT DUIAxHost** ppElement) { return Create(0, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nCreate, UINT nActive, OUT DUIAxHost** ppElement);

    ~DUIAxHost() { ATOMICRELEASE(_pOleObject); }

    // Initialization
    HRESULT SetSite(IUnknown* punkSite);
    HRESULT AttachControl(IUnknown* punkObject);

    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);
    virtual void OnDestroy();

    // Rendering
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Keyboard navigation
    virtual void SetKeyFocus();
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    DUIAxHost() : _pOleObject(NULL) {}
    bool FakeTabEvent();

    virtual HWND CreateHWND(HWND hwndParent);
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);

private:
    IOleObject* _pOleObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duiinfo.cpp ===
#include "shellprv.h"
#include "duiinfo.h"
#include "ids.h"
#include "datautil.h"


DWORD FormatMessageArg(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID,
        LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer,
            cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

CNameSpaceItemUIProperty::~CNameSpaceItemUIProperty()
{
}

void CNameSpaceItemUIProperty::_SetParentAndItem(IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    // set aliases to current values these are not refed
    // it is assumed that all helpers that use these variables won't be called
    // unless these have been set. since this can't fail this all works out fine
    m_psf = psf;        // alias, not refed
    m_pidl = pidl;      // alias, not cloned
}

STDMETHODIMP CNameSpaceItemUIProperty::GetPropertyDisplayName(SHCOLUMNID scid, WCHAR* pwszPropDisplayName, int cchPropDisplayName)
{
    *pwszPropDisplayName = 0;
    
    CComPtr<IPropertyUI> spPropertyUI;
    HRESULT hr = _GetPropertyUI(&spPropertyUI);
    if (SUCCEEDED(hr))
    {
        hr = spPropertyUI->GetDisplayName(
                scid.fmtid,
                scid.pid,
                PUIFNF_DEFAULT,
                pwszPropDisplayName,
                cchPropDisplayName);
    }

    return hr;
}

STDMETHODIMP CNameSpaceItemUIProperty::GetPropertyDisplayValue(SHCOLUMNID scid, WCHAR* pszValue, int cch, PROPERTYUI_FORMAT_FLAGS flagsFormat)
{
    *pszValue = 0;
    HRESULT hr = E_FAIL;
    
    // Use GetDisplayNameOf for the SCID_NAME property
    if (IsEqualSCID(scid, SCID_NAME))
    {
        hr = DisplayNameOf(m_psf, m_pidl, SHGDN_INFOLDER, pszValue, cch);
    }
    else
    {   // Use GetDetailsEx to get the value
        CComVariant varPropDisplayValue;
        
        if (m_psf->GetDetailsEx(m_pidl, &scid, &varPropDisplayValue) == S_OK) // S_FALSE means property wasn't there.
        {
            if (IsEqualSCID(scid, SCID_SIZE) && 
                ((varPropDisplayValue.vt == VT_UI8) && (varPropDisplayValue.ullVal <= 0)))
            {
                hr = E_FAIL;    // Don't display 0 byte sizes
            }
            else
            {
                CComPtr<IPropertyUI> spPropertyUI;
                hr = _GetPropertyUI(&spPropertyUI);
                if (SUCCEEDED(hr))
                {
                    hr = spPropertyUI->FormatForDisplay(scid.fmtid, scid.pid,
                            (PROPVARIANT*)&varPropDisplayValue,  //cast from VARIANT to PROPVARIANT should be ok
                            flagsFormat, pszValue, cch);
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CNameSpaceItemUIProperty::GetInfoString(SHCOLUMNID scid, WCHAR* pwszInfoString, int cchInfoString)
{
    HRESULT hr = E_FAIL;

    // No DisplayName for the following properties
    if (IsEqualSCID(scid, SCID_NAME) || 
        IsEqualSCID(scid, SCID_TYPE) || 
        IsEqualSCID(scid, SCID_Comment))
    {
        hr = GetPropertyDisplayValue(scid, pwszInfoString, cchInfoString, PUIFFDF_DEFAULT);
    }
    else
    {   // The other properties are in the format PropertyName: Value
        // Get the display name
        WCHAR wszPropertyDisplayName[50];
        hr = GetPropertyDisplayName(scid, wszPropertyDisplayName, ARRAYSIZE(wszPropertyDisplayName));
        if (SUCCEEDED(hr))
        {
            // Get the display value
            PROPERTYUI_FORMAT_FLAGS flagsFormat = IsEqualSCID(scid, SCID_WRITETIME) ? PUIFFDF_FRIENDLYDATE : PUIFFDF_DEFAULT;

            WCHAR wszPropertyDisplayValue[INTERNET_MAX_URL_LENGTH];
            hr = GetPropertyDisplayValue(scid, wszPropertyDisplayValue, ARRAYSIZE(wszPropertyDisplayValue), flagsFormat);

            // If the property display name or the property value is empty then we fail, so
            // this property will not be displayed.
            if (SUCCEEDED(hr))
            {
                hr = (wszPropertyDisplayName[0] && wszPropertyDisplayValue[0]) ? S_OK : E_FAIL;
            }

            // Now, combine the display name and value, seperated by a colon
            if (SUCCEEDED(hr))
            {
                // ShellConstructMessageString here to form the string
                WCHAR wszFormatStr[50];
                LoadStringW(HINST_THISDLL, IDS_COLONSEPERATED, wszFormatStr, ARRAYSIZE(wszFormatStr));
                if (FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, wszFormatStr, 0, 0,
                        pwszInfoString, cchInfoString, wszPropertyDisplayName,
                        wszPropertyDisplayValue))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
}

HRESULT CNameSpaceItemUIProperty::_GetPropertyUI(IPropertyUI **pppui)
{
    HRESULT hr = E_FAIL;
    if (!m_spPropertyUI)
    {
        hr = SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &m_spPropertyUI));
    }
    
    *pppui = m_spPropertyUI;
    if (*pppui)
    {
        (*pppui)->AddRef();
        hr = S_OK;
    }
    return hr;
}

CNameSpaceItemInfoList::~CNameSpaceItemInfoList()
{
    if (m_pDUIView)
    {
        m_pDUIView->SetDetailsInfoMsgWindowPtr(NULL, this);
        m_pDUIView->Release();
    }
}

STDMETHODIMP CNameSpaceItemInfoList::Create(CDUIView* pDUIView, Value* pvDetailsSheet,
        IShellItemArray *psiItemArray, Element** ppElement)
{
    HRESULT hr;

    *ppElement = NULL;

    CNameSpaceItemInfoList* pNSIInfoList = HNewAndZero<CNameSpaceItemInfoList>();
    if (!pNSIInfoList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNSIInfoList->Initialize(pDUIView, pvDetailsSheet, psiItemArray);
        if (SUCCEEDED(hr))
            *ppElement = pNSIInfoList;
        else
            pNSIInfoList->Destroy();
    }

    return hr;
}

STDMETHODIMP CNameSpaceItemInfoList::Initialize(CDUIView* pDUIView, Value* pvDetailsSheet,
        IShellItemArray *psiItemArray)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        IDataObject *pdtobj = NULL;

        (m_pDUIView = pDUIView)->AddRef();
        
         Value* pvLayout = NULL;
        int arVLOptions[] = { FALSE, ALIGN_LEFT, ALIGN_JUSTIFY, ALIGN_TOP };
        hr = VerticalFlowLayout::Create(ARRAYSIZE(arVLOptions), arVLOptions, &pvLayout);
        if (SUCCEEDED(hr))
        {
            SetValue(LayoutProp, PI_Local, pvLayout);
            pvLayout->Release();
        }

        if (pvDetailsSheet)
        {
            SetValue(SheetProp, PI_Local, pvDetailsSheet);
        }

        // the HIDA format has 2 forms, one is each item in the array is a
        // fully qualified pidl. this is what the search folder produces
        // the other is the items are relative to a sigle folder pidl
        // the code below deals with both cases

        // Should just use use the ShellItemArray instead of getting the HIDA
        if (psiItemArray)
        {
            if (FAILED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdtobj))))
            {
                pdtobj = NULL;
            }

        }
        hr = S_OK;
        BOOL bDetailsAvailable = FALSE;

        if (pdtobj)
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                IShellFolder2 *psfRoot;
                LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
                hr = SHBindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder2, &psfRoot));
                if (SUCCEEDED(hr))
                {
                    if (pida->cidl == 1)
                    {
                        LPCITEMIDLIST pidlItem = IDA_GetIDListPtr(pida, 0);
                        IShellFolder2 *psf;
                        LPCITEMIDLIST pidl;
                        hr = SHBindToFolderIDListParent(psfRoot, pidlItem, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
                        if (SUCCEEDED(hr))
                        {
                            if (!SHGetAttributes(psf, pidl, SFGAO_ISSLOW | SFGAO_FOLDER) && m_pDUIView->ShouldShowMiniPreview())
                            {
                                _AddMiniPreviewerToList(psf, pidl);
                                bDetailsAvailable = TRUE;
                            }

                            LPITEMIDLIST  pidlFull;
                            if (SUCCEEDED(SHILCombine(pidlFolder, pidlItem, &pidlFull)))
                            {
                                if (SUCCEEDED(m_pDUIView->InitializeDetailsInfo(
                                        CNameSpaceItemInfoList::WindowProc)))
                                {
                                    m_pDUIView->SetDetailsInfoMsgWindowPtr(this, NULL);
                                    m_pDUIView->StartInfoExtraction(pidlFull);
                                    bDetailsAvailable = TRUE;
                                }
                                ILFree(pidlFull);
                            }

                            psf->Release();
                        }
                    }
                    else
                    {
                        hr = _OnMultiSelect(psfRoot, pida);
                        bDetailsAvailable = SUCCEEDED(hr);
                    }
                    psfRoot->Release();
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }

            pdtobj->Release();
        }


        if (!pdtobj || !bDetailsAvailable)
        {
            pDUIView->ShowDetails(FALSE);
        }
    }
    return hr;
}

LRESULT CALLBACK CNameSpaceItemInfoList::WindowProc(HWND hwnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam)
{
    CNameSpaceItemInfoList* pNSIInfoList = (CNameSpaceItemInfoList*)::GetWindowPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_DESTROY:
        // ignore late messages
        {
            MSG msg;
            while (PeekMessage(&msg, hwnd, WM_DETAILS_INFO, WM_DETAILS_INFO, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    CDetailsInfoList* pDetailsInfoList = (CDetailsInfoList*)msg.lParam;
                    // The destructor will do the necessary cleanup
                    delete pDetailsInfoList;
                }
            }
            SetWindowPtr(hwnd, 0, NULL);
        }
        break;

    case WM_DETAILS_INFO:
    {
        // Check that pDetailsInfo is still alive and that you have a CDetailsInfoList object of the requested pidl
        CDetailsInfoList* pDetailsInfoList = (CDetailsInfoList*)lParam;
        if (pDetailsInfoList && pNSIInfoList
                && (wParam == pNSIInfoList->m_pDUIView->_dwDetailsInfoID))
        {
            BOOL fShow = FALSE;

            StartDefer();

            Element * peDetailsInfoArea = pNSIInfoList->GetParent();

            if (peDetailsInfoArea)
            {
                peDetailsInfoArea->RemoveLocalValue(HeightProp);
            }

            for (int i = 0; i < pDetailsInfoList->_nProperties; i++)
            {
                if (!pDetailsInfoList->_diProperty[i].bstrValue)
                {
                    continue;
                }

                // 253647 - surpress the comment field from showing in the
                // Details section.  Note, I left the support for Comments
                // in the code below because this decision might be reversed.
                if (IsEqualSCID(pDetailsInfoList->_diProperty[i].scid, SCID_Comment))
                {
                    continue;
                }
                
                WCHAR wszInfoString[INTERNET_MAX_URL_LENGTH];
                wszInfoString[0] = L'\0';
                
                SHCOLUMNID scid = pDetailsInfoList->_diProperty[i].scid;
                // No DisplayName if we don't have one
                // or if it is one of the following properties
                if ((!pDetailsInfoList->_diProperty[i].bstrDisplayName)
                        || ( IsEqualSCID(scid, SCID_NAME)
                        ||   IsEqualSCID(scid, SCID_TYPE)
                        ||   IsEqualSCID(scid, SCID_Comment) ))
                {
                    StrCpyNW(wszInfoString, pDetailsInfoList->_diProperty[i].bstrValue, ARRAYSIZE(wszInfoString));
                }
                else
                {
                    // Now, combine the display name and value, seperated by a colon
                    // ShellConstructMessageString here to form the string
                    WCHAR wszFormatStr[50];
                    LoadStringW(HINST_THISDLL, IDS_COLONSEPERATED, wszFormatStr, ARRAYSIZE(wszFormatStr));
                    FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, wszFormatStr, 0, 0,
                            wszInfoString, ARRAYSIZE(wszInfoString),
                            pDetailsInfoList->_diProperty[i].bstrDisplayName,
                            pDetailsInfoList->_diProperty[i].bstrValue);
                }

                if (wszInfoString[0])
                {
                    Element* pElement;
                    HRESULT hr = CNameSpaceItemInfo::Create(wszInfoString, &pElement);
                    if (SUCCEEDED(hr))
                    {
                        hr = pNSIInfoList->Add(pElement);
                        
                        if (IsEqualSCID(scid, SCID_NAME))
                        {
                            pElement->SetID(L"InfoName");
                        }
                        else if (IsEqualSCID(scid, SCID_TYPE))
                        {
                            pElement->SetID(L"InfoType");
                        }
                        else if (IsEqualSCID(scid, SCID_Comment))
                        {
                            pElement->SetID(L"InfoTip");
                        }

                        fShow = TRUE;
                    }
                }
            }

            pNSIInfoList->m_pDUIView->ShowDetails(fShow);

            EndDefer();
        }

        if (pDetailsInfoList)
        {
            delete pDetailsInfoList;    // The destructor will do the necessary cleanup
        }
        break;
    }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return (LRESULT)0;
}

HRESULT CNameSpaceItemInfoList::_AddMiniPreviewerToList(IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    Element* pElement;
    HRESULT hr = CMiniPreviewer::Create(m_pDUIView, psf, pidl, &pElement);
    if (SUCCEEDED(hr))
    {
        hr = Add(pElement);
    }
    return E_NOTIMPL;
}

#define MAX_FILES_FOR_COMPUTING_SIZE        100

HRESULT CNameSpaceItemInfoList::_OnMultiSelect(IShellFolder2 *psfRoot, LPIDA pida)
{
    WCHAR wszText[INTERNET_MAX_URL_LENGTH];
    
    // Get the format string for n selection text
    WCHAR wszFormatStr[128];
    LoadStringW(HINST_THISDLL, IDS_NSELECTED, wszFormatStr, ARRAYSIZE(wszFormatStr));

    // Now, form the n selection text
    wnsprintfW(wszText, ARRAYSIZE(wszText), wszFormatStr, pida->cidl);

    WCHAR wszTemp[MAX_PATH];
    wszTemp[0] = 0;
    
    CComPtr<IPropertyUI> spPropertyUI;
    HRESULT hr = _GetPropertyUI(&spPropertyUI);
    if (SUCCEEDED(hr))
    {
        ULONGLONG ullSizeTotal = 0;
        if (pida->cidl <= MAX_FILES_FOR_COMPUTING_SIZE)
        {
            // Compute the total size and the names of the selected files
            for (UINT i = 0; i < pida->cidl; i++)
            {
                IShellFolder2 *psf;
                LPCITEMIDLIST pidl;
                hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder2, &psf), &pidl);
                if (SUCCEEDED(hr))
                {
                    ULONGLONG ullSize;
                    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
                    {
                        ullSizeTotal += ullSize;
                    }
                    psf->Release();
                }
            }
        }

        // Get the display string for Total Size
        if (ullSizeTotal > 0)
        {
            // Convert ullSizeTotal to a string
            PROPVARIANT propvar;
            propvar.vt = VT_UI8;
            propvar.uhVal.QuadPart = ullSizeTotal;

            WCHAR wszFormattedTotalSize[128];
            if (SUCCEEDED(spPropertyUI->FormatForDisplay(SCID_SIZE.fmtid, SCID_SIZE.pid,
                    &propvar, PUIFFDF_DEFAULT, wszFormattedTotalSize,
                    ARRAYSIZE(wszFormattedTotalSize))))
            {
                // Get the format string for Total File Size text
                LoadStringW(HINST_THISDLL, IDS_TOTALFILESIZE, wszFormatStr, ARRAYSIZE(wszFormatStr));

                // Now, form the Total File Size text
                wnsprintfW(wszTemp, ARRAYSIZE(wszTemp), wszFormatStr, wszFormattedTotalSize);
            }
        }
    }

    if (wszTemp[0])
    {
        // Append two line breaks
        StrCatBuffW(wszText, L"\n\n", ARRAYSIZE(wszText));
        // Append the Total Size string
        StrCatBuffW(wszText, wszTemp, ARRAYSIZE(wszText));
    }

    // Now make a dui gadget for wszText
    Element* pElement;
    if (SUCCEEDED(CNameSpaceItemInfo::Create(wszText, &pElement)))
    {
        Add(pElement);
    }

    return S_OK;
}

IClassInfo* CNameSpaceItemInfoList::Class = NULL;
HRESULT CNameSpaceItemInfoList::Register()
{
    return ClassInfo<CNameSpaceItemInfoList,Element>::Register(L"NameSpaceItemInfoList", NULL, 0);
}


STDMETHODIMP CNameSpaceItemInfo::Create(WCHAR* pwszInfoString, Element** ppElement)
{
    *ppElement = NULL;
    HRESULT hr = E_FAIL;

    CNameSpaceItemInfo* pNSIInfo = HNewAndZero<CNameSpaceItemInfo>();
    if (!pNSIInfo)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNSIInfo->Initialize(pwszInfoString);
        if (SUCCEEDED(hr))
            *ppElement = pNSIInfo;
        else
            pNSIInfo->Destroy();
    }
    return hr;
}

STDMETHODIMP CNameSpaceItemInfo::Initialize(WCHAR* pwszInfoString)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        hr = SetContentString(pwszInfoString);
    }
    return hr;
}

IClassInfo* CNameSpaceItemInfo::Class = NULL;
HRESULT CNameSpaceItemInfo::Register()
{
    return ClassInfo<CNameSpaceItemInfo,Element>::Register(L"NameSpaceItemInfo", NULL, 0);
}


STDMETHODIMP CBitmapElement::Create(HBITMAP hBitmap, Element** ppElement)
{
    *ppElement = NULL;
    HRESULT hr;

    CBitmapElement* pBitmapElement = HNewAndZero<CBitmapElement>();
    if (!pBitmapElement)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pBitmapElement->Initialize(hBitmap);
        if (SUCCEEDED(hr))
            *ppElement = pBitmapElement;
        else
            pBitmapElement->Destroy();
    }
    return hr;
}

STDMETHODIMP CBitmapElement::Initialize(HBITMAP hBitmap)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        if (hBitmap)
        {
            Value* pGraphic = Value::CreateGraphic(hBitmap);
            if (pGraphic)
            {
                SetValue(ContentProp, PI_Local, pGraphic);
                pGraphic->Release();
            }
        }
    }
    return hr;
}

IClassInfo* CBitmapElement::Class = NULL;
HRESULT CBitmapElement::Register()
{
    return ClassInfo<CBitmapElement,Element>::Register(L"BitmapElement", NULL, 0);
}


CMiniPreviewer::~CMiniPreviewer()
{
    // We are going away
    if (m_pDUIView)
    {
        m_pDUIView->SetThumbnailMsgWindowPtr(NULL, this);
        m_pDUIView->Release();
    }
}

STDMETHODIMP CMiniPreviewer::Create(CDUIView* pDUIView, IShellFolder2* psf, LPCITEMIDLIST pidl, Element** ppElement)
{
    HRESULT hr;

    *ppElement = NULL;

    CMiniPreviewer* pMiniPreviewer = HNewAndZero<CMiniPreviewer>();
    if (!pMiniPreviewer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pMiniPreviewer->Initialize(pDUIView, psf, pidl);
        if (SUCCEEDED(hr))
            *ppElement = pMiniPreviewer;
        else
            pMiniPreviewer->Destroy();
    }

    return hr;
}

STDMETHODIMP CMiniPreviewer::Initialize(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        (m_pDUIView = pDUIView)->AddRef();

        LPITEMIDLIST pidlFull;
        if (SUCCEEDED(SHFullIDListFromFolderAndItem(psf, pidl, &pidlFull)))
        {
            if (SUCCEEDED(m_pDUIView->InitializeThumbnail(CMiniPreviewer::WindowProc)))
            {
                m_pDUIView->SetThumbnailMsgWindowPtr(this, NULL);
                m_pDUIView->StartBitmapExtraction(pidlFull);
            }
            ILFree(pidlFull);
        }
    }
    return hr;
}

// Window procedure for catching the "image-extraction-done" message
// from m_pDUIView->_spThumbnailExtractor2
LRESULT CALLBACK CMiniPreviewer::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMiniPreviewer* pMiniPreviewer = (CMiniPreviewer*)::GetWindowPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_DESTROY:
        // ignore late messages
        {
            MSG msg;
            while (PeekMessage(&msg, hwnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            SetWindowPtr(hwnd, 0, NULL);
        }
        break;

    case WM_HTML_BITMAP:
        // Check that pMiniPreviewer is still alive and that you have an HBITMAP of the requested pidl
        if (pMiniPreviewer && (wParam == pMiniPreviewer->m_pDUIView->_dwThumbnailID))
        {
            if (lParam) // This is the HBITMAP of the extracted image
            {
                Element* pElement;
                HRESULT hr = CBitmapElement::Create((HBITMAP)lParam, &pElement);
                if (SUCCEEDED(hr))
                {
                    // The addition of the thumbnail comes in late.  DUI is
                    // not currently set up to handle a DisableAnimations()/
                    // EnableAnimations() here, which we were originally
                    // doing to prevent jumpiness.  This was discovered in
                    // RAID 389343, because our coming off the background
                    // thread and calling DisableAnimations() was screwing up
                    // other animations that were already underway.  Talking
                    // with markfi, the problem is understood BUT not one to
                    // be fixed because of the negative perf impact it would
                    // have on DUI.  So instead we'll StartDefer()/EndDefer()
                    // to minimize jumpiness from our two layout ops below.
                    StartDefer();

                    // Set the VerticalFlowLayout for our element. Otherwise,
                    // our control will not render.
                    Value* pvLayout = NULL;
                    hr = FillLayout::Create(0, NULL, &pvLayout);
                    if (SUCCEEDED(hr))
                    {
                        hr = pMiniPreviewer->SetValue(LayoutProp, PI_Local, pvLayout);
                        if (SUCCEEDED(hr))
                        {
                            hr = pMiniPreviewer->Add(pElement);
                        }
                        pvLayout->Release();
                    }
                    
                    if (FAILED(hr))
                    {
                        pElement->Destroy();
                    }

                    EndDefer();
                }
                else
                {
                    DeleteObject((HBITMAP)lParam);
                }
            }
        }
        else if (lParam)    // This extraction got done too late.
                            // So, just delete the wasted HBITMAP.
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return (LRESULT)0;
}

IClassInfo* CMiniPreviewer::Class = NULL;
HRESULT CMiniPreviewer::Register()
{
    return ClassInfo<CMiniPreviewer,Element>::Register(L"MiniPreviewer", NULL, 0);
}





// ***** CDetailsInfoList *******

CDetailsInfoList::CDetailsInfoList() : _nProperties(0)
{
}

CDetailsInfoList::~CDetailsInfoList()
{
    for (int i = 0; i < _nProperties; i++)
    {
        if (_diProperty[i].bstrValue)
        {
            SysFreeString(_diProperty[i].bstrValue);
        }
        if (_diProperty[i].bstrDisplayName)
        {
            SysFreeString(_diProperty[i].bstrDisplayName);
        }
    }
}

// ***** CDetailsSectionInfoTask *******

CDetailsSectionInfoTask::CDetailsSectionInfoTask(HRESULT *phr,
                                                 IShellFolder *psfContaining,
                                                 LPCITEMIDLIST pidlAbsolute,
                                                 HWND hwndMsg,
                                                 UINT uMsg,
                                                 DWORD dwDetailsInfoID)
                                                 : CRunnableTask(RTF_DEFAULT),
                                                   _hwndMsg(hwndMsg),
                                                   _uMsg(uMsg),
                                                   _dwDetailsInfoID(dwDetailsInfoID)
{
    ASSERT(psfContaining && pidlAbsolute && hwndMsg);

    _psfContaining = psfContaining;
    _psfContaining->AddRef();

    *phr = SHILClone(pidlAbsolute, &_pidlAbsolute);
}

CDetailsSectionInfoTask::~CDetailsSectionInfoTask()
{
    _psfContaining->Release();

    ILFree(_pidlAbsolute);
}

HRESULT CDetailsSectionInfoTask_CreateInstance(IShellFolder *psfContaining,
                                               LPCITEMIDLIST pidlAbsolute,
                                               HWND hwndMsg,
                                               UINT uMsg,
                                               DWORD dwDetailsInfoID,
                                               CDetailsSectionInfoTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CDetailsSectionInfoTask* pNewTask = new CDetailsSectionInfoTask(
        &hr,
        psfContaining,
        pidlAbsolute,
        hwndMsg,
        uMsg,
        dwDetailsInfoID);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = pNewTask;
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CDetailsSectionInfoTask::RunInitRT()
{
    ASSERT(_pidlAbsolute);
    
    BOOL bMsgPosted = FALSE;

    HRESULT hr = E_FAIL;
    CDetailsInfoList* pCDetailsInfoList = new CDetailsInfoList;
    if (!pCDetailsInfoList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CComPtr<IShellFolder2>  psf2;
        LPCITEMIDLIST           pidlLast;
        hr = SHBindToIDListParent(_pidlAbsolute, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
        if (SUCCEEDED(hr))
        {
            _SetParentAndItem(psf2, pidlLast);

            WCHAR wszProperties[MAX_PATH];
            hr = _GetDisplayedDetailsProperties(psf2, pidlLast, wszProperties, ARRAYSIZE(wszProperties));
            if (SUCCEEDED(hr))
            {
                // pwszProperties is usually of the form "prop:Name;Type;Author"
                CComPtr<IPropertyUI> spPropertyUI;
                hr = _GetPropertyUI(&spPropertyUI);
                if (SUCCEEDED(hr))
                {
                    SHCOLUMNID scid;
                    WCHAR wszInfoString[INTERNET_MAX_URL_LENGTH];
                    
                    ULONG chEaten = 0;  // loop var, incremented by ParsePropertyName
                    for (pCDetailsInfoList->_nProperties = 0;
                            pCDetailsInfoList->_nProperties < ARRAYSIZE(pCDetailsInfoList->_diProperty)
                                && SUCCEEDED(spPropertyUI->ParsePropertyName(wszProperties, &scid.fmtid, &scid.pid, &chEaten));
                            pCDetailsInfoList->_nProperties++)
                    {
                        pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].scid = scid;
                        
                        PROPERTYUI_FORMAT_FLAGS flagsFormat = IsEqualSCID(scid, SCID_WRITETIME) ? PUIFFDF_FRIENDLYDATE : PUIFFDF_DEFAULT;
                        // Get the display value
                        hr = GetPropertyDisplayValue(scid, wszInfoString, ARRAYSIZE(wszInfoString), flagsFormat);
                        if (SUCCEEDED(hr) && wszInfoString[0])
                        {
                            pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].bstrValue = SysAllocString(wszInfoString);
                        }

                        // Get the display name
                        hr = GetPropertyDisplayName(scid, wszInfoString, ARRAYSIZE(wszInfoString));
                        if (SUCCEEDED(hr) && wszInfoString[0])
                        {
                            pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].bstrDisplayName = SysAllocString(wszInfoString);
                        }
                    }

                    //The extraction is done. Now post a message.
                    if (PostMessage(_hwndMsg, WM_DETAILS_INFO,
                            (WPARAM)_dwDetailsInfoID, (LPARAM)pCDetailsInfoList))
                    {
                        bMsgPosted = TRUE;
                    }
                }
            }

        }
    }

    if (!bMsgPosted && pCDetailsInfoList)
    {
        delete pCDetailsInfoList;
    }
    return S_OK;
}


HRESULT CDetailsSectionInfoTask::_GetDisplayedDetailsProperties(IShellFolder2* psf,
                                                                LPCITEMIDLIST pidl,
                                                                WCHAR* pwszProperties,
                                                                int cchProperties)
{
    HRESULT hr = GetStringProperty(psf, pidl, &SCID_DetailsProperties, pwszProperties, cchProperties);
    if (FAILED(hr)) // Default properties
    {
        if (SHGetAttributes(psf, pidl, SFGAO_ISSLOW))
        {
            // SCID_NAME;SCID_TYPE
            StrCpyNW(pwszProperties, L"prop:Name;Type", cchProperties);
        }
        else
        {
            // SCID_NAME;SCID_TYPE;SCID_ATTRIBUTES_DESCRIPTION;SCID_Comment;SCID_WRITETIME;SCID_SIZE;SCID_Author;SCID_CSC_STATUS
            StrCpyNW(pwszProperties, L"prop:Name;Type;AttributesDescription;DocComments;Write;Size;DocAuthor;CSCStatus", cchProperties);
        }
    }

    // Augment properties to include "Location" if in CLSID_DocFindFolder.
    IPersist *pPersist;
    ASSERT(_psfContaining);
    if (SUCCEEDED(_psfContaining->QueryInterface(IID_IPersist, (void**)&pPersist)))
    {
        CLSID clsid;
        if (SUCCEEDED(pPersist->GetClassID(&clsid)) && IsEqualCLSID(clsid, CLSID_DocFindFolder))
            _AugmentDisplayedDetailsProperties(pwszProperties, cchProperties);
        pPersist->Release();
    }

    return S_OK;
}

void CDetailsSectionInfoTask::_AugmentDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t cchDetailsProperties)
{
    static WCHAR  szDeclarator[]    = L"prop:";
    static size_t lenDeclarator     = lstrlen(szDeclarator);
    static WCHAR  szName[64]        = { 0 };
    static size_t lenName           = 0;
    static WCHAR  szType[64]        = { 0 };
    static size_t lenType           = 0;
    static WCHAR  szDirectory[64]   = { 0 };
    static size_t lenDirectory      = 0;

    // Initialize statics once 'n only once.
    if (!szName[0] || !szType[0] || !szDirectory[0])
    {
        HRESULT hr;

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_NAME, szName, ARRAYSIZE(szName));
        ASSERT(SUCCEEDED(hr));
        lenName = lstrlen(szName);

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_TYPE, szType, ARRAYSIZE(szType));
        ASSERT(SUCCEEDED(hr));
        lenType = lstrlen(szType);

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_DIRECTORY, szDirectory, ARRAYSIZE(szDirectory));
        ASSERT(SUCCEEDED(hr));
        lenDirectory = lstrlen(szDirectory);
    }

    // Attempt to merge the "Directory" property, in the following ways:
    //  "prop:Name;Type;Directory;..."
    //  "prop:Name;Directory;..."
    //  "prop:Directory;..."
    //
    size_t lenDetailsProperties = lstrlen(pszDetailsProperties);
    size_t lenMerged = lenDetailsProperties + 1 + lenDirectory;
    if (lenMerged < cchDetailsProperties && 0 == StrCmpNI(pszDetailsProperties, szDeclarator, lenDeclarator))
    {
        // Search for "Directory" property (in case it is already specified).
        if (!_SearchDisplayedDetailsProperties(pszDetailsProperties, lenDetailsProperties, szDirectory, lenDirectory))
        {
            // Allocate a temporary buffer to merge into.
            size_t cchMerged = cchDetailsProperties;
            LPWSTR pszMerged = new WCHAR[cchMerged];
            if (pszMerged)
            {
                // Determine offset in pszDetailsProperties to merge at.
                size_t offsetInsert;
                if (lenDeclarator < lenDetailsProperties)
                {
                    // Search for "Name" property.
                    LPWSTR pszName = _SearchDisplayedDetailsProperties(
                        &pszDetailsProperties[lenDeclarator],
                        lenDetailsProperties - lenDeclarator,
                        szName,
                        lenName);
                    if (pszName)
                    {
                        // Search for "Type" property (immediately following "Name").
                        size_t offsetName = (pszName - pszDetailsProperties);
                        size_t offsetType = offsetName + lenName + 1;
                        size_t offsetRemainder = offsetType + lenType;
                        if ((offsetRemainder == lenDetailsProperties || (offsetRemainder < lenDetailsProperties && pszDetailsProperties[offsetRemainder] == ';')) &&
                            !StrCmpNI(&pszDetailsProperties[offsetType], szType, lenType))
                        {
                            offsetInsert = offsetRemainder;
                        }
                        else
                            offsetInsert = offsetName + lenName;
                    }
                    else
                        offsetInsert = lenDeclarator;
                }
                else
                    offsetInsert = lenDeclarator;

                // Merge the "Directory" property.
                StrCpyN(pszMerged, pszDetailsProperties, offsetInsert + 1); // + 1 to account for null terminator.
                if (offsetInsert > lenDeclarator)                           
                    StrCatBuff(pszMerged, L";", cchMerged);                 // ';' prepend if necessary
                StrCatBuff(pszMerged, szDirectory, cchMerged);              // "Directory"
                if (offsetInsert < lenDetailsProperties)
                {
                    if (pszDetailsProperties[offsetInsert] != ';')
                        StrCatBuff(pszMerged, L";", cchMerged);             // ';' append if necessary
                    StrCatBuff(pszMerged, &pszDetailsProperties[offsetInsert], cchMerged);
                }

                // Update in/out pszDetailsProperties.
                StrCpyN(pszDetailsProperties, pszMerged, cchDetailsProperties);
                ASSERT(lenMerged == lstrlen(pszMerged));
                ASSERT(lenMerged < cchDetailsProperties);
                delete[] pszMerged;
            }
        }
    }
    else
    {
        // Invalid format.
        ASSERT(FALSE);
    }
}

LPWSTR CDetailsSectionInfoTask::_SearchDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties, LPWSTR pszProperty, size_t lenProperty)
{
    LPWSTR psz = StrStrI(pszDetailsProperties, pszProperty);
    while (psz)
    {
        // Check start...
        if (psz == pszDetailsProperties || psz[-1] == ';')
        {
            // ... and end.
            size_t lenToEndOfProperty = (psz - pszDetailsProperties) + lenProperty;
            if (lenToEndOfProperty == lenDetailsProperties || pszDetailsProperties[lenToEndOfProperty] == ';')
                break;
        }

        psz = StrStrI(psz + lenProperty, pszProperty);
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duilist.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duilist.h"


// DUIListView

DUIListView::~DUIListView()
{
    DetachListview();
}

void DUIListView::DetachListview()
{
    if (m_hwndListview)
    {
        // Unhook DUI from the HWND before doing this
        HWNDHost::Detach();

        if (m_bClientEdge)
            SetWindowBits(m_hwndListview, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);

        ShowWindow(m_hwndListview, SW_HIDE);       // HIDE IT SO IT doesn't flash before switching.
        SHSetParentHwnd(m_hwndListview, m_hwndLVOrgParent);
    }
}

HRESULT DUIListView::Create(UINT nActive, HWND hwndListView, OUT Element** ppElement)
{
    *ppElement = NULL;

    DUIListView* pDUIListView = HNewAndZero<DUIListView>();
    if (!pDUIListView)
        return E_OUTOFMEMORY;

    HRESULT hr = pDUIListView->Initialize(nActive, hwndListView);
    if (FAILED(hr))
    {
        pDUIListView->Destroy();
        return E_OUTOFMEMORY;
    }

    pDUIListView->SetAccessible(true);
    *ppElement = pDUIListView;

    return S_OK;
}

HWND DUIListView::CreateHWND(HWND hwndParent)
{
    m_hwndParent = hwndParent;

    // Save the original parent window handle

    m_hwndLVOrgParent = ::GetParent(m_hwndListview);

    SHSetParentHwnd(m_hwndListview, hwndParent);

    LONG lExStyle = GetWindowLong(m_hwndListview, GWL_EXSTYLE);

    m_bClientEdge = lExStyle & WS_EX_CLIENTEDGE ? TRUE : FALSE;

    if (m_bClientEdge)
    {
        lExStyle &= ~WS_EX_CLIENTEDGE;
        SetWindowLong(m_hwndListview, GWL_EXSTYLE, lExStyle);
    }

    return m_hwndListview;
}

// Global action callback

UINT DUIListView::MessageCallback(GMSG* pGMsg)
{
    return HWNDHost::MessageCallback(pGMsg);
}

// Pointer is only guaranteed good for the lifetime of the call
void DUIListView::OnInput(InputEvent* pie)
{

    // Bypass HWNDHost::OnInput for tab input events so they aren't forwarded
    // to the HWND control. Element::OnInput will handle the events (keyboard nav)

    if (pie->nStage == GMF_DIRECT)
    {
        if (pie->nDevice == GINPUT_KEYBOARD)
        {
            KeyboardEvent* pke = (KeyboardEvent*)pie;

            if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
            {
                if (pke->ch == VK_TAB)
                {
                    Element::OnInput(pie);
                    return;
                }
            }
            else if (pke->nCode == GKEY_CHAR) // Characters
            {
                if (pke->ch == 9)
                {
                    Element::OnInput(pie);
                    return;
                }
            }
        }
    }

    HWNDHost::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties

// Define class info with type and base type, set static class pointer

IClassInfo* DUIListView::Class = NULL;
HRESULT DUIListView::Register()
{
    return ClassInfo<DUIListView,HWNDHost>::Register(L"DUIListView", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duiinfo.h ===
#ifndef _DUIINFO_
#define _DUIINFO_

#include "defviewp.h"
#include "duiview.h"
#include "prop.h"

class CNameSpaceItemUIProperty
{
public:
    virtual ~CNameSpaceItemUIProperty();
    
    STDMETHODIMP GetPropertyDisplayName(SHCOLUMNID scid, WCHAR* pwszPropDisplayName, int cchPropDisplayName);
    STDMETHODIMP GetPropertyDisplayValue(SHCOLUMNID scid, WCHAR* pwszPropDisplayValue, int cchPropDisplayValue, PROPERTYUI_FORMAT_FLAGS flagsFormat);
    STDMETHODIMP GetInfoString(SHCOLUMNID scid, WCHAR* pwszInfoString, int cchInfoString);

protected:
    HRESULT _GetPropertyUI(IPropertyUI** ppPropertyUI);
    void _SetParentAndItem(IShellFolder2 *psf, LPCITEMIDLIST pidl);

private:
    
    CComPtr<IPropertyUI>    m_spPropertyUI;
    IShellFolder2           *m_psf;             // alias to current psf
    LPCITEMIDLIST           m_pidl;             // alias to current relative pidl
};


class CNameSpaceItemInfoList : public Element, public CNameSpaceItemUIProperty
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, NULL, NULL, ppElement); }
    static STDMETHODIMP Create(CDUIView* pDUIView, Value* pvDetailsSheet,IShellItemArray *psiItemArray,
            Element** ppElement);

    STDMETHODIMP Initialize(CDUIView* pDUIView, Value* pvDetailsSheet,IShellItemArray *psiItemArray);

    // Window procedure for catching the "info-extraction-done" message
    // from CDetailsSectionInfoTask::RunInitRT
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
            LPARAM lParam);

private:
    HRESULT _AddMiniPreviewerToList(IShellFolder2 *psf, LPCITEMIDLIST pidl);
    HRESULT _OnMultiSelect(IShellFolder2 *psfRoot, LPIDA pida);

    CDUIView*               m_pDUIView;
};


class CNameSpaceItemInfo : public Element
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(L"", ppElement); }
    static STDMETHODIMP Create(WCHAR* pwszInfoString, Element** ppElement);

    STDMETHODIMP Initialize(WCHAR* pwszInfoString);
};

class CMiniPreviewer : public Element
{
public:
    ~CMiniPreviewer();
    
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, NULL, NULL, ppElement); }
    static STDMETHODIMP Create(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl, Element** ppElement);

    STDMETHODIMP Initialize(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl);

    // Window procedure for catching the "image-extraction-done" message
    // from m_pDUIView->m_spThumbnailExtractor2
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    CDUIView*               m_pDUIView;
};

class CBitmapElement : public Element
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, ppElement); }
    static STDMETHODIMP Create(HBITMAP hBitmap, Element** ppElement);

    STDMETHODIMP Initialize(HBITMAP hBitmap);
};




typedef struct
{
    SHCOLUMNID  scid;
    BSTR        bstrValue;
    BSTR        bstrDisplayName;
} DetailsInfo;

// A wrapper class around a DetailsInfo array. See CDetailsSectionInfoTask for its use.
class CDetailsInfoList
{
public:
    CDetailsInfoList();
    ~CDetailsInfoList();

    DetailsInfo     _diProperty[20];    // A max of 20 properties allowed
    int             _nProperties;       // The count of properties
};


// Task used to extract the Details Section info in the background:
// Given a pidl, this task extracts the display names and display values
// of properties mentioned by SCID_WebViewDisplayProperties.
// Once the extraction is done, it posts uMsg to hwndMsg
// with lParam == pointer to an object of CDetailsInfoList
// wParam == the ID of the info extraction, the results of which are in lParam
class CDetailsSectionInfoTask : public CRunnableTask, public CNameSpaceItemUIProperty
{
public:
    CDetailsSectionInfoTask(HRESULT *phr, IShellFolder *psfContaining, LPCITEMIDLIST pidlAbsolute, HWND hwndMsg, UINT uMsg, DWORD dwDetailsInfoID);
    STDMETHODIMP RunInitRT();

protected:
    ~CDetailsSectionInfoTask();

    // Helper functions
    HRESULT _GetDisplayedDetailsProperties(IShellFolder2 *psf, LPCITEMIDLIST pidl, WCHAR* pwszProperties, int cch);
    void    _AugmentDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties);
    LPWSTR  _SearchDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties, LPWSTR pszProperty, size_t lenProperty);

    IShellFolder *  _psfContaining;     // AddRef()'d
    LPITEMIDLIST    _pidlAbsolute;      // SHILClone()'d
    HWND            _hwndMsg;           // the window to post _uMsg to
    UINT            _uMsg;
    DWORD           _dwDetailsInfoID;   // an ID to the current info extraction
};

#endif _DUIINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duilist.h ===
// DUIListView

// Class definition
class DUIListView : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, ppElement); }
    static HRESULT Create(UINT nActive, HWND hwndListView, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    void DetachListview();

    DUIListView() { }
    ~DUIListView();
    HRESULT Initialize(UINT nActive, HWND hwndListView) { m_hwndListview = hwndListView; return HWNDHost::Initialize(HHC_CacheFont | HHC_NoMouseForward, nActive); }

    virtual HWND CreateHWND(HWND hwndParent);

private:

    HWND m_hwndParent;
    HWND m_hwndLVOrgParent;
    HWND m_hwndListview;
    BOOL m_bClientEdge;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duisec.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "duiview.h"
#include "duisec.h"
#include "duitask.h"


////////////////////////////////////////////////////////
// Expando class
////////////////////////////////////////////////////////

// Cached IDs
ATOM Expando::idTitle = NULL;
ATOM Expando::idIcon = NULL;
ATOM Expando::idTaskList = NULL;
ATOM Expando::idWatermark = NULL;


HRESULT Expando::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expando* pex = HNewAndZero<Expando>();
    if (!pex)
        return E_OUTOFMEMORY;

    HRESULT hr = pex->Initialize();
    if (FAILED(hr))
    {
        pex->Destroy();
        return hr;
    }

    *ppElement = pex;

    return S_OK;
}

Expando::Expando()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_puiHeader   == NULL);
    ASSERT(_pDUIView    == NULL);
    ASSERT(_pDefView    == NULL);

    // Initialize member variables.
    _eDUISecID = DUISEC_UNKNOWN;
    _bInfotip = FALSE;
}
Expando::~Expando()
{
    DeleteAtom(idTitle);
    DeleteAtom(idIcon);
    DeleteAtom(idTaskList);
    DeleteAtom(idWatermark);

    if (_bInfotip)
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);

    if (_puiHeader)
        _puiHeader->Release();

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}

HRESULT Expando::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    _fExpanding = false;
    SetSelected(true);

    // Cache atoms used for loading from resources
    idTitle = AddAtomW(L"title");
    idIcon = AddAtomW(L"icon");
    idTaskList = AddAtomW(L"tasklist");
    idWatermark = AddAtomW(L"watermark");

    return S_OK;
}

void Expando::Initialize(DUISEC eDUISecID, IUIElement *puiHeader, CDUIView *pDUIView, CDefView *pDefView)
{
    ASSERT(eDUISecID != DUISEC_UNKNOWN);
    ASSERT(pDUIView);
    ASSERT(pDefView);

    _eDUISecID = eDUISecID;

    _puiHeader = puiHeader;
    if (_puiHeader)
        _puiHeader->AddRef();

    pDUIView->AddRef();
    _pDUIView = pDUIView;

    pDefView->AddRef();
    _pDefView = pDefView;

    _SetAccStateInfo(TRUE);
}

HRESULT Expando::ShowInfotipWindow(Element *peHeader, BOOL bShow)
{
    HRESULT hr;

    if (_puiHeader)
    {
        RECT rect = { 0 };

        if (bShow)
        {
            _pDUIView->CalculateInfotipRect(peHeader, &rect);
            if (_bInfotip)
            {
                // Reposition infotip at position.
                hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
            }
            else
            {
                // Create infotip at position (on the ui thread).
                LPWSTR pwszInfotip;
                hr = _puiHeader->get_Tooltip(NULL, &pwszInfotip);
                if (SUCCEEDED(hr))
                {
                    hr = GetElementRootHWND(this, &_hwndRoot);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDefView->CreateInfotip(_hwndRoot, (UINT_PTR)this, &rect, pwszInfotip, 0);
                        if (SUCCEEDED(hr))
                        {
                            _bInfotip = TRUE;
                        }
                    }
                    CoTaskMemFree(pwszInfotip);
                }
            }
        }
        else
        {
            if (_bInfotip)
            {
                // Reposition infotip at nowhere.
                hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
            }
            else
            {
                // No infotip == no show!
                hr = S_OK;
            }
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

void Expando::OnEvent(Event* pev)
{
    if (pev->uidType == Button::Click)
    {
        // Update exanded property based on clicks that originate
        // only from the first child's subtree
        Value* pv;
        ElementList* peList = GetChildren(&pv);

        if (peList && peList->GetSize() > 0)
        {
            if (peList->GetItem(0) == GetImmediateChild(pev->peTarget))
            {
                SetSelected(!GetSelected());
                pev->fHandled = true;
            }
        }

        pv->Release();
    }

    Element::OnEvent(pev);
}

////////////////////////////////////////////////////////
// System events

void Expando::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        // Update height of second child based on expanded state
        Value* pvChildren;
        ElementList* peList = GetChildren(&pvChildren);
        if (peList && peList->GetSize() > 1)
        {
            // The following will cause a relayout, mark object so that
            // when the expando's Extent changes, it'll go through
            // with the EnsureVisible. Otherwise, it's being resized
            // as a result of something else. In which case, do nothing.
            _fExpanding = true;

            Element* pe = peList->GetItem(1);

            // To achieve "pulldown" animation, we use a clipper control that will
            // size it's child based on it's unconstrained desired size in its Y direction.
            //
            if (pvNew->GetBool())
            {
                pe->RemoveLocalValue(HeightProp);
                _pDUIView->OnExpandSection(_eDUISecID, TRUE);
            }
            else
            {
                pe->SetHeight(0);
                _pDUIView->OnExpandSection(_eDUISecID, FALSE);
            }

        }
        pvChildren->Release();

        _SetAccStateInfo(pvNew->GetBool());
    }
    else if (IsProp(Extent))
    {
        if (_fExpanding && GetSelected())
        {
            _fExpanding = false;

            // On extent, we want to ensure that not just the client area but
            // also the bottom margin of the expando is visible.  Why?  Simply
            // because it looks better to scroll the expando plus its margin
            // into view versus just the expando.
            //
            Value* pvSize;
            Value* pvMargin;
            const SIZE* psize = GetExtent(&pvSize);
            const RECT* prect = GetMargin(&pvMargin);
            EnsureVisible(0, 0, psize->cx, psize->cy + prect->bottom);
            pvSize->Release();
            pvMargin->Release();
        }
    }
    else if (IsProp(MouseWithin))
    {
        // Extended processing for infotip...
        Value* pvChildren;
        ElementList* peList = GetChildren(&pvChildren);
        if (peList && peList->GetSize() > 0 && pvNew->GetBool() && SHShowInfotips())
        {
            // ... only displays tip if mouse is within title of Expando.
            Element *peHeader = peList->GetItem(0);
            ShowInfotipWindow(peHeader, peHeader->GetMouseWithin());
        }
        else
        {
            ShowInfotipWindow(NULL, FALSE);
        }
        pvChildren->Release();

    }
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Expando::Class = NULL;
HRESULT Expando::Register()
{
    return ClassInfo<Expando,Element>::Register(L"Expando", NULL, 0);
}

void Expando::UpdateTitleUI(IShellItemArray *psiItemArray)
{
    if (_puiHeader)
    {
        LPWSTR pszTitle;
        if (SUCCEEDED(_puiHeader->get_Name(psiItemArray, &pszTitle)))
        {
            Value* pv = Value::CreateString(pszTitle);
            if (pv)
            {
                Element* pe = FindDescendent(StrToID(L"header"));

                if (pe)
                {
                    pe->SetAccessible(true);
                    pe->SetAccRole(ROLE_SYSTEM_OUTLINEBUTTON);
                    pe->SetValue (Element::AccNameProp, PI_Local, pv);
                }
                else
                {
                    TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: Button child for Expando not found.");
                }

                pe = FindDescendent (Expando::idTitle);
                if (pe)
                {
                    pe->SetValue (Element::ContentProp, PI_Local, pv);
                }
                else
                {
                    TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: FindDescendent for the title failed.");
                }
                pv->Release ();
            }
            else
            {
                TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: CreateString for the title failed.");
            }

            CoTaskMemFree(pszTitle);
        }
        else
        {
            TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: get_Name failed.");
        }
    }
}

void Expando::ShowExpando(BOOL fShow)
{
    if (fShow && (_fShow != TRIBIT_TRUE))
    {
        SetHeight(-1);
        RemoveLocalValue(MarginProp);

        _fShow = TRIBIT_TRUE;
    }

    if (!fShow && (_fShow != TRIBIT_FALSE))
    {
        SetHeight(0);
        SetMargin(0,0,0,0);
        
        _fShow = TRIBIT_FALSE;
    }
}

void Expando::_SetAccStateInfo (BOOL bExpanded)
{
    // Update the accessibility state information
    //
    // Note:  In the Expando::Initialize() method, we explicitly set the
    // Selected state to true.  This causes OnPropertyChanged to be called
    // for the Selected property, which will call this method.  However,
    // the child elements will not exist yet (since we are in the creation process).
    // Hence, the call to FindDescendent will return NULL and this method will exit.
    // This method is explicitly called in the second version of Initialze to
    // set the correct accessibility information.

    Element * pe = FindDescendent(StrToID(L"header"));

    if (pe)
    {
        TCHAR szDefaultAction[50] = {0};

        if (bExpanded)
        {
            pe->SetAccState(STATE_SYSTEM_EXPANDED);
            LoadString(HINST_THISDLL, IDS_EXPANDO_DEFAULT_ACTION_COLLAPSE, szDefaultAction, ARRAYSIZE(szDefaultAction));
        }
        else
        {
            pe->SetAccState(STATE_SYSTEM_COLLAPSED);
            LoadString(HINST_THISDLL, IDS_EXPANDO_DEFAULT_ACTION_EXPAND, szDefaultAction, ARRAYSIZE(szDefaultAction));
        }

        pe->SetAccDefAction(szDefaultAction);
    }
}

////////////////////////////////////////////////////////
// Clipper class
////////////////////////////////////////////////////////

HRESULT Clipper::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Clipper* pc = HNewAndZero<Clipper>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT Clipper::Initialize()
{
    // Initialize base
    HRESULT hr = Element::Initialize(EC_SelfLayout); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    return S_OK;
}

////////////////////////////////////////////////////////
// Self-layout methods

SIZE Clipper::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(cyConstraint);

    Value* pvChildren;
    SIZE size = { 0, 0 };
    ElementList* peList = GetChildren(&pvChildren);

    // Desired size of this is based solely on it's first child.
    // Width is child's width, height is unconstrained height of child.
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        size = pec->_UpdateDesiredSize(cxConstraint, INT_MAX, psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    pvChildren->Release();

    return size;
}

void Clipper::_SelfLayoutDoLayout(int cx, int cy)
{
    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    // Layout first child giving it's desired height and aligning
    // it with the clipper's bottom edge
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        const SIZE* pds = pec->GetDesiredSize();

        pec->_UpdateLayoutPosition(0, cy - pds->cy);
        pec->_UpdateLayoutSize(cx, pds->cy);
    }

    pvChildren->Release();
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Clipper::Class = NULL;
HRESULT Clipper::Register()
{
    return ClassInfo<Clipper,Element>::Register(L"Clipper", NULL, 0);
}


////////////////////////////////////////////////////////
// TaskList class
////////////////////////////////////////////////////////

HRESULT TaskList::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    TaskList* pc = HNewAndZero<TaskList>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT TaskList::Initialize()
{
    // Initialize base
    HRESULT hr = Element::Initialize(0); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    return S_OK;
}

////////////////////////////////////////////////////////
// Hierarchy

Element* TaskList::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    if ((iNavDir & NAV_LOGICAL) && peFrom)
        return NULL;

    return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
}


////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* TaskList::Class = NULL;
HRESULT TaskList::Register()
{
    return ClassInfo<TaskList,Element>::Register(L"TaskList", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duisec.h ===
class Expando: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static ATOM idTitle;
    static ATOM idIcon;
    static ATOM idTaskList;
    static ATOM idWatermark;

    void Initialize(DUISEC eDUISecID, IUIElement *puiHeader, CDUIView *pDUIView, CDefView *pDefView);

    void UpdateTitleUI(IShellItemArray *psiItemArray);

    void ShowExpando(BOOL fShow);
    void _SetAccStateInfo (BOOL bExpanded);

    Expando();
    virtual ~Expando();
    HRESULT Initialize();
    HRESULT ShowInfotipWindow(Element *peHeader, BOOL bShow);

private:
    bool        _fExpanding;
    TRIBIT      _fShow;
    DUISEC      _eDUISecID;
    IUIElement* _puiHeader;
    CDUIView*   _pDUIView;
    CDefView*   _pDefView;
    HWND        _hwndRoot;      // cache of root hwnd element's hwnd
    BOOL        _bInfotip;      // TRUE if infotip has been created
};


class TaskList: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    TaskList() { }
    virtual ~TaskList() { }
    HRESULT Initialize();

private:
};

class Clipper: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Clipper() { }
    virtual ~Clipper() { }
    HRESULT Initialize();

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duitask.h ===
HRESULT GetElementRootHWNDElement(Element *pe, HWNDElement **pphwndeRoot);
HRESULT GetElementRootHWND(Element *pe, HWND *phwnd);

class ActionTask: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(0, NULL, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement);

    // System event callbacks
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    void UpdateTaskUI();

    ActionTask();
    virtual ~ActionTask();

protected:
    HRESULT Initialize(IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView);
    HRESULT InitializeElement();    // init ActionTask DUI Element
    HRESULT InitializeButton();     // init ActionTask's DUI Button
    HRESULT ShowInfotipWindow(BOOL bShow);

private:
    Button*      _peButton;
    IUICommand*  _puiCommand;
    IShellItemArray* _psiItemArray;
    CDUIView*    _pDUIView; // weak link - do not ref.
    CDefView*    _pDefView;
    HWND         _hwndRoot;         // cache of root hwnd element's hwnd
    BOOL         _bInfotip;         // TRUE if infotip has been created
};


class DestinationTask: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(0, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, LPITEMIDLIST pidl, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement);

    // System event callbacks
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    DestinationTask();
    virtual ~DestinationTask();

protected:
    HRESULT Initialize(LPITEMIDLIST pidl, CDUIView* pDUIView, CDefView *pDefView);
    HRESULT InitializeElement();                                // init DestinationTask DUI Element
    HRESULT InitializeButton(HICON hIcon, LPCWSTR pwszTitle);   // init DestinationTask's DUI Button
    HRESULT InvokePidl();
    HRESULT OnContextMenu(POINT *ppt);
    HRESULT ShowInfotipWindow(BOOL bShow);

    HWND GetHWND()
    {
        if (!_peHost)
            GetElementRootHWNDElement(this, &_peHost);
        return _peHost ? _peHost->GetHWND() : NULL;
    }


private:
    Button*      _peButton;
    LPITEMIDLIST _pidlDestination;
    CDUIView*    _pDUIView;
    CDefView*    _pDefView;
    HWND         _hwndRoot;         // cache of root hwnd element's hwnd
    BOOL         _bInfotip;         // TRUE if infotip has been created

    // Caching host information
    HWNDElement *           _peHost;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duiview.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duilist.h"
#include "duisec.h"
#include "duitask.h"
#include "duiinfo.h"
#include "duihost.h"
#include "duidrag.h"
#include "defviewp.h"
#include "ids.h"
#include "dvtasks.h"
#include <shimgvw.h>
#include <uxtheme.h>
#include <shstyle.h>

UsingDUIClass(DUIListView);
UsingDUIClass(DUIAxHost);
UsingDUIClass(Expando);
UsingDUIClass(ActionTask);
UsingDUIClass(DestinationTask);


//
// These are private window messages posted to the host window
// so they will be processed async.  There are issues with
// trying to destroy a handler while inside of the handler
//

#define WM_NAVIGATETOPIDL  (WM_USER + 42)
#define WM_REFRESHVIEW     (WM_USER + 43)


#define DUI_HOST_WINDOW_CLASS_NAME  TEXT("DUIViewWndClassName")

//
// Default attributes associated with our DUI sections.
//

struct DUISEC_ATTRIBUTES {
    DUISEC  _eDUISecID;
    BOOL    _bExpandedDefault;
    LPCWSTR _pszExpandedPropName;
} const c_DUISectionAttributes[] = {
    DUISEC_SPECIALTASKS,        TRUE,   L"ExpandSpecialTasks",
    DUISEC_FILETASKS,           TRUE,   L"ExpandFileTasks",
    DUISEC_OTHERPLACESTASKS,    TRUE,   L"ExpandOtherPlacesTasks",
    DUISEC_DETAILSTASKS,        FALSE,  L"ExpandDetailsTasks"
};




//  pDefView - pointer to the defview class

CDUIView* Create_CDUIView(CDefView * pDefView)
{
    CDUIView* p = new CDUIView(pDefView);
    if (p)
    {
        if (FAILED(p->Initialize()))
        {
            delete p;
            p = NULL;
        }
    }
    return p;
}

CDUIView::CDUIView(CDefView * pDefView)
{
    // We have a zero-init constructor.  Be paranoid and check a couple:
    ASSERT(NULL ==_hWnd);
    ASSERT(NULL == _pshlItems);
    ASSERT(NULL == _ppbShellFolders);

    _cRef = 1;
    _pDefView = pDefView;
    _pDefView->AddRef();
}

HRESULT CDUIView::Initialize()
{
    // Initialize DirectUI process (InitProcess) and register classes
    _hrInit = InitializeDirectUI();
    if (FAILED(_hrInit))
        goto Failure;

    // Initialize DirectUI thread
    _hrInit = InitThread();
    if (FAILED(_hrInit))
        goto Failure;
        
    ManageAnimations(FALSE);

    _pDT = new CDUIDropTarget ();

Failure:

    return _hrInit;
}

CDUIView::~CDUIView()
{
    IUnknown_SetSite(_spThumbnailExtractor2, NULL);
    if (_hwndMsgThumbExtract)  // May have been (likely) created by CMiniPreviewer
    {
        DestroyWindow(_hwndMsgThumbExtract);
    }
    
    if (_hwndMsgInfoExtract)  // May have been (likely) created by CNameSpaceItemInfoList
    {
        DestroyWindow(_hwndMsgInfoExtract);
    }
    
    ATOMICRELEASE(_pshlItems);
    if (_bstrIntroText)
    {
        SysFreeString(_bstrIntroText);
    }

    if (_hinstTheme)
    {
        FreeLibrary(_hinstTheme);
        _hinstTheme = NULL;
        _fLoadedTheme = FALSE;
    }

    if (_hinstScrollbarTheme)
    {
        CloseThemeData(_hinstScrollbarTheme);
        _hinstScrollbarTheme = NULL;
    }

    UnInitializeDirectUI();

    if (_ppbShellFolders)
        _ppbShellFolders->Release();

    _pDefView->Release();
}


//
// This DUI uninitialization code was broken out from the destructor
// because we need to call it from defview in response to WM_NCDESTROY
// before the CDUIView object is destroyed.  This is required to properly
// initiate the shutdown of DUser on the thread.  Since we don't own the
// browser thread message pump we must ensure all DUser processing is
// complete before our defview instance goes away.
// Therefore, since it can be called twice, once from defview and once
// from CDUIView::~CDUIView, all processing must tolerate multiple calls
// for the same instance.
//
void CDUIView::UnInitializeDirectUI(void)
{
    ATOMICRELEASE(_pvSpecialTaskSheet);
    ATOMICRELEASE(_pvFolderTaskSheet);
    ATOMICRELEASE(_pvDetailsSheet);
    _ClearNonStdTaskSections();

    if (_pDT)
    {
        _pDT->Release();
        _pDT = NULL;
    }

    ManageAnimations(TRUE);

    if (SUCCEEDED(_hrInit))
    {
        UnInitThread();
        _hrInit = E_FAIL;  // UnInit thread only once.
    }
}


// Right now our themeing information is hard-coded due to limitations of DirectUI (only one resource)
// so we'll ask the namespace for a hardcoded name that we can look up in the below table.  Add new
// names/entries to this list as we add theme parts to our shellstyle.dll.
//

// These theme elements come from shellstyle.dll.
const WVTHEME c_wvTheme[] =
{
    { L"music",   IDB_MUSIC_ICON_BMP,    IDB_MUSIC_TASKS_BMP,    IDB_MUSIC_LISTVIEW_BMP },
    { L"picture", IDB_PICTURES_ICON_BMP, IDB_PICTURES_TASKS_BMP, IDB_PICTURES_LISTVIEW_BMP },
    { L"video",   IDB_VIDEO_ICON_BMP,    IDB_VIDEO_TASKS_BMP,    IDB_VIDEO_LISTVIEW_BMP },
    { L"search",  IDB_SEARCH_ICON_BMP,   IDB_SEARCH_TASKS_BMP,   IDB_SEARCH_LISTVIEW_BMP },
};

const WVTHEME* CDUIView::GetThemeInfo()
{
    for (UINT i = 0 ; i < ARRAYSIZE(c_wvTheme) ; i++)
    {
        if (0 == lstrcmp(_pDefView->_wvTheme.pszThemeID, c_wvTheme[i].pszThemeName))
            return &(c_wvTheme[i]);
    }

    return NULL;
}

//  Main intialization point for DUI view
//
//  bDisplayBarrier - Display soft barrier over top of listview

HRESULT CDUIView::Initialize(BOOL bDisplayBarrier, IUnknown * punkPreview)
{
    DisableAnimations();
    Element::StartDefer();

    // Create the host window for the DUI elements

    HRESULT hr = _CreateHostWindow();
    if (SUCCEEDED(hr))
    {
        // Dynamically build the .ui file for this view

        int iCharCount;
        char *pUIFile = NULL;
        hr = _BuildUIFile(&pUIFile, &iCharCount);
        if (SUCCEEDED(hr))
        {
            // Parse the .ui file and initialize the elements
            hr = _InitializeElements(pUIFile, iCharCount, bDisplayBarrier, punkPreview);
            if (SUCCEEDED(hr))
            {
                BuildDropTarget(_phe->GetDisplayNode(), _phe->GetHWND());

                // Set visible for host element
                _phe->SetVisible(true);
            }
            LocalFree(pUIFile);
        }
    }

    // Note:
    //  EndDefer() here so layout coordinates are calculated before executing
    //  the next snippit of code which depends on them being set properly.
    //  The one thing to be aware of in future is that if this isn't the
    //  outermost BeginDefer()/EndDefer() pair in the codepath, we're in
    //  trouble because then DUI won't calculate its layout coordinates.
    Element::EndDefer();

    if (SUCCEEDED(hr))
    {
        Value* pv;
        if (_peTaskPane->GetExtent(&pv))
        {
            const SIZE * pSize = pv->GetSize();

            _iOriginalTaskPaneWidth = pSize->cx;
            _iTaskPaneWidth = pSize->cx;

            pv->Release();

            // REVIEW: Why are we doing this based on a resource string, instead
            // of simply having the localizers localize the size in the theme???
            // It kind of sucks because we're forcing two layouts all the time.
            _iTaskPaneWidth = ScaleSizeBasedUponLocalization(_iOriginalTaskPaneWidth);

            if (_iTaskPaneWidth != _iOriginalTaskPaneWidth)
            {
                Element::StartDefer();

                // Increase the width of the scroller if the localizers have
                // bumped up the size defined in the resources
                _peTaskPane->SetWidth(_iTaskPaneWidth);

                Element::EndDefer();
            }
        }

        if (_fHideTasklist || (_phe->GetWidth() / 2) < _iTaskPaneWidth)
        {
            Element::StartDefer();

            _peTaskPane->SetWidth(0);

            Element::EndDefer();
        }
        _bInitialized = true;
    }
    else
    {
        if (_hWnd)
        {
            DestroyWindow (_hWnd);
            _hWnd = NULL;
        }
    }

    // Note:
    //  We don't re-enable animations until after we're completely finished
    //  with all our crazy resizing and stuff.  This prevents some nasty
    //  issues with DUI panes only partly painting (i.e. RAID 422057).
    EnableAnimations();

    return hr;
}

void CDUIView::DetachListview()
{
    if (_peListView)
        _peListView->DetachListview();

    if (_hWnd)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }
}

//  Creates the host window for the DUI elements to
//  be associated with.  This child window
//  will also be passed back to defview to be used
//  as the result pane host.

HRESULT CDUIView::_CreateHostWindow (void)
{
    WNDCLASS wc = {0};
    
    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = _DUIHostWndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    wc.lpszClassName  = DUI_HOST_WINDOW_CLASS_NAME;
    
    RegisterClass(&wc);
    
    // Query for the size of defview's client window so we can size this window
    // to match
    RECT rc;
    GetClientRect(_pDefView->_hwndView, &rc);
    
    _hWnd = CreateWindowEx(0, DUI_HOST_WINDOW_CLASS_NAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
        rc.left, rc.top, rc.right, rc.bottom,
        _pDefView->_hwndView, NULL, HINST_THISDLL, (void *)this);
    
    if (!_hWnd)
    {
        TraceMsg(TF_ERROR, "CDUIView::_CreateHostWindow: CreateWindowEx failed with %d", GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Temporary work-around for DUI mirroring bug 259158
    SHSetWindowBits(_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, 0);

    return S_OK;
}

void CDUIView::ManageAnimations(BOOL bExiting)
{
    if (bExiting)
    {
        if (_bAnimationsDisabled)
        {
            DirectUI::EnableAnimations();
            _bAnimationsDisabled = FALSE;
        }
    }
    else
    {
        BOOL bAnimate = TRUE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &bAnimate, 0);


        if (bAnimate)
        {
            if (_bAnimationsDisabled)
            {
                DirectUI::EnableAnimations();
                _bAnimationsDisabled = FALSE;
            }
        }
        else
        {
            if (!_bAnimationsDisabled)
            {
                DirectUI::DisableAnimations();
                _bAnimationsDisabled = TRUE;
            }
        }
    }
}

HINSTANCE CDUIView::_GetThemeHinst()
{
    if (!_fLoadedTheme)
    {
        _fLoadedTheme = TRUE;
        if (_hinstTheme)
        {
            FreeLibrary(_hinstTheme);
        }

        _hinstTheme = SHGetShellStyleHInstance();

        if (_hinstScrollbarTheme)
        {
            CloseThemeData (_hinstScrollbarTheme);
        }

        _hinstScrollbarTheme = OpenThemeData(_hWnd, L"Scrollbar");
    }

    return _hinstTheme ? _hinstTheme : HINST_THISDLL;
}

//  Loads the requested UI file from shell32's resources
//
//  iID         - UI file id
//  pUIFile     - receives a pointer to the UI file

HRESULT CDUIView::_LoadUIFileFromResources(HINSTANCE hinst, int iID, char **pUIFile)
{
    HRESULT hr;

    HRSRC hFile = FindResource(hinst, MAKEINTRESOURCE(iID), TEXT("UIFILE"));
    if (hFile)
    {
        HGLOBAL hFileHandle = LoadResource(hinst, hFile);
        if (hFileHandle)
        {
            char *pFile = (char *)LockResource(hFileHandle);
            if (pFile)
            {
                DWORD dwSize = SizeofResource(hinst, hFile);

                *pUIFile = (char *)LocalAlloc(LPTR, dwSize + 1);
                if (*pUIFile)
                {
                    CopyMemory(*pUIFile, pFile, dwSize);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

//  Builds the UI file for this view from the
//  appropriate base template + style sheet
//
//  pUIFile receives a pointer to the ui file in memory
//  piCharCount receives the size of the file

HRESULT CDUIView::_BuildUIFile(char **pUIFile, int *piCharCount)
{
    // Load the base UI file
    char * pBase;
    HRESULT hr = _LoadUIFileFromResources(HINST_THISDLL, IDR_DUI_FOLDER, &pBase);
    if (SUCCEEDED(hr))
    {
        // Load the style sheet.  First, check if the current theme has a style sheet,
        // if not, use the default style sheet in the resources.
        char *pStyle;
        hr = _LoadUIFileFromResources(_GetThemeHinst(), IDR_DUI_STYLESHEET, &pStyle);
        if (SUCCEEDED(hr))
        {
            char *pResult = (char *)LocalAlloc(LPTR, lstrlenA(pBase) + lstrlenA(pStyle) + 1);
            if (pResult)
            {
                // Put the files together
                lstrcpyA(pResult, pStyle);
                lstrcatA(pResult, pBase);

                // Store the final results
                *pUIFile = pResult;
                *piCharCount = lstrlenA(pResult);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            LocalFree(pStyle);
        }
        LocalFree(pBase);
    }
    return hr;
}

//  Callback function used by the ui file parser
//
//  pszError -  Error text
//  pszToken -  Token text
//  iLine    -  Line number

void CALLBACK UIFileParseError(LPCWSTR pszError, LPCWSTR pszToken, int iLine)
{
    TraceMsg (TF_ERROR, "UIFileParseError: %s '%s' at line %d", pszError, pszToken, iLine);
}

//  Builds a section which holds tasks
//
//  peSectionList  - parent of the section
//  bMain          - Main section or normal section
//  pTitleUI       - interface describing the title, may be NULL if pTitleDesc provided
//  pBitmapDesc    - Description of the bitmap
//  pWatermarkDesc - Description of the watermark
//  pvSectionSheet - Style sheet to be used
//  pParser        - Parser instance pointer
//  fExpanded      - Expanded or closed
//  ppeExpando     - [out,optional] Receives the section just created
//  pTaskList      - [out] Receives the task list area element pointer within the pExpando

HRESULT CDUIView::_BuildSection(Element* peSectionList, BOOL bMain, IUIElement* pTitleUI,
                                int idBitmapDesc, int idWatermarkDesc, Value* pvSectionSheet,
                                Parser* pParser, DUISEC eDUISecID, Expando** ppeExpando, Element ** pTaskList)
{
    Expando* peSection = NULL;
    Value* pv = NULL;
    Element* pe = NULL;
    HBITMAP hBitmap;


    // Create a section using the definition in the ui file

    HRESULT hr = pParser->CreateElement (bMain ? L"mainsection" : L"section", NULL, &pe);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateElement failed with 0x%x", hr);
        return hr;
    }

    ASSERTMSG(pe->GetClassInfo() == Expando::Class, "CDUIView::_BuildSection: didn't get an Expando::Class object (%s)", pe->GetClassInfo()->GetName());
    peSection = (Expando*)pe;

    pe->SetWidth(ScaleSizeBasedUponLocalization(pe->GetWidth()));

    peSection->Initialize(eDUISecID, pTitleUI, this, _pDefView);
    if (ppeExpando)
        *ppeExpando = peSection;

    // Add the section to the list

    peSectionList->Add (peSection);


    // Set the title

    peSection->UpdateTitleUI(NULL); // nothing is selected when the folder starts up


    // Set the bitmap on the left side

    if (idBitmapDesc)
    {
        pe = peSection->FindDescendent (Expando::idIcon);

        if (pe)
        {
            hBitmap = DUILoadBitmap(_GetThemeHinst(), idBitmapDesc, LR_CREATEDIBSECTION);
            if (hBitmap)
            {
                pv = Value::CreateGraphic(hBitmap, GRAPHIC_AlphaConstPerPix);

                if (pv)
                {
                    pe->SetValue (Element::ContentProp, PI_Local, pv);
                    pv->Release ();
                }
                else
                {
                    DeleteObject(hBitmap);

                    TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateGraphic for the bitmap failed.");
                }
            }
            else
            {
                TraceMsg (TF_ERROR, "CDUIView::_BuildSection: DUILoadBitmap failed.");
            }
        }
        else
        {
            TraceMsg (TF_ERROR, "CDUIView::_BuildSection: FindDescendent for the bitmap failed.");
        }
    }


    if (idWatermarkDesc)
    {
        HINSTANCE hinstTheme = _GetThemeHinst();
        pe = peSection->FindDescendent (Expando::idWatermark);
        if (pe)
        {
            // Note:  in Classic mode, we don't want the watermarks, so this function
            // will return NULL
            hBitmap = DUILoadBitmap(hinstTheme, idWatermarkDesc, LR_CREATEDIBSECTION);
            if (hBitmap)
            {
                pv = Value::CreateGraphic(hBitmap, GRAPHIC_NoBlend);
                if (pv)
                {
                    pe->SetValue (Element::ContentProp, PI_Local, pv);
                    pv->Release ();
                }
                else
                {
                    DeleteObject(hBitmap);

                    TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateGraphic for the watermark failed.");
                }
            }
        }
        else
        {
            TraceMsg (TF_ERROR, "CDUIView::_BuildSection: FindDescendent for the watermark failed.");
        }
    }


    // Set the style sheet if specified

    if (pvSectionSheet)
    {
        peSection->SetValue (Element::SheetProp, PI_Local, pvSectionSheet);
    }


    // Set the expanded state.  By default, it is expanded.

    if (!_ShowSectionExpanded(eDUISecID))
    {
        peSection->SetSelected(FALSE);
    }


    // Add padding for the icon if appropriate.  Note, this has to happen
    // after the style sheet is applied

    if (idBitmapDesc)
    {
        Element* pe = peSection->FindDescendent(StrToID(L"header"));

        if (pe)
        {
            Value* pvValue;
            const RECT * prect;

            prect = pe->GetPadding (&pvValue);

            if (prect)
            {
                pe->SetPadding ((prect->left + 20), prect->top, prect->right, prect->bottom);
                pvValue->Release();
            }
        }
    }


    // Return the task list element pointer

    *pTaskList = peSection->FindDescendent (Expando::idTaskList);

    if (*pTaskList)
    {
        hr = S_OK;
    }
    else
    {
        TraceMsg (TF_ERROR, "CDUIView::_BuildSection: Failed to find task list element");
        hr = E_FAIL;
    }


    return hr;
}

//  Adds the action tasks to the task list
//
//  peTaskList  - Parent element
//  penum       - enumeration interface
//  pvTaskSheet - Style sheet

HRESULT CDUIView::_AddActionTasks(Expando* peExpando, Element* peTaskList, IEnumUICommand* penum, Value* pvTaskSheet, BOOL bIntroAdded)
{
    IUICommand* puiCommand;
    BOOL fShow = bIntroAdded;

    while (S_OK==penum->Next(1, &puiCommand, NULL))
    {
        UISTATE uis;
        HRESULT hr = puiCommand->get_State(_pshlItems, FALSE, &uis);  // Don't do it if it's going to take long, instead, returns E_PENDING
        if (SUCCEEDED(hr) && (uis==UIS_ENABLED))
        {
            Element *pe;
            HRESULT hr = ActionTask::Create(0, puiCommand, _pshlItems, this, _pDefView, &pe);
            if (SUCCEEDED(hr))
            {
                if (pvTaskSheet)
                {
                    pe->SetValue(Element::SheetProp, PI_Local, pvTaskSheet);
                }

                peTaskList->Add(pe);
                fShow = TRUE;
            }
        }
        else if (hr == E_PENDING)
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(CGetCommandStateTask_Create(_pDefView, puiCommand, _pshlItems, &pTask)))
            {
                _pDefView->_AddTask(pTask, TOID_DVGetCommandState, 0, TASK_PRIORITY_GETSTATE, ADDTASK_ATEND);
                pTask->Release();
            }
        }

        puiCommand->Release();
    }
    penum->Reset();

    peExpando->ShowExpando(fShow);

    return S_OK;
}

//  Adds the destination tasks to the task list
//
//  peTaskList  - Parent element
//  penum       - enumerator of pidls to display
//  pvTaskSheet - Style sheet

HRESULT CDUIView::_AddDestinationTasks(Element* peTaskList, IEnumIDList* penum, Value* pvTaskSheet)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;

    while (S_OK==penum->Next(1, &pidl, NULL))
    {
        Element *pe;
        hr = DestinationTask::Create (0, pidl, this, _pDefView, &pe);
        if (SUCCEEDED(hr))
        {
            if (pvTaskSheet)
            {
                pe->SetValue(Element::SheetProp, PI_Local, pvTaskSheet);
            }

            peTaskList->Add(pe);
        }
        ILFree(pidl);
    }

    penum->Reset();

    return hr;
}

//
//  Purpose:    Adds the DetailsSectionInfo
//
HRESULT CDUIView::_AddDetailsSectionInfo()
{
IShellItemArray *psiShellItems = _pshlItems;

    if (!psiShellItems && _pDefView)
    {
        psiShellItems = _pDefView->_GetFolderAsShellItemArray();
    }
    
    //TODO: background thread!
    Element* pElement;
    HRESULT hr = CNameSpaceItemInfoList::Create(this, _pvDetailsSheet,psiShellItems, &pElement);
    if (pElement)
    {
        hr = _peDetailsInfoArea->Add(pElement);
    }
    return hr;
}

//  Navigates to the destination pidl
//
//  pidl - destination

HRESULT CDUIView::NavigateToDestination(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone)
    {
        UINT wFlags = (SBSP_DEFBROWSER | SBSP_ABSOLUTE);

        // mimic "new window" behavior
        if (0 > GetKeyState(VK_SHIFT))
        {
            wFlags |= SBSP_NEWBROWSER;
        }

        PostMessage(_hWnd, WM_NAVIGATETOPIDL, (WPARAM)wFlags, (LPARAM)pidlClone);
    }
    
    return S_OK;
}

//  Sends a delay navigation command to the view window. This delay allows 
//  double-clicks to be interpretted as a single click. This prevents
//  double navigations usually causing the user to end up with two "things"
//  instead of just one. 
//
//  Also by doing this, the issue of the 2nd click causing the old window to 
//  get activation is handled. The user is expecting the new window to pop 
//  up in front of the old window. But, because the user double-clicked,
//  the old window would get reactivated and the new window would end up 
//  behind the current window. See WM_USER_DELAY_NAVIGATION in HWNDView (below)
//  for more details.
//
//  psiItemArray - the shell item to navigate. Can be NULL.
//  puiCommand - the command object to send the navigation to.

HRESULT CDUIView::DelayedNavigation(IShellItemArray *psiItemArray, IUICommand *puiCommand)
{
    SendMessage(_phe->GetHWND(), WM_USER_DELAY_NAVIGATION, (WPARAM) psiItemArray, (LPARAM) puiCommand);
    return S_OK;
}


//  Builds the task list area
//
//  pParser - Parsing instance

HRESULT CDUIView::_BuildTaskList(Parser* pParser)
{
    HRESULT hr = S_OK;

    // Locate section list element

    Element* peSectionList = _phe->FindDescendent (StrToID(L"sectionlist"));

    if (!peSectionList)
    {
        TraceMsg (TF_ERROR, "CDUIView::_BuildTaskList: Failed to find section list element");
        return E_FAIL;
    }

    if (SFVMWVF_ENUMTASKS & _pDefView->_wvContent.dwFlags)
    {
        if (_bInitialized)
        {
            //
            // The 'non-standard' task list is the type who's contents
            // are dynamically enumerated by the folder view.
            // In the case of Control Panel, items in this content appear
            // conditionally based upon many factors, one being the categorization
            // of applets.  In order for the content to be correct, categorization
            // must be correct which means that all folder items are known.
            // To avoid multiple repaints of the task lists, we defer creation 
            // of the task lists until AFTER the initial creation of the view.  
            // Once all folder items have been enumerated, the webview content
            // is refreshed in response to a 'contents changed' notification from
            // defview.  It is during this update that we pass through this code
            // section and build the task list.
            // 
            _ClearNonStdTaskSections();
            hr = _GetNonStdTaskSectionsFromViewCB();
            if (SUCCEEDED(hr) && NULL != _hdsaNonStdTaskSections)
            {
                hr = _BuildNonStandardTaskList(pParser, peSectionList, _hdsaNonStdTaskSections);
            }
        }
    }
    else
    {
        hr = _BuildStandardTaskList(pParser, peSectionList);
    }
    return THR(hr);
}


//
// Builds the task list by requesting task section information
// from the view callback using an enumeration mechanism.
//
//
// ISSUE-2001/01/03-BrianAu  Review
//
//     Review this with MikeSh and EricFlo.  
//     I think we should build this generic mechanism then implement the
//     'standard' webview code in terms of this generic mechanism.  
//     Would be best to replace the SFVM_ENUMWEBVIEWTASKS callback message
//     with a message that receives a COM enumerator.
//
//     I like the idea.  We replace SFVMWVF_SPECIALTASK with an LPCSTR to the theme identifier.
//     We can put a SFVM_GETWEBVIEWTASKS to SFVM_ENUMWEBVIEWTASKS layer in for us too.
//
HRESULT CDUIView::_BuildNonStandardTaskList(Parser *pParser, Element *peSectionList, HDSA hdsaSections)
{
    Value* pvMainSectionSheet = NULL;
    Value *pvMainTaskSheet    = NULL;
    Value* pvStdSectionSheet  = NULL;
    Value* pvStdTaskSheet     = NULL;

    HRESULT hr = S_OK;

    ASSERT(NULL != hdsaSections);
    ASSERT(NULL != pParser);
    ASSERT(NULL != peSectionList);

    const int cSections = DSA_GetItemCount(hdsaSections);
    for (int i = 0; i < cSections; i++)
    {
        SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pSection = (SFVM_WEBVIEW_ENUMTASKSECTION_DATA *)DSA_GetItemPtr(hdsaSections, i);
        ASSERT(NULL != pSection);

        const BOOL bMainSection = (0 != (SFVMWVF_SPECIALTASK & pSection->dwFlags));

        Value *pvSectionSheet = NULL;
        Value *pvTaskSheet    = NULL;
        DUISEC eDUISecID;

        if (bMainSection)
        {
            if (NULL == pvMainSectionSheet)
            {
                pvMainSectionSheet = pParser->GetSheet(L"mainsectionss");
            }
            if (NULL == pvMainTaskSheet)
            {
                pvMainTaskSheet = pParser->GetSheet(L"mainsectiontaskss");
            }

            pvSectionSheet = pvMainSectionSheet;
            pvTaskSheet    = pvMainTaskSheet;
            eDUISecID      = DUISEC_SPECIALTASKS;
        }
        else
        {
            if (NULL == pvStdSectionSheet)
            {
                pvStdSectionSheet = pParser->GetSheet(L"sectionss");
            }
            if (NULL == pvStdTaskSheet)
            {
                pvStdTaskSheet = pParser->GetSheet(L"sectiontaskss");
            }

            pvSectionSheet = pvStdSectionSheet;
            pvTaskSheet    = pvStdTaskSheet;
            eDUISecID      = DUISEC_FILETASKS;
        }

        ASSERT(NULL != pvSectionSheet);
        Expando *peSection;
        Element *peTaskList;
        hr = _BuildSection(peSectionList, 
                           bMainSection,
                           pSection->pHeader,
                           pSection->idBitmap,
                           pSection->idWatermark,
                           pvSectionSheet,
                           pParser,
                           eDUISecID,
                           &peSection,
                           &peTaskList);
        if (SUCCEEDED(hr))
        {
            hr = _AddActionTasks(peSection, peTaskList, pSection->penumTasks, pvTaskSheet, FALSE);
        }
    }

    if (pvMainSectionSheet)
    {
        pvMainSectionSheet->Release();
    }
    if (pvMainTaskSheet)
    {
        pvMainTaskSheet->Release();
    }
    if (pvStdSectionSheet)
    {
        pvStdSectionSheet->Release();
    }
    if (pvStdTaskSheet)
    {
        pvStdTaskSheet->Release();
    }

    return THR(hr);
}


HRESULT CDUIView::_GetIntroTextElement(Element** ppeIntroText)
{
    if (SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER, TEXT("ShowWebViewIntroText"), FALSE, FALSE))
    {
        if (!_bstrIntroText)
        {
            WCHAR wszIntroText[INFOTIPSIZE];
            if (_bBarrierShown)
            {
                LoadString(HINST_THISDLL, IDS_INTRO_BARRICADED, wszIntroText, ARRAYSIZE(wszIntroText));
            }
            else if (!_pDefView->_pshf2Parent
                    || FAILED(GetStringProperty(_pDefView->_pshf2Parent, _pDefView->_pidlRelative,
                        &SCID_FolderIntroText, wszIntroText, ARRAYSIZE(wszIntroText))))
            {
                wszIntroText[0] = L'\0';
            }

            _bstrIntroText = SysAllocString(wszIntroText);
        }
    }
    
    HRESULT hr = E_FAIL;
    if (_bstrIntroText && _bstrIntroText[0])
    {
        hr = CNameSpaceItemInfo::Create(_bstrIntroText, ppeIntroText);
        if (SUCCEEDED(hr))
        {
            if (_pvDetailsSheet)
            {
                (*ppeIntroText)->SetValue(Element::SheetProp, PI_Local, _pvDetailsSheet);
            }
        }
    }
    return hr;
}

HRESULT CDUIView::_BuildStandardTaskList(Parser *pParser, Element *peSectionList)
{
    Element* peTaskList;
    Value* pvSectionSheet = NULL;
    Value* pvTaskSheet = NULL;
    Value* pvDetailsSheet = NULL;

    HRESULT hr = S_OK;

    Element* peIntroText;
    if (FAILED(_GetIntroTextElement(&peIntroText)))
    {
        peIntroText = NULL;
    }

    //
    // Special Tasks section is optional (main section)
    //
    if (_pDefView->_wvContent.pSpecialTaskHeader)
    {
        pvSectionSheet = pParser->GetSheet(L"mainsectionss");

        int idBitmap = 0;
        int idWatermark = 0;
        const WVTHEME* pThemeInfo = GetThemeInfo();
        if (pThemeInfo)
        {
            idBitmap = pThemeInfo->idSpecialSectionIcon;
            idWatermark = pThemeInfo->idSpecialSectionWatermark;
        }

        // TODO: get special section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            TRUE,
            _pDefView->_wvContent.pSpecialTaskHeader,
            idBitmap,
            idWatermark,
            pvSectionSheet,
            pParser,
            DUISEC_SPECIALTASKS,
            &_peSpecialSection,
            &peTaskList);


        if (SUCCEEDED(hr))
        {
            BOOL bIntroTextAdded = FALSE;

            _peSpecialTaskList = peTaskList;

            // Add the tasks + style sheet

            _pvSpecialTaskSheet = pParser->GetSheet(L"mainsectiontaskss");

            if (peIntroText)
            {
                if (SUCCEEDED(_peSpecialTaskList->Add(peIntroText)))
                {
                    bIntroTextAdded = TRUE;
                    peIntroText = NULL;
                }
            }
            
            _AddActionTasks(_peSpecialSection, _peSpecialTaskList, _pDefView->_wvTasks.penumSpecialTasks, _pvSpecialTaskSheet, bIntroTextAdded);
        }

        if (pvSectionSheet)
            pvSectionSheet->Release();
    }

    // Get the style sheets for remaining standard sections

    pvSectionSheet = pParser->GetSheet (L"sectionss");
    pvTaskSheet = pParser->GetSheet (L"sectiontaskss");

    // File tasks section (standard section) Not shown if the barricade is shown.

    if (!_bBarrierShown)
    {
        if (_pDefView->_wvContent.pFolderTaskHeader)
        {
            // TODO: get folder section open/closed state from the per-user-per-pidl property bag

            hr = _BuildSection(
                peSectionList,
                FALSE,
                _pDefView->_wvContent.pFolderTaskHeader,
                0,
                0,
                pvSectionSheet,
                pParser,
                DUISEC_FILETASKS,
                &_peFolderSection,
                &peTaskList);
            if (SUCCEEDED(hr))
            {
                BOOL bIntroTextAdded = FALSE;

                _peFolderTaskList = peTaskList;

                _pvFolderTaskSheet = pvTaskSheet;
                if (_pvFolderTaskSheet)
                    _pvFolderTaskSheet->AddRef();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peFolderTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                
                _AddActionTasks(_peFolderSection, _peFolderTaskList, _pDefView->_wvTasks.penumFolderTasks, _pvFolderTaskSheet, bIntroTextAdded);
            }
        }
    }

    // Other places tasks section (standard section)

    if (_pDefView->_pOtherPlacesHeader)
    {
        // TODO: get OtherPlaces section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            FALSE,
            _pDefView->_pOtherPlacesHeader,
            0,
            0,
            pvSectionSheet,
            pParser,
            DUISEC_OTHERPLACESTASKS,
            NULL,
            &peTaskList);
        if (SUCCEEDED(hr))
        {
            _AddDestinationTasks(peTaskList, _pDefView->_wvContent.penumOtherPlaces, pvTaskSheet);
        }
    }


    // Details tasks section (standard section)

    if (_pDefView->_pDetailsHeader)
    {
        // TODO: get Details section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            FALSE,
            _pDefView->_pDetailsHeader,
            0,
            0,
            pvSectionSheet,
            pParser,
            DUISEC_DETAILSTASKS,
            &_peDetailsSection,
            &_peDetailsInfoArea);
        if (SUCCEEDED(hr))
        {
            _AddDetailsSectionInfo();
            
        }
    }

    if (peIntroText)
    {
        peIntroText->Destroy();
    }
    
    if (pvTaskSheet)
    {
        pvTaskSheet->Release();
    }

    if (pvSectionSheet)
    {
        pvSectionSheet->Release();
    }

    return hr;
}

BOOL CDUIView::_ShowSectionExpanded(DUISEC eDUISecID)
{
    const struct DUISEC_ATTRIBUTES *pAttrib = _GetSectionAttributes(eDUISecID);
    BOOL bDefault;
    BOOL bShow;

    if (eDUISecID == DUISEC_DETAILSTASKS)
        bDefault = ((_pDefView->_wvLayout.dwLayout & SFVMWVL_ORDINAL_MASK) == SFVMWVL_DETAILS);
    else
        bDefault = pAttrib->_bExpandedDefault;

    if (_ppbShellFolders)
        bShow = SHPropertyBag_ReadBOOLDefRet(_ppbShellFolders, pAttrib->_pszExpandedPropName, bDefault);
    else
        bShow = bDefault;

    return bShow;
}

const struct DUISEC_ATTRIBUTES *CDUIView::_GetSectionAttributes(DUISEC eDUISecID)
{
    static const size_t nSections = ARRAYSIZE(c_DUISectionAttributes);
    size_t iSection;

    // Determine attributes of DUISEC we're interested in.
    for (iSection = 0; iSection < nSections; iSection++)
        if (c_DUISectionAttributes[iSection]._eDUISecID == eDUISecID)
            return &c_DUISectionAttributes[iSection];

    ASSERT(FALSE);  // Game over -- insert quarters!
    return NULL;    // AV!
}

HRESULT SetDescendentString(Element* pe, LPWSTR pszID, UINT idString)
{
    HRESULT hr;
    
    Element* peChild = pe->FindDescendent(StrToID(pszID));
    if (peChild)
    {
        TCHAR szString [INFOTIPSIZE];
        LoadString(HINST_THISDLL, idString, szString, ARRAYSIZE(szString));

        hr = peChild->SetContentString(szString);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//  Parses the .ui file and initializes the DUI elements
//
//  pUIFile         - Pointer to the UI file in memory
//  iCharCount      - Number of characters in the ui file
//  bDisplayBarrier - Display soft barrier over listview
//  punkPreview     - IUnknown interface for the preview control

HRESULT CDUIView::_InitializeElements (char * pUIFile, int iCharCount,
                                       BOOL bDisplayBarrier, IUnknown * punkPreview)
{
    Parser* pParser;
    Element* pe;
    RECT rc;
    HANDLE arH[2];

    // Parse the UI file

    arH[0] = _GetThemeHinst();
    arH[1] = _hinstScrollbarTheme;

    HRESULT hr = Parser::Create(pUIFile, iCharCount, arH, UIFileParseError, &pParser);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: Parser::Create failed with 0x%x", hr);
        return hr;
    }

    if (pParser->WasParseError())
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: WasParseError is TRUE");
        pParser->Destroy();
        return E_FAIL;
    }

    // Create the host element
    hr = HWNDView::Create(_hWnd, false, 0, this, _pDefView, (Element**)&_phe); // _phe is owned by _hWnd
    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: HWNDElement::Create failed with 0x%x", hr);
        pParser->Destroy();
        return hr;
    }

    // We need to ensure that the root item will not paint on WM_ERASEBCKGRND, so here we remove the default brush
    // - Turn off the (default) background fill
    HGADGET hgadRoot = _phe->GetDisplayNode();
    ASSERTMSG(hgadRoot != NULL, "Must have a peer Gadget");
    SetGadgetFillI(hgadRoot, NULL, BLEND_OPAQUE, 0, 0);

    // We need to ensure that the root item will not paint on WM_ERASEBCKGRND, so make it transparent
    _phe->SetBackgroundColor(ARGB(0, 0, 0, 0));

    // Size the host element to match the size of the host window

    GetClientRect (_hWnd, &rc);
    _phe->SetWidth(rc.right - rc.left);
    _phe->SetHeight(rc.bottom - rc.top);

    // Create the main element in the ui file

    hr = pParser->CreateElement(L"main", _phe, &pe);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: pParser->CreateElement failed with 0x%x", hr);
        pParser->Destroy();
        return hr;
    }

    // Cache the element pointers to the 3 main areas: taskpane, clientviewhost, blockade
    _peTaskPane = _phe->FindDescendent(StrToID(L"scroller"));
    _peClientViewHost = _phe->FindDescendent(StrToID(L"clientviewhost"));
    _peBarrier = _phe->FindDescendent(StrToID(L"blockade"));

    // Cache style sheets for the items we create directly (that don't inherit from their immediate parents)
    _pvDetailsSheet = pParser->GetSheet(L"NameSpaceItemInfoList");
        
    if (_peTaskPane && _peClientViewHost && _peBarrier && _pvDetailsSheet)
    {
        // Double buffered items need to be opaque
        _peTaskPane->SetBackgroundColor(ARGB(255, 0, 0, 0));
        _peTaskPane->DoubleBuffered(true);

        // Create the real listview element
        hr = DUIListView::Create(AE_MouseAndKeyboard, _pDefView->_hwndListview, (Element **)&_peListView);
        if (SUCCEEDED(hr))
        {
            _peListView->SetLayoutPos(BLP_Client);
            _peListView->SetID(L"listview");

            hr = _peClientViewHost->Add(_peListView);
            if (SUCCEEDED(hr))
            {
                _pDefView->_AutoAutoArrange(0);
            }
            else
            {
                TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: DUIListView::Could not add listview with 0x%x", hr);

                _peListView->Destroy();
                _peListView = NULL;
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: Could not create listview element");
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: Could not find main element");

        hr = E_FAIL;
    }
    
    if (FAILED(hr))
    {
        // we gotta have the listview or you get no webview...
        pParser->Destroy();
        return hr;
    }

    // Build the preview control if appropriate
    _ManagePreview(punkPreview);

    _BuildSoftBarrier();

    _SwitchToBarrier(bDisplayBarrier);

    // Create an interface to the property bag for this class of IShellFolder.

    _InitializeShellFolderPropertyBag();

    // Build the task list area

    hr = _BuildTaskList (pParser);

    _fHideTasklist = (S_OK == IUnknown_Exec(_pDefView->_psb, &CGID_ShellDocView, SHDVID_ISEXPLORERBARVISIBLE, 0, NULL, NULL));

    pParser->Destroy();

    return hr;
}

void CDUIView::_InitializeShellFolderPropertyBag()
{
    CLSID clsid;
    if (SUCCEEDED(IUnknown_GetClassID(_pDefView->_pshf, &clsid)))
    {
        WCHAR szSubKey[] = L"DUIBags\\ShellFolders\\{00000000-0000-0000-0000-000000000000}";
        if (SHStringFromGUID(clsid, &szSubKey[lstrlen(szSubKey) + 1 - GUIDSTR_MAX], GUIDSTR_MAX) == GUIDSTR_MAX)
        {
            HKEY hk = SHGetShellKey(SKPATH_SHELLNOROAM, szSubKey, TRUE);
            if (hk)
            {
                SHCreatePropertyBagOnRegKey(hk, NULL, STGM_READWRITE | STGM_SHARE_DENY_NONE, IID_PPV_ARG(IPropertyBag, &_ppbShellFolders));
                RegCloseKey(hk);
            }
        }
    }
}

HRESULT CDUIView::_BuildSoftBarrier(void)
{
    HRESULT hr = S_OK;
    
    // Build the soft barrier if the view wants one
    if (_pDefView->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        // Allow the view to give us a barrier implementation
        Element* peBarricade = NULL;
        _pDefView->CallCB(SFVM_GETWEBVIEWBARRICADE, 0, (LPARAM)&peBarricade);
        if (peBarricade)
        {
            Element *pe = _peBarrier->GetParent();
            hr = pe->Add(peBarricade);
            if (SUCCEEDED(hr))
            {
                _peBarrier->Destroy();
                _peBarrier = peBarricade;
            }
            else
            {
                peBarricade->Destroy();
            }
        }
        else
        {
            // Load the bitmap
            Element *peClient = _peBarrier->FindDescendent(StrToID(L"blockadeclient"));
            if (peClient)
            {
                HBITMAP hBitmap = DUILoadBitmap(_GetThemeHinst(), IDB_BLOCKADE_WATERMARK, LR_CREATEDIBSECTION);

                if (hBitmap)
                {
                    BITMAP bmp;

                    if (GetObject (hBitmap, sizeof(bmp), &bmp))
                    {
                        BYTE dBlendMode = GRAPHIC_TransColor;

                        if (bmp.bmBitsPixel == 32)
                        {
                            dBlendMode = GRAPHIC_AlphaConstPerPix;
                        }

                        Value *pVal = Value::CreateGraphic(hBitmap, dBlendMode, 255);

                        if (pVal)
                        {
                            peClient->SetValue(Element::ContentProp, PI_Local, pVal);
                            pVal->Release();
                        }
                    }
                }
            }

            // Give the view the standard barrier
            hr = SetDescendentString(_peBarrier, L"blockadetitle", IDS_BLOCKADETITLE);
            if (SUCCEEDED(hr))
            {
                hr = SetDescendentString(_peBarrier, L"blockademessage", IDS_BLOCKADEMESSAGE);

                // "clear barrier" button (failure of "clear barrier" button setup is not fatal)
                Element *peButton = _peBarrier->FindDescendent(StrToID(L"blockadeclearbutton"));
                if (peButton)
                {
                    Element *peButtonText = peButton->FindDescendent(StrToID(L"blockadecleartext"));
                    if (peButtonText)
                    {
                        WCHAR wsz[INFOTIPSIZE];
                        if (LoadString(HINST_THISDLL, IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER, wsz, ARRAYSIZE(wsz)))
                        {
                            Value *pv = Value::CreateString(wsz, NULL);
                            if (pv)
                            {
                                if (SUCCEEDED(peButtonText->SetValue(Element::ContentProp, PI_Local, pv)))
                                {

                                    peButton->SetAccessible(true);
                                    peButton->SetAccName(wsz);
                                    peButton->SetAccRole(ROLE_SYSTEM_PUSHBUTTON);
                                    if (LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, wsz, ARRAYSIZE(wsz)))
                                    {
                                        peButton->SetAccDefAction(wsz);
                                    }
                                }
                                pv->Release();
                            }
                        }
                    }
                }
            }
        }
        // Double buffered items need to be opaque
        _phe->SetBackgroundColor(ARGB(255, 0, 0, 0));
        _phe->DoubleBuffered(true);

        // We couldn't create the barrier? don't use it then...
        if (FAILED(hr))
        {
            _peBarrier->Destroy();
            _peBarrier = NULL;
        }
    }
    return hr;
}


//  Switches to / from the soft barrier and the listview

HRESULT CDUIView::_SwitchToBarrier (BOOL bDisplayBarrier)
{
    if (bDisplayBarrier && !_peBarrier)
        bDisplayBarrier = FALSE;

    Element *peClearButton = _peBarrier ? _peBarrier->FindDescendent(StrToID(L"blockadeclearbutton")) : NULL;
    if (peClearButton)
    {
        // Note:
        //  This is required to prevent the "clear barrier" button from being
        //  accessed via our accessibility interface when the barrier is hidden.
        peClearButton->SetAccessible(bDisplayBarrier == TRUE);
    }

    if (bDisplayBarrier)
    {
        _peClientViewHost->SetVisible(FALSE);
        _peBarrier->SetVisible(TRUE);
    }
    else
    {
        if (_peBarrier)
        {
            _peBarrier->SetVisible(FALSE);
        }

        _peClientViewHost->SetVisible(TRUE);
        _pDefView->_AutoAutoArrange(0);
    }

    _bBarrierShown = bDisplayBarrier;

    return S_OK;
}

//  Controls the display of the soft barrier

HRESULT CDUIView::EnableBarrier (BOOL bDisplayBarrier)
{
    if (_bBarrierShown != bDisplayBarrier)
    {
        DisableAnimations();
        Element::StartDefer ();

        _SwitchToBarrier (bDisplayBarrier);
        PostMessage (_hWnd, WM_REFRESHVIEW, 0, 0);

        Element::EndDefer ();
        EnableAnimations();
    }

    return S_OK;
}

//  Creates / destroys the preview control

HRESULT CDUIView::_ManagePreview (IUnknown * punkPreview)
{
    HRESULT hr = S_OK;

    if ((_pePreview && punkPreview) ||
        (!_pePreview && !punkPreview))
    {
        return S_OK;
    }

    if (punkPreview)
    {
        // Create the DUI element that can host an active x control

        hr = DUIAxHost::Create (&_pePreview);
        if (SUCCEEDED(hr))
        {
            _pePreview->SetLayoutPos (BLP_Top);
            _pePreview->SetID (L"preview");
            _pePreview->SetHeight(_phe->GetHeight());
            _pePreview->SetAccessible(TRUE);

            // The order of the next 4 calls is very important!
            //
            // Initialize atl so the window class is registered.
            // Then call the Add method.  This will cause CreateHWND to be
            // called.  Then site it so when we call AttachControl to 
            // put the preview control in (this requires the hwnd to exist already)
            // it will be parented properly

            AtlAxWinInit();

            hr = _peClientViewHost->Add (_pePreview);

            if (SUCCEEDED(hr))
            {
                _pePreview->SetSite(SAFECAST(_pDefView, IShellView2*));

                hr = _pePreview->AttachControl(punkPreview);

                if (SUCCEEDED(hr))
                {
                    // Double buffered items need to be opaque
                    _phe->SetBackgroundColor(ARGB(255, 0, 0, 0));
                    _phe->DoubleBuffered(true);

                    if (_peListView)
                    {
                        // Since the preview control is displayed, the listview
                        // will be sized to 1 row in height.  Determine the height
                        // of the listview now so we can size the preview control
                        // appropriate plus take care of the sizing in the SetSize
                        // method later
                        
                        DWORD dwItemSpace = ListView_GetItemSpacing (_peListView->GetHWND(), FALSE);
                        _iListViewHeight = (int)HIWORD(dwItemSpace) + GetSystemMetrics (SM_CYHSCROLL) + 4;

                        if (_phe->GetHeight() > _iListViewHeight)
                        {
                            _pePreview->SetHeight(_phe->GetHeight() - _iListViewHeight);
                        }
                        else
                        {
                            _pePreview->SetHeight(0);
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                _pePreview->Destroy();
                _pePreview = NULL;
            }
        }
        else
        {
            TraceMsg (TF_ERROR, "CDUIView::_ManagePreview: DUIAxHost::Create failed with 0x%x", hr);
        }
    }
    else
    {
        _pePreview->Destroy();
        _pePreview = NULL;
    }

    return S_OK;
}

//  Controls the display of the preview control

HRESULT CDUIView::EnablePreview(IUnknown * punkPreview)
{
    DisableAnimations();
    Element::StartDefer ();

    _ManagePreview (punkPreview);

    Element::EndDefer ();
    EnableAnimations();

    return S_OK;
}

//  Refreshes the view

HRESULT CDUIView::Refresh(void)
{
    Element *pe;
    Parser* pParser = NULL;
    Value* pvSheet = NULL;
    HANDLE arH[2];

    ManageAnimations(FALSE);
    DisableAnimations();
    Element::StartDefer();

    _fLoadedTheme = FALSE; // try to re-load the theme file

    _iTaskPaneWidth = ScaleSizeBasedUponLocalization(_iOriginalTaskPaneWidth);

    // Setting the task pane visibility to the current state will
    // cause it to re-initialize the task pane width appropriately
    SetTaskPaneVisibility(!_bHideTaskPaneAlways);

    // Dynamically build the .ui file for this view

    int iCharCount;
    char *pUIFile = NULL;
    HRESULT hr = _BuildUIFile(&pUIFile, &iCharCount);
    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: _BuildUIFile failed with 0x%x", hr);
        goto Exit;
    }


    // Parse the UI file

    arH[0] = _GetThemeHinst();
    arH[1] = _hinstScrollbarTheme;

    hr = Parser::Create(pUIFile, iCharCount, arH, UIFileParseError, &pParser);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: Parser::Create failed with 0x%x", hr);
        goto Exit;
    }

    if (pParser->WasParseError())
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: WasParseError is TRUE");
        hr = E_FAIL;
        goto Exit;
    }

    // Find the section list element

    pe = _phe->FindDescendent (StrToID(L"sectionlist"));

    if (!pe)
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: Failed to find section list element");
        hr = E_FAIL;
        goto Exit;
    }

    // Free all the pointers we have to elements inside of the sectionlist

    ATOMICRELEASE(_pshlItems);
    ATOMICRELEASE(_pvSpecialTaskSheet);
    ATOMICRELEASE(_pvFolderTaskSheet);
    ATOMICRELEASE(_peDetailsInfoArea);
    ATOMICRELEASE(_pvDetailsSheet);

    _peSpecialSection = NULL;
    _peSpecialTaskList = NULL;
    _peFolderSection = NULL;
    _peFolderTaskList = NULL;
    _peDetailsSection = NULL;

    // Destroy the section list

    pe->DestroyAll();

    // Take the style sheets from the new .UI file and put them on the running objects...
    //
    pe = _phe->FindDescendent (StrToID(L"main"));
    if (pe)
    {
        // Query for the main style sheet and set it
        pvSheet = pParser->GetSheet (L"main");
        if (pvSheet)
        {
            pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
            pvSheet->Release();
            pvSheet = NULL;
        }
    }

    pe = _phe->FindDescendent (StrToID(L"scroller"));
    if (pe)
    {
        // Query for the taskpane style sheet and set it
        pvSheet = pParser->GetSheet (L"taskpane");
        if (pvSheet)
        {
            pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
            pvSheet->Release();
            pvSheet = NULL;
        }
    }

    _pvDetailsSheet = pParser->GetSheet(L"NameSpaceItemInfoList");

    // Rebuild the soft barrier if one exists.
    
    _BuildSoftBarrier();
    
    // Build the task list area again

    _BuildTaskList (pParser);

Exit:

    Element::EndDefer();
    EnableAnimations();

    // When turning off the barricade the icons in listview
    // are arranged as if duiview isn't present.  Call _AutoAutoArrange
    // to reposition the icons correctly.

    _pDefView->_AutoAutoArrange(0);

    if (pParser)
    {
        pParser->Destroy();
    }
   
    if (pUIFile)
    {
        LocalFree(pUIFile);
    }

    return hr;
}

//  Resizes the host element when the frame size changes
//
//  rc - size of frame
//

HRESULT CDUIView::SetSize(RECT * rc)
{
    _fHideTasklist = (S_OK == IUnknown_Exec(_pDefView->_psb, &CGID_ShellDocView, SHDVID_ISEXPLORERBARVISIBLE, 0, NULL, NULL));

    SetWindowPos(_hWnd, NULL, rc->left, rc->top,
        rc->right - rc->left, rc->bottom - rc->top, SWP_NOZORDER | SWP_NOACTIVATE);

    return S_OK;
}


HRESULT CDUIView::_OnResize(long lWidth, long lHeight)
{
    DisableAnimations();
    Element::StartDefer();

    _phe->SetWidth(lWidth);
    _phe->SetHeight(lHeight);

    if (_pePreview)
    {
        if (_phe->GetHeight() > _iListViewHeight)
        {
            _pePreview->SetHeight(_phe->GetHeight() - _iListViewHeight);
        }
        else
        {
            _pePreview->SetHeight(0);
        }
    }

    // Hide task pane if task area is greater than 50% of the window size

    // The show/hide state of the tasklist pane can change for:
    //   1) we're told to always hide
    //   2) an explorer bar is showing
    //   3) the window is too narrow.
    //
    if (_peTaskPane)
    {
        if (_bHideTaskPaneAlways || _fHideTasklist || ((lWidth / 2) < _iTaskPaneWidth))
        {
            _peTaskPane->SetWidth(0);
        }
        else if (_peTaskPane->GetWidth() == 0)
        {
            _peTaskPane->SetWidth(_iTaskPaneWidth);
        }
    }

    Element::EndDefer();
    EnableAnimations();

    return S_OK;
}

HRESULT CDUIView::SetTaskPaneVisibility(BOOL bShow)
{
    _bHideTaskPaneAlways = !bShow;
    return _OnResize(_phe->GetWidth(), _phe->GetHeight());
}

// Description:
//  Calculates the bounding rectangle of the infotip hotspot for
//  the specified element.  The bounding rectangle's coordinates
//  are relative to the specified element's root element.
//
void CDUIView::CalculateInfotipRect(Element *pe, RECT *pRect)
{
    ASSERT(pe);
    ASSERT(pRect);

    // Calculate location.
    const POINT ptLocation = { 0, 0 };
    POINT ptLocationRelativeToRoot;
    pe->GetRoot()->MapElementPoint(pe, &ptLocation, &ptLocationRelativeToRoot);
    pRect->left = ptLocationRelativeToRoot.x;
    pRect->top = ptLocationRelativeToRoot.y;

    // Calculate size.
    Value *pvExtent;
    const SIZE *psizeExtent = pe->GetExtent(&pvExtent);
    pRect->right = pRect->left + psizeExtent->cx;
    pRect->bottom = pRect->top + psizeExtent->cy;
    pvExtent->Release();

    // Sanity check.
    ASSERT(pRect->right  > pRect->left);
    ASSERT(pRect->bottom > pRect->top);
}

HRESULT CDUIView::InitializeThumbnail(WNDPROC pfnWndProc)
{
    HRESULT hr = E_FAIL;
    if (!_spThumbnailExtractor2)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IThumbnail2, &_spThumbnailExtractor2))))
        {
            _hwndMsgThumbExtract = SHCreateWorkerWindowW(pfnWndProc, NULL, 0, WS_POPUP, NULL, this);
            if (_hwndMsgThumbExtract)
            {
                // Set defview as the site for the thumbnail extractor so that
                // it can QueryService defview for IShellTaskScheduler
                IUnknown_SetSite(_spThumbnailExtractor2, SAFECAST(_pDefView, IShellView2*));
                
                // Tell the image extractor to post WM_HTML_BITMAP to _hwndMsgThumbExtract
                // The lParam will be the HBITMAP of the extracted image.
                _spThumbnailExtractor2->Init(_hwndMsgThumbExtract, WM_HTML_BITMAP);
            }
        }
    }
    return (_spThumbnailExtractor2 && _hwndMsgThumbExtract) ? S_OK : E_FAIL;
}

// if pCheck != NULL, check if the current window ptr == pCheck before setting it to p
HRESULT CDUIView::SetThumbnailMsgWindowPtr(void* p, void* pCheck)
{
    if (_hwndMsgThumbExtract)
    {
        if (pCheck)
        {
            void* pCurrent = GetWindowPtr(_hwndMsgThumbExtract, 0);
            if (pCurrent == pCheck)
            {
                SetWindowPtr(_hwndMsgThumbExtract, 0, p);
            }
        }
        else
        {
            SetWindowPtr(_hwndMsgThumbExtract, 0, p);
        }
    }
    return S_OK;
}

HRESULT CDUIView::StartBitmapExtraction(LPCITEMIDLIST pidl)
{
    _dwThumbnailID++;   // We are looking for a new thumbnail

    return _spThumbnailExtractor2 ? _spThumbnailExtractor2->GetBitmapFromIDList(pidl,
            _dwThumbnailID, 150, 100) : E_FAIL;
}

HRESULT CDUIView::InitializeDetailsInfo(WNDPROC pfnWndProc)
{
    if (!_hwndMsgInfoExtract)
    {
        _hwndMsgInfoExtract = SHCreateWorkerWindowW(pfnWndProc, NULL, 0, WS_POPUP, NULL, this);
    }
    return _hwndMsgInfoExtract ? S_OK : E_FAIL;
}

// if pCheck != NULL, check if the current window ptr == pCheck before setting it to p
HRESULT CDUIView::SetDetailsInfoMsgWindowPtr(void* p, void* pCheck)
{
    if (_hwndMsgInfoExtract)
    {
        if (pCheck)
        {
            void* pCurrent = GetWindowPtr(_hwndMsgInfoExtract, 0);
            if (pCurrent == pCheck)
            {
                SetWindowPtr(_hwndMsgInfoExtract, 0, p);
            }
        }
        else
        {
            SetWindowPtr(_hwndMsgInfoExtract, 0, p);
        }
    }
    return S_OK;
}

HRESULT CDUIView::StartInfoExtraction(LPCITEMIDLIST pidl)
{
    _dwDetailsInfoID++;   // We are looking for a new Details section info
    CDetailsSectionInfoTask *pTask;
    HRESULT hr = CDetailsSectionInfoTask_CreateInstance(
        _pDefView->_pshf, pidl, _hwndMsgInfoExtract, WM_DETAILS_INFO, _dwDetailsInfoID, &pTask);
    if (SUCCEEDED(hr))
    {
        if (_pDefView->_pScheduler)
        {
            // Make sure there are no other background DetailsSectionInfo
            // extraction going on...
            _pDefView->_pScheduler->RemoveTasks(TOID_DVBackgroundDetailsSectionInfo,
                    ITSAT_DEFAULT_LPARAM, FALSE);
        }

        hr = _pDefView->_AddTask(pTask, TOID_DVBackgroundDetailsSectionInfo,
                0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
        pTask->Release();
    }
    return hr;
}

VOID CDUIView::ShowDetails (BOOL fShow)
{
    if (_peDetailsSection)
    {
        _peDetailsSection->ShowExpando (fShow);
    }
}

BOOL CDUIView::ShouldShowMiniPreview()
{
    return !_pDefView->_IsImageMode();
}

//  Window procedure for host window

LRESULT CALLBACK CDUIView::_DUIHostWndProc(HWND hWnd, UINT uMessage, WPARAM wParam,
                                          LPARAM lParam)
{
    CDUIView  *pThis = (CDUIView*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMessage)
    {
        case WM_NCCREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
                pThis = (CDUIView*)(lpcs->lpCreateParams);
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            }
            break;

        case WM_SIZE:
            if (pThis && pThis->_phe)
            {
                pThis->_OnResize(LOWORD(lParam), HIWORD(lParam));
            }
            break;

        case WM_SETFOCUS:
            // Push focus to HWNDElement (won't set gadget focus to the HWNDElement, but
            // will push focus to the previous gadget with focus)

            if (pThis)
            {

                if (pThis->_phe && pThis->_phe->GetHWND())
                    SetFocus(pThis->_phe->GetHWND());
            }
            break;

        case WM_PALETTECHANGED:
        case WM_QUERYNEWPALETTE:
        case WM_DISPLAYCHANGE:
            if (pThis && pThis->_phe)
            {
                return SendMessageW(pThis->_phe->GetHWND(), uMessage, wParam, lParam);
            }
            break;

        case WM_DESTROY:
            // clear posted messages
            MSG msg;

            while (PeekMessage(&msg, hWnd, WM_NAVIGATETOPIDL, WM_NAVIGATETOPIDL, PM_REMOVE))
            {
                // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
                // Verify that the message was really for us.

                if (msg.hwnd == hWnd)
                {
                    LPITEMIDLIST pidl = (LPITEMIDLIST)msg.lParam;
                    ILFree(pidl);
                }
            }
            break;


        case WM_NAVIGATETOPIDL:
            {
                LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
                UINT wFlags = (UINT)wParam;

                pThis->_pDefView->_psb->BrowseObject(pidl, wFlags);

                ILFree(pidl);
            }
            break;

        case WM_REFRESHVIEW:
            {
                pThis->Refresh();       
            }
            break;

        case WM_MOUSEACTIVATE:
            if (pThis->_bBarrierShown)
            {
                return MA_ACTIVATE;
            }
            break;

        default:
            break;
    }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

//  Updates all selection-parameterized UI
//
//  pdo - data object representing the selection

void CDUIView::_Refresh(IShellItemArray *psiItemArray, DWORD dwRefreshFlags)
{
    //DirectUI::DisableAnimations();
    Element::StartDefer();

    IUnknown_Set((IUnknown **)&_pshlItems,psiItemArray);

    if (SFVMWVF_ENUMTASKS & _pDefView->_wvContent.dwFlags)
    {
        if (0 == (REFRESH_SELCHG & dwRefreshFlags))
        {
            //
            // Only refresh if it's not a selection change.
            // If we refresh here, Control Panel's left-pane menus
            // are constantly rebuilt as the folder items selection
            // changes.  That's really ugly.
            // Will this affect other folders?  No, Control Panel
            // is currently the only folder that sets this SFVMWVF_ENUMTASKS
            // flag.  Post WinXP if we decide to keep this webview
            // content in the left pane, we need to re-think how better
            // to handle Control Panel's special needs.
            //
            Refresh();
        }
    }
    else
    {
        if (REFRESH_CONTENT & dwRefreshFlags)
        {
            _BuildSoftBarrier();
        }

        if (REFRESH_TASKS & dwRefreshFlags)
        {
            Element* peIntroText;
            if (FAILED(_GetIntroTextElement(&peIntroText)))
            {
                peIntroText = NULL;
            }
            
            if (_peSpecialSection)
            {
                BOOL bIntroTextAdded = FALSE;

                _peSpecialSection->UpdateTitleUI(_pshlItems);
                _peSpecialTaskList->DestroyAll();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peSpecialTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                
                _AddActionTasks(_peSpecialSection, _peSpecialTaskList, _pDefView->_wvTasks.penumSpecialTasks, _pvSpecialTaskSheet, bIntroTextAdded);
            }

            if (_peFolderSection)
            {
                BOOL bIntroTextAdded = FALSE;

                _peFolderSection->UpdateTitleUI(_pshlItems);
                _peFolderTaskList->DestroyAll();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peFolderTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                        
                _AddActionTasks(_peFolderSection, _peFolderTaskList, _pDefView->_wvTasks.penumFolderTasks, _pvFolderTaskSheet, bIntroTextAdded);
            }

    if (_peDetailsInfoArea)
    {
        const SIZE *pSize;
        LONG lHeight = 0;
        Value * pv;

        pSize = _peDetailsInfoArea->GetExtent(&pv);

        if (pSize)
        {
            _peDetailsInfoArea->SetHeight(pSize->cy);
            pv->Release();
        }

        _peDetailsInfoArea->DestroyAll();

                _AddDetailsSectionInfo();
            }
        
            if (peIntroText)
            {
                peIntroText->Destroy();
            }
        }
    }
    
    Element::EndDefer();
    //DirectUI::EnableAnimations();
}

void CDUIView::OnSelectionChange(IShellItemArray *psiItemArray)
{
    _Refresh(psiItemArray, REFRESH_ALL | REFRESH_SELCHG);
}


void CDUIView::OnContentsChange(IShellItemArray *psiItemArray)
{
    DWORD dwRefreshFlags = 0;
    if (_pDefView->_wvTasks.dwUpdateFlags & SFVMWVTSDF_CONTENTSCHANGE)
    {
        dwRefreshFlags |= REFRESH_TASKS;
    }
    if (_pDefView->_wvContent.dwFlags & SFVMWVF_CONTENTSCHANGE)
    {
        dwRefreshFlags |= REFRESH_CONTENT;
    }
    if (0 != dwRefreshFlags)
    {
        _Refresh(psiItemArray, dwRefreshFlags);
    }
}


void CDUIView::OnExpandSection(DUISEC eDUISecID, BOOL bExpanded)
{
    if (_ppbShellFolders)
    {
        SHPropertyBag_WriteDWORD(_ppbShellFolders, _GetSectionAttributes(eDUISecID)->_pszExpandedPropName, bExpanded);
    }
}


//
// ISSUE-2001/01/02-BrianAu  Review
//
//     This webview task section code may be reworked soon.
//     I created it to address the webview needs of Control Panel.
//     Following this first checkin, the webview guys (EricFlo
//     and MikeSh) and I will look at consolidating the generic
//     needs of Control Panel with the existing webview code.
//
//
// Add a WebView task section to the list of task sections.
//
HRESULT CDUIView::_AddNonStdTaskSection(const SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData)
{
    ASSERT(NULL != pData);
    ASSERT(!IsBadReadPtr(pData, sizeof(*pData)));

    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == _hdsaNonStdTaskSections)
    {
        _hdsaNonStdTaskSections = DSA_Create(sizeof(*pData), 5);
    }
    if (NULL != _hdsaNonStdTaskSections)
    {
        if (-1 != DSA_AppendItem(_hdsaNonStdTaskSections, (void *)pData))
        {
            ASSERT(NULL != pData->pHeader);
            ASSERT(NULL != pData->penumTasks);
            //
            // The list now owns a ref count on the referenced objects.
            //
            pData->pHeader->AddRef();
            pData->penumTasks->AddRef();
            hr = S_OK;
        }
    }
    return THR(hr);
}


void CDUIView::_ClearNonStdTaskSections(void)
{
    if (NULL != _hdsaNonStdTaskSections)
    {
        HDSA hdsa = _hdsaNonStdTaskSections;
        _hdsaNonStdTaskSections = NULL;

        const int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData = (SFVM_WEBVIEW_ENUMTASKSECTION_DATA *)DSA_GetItemPtr(hdsa, i);
            if (NULL != pData)
            {
                ATOMICRELEASE(pData->pHeader);
                ATOMICRELEASE(pData->penumTasks);
            }
        }
        DSA_Destroy(hdsa);
    }
}

//
// Enumerate the non-standard webview task sections
// from the view callback.
//
// ISSUE-2001/01/03-BrianAu  Review
//
//     This SFVM_ENUMWEBVIEWTASKS mechanism may be replaced
//     with a COM enumerator.  I'll be revisiting this with
//     the webview guys soon.
//
HRESULT CDUIView::_GetNonStdTaskSectionsFromViewCB(void)
{
    SFVM_WEBVIEW_ENUMTASKSECTION_DATA data;

    HRESULT hr = S_OK;
    do
    {
        //
        // Continue requesting task section information from
        // the callback until it sets the SFVMWVF_NOMORETASKS
        // flag in the data.  The record with this flag set
        // should not contain any valid data.
        //
        ZeroMemory(&data, sizeof(data));
        hr = _pDefView->CallCB(SFVM_ENUMWEBVIEWTASKS, 0, (LPARAM)&data);
        if (SUCCEEDED(hr))
        {
            if (0 == (SFVMWVF_NOMORETASKS & data.dwFlags))
            {
                hr = _AddNonStdTaskSection(&data);
                ASSERT(S_FALSE != hr);

                data.pHeader->Release();
                data.penumTasks->Release();
            }
            else
            {
                ASSERT(NULL == data.pHeader);
                ASSERT(NULL == data.penumTasks);
                hr = S_FALSE;
            }
        }
    }
    while(S_OK == hr);

    return THR(hr);
}




//  Loads a bitmap based upon:
//
//  lpBitmapID - contains the bitmap description
//  hInstTheme   - instance handle of theme dll

HBITMAP DUILoadBitmap(HINSTANCE hInstTheme, int idBitmapID, UINT uiLoadFlags)
{
    return (HBITMAP)LoadImage(hInstTheme, MAKEINTRESOURCE(idBitmapID), IMAGE_BITMAP, 0, 0, uiLoadFlags);
}

//  Loads an icon based upon the description.
//    Example:  shell32,-42
//
//  pszIconDesc - contains the icon description
//  bSmall     - small icon vs large icon

HICON DUILoadIcon(LPCWSTR pszIconDesc, BOOL bSmall)
{
    HICON hIcon = NULL;
    TCHAR szFile[MAX_PATH];

    StrCpyN(szFile, pszIconDesc, ARRAYSIZE(szFile)); // the below writes this buffer
    int iIconID = PathParseIconLocation(szFile);

    if (bSmall)
    {
        PrivateExtractIcons(szFile, iIconID, 16, 16, &hIcon, NULL, 1, 0);
    }
    else
    {
        PrivateExtractIcons(szFile, iIconID, 32, 32, &hIcon, NULL, 1, 0);
    }

    return hIcon;
}

BOOL CDUIView::Navigate(BOOL fForward)
{
    if (!_phe)
        return FALSE;

    return _phe->Navigate(fForward);
}

HRESULT CDUIView::InitializeDropTarget (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt)
{
    HRESULT hr = E_FAIL;

    if (_pDT)
    {
        hr = _pDT->Initialize(pidl, hWnd, pdt);
    }

    return hr;
}

////////////////////////////////////////////////////////
// HWNDView class
////////////////////////////////////////////////////////

HWNDView::HWNDView(void)
    : _fFocus(TRUE),
      _fDelayedNavigation(false),
      _puiDelayNavCmd(NULL),
      _psiDelayNavArray(NULL),
      _pDefView(NULL),
      _pDUIView(NULL)
{

}

HWNDView::~HWNDView(void)
{
    ATOMICRELEASE(_puiDelayNavCmd);
    ATOMICRELEASE(_psiDelayNavArray);
    ATOMICRELEASE(_pDefView);
    ATOMICRELEASE(_pDUIView);
}


HRESULT HWNDView::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT HWNDView::Create(HWND hParent, bool fDblBuffer, UINT nCreate, CDUIView * pDUIView, CDefView *pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDView* phv = HNewAndZero<HWNDView>();
    if (!phv)
        return E_OUTOFMEMORY;

    HRESULT hr = phv->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        phv->Destroy();
        return hr;
    }

    phv->SetWrapKeyboardNavigate(false);
    phv->SetAccessible(true);
    phv->SetAccRole(ROLE_SYSTEM_PANE);
    phv->SetAccName(L"WebView Pane");
    phv->SetViewPtrs(pDUIView, pDefView);
    *ppElement = phv;

    return S_OK;
}

void HWNDView::SetViewPtrs (CDUIView * pDUIView, CDefView *pDefView)
{
    pDUIView->AddRef();
    _pDUIView = pDUIView;
    pDefView->AddRef();
    _pDefView = pDefView;
}


#define DELAYED_NAVIGATION_TIMER_ID     1236    // random - can be moved

LRESULT HWNDView::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
    case WM_TIMER:
        if (wParam == DELAYED_NAVIGATION_TIMER_ID)
        {
            KillTimer(hWnd, DELAYED_NAVIGATION_TIMER_ID);

            //
            // We have encountered some rare scenarios where _puiDelayNavCmd
            // can be NULL.  
            //
            if (_puiDelayNavCmd)
            {
                HRESULT hr = _puiDelayNavCmd->Invoke(_psiDelayNavArray, NULL);
                if (FAILED(hr))
                {
                    MessageBeep(0);
                }
            }
            ATOMICRELEASE(_puiDelayNavCmd);
            ATOMICRELEASE(_psiDelayNavArray);

            _fDelayedNavigation = false;
        }
        break;

    case WM_USER_DELAY_NAVIGATION:
        ATOMICRELEASE(_puiDelayNavCmd);
        ATOMICRELEASE(_psiDelayNavArray);

        _puiDelayNavCmd = (IUICommand *) lParam;
        _puiDelayNavCmd->AddRef();

        _psiDelayNavArray = (IShellItemArray *) wParam;
        if (NULL != _psiDelayNavArray)
        {
            _psiDelayNavArray->AddRef();
        }

        _fDelayedNavigation = true;

        ::SetTimer(hWnd, DELAYED_NAVIGATION_TIMER_ID, GetDoubleClickTime(), NULL);
        break;

    case WM_MOUSEACTIVATE:
        if ( _fDelayedNavigation )
        {
            //
            //  KB: gpease  05-APR-2001     Fix for WinBug #338552
            //
            //      This prevents the re-activation of the view window after
            //      the user clicks on a link that launches another application,
            //      window, or CPL Applet.
            //
            return MA_NOACTIVATE;
        }
        break;  // do the default wndproc
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
        if (_pDefView)
        {
            // Relay relevant messages to CDefView's infotip control so any
            // infotip tools created in the DUI view will appear/function.
            _pDefView->RelayInfotipMessage(hWnd, uMsg, wParam, lParam);
        }
        break;
    }

    return HWNDElement::WndProc(hWnd, uMsg, wParam, lParam);
}

BOOL HWNDView::Navigate(BOOL fForward)
{
    KeyboardNavigateEvent kne;
    kne.uidType = Element::KeyboardNavigate;
    kne.iNavDir = fForward ? NAV_NEXT : NAV_PREV;

    if (_fFocus)   // remove this check after SetGadgetFocus(NULL) is fixed.
    {
        kne.peTarget = GetKeyFocusedElement();
    }
    else
    {
        kne.peTarget = NULL;
    }

    if (kne.peTarget)
    {
        kne.peTarget->FireEvent(&kne);
        _fFocus = !kne.peTarget->GetKeyFocused();
 
        // If this is the last element in the duiview focus cycle clear focus so if
        // no one else grabs focus and we come back to duiview we'll restart at the 
        // first element.
        //
        // 
        //if (!fFocus)
        //{
        //    SetGadgetFocus(NULL);    Doesn't like NULL!!!
        //}
    }
    else
    {
        bool fWrap;
        if(!fForward)
        {
            fWrap = GetWrapKeyboardNavigate();
            SetWrapKeyboardNavigate(true);
        }

        FireEvent(&kne);  
        _fFocus = (GetKeyFocusedElement() != NULL);

        if(!fForward)
        {
            SetWrapKeyboardNavigate(fWrap);
        }
    }

    return _fFocus;
}

UINT HWNDView::MessageCallback(GMSG* pGMsg)
{
    EventMsg * pmsg = static_cast<EventMsg *>(pGMsg);

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
    case GMF_BUBBLED:

        if (pGMsg->nMsg == GM_QUERY)
        {
            GMSG_QUERYDROPTARGET * pTemp = (GMSG_QUERYDROPTARGET *)pGMsg;

            if (pTemp->nCode == GQUERY_DROPTARGET)
            {
                if (SUCCEEDED(_pDUIView->InitializeDropTarget(NULL, NULL, &pTemp->pdt)))
                {
                    pTemp->hgadDrop = pTemp->hgadMsg;
                    return DU_S_COMPLETE;
                }
            }
        }
        break;
    }

    return Element::MessageCallback(pGMsg);
}

void HWNDView::OnEvent(Event* pev)
{
    if (pev->uidType == Button::Click)
    {
        if (pev->peTarget == FindDescendent(StrToID(L"blockadeclearbutton")))
        {
            if (NULL != _pDefView)
            {
                _pDefView->RemoveBarricade();
            }
            pev->fHandled = true;
        }
    }
    HWNDElement::OnEvent(pev);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDView::Class = NULL;
HRESULT HWNDView::Register()
{
    return ClassInfo<HWNDView,HWNDElement>::Register(L"HWNDView", NULL, 0);
}

HRESULT InitializeDUIViewClasses(void)
{
    HRESULT hr;

    hr = DUIAxHost::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CNameSpaceItemInfoList::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CNameSpaceItemInfo::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CMiniPreviewer::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CBitmapElement::Register();
    if (FAILED(hr))
        goto Failure;

    hr = DUIListView::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expando::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Clipper::Register();
    if (FAILED(hr))
        goto Failure;

    hr = TaskList::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ActionTask::Register();
    if (FAILED(hr))
        goto Failure;

    hr = DestinationTask::Register();
    if (FAILED(hr))
        goto Failure;

    hr = HWNDView::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duiview.h ===
#ifndef _DUIVIEW_H_INCLUDED_
#define _DUIVIEW_H_INCLUDED_

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#define GADGET_ENABLE_OLE
#include <duser.h>
#include <directui.h>
#include <duserctrl.h>

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);
UsingDUIClass(Thumb);
UsingDUIClass(ScrollBar);
UsingDUIClass(Viewer);
UsingDUIClass(Selector);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Edit);


#define WM_HTML_BITMAP  (WM_USER + 100)
#define WM_DETAILS_INFO (WM_USER + 101)

typedef enum {
    DUISEC_UNKNOWN          = 0,
    DUISEC_SPECIALTASKS     = 1,
    DUISEC_FILETASKS        = 2,
    DUISEC_OTHERPLACESTASKS = 3,
    DUISEC_DETAILSTASKS     = 4
} DUISEC;

struct DUISEC_ATTRIBUTES;


// Right now our themeing information is hard-coded due to limitations of DirectUI (only one resource)
// so we'll ask the namespace for a hardcoded name that we can look up in the below table.  Add new
// names/entries to this list as we add theme parts to our shellstyle.dll.
//
typedef struct {
    LPCWSTR pszThemeName;
    int     idSpecialSectionIcon;
    int     idSpecialSectionWatermark;
    int     idListviewWatermark;
} WVTHEME;

#include "defviewp.h"
#include "w32utils.h"

class CDefView;
class Expando;
class HWNDView;
class ActionTask;
class DestinationTask;
class DUIListView;
class DUIAxHost;
class CDetailsSectionInfoTask;
class CDUIDropTarget;

STDAPI CDetailsSectionInfoTask_CreateInstance(IShellFolder *psfContaining,
                                              LPCITEMIDLIST pidlAbsolute,
                                              HWND hwndMsg,
                                              UINT uMsg,
                                              DWORD dwDetailsInfoID,
                                              CDetailsSectionInfoTask **ppTask);

//
// CDUIView class
//

class CDUIView
{

private:
    LONG                _cRef;
    HWND                _hWnd;
    HWNDView *          _phe;
    DUIListView *       _peListView;
    INT                 _iListViewHeight;  // used when the preview control is also displayed
    INT                 _iOriginalTaskPaneWidth;
    INT                 _iTaskPaneWidth;
    DUIAxHost *         _pePreview;
    IUnknown *          _punkPreview;
    CDefView *          _pDefView;
    Element *           _peTaskPane;
    Element *           _peClientViewHost;
    Element *           _peBarrier;
    BOOL                _bBarrierShown;
    BOOL                _bInitialized;
    BSTR                _bstrIntroText;
    IPropertyBag *      _ppbShellFolders;
    CDUIDropTarget *    _pDT;


    Expando* _peSpecialSection;
    Element* _peSpecialTaskList;
    Value*   _pvSpecialTaskSheet;
    Expando* _peFolderSection;
    Element* _peFolderTaskList;
    Value*   _pvFolderTaskSheet;
    Expando* _peDetailsSection;
    Element* _peDetailsInfoArea;
    Value*   _pvDetailsSheet;
    IShellItemArray* _pshlItems;
    HDSA      _hdsaNonStdTaskSections;
    BOOL      _fLoadedTheme;
    HINSTANCE _hinstTheme;
    HANDLE    _hinstScrollbarTheme;
    BOOL      _bAnimationsDisabled;

    HRESULT _hrInit;
    CDUIView(CDefView * pDefView);
    ~CDUIView();

public:
    HRESULT Initialize();
    friend CDUIView* Create_CDUIView(CDefView * pDefView);

    void AddRef(void)
        { InterlockedIncrement(&_cRef); }
    
    void Release(void)
        { if (0 == InterlockedDecrement(&_cRef)) delete this; }

    void DetachListview();

    HRESULT Initialize(BOOL bDisplayBarrier, IUnknown * punkPreview);
    HRESULT EnableBarrier(BOOL bDisplayBarrier);
    HRESULT EnablePreview(IUnknown * punkPreview);
    HRESULT Refresh(void);
    HRESULT SetSize(RECT *rc);
    HRESULT SetTaskPaneVisibility(BOOL bShow);
    void CalculateInfotipRect(Element *pe, RECT *pRect);
    BOOL Navigate(BOOL fForward);
    HRESULT InitializeDropTarget (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt);

    HRESULT NavigateToDestination(LPCITEMIDLIST pidl);
    HRESULT DelayedNavigation(IShellItemArray *psiItemArray, IUICommand *puiCommand);

    void UnInitializeDirectUI(void);

    void ManageAnimations(BOOL bExiting);
    HINSTANCE _GetThemeHinst(void);

    void OnSelectionChange(IShellItemArray *psiItemArray);
    void OnContentsChange(IShellItemArray *psiItemArray);
    void OnExpandSection(DUISEC eDUISecID, BOOL bExpanded);
    const WVTHEME* GetThemeInfo();

private:

    //
    // Flags passed to _Refresh().
    //
    enum REFRESH_FLAGS { 
        REFRESH_TASKS   = 0x00000001,  // Refresh webview task list content.
        REFRESH_CONTENT = 0x00000002,  // Refresh webview right-pane content.
        REFRESH_SELCHG  = 0x00000004,  // Refreshing for a selection change
        REFRESH_ALL     = 0x00000003
        };

    HRESULT _CreateHostWindow(void);
    HRESULT _LoadUIFileFromResources(HINSTANCE hinst, INT iID, char **pUIFile);
    HRESULT _BuildUIFile(char **pUIFile, int *piCharCount);
    HRESULT _BuildSection(Element* peSectionList, BOOL bMain, IUIElement* pTitle,
                              int idBitmapDesc, int idWatermarkDesc, Value* pvSectionSheet,
                              Parser* pParser, DUISEC eDUISecID, Expando ** ppeExpando, Element ** pTaskList);
    HRESULT _AddActionTasks(Expando* peExpando, Element* peTaskList, IEnumUICommand* penum, Value* pvTaskSheet, BOOL bIntroAdded);
    HRESULT _AddDestinationTasks(Element* peTaskList, IEnumIDList* penum, Value* pvTaskSheet);
    HRESULT _AddDetailsSectionInfo();
    HRESULT _BuildTaskList(Parser* pParser);
    HRESULT _BuildStandardTaskList(Parser *pParser, Element *peSectionList);
    HRESULT _BuildNonStandardTaskList(Parser *pParser, Element *peSectionList, HDSA hdsaSections);
    HRESULT _InitializeElements(char * pUIFile, int iCharCount, BOOL bDisplayBarrier, IUnknown * punkPreview);
    HRESULT _SwitchToBarrier(BOOL bDisplayBarrier);
    HRESULT _ManagePreview(IUnknown * punkPreview);
    HRESULT _GetIntroTextElement(Element** ppeIntroText);
    HRESULT _BuildSoftBarrier(void);
    void    _InitializeShellFolderPropertyBag();
    BOOL    _ShowSectionExpanded(DUISEC eDUISecID);
    const struct DUISEC_ATTRIBUTES *_GetSectionAttributes(DUISEC eDUISecID);
    static LRESULT CALLBACK _DUIHostWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    HRESULT _OnResize(long lWidth, long lHeight);
    void _Refresh(IShellItemArray *psiItemArray, DWORD dwRefreshFlags = REFRESH_ALL);

    HRESULT _AddNonStdTaskSection(const SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData);
    HRESULT _GetNonStdTaskSectionsFromViewCB(void);
    void _ClearNonStdTaskSections(void);

    BOOL _bHideTaskPaneAlways;    // Set to TRUE when "Use Classic View" is used, FALSE otherwise
    BOOL _fHideTasklist;          // Set to TRUE when an explorer bar is visible

public:
    // Thumbnail extraction stuff...
    HRESULT InitializeThumbnail(WNDPROC pfnWndProc);
    HRESULT SetThumbnailMsgWindowPtr(void* p, void* pCheck);
    HRESULT StartBitmapExtraction(LPCITEMIDLIST pidl);

    // Details section info extraction stuff...
    HRESULT InitializeDetailsInfo(WNDPROC pfnWndProc);
    HRESULT SetDetailsInfoMsgWindowPtr(void* p, void* pCheck);
    HRESULT StartInfoExtraction(LPCITEMIDLIST pidl);
    VOID ShowDetails(BOOL fShow);
    BOOL ShouldShowMiniPreview();

    DWORD                   _dwThumbnailID;         // Accessed by CMiniPreviewer (duiinfo.cpp)
    DWORD                   _dwDetailsInfoID;       // Accessed by CMiniPreviewer (duiinfo.cpp)

protected:
    CComPtr<IThumbnail2>    _spThumbnailExtractor2;
    HWND                    _hwndMsgThumbExtract;
    HWND                    _hwndMsgInfoExtract;
    
};

HBITMAP DUILoadBitmap(HINSTANCE hInstTheme, int idBitmapID, UINT uiLoadFlags);
HICON DUILoadIcon(LPCWSTR pszIconDesc, BOOL bSmall);


class HWNDView: public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement); // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement);
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, CDUIView * pDUIView, CDefView* pDefView, OUT Element** ppElement);

    BOOL Navigate(BOOL fForward);
    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual UINT MessageCallback(GMSG* pGMsg);
    virtual void OnEvent(Event* pEvent);
    void SetViewPtrs (CDUIView * pDUIView, CDefView* pDefView);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HWNDView(void);
    virtual ~HWNDView(void);

private:
    BOOL _fFocus;               // hack until SetGadgetFocus(NULL) works.
                                // see HWNDView::Navigate.
    BOOL _fDelayedNavigation;   //  Try to prevent double-clicking. If this is TRUE, then one click
                                //  has already been fired.
    IUICommand *      _puiDelayNavCmd;      //  The UI command object for delayed navigation. Look for WM_USER_DELAY_NAGIVATION.
    IShellItemArray * _psiDelayNavArray;    //  The Shell Item Arraay for delayed navigation. Look for WM_USER_DELAY_NAGIVATION.
    CDefView *        _pDefView;// used to relay infotip messages
    CDUIView*         _pDUIView;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\duitask.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "duiview.h"
#include "duitask.h"
#include "dvtasks.h"
#include "contextmenu.h"
#include "ids.h"





//  Returns a given task element's root HWND element.
//
//

HRESULT GetElementRootHWNDElement(Element *pe, HWNDElement **pphwndeRoot)
{
    HRESULT hr;
    if (pe)
    {
        Element *peRoot = pe->GetRoot();
        if (peRoot && peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
        {
            *pphwndeRoot = reinterpret_cast<HWNDElement *>(peRoot);
            hr = S_OK;
        }
        else
        {
            *pphwndeRoot = NULL;
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        ASSERT(FALSE);
    }
    return hr;
}

//  Returns a given task element's root HWND element's HWND.
//
//

HRESULT GetElementRootHWND(Element *pe, HWND *phwnd)
{
    HWNDElement *phwndeRoot;
    HRESULT hr = GetElementRootHWNDElement(pe, &phwndeRoot);
    if (SUCCEEDED(hr))
    {
        *phwnd = phwndeRoot->GetHWND();
        hr = *phwnd ? S_OK : S_FALSE;
    }
    return hr;
}

//  Creates an instance of the ActionTask and
//  initializes it
//
//  nActive    - Activation type
//  puiCommand - the Task itself
//  ppElement  - Receives element pointer

HRESULT ActionTask::Create(UINT nActive, IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    if (!puiCommand || !pDUIView || !pDefView)
    {
        return E_INVALIDARG;
    }

    ActionTask* pAT = HNewAndZero<ActionTask>();
    if (!pAT)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pAT->Initialize(puiCommand, psiItemArray, pDUIView, pDefView);
    if (FAILED(hr))
    {
        pAT->Destroy();
        return hr;
    }

    *ppElement = pAT;

    return S_OK;
}

//  Initializes this task
//
//  puiCommand - the Task itself

HRESULT ActionTask::Initialize(IUICommand *puiCommand, IShellItemArray *psiItemArray, CDUIView *pDUIView, CDefView *pDefView)
{
    HRESULT hr;

    // Initialize this DUI Element.
    hr = InitializeElement();
    if (SUCCEEDED(hr))
    {
        // Initialize the contained DUI Button.
        hr = InitializeButton();
        if (SUCCEEDED(hr))
        {
            // Save the pointer to the IUICommand class
            puiCommand->AddRef();
            _puiCommand = puiCommand;

            // Save the pointer to the CDUIView class
            pDUIView->AddRef();
            _pDUIView = pDUIView;

            // Save the pointer to the CDefView class
            pDefView->AddRef();
            _pDefView = pDefView;

            // Save the pointer to the IShellItemArray class (if available)
            if (psiItemArray)
            {
                psiItemArray->AddRef();
                _psiItemArray = psiItemArray;
            }

            UpdateTaskUI();
        }
    }

    return hr;
}

HRESULT ActionTask::InitializeElement()
{
    HRESULT hr;

    // Initialize base class (normal display node creation).
    hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        // Create a layout for this element.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for this element.
            hr = SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "ActionTask::Initialize: base class failed to initialize with 0x%x", hr);
    }

    return hr;
}

HRESULT ActionTask::InitializeButton()
{
    HRESULT hr;

    // Create the button.
    hr = Button::Create((Element**)&_peButton);
    if (SUCCEEDED(hr))
    {
        // Set some button attributes.
        _peButton->SetLayoutPos(BLP_Left);
        _peButton->SetAccessible(true);
        _peButton->SetAccRole(ROLE_SYSTEM_PUSHBUTTON);
        TCHAR szDefaultAction[50] = {0};
        LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, szDefaultAction, ARRAYSIZE(szDefaultAction));
        _peButton->SetAccDefAction(szDefaultAction);

        // Create a border layout for the icon and title in the button.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the button layout.
            hr = _peButton->SetValue(LayoutProp, PI_Local, pv);
            if (SUCCEEDED(hr))
            {
                // Add the button to this element.
                hr = Add(_peButton);
            }
            pv->Release();
        }

        // Cleanup (if necessary).
        if (FAILED(hr))
        {
            _peButton->Destroy();
            _peButton = NULL;
        }
    }

    return hr;
}

ActionTask::ActionTask()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_peButton     == NULL);
    ASSERT(_puiCommand   == NULL);
    ASSERT(_psiItemArray == NULL);
    ASSERT(_pDefView     == NULL);
    ASSERT(_pDefView     == NULL);
    ASSERT(_hwndRoot     == NULL);
    ASSERT(_pDUIView     == NULL);

    _bInfotip = FALSE;
}

ActionTask::~ActionTask()
{
    if (_bInfotip)
    {
        // Destroy the infotip.
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
    }

    if (_puiCommand)
        _puiCommand->Release();

    if (_psiItemArray)
        _psiItemArray->Release();

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}

void ActionTask::UpdateTaskUI()
{
    // Set the icon

    LPWSTR pIconDesc;
    if (SUCCEEDED(_puiCommand->get_Icon(_psiItemArray, &pIconDesc)))
    {
        Element* pe;
        if (SUCCEEDED(Element::Create(0, &pe)))
        {
            pe->SetLayoutPos(BLP_Left);
            pe->SetID(L"icon");
            _peButton->Add(pe);

            HICON hIcon = DUILoadIcon(pIconDesc, TRUE);
            if (hIcon)
            {
                Value* pv = Value::CreateGraphic (hIcon);
                if (pv)
                {
                    pe->SetValue(Element::ContentProp, PI_Local, pv);
                    pv->Release();
                }
                else
                {
                    DestroyIcon(hIcon);

                    TraceMsg(TF_ERROR, "ActionTask::Initialize: CreateGraphic for the icon failed.");
                }
            }
            else
            {
                TraceMsg(TF_ERROR, "ActionTask::Initialize: DUILoadIcon failed.");
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "ActionTask::Initialize: Failed to create icon element");
        }

        CoTaskMemFree(pIconDesc);
    }

    // Set the title

    LPWSTR pszTitleDesc;
    if (SUCCEEDED(_puiCommand->get_Name(_psiItemArray, &pszTitleDesc)))
    {
        Element* pe;
        if (SUCCEEDED(Element::Create(0, &pe)))
        {
            pe->SetLayoutPos(BLP_Left);
            pe->SetID(L"title");
            _peButton->Add(pe);

            Value* pv = Value::CreateString(pszTitleDesc);
            if (pv)
            {
                _peButton->SetValue(Element::AccNameProp, PI_Local, pv);
                pe->SetValue(Element::ContentProp, PI_Local, pv);
                pv->Release();
            }
            else
            {
                TraceMsg(TF_ERROR, "ActionTask::Initialize: CreateString for the title failed.");
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "ActionTask::Initialize: Failed to create title element");
        }

        CoTaskMemFree(pszTitleDesc);
    }
}

//  Shows/hides an Infotip window
//
//  bShow - TRUE or FALSE to show or hide the Infotip window

HRESULT ActionTask::ShowInfotipWindow(BOOL bShow)
{
    RECT rect = { 0 };
    HRESULT hr;

    if (bShow)
    {
        _pDUIView->CalculateInfotipRect(this, &rect);
        if (_bInfotip)
        {
            // Reposition infotip at position.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // Create infotip at position (on the ui thread).
            LPWSTR pwszInfotip;
            hr = _puiCommand->get_Tooltip(_psiItemArray, &pwszInfotip);
            if (SUCCEEDED(hr))
            {
                hr = GetElementRootHWND(this, &_hwndRoot);
                if (SUCCEEDED(hr))
                {
                    hr = _pDefView->CreateInfotip(_hwndRoot, (UINT_PTR)this, &rect, pwszInfotip, 0);
                    if (SUCCEEDED(hr))
                    {
                        _bInfotip = TRUE;
                    }
                }
                CoTaskMemFree(pwszInfotip);
            }
        }
    }
    else
    {
        if (_bInfotip)
        {
            // Reposition infotip at nowhere.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // No infotip == no show!
            hr = S_OK;
        }
    }

    return hr;
}

// System event handler
//
//

void ActionTask::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Default processing...
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Extended processing for infotip...
    if (IsProp(MouseWithin))
        ShowInfotipWindow(pvNew->GetBool() && SHShowInfotips());
}


//  Event handler
//
//  pev - event information

void ActionTask::OnEvent(Event* pev)
{
    if (pev->peTarget == _peButton)
    {
        if (pev->uidType == Button::Click)
        {
            if ( NULL != _pDUIView )    // This should have been past in during initialization.
            {
                _pDUIView->DelayedNavigation(_psiItemArray, _puiCommand);
            }
            pev->fHandled = true;
        }
    }
    Element::OnEvent(pev);
}

// Class information

IClassInfo* ActionTask::Class = NULL;
HRESULT ActionTask::Register()
{
    return ClassInfo<ActionTask,Element>::Register(L"ActionTask", NULL, 0);
}


//  Creates an instance of the DestinationTask and
//  initializes it
//
//  nActive    - Activation type
//  pidl       - pidl of destination
//  ppElement  - Receives element pointer
//

HRESULT DestinationTask::Create(UINT nActive, LPITEMIDLIST pidl,
                                 CDUIView * pDUIView, CDefView *pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    if (!pidl || !pDUIView || !pDefView)
    {
        return E_FAIL;
    }

    DestinationTask* pDT = HNewAndZero<DestinationTask>();
    if (!pDT)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pDT->Initialize(pidl, pDUIView, pDefView);

    if (FAILED(hr))
    {
        pDT->Destroy();
        return hr;
    }

    *ppElement = pDT;

    return S_OK;
}

//  Initializes this task
//
//  pidl - Destination pidl

HRESULT DestinationTask::Initialize(LPITEMIDLIST pidl, CDUIView *pDUIView, CDefView *pDefView)
{
    HRESULT hr;

    // Initialize this DUI Element.
    hr = InitializeElement();
    if (SUCCEEDED(hr))
    {
        HICON hIcon = NULL;
        WCHAR szTitle[MAX_PATH];

        // Retrieve the info needed to initialize the contained DUI Button.
        HIMAGELIST himl;
        if (Shell_GetImageLists(NULL, &himl))
        {
            IShellFolder *psf;
            LPCITEMIDLIST pidlItem;
            hr = SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlItem);
            if (SUCCEEDED(hr))
            {
                // Retrieve icon.
                int iSysIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
                if (iSysIndex != -1)
                {
                    hIcon = ImageList_GetIcon(himl, iSysIndex, 0);
                }

                // Retrieve text.
                hr = DisplayNameOf(psf, pidlItem, SHGDN_INFOLDER, szTitle, ARRAYSIZE(szTitle));

                psf->Release();
            }

        }
        else
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            // Initialize the contained DUI Button.
            hr = InitializeButton(hIcon, szTitle);
            if (SUCCEEDED(hr))
            {
                // Save the destination pidl
                hr = SHILClone(pidl, &_pidlDestination);
                if (SUCCEEDED(hr))
                {
                    // Save the pointer to the CDUIView class
                    pDUIView->AddRef();
                    _pDUIView = pDUIView;

                    // Save the pointer to the CDefView class
                    pDefView->AddRef();
                    _pDefView = pDefView;
                }
            }
        }
    }
    return hr;
}

HRESULT DestinationTask::InitializeElement()
{
    HRESULT hr;

    // Initialize base class (normal display node creation).
    hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        // Create a layout for this element.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for this element.
            hr = SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "DestinationTask::Initialize: base class failed to initialize with 0x%x", hr);
    }

    return hr;
}

HRESULT DestinationTask::InitializeButton(HICON hIcon, LPCWSTR pwszTitle)
{
    ASSERT(pwszTitle);
    HRESULT hr;

    // Create the button.
    hr =  Button::Create((Element**)&_peButton);
    if (SUCCEEDED(hr))
    {
        // Set some button attributes.
        _peButton->SetLayoutPos(BLP_Left);
        _peButton->SetAccessible(true);
        _peButton->SetAccRole(ROLE_SYSTEM_LINK);
        TCHAR szDefaultAction[50] = {0};
        LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, szDefaultAction, ARRAYSIZE(szDefaultAction));
        _peButton->SetAccDefAction(szDefaultAction);

        // Create a border layout for the icon and title in the button.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for the button.
            hr = _peButton->SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
            if (SUCCEEDED(hr))
            {
                HRESULT hr2 = E_FAIL;
                HRESULT hr3 = E_FAIL;

                // Init the button icon.
                if (hIcon)
                {
                    Element *peIcon;

                    // Create an icon element.
                    hr2 = Element::Create(0, &peIcon);
                    if (SUCCEEDED(hr2))
                    {
                        // Set some icon element attributes.
                        peIcon->SetLayoutPos(BLP_Left);
                        peIcon->SetID(L"icon");

                        // Add the icon to the icon element.
                        pv = Value::CreateGraphic(hIcon);
                        if (pv)
                        {
                            hr2 = peIcon->SetValue(Element::ContentProp, PI_Local, pv);
                            pv->Release();
                            if (SUCCEEDED(hr2))
                            {
                                // Add the icon element to the button.
                                hr2 = _peButton->Add(peIcon);
                            }
                        }

                        // Cleanup (if necessary).
                        if (FAILED(hr2))
                        {
                            peIcon->Destroy();
                        }
                    }
                }

                // Init the button title.
                if (pwszTitle[0])
                {
                    Element *peTitle;
                    
                    // Create a title element.
                    hr3 = Element::Create(0, &peTitle);
                    if (SUCCEEDED(hr3))
                    {
                        // Set some title element attributes.
                        peTitle->SetLayoutPos(BLP_Left);
                        peTitle->SetID(L"title");

                        // Add the title to the title element.
                        pv = Value::CreateString(pwszTitle);
                        if (pv)
                        {
                            hr3 = peTitle->SetValue(Element::ContentProp, PI_Local, pv);
                            if (SUCCEEDED(hr3))
                            {
                                _peButton->SetValue(Element::AccNameProp, PI_Local, pv);

                                // Add the title element to the button.
                                hr3 = _peButton->Add(peTitle);
                            }
                            pv->Release();
                        }

                        // Cleanup (if necessary).
                        if (FAILED(hr3))
                        {
                            peTitle->Destroy();
                        }
                    }
                }

                if (SUCCEEDED(hr2) || SUCCEEDED(hr3))
                {
                    // Add the button to this element.
                    hr = Add(_peButton);
                }
                else
                {
                    // Failed init icon AND init title for button.
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            _peButton->Destroy();
            _peButton = NULL;
        }
    }

    return hr;
}

DestinationTask::DestinationTask()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_peButton        == NULL);
    ASSERT(_pidlDestination == NULL);
    ASSERT(_pDUIView        == NULL);
    ASSERT(_pDefView        == NULL);
    ASSERT(_hwndRoot        == NULL);

    _bInfotip = FALSE;
}

DestinationTask::~DestinationTask()
{
    if (_bInfotip)
    {
        // Kill the background infotip task (if any).
        if (_pDefView->_pScheduler)
            _pDefView->_pScheduler->RemoveTasks(TOID_DVBackgroundInfoTip, (DWORD_PTR)this, FALSE);

        // Destroy the infotip.
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
    }

    ILFree(_pidlDestination); /* NULL ok */

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}


// To use _pDUIView->DelayedNavigation(_psiItemArray, _puiCommand)
// we create this bogus IUICommand impl to get Invoke through
class CInvokePidl : public IUICommand
{
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IUICommand
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) { return E_NOTIMPL; }
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) { return E_NOTIMPL; }
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) { return E_NOTIMPL; }
    STDMETHODIMP get_CanonicalName(GUID* pguidCommandName) { return E_NOTIMPL; }
    STDMETHODIMP get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState) { return E_NOTIMPL; }
    // Our one real method:
    STDMETHODIMP Invoke(IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        return _pDUIView->NavigateToDestination(_pidlDestination);
    }

    friend HRESULT Create_InvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, REFIID riid, void** ppv);

private:
    CInvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, HRESULT* phr);
    ~CInvokePidl();

    LONG _cRef;
    CDUIView* _pDUIView;
    LPITEMIDLIST _pidlDestination;
};

CInvokePidl::CInvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, HRESULT* phr)
{
    _cRef = 1;
    (_pDUIView = pDUIView)->AddRef();

    _pidlDestination = ILClone(pidl);
    if (_pidlDestination)
        *phr = S_OK;
    else
        *phr = E_OUTOFMEMORY;
}

CInvokePidl::~CInvokePidl()
{
    ILFree(_pidlDestination);
    if (_pDUIView)
        _pDUIView->Release();
}

HRESULT Create_InvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, REFIID riid, void** ppv)
{
    HRESULT hr;
    *ppv = NULL;
    CInvokePidl* p = new CInvokePidl(pDUIView, pidl, &hr);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDMETHODIMP CInvokePidl::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CInvokePidl, IUICommand),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CInvokePidl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CInvokePidl::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


//  Navigates to the destination pidl
//
//  none

HRESULT DestinationTask::InvokePidl()
{
    IUICommand* puiInvokePidl;
    HRESULT hr = Create_InvokePidl(_pDUIView, _pidlDestination, IID_PPV_ARG(IUICommand, &puiInvokePidl));
    if (SUCCEEDED(hr))
    {
        hr = _pDUIView->DelayedNavigation(NULL, puiInvokePidl);
        puiInvokePidl->Release();
    }
    return hr;
}

//  Displays the context menu
//
//  ppt - point to display menu

HRESULT DestinationTask::OnContextMenu(POINT *ppt)
{
    HRESULT hr = E_FAIL;

    if (!GetHWND())
        return hr;

    if (ppt->x == -1) // Keyboard context menu
    {
        Value *pv;
        const SIZE *psize = GetExtent(&pv);
        ppt->x = psize->cx/2;
        ppt->y = psize->cy/2;
        pv->Release();
    }

    POINT pt;
    GetRoot()->MapElementPoint(this, ppt, &pt);

    ClientToScreen(GetHWND(), &pt);

    IContextMenu *pcm;
    if (SUCCEEDED(SHGetUIObjectFromFullPIDL(_pidlDestination, GetHWND(), IID_PPV_ARG(IContextMenu, &pcm))))
    {
        IContextMenu *pcmWrap;
        if (SUCCEEDED(Create_ContextMenuWithoutVerbs(pcm, L"link;cut;delete", IID_PPV_ARG(IContextMenu, &pcmWrap))))
        {
            hr = IUnknown_DoContextMenuPopup(SAFECAST(_pDefView, IShellView2*), pcmWrap, CMF_NORMAL, pt);

            pcmWrap->Release();
        }
        pcm->Release();
    }

    return hr;
}

//  Shows/hides an Infotip window
//
//  bShow - TRUE or FALSE to show or hide the Infotip window

HRESULT DestinationTask::ShowInfotipWindow(BOOL bShow)
{
    RECT rect = { 0 };
    HRESULT hr;

    if (bShow)
    {
        _pDUIView->CalculateInfotipRect(this, &rect);
        if (_bInfotip)
        {
            // Reposition infotip at position.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // Create infotip at position.
            hr = GetElementRootHWND(this, &_hwndRoot);
            if (SUCCEEDED(hr))
            {
                // PreCreateInfotip() on the ui thread.
                hr = _pDefView->PreCreateInfotip(_hwndRoot, (UINT_PTR)this, &rect);
                if (SUCCEEDED(hr))
                {
                    // PostCreateInfotip() on a background thread.
                    CDUIInfotipTask *pTask;
                    hr = CDUIInfotipTask_CreateInstance(_pDefView, _hwndRoot, (UINT_PTR)this, _pidlDestination, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDefView->_AddTask(pTask, TOID_DVBackgroundInfoTip, (DWORD_PTR)this, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                        pTask->Release();
                    }

                    // Persist success or cleanup failure.
                    if (SUCCEEDED(hr))
                        _bInfotip = TRUE;
                    else
                        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
                }
            }
        }
    }
    else
    {
        if (_bInfotip)
        {
            // Reposition infotip at nowhere.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // No infotip == no show!
            hr = S_OK;
        }
    }

    return hr;
}

// System event handler
//
//

void DestinationTask::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Default processing...
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Extended processing for infotip...
    if (IsProp(MouseWithin))
        ShowInfotipWindow(pvNew->GetBool() && SHShowInfotips());
}

//  Event handler
//
//  pev - event information

void DestinationTask::OnEvent(Event* pev)
{
    if (pev->peTarget == _peButton)
    {
        if (pev->uidType == Button::Click)
        {
            InvokePidl();
            pev->fHandled = true;
        }
        else if (pev->uidType == Button::Context)
        {
            ButtonContextEvent *peButton = reinterpret_cast<ButtonContextEvent *>(pev);
            OnContextMenu(&peButton->pt);
            pev->fHandled = true;
        }
    }
    Element::OnEvent(pev);
}

//  Gadget message callback handler used to return
//  the IDropTarget interface
//
//  pGMsg - Gadget message
//
//  DU_S_COMPLETE if handled
//  Host element's return value if not

UINT DestinationTask::MessageCallback(GMSG* pGMsg)
{
    EventMsg * pmsg = static_cast<EventMsg *>(pGMsg);

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
    case GMF_BUBBLED:

        if (pGMsg->nMsg == GM_QUERY)
        {
            GMSG_QUERYDROPTARGET * pTemp = (GMSG_QUERYDROPTARGET *)pGMsg;

            if (pTemp->nCode == GQUERY_DROPTARGET)
            {
                if (SUCCEEDED(_pDUIView->InitializeDropTarget(_pidlDestination, GetHWND(), &pTemp->pdt)))
                {
                    pTemp->hgadDrop = pTemp->hgadMsg;
                    return DU_S_COMPLETE;
                }
            }
        }
        break;
    }

    return Element::MessageCallback(pGMsg);
}

// Class information

IClassInfo* DestinationTask::Class = NULL;
HRESULT DestinationTask::Register()
{
    return ClassInfo<DestinationTask,Element>::Register(L"DestinationTask", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dvmenu.cpp ===
#include "shellprv.h"
#include "defview.h"
#include "defviewp.h"
#include "contextmenu.h"
#include "ids.h"
#include "unicpp\deskhtm.h"

class CThumbnailMenu : public IContextMenu3,
                       public CComObjectRoot,
                       public IObjectWithSite
{
public:
    BEGIN_COM_MAP(CThumbnailMenu)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu3,IContextMenu3)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu2,IContextMenu2)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu,IContextMenu)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CThumbnailMenu)
    
    CThumbnailMenu();
    ~CThumbnailMenu();

    HRESULT Init(CDefView* pView, LPCITEMIDLIST * apidl, UINT cidl);
    
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                   UINT indexMenu,
                                   UINT idCmdFirst,
                                   UINT idCmdLast,
                                   UINT uFlags);


    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    STDMETHOD(GetCommandString)(UINT_PTR idCmd,
                                 UINT uType,
                                 UINT * pwReserved,
                                 LPSTR pszName,
                                 UINT cchMax);
                                 
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plRes);
                              
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    LPCITEMIDLIST * _apidl;
    UINT _cidl;
    IContextMenu *_pMenu;
    IContextMenu2 *_pMenu2;
    BOOL _fCaptureAvail;
    UINT _wID;
    CDefView* _pView;
};


HRESULT CDefView::_CreateSelectionContextMenu(REFIID riid, void** ppv)
{
    *ppv = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    if (_IsImageMode() && !_IsOwnerData())
    {
        LPCITEMIDLIST* apidl;
        UINT cidl;

        _GetItemObjects(&apidl, SVGIO_SELECTION, &cidl);
        if (apidl)
        {
            // get the context menu interface for the object ....
            CComObject<CThumbnailMenu> * pMenuTmp = new CComObject<CThumbnailMenu>;
            if (pMenuTmp)
            {
                pMenuTmp->AddRef(); // ATL is strange, start with zero ref
                hr = pMenuTmp->Init(this, apidl, cidl);
                if (SUCCEEDED(hr))
                    hr = pMenuTmp->QueryInterface(riid, ppv);
                pMenuTmp->Release();
            }

            LocalFree((HLOCAL)apidl);
        }
    }
    else
    {
        hr = GetItemObject(SVGIO_SELECTION, riid, ppv);
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && !*ppv));
    return hr;
}


LPCITEMIDLIST * DuplicateIDArray(LPCITEMIDLIST * apidl, UINT cidl)
{
    LPCITEMIDLIST * apidlNew = (LPCITEMIDLIST *) LocalAlloc(LPTR, cidl * sizeof(LPCITEMIDLIST));

    if (apidlNew)
    {
        CopyMemory(apidlNew, apidl, cidl * sizeof(LPCITEMIDLIST));
    }

    return apidlNew;
}

CThumbnailMenu::CThumbnailMenu()
{
    _pMenu = NULL;
    _pMenu2 = NULL;
    _pView = NULL;
    _apidl = NULL;
    _cidl = NULL;
    _fCaptureAvail = FALSE;
    _wID = -1;
}

CThumbnailMenu::~CThumbnailMenu()
{
    if (_pMenu)
    {
        _pMenu->Release();
    }

    if (_pMenu2)
    {
        _pMenu2->Release();
    }

    if (_pView)
    {
        _pView->Release();
    }
    
    if (_apidl)
    {
        LocalFree(_apidl);
    }
}

HRESULT CThumbnailMenu::Init(CDefView*pView, LPCITEMIDLIST *apidl, UINT cidl)
{
    if (cidl == 0)
        return E_INVALIDARG;

    // duplicate the array that holds the pointers ..
    _apidl = DuplicateIDArray(apidl, cidl);
    _cidl  = cidl;

    if (_apidl == NULL)
    {
        _cidl = 0;
        return E_OUTOFMEMORY;
    }

    _pView = pView;
    pView->AddRef();
    
    // scan the pidl array and check for Extractors ...
    for (int i = 0; i < (int) _cidl; i++)
    {
        IExtractImage *pExtract;
        HRESULT hr = pView->_pshf->GetUIObjectOf(pView->_hwndView, 1, &_apidl[i], IID_PPV_ARG_NULL(IExtractImage, &pExtract));
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            DWORD dwFlags = 0;
            SIZE rgThumbSize;
            pView->_GetThumbnailSize(&rgThumbSize);
            
            hr = pExtract->GetLocation(szPath, ARRAYSIZE(szPath), NULL, &rgThumbSize, pView->_dwRecClrDepth, &dwFlags);
            pExtract->Release();
            if (dwFlags & (IEIFLAG_CACHE | IEIFLAG_REFRESH))
            {
                _fCaptureAvail = TRUE;
                break;
            }
        }
        else
        {
            // blank it out so we don't bother trying it if the user choses the command
            _apidl[i] = NULL;
        }
    }

    HRESULT hr = pView->_pshf->GetUIObjectOf(pView->_hwndMain, cidl, apidl, 
        IID_PPV_ARG_NULL(IContextMenu, & _pMenu));
    if (SUCCEEDED(hr))
    {
        _pMenu->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pMenu2));
    }
    
    return hr;
}

STDMETHODIMP CThumbnailMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                              UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    ASSERT(_pMenu != NULL);
    
    // generate the proper menu 
    HRESULT hr = _pMenu->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    if (SUCCEEDED(hr) && _fCaptureAvail)
    {
        // find the first separator and insert the menu text after it....
        int cMenuSize = GetMenuItemCount(hmenu);
        for (int iIndex = 0; iIndex < cMenuSize; iIndex ++)
        {
            WCHAR szText[80];
            MENUITEMINFOW mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE;
            mii.fType = 0;
            mii.dwTypeData = szText;
            mii.cch = 80;

            GetMenuItemInfo(hmenu, iIndex, TRUE, &mii);
            if (mii.fType & MFT_SEPARATOR)
            {
                szText[0] = 0;
                LoadString(HINST_THISDLL, IDS_CREATETHUMBNAIL, szText, 80);
                
                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwTypeData = szText;
                mii.cch = 0;

                // assuming 0 is the first id, therefore the next one = the count they returned
                _wID = HRESULT_CODE(hr);
                mii.wID = idCmdFirst + _wID;

                InsertMenuItem(hmenu, iIndex, TRUE, & mii);

                // we used an extra ID.
                hr ++;
                
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CThumbnailMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(_pMenu != NULL);

    if (pici->lpVerb != IntToPtr_(LPCSTR, _wID))
    {
        hr = _pMenu->InvokeCommand(pici);
    }
    else
    {
        // capture thumbnails .....
        for (UINT i = 0; i < _cidl; i++)
        {
            if (_apidl[i])
            {
                UINT uiImage;
                _pView->ExtractItem(&uiImage, -1, _apidl[i], TRUE, TRUE, PRIORITY_P5);
            }
        }
    }
    return hr;    
}


STDMETHODIMP CThumbnailMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    if (cchMax)
        pszName[0] = 0;

    if (!IS_INTRESOURCE(idCmd))
    {
        // it is really a text verb ...
        LPSTR pszCommand = (LPSTR) idCmd;
        if (lstrcmpA(pszCommand, "CaptureThumbnail") == 0)
        {
            return S_OK;
        }
    }
    else
    {
        if (idCmd == _wID)
        {
            // it is ours ...
            switch(uType)
            {
            case GCS_VERB:
                StrCpyN((LPWSTR) pszName, TEXT("CaptureThumbnail"), cchMax);
                break;
                
            case GCS_HELPTEXT:
                LoadString(HINST_THISDLL, IDS_CREATETHUMBNAILHELP, (LPWSTR) pszName, cchMax);
                break;
                
            case GCS_VALIDATE:
                break;

            default:
                return E_INVALIDARG;
            }

            return S_OK;
        }
    }
    return _pMenu->GetCommandString(idCmd, uType, pwRes, pszName, cchMax);
}

STDMETHODIMP CThumbnailMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRes)
{
    HRESULT hr = E_NOTIMPL;

    if (uMsg == WM_MENUCHAR)
    {
        hr = SHForwardContextMenuMsg(_pMenu2, uMsg, wParam, lParam, plRes, FALSE);
    }
    else
    {
        hr = HandleMenuMsg(uMsg, wParam, lParam);

        if (plRes)
            *plRes = 0;
    }

    return hr;
}

STDMETHODIMP CThumbnailMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (_pMenu2 == NULL)
    {
        return E_NOTIMPL;
    }
    
    switch (uMsg)
    {
    case WM_DRAWITEM:
        {
            DRAWITEMSTRUCT * pdi = (DRAWITEMSTRUCT *)lParam;
            
            if (pdi->CtlType == ODT_MENU && pdi->itemID == _wID) 
            {
                return E_NOTIMPL;
            }
        }
        break;
        
    case WM_MEASUREITEM:
        {
            MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
            
            if (pmi->CtlType == ODT_MENU && pmi->itemID == _wID) 
            {
                return E_NOTIMPL;
            }
        }
        break;
    }
    return _pMenu2->HandleMenuMsg(uMsg, wParam, lParam);
}

HRESULT CThumbnailMenu::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_pMenu, punkSite);
    return S_OK;
}

HRESULT CThumbnailMenu::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_pMenu, riid, ppvSite);
}


//
// To be called back from within CDefFolderMenu
//
// Returns:
//      S_OK, if successfully processed.
//      (S_FALSE), if default code should be used.
//
HRESULT CALLBACK DefView_DFMCallBackBG(IShellFolder *psf, HWND hwndOwner,
        IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;

    switch(uMsg) 
    {
    case DFM_VALIDATECMD:
    case DFM_INVOKECOMMAND:
        hr = S_FALSE;
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


// Create defview's POPUP_SFV_BACKGROUND menu
HRESULT CDefView::_Create_BackgrndHMENU(BOOL fViewMenuOnly, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    HMENU hmContext = SHLoadPopupMenu(HINST_THISDLL, POPUP_SFV_BACKGROUND);
    if (hmContext)
    {
        // HACK: we are only initializing the Paste command, so we don't
        // need any attributes
        Def_InitEditCommands(0, hmContext, SFVIDM_FIRST, _pdtgtBack,
            DIEC_BACKGROUNDCONTEXT);

        InitViewMenu(hmContext);

        // Do a whole lot of desktop-only stuff for the actual desktop
        if (_IsDesktop() && IsDesktopBrowser(_psb))
        {
            // We only want LargeIcons on the real desktop
            // so we remove the View menu
            DeleteMenu(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND);

            // No Choose Columns either
            DeleteMenu(hmContext, SFVIDM_VIEW_COLSETTINGS, MF_BYCOMMAND);

            // Only put on ActiveDesktop menu item if it isn't restricted.
            if (SHRestricted(REST_FORCEACTIVEDESKTOPON) ||
                (!PolicyNoActiveDesktop() &&
                 !SHRestricted(REST_CLASSICSHELL) &&
                 !SHRestricted(REST_NOACTIVEDESKTOPCHANGES)))
            {
                HMENU hmenuAD;

                // Load the menu and make the appropriate modifications
                if (hmenuAD = SHLoadMenuPopup(HINST_THISDLL, POPUP_SFV_BACKGROUND_AD))
                {
                    MENUITEMINFO mii = {0};

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_SUBMENU;

                    if (GetMenuItemInfo(hmContext, SFVIDM_MENU_ARRANGE, FALSE, &mii))
                    {
                        // Get the present settings regarding HTML on desktop
                        SHELLSTATE ss;
                        SHGetSetSettings(&ss, SSF_DESKTOPHTML | SSF_HIDEICONS, FALSE);

                        if (!ss.fHideIcons)
                            CheckMenuItem(hmenuAD, SFVIDM_DESKTOPHTML_ICONS, MF_BYCOMMAND | MF_CHECKED);
                        if (GetDesktopFlags() & COMPONENTS_LOCKED)
                            CheckMenuItem(hmenuAD, SFVIDM_DESKTOPHTML_LOCK, MF_BYCOMMAND | MF_CHECKED);

                        // Hide the desktop cleanup wizard item if we're not allowed to run it
                        // (user is guest or policy forbids it)
                        if (IsOS(OS_ANYSERVER) || IsUserAGuest() || SHRestricted(REST_NODESKTOPCLEANUP))
                        {
                            DeleteMenu(hmenuAD, SFVIDM_DESKTOPHTML_WIZARD, MF_BYCOMMAND);
                        }

                        Shell_MergeMenus(mii.hSubMenu, hmenuAD, (UINT)-1, 0, (UINT)-1, MM_ADDSEPARATOR);
                    }

                    DestroyMenu(hmenuAD);
                }
            }
        }

        if (fViewMenuOnly)
        {
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU;

            GetMenuItemInfo(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND, &mii);

            HMENU hmenuView = mii.hSubMenu;
            RemoveMenu(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND);

            DestroyMenu(hmContext);
            hmContext = hmenuView;
        }

        hr = Create_ContextMenuOnHMENU(hmContext, _hwndView, riid, ppv);
    }

    return hr;
}

// Create defview's actual background context menu, an array of:
//   defview's POPUP_SFV_BACKGROUND and
//   the IShellFolder's CreateViewObject(IID_IContextMenu)
//
HRESULT CDefView::_CBackgrndMenu_CreateInstance(REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    IContextMenu* pcmMenu;
    hr = _Create_BackgrndHMENU(FALSE, IID_PPV_ARG(IContextMenu, &pcmMenu));
    if (SUCCEEDED(hr))
    {
        IContextMenu* pcmView;
        if (SUCCEEDED(_pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcmView))))
        {
            IContextMenu* rgpcm[2] = {pcmMenu, pcmView};
            hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);

            pcmView->Release();
        }
        else
        {
            // Compat - RNAUI fails the CreateViewObject and they rely on simply having the default stuff...
            //
            hr = pcmMenu->QueryInterface(riid, ppv);
        }

        pcmMenu->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dvtasks.cpp ===
#include "shellprv.h"
#include <runtask.h>
#include "defviewp.h"
#include "dvtasks.h"
#include "ids.h"
#include "guids.h"
#include "prop.h"    // for SCID_Comment
#include "infotip.h"

// ACL stuff from public/internal/base/inc/seopaque.h
typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))


CDefviewEnumTask::CDefviewEnumTask(CDefView *pdsv)
   : CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pdsv(pdsv)
{
}

CDefviewEnumTask::~CDefviewEnumTask()
{
    ATOMICRELEASE(_peunk);
    DPA_FreeIDArray(_hdpaEnum); // accepts NULL
    if (_hdpaPending)
        DPA_DeleteAllPtrs(_hdpaPending);    // the pidl's are owned by defview/listview
}

HRESULT CDefviewEnumTask::FillObjectsToDPA(BOOL fInteractive)
{
    DWORD dwTimeout, dwTime = GetTickCount();

    if (_pdsv->_IsDesktop())
        dwTimeout = 30000;          // 30 seconds
    else if (_pdsv->_fs.fFlags & FWF_BESTFITWINDOW)
        dwTimeout = 3000;           // 3 seconds
    else
        dwTimeout = 500;            // 1/2 sec

    // Make sure _GetEnumFlags calculates the correct bits
    _pdsv->_UpdateEnumerationFlags();

    HRESULT hr = _pdsv->_pshf->EnumObjects(fInteractive ? _pdsv->_hwndMain : NULL, _pdsv->_GetEnumFlags(), &_peunk);
    if (S_OK == hr)
    {
        IUnknown_SetSite(_peunk, SAFECAST(_pdsv, IOleCommandTarget *));      // give enum a ref to defview

        _hdpaEnum = DPA_Create(16);
        if (_hdpaEnum)
        {
            // let callback force background enum
            //
            // NOTE: If it is desktop, avoid the Background enumeration. Otherwise, it results in
            // a lot of flickering when ActiveDesktop is ON. Bug #394940. Fixed by: Sankar.
            if ((!_pdsv->_fAllowSearchingWindow && !_pdsv->_IsDesktop()) || S_OK == _pdsv->CallCB(SFVM_BACKGROUNDENUM, 0, 0) || ((GetTickCount() - dwTime) > dwTimeout))
            {
                _fBackground = TRUE;
            }
            else
            {
                LPITEMIDLIST pidl;
                ULONG celt;
                while (S_OK == _peunk->Next(1, &pidl, &celt))
                {
                    ASSERT(1==celt);
                    if (DPA_AppendPtr(_hdpaEnum, pidl) == -1)
                        SHFree(pidl);

                    // Are we taking too long?
                    if (((GetTickCount() - dwTime) > dwTimeout))
                    {
                        _fBackground = TRUE;
                        break;
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        IUnknown_SetSite(_peunk, NULL);      // Break the site back pointer.
    }

    _hrRet = hr;

    // Let the callback have a chance to "sniff" the items we just enumerated
    _pdsv->CallCB(SFVM_ENUMERATEDITEMS, (WPARAM)DPACount(), (LPARAM)DPAArray());

    return hr;
}

HRESULT CDefviewEnumTask::FillObjectsDPAToDone()
{
    HRESULT hr = S_OK;

    if (_fBackground)
    {
        ASSERT(S_OK == _hrRet);
        ASSERT(_peunk);

        // let defview do it's background thing
        _pdsv->_OnStartBackgroundEnum();

        // put ourself on the background scheduler
        hr = _pdsv->_AddTask(this, TOID_DVBackgroundEnum, 0, TASK_PRIORITY_BKGRND_FILL, ADDTASK_ATEND);
        if (FAILED(hr))
        {
            // we can't do background, pretend we're done
            hr = _pdsv->_OnStopBackgroundEnum();
        }
    }

    if (!_fBackground)
    {
        _pdsv->FillDone();
    }

    return hr;
}

HRESULT CDefviewEnumTask::FillObjectsDoneToView()
{
    if (SUCCEEDED(_hrRet))
    {
        HDPA hdpaView = NULL;
        int cItems = ListView_GetItemCount(_pdsv->_hwndListview);
        if (cItems)
        {
            hdpaView = DPA_Create(16);
            if (hdpaView)
            {
                for (int i = 0; i < cItems; i++)
                {
                    LPCITEMIDLIST pidl = _pdsv->_GetPIDL(i);
                    ASSERT(IsValidPIDL(pidl));
                    if (pidl)
                    {
                        DPA_AppendPtr(hdpaView, (void *)pidl);
                    }
                }
            }
        }

        // We only need to sort _hdpaView and _hdpaEnum if they both exist
        if (hdpaView && _hdpaEnum)
        {
            _SortForFilter(hdpaView);
            if (!_fEnumSorted)
                _SortForFilter(_hdpaEnum);
        }

        _FilterDPAs(_hdpaEnum, hdpaView);

        DPA_Destroy(hdpaView);
    }

    return _hrRet;
}

// 99/05/13 vtan: Only use CDefView::_CompareExact if you know that
// IShellFolder2 is implemented. SHCIDS_ALLFIELDS is IShellFolder2
// specific. Use CDefView::_GetCanonicalCompareFunction() to get the function
// to pass to DPA_Sort() if you don't want to make this determination.

// p1 and p2 are pointers to the lv_item's LPARAM, which is currently the pidl
int CALLBACK CDefviewEnumTask::_CompareExactCanonical(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = (CDefView *)lParam;
    return pdv->_CompareIDsDirection(0 | SHCIDS_ALLFIELDS | SHCIDS_CANONICALONLY, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
}


PFNDPACOMPARE CDefviewEnumTask::_GetCanonicalCompareFunction(void)
{
    if (_pdsv->_pshf2)
        return _CompareExactCanonical;
    else
        return &(CDefView::_Compare);

}

LPARAM CDefviewEnumTask::_GetCanonicalCompareBits()
{
    if (_pdsv->_pshf2)
        return 0 | SHCIDS_ALLFIELDS | SHCIDS_CANONICALONLY;
    else
        return 0;
}

void CDefviewEnumTask::_SortForFilter(HDPA hdpa)
{
    DPA_Sort(hdpa, _GetCanonicalCompareFunction(), (LPARAM)_pdsv);
}

//  We refreshed the view.  Take the old pidls and new pidls and compare
//  them, doing a _AddObject for all the new pidls, _RemoveObject
//  for the deleted pidls, and _UpdateObject for the inplace modifies.
void CDefviewEnumTask::_FilterDPAs(HDPA hdpaNew, HDPA hdpaOld)
{
    LPARAM lParamSort = _GetCanonicalCompareBits();

    for (;;)
    {
        LPITEMIDLIST pidlNew, pidlOld;

        int iCompare;
        int cOld = hdpaOld ? DPA_GetPtrCount(hdpaOld) : 0;
        int cNew = hdpaNew ? DPA_GetPtrCount(hdpaNew) : 0;

        if (!cOld && !cNew)
            break;

        if (!cOld)
        {
            // only new ones left.  Insert all of them.
            iCompare = -1;
            pidlNew = (LPITEMIDLIST)DPA_FastGetPtr(hdpaNew, 0);
        }
        else if (!cNew)
        {
            // only old ones left.  remove them all.
            iCompare = 1;
            pidlOld = (LPITEMIDLIST)DPA_FastGetPtr(hdpaOld, 0);
        }
        else
        {
            pidlOld = (LPITEMIDLIST)DPA_FastGetPtr(hdpaOld, 0);
            pidlNew = (LPITEMIDLIST)DPA_FastGetPtr(hdpaNew, 0);

            iCompare = _pdsv->_CompareIDsDirection(lParamSort, pidlNew, pidlOld);
        }

        if (iCompare == 0)
        {
            // they're the same, remove one of each.
            ILFree(pidlNew);
            DPA_DeletePtr(hdpaNew, 0);
            DPA_DeletePtr(hdpaOld, 0);
        }
        else
        {
            // Not identical.  See if it's just a modify.
            if (cOld && cNew && (lParamSort&SHCIDS_ALLFIELDS))
            {
                iCompare = _pdsv->_CompareIDsDirection((lParamSort&~SHCIDS_ALLFIELDS), pidlNew, pidlOld);
            }
            if (iCompare == 0)
            {
                _pdsv->_UpdateObject(pidlOld, pidlNew);
                ILFree(pidlNew);
                DPA_DeletePtr(hdpaNew, 0);
                DPA_DeletePtr(hdpaOld, 0);
            }
            else if (iCompare < 0) // we have a new item!
            {
                _pdsv->_AddObject(pidlNew);  // takes over pidl ownership.
                DPA_DeletePtr(hdpaNew, 0);
            }
            else // there's an old item in the view!
            {
                if (!_DeleteFromPending(pidlOld))
                    _pdsv->_RemoveObject(pidlOld, TRUE);
                DPA_DeletePtr(hdpaOld, 0);
            }
        }
    }
}

BOOL CDefviewEnumTask::_DeleteFromPending(LPCITEMIDLIST pidl)
{
    if (_hdpaPending)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpaPending); i++)
        {
            LPCITEMIDLIST pidlPending = (LPCITEMIDLIST) DPA_FastGetPtr(_hdpaPending, i);

            if (S_OK == _pdsv->_CompareIDsFallback(0, pidl, pidlPending))
            {
                //  remove this from the pending list
                DPA_DeletePtr(_hdpaPending, i);    // the pidl is owned by defview/listview
                return TRUE;
            }
        }
    }
    return FALSE;
}

void CDefviewEnumTask::_AddToPending(LPCITEMIDLIST pidl)
{
    if (!_hdpaPending)
        _hdpaPending = DPA_Create(16);

    if (_hdpaPending)
        DPA_AppendPtr(_hdpaPending, (void *)pidl);
}



STDMETHODIMP CDefviewEnumTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CDefviewEnumTask::InternalResumeRT()
{
    ULONG celt;
    LPITEMIDLIST pidl;

    IUnknown_SetSite(_peunk, SAFECAST(_pdsv, IOleCommandTarget *));      // give enum a ref to defview
    while (S_OK == _peunk->Next(1, &pidl, &celt))
    {
        if (DPA_AppendPtr(_hdpaEnum, pidl) == -1)
        {
            SHFree(pidl);
        }

        // we were told to either suspend or quit...
        if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    IUnknown_SetSite(_peunk, NULL);      // Break the site back pointer.

    // Sort on this thread so we do not hang the main thread for as long
    DPA_Sort(_hdpaEnum, _GetCanonicalCompareFunction(), (LPARAM)_pdsv);
    _fEnumSorted = TRUE;

    // notify DefView (async) that we're done
    PostMessage(_pdsv->_hwndView, WM_DSV_BACKGROUNDENUMDONE, 0, (LPARAM)this);
    return S_OK;
}




class CExtendedColumnTask : public CRunnableTask
{
public:
    CExtendedColumnTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn);
    STDMETHODIMP RunInitRT(void);

private:
    ~CExtendedColumnTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    const int _fmt;
    const UINT _uiCol;
    const UINT _uId;
};


CExtendedColumnTask::CExtendedColumnTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn)
    : CRunnableTask(RTF_DEFAULT), _pdsv(pdsv), _fmt(fmt), _uiCol(uiColumn), _uId(uId)
{
    *phr = SHILClone(pidl, &_pidl);
}

CExtendedColumnTask::~CExtendedColumnTask()
{
    ILFree(_pidl);
}

STDMETHODIMP CExtendedColumnTask::RunInitRT(void)
{
    DETAILSINFO di;

    di.pidl = _pidl;
    di.fmt = _fmt;

    if (SUCCEEDED(_pdsv->_GetDetailsHelper(_uiCol, &di)))
    {
        CBackgroundColInfo *pbgci = new CBackgroundColInfo(_pidl, _uId, _uiCol, di.str);
        if (pbgci)
        {
            _pidl = NULL;        // give up ownership of this, ILFree checks for null

            if (!PostMessage(_pdsv->_hwndView, WM_DSV_UPDATECOLDATA, 0, (LPARAM)pbgci))
                delete pbgci;
        }
    }
    return S_OK;
}

HRESULT CExtendedColumnTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn, IRunnableTask **ppTask)
{
    HRESULT hr;
    CExtendedColumnTask *pECTask = new CExtendedColumnTask(&hr, pdsv, pidl, uId, fmt, uiColumn);
    if (pECTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pECTask, IRunnableTask*);
        else
            pECTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

class CIconOverlayTask : public CRunnableTask
{
public:
    CIconOverlayTask(HRESULT *phr, LPCITEMIDLIST pidl, int iList, CDefView *pdsv);

    STDMETHODIMP RunInitRT(void);

private:
    ~CIconOverlayTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    int _iList;
};


CIconOverlayTask::CIconOverlayTask(HRESULT *phr, LPCITEMIDLIST pidl, int iList,  CDefView *pdsv)
    : CRunnableTask(RTF_DEFAULT), _iList(iList), _pdsv(pdsv)
{
    *phr = SHILClone(pidl, &_pidl);
}

CIconOverlayTask::~CIconOverlayTask()
{
    ILFree(_pidl);
}

STDMETHODIMP CIconOverlayTask::RunInitRT()
{
    int iOverlay = 0;

    // get the overlay index for this item.
    _pdsv->_psio->GetOverlayIndex(_pidl, &iOverlay);

    if (iOverlay > 0)
    {
        // now post the result back to the main thread
        PostMessage(_pdsv->_hwndView, WM_DSV_UPDATEOVERLAY, (WPARAM)_iList, (LPARAM)iOverlay);
    }

    return S_OK;
}

HRESULT CIconOverlayTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, int iList, IRunnableTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CIconOverlayTask * pNewTask = new CIconOverlayTask(&hr, pidl, iList, pdsv);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CStatusBarAndInfoTipTask::CStatusBarAndInfoTipTask(HRESULT *phr, 
                                 LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl,
                                 UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit,
                                 HWND hwnd, IShellTaskScheduler2* pScheduler)
    : CRunnableTask(RTF_DEFAULT), _uMsg(uMsg), _nMsgParam(nMsgParam), _pbit(pbit), _hwnd(hwnd), _pScheduler(pScheduler)
{
    // If we have a pidl, then the number of objects selected must be 1
    // This assert applies to the status bar text, but not to the InfoTip text
    ASSERT(pbit || !pidl || nMsgParam == 1);
    *phr = pidl ? SHILClone(pidl, &_pidl) : S_OK;

    if (SUCCEEDED(*phr))
    {
        *phr = SHILClone(pidlFolder, &_pidlFolder); 
        if (FAILED(*phr))
        {
            ILFree(_pidl);
        }
    }

    if (_pbit)
        _pbit->AddRef();
}

CStatusBarAndInfoTipTask::~CStatusBarAndInfoTipTask()
{
    ILFree(_pidl);
    ILFree(_pidlFolder);
    ATOMICRELEASE(_pbit);
}

HRESULT CleanTipForSingleLine(LPWSTR pwszTip)
{
    HRESULT hr = E_FAIL;    // NULL string, same as failure
    if (pwszTip)
    {
        // Infotips often contain \t\r\n characters, so
        // map control characters to spaces.  Also collapse
        // consecutive spaces to make us look less badf.
        LPWSTR pwszDst, pwszSrc;

        // Since we are unicode, we don't have to worry about DBCS.
        for (pwszDst = pwszSrc = pwszTip; *pwszSrc; pwszSrc++)
        {
            if ((UINT)*pwszSrc <= (UINT)L' ')
            {
                if (pwszDst == pwszTip || pwszDst[-1] != L' ')
                {
                    *pwszDst++ = L' ';
                }
            }
            else
            {
                *pwszDst++ = *pwszSrc;
            }
        }
        *pwszDst = 0;
        // GetInfoTip can return a Null String too.
        if (*pwszTip)
            hr = S_OK;
        else
            SHFree(pwszTip);
    }
    return hr;
}

STDMETHODIMP CStatusBarAndInfoTipTask::RunInitRT()
{
    LPWSTR pwszTip = NULL;
    HRESULT hr;
    if (_pidl)
    {
        IShellFolder* psf;
        hr = SHBindToObjectEx(NULL, _pidlFolder, NULL, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            IQueryInfo *pqi;
            hr = psf->GetUIObjectOf(_hwnd, 1, (LPCITEMIDLIST*)&_pidl, IID_X_PPV_ARG(IQueryInfo, 0, &pqi));
            IShellFolder2* psf2;
            if (FAILED(hr) && SUCCEEDED(hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                hr = CreateInfoTipFromItem(psf2, _pidl, TEXT("prop:Comment"), IID_PPV_ARG(IQueryInfo, &pqi));
                psf2->Release();
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwFlags = _pbit ? QITIPF_USESLOWTIP : 0;

                if (_pbit && _pbit->_lvSetInfoTip.pszText[0])
                {
                    ICustomizeInfoTip *pcit;
                    if (SUCCEEDED(pqi->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
                    {
                        pcit->SetPrefixText(_pbit->_lvSetInfoTip.pszText);
                        pcit->Release();
                    }
                }

                hr = pqi->GetInfoTip(dwFlags, &pwszTip);

                // Prepare for status bar if we have not requested the InfoTip
                if (SUCCEEDED(hr) && !_pbit)
                    hr = CleanTipForSingleLine(pwszTip);
                pqi->Release();
            }

            psf->Release();
        }

        if (FAILED(hr))
        {
            pwszTip = NULL;
            _uMsg = IDS_FSSTATUSSELECTED;
        }
    }

    if (_pbit)
    {
        // regular info tip case
        CoTaskMemFree(_pbit->_lvSetInfoTip.pszText);
        _pbit->_lvSetInfoTip.pszText = pwszTip;

        _pbit->_fReady = TRUE;
        if (_pScheduler->CountTasks(TOID_DVBackgroundInfoTip) == 1)
            PostMessage(_hwnd, WM_DSV_DELAYINFOTIP, (WPARAM)_pbit, 0);
    }
    else
    {
        // status bar case
        // Now prepare the text and post it to the view which will set the status bar text
        LPWSTR pszStatus = pwszTip;
        if (pwszTip)
        {
            pszStatus = StrDupW(pwszTip);
            SHFree(pwszTip);
        }
        else
        {
            WCHAR szTemp[30];
            pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(_uMsg),
                             AddCommas(_nMsgParam, szTemp, ARRAYSIZE(szTemp)));
        }

        if (pszStatus && _pScheduler->CountTasks(TOID_DVBackgroundStatusBar) != 1 ||
            !PostMessage(_hwnd, WM_DSV_DELAYSTATUSBARUPDATE, 0, (LPARAM)pszStatus))
        {
            LocalFree((void *)pszStatus);
        }
    }

    return S_OK;
}

HRESULT CStatusBarAndInfoTipTask_CreateInstance(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl,
                                                  UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, 
                                                  HWND hwnd, IShellTaskScheduler2* pScheduler,
                                                  CStatusBarAndInfoTipTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CStatusBarAndInfoTipTask * pNewTask = new CStatusBarAndInfoTipTask(&hr, pidlFolder, pidl, uMsg, nMsgParam, pbit, hwnd, pScheduler);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = pNewTask;
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CDUIInfotipTask_CreateInstance(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl, CDUIInfotipTask **ppTask)
{
    HRESULT hr;

    CDUIInfotipTask* pTask = new CDUIInfotipTask();
    if (pTask)
    {
        hr = pTask->Initialize(pDefView, hwndContaining, uToolID, pidl);
        if (SUCCEEDED(hr))
            *ppTask = pTask;
        else
            pTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

CDUIInfotipTask::~CDUIInfotipTask()
{
    if (_pDefView)
        _pDefView->Release();

    if (_pidl)
        ILFree(_pidl);
}

HRESULT CDUIInfotipTask::Initialize(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl)
{
    HRESULT hr;

    if (pDefView && hwndContaining && pidl)
    {
        ASSERT(!_pDefView && !_hwndContaining && !_uToolID && !_pidl);

        _hwndContaining = hwndContaining;   // DUI task's containing hwnd
        _uToolID = uToolID;                 // DUI task's identifier
        hr = SHILClone(pidl, &_pidl);       // DUI task's destination pidl

        if (SUCCEEDED(hr))
        {
            _pDefView = pDefView;
            pDefView->AddRef();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDUIInfotipTask::RunInitRT()
{
    HRESULT hr;

    ASSERT(_pDefView);
    ASSERT(_hwndContaining);
    ASSERT(_pidl);

    // Retrieve an IQueryInfo for the _pidl.
    IQueryInfo *pqi;
    hr = SHGetUIObjectFromFullPIDL(_pidl, _hwndContaining, IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        // Retrieve infotip text from IQueryInfo.
        LPWSTR pwszInfotip;
        hr = pqi->GetInfoTip(QITIPF_USESLOWTIP, &pwszInfotip);
        if (SUCCEEDED(hr))
        {
            // Create infotip.
            hr = _pDefView->PostCreateInfotip(_hwndContaining, _uToolID, pwszInfotip, 0);
            CoTaskMemFree(pwszInfotip);
        }

        pqi->Release();
    }

    return hr;
}

STDMETHODIMP CTestCacheTask::RunInitRT()
{
    HRESULT hr = E_FAIL;

    if (!_fForce)
    {
        // make sure the disk cache is open for reading.
        DWORD dwLock = 0;
        hr = _pView->_pDiskCache ? _pView->_pDiskCache->Open(STGM_READ, &dwLock) : E_FAIL;
        if (SUCCEEDED(hr))
        {
            // start the timer, once every two seconds....
            SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);

            // is it in the cache....
            FILETIME ftCacheTimeStamp;
            hr = _pView->_pDiskCache->IsEntryInStore(_szPath, &ftCacheTimeStamp);

            // if it is in the cache, and it is an uptodate image, then fetch from disk....
            // if the timestamps are wrong, then the extract code further down will then try
            // and write its image back to the cache to update it anyway.....
            if ((hr == S_OK) &&
                ((0 == CompareFileTime(&ftCacheTimeStamp, &_ftDateStamp)) || IsNullTime(&_ftDateStamp)))
            {
                DWORD dwPriority = _dwPriority - PRIORITY_DELTA_DISKCACHE;

                if ((!_pView->_fDestroying) &&
                    (S_OK != _pView->_pScheduler->MoveTask(TOID_DiskCacheTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT)))
                {
                    // try it in the background...
                    IRunnableTask *pTask;
                    hr = CDiskCacheTask_Create(_dwTaskID, _pView, dwPriority, _iItem, _pidl, _szPath, _ftDateStamp, _pExtract, _dwFlags, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        // add the task to the scheduler...
                        TraceMsg(TF_DEFVIEW, "CTestCacheTask *ADDING* CDiskCacheTask (path=%s, priority=%x)", _szPath, dwPriority);
                        hr = _pView->_pScheduler->AddTask2(pTask, TOID_DiskCacheTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                        if (SUCCEEDED(hr))
                            hr = S_FALSE;
                        pTask->Release();
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "CTestCacheTask *MISS* (hr:%x)", hr);
                hr = E_FAIL;
            }
            _pView->_pDiskCache->ReleaseLock(&dwLock);
        }
        else
        {
           TraceMsg(TF_DEFVIEW, "CTestCacheTask *WARNING* Could not open thumbnail cache");
        }
    }
    if (FAILED(hr))
    {
        // Extract It....
        
        // does it not support Async, or were we told to run it forground ?
        if (!_fAsync || !_fBackground)
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
            {
                if (!_fBackground)
                {
                    // make sure there is no extract task already underway as we
                    // are not adding this to the queue...
                    _pView->_pScheduler->RemoveTasks(TOID_ExtractImageTask, _dwTaskID, TRUE);
                }
                hr = pTask->Run();

                pTask->Release();
            }
        }
        else
        {
            DWORD dwPriority = _dwPriority - PRIORITY_DELTA_EXTRACT;
            if (S_OK != _pView->_pScheduler->MoveTask(TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT))
            {
                IRunnableTask *pTask;
                if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
                {
                    // add the task to the scheduler...
                    TraceMsg(TF_DEFVIEW, "CTestCacheTask *ADDING* CExtractImageTask (path=%s, priority=%x)", _szPath, dwPriority);
                    hr = _pView->_pScheduler->AddTask2(pTask, TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                    pTask->Release();
                }
            }
            
            // signify we want a default icon for now....
            hr = S_FALSE;
        }
    }
    return hr;
}

CTestCacheTask::CTestCacheTask(DWORD dwTaskID, CDefView* pView, IExtractImage *pExtract,
                               LPCWSTR pszPath, FILETIME ftDateStamp,
                               int iItem, DWORD dwFlags, DWORD dwPriority,
                               BOOL fAsync, BOOL fBackground, BOOL fForce) :
    CRunnableTask(RTF_DEFAULT), _iItem(iItem), _dwTaskID(dwTaskID), _dwFlags(dwFlags), _dwPriority(dwPriority),
    _fAsync(fAsync), _fBackground(fBackground), _fForce(fForce), _pExtract(pExtract), _pView(pView), _ftDateStamp(ftDateStamp)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));

    _pExtract->AddRef();
}

CTestCacheTask::~CTestCacheTask()
{
    ILFree(_pidl);

    _pExtract->Release();
}

HRESULT CTestCacheTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

HRESULT CTestCacheTask_Create(DWORD dwTaskID, CDefView* pView, IExtractImage *pExtract,
                               LPCWSTR pszPath, FILETIME ftDateStamp, LPCITEMIDLIST pidl,
                               int iItem, DWORD dwFlags, DWORD dwPriority,
                               BOOL fAsync, BOOL fBackground, BOOL fForce,
                               CTestCacheTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CTestCacheTask * pNew = new CTestCacheTask(dwTaskID, pView, pExtract,
                               pszPath, ftDateStamp, iItem, dwFlags, dwPriority,
                               fAsync, fBackground, fForce);
    if (pNew)
    {
        hr = pNew->Init(pidl);
        if (SUCCEEDED(hr))
        {
            *ppTask = pNew;
            hr = S_OK;
        }
        else
            pNew->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

class CDiskCacheTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT(void);

    CDiskCacheTask(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags);
    HRESULT Init(LPCITEMIDLIST pidl);

private:
    ~CDiskCacheTask();

    int _iItem;
    LPITEMIDLIST _pidl;
    CDefView* _pView;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    DWORD _dwTaskID;
    DWORD _dwPriority;
    IExtractImage *_pExtract;
    DWORD _dwFlags;
};


CDiskCacheTask::CDiskCacheTask(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags)
    : CRunnableTask(RTF_DEFAULT), _pView(pView), _dwTaskID(dwTaskID), _dwPriority(dwPriority), _iItem(iItem), _ftDateStamp(ftDateStamp),
      _pExtract(pExtract), _dwFlags(dwFlags)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
    _pExtract->AddRef();
}

CDiskCacheTask::~CDiskCacheTask()
{
    ILFree(_pidl);
    _pExtract->Release();
}

HRESULT CDiskCacheTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CDiskCacheTask::RunInitRT()
{
    DWORD dwLock;

    HRESULT hr = E_FAIL;

    if (_dwFlags & IEIFLAG_CACHE)
    {
        hr = _pView->_pDiskCache->Open(STGM_READ, &dwLock);
        if (SUCCEEDED(hr))
        {
            HBITMAP hBmp;
            hr = _pView->_pDiskCache->GetEntry(_szPath, STGM_READ, &hBmp);
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_DEFVIEW, "CDiskCacheTask *CACHE* (path=%s, priority=%x)", _szPath, _dwPriority);
                hr = _pView->UpdateImageForItem(_dwTaskID, hBmp, _iItem, _pidl, _szPath, _ftDateStamp, FALSE, _dwPriority);
                if (hr != S_FALSE)
                    DeleteObject(hBmp);
            }
            // set the tick count so we know when we last accessed the disk cache
            SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);
            _pView->_pDiskCache->ReleaseLock(&dwLock);
        }
    }

    if (FAILED(hr)) // We couldn't pull it out of the disk cache, try an extract
    {
        DWORD dwPriority = _dwPriority - PRIORITY_DELTA_EXTRACT;
        if (S_OK != _pView->_pScheduler->MoveTask(TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT))
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
            {
                // add the task to the scheduler...
                TraceMsg(TF_DEFVIEW, "CDiskCacheTask *ADDING* CExtractImageTask (path=%s, priority=%x)", _szPath, dwPriority);
                hr = _pView->_pScheduler->AddTask2(pTask, TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                pTask->Release();
            }
        }
    }
    return hr;
}

HRESULT CDiskCacheTask_Create(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCITEMIDLIST pidl,
                              LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags, IRunnableTask **ppTask)
{
    HRESULT hr;
    CDiskCacheTask *pTask = new CDiskCacheTask(dwTaskID, pView, dwPriority, iItem, pszPath, ftDateStamp, pExtract, dwFlags);
    if (pTask)
    {
        hr = pTask->Init(pidl);
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}


class CWriteCacheTask : public CRunnableTask
{
public:
    STDMETHOD (RunInitRT)();

    CWriteCacheTask(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp, HBITMAP hImage);

private:
    ~CWriteCacheTask();

    LONG _lState;
    CDefView* _pView;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    HBITMAP _hImage;
    DWORD _dwTaskID;
};

CWriteCacheTask::CWriteCacheTask(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp, HBITMAP hImage)
    : CRunnableTask(RTF_DEFAULT), _dwTaskID(dwTaskID), _hImage(hImage), _pView(pView), _ftDateStamp(ftDateStamp)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
}

CWriteCacheTask::~CWriteCacheTask()
{
    DeleteObject(_hImage);
}

HRESULT CWriteCacheTask_Create(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp,
                               HBITMAP hImage, IRunnableTask **ppTask)
{
    *ppTask = NULL;

    CWriteCacheTask * pNew = new CWriteCacheTask(dwTaskID, pView, pszPath, ftDateStamp, hImage);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}

STDMETHODIMP CWriteCacheTask::RunInitRT()
{
    DWORD dwLock;

    HRESULT hr = _pView->_pDiskCache->Open(STGM_WRITE, &dwLock);
    if (hr == STG_E_FILENOTFOUND)
    {
        hr = _pView->_pDiskCache->Create(STGM_WRITE, &dwLock);
    }

    if (SUCCEEDED(hr))
    {
        hr = _pView->_pDiskCache->AddEntry(_szPath, IsNullTime(&_ftDateStamp) ? NULL : &_ftDateStamp, STGM_WRITE, _hImage);
        // set the tick count so that when the timer goes off, we can know when we
        // last used it...
        SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);
        hr = _pView->_pDiskCache->ReleaseLock(&dwLock);
    }

    return hr;
}

class CReadAheadTask : public IRunnableTask
{
public:
    CReadAheadTask(CDefView *pView);
    HRESULT Init();

    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)(void);

private:
    ~CReadAheadTask();
    HRESULT InternalResume();

    LONG _cRef;
    LONG _lState;
    CDefView *_pView;
    HANDLE _hEvent;

    ULONG _ulCntPerPage;
    ULONG _ulCntTotal;
    ULONG _ulCnt;
};

CReadAheadTask::~CReadAheadTask()
{
    if (_hEvent)
        CloseHandle(_hEvent);
}

CReadAheadTask::CReadAheadTask(CDefView *pView) : _cRef(1), _pView(pView)
{
    _ulCntPerPage = pView->_ApproxItemsPerView();
    _ulCntTotal = ListView_GetItemCount(pView->_hwndListview);
#ifndef DEBUG
    // Because we define a small cache in debug we need to only do this
    // in retail.  Otherwise we would not be able to debug readahead.
    _ulCntTotal = min(_ulCntTotal, (ULONG)pView->_iMaxCacheSize);
#endif
    _ulCnt = _ulCntPerPage;
}

HRESULT CReadAheadTask::Init()
{
    _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    return _hEvent ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CReadAheadTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CReadAheadTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CReadAheadTask::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CReadAheadTask::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CReadAheadTask_Create(CDefView *pView, IRunnableTask **ppTask)
{
    HRESULT hr;
    CReadAheadTask *pTask = new CReadAheadTask(pView);
    if (pTask)
    {
        hr = pTask->Init();
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CReadAheadTask::Run()
{
    if (_lState == IRTIR_TASK_RUNNING)
    {
        return S_FALSE;
    }

    if (_lState == IRTIR_TASK_PENDING)
    {
        // it is about to die, so fail
        return E_FAIL;
    }

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
    if (lRes == IRTIR_TASK_PENDING)
    {
        _lState = IRTIR_TASK_FINISHED;
        return S_OK;
    }

    // otherwise, run the task ....
    HRESULT hr = InternalResume();
    if (hr != E_PENDING)
        _lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP CReadAheadTask::Suspend()
{
    if (_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }

    // suspend ourselves
    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        _lState = lRes;
        return S_OK;
    }

    // if it is running, then there is an Event Handle, if we have passed where
    // we are using it, then we are close to finish, so it will ignore the suspend
    // request
    ASSERT(_hEvent);
    SetEvent(_hEvent);

    return S_OK;
}

STDMETHODIMP CReadAheadTask::Resume()
{
    if (_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }

    ResetEvent(_hEvent);
    _lState = IRTIR_TASK_RUNNING;

    HRESULT hr = InternalResume();
    if (hr != E_PENDING)
    {
        _lState= IRTIR_TASK_FINISHED;
    }
    return hr;
}

STDMETHODIMP CReadAheadTask::Kill(BOOL fWait)
{
    if (_lState == IRTIR_TASK_RUNNING)
    {
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
        if (lRes == IRTIR_TASK_FINISHED)
        {
            _lState = lRes;
        }
        else if (_hEvent)
        {
            // signal the event it is likely to be waiting on
            SetEvent(_hEvent);
        }

        return S_OK;
    }
    else if (_lState == IRTIR_TASK_PENDING || _lState == IRTIR_TASK_FINISHED)
    {
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP_(ULONG) CReadAheadTask::IsRunning()
{
    return _lState;
}

HRESULT CReadAheadTask::InternalResume()
{
    HRESULT hr = S_OK;

    // pfortier: this algorithm of determining which guys are off the page or not, seems kind of broken.
    // For example, grouping will screw it up.  Also, the Z-order of the items, is not necessarily
    // the same as the item order, and we're going by item order.
    // Also, _ulCnt is calculated before dui view is present, so the value is off.
    TraceMsg(TF_DEFVIEW, "ReadAhead: Start");

    for (; _ulCnt < _ulCntTotal; ++_ulCnt)
    {
        // See if we need to suspend
        if (WaitForSingleObject(_hEvent, 0) == WAIT_OBJECT_0)
        {
            // why were we signalled ...
            if (_lState == IRTIR_TASK_SUSPENDED)
            {
                hr = E_PENDING;
                break;
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }

        LV_ITEMW rgItem;
        rgItem.iItem = (int)_ulCnt;
        rgItem.mask = LVIF_IMAGE;
        rgItem.iSubItem = 0;

        TraceMsg(TF_DEFVIEW, "Thumbnail readahead for item %d", _ulCnt);
            
        // This will force the extraction of the image if necessary.  We will extract it at the right
        // priority, by determining if the item is visible during GetDisplayInfo.
        int iItem = ListView_GetItem(_pView->_hwndListview, &rgItem);
    }

    TraceMsg(TF_DEFVIEW, "ReadAhead: Done (hr:%x)", hr);

    return hr;
}

class CFileTypePropertiesTask : public CRunnableTask
{
public:
    CFileTypePropertiesTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId);
    STDMETHODIMP RunInitRT();
    STDMETHODIMP InternalResumeRT();

private:
    ~CFileTypePropertiesTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    UINT _uMaxPropertiesToShow;
    UINT _uId;
};

CFileTypePropertiesTask::CFileTypePropertiesTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId)
    : CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pdsv(pdsv), _uMaxPropertiesToShow(uMaxPropertiesToShow), _uId(uId)
{
    *phr = SHILClone(pidl, &_pidl);
}

CFileTypePropertiesTask::~CFileTypePropertiesTask()
{
    ILFree(_pidl);
}
STDMETHODIMP CFileTypePropertiesTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CFileTypePropertiesTask::InternalResumeRT(void)
{
    // If Columns are not loaded yet, this means this window is just starting up
    // so we want to give it some time to finish the startup (let it paint and such)
    // before we proceed here because the first call to GetImportantColumns will
    // causes all column handlers to be loaded, a slow process.
    if (!_pdsv->_bLoadedColumns)
    {
        if (WaitForSingleObject(_hDone, 750) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    UINT rgColumns[8];  // currently _uMaxPropertiesToShow is 2, this is big enough if that grows
    UINT cColumns = min(_uMaxPropertiesToShow, ARRAYSIZE(rgColumns));

    if (SUCCEEDED(_pdsv->_GetImportantColumns(_pidl, rgColumns, &cColumns)))
    {
        CBackgroundTileInfo *pbgTileInfo = new CBackgroundTileInfo(_pidl, _uId, rgColumns, cColumns);
        if (pbgTileInfo)
        {
            _pidl = NULL;        // give up ownership of this, ILFree checks for null

            if (!PostMessage(_pdsv->_hwndView, WM_DSV_SETIMPORTANTCOLUMNS, 0, (LPARAM)pbgTileInfo))
                delete pbgTileInfo;
        }
    }
        
    return S_OK;
}

HRESULT CFileTypePropertiesTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId, IRunnableTask **ppTask)
{
    HRESULT hr;
    CFileTypePropertiesTask *pFTPTask = new CFileTypePropertiesTask(&hr, pdsv, pidl, uMaxPropertiesToShow, uId);
    if (pFTPTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pFTPTask, IRunnableTask*);
        else
            pFTPTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}



class CExtractImageTask : public IRunnableTask
{
public:
    CExtractImageTask(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract,
                                 LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME ftNewDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority);
    HRESULT Init(LPCITEMIDLIST pidl);

    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)(void);

private:
    ~CExtractImageTask();
    HRESULT InternalResume();

    LONG _cRef;
    LONG _lState;
    IExtractImage *_pExtract;
#if 0
    IRunnableTask *_pTask;
#endif
    WCHAR _szPath[MAX_PATH];
    LPITEMIDLIST _pidl;
    CDefView* _pView;
    DWORD _dwMask;
    DWORD _dwFlags;
    int _iItem;
    HBITMAP _hBmp;
    FILETIME _ftDateStamp;
    DWORD _dwTaskID;
    DWORD _dwPriority;
};

CExtractImageTask::CExtractImageTask(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract, LPCWSTR pszPath,
                                     LPCITEMIDLIST pidl, FILETIME ftNewDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority)
    : _cRef(1), _lState(IRTIR_TASK_NOT_RUNNING), _dwTaskID(dwTaskID), _ftDateStamp(ftNewDateStamp), _dwFlags(dwFlags), _pExtract(pExtract), _pView(pView), _dwPriority(dwPriority)
{
    _pExtract->AddRef();

    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
    _iItem = iItem == -1 ? _pView->_FindItem(pidl, NULL, FALSE) : iItem;
    _dwMask = pView->_GetOverlayMask(pidl);
}

CExtractImageTask::~CExtractImageTask()
{
    _pExtract->Release();
#if 0
    if (_pTask)
        _pTask->Release();
#endif

    ILFree(_pidl);

    if (_hBmp)
        DeleteObject(_hBmp);
}

STDMETHODIMP CExtractImageTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CExtractImageTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExtractImageTask::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExtractImageTask::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CExtractImageTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

HRESULT CExtractImageTask_Create(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract,
                                 LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME ftNewDateStamp, int iItem, DWORD dwFlags,
                                 DWORD dwPriority, IRunnableTask **ppTask)
{
    HRESULT hr;
    CExtractImageTask *pTask = new CExtractImageTask(dwTaskID, pView, pExtract,
                                 pszPath, pidl, ftNewDateStamp, iItem, dwFlags, dwPriority);
    if (pTask)
    {
        hr = pTask->Init(pidl);
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CExtractImageTask::Run(void)
{
    HRESULT hr = E_FAIL;
    if (_lState == IRTIR_TASK_RUNNING)
    {
        hr = S_FALSE;
    }
    else if (_lState == IRTIR_TASK_PENDING)
    {
        hr = E_FAIL;
    }
    else if (_lState == IRTIR_TASK_NOT_RUNNING)
    {
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
        if (lRes == IRTIR_TASK_PENDING)
        {
            _lState = IRTIR_TASK_FINISHED;
            return S_OK;
        }

        // extractor may support IRunnableTask so they can support being
        // canceled in the middle of the extract call. CHtmlThumb & CImgCtxThumb
        // extractors use this. CImgCtxThumb has been replaced that with our GDI+ extractor
#if 0
        if (!_pTask)
        {
            _pExtract->QueryInterface(IID_PPV_ARG(IRunnableTask, &_pTask));
        }
#endif

        if (_lState == IRTIR_TASK_RUNNING)
        {
            TraceMsg(TF_DEFVIEW, "CExtractImageTask *START* (path=%s, priority=%x)", _szPath, _dwPriority);
            // start the extractor....
            // extractor can return S_FALSE and set _hBmp to NULL.  We will use _hBmp to recognize this situation
            ASSERT(_hBmp == NULL);
            if (FAILED(_pExtract->Extract(&_hBmp)))
            {
                _hBmp = NULL;
            }
        }

        if (_hBmp && _lState == IRTIR_TASK_RUNNING)
        {
            TraceMsg(TF_DEFVIEW, "CExtractImageTask *EXTRACT* (path=%s, priority=%x)", _szPath, _dwPriority);
            hr = InternalResume();
        }

        if (_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            _lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

STDMETHODIMP CExtractImageTask::Kill(BOOL fWait)
{
    // This is broken: by not setting the fSuspended flag on the task,
    // the scheduler doesn't know to call Resume back. Instead, it calls
    // Run. This causes the task to never finish.
#if 0
    if (_lState != IRTIR_TASK_RUNNING)
    {
        return S_FALSE;
    }

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        _lState = lRes;
        return S_OK;
    }

    // does it support IRunnableTask ? Can we kill it ?
    if (_pExtract)
    {
        IRunnableTask *pTask;
        if (SUCCEEDED(_pExtract->QueryInterface(IID_PPV_ARG(IRunnableTask, &pTask))))
        {
            pTask->Kill(FALSE);
            pTask->Release();
        }
    }
    return S_OK;
#else  // 0

    return E_NOTIMPL;

#endif // 0
}

STDMETHODIMP CExtractImageTask::Suspend(void)
{
    // This is broken: by not setting the fSuspended flag on the task,
    // the scheduler doesn't know to call Resume back. Instead, it calls
    // Run. This causes the task to never finish.
#if 0
    if (!_pTask)
        return E_NOTIMPL;

    if (_lState != IRTIR_TASK_RUNNING)
        return E_FAIL;

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);
    HRESULT hr = _pTask->Suspend();
    if (SUCCEEDED(hr))
    {
        lRes = (LONG) _pTask->IsRunning();
        if (lRes == IRTIR_TASK_SUSPENDED)
        {
            if (lRes != IRTIR_TASK_RUNNING)
            {
                _lState = lRes;
            }
        }
    }
    else
    {
        _lState = lRes;
    }

    return hr;
#else  // 0

    return E_NOTIMPL;

#endif // 0
}

STDMETHODIMP CExtractImageTask::Resume(void)
{
#if 0
    if (!_pTask)
        return E_NOTIMPL;

    if (_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }

    _lState = IRTIR_TASK_RUNNING;

    HRESULT hr = _pTask->Resume();
    if (SUCCEEDED(hr))
    {
        hr = InternalResume();
    }

    return hr;
#else  // 0

    return E_NOTIMPL;

#endif // 0
}

HRESULT CExtractImageTask::InternalResume()
{
    ASSERT(_hBmp != NULL);
    BOOL bCache = (_dwFlags & IEIFLAG_CACHE);

    if (bCache)
    {
        IShellFolder* psf = NULL;

        if (SUCCEEDED(_pView->GetShellFolder(&psf)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, _pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
            {            
                // Make sure we don't request to cache an item that is encrypted in a folder that is not
                if (SFGAO_ENCRYPTED == SHGetAttributes(psf, _pidl, SFGAO_ENCRYPTED))
                {
                    bCache = FALSE;
                    
                    LPITEMIDLIST pidlParent = _pView->_GetViewPidl();
                    if (pidlParent)
                    {
                        if (SFGAO_ENCRYPTED == SHGetAttributes(NULL, pidlParent, SFGAO_ENCRYPTED))
                        {
                            bCache = TRUE;
                        }
#ifdef DEBUG                            
                        else
                        {
                            TraceMsg(TF_DEFVIEW, "CExtractImageTask (%s is encrypted in unencrypted folder)", szPath);
                        }
#endif                                
                        ILFree(pidlParent);
                    }
                }

                // Make sure we don't request to cache an item that has differing ACLs applied
                if (bCache)
                {
                    PACL pdacl;
                    PSECURITY_DESCRIPTOR psd;

                    bCache = FALSE;
                    
                    if (ERROR_SUCCESS == GetNamedSecurityInfo(szPath, 
                                                                            SE_FILE_OBJECT,
                                                                            DACL_SECURITY_INFORMATION,
                                                                            NULL,
                                                                            NULL,
                                                                            &pdacl,
                                                                            NULL,
                                                                            &psd))
                    {
                        SECURITY_DESCRIPTOR_CONTROL sdc;
                        DWORD dwRevision;
                        if (GetSecurityDescriptorControl(psd, &sdc, &dwRevision) && !(sdc & SE_DACL_PROTECTED))
                        {
                            if (pdacl)
                            {
                                PKNOWN_ACE pACE = (PKNOWN_ACE) FirstAce(pdacl);
                                if ((pACE->Header.AceType != ACCESS_DENIED_ACE_TYPE) || (pACE->Header.AceFlags & INHERITED_ACE))
                                {
                                    bCache = TRUE;
                                }
#ifdef DEBUG                                
                                else
                                {
                                    TraceMsg(TF_DEFVIEW, "CExtractImageTask (%s has a non-inherited deny acl)", szPath);
                                }
#endif                                
                            }
                            else
                            {
                                bCache = TRUE; // NULL dacl == everyone all access
                            }
                        }
#ifdef DEBUG
                        else
                        {
                            TraceMsg(TF_DEFVIEW,"CExtractImageTask (%s has a protected dacl)", szPath);
                        }                            
#endif
                        LocalFree(psd);
                    }
                }
            }
            psf->Release();
        }
        
        if (!bCache && _pView->_pDiskCache) // If we were asked to cache and are not for security reasons
        {
            DWORD dwLock;            
            if (SUCCEEDED(_pView->_pDiskCache->Open(STGM_WRITE, &dwLock)))
            {
                _pView->_pDiskCache->DeleteEntry(_szPath);
                _pView->_pDiskCache->ReleaseLock(&dwLock);
                SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);  // Keep open for 2 seconds, just in case
            }        
        }
    }

    HRESULT hr = _pView->UpdateImageForItem(_dwTaskID, _hBmp, _iItem, _pidl, _szPath, _ftDateStamp, bCache, _dwPriority);

    // UpdateImageForItem returns S_FALSE if it assumes ownership of bitmap
    if (hr == S_FALSE)
    {
        _hBmp = NULL;
    }

    _lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP_(ULONG) CExtractImageTask::IsRunning(void)
{
    return _lState;
}

class CCategoryTask : public CRunnableTask
{
public:
    STDMETHOD (RunInitRT)();

    CCategoryTask(CDefView *pView, UINT uId, LPCITEMIDLIST pidl);

private:
    ~CCategoryTask();

    CDefView* _pView;
    LPITEMIDLIST _pidl;
    ICategorizer* _pcat;
    UINT _uId;
};

CCategoryTask::CCategoryTask(CDefView *pView, UINT uId, LPCITEMIDLIST pidl) 
    : CRunnableTask(RTF_DEFAULT), _uId(uId), _pView(pView), _pcat(pView->_pcat)
{
    _pcat->AddRef();
    _pidl = ILClone(pidl);
}

CCategoryTask::~CCategoryTask()
{
    ATOMICRELEASE(_pcat);
    ILFree(_pidl);
    PostMessage(_pView->_hwndView, WM_DSV_GROUPINGDONE, 0, 0);
}

HRESULT CCategoryTask_Create(CDefView *pView, LPCITEMIDLIST pidl, UINT uId, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    CCategoryTask * pNew = new CCategoryTask(pView, uId, pidl);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}                               

STDMETHODIMP CCategoryTask::RunInitRT()
{
    if (_pidl)
    {
        DWORD dwGroup = -1;
        _pcat->GetCategory(1, (LPCITEMIDLIST*)&_pidl, &dwGroup);

        CBackgroundGroupInfo* pbggi = new CBackgroundGroupInfo(_pidl, _uId, dwGroup);
        if (pbggi)
        {
            _pidl = NULL;       // Transferred ownership to BackgroundInfo
            if (!PostMessage(_pView->_hwndView, WM_DSV_SETITEMGROUP, NULL, (LPARAM)pbggi))
                delete pbggi;
        }
    }

    return S_OK;
}

class CGetCommandStateTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT();
    STDMETHODIMP InternalResumeRT();

    CGetCommandStateTask(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray);

private:
    ~CGetCommandStateTask();

    CDefView    *_pView;
    IUICommand  *_puiCommand;
    IShellItemArray *_psiItemArray;
};

HRESULT CGetCommandStateTask_Create(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    CGetCommandStateTask *pNew = new CGetCommandStateTask(pView, puiCommand, psiItemArray);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}

CGetCommandStateTask::CGetCommandStateTask(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray)
    : CRunnableTask(RTF_SUPPORTKILLSUSPEND)
{
    _pView = pView;
    _puiCommand = puiCommand;
    _puiCommand->AddRef();
    _psiItemArray = psiItemArray;
    if (_psiItemArray)
        _psiItemArray->AddRef();
}
CGetCommandStateTask::~CGetCommandStateTask()
{
    ATOMICRELEASE(_puiCommand);
    ATOMICRELEASE(_psiItemArray);
}

STDMETHODIMP CGetCommandStateTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CGetCommandStateTask::InternalResumeRT()
{
    // Don't want to interfere with the explorer view starting up, so give it a head start.
    // we were told to either suspend or quit...
    if (WaitForSingleObject(_hDone, 1000) == WAIT_OBJECT_0)
    {
        return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
    }
    UISTATE uis;
    HRESULT hr = _puiCommand->get_State(_psiItemArray, TRUE, &uis);
    if (SUCCEEDED(hr) && (uis==UIS_ENABLED))
    {
        _pView->_PostSelectionChangedMessage(LVIS_SELECTED);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dvthumbnail.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "defview.h"
#include "defviewp.h"
#include "dvtasks.h"
#include "guids.h"
#include "prop.h"
#include "CommonControls.h"
#include "thumbutil.h"

// Thumbnail support
HRESULT CDefView::_SafeAddImage(BOOL fQuick, IMAGECACHEINFO* prgInfo, UINT* piImageIndex, int iListID)
{
    HRESULT hr = S_FALSE;
    UINT uCacheSize = 0;
    _pImageCache->GetCacheSize(&uCacheSize);
    
    ASSERT(_iMaxCacheSize>0);

    BOOL bSpaceOpen = (uCacheSize < (UINT)_iMaxCacheSize);
    if (!bSpaceOpen)
    {
        BOOL bMakeSpace = TRUE;
        int iListIndex = -1;

        // Check to see if we are visible and need to make space
        if (-1 != iListID)
        {
            iListIndex = _MapIDToIndex(iListID);
            if (-1 == iListIndex) // Someone removed our item
            {
                hr = E_INVALIDARG;
                bMakeSpace = FALSE;
            }
            else if (!ListView_IsItemVisible(_hwndListview, iListIndex))
            {
                hr = S_FALSE;
                bMakeSpace = FALSE;
            }
        }

        if (bMakeSpace)
        {
            // item is visible... try and make a space
            UINT uCacheIndex = 0;
            do
            {
                UINT uImageIndex;
                int iUsage;
                if (FAILED(_pImageCache->GetImageIndexFromCacheIndex(uCacheIndex, &uImageIndex)) ||
                    FAILED(_pImageCache->GetUsage(uImageIndex, (UINT*) &iUsage)))
                {
                    break;
                }

                if (iUsage != ICD_USAGE_SYSTEM) // Magic number for System Image
                {
                    TraceMsg(TF_DEFVIEW, "CDefView::_SafeAddImage -- FreeImage (CI::%d II::%d)", uCacheIndex, uImageIndex);
                    _pImageCache->FreeImage(uImageIndex);
                    _UpdateImage(uImageIndex);
                    bSpaceOpen = TRUE;

                    ASSERT((LONG)(uCacheSize - uCacheIndex) > (LONG)_ApproxItemsPerView()); 
                }

                uCacheIndex++;
            }
            while (!bSpaceOpen);

            // If we repeatedly fail to add images to the list and are still decoding more images this means
            // we will have to re-walk the list view every time we finish decoding another image, only to then
            // throw away the result because we have no where to save it.  This could lead to sluggish response
            // from the UI.  In short, if the following Trace is common then we have a problem that needs to be
            // fixed (which might required considerable rearchitecting).
            if (!bSpaceOpen)
            {
                TraceMsg(TF_WARNING, "CDefView::_SafeAddImage failed to make room in cache!!");
                hr = E_FAIL;
            }
        }
    }
    
    *piImageIndex = I_IMAGECALLBACK;
    if (bSpaceOpen) // There is space in the cache for this image
    {
        hr = _pImageCache->AddImage(prgInfo, piImageIndex);
        TraceMsg(TF_DEFVIEW, "CDefView::_SafeAddImage -- AddImage (HR:0x%08x name:%s,index:%u)", hr, prgInfo->pszName, *piImageIndex);
    }
    
    return hr;
}

COLORREF CDefView::_GetBackColor()
{
    // SendMessage traffic is greatly reduced if we don't ask for the bkcolor
    // every time we need it...
    if (_rgbBackColor == CLR_INVALID)
    {
        _rgbBackColor = ListView_GetBkColor(_hwndListview); 
        if (_rgbBackColor == CLR_NONE)
            _rgbBackColor = GetSysColor(COLOR_WINDOW);
    }

    return _rgbBackColor;
}


HRESULT CDefView::TaskUpdateItem(LPCITEMIDLIST pidl, int iItem, DWORD dwMask, LPCWSTR pszPath,
                                 FILETIME ftDateStamp, int iThumbnail, HBITMAP hBmp, DWORD dwItemID)
{
    // check the size of the bitmap to make sure it is big enough, if it is not, then 
    // we must center it on a background...
    BITMAP rgBitmap;
    HBITMAP hBmpCleanup = NULL;
    HRESULT hr = E_FAIL;

    if (::GetObject((HGDIOBJ)hBmp, sizeof(rgBitmap), &rgBitmap))
    {
        // if the image is the wrong size, or the wrong colour depth, then do the funky stuff on it..
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        if (rgBitmap.bmWidth != sizeThumbnail.cx || 
            rgBitmap.bmHeight != sizeThumbnail.cy ||
            rgBitmap.bmBitsPixel > _dwRecClrDepth)
        {
            // alloc the colour table just incase....
            BITMAPINFO *pInfo = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 256);
            if (pInfo)
            {
                // get a DC for this operation...
                HDC hdcMem = CreateCompatibleDC(NULL);
                if (hdcMem)
                {
                    pInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    if (GetDIBits(hdcMem, hBmp, 0, 0, NULL, pInfo, DIB_RGB_COLORS))
                    {
                        // we have the header, now get the data....
                        void *pBits = LocalAlloc(LPTR, pInfo->bmiHeader.biSizeImage);
                        if (pBits)
                        {
                            if (GetDIBits(hdcMem, hBmp, 0, pInfo->bmiHeader.biHeight, pBits, pInfo, DIB_RGB_COLORS))
                            {
                                RECT rgRect = {0, 0, rgBitmap.bmWidth, rgBitmap.bmHeight};
                                CalculateAspectRatio(&sizeThumbnail, &rgRect);

                                HPALETTE hpal = NULL;
                                HRESULT hrPalette = _dwRecClrDepth <= 8 ? _GetBrowserPalette(&hpal) : S_OK;
                                if (SUCCEEDED(hrPalette))
                                {
                                    if (FactorAspectRatio(pInfo, pBits, &sizeThumbnail, rgRect, _dwRecClrDepth, hpal, FALSE, _GetBackColor(), &hBmpCleanup))
                                    {
                                        // finally success :-) we have the new image we can abandon the old one...
                                        hBmp = hBmpCleanup;
                                        hr = S_OK;
                                    }
                                }
                            }
                            LocalFree(pBits);
                        }
                    }
                    DeleteDC(hdcMem);
                }
                LocalFree(pInfo);
           }
        }
        else
        {
            // the original bitmap is fine
            hr = S_OK;
        }
    }

    UINT iImage;
    if (SUCCEEDED(hr))
    {
        // check if we are going away, if so, then don't use Sendmessage because it will block the
        // destructor of the scheduler...
        if (_fDestroying)
        {
            hr = E_FAIL;
        }
        else
        {
            // copy thumbnail into the cache.
            IMAGECACHEINFO rgInfo = {0};
            rgInfo.cbSize = sizeof(rgInfo);
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX | ICIFLAG_LARGE | ICIFLAG_BITMAP;
            rgInfo.pszName = pszPath;
            rgInfo.dwFlags = dwMask;
            rgInfo.iIndex = (int) iThumbnail;
            rgInfo.hBitmapLarge = hBmp;
            rgInfo.ftDateStamp = ftDateStamp;

            if (!IsNullTime(&ftDateStamp))
                rgInfo.dwMask |= ICIFLAG_DATESTAMP;

            if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                rgInfo.dwMask |= ICIFLAG_MIRROR;

            hr = _SafeAddImage(FALSE, &rgInfo, &iImage, (int) dwItemID);
        }
    }

    if (hBmpCleanup)
    {
        DeleteObject(hBmpCleanup);
    }

#ifdef USEMASK
    DeleteObject(hbmMask);
#endif

    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlToSend = ILClone(pidl);
        if (pidlToSend)
        {
            DSV_UPDATETHUMBNAIL* putn = (DSV_UPDATETHUMBNAIL*)LocalAlloc(LPTR, sizeof(DSV_UPDATETHUMBNAIL));
            if (putn)
            {
                putn->iImage = (hr == S_OK) ? iImage : I_IMAGECALLBACK;
                putn->iItem  = iItem;
                putn->pidl   = pidlToSend;

                // post to the main thread so we don't deadlock
                if (!::PostMessage(_hwndView, WM_DSV_UPDATETHUMBNAIL, 0, (LPARAM)putn))
                    _CleanupUpdateThumbnail(putn);
            }
            else
            {
                ILFree(pidlToSend);
            }
        }
    }

    return hr;
}

int CDefView::_IncrementWriteTaskCount()
{
    return InterlockedIncrement((PLONG)&_iWriteTaskCount);
}

int CDefView::_DecrementWriteTaskCount()
{
    return InterlockedDecrement((PLONG)&_iWriteTaskCount);
}

HRESULT CDefView::UpdateImageForItem(DWORD dwTaskID, HBITMAP hImage, int iItem, LPCITEMIDLIST pidl,
                                     LPCWSTR pszPath, FILETIME ftDateStamp, BOOL fCache, DWORD dwPriority)
{
    HRESULT hr = S_OK;
    
    TaskUpdateItem(pidl, iItem, _GetOverlayMask(pidl), pszPath, ftDateStamp, 0, hImage, dwTaskID);

    if (_pDiskCache && fCache && (_iWriteTaskCount < MAX_WRITECACHE_TASKS))
    {
        // REVIEW: if pidl is an encrypted file but isn't in an encrytped folder, should avoid writing it's thumbnail?
        // If we don't, other users could otherwise view the thumbnail and thus know the contents of the encrypted file.

        // Add a cache write test
        IRunnableTask *pTask;
        if (SUCCEEDED(CWriteCacheTask_Create(dwTaskID, this, pszPath, ftDateStamp, hImage, &pTask)))
        {
            _AddTask(pTask, TOID_WriteCacheHandler, dwTaskID, dwPriority - PRIORITY_DELTA_WRITE, ADDTASK_ONLYONCE | ADDTASK_ATEND);
            pTask->Release();
            hr = S_FALSE;
        }
    }

    return hr;
}

DWORD CDefView::_GetOverlayMask(LPCITEMIDLIST pidl)
{
    DWORD dwLink = SFGAO_GHOSTED; // SFGAO_LINK | SFGAO_SHARE
    _pshf->GetAttributesOf(1, &pidl, &dwLink);
    return dwLink;
}

void CDefView::_UpdateThumbnail(int iItem, int iImage, LPCITEMIDLIST pidl)
{
    if (!_IsOwnerData())
    {
        if (_hwndListview)
        {
            int iFoundItem = _FindItemHint(pidl, iItem);
            if (-1 != iFoundItem)
            {
                LV_ITEM rgItem = {0};
                rgItem.mask = LVIF_IMAGE;
                rgItem.iItem = iFoundItem;
                rgItem.iImage = iImage;

                // We are about to change the given item for purely internal reasons, we should not treat
                // this change as a "real change".  As such we set a flag so that we ignore the LVN_ITEMCHANGED
                // notification that is generated by this LVM_SETITEM message.  If we don't ingore this
                // next message then we would fire another DISPID_SELECTIONCHANGED every time we finish
                // extracting an image (if the image is selected).
                _fIgnoreItemChanged = TRUE;
                ListView_SetItem(_hwndListview, &rgItem);
                _fIgnoreItemChanged = FALSE;
            }
        }
    }
    else
    {
        RECT rc;
        ListView_GetItemRect(_hwndListview, iItem, &rc, LVIR_BOUNDS);
        InvalidateRect(_hwndListview, &rc, FALSE);
    }
}

void CDefView::_CleanupUpdateThumbnail(DSV_UPDATETHUMBNAIL* putn)
{
    ILFree(putn->pidl);
    LocalFree((HLOCAL)putn);
}

int CDefView::ViewGetIconIndex(LPCITEMIDLIST pidl)
{
    int iIndex = -1;

    if (_psi)
    {
        // check to see if we succeeded and we weren't told to extract the icon
        // ourselves ...

        if ((S_OK == _psi->GetIconOf(pidl, 0, &iIndex)) && _psio)
        {
            int iOverlay;
            if (SUCCEEDED(_psio->GetOverlayIndex(pidl, &iOverlay)))
            {
                iIndex |= iOverlay << 24;
            }
        }
    }

    if (-1 == iIndex)
    {
        iIndex = SHMapPIDLToSystemImageListIndex(_pshf, pidl, NULL);
    }

    return (iIndex >= 0) ? iIndex : II_DOCNOASSOC;
}

HRESULT CDefView::CreateDefaultThumbnail(int iIndex, HBITMAP *phBmpThumbnail, BOOL fCorner)
{
    HRESULT hr = E_FAIL;
    
    // get the background for the default thumbnail.
    HDC hdc = GetDC(NULL);
    HDC hMemDC = CreateCompatibleDC(hdc);
    if (hMemDC)
    {
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        *phBmpThumbnail = CreateCompatibleBitmap(hdc, sizeThumbnail.cx, sizeThumbnail.cy);
        if (*phBmpThumbnail)
        {
            HGDIOBJ hTmp = SelectObject(hMemDC, *phBmpThumbnail);
            RECT rc = {0, 0, sizeThumbnail.cx, sizeThumbnail.cy};

            SHFillRectClr(hMemDC, &rc, _GetBackColor());
            
            IImageList* piml;
            if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
            {
                int cxIcon, cyIcon, x, y, dx, dy;
                
                // calculate position and width of icon.
                piml->GetIconSize(&cxIcon, &cyIcon);
                if (cxIcon < sizeThumbnail.cx)
                {
                    if (fCorner)
                    {
                        x = 0;
                    }
                    else
                    {
                        x = (sizeThumbnail.cx - cxIcon) / 2;
                    }
                    dx = cxIcon;
                }
                else
                {
                    // in case icon size is larger than thumbnail size.
                    x = 0;
                    dx = sizeThumbnail.cx;
                }
                
                if (cyIcon < sizeThumbnail.cy)
                {
                    if (fCorner)
                    {
                        y = sizeThumbnail.cy - cyIcon;
                    }
                    else
                    {
                        y = (sizeThumbnail.cy - cyIcon) / 2;
                    }
                    dy = cyIcon;
                }
                else
                {
                    // in case icon size is larger than thumbnail size.
                    y = 0;
                    dy = sizeThumbnail.cy;
                }

                IMAGELISTDRAWPARAMS idp = {sizeof(idp)};
                idp.i = (iIndex & 0x00ffffff);
                idp.hdcDst = hMemDC;
                idp.x = x;
                idp.y = y;
                idp.cx = dx;
                idp.cy = dy;
                idp.rgbBk = CLR_DEFAULT;
                idp.rgbFg = CLR_DEFAULT;
                idp.fStyle = ILD_TRANSPARENT;
                
                piml->Draw(&idp);
                piml->Release();
            }
            
            // get the bitmap produced so that it will be returned.
            *phBmpThumbnail = (HBITMAP) SelectObject(hMemDC, hTmp);
            hr = S_OK;
        }
    }
    
    if (hMemDC)
        DeleteDC(hMemDC);
    ReleaseDC(NULL, hdc);
    return hr;
}

void CDefView::_CacheDefaultThumbnail(LPCITEMIDLIST pidl, int* piIcon)
{
    // create the default one for that file type,
    // the index into the sys image list is used to detect items of the
    // same type, thus we only generate one default thumbnail for each
    // particular icon needed
    UINT iIndex = (UINT) ViewGetIconIndex(pidl);

    if (iIndex == (UINT) I_IMAGECALLBACK)
    {
        iIndex = II_DOCNOASSOC;
    }

    if (_pImageCache)
    {
        // check if the image is already in the image cache.
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof(rgInfo);
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX;
        rgInfo.pszName = L"Default";
        rgInfo.dwFlags = _GetOverlayMask(pidl);
        rgInfo.iIndex = (int) iIndex;

        HRESULT hr = _pImageCache->FindImage(&rgInfo, (UINT*)piIcon);
        if (hr != S_OK)
        {
            HBITMAP hBmpThumb = NULL;

            hr = CreateDefaultThumbnail(iIndex, &hBmpThumb, FALSE);
            if (SUCCEEDED(hr))
            {
                // we are creating a new one, so we shouldn't have an index yet ..
                Assert(*piIcon == I_IMAGECALLBACK);

                // copy thumbnail into the imagelist.
                rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX | ICIFLAG_LARGE | ICIFLAG_BITMAP;
                rgInfo.hBitmapLarge = hBmpThumb;
                rgInfo.hMaskLarge = NULL;

                if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                    rgInfo.dwMask |= ICIFLAG_MIRROR;

                hr = _SafeAddImage(TRUE, &rgInfo, (UINT*)piIcon, -1);

                DeleteObject(hBmpThumb);
            }
            else
            {
                *piIcon = (UINT) I_IMAGECALLBACK;
            }
        }
    }
    else
    {
        *piIcon = II_DOCNOASSOC;
    }
}

//
// Creates an thumbnail overlay based on the system index
//
HRESULT CDefView::_CreateOverlayThumbnail(int iIndex, HBITMAP* phbmOverlay, HBITMAP* phbmMask)
{
    HRESULT hr = CreateDefaultThumbnail(iIndex, phbmOverlay, TRUE);
    if (SUCCEEDED(hr))
    {
        HDC    hdc = GetDC(NULL);
        BITMAP bm;
        
        hr = E_FAIL;
        if (::GetObject(*phbmOverlay, sizeof(bm), &bm) == sizeof(bm)) 
        {
            HDC hdcImg = ::CreateCompatibleDC(hdc);
            HDC hdcMask = ::CreateCompatibleDC(hdc);

            if (hdcImg && hdcMask)
            {
                *phbmMask = ::CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                if (*phbmMask)
                {
                    HBITMAP  hbmpOldImg = (HBITMAP) ::SelectObject(hdcImg,  *phbmOverlay);
                    HBITMAP  hbmpOldMsk = (HBITMAP) ::SelectObject(hdcMask, *phbmMask);
                    COLORREF clrTransparent = ::GetPixel(hdcImg, 0, 0);
                    
                    ::SetBkColor(hdcImg, clrTransparent);
                    ::BitBlt(hdcMask, 0, 0, bm.bmWidth, bm.bmHeight, hdcImg, 0, 0, SRCCOPY);

                    ::SelectObject(hdcImg, hbmpOldImg);
                    ::SelectObject(hdcMask, hbmpOldMsk);

                    hr = S_OK;
                }
            }
                    
            if (hdcImg)
            {
                DeleteDC(hdcImg);
            }
            if (hdcMask)
            {
                DeleteDC(hdcMask);
            }
        }

        ReleaseDC(NULL, hdc);
    }

    return hr;
}

void CDefView::_DoThumbnailReadAhead()
{
    // Start up the ReadAheadHandler if:
    //  1) view requires thumbnails
    //  2) we have items in view (handle delayed enum)
    //  3) we haven't kicked it off already
    //  4) If we're not ownerdata
    if (_IsImageMode())
    {
        UINT cItems = ListView_GetItemCount(_hwndListview);
        if (cItems && !_fReadAhead && !_IsOwnerData())
        {
            // Start the read-ahead task
            _fReadAhead = TRUE;
            
            IRunnableTask *pTask;
            if (SUCCEEDED(CReadAheadTask_Create(this, &pTask)))
            {
                // add with a low prority, but higher than HTML extraction...
                _AddTask(pTask, TOID_ReadAheadHandler, 0, PRIORITY_READAHEAD, ADDTASK_ATEND);
                pTask->Release();
            }
        }
    }
}

HRESULT CDefView::ExtractItem(UINT *puIndex, int iItem, LPCITEMIDLIST pidl, BOOL fBackground, BOOL fForce, DWORD dwMaxPriority)
{   
    if (!_pImageCache || _fDestroying)
        return S_FALSE;

    if (iItem == -1 && !pidl)
    {
        return S_FALSE;   // failure....
    }

    if (iItem == -1)
    {
        // LISTVIEW
        iItem = _FindItem(pidl, NULL, FALSE);
        if (iItem == -1)
        {
            return S_FALSE;
        }
    }

    IExtractImage *pExtract;
    HRESULT hr = _pshf->GetUIObjectOf(_hwndMain, 1, &pidl, IID_X_PPV_ARG(IExtractImage, 0, &pExtract));
    if (FAILED(hr))
    {
        hr = _GetDefaultTypeExtractor(pidl, &pExtract);
    }

    if (SUCCEEDED(hr))
    {
        FILETIME ftImageTimeStamp = {0,0};

        // do they support date stamps....
        IExtractImage2 *pei2;
        if (SUCCEEDED(pExtract->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
        {
            pei2->GetDateStamp(&ftImageTimeStamp);
            pei2->Release();
        }

        if (IsNullTime(&ftImageTimeStamp) && _pshf2)
        {
            // fall back to this (most common case)
            GetDateProperty(_pshf2, pidl, &SCID_WRITETIME, &ftImageTimeStamp);
        }

        // always extract at 24 bit incase we have to cache it ...
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ORIGSIZE;
        if (fForce)
        {
            dwFlags |= IEIFLAG_QUALITY;     // Force means give me the high-quality thumbnail, if possible
        }

        // Let this run at a slightly higher priority so that we can get the eventual
        // cache read or extract task scheduled sooner
        DWORD dwPriority = PRIORITY_EXTRACT_NORMAL;
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);
        hr = pExtract->GetLocation(szPath, ARRAYSIZE(szPath), &dwPriority, &sizeThumbnail, 24, &dwFlags);
        if (dwPriority == PRIORITY_EXTRACT_NORMAL)
        {
            dwPriority = dwMaxPriority;
        }
        else if (dwPriority > PRIORITY_EXTRACT_NORMAL)
        {
            dwPriority = dwMaxPriority + PRIORITY_DELTA_FAST;
        }
        else
        {
            dwPriority = dwMaxPriority - PRIORITY_DELTA_SLOW;
        }

        if (SUCCEEDED(hr) || (hr == E_PENDING))
        {
            BOOL fAsync = (hr == E_PENDING);
            hr = E_FAIL;

            // use the name of the item in defview as the key for the caches
            DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));

            if (!fForce)
            {
                // check if the image is already in the in memory cache
                IMAGECACHEINFO rgInfo = {0};
                rgInfo.cbSize = sizeof(rgInfo);
                rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS;
                rgInfo.pszName = szPath;
                rgInfo.dwFlags = _GetOverlayMask(pidl);
                rgInfo.ftDateStamp = ftImageTimeStamp;

                if (!IsNullTime(&ftImageTimeStamp))
                    rgInfo.dwMask |= ICIFLAG_DATESTAMP;
                
                hr = _pImageCache->FindImage(&rgInfo, puIndex);
            }

            if (hr != S_OK)
            {
                DWORD dwTaskID = _MapIndexPIDLToID(iItem, pidl);
                if (dwTaskID != (DWORD) -1)
                {
                    // create a task for a disk cache
                    CTestCacheTask *pTask;
                    hr = CTestCacheTask_Create(dwTaskID, this, pExtract, szPath, ftImageTimeStamp, pidl, 
                                               iItem, dwFlags, dwPriority, fAsync, fBackground, fForce, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        // does it not support Async, or were we told to run it forground ?
                        if (!fAsync || !fBackground)
                        {
                            if (!fBackground)
                            {
                                // make sure there is no extract task already underway as we
                                // are not adding this to the queue...
                                _pScheduler->RemoveTasks(TOID_ExtractImageTask, dwTaskID, TRUE);
                            }

                            // NOTE: We must call RunInitRT, not Run, for CTestCacheTask.  The reason is that RunInitRT
                            // will return S_FALSE if it needs the default icon to be displayed but we would loose that
                            // extra data if we call Run directly.

                            hr = pTask->RunInitRT();

                            // If RunInitRT returns S_OK then the correct image index was generated, however we don't know what
                            // that index is at this time.  We will return S_OK and I_IMAGECALLBACK in this case because we
                            // know that a WM_UPDATEITEMIMAGE message should have been posted
                        }
                        else
                        {
                            // add the task to the scheduler...
                            TraceMsg(TF_DEFVIEW, "ExtractItem *ADDING* CCheckCacheTask (szPath=%s priority=%x index=%d ID=%d)", szPath, dwPriority, iItem, dwTaskID);
                            hr = _AddTask((IRunnableTask *)pTask, TOID_CheckCacheTask, dwTaskID, dwPriority, ADDTASK_ONLYONCE);

                            // signify we want a default icon for now....
                            hr = S_FALSE;
                        }
                        pTask->Release();
                    }
                }
            }
        }
        pExtract->Release();
    }

    return hr;
}

DWORD GetCurrentColorFlags(UINT * puBytesPerPixel)
{
    DWORD dwFlags = 0;
    UINT uBytesPerPix = 1;
    int res = (int)GetCurColorRes();
    switch (res)
    {
    case 16 :   dwFlags = ILC_COLOR16;
                uBytesPerPix = 2;
                break;
    case 24 :
    case 32 :   dwFlags = ILC_COLOR24;
                uBytesPerPix = 3;
                break;
    default :   dwFlags = ILC_COLOR8;
                uBytesPerPix = 1;
    }
    if (puBytesPerPixel)
    {
        *puBytesPerPixel = uBytesPerPix;
    }

    return dwFlags;
}

UINT CalcCacheMaxSize(const SIZE * psizeThumbnail, UINT uBytesPerPix)
{
    // the minimum in the cache is the number of thumbnails visible on the screen at once.
    HDC hdc = GetDC(NULL);
    int iWidth = GetDeviceCaps(hdc, HORZRES);
    int iHeight = GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(NULL, hdc);

    // the minimum number of thumbnails in the cache, is set to the maximum amount
    // of thumbnails that can be diplayed by a single view at once.
    int iRow =  iWidth / (psizeThumbnail->cx + DEFSIZE_BORDER);
    int iCol = iHeight / (psizeThumbnail->cy + DEFSIZE_VERTBDR);
    UINT iMinThumbs = iRow * iCol + NUM_OVERLAY_IMAGES;

    // calculate the maximum number of thumbnails in the cache based on available memory
    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus(&ms);

    // set the thumbnail maximum by calculating the memory required for a single thumbnail.
    // then use no more than 1/3 the available memory.
    // Say you had 80x80x32bpp thumbnails, this would be 13 images per MB of available memory.
    int iMemReqThumb = psizeThumbnail->cx * psizeThumbnail->cy * uBytesPerPix;
    UINT iMaxThumbs = UINT((ms.dwAvailPhys / 3) / iMemReqThumb);

#ifdef DEBUG
    return iMinThumbs;
#else
    return __max(iMaxThumbs, iMinThumbs);
#endif    
}

void ListView_InvalidateImageIndexes(HWND hwndList)
{
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(hwndList, iItem, 0)) != -1)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iImage = I_IMAGECALLBACK;

        ListView_SetItem(hwndList, &lvi);
    }
}

ULONG CDefView::_ApproxItemsPerView()
{
    RECT rcClient;
    ULONG ulItemsPerView = 0;
    
    if (_hwndView && GetClientRect(_hwndView, &rcClient))
    {
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        ULONG ulItemWidth = sizeThumbnail.cx + DEFSIZE_BORDER;
        ULONG ulItemHeight = sizeThumbnail.cy + DEFSIZE_VERTBDR;
        
        ulItemsPerView = (rcClient.right - rcClient.left + ulItemWidth / 2) / ulItemWidth;
        ulItemsPerView *= (rcClient.bottom - rcClient.top + ulItemHeight / 2) / ulItemHeight;
    }

    return ulItemsPerView;
}

void CDefView::_SetThumbview()
{
    // Since we are switching into thumbnail view, remove any icon tasks
    if (_pScheduler)
        _pScheduler->RemoveTasks(TOID_DVIconExtract, ITSAT_DEFAULT_LPARAM, TRUE);

    if (_pImageCache == NULL)
    {
        // create the image cache (before we do the CreateWindow)....
        CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC, 
                         IID_PPV_ARG(IImageCache3, &_pImageCache)); 
    }

    if (_pDiskCache == NULL && 
        !SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE))
    {
        LPITEMIDLIST pidlFolder = _GetViewPidl();
        if (pidlFolder)
        {
            LoadFromIDList(CLSID_ShellThumbnailDiskCache, pidlFolder, IID_PPV_ARG(IShellImageStore, &_pDiskCache));
            ILFree(pidlFolder);
        }
    }

    if (_IsOwnerData())
        _ThumbnailMapInit();

    if (_pImageCache)
    {
        HRESULT hrInit = E_FAIL;
        UINT uBytesPerPix;
        IMAGECACHEINITINFO rgInitInfo;
        rgInitInfo.cbSize = sizeof(rgInitInfo);
        rgInitInfo.dwMask = ICIIFLAG_LARGE | ICIIFLAG_SORTBYUSED;
        _GetThumbnailSize(&rgInitInfo.rgSizeLarge);
        rgInitInfo.iStart = 0;
        rgInitInfo.iGrow = 5;
        _dwRecClrDepth = rgInitInfo.dwFlags = GetCurrentColorFlags(&uBytesPerPix);
        rgInitInfo.dwFlags |= ILC_MASK;
        
        _iMaxCacheSize = CalcCacheMaxSize(&rgInitInfo.rgSizeLarge, uBytesPerPix);

        hrInit = _pImageCache->GetImageList(&rgInitInfo);
        if (SUCCEEDED(hrInit))
        {
            // GetImageList() will return S_FALSE if it was already created...

            if (_dwRecClrDepth <= 8)
            {
                HPALETTE hpal = NULL;
                HRESULT hrPalette = _GetBrowserPalette(&hpal);
                if (SUCCEEDED(_GetBrowserPalette(&hpal)))
                {
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    ImageList_SetColorTable(rgInitInfo.himlLarge, 0, nColours, rgDIBColours);
                }

                // Make sure we are not using the double buffer stuff...
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_DOUBLEBUFFER, 0);
            }

            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_BORDERSELECT, LVS_EX_BORDERSELECT);

            if (_fs.fFlags & FWF_OWNERDATA)
            {
                InvalidateRect(_hwndListview, NULL, TRUE);
            }
            else
            {
                ListView_InvalidateImageIndexes(_hwndListview);
            }

            ListView_SetImageList(_hwndListview, rgInitInfo.himlLarge, LVSIL_NORMAL);

            HIMAGELIST himlLarge;
            Shell_GetImageLists(&himlLarge, NULL);

            int cxIcon, cyIcon;
            ImageList_GetIconSize(himlLarge, &cxIcon, &cyIcon);
            int cySpacing = (_fs.fFlags & FWF_HIDEFILENAMES) ? cyIcon / 4 + rgInitInfo.rgSizeLarge.cy + 3 : 0;
            int cxSpacing = cxIcon / 4 + rgInitInfo.rgSizeLarge.cx + 1;

            // Usability issue: people have trouble unselecting, marquee selecting, and dropping
            // since they can't find the background.  Add an extra 20 pixels between the thumbnails
            // to avoid this problem.
            //
            ListView_SetIconSpacing(_hwndListview, cxSpacing + 20, cySpacing);

            // NOTE: if you need to adjust cySpacing above, you can't do it directly since we
            // can't calculate the proper size of the icons.  Do it this way:
            //   DWORD dwOld = ListView_SetIconSpacing(_hwndListview, cxSpacing, cySpacing);
            //   ListView_SetIconSpacing(_hwndListview, LOWORD(dwOld)+20, HIWORD(dwOld)+20);

            if (_fs.fFlags & FWF_HIDEFILENAMES)
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_HIDELABELS, LVS_EX_HIDELABELS);

            // We need to pre-populate the ImageList controled by _pImageCache
            // to contain the default system overlays so that our overlays will
            // work.  We are going to get them from the already created shell image
            // lists as they are in hard-coded locations
            UINT uCacheSize = 0;
            _pImageCache->GetCacheSize(&uCacheSize);

            if (!uCacheSize)  // If there are images in the cache the overlays are already there
            {
                IImageList* piml;
                if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
                {
                    struct _OverlayMap 
                    {
                        int iSystemImage;
                        int iThumbnailImage;
                    } rgOverlay[NUM_OVERLAY_IMAGES];
                    
                    // For whatever reason Overlays are one-based
                    for (int i = 1; i <= NUM_OVERLAY_IMAGES; i++)
                    {
                        int iSysImageIndex;
                        if (SUCCEEDED(piml->GetOverlayImage(i, &iSysImageIndex)) && (iSysImageIndex != -1))
                        {
                            int iMap;
                            for (iMap = 0; iMap < i - 1; iMap++)
                            {
                                if (rgOverlay[iMap].iSystemImage == iSysImageIndex)
                                    break;
                            }

                            if (iMap == (i - 1)) // We haven't used this System Image yet
                            {
                                HBITMAP hbmOverlay = NULL;
                                HBITMAP hbmMask = NULL;
                                if (SUCCEEDED(_CreateOverlayThumbnail(iSysImageIndex, &hbmOverlay, &hbmMask)) && hbmOverlay && hbmMask)
                                {
                                    IMAGECACHEINFO rgInfo = {0};
                                    int iThumbImageIndex;
                    
                                    rgInfo.cbSize = sizeof(rgInfo);
                                    rgInfo.dwMask = ICIFLAG_SYSTEM | ICIFLAG_LARGE | ICIFLAG_BITMAP;
                                    rgInfo.hBitmapLarge = hbmOverlay;
                                    rgInfo.hMaskLarge = hbmMask;

                                    if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                                        rgInfo.dwMask |= ICIFLAG_MIRROR;

                                    if (SUCCEEDED(_SafeAddImage(TRUE, &rgInfo, (UINT*)&iThumbImageIndex, -1)))
                                    {
                                        ImageList_SetOverlayImage(rgInitInfo.himlLarge, iThumbImageIndex, i);
                                        rgOverlay[iMap].iSystemImage = iSysImageIndex;
                                        rgOverlay[iMap].iThumbnailImage = iThumbImageIndex;
                                    }
                                    else
                                    {
                                        rgOverlay[i - 1].iSystemImage = -1; // failed to add the image
                                        ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i);
                                    }
                                }
                                else
                                {
                                    rgOverlay[i - 1].iSystemImage = -1;  // failed to import htis image
                                    ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i); 
                                }
                                if (hbmOverlay)
                                {
                                    DeleteObject(hbmOverlay);
                                }
                                if (hbmMask)
                                {
                                    DeleteObject(hbmMask);
                                }
                            }
                            else
                            {
                                ImageList_SetOverlayImage(rgInitInfo.himlLarge, rgOverlay[iMap].iThumbnailImage, i);
                                rgOverlay[i - 1].iSystemImage = -1;  // image already shows up in list
                            }
                        }
                        else
                        {
                            rgOverlay[i - 1].iSystemImage = -1; // Didn't find a system image
                            ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i);
                        }                    
                    }
                }
            }
        }
    } 
}
void CDefView::_ResetThumbview()
{
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_BORDERSELECT, 0);

    if (_fs.fFlags & FWF_HIDEFILENAMES)
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_HIDELABELS, 0);

    if (_dwRecClrDepth <= 8)
    {
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_DOUBLEBUFFER, LVS_EX_DOUBLEBUFFER);
    }

    ListView_SetIconSpacing(_hwndListview, -1, -1);
    _SetSysImageList();

    if (_IsOwnerData())
        _ThumbnailMapClear();        
}

HRESULT CDefView::_GetDefaultTypeExtractor(LPCITEMIDLIST pidl, IExtractImage **ppExt)
{
    IAssociationArray * paa;
    HRESULT hr = _pshf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IAssociationArray, NULL, &paa));
    if (SUCCEEDED(hr))
    {
        LPWSTR psz;
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQN_NAMED_VALUE, L"Thumbnail", &psz);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlThumb;
            hr = SHILCreateFromPath(psz, &pidlThumb, NULL);
            if (SUCCEEDED(hr))
            {
                SHGetUIObjectFromFullPIDL(pidlThumb, NULL, IID_PPV_ARG(IExtractImage, ppExt));
                ILFree(pidlThumb);
            }
            CoTaskMemFree(psz);
        }
        paa->Release();
    }
    return hr;
}

struct ThumbMapNode
{
    int iIndex;
    LPITEMIDLIST pidl;

    ~ThumbMapNode() { ILFree(pidl); }
};

int CDefView::_MapIndexPIDLToID(int iIndex, LPCITEMIDLIST pidl)
{
    int ret = -1;
    if (_IsOwnerData())
    {
        int cNodes = DPA_GetPtrCount(_dpaThumbnailMap);
        int iNode = 0;
        for (; iNode < cNodes; iNode++)
        {
            ThumbMapNode* pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iNode);
            ASSERT(pNode);
            if (pNode->iIndex == iIndex)
            {
                if (!(_pshf->CompareIDs(0, pidl, pNode->pidl)))  // 99 percent of the time we are good
                {
                    ret = iNode;
                }
                else  // Someone moved our pidl!
                {
                    int iNodeStop = iNode;
                    for (iNode = (iNode + 1) % cNodes; iNode != iNodeStop; iNode = (iNode + 1) % cNodes)
                    {
                        pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iNode);
                        if (!(_pshf->CompareIDs(0, pidl, pNode->pidl)))
                        {
                            ret = iNode;
                            pNode->iIndex = iIndex; // Newer index for pidl
                            break;
                        }
                    }
                }
                break;
            }
        }
        if (ret == -1)
        {
            ThumbMapNode* pNode = new ThumbMapNode;
            if (pNode)
            {
                pNode->iIndex = iIndex;
                pNode->pidl = ILClone(pidl);
                ret = DPA_AppendPtr(_dpaThumbnailMap, pNode);
                if (ret == -1)
                {
                    delete pNode;
                }
            }
        }
    }
    else
    {
        ret = ListView_MapIndexToID(_hwndListview, iIndex);
    }
    return ret;
}

int CDefView::_MapIDToIndex(int iID)
{
   int ret = -1;
   if (_IsOwnerData())
   {
        ThumbMapNode* pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iID);
        if (pNode)
        {
            ret = pNode->iIndex;
        }
   }
   else
   {
       ret = ListView_MapIDToIndex(_hwndListview, iID);
   }
   return ret;
}

void CDefView::_ThumbnailMapInit()
{
    if (_dpaThumbnailMap)
    {
        _ThumbnailMapClear();
    }
    else
    {
        _dpaThumbnailMap = DPA_Create(1);
    }
}

void CDefView::_ThumbnailMapClear()
{
    if (_dpaThumbnailMap)
    {
        int i = DPA_GetPtrCount(_dpaThumbnailMap);
        while (--i >= 0)
        {
            ThumbMapNode* pNode = (ThumbMapNode*) DPA_FastGetPtr(_dpaThumbnailMap, i);
            delete pNode;
        }
        DPA_DeleteAllPtrs(_dpaThumbnailMap);
    }
}

HRESULT CDefView::_GetBrowserPalette(HPALETTE* phpal)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (_psb) 
    {
        IBrowserService *pbs;
        hr = _psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs));
        if (SUCCEEDED(hr))
        {
            hr = pbs->GetPalette(phpal);
            pbs->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dvtasks.h ===
#ifndef _DVTASKS_H
#define _DVTASKS_H

#include <runtask.h>

class CDefView;
class CGetIconTask;
class CStatusBarAndInfoTipTask;
class CDUIInfotipTask;
class CTestCacheTask;
class CBackgroundInfoTip;   // Used for the background processing of InfoTips

STDAPI CCategoryTask_Create(CDefView *pView, LPCITEMIDLIST pidl, UINT uId, IRunnableTask **ppTask);
STDAPI CBkgrndEnumTask_CreateInstance(CDefView *pdsv, IEnumIDList * peunk, HDPA hdpaNew, BOOL fRefresh, IRunnableTask **ppTask);
STDAPI CIconOverlayTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pdl, int iList, IRunnableTask **ppTask);
STDAPI CExtendedColumnTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn, IRunnableTask **ppTask);
STDAPI CFileTypePropertiesTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId, IRunnableTask **ppTask);
STDAPI CStatusBarAndInfoTipTask_CreateInstance(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, HWND hwnd, IShellTaskScheduler2* pScheduler, CStatusBarAndInfoTipTask ** ppTask);
STDAPI CDUIInfotipTask_CreateInstance(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl, CDUIInfotipTask **ppTask);

STDAPI CTestCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                             IExtractImage * pExtract, LPCWSTR pszPath, FILETIME ftDateStamp,
                             LPCITEMIDLIST pidl, int iItem, DWORD dwFlags, DWORD dwPriority,
                             BOOL fAsync, BOOL fBackground, BOOL fForce, CTestCacheTask **ppTask);
HRESULT CDiskCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                              DWORD dwPriority, int iItem, LPCITEMIDLIST pidl, LPCWSTR pszPath, 
                              FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags, IRunnableTask **ppTask);
HRESULT CExtractImageTask_Create(DWORD dwTaskID, CDefView* pView, 
                                 IExtractImage *pExtract, LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME fNewTimeStamp, int iItem, 
                                 DWORD dwFlags, DWORD dwPriority, IRunnableTask **ppTask);
HRESULT CWriteCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                               LPCWSTR pszFullPath, FILETIME ftTimeStamp, HBITMAP hImage, IRunnableTask **ppTask);

HRESULT CReadAheadTask_Create(CDefView *pView, IRunnableTask **ppTask);

HRESULT CGetCommandStateTask_Create(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray, IRunnableTask **ppTask);

class CTestCacheTask : public CRunnableTask
{
public:
    CTestCacheTask(DWORD dwTaskID, CDefView *pView, IExtractImage *pExtract, LPCWSTR pszPath,
                   FILETIME ftDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority,
                   BOOL fAsync, BOOL fBackground, BOOL fForce);

    STDMETHOD (RunInitRT)();
    HRESULT Init(LPCITEMIDLIST pidl);

protected:
    ~CTestCacheTask();

    CDefView *_pView;
    IExtractImage * _pExtract;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    LPITEMIDLIST _pidl;
    int _iItem;
    DWORD _dwFlags;
    DWORD _dwPriority;
    BOOL _fAsync;
    BOOL _fBackground;
    BOOL _fForce;
    DWORD _dwTaskID;
};

// task used to perform the background status bar update
class CStatusBarAndInfoTipTask : public CRunnableTask
{
public:
    CStatusBarAndInfoTipTask(HRESULT *phr, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, HWND hwnd, IShellTaskScheduler2* pScheduler);
    STDMETHODIMP RunInitRT(void);

protected:
    ~CStatusBarAndInfoTipTask();

    LPITEMIDLIST    _pidl;
    LPITEMIDLIST    _pidlFolder;
    UINT            _uMsg;
    int             _nMsgParam;
    CBackgroundInfoTip *_pbit;
    HWND            _hwnd;
    IShellTaskScheduler2* _pScheduler;
};

class CBackgroundInfoTip : IUnknown
{
public:
    CBackgroundInfoTip(HRESULT *phr, NMLVGETINFOTIP *plvGetInfoTip)
    {
        _lvSetInfoTip.cbSize = sizeof(_lvSetInfoTip);
        _lvSetInfoTip.iItem = plvGetInfoTip->iItem;
        _lvSetInfoTip.iSubItem = plvGetInfoTip->iSubItem;

        *phr = SHStrDup(plvGetInfoTip->pszText, &_lvSetInfoTip.pszText);
        if (SUCCEEDED(*phr))
        {
            // Do not repeat the text if the item is not folded
            if (plvGetInfoTip->dwFlags & LVGIT_UNFOLDED)
                _lvSetInfoTip.pszText[0] = 0;
        }

        _cRef = 1;
    }

    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return E_NOINTERFACE; }

    virtual STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release(void)
    {
        if (InterlockedDecrement(&_cRef))
            return _cRef;

        delete this;
        return 0;
    }

    LVSETINFOTIP _lvSetInfoTip;

    BOOL        _fReady; // This ensures that we will not try to use the object before it's ready
                         // CONSIDER: the memory can be released and then re-used by the same object
                         // CONSIDER: which would have us believe that the InfoTip should be shown.
                         // CONSIDER: But if another InfoTip had been requested and the memory re-used for the new CBackgroundInfoTip
                         // CONSIDER: we would handle the message WM_AEB_ASYNCNAVIGATION with an
                         // CONSIDER: unprocessed CBackgroundInfoTip object. (See the handler for WM_AEB_ASYNCNAVIGATION).

private:
    LONG _cRef;
    ~CBackgroundInfoTip()
    {
        CoTaskMemFree(_lvSetInfoTip.pszText);   // NULL ok
    }
};

class CDUIInfotipTask : public CRunnableTask
{
public:
    CDUIInfotipTask() : CRunnableTask(RTF_DEFAULT) {}

    // Local
    HRESULT Initialize(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl);

    // IRunnableTask
    STDMETHOD(RunInitRT)(void);

protected:
    virtual ~CDUIInfotipTask();

    CDefView *      _pDefView;
    HWND            _hwndContaining;    // hwnd containing tool
    UINT            _uToolID;           // tool id (unique among tools in containing hwnd)
    LPITEMIDLIST    _pidl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\eballoon.h ===
typedef enum
{
    CBSHOW_HIDE     = -1,
    CBSHOW_SHOW     = 0,
} CBSHOW;

typedef struct 
{
    POINT pt;           //  REQUIRED - maybe OPTIONAL?
    HINSTANCE hinst;    //  REQUIRED - for LoadString
    int idsTitle;       //  REQUIRED 
    int idsMessage;     //  REQUIRED 
    int ttiIcon;        //  REQUIRED one of TTI_ values

    DWORD dwMSecs;      //  OPTIONAL 
    DWORD cLimit;       //  OPTIONAL - if non-zero then query registry
    HKEY hKey;          //  OPTIONAL - REQUIRED if cLimit > 0
    LPCWSTR pszSubKey;  //  OPTIONAL - REQUIRED if cLimit > 0
    LPCWSTR pszValue;   //  OPTIONAL - REQUIRED if cLimit > 0
} CONDITIONALBALLOON;

STDAPI SHShowConditionalBalloon(HWND hwnd, CBSHOW show, CONDITIONALBALLOON *pscb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\enumidlist.h ===
#ifndef _enumidlist_h_
#define _enumidlist_h_
#include "cowsite.h"

// A minimal base IEnumIDList implementation good enough for all our IShellFolder's EnumObject implementations.
// Just provide a Next..
class CEnumIDListBase : public CObjectWithSite, IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched) PURE;
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP Clone(IEnumIDList **ppenum) { *ppenum = NULL; return E_NOTIMPL; }

protected:
    CEnumIDListBase();
    virtual ~CEnumIDListBase();

private:
    LONG _cRef;
};


// [in] pidlFolder - optional parent of this pidl is the first item in the enumerator
// [in] rgcsidl - array of CSIDLs to include in the enumerator
// [in] cItems - count of rgcsidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnCSIDLs(LPCITEMIDLIST pidlFolder, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList** ppenum);

// [in] pidlFolder - optional parent of this pidl is the first item in the enumerator
// [in] pidlItem - optional pidl is the next item in the enumerator
// [in] rgcsidl - array of CSIDLs to include in the enumerator
// [in] cItems - count of rgcsidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnCSIDLs2(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList** ppenum);

// [in] apidl - array of LPCITEMIDLISTs
// [in] cItems - count of *papidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, IEnumIDList** ppenum);
STDAPI CreateIEnumIDListPaths(LPCTSTR pszPaths, IEnumIDList** ppenum);

#endif // _enumidlist_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\eballoon.cpp ===
#include "shellprv.h"
#include "EBalloon.h"

class CErrorBalloon
{
public:
    CErrorBalloon();
    ~CErrorBalloon();

    HRESULT ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, const POINT *ppt, LPTSTR pszTitle, LPTSTR pszMessage, DWORD dwIconIndex, int iTimeout);
    void HideToolTip(BOOL fDestroy);

protected:
    HWND _CreateToolTipWindow(HWND hwnd);
    static LRESULT CALLBACK _SubclassTipProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);
    
    HWND        _hwndTarget;   // the targeted control hwnd
    HWND        _hwndToolTip;  // the tooltip control
    UINT_PTR    _uTimerID;     // the timer id
};


#define ERRORBALLOONTIMERID 1000
#define EB_WARNINGBELOW    0x00000000      // default value.  Balloon tooltips will be shown below the window by default.
#define EB_WARNINGABOVE    0x00000004      // Ballon tooltips will be shown above the window by default.
#define EB_WARNINGCENTERED 0x00000008      // Ballon tooltips will be shown pointing to the center of the window.

CErrorBalloon::CErrorBalloon()
{
    // our allocation function should have zeroed our memory.  Check to make sure:
    ASSERT(0==_hwndToolTip);
    ASSERT(0==_uTimerID);
}

CErrorBalloon::~CErrorBalloon()
{
    ASSERT(0==_hwndToolTip);
    ASSERT(0==_hwndTarget);
}

LRESULT CALLBACK CErrorBalloon::_SubclassTipProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    UNREFERENCED_PARAMETER(uID);
    CErrorBalloon * pthis = (CErrorBalloon*)dwRefData;

    switch (uMsg)
    {
        case WM_MOUSEACTIVATE:  // Never activate tooltip
            pthis->HideToolTip(FALSE);
            return MA_NOACTIVATEANDEAT;

        case WM_DESTROY:  
            pthis->HideToolTip(TRUE);
            delete pthis;
            break;

        case WM_TIMER:
            if (wParam == ERRORBALLOONTIMERID)
            {
                pthis->HideToolTip(FALSE);
                return 0;
            }
            break;

    default:
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

HRESULT CErrorBalloon::ShowToolTip(HINSTANCE hinst, HWND hwndTarget, const POINT *ppt, LPTSTR pszTitle, LPTSTR pszMessage, DWORD dwIconIndex, int iTimeout)
{
    if (_hwndToolTip)
    {
        HideToolTip(FALSE);
    }

    HWND hwnd = _CreateToolTipWindow(hwndTarget);
    if (hwnd)
    {
        int x, y;
        x = ppt->x;
        y = ppt->y;

        SendMessage(hwnd, TTM_TRACKPOSITION, 0, MAKELONG(x,y));

        if (pszTitle)
        {
            SendMessage(hwnd, TTM_SETTITLE, (WPARAM)dwIconIndex, (LPARAM)pszTitle);
        }

        TOOLINFO ti = {0};
        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.hwnd = hwnd;
        ti.uId = 1;
        ti.lpszText = pszMessage;
        SendMessage(hwnd, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

        // Show the tooltip
        SendMessage(hwnd, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

        _uTimerID = SetTimer(hwnd, ERRORBALLOONTIMERID, iTimeout, NULL);

        if (SetWindowSubclass(hwnd, CErrorBalloon::_SubclassTipProc, (UINT_PTR)this, (LONG_PTR)this))
        {
            _hwndToolTip = hwnd;
            return S_OK;
        }

        //  we blew the subclassing
        DestroyWindow(hwnd);
    }
    return E_FAIL;
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
HWND CErrorBalloon::_CreateToolTipWindow(HWND hwndTarget)
{
    HWND hwnd = CreateWindow(
            TOOLTIPS_CLASS,
            NULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            hwndTarget,
            NULL,
            GetModuleHandle(NULL),
            NULL);

    ASSERT(!_hwndToolTip);
    ASSERT(!_hwndTarget);

    if (hwnd)
    {
        TOOLINFO ti = {0};

        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.uFlags = TTF_TRACK;
        ti.hwnd = hwnd;
        ti.uId = 1;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(hwnd, TTM_SETMAXTIPWIDTH, 0, 300);
        //  set tink-tink?
    }

    return hwnd;
}

void CErrorBalloon::HideToolTip(BOOL fOnDestroy)
{
    // When the timer fires we hide the tooltip window
    if (fOnDestroy)
    {
        //  we need to tear everything down
        if (_uTimerID)
        {
            KillTimer(_hwndTarget, ERRORBALLOONTIMERID);
            _uTimerID = 0;
        }
        
        if (_hwndTarget)
        {
            //  RemoveWindowSubclass(_hwndTarget, CErrorBalloon::_SubclassTargetProc, (UINT_PTR)this);
            RemoveProp(_hwndTarget, L"ShellConditionalBalloon");
            _hwndTarget = NULL;
        }

        if (_hwndToolTip)
        {
            RemoveWindowSubclass(_hwndToolTip, CErrorBalloon::_SubclassTipProc, (UINT_PTR)this);
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
            _hwndToolTip = NULL;
        }
    }
    else
        DestroyWindow(_hwndToolTip);
}
#if 0
_GetTipPoint()
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);
    POINT pt;
    pt.x = (rc.left+rc.right)/2;
    if ( EB_WARNINGABOVE & dwFlags )
    {
        pt.y = rc.top;
    }
    else if ( EB_WARNINGCENTERED & dwFlags )
    {
        pt.y = (rc.top+rc.bottom)/2;
    }
    else
    {
        pt.y = rc.bottom;
    }
}
#endif

STDAPI SHShowConditionalBalloon(HWND hwnd, CBSHOW show, CONDITIONALBALLOON *pscb)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (hwnd)
    {
        CErrorBalloon *peb = (CErrorBalloon *) GetProp(hwnd, L"ShellConditionalBalloon");
        if (show != CBSHOW_HIDE && pscb)
        {
            DWORD dw = 0;
            BOOL fShow = TRUE;
            HKEY hkSession = NULL;
            if (SUCCEEDED(SHCreateSessionKey(MAXIMUM_ALLOWED, &hkSession)))
            {
                fShow = (ERROR_SUCCESS != SHGetValue(hkSession, NULL, pscb->pszValue, NULL, NULL, NULL));
            }
            //  check cLimit
            if (fShow && pscb->cLimit)
            {
                ASSERT(pscb->hKey);
                DWORD cb = sizeof(dw);
                SHGetValue(pscb->hKey, pscb->pszSubKey, pscb->pszValue, NULL, &dw, &cb);
                fShow = dw < pscb->cLimit;
            }

            if (fShow)
            {
                //  we need to show something
                if (!peb)
                {
                    peb = new CErrorBalloon();
                    if (peb && !SetProp(hwnd, L"ShellConditionalBalloon", peb))
                    {
                        delete peb;
                        peb = NULL;
                    }
                }

                if (peb)
                {
                    TCHAR szTitle[MAX_PATH];
                    TCHAR szMessage[INFOTIPSIZE];
                    LoadString(pscb->hinst, pscb->idsTitle, szTitle, ARRAYSIZE(szTitle));
                    LoadString(pscb->hinst, pscb->idsMessage, szMessage, ARRAYSIZE(szMessage));
                    // Set the tooltip display point
                    //if (pscb->pt.x == -1 && pscb->pt.y == -1)
                    //    _GetTipPoint(hwndTarget, &pscb->pt);    
                    DWORD dwMSecs = pscb->dwMSecs;
                    if (dwMSecs == 0)
                    {
                        // default to 1 sec / 10 chars;
                        dwMSecs = lstrlen(szMessage) * 100;
                        if (dw == 0)
                            dwMSecs *= 5;  //  first time put it up for a while
                    }
                        
                    hr = peb->ShowToolTip(pscb->hinst, hwnd, &pscb->pt, szTitle, szMessage, pscb->ttiIcon, dwMSecs);
                    if (FAILED(hr))
                    {
                        RemoveProp(hwnd, L"ShellConditionalBalloon");
                        delete peb;
                    }

                    if (pscb->cLimit)
                    {
                        dw++;
                        SHSetValueW(pscb->hKey, pscb->pszSubKey, pscb->pszValue, REG_DWORD, &dw, sizeof(dw));
                    }
                }
            }
            else 
                hr = S_FALSE;

            if (hkSession)
            {
                SHSetValueW(hkSession, NULL, pscb->pszValue, REG_NONE, NULL, NULL);
                RegCloseKey(hkSession);
            }
                
        }
        else if (peb)
        {
            peb->HideToolTip(FALSE);
            //  we delete ourselves during WM_DESTROY
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\dynastg.cpp ===
#include "shellprv.h"
#include <shlobj.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <assert.h>
#include <shlwapi.h>
#include <stgutil.h>
#include <datautil.h>
#include <idlcomm.h>
#include <dpa.h>
#include <objbase.h>

#define DSTYPE_STORAGE      0x1
#define DSTYPE_STREAM       0x2

// do not change order of these parameters, we have some in line variable initializations going on
typedef struct 
{
    LPWSTR pwszTag;
    IShellItem *psi;
    DWORD_PTR grfMode;
} DYNASTGDATA;

// Prototype definitions
STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CDynamicStorageEnum_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

class CDynamicStorage : public IStorage, public IDynamicStorage
{
friend class CDynamicStorageEnum;
friend HRESULT CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

public:
    CDynamicStorage();
    ~CDynamicStorage();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDynamicStorage
    STDMETHODIMP AddIDList(DWORD cpidl, LPITEMIDLIST* rgpidl, DSTGF dstgf);
    STDMETHODIMP BindToItem(LPCWSTR pwszName, REFIID riid, void **ppv);
    STDMETHODIMP EnumItems(IEnumShellItems **ppesi);
    
    // IStorage
    //  we only implement: CreateStream, OpenStream, OpenStorage, MoveElementTo, EnumElements.
    //  others just return E_NOTIMPL;

    STDMETHODIMP CreateStream(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP OpenStream(const WCHAR *pwcsName, void *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP CreateStorage(const WCHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage **ppstg)
        { return E_NOTIMPL; }
    STDMETHODIMP OpenStorage(const WCHAR *pwcsName, IStorage * pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage ** ppstg);
    STDMETHODIMP CopyTo(DWORD ciidExclude, IID const * rgiidExclude,  SNB snbExclude, IStorage * pstgDest)
        { return E_NOTIMPL; }
    STDMETHODIMP MoveElementTo(const WCHAR * pwcsName, IStorage * pstgDest, const WCHAR * pwcsNewName, DWORD grfFlags);
    STDMETHODIMP Commit(DWORD grfCommitFlags)
        { return S_OK; }
    STDMETHODIMP Revert(void)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumElements(DWORD reserved1, void * reserved2, DWORD reserved3, IEnumSTATSTG ** ppenum);
    STDMETHODIMP DestroyElement(const WCHAR* pwcsName) 
        { return E_NOTIMPL; }
    STDMETHODIMP RenameElement(const WCHAR * pwcsOldName, const WCHAR * pwcsNewName)
        { return E_NOTIMPL; }
    STDMETHODIMP SetElementTimes(const WCHAR * pwcsName, FILETIME const * pctime, FILETIME const * patime, FILETIME const * pmtime)
        { return E_NOTIMPL; }
    STDMETHODIMP SetClass(REFCLSID clsid)
        { return E_NOTIMPL; }
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask)
        { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG * pstatstg, DWORD grfStatFlag)
        { return E_NOTIMPL; }

private:
    HRESULT _Init();
    HRESULT _EnsureDirectory();
    HRESULT _InsertItem(LPWSTR pszTag, IShellItem *psi, DSTGF dstgf);
    HRESULT _GetStream(int i, DWORD grfMode, IStream **ppstm);
    HRESULT _GetStorage(int i, DWORD grfMode, IStorage **ppstg);

    static int s_DataCompare(DYNASTGDATA *pData1, DYNASTGDATA *pData2, LPARAM lParam);
    static int s_DataDestroy(DYNASTGDATA* pData, void* pv);
    
private:        
    CDPA<DYNASTGDATA>   _dpaData;
    IStorage*           _pstgTemp;   // pointer to our temp subfolder
    IStorage*           _pstgTempDir; // the temp folder itself
    LPWSTR              _pwszTemp; // name of our temp subfolder
    LONG                _cRef;
};

class CDynamicStorageEnum : public IEnumSTATSTG 
                          , public IEnumShellItems
{
public:    
    CDynamicStorageEnum();
    ~CDynamicStorageEnum();

    STDMETHODIMP Init(CDynamicStorage* pDynStorage);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumXXX
    STDMETHODIMP Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Clone(IEnumShellItems **ppenum) { return E_NOTIMPL; }
    STDMETHODIMP Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSTATSTG **ppenum) { return E_NOTIMPL; }

private:
    CDynamicStorage *_pDynStorage;
    IShellFolder *_psfParent;
    LPITEMIDLIST _pidlParent;
    ULONG _cItems;
    ULONG _cPos;
    LONG  _cRef;
};

#define DYNSTG_DPA_GROW_SIZE 10

CDynamicStorage::CDynamicStorage(): _cRef(1)
{    
}

int CDynamicStorage::s_DataDestroy(DYNASTGDATA* pData, void* pv)
{
    ASSERTMSG(pData != NULL, "NULL dynamic storage data element");
    CoTaskMemFree(pData->pwszTag);
    pData->psi->Release();
    LocalFree(pData);
    return 1;
}

CDynamicStorage::~CDynamicStorage()
{
    _dpaData.DestroyCallback(s_DataDestroy, NULL);
    if (_pstgTemp)
    {
        ASSERT(_pstgTempDir);
        _pstgTempDir->DestroyElement(_pwszTemp);
        _pstgTempDir->Release();

        _pstgTemp->Release();

        CoTaskMemFree(_pwszTemp);
    }
}


// IUnknown

STDMETHODIMP CDynamicStorage::QueryInterface(REFIID iid, void** ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDynamicStorage, IDynamicStorage), 
        QITABENT(CDynamicStorage, IStorage), 
        { 0 },
    };
    return QISearch(this, qit, iid, ppv);
}

ULONG STDMETHODCALLTYPE CDynamicStorage::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
    
ULONG STDMETHODCALLTYPE CDynamicStorage::Release()
{
    if (::InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }    
    return _cRef;
}

STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;
        
    HRESULT hr = E_OUTOFMEMORY;
    CDynamicStorage *pstgf = new CDynamicStorage();
    if (pstgf)
    {
        hr = pstgf->_Init();
        if (SUCCEEDED(hr))
        {
            hr = pstgf->QueryInterface(riid, ppv);
        }
        pstgf->Release();
    }
    
    return hr;    
}


HRESULT CDynamicStorage::_InsertItem(LPWSTR pszTag, IShellItem *psi, DSTGF dstgf)
{
    HRESULT hr = E_OUTOFMEMORY;
    DYNASTGDATA* pData = (DYNASTGDATA*)LocalAlloc(LPTR, sizeof(DYNASTGDATA));
    if (pData)
    {
        hr = SHStrDup(pszTag, &pData->pwszTag);
        if (SUCCEEDED(hr))
        {
            pData->psi = psi;
            pData->psi->AddRef();
            if (!(dstgf & DSTGF_ALLOWDUP))
            {
                int i = _dpaData.Search(pData, 0, s_DataCompare, 0, 0);
                if (i != -1)
                {
                    s_DataDestroy(_dpaData.GetPtr(i), NULL);
                    _dpaData.DeletePtr(i);
                }
            }

            // i != -1 if we succeeded, at which point pass out the data pointer or
            // ensure that we clean up.

            if (-1 == _dpaData.AppendPtr(pData))
            {
                s_DataDestroy(pData, NULL);
                hr = E_FAIL;
            }
        }
    }
    
    return hr;
}

// IDynamicStorage 
STDMETHODIMP CDynamicStorage::AddIDList(DWORD cpidl, LPITEMIDLIST* rgpidl, DSTGF dstgf)
{
    if (!rgpidl || !cpidl)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    for (DWORD i = 0; SUCCEEDED(hr) && i < cpidl; i++)
    {
        IShellItem *psi;
        hr = SHCreateShellItem(NULL, NULL, rgpidl[i], &psi);
        if (SUCCEEDED(hr))
        {
            LPWSTR pszName;
            hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName);
            if (SUCCEEDED(hr))
            {
                hr = _InsertItem(pszName, psi, dstgf);
                CoTaskMemFree(pszName);
            }
            psi->Release();
        }
    }

    return hr;
} 
                         
HRESULT CDynamicStorage::BindToItem(LPCWSTR pwszName, REFIID riid, void **ppv)
{
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwszName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        DYNASTGDATA* pData = _dpaData.GetPtr(iResult);
        if (pData && riid == IID_IShellItem)
            hr = pData->psi->QueryInterface(riid, ppv);
        else
            hr = E_NOINTERFACE;
    }       
    return hr;
}

HRESULT CDynamicStorage::EnumItems(IEnumShellItems **ppesi)
{
    *ppesi = NULL;
    
    IEnumShellItems *penum = NULL;
    HRESULT hr = CDynamicStorageEnum_CreateInstance(NULL, IID_PPV_ARG(IEnumShellItems, &penum));
    if (SUCCEEDED(hr))
    {
        hr = ((CDynamicStorageEnum*)penum)->Init(this);
        if (FAILED(hr))
        {
            penum->Release();
        }
    }
    
    if (SUCCEEDED(hr))
    {
        *ppesi = penum;
    }

    return hr;

}

HRESULT CDynamicStorage::_Init()
{
    return _dpaData.Create(DYNSTG_DPA_GROW_SIZE) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CDynamicStorage::_EnsureDirectory()
{
    HRESULT hr = S_OK;

    if (!_pstgTemp)
    {
        hr = E_FAIL;
        WCHAR wszTempDir[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(wszTempDir), wszTempDir))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(wszTempDir, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, &_pstgTempDir));
                if (SUCCEEDED(hr))
                {
                    hr = StgMakeUniqueName(_pstgTempDir, L"dynastg", IID_PPV_ARG(IStorage, &_pstgTemp));
                    if (SUCCEEDED(hr))
                    {
                        STATSTG statstg = {0};

                        hr = _pstgTemp->Stat(&statstg, STATFLAG_DEFAULT);
                        if (SUCCEEDED(hr))
                            _pwszTemp = statstg.pwcsName;
                    }

                    if (FAILED(hr))
                    {
                        ATOMICRELEASE(_pstgTempDir);                            // if we failed, _pwszTemp could not have been allocated...
                        ATOMICRELEASE(_pstgTemp);
                    }
                }
                ILFree(pidl);
            }
        }
    }
    
    return hr;
}

int CDynamicStorage::s_DataCompare(DYNASTGDATA *pData1, DYNASTGDATA *pData2, LPARAM lParam)
{
    return lstrcmp(pData1->pwszTag, pData2->pwszTag);
}

HRESULT CDynamicStorage::_GetStream(int i, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;
    
    HRESULT hr = E_FAIL;
    DYNASTGDATA* pData = _dpaData.GetPtr(i);
    if (pData)
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pData->psi->BindToHandler(pbc, BHID_Stream, IID_PPV_ARG(IStream, ppstm));
            pbc->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::OpenStream(const WCHAR * pwcsName,
                                         void * reserved1,
                                         DWORD grfMode,
                                         DWORD reserved2,
                                         IStream ** ppstm)
{
    if (reserved1 || reserved2)
        return E_INVALIDARG;
        
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwcsName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        hr = _GetStream(iResult, grfMode, ppstm);
    }

    return hr;
}

HRESULT CDynamicStorage::_GetStorage(int i, DWORD grfMode, IStorage **ppstg)
{
    *ppstg = NULL;
    
    HRESULT hr = E_FAIL;
    DYNASTGDATA* pData = _dpaData.GetPtr(i);
    if (pData)
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pData->psi->BindToHandler(pbc, BHID_Storage, IID_PPV_ARG(IStorage, ppstg));
            pbc->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::OpenStorage(const WCHAR * pwcsName,
                                          IStorage * pstgPriority,
                                          DWORD grfMode,
                                          SNB snbExclude,
                                          DWORD reserved,
                                          IStorage ** ppstg)
{
    if (pstgPriority || snbExclude || reserved)
        return E_INVALIDARG;
        
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwcsName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        hr = _GetStorage(iResult, grfMode, ppstg);
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::EnumElements(DWORD reserved1,
                                           void * reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG ** ppenum)
{
    if (reserved1 || reserved2 || reserved3 || !ppenum)
        return E_INVALIDARG;

    *ppenum = NULL;
    IEnumSTATSTG* pEnumObj = NULL;
    HRESULT hr = CDynamicStorageEnum_CreateInstance(NULL, IID_PPV_ARG(IEnumSTATSTG, &pEnumObj));
    if (SUCCEEDED(hr))
    {
        hr = ((CDynamicStorageEnum*)pEnumObj)->Init(this);
        if (FAILED(hr))
        {
            pEnumObj->Release();
        }
    }
    
    if (SUCCEEDED(hr))
    {
        *ppenum = pEnumObj;
    }

    return hr;
}


STDMETHODIMP CDynamicStorage::MoveElementTo(const WCHAR * pwcsName,
                                            IStorage * pstgDest,
                                            const WCHAR* pwcsNewName,
                                            DWORD grfFlags)
{
    if (!pwcsName || !pstgDest || !pwcsNewName || grfFlags != STGMOVE_COPY)
        return E_INVALIDARG;

    IStorage* pStorageSrc;
    HRESULT hr = OpenStorage(pwcsName, NULL, STGM_READ, NULL, 0, &pStorageSrc);
    if (SUCCEEDED(hr))
    {
        IStorage* pStorageDest;
        hr = pstgDest->CreateStorage(pwcsNewName, STGM_WRITE | STGM_CREATE, 0, 0, &pStorageDest);
        if (SUCCEEDED(hr))
        {
            hr = pStorageSrc->CopyTo(0, NULL, NULL, pStorageDest);
        }
    }
    else 
    {
        IStream* pStreamSrc;
        hr = OpenStream(pwcsName, NULL, STGM_READ, 0, &pStreamSrc);
        if (SUCCEEDED(hr))
        {
            IStream* pStreamDest;
            hr = pstgDest->CreateStream(pwcsNewName, STGM_WRITE | STGM_CREATE, 0, 0, &pStreamDest);
            if (SUCCEEDED(hr))
            {                    
                ULARGE_INTEGER ulSize = {0xffffffff, 0xffffffff};
                hr = pStreamSrc->CopyTo(pStreamDest, ulSize, NULL, NULL);
                pStreamDest->Release();
            }
            pStreamSrc->Release();
        }
    }
    
    return hr;
}

STDMETHODIMP CDynamicStorage::CreateStream(const WCHAR *pwcsName,
                                           DWORD grfMode,
                                           DWORD reserved1,
                                           DWORD reserved2,
                                           IStream **ppstm)
{
    *ppstm = NULL;
    
    HRESULT hr = _EnsureDirectory();
    if (SUCCEEDED(hr))
    {
        hr = _pstgTemp->CreateStream(pwcsName, grfMode, 0, 0, ppstm);
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            WCHAR wszPath[MAX_PATH];
            if (GetTempPath(ARRAYSIZE(wszPath), wszPath) && PathCombine(wszPath, wszPath, _pwszTemp))
            {
                STATSTG statstg;
                if (SUCCEEDED((*ppstm)->Stat(&statstg, 0)))
                {
                    LPITEMIDLIST pidl;
                    if (PathCombine(wszPath, wszPath, statstg.pwcsName) && SUCCEEDED(SHILCreateFromPath(wszPath, &pidl, NULL)))
                    {
                        hr = AddIDList(1, &pidl, DSTGF_NONE);
                        ILFree(pidl);
                    }
                    CoTaskMemFree(statstg.pwcsName);
                }
            }

            if (FAILED(hr))
            {
                // no need to DeleteElement here because the whole temp storage
                // will be deleted in destructor
                ATOMICRELEASE(*ppstm);
            }
        }
    }

    return hr;
}


CDynamicStorageEnum::CDynamicStorageEnum(): _cRef(1)
{
}

CDynamicStorageEnum::~CDynamicStorageEnum()
{
    if (_pDynStorage)
        _pDynStorage->Release();

    if (_psfParent)
        _psfParent->Release();

    ILFree(_pidlParent);
}

STDMETHODIMP CDynamicStorageEnum::Init(CDynamicStorage* pDynStorage)
{
    _pDynStorage = pDynStorage;        
    _pDynStorage->AddRef();

    _cItems = _pDynStorage->_dpaData.GetPtrCount();
    _cPos = 0;    

    return S_OK;
}

STDMETHODIMP CDynamicStorageEnum::QueryInterface(REFIID iid, void** ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDynamicStorageEnum, IEnumSTATSTG), 
        QITABENT(CDynamicStorageEnum, IEnumShellItems), 
        { 0 },
    };
    return QISearch(this, qit, iid, ppv);
}

ULONG STDMETHODCALLTYPE CDynamicStorageEnum::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
    
ULONG STDMETHODCALLTYPE CDynamicStorageEnum::Release()
{
    if (::InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }    
    return _cRef;
}

STDAPI CDynamicStorageEnum_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    HRESULT hr = E_OUTOFMEMORY;
    CDynamicStorageEnum *pstgEnum = new CDynamicStorageEnum();
    if (pstgEnum)
    {
        hr = pstgEnum->QueryInterface(riid, ppv);
        pstgEnum->Release();
    }
    
    return hr;    
}

STDMETHODIMP CDynamicStorageEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    if (!rgelt || celt != 1)
        return E_INVALIDARG;

    if (pceltFetched)
        *pceltFetched = 0;
    *rgelt = NULL;
    
    if (_cPos >= _cItems)
        return S_FALSE;

    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");

    DYNASTGDATA* pData = _pDynStorage->_dpaData.GetPtr(_cPos++);
    HRESULT hr;
    if (_cPos > _cItems)
    {
        hr = S_FALSE;
    }
    else
    {
        ASSERTMSG(pData != NULL, "dynamic storage has null DPA item");

        hr = S_OK;
        rgelt[0] = pData->psi;
        rgelt[0]->AddRef();
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

STDMETHODIMP CDynamicStorageEnum::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    // ISSUE: for now, we only support calling next asking for one item
    if (!rgelt || celt != 1)
        return E_INVALIDARG;

    if (_cPos >= _cItems)
        return S_FALSE;

    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");

    ZeroMemory(rgelt, sizeof(STATSTG));  // per COM conventions
    if (pceltFetched)
        *pceltFetched = 0;

    HRESULT hr = E_FAIL;
    IStorage *pstg;
    IStream *pstm;
    if (SUCCEEDED(_pDynStorage->_GetStream(_cPos, STGM_READ, &pstm)))
    {
        hr = pstm->Stat(rgelt, STATFLAG_DEFAULT);
        pstm->Release();
    }
    else if (SUCCEEDED(_pDynStorage->_GetStorage(_cPos, STGM_READ, &pstg)))
    {
        hr = pstg->Stat(rgelt, STATFLAG_DEFAULT);
        pstg->Release();
    }

    if (SUCCEEDED(hr))
    {
        _cPos++;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}
    
STDMETHODIMP CDynamicStorageEnum::Skip(ULONG celt)
{
    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");
    HRESULT hr;
    if (_cPos + celt > _cItems)
    {
        _cPos = _cItems;
        hr = S_FALSE;
    }
    else
    {
        _cPos += celt;
        hr = S_OK;
    }

    return hr;
}
    
STDMETHODIMP CDynamicStorageEnum::Reset()
{
    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");
    _cPos = 0;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\enumuicommand.h ===
#ifndef _enumuicommand_h_
#define _enumuicommand_h_

// a helper class for defview and task implementations
class CWVTASKITEM
{
public:
    HRESULT get_Name(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszName);
    HRESULT get_Icon(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
    HRESULT get_Tooltip(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
    HRESULT get_CanonicalName(const WVTASKITEM* pTask, GUID* pguidCommandName);
    HRESULT get_State(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    HRESULT Invoke(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

    CWVTASKITEM() {};
    virtual ~CWVTASKITEM() {};

private:
    HRESULT _get_String(const WVTASKITEM* pTask, DWORD dwIndex, LPWSTR* ppsz, DWORD cchMin, BOOL bIsIcon);
    DWORD _GetSelectionState(const WVTASKITEM* pTask,IShellItemArray *psiItemArray);
};

#endif // _enumuicommand_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\enumidlist.cpp ===
#include <shellprv.h>
#include "enumidlist.h"

CEnumIDListBase::CEnumIDListBase() : _cRef(1)
{
}

CEnumIDListBase::~CEnumIDListBase()
{
}

STDMETHODIMP CEnumIDListBase::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumIDListBase, IEnumIDList),                        // IID_IEnumIDList
        QITABENT(CEnumIDListBase, IObjectWithSite),                    // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CEnumIDListBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CEnumIDListBase::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


class CEnumArray : public CEnumIDListBase
{
public:
    CEnumArray();
    HRESULT Init(const LPCITEMIDLIST rgpidl[], UINT cidl, UINT ulIndex);
    HRESULT InitFromPaths(LPCTSTR pszPaths);
    HRESULT InitFromCSIDLArray(const LPCTSTR rgcsidl[], UINT ccsidls, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    virtual ~CEnumArray();
    LPITEMIDLIST *_ppidl;

    BOOL         _InitFolderParent(LPITEMIDLIST rgItems[], UINT cMaxItems, UINT *pcItems, LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidlParent);
    LPITEMIDLIST _ILLogical(LPCITEMIDLIST pidl);
    BOOL         _ShouldEnumCSIDL(int csidl);

private:
    LONG  _cRef;
    ULONG _ulIndex;
    UINT _cItems;
};

CEnumArray::CEnumArray() : CEnumIDListBase()
{
}

CEnumArray::~CEnumArray()
{
    if (_ppidl)
        FreeIDListArray(_ppidl, _cItems);
}

HRESULT CEnumArray::Init(const LPCITEMIDLIST rgpidl[], UINT cidl, UINT ulIndex)
{
    _ulIndex = ulIndex;
    HRESULT hr = CloneIDListArray(cidl, rgpidl, &_cItems, &_ppidl);
    if (S_FALSE == hr)
        hr = S_OK;  // S_FALSE to S_OK
    return hr;
}

HRESULT CEnumArray::InitFromCSIDLArray(const LPCTSTR rgcsidl[], UINT ccsidls, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    LPITEMIDLIST rgItems[32] = {0}; // reasonable max size, grow as needed
    UINT cItems = 0;

    LPITEMIDLIST pidlParent = NULL;         // pidlFolder's pidlParent (filesystem or logical pidl)
    LPITEMIDLIST pidlParentLogical = NULL;  // pidlFolder's pidlParent (logical pidl -- if exists)

    // Initialize pidlFolder's parent pidl.
    if (_InitFolderParent(rgItems, ARRAYSIZE(rgItems), &cItems, pidlFolder, &pidlParent))
    {
        // Retrieve pidlFolder's logical parent pidl.
        pidlParentLogical = _ILLogical(pidlParent);
    }

    // Initialize pidlItem.
    if (pidlItem &&
        (!pidlParent || !ILIsEqual(pidlItem, pidlParent)) &&
        (!pidlParentLogical || !ILIsEqual(pidlItem, pidlParentLogical)))
    {
        if (rgItems[cItems] = ILClone(pidlItem))
        {
            cItems++;
        }
    }

    // Initialize CSIDLs.
    for (UINT i = 0; (i < ccsidls) && (cItems < ARRAYSIZE(rgItems)); i++)
    {
        LPITEMIDLIST pidl;
        if (IS_INTRESOURCE(rgcsidl[i]))
        {
            int csidl = LOWORD((UINT_PTR)rgcsidl[i]);

            if (_ShouldEnumCSIDL(csidl))
                SHGetSpecialFolderLocation(NULL, csidl, &pidl);
            else
                pidl = NULL;
        }
        else
        {
            SHParseDisplayName((LPTSTR)rgcsidl[i], NULL, &pidl, 0, NULL);
        }

        if (pidl)
        {
            DWORD dwAttribs = SFGAO_NONENUMERATED;
            if ((pidlFolder && ILIsEqual(pidlFolder, pidl)) ||                  // if pidl is not myself
                (pidlParent && ILIsEqual(pidlParent, pidl)) ||                  // if pidl is not my parent
                (pidlParentLogical && ILIsEqual(pidlParentLogical, pidl)) ||    // (need to check logical parent too)
                (pidlItem && ILIsEqual(pidlItem, pidl)) ||                      // if pidl is not pidlItem
                FAILED(SHGetNameAndFlags(pidl, 0, NULL, 0, &dwAttribs)) ||      // if pidl is not SFGAO_NONENUMERATED
                (SFGAO_NONENUMERATED & dwAttribs))
            {
                ILFree(pidl);
            }
            else
            {
                rgItems[cItems++] = pidl;                                       // then add pidl
            }
        }
    }

    // Initialize CEnumArray with collected pidls.
    HRESULT hr = Init(rgItems, cItems, 0);

    // Cleanup.
    for (i = 0; i < cItems; i++)
    {
        ILFree(rgItems[i]);
    }
    ILFree(pidlParentLogical);

    return hr;
}

BOOL CEnumArray::_InitFolderParent(LPITEMIDLIST rgItems[], UINT cMaxItems, UINT *pcItems, LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidlParent)
{
    ASSERT(*pcItems == 0);  // Currently we expect to add the parent pidl as the FIRST entry.
    ASSERT(cMaxItems > 0);  // Sanity check.

    // If there is a pidlFolder and it's NOT the Desktop pidl, add its parent
    // as the first entry in the rgItems array.  Note that the reason we
    // exclude the Desktop pidl from having its parent added to the array is
    // because its parent is itself, and we don't want the folder we're
    // currently in appearing in rgItems since we're already there!

    if (pidlFolder && !ILIsEmpty(pidlFolder))
    {
        *ppidlParent = ILCloneParent(pidlFolder);
        if (*ppidlParent)
        {
            rgItems[*pcItems] = *ppidlParent;
            (*pcItems)++;
        }
    }
    else
    {
        *ppidlParent = NULL;
    }

    return (*ppidlParent != NULL);
}

// Description:
//  _ILLogical() will return NULL in three cases:
//  1.  out of memory
//  2.  pidl has no logical pidl equivalent
//  3.  pidl is SAME as logical pidl equivalent
//      (thus we already have the logical pidl)
//
// Note:
//  ILFree() must be called on returned pidls.
//
LPITEMIDLIST CEnumArray::_ILLogical(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlLogical = SHLogILFromFSIL(pidl);
    if (pidlLogical && ILIsEqual(pidl, pidlLogical))
    {
        // If the pidl argument is logical, then we already
        // have the logical pidl so don't return another one.
        ILFree(pidlLogical);
        pidlLogical = NULL;
    }
    return pidlLogical;
}

STDMETHODIMP CEnumArray::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    if (_ppidl && (_ulIndex < _cItems))
    {
        hr = SHILClone(_ppidl[_ulIndex++], ppidl);
    }
    
    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

STDMETHODIMP CEnumArray::Skip(ULONG celt) 
{
    _ulIndex = min(_cItems, _ulIndex + celt);
    return S_OK;
}

STDMETHODIMP CEnumArray::Reset() 
{
    _ulIndex = 0;
    return S_OK;
}

HRESULT _CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, UINT ulIndex, IEnumIDList **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;

    CEnumArray *p = new CEnumArray();
    if (p)
    {
        hr = p->Init(rgpidl, cItems, ulIndex);
        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        }
        p->Release();
    }
    return hr;
}

STDMETHODIMP CEnumArray::Clone(IEnumIDList **ppenum) 
{ 
    return _CreateIEnumIDListOnIDLists(_ppidl, _cItems, _ulIndex, ppenum);
}

// Depending on the current state of the world, certain we may not want
// to allow certain CSIDLs to be enumerated (i.e. we want to hide them).
//
BOOL CEnumArray::_ShouldEnumCSIDL(int csidl)
{
    BOOL bEnum;

    switch (csidl)
    {
        case CSIDL_COMMON_DOCUMENTS:
        case CSIDL_COMMON_MUSIC:
        case CSIDL_COMMON_PICTURES:
        case CSIDL_COMMON_VIDEO:
            bEnum = SHShowSharedFolders();
            break;

        default:
            bEnum = TRUE;
            break;
    }

    return bEnum;
}

STDAPI CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, IEnumIDList **ppenum)
{
    return _CreateIEnumIDListOnIDLists(rgpidl, cItems, 0, ppenum);
}

STDAPI CreateIEnumIDListOnCSIDLs(LPCITEMIDLIST pidlFolder, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList **ppenum)
{
    return CreateIEnumIDListOnCSIDLs2(pidlFolder, NULL, rgcsidl, cItems, ppenum);
}

STDAPI CreateIEnumIDListOnCSIDLs2(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;

    CEnumArray *p = new CEnumArray();
    if (p)
    {
        hr = p->InitFromCSIDLArray(rgcsidl, cItems, pidlFolder, pidlItem);
        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        }
        p->Release();
    }
    return hr;
}

STDAPI CreateIEnumIDListPaths(LPCTSTR pszPaths, IEnumIDList **ppenum)
{
    *ppenum = NULL;
    HRESULT hr = E_FAIL;

    LPITEMIDLIST rgItems[32] = {0};
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszNext = pszPaths;
    int cItems = 0;

    while ((cItems < ARRAYSIZE(rgItems)) && (pszNext = NextPath(pszNext, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveBackslash(szPath);
        TCHAR szExpanded[MAX_PATH];
        if (SHExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded)))
        {
            if (SUCCEEDED(SHParseDisplayName(szExpanded, NULL, &rgItems[cItems], 0, NULL)))
            {
                cItems++;
            }
        }
    }

    if (cItems > 0)
    {
        hr = _CreateIEnumIDListOnIDLists(rgItems, cItems, 0, ppenum);

        for (int i = 0; i < cItems; i++)
            ILFree(rgItems[i]);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\exec.c ===
#include "shellprv.h"
#pragma  hdrstop

BOOL _CopyCommand(LPCTSTR pszCommand, LPCTSTR pszDir, LPTSTR pszOut, DWORD cchOut)
{
    BOOL fCopyBack = TRUE;
    BOOL fRet = TRUE;
    // if it does not have quotes, try unquoted name to see if that works...
    if (pszCommand[0] != TEXT('"'))
    {
        if (UrlIs(pszCommand, URLIS_URL))
        {
            //  urls never have params...
            fCopyBack = fRet = FALSE;
            lstrcpyn(pszOut, pszCommand, cchOut);
        }
        else if (StrChr(pszCommand, TEXT(' ')))
        {
            lstrcpyn(pszOut, pszCommand, cchOut);
            PathQualifyDef(pszOut, pszDir, 0);

            // Check for possible existence of arguments
            if (PathFileExistsAndAttributes(pszOut, NULL))
            {
                fCopyBack = fRet = FALSE;
                
            }
        }
        else
            fRet = FALSE;
    }

    //  we need to put the original command for args parsing
    if (fCopyBack)
        lstrcpyn(pszOut, pszCommand, cchOut);

    return fRet;
}

BOOL _QualifyWorkingDir(LPCTSTR pszPath, LPTSTR pszDir, DWORD cchDir)
{
    // special case to make sure the working dir gets set right:
    //   1) no working dir specified
    //   2) a drive or a root path, or a relative path specified
    // derive the working dir from the qualified path. this is to make
    // sure the working dir for setup programs "A:setup" is set right

    if (StrChr(pszPath, TEXT('\\')) || StrChr(pszPath, TEXT(':')))
    {
        // build working dir based on qualified path
        lstrcpyn(pszDir, pszPath, cchDir);
        PathQualifyDef(pszDir, NULL, PQD_NOSTRIPDOTS);
        PathRemoveFileSpec(pszDir);
        return TRUE;
    }

    return FALSE;
}
    
// Run the thing, return TRUE if everything went OK
BOOL ShellExecCmdLine(HWND hwnd, LPCTSTR pszCommand, LPCTSTR pszDir,
        int nShow, LPCTSTR pszTitle, DWORD dwFlags)
{
    TCHAR szWD[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    LPTSTR pszArgs;
    SHELLEXECUTEINFO ei = {0};

    if (pszDir && *pszDir == TEXT('\0'))
        pszDir = NULL;

    if (_CopyCommand(pszCommand, pszDir, szFileName, SIZECHARS(szFileName)))
    {
        //  there might be args in that command
        pszArgs = PathGetArgs(szFileName);
        if (*pszArgs)
            *(pszArgs - 1) = TEXT('\0');
    }
    else
        pszArgs = NULL;

    PathUnquoteSpaces(szFileName);

    // this needs to be here.  app installs rely on the current directory
    // to be the directory with the setup.exe 
    if (!UrlIs(szFileName, URLIS_URL) 
    && ((dwFlags & SECL_USEFULLPATHDIR) || !pszDir))
    {
        if (_QualifyWorkingDir(szFileName, szWD, SIZECHARS(szWD)))
            pszDir = szWD;
    }

    FillExecInfo(ei, hwnd, NULL, szFileName, pszArgs, pszDir, nShow);
    ei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;

    if (dwFlags & SECL_NO_UI)
        ei.fMask |= SEE_MASK_FLAG_NO_UI;

    if (dwFlags & SECL_SEPARATE_VDM)
        ei.fMask |= SEE_MASK_FLAG_SEPVDM;

    if (dwFlags & SECL_LOG_USAGE)
        ei.fMask |= SEE_MASK_FLAG_LOG_USAGE;

    return ShellExecuteEx(&ei);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\enumuicommand.cpp ===
#include "shellprv.h"
#include "enumuicommand.h"
#include "datautil.h"


HRESULT CWVTASKITEM::_get_String(const WVTASKITEM* pTask,
                                 DWORD dwIndex,
                                 LPWSTR * ppsz,
                                 DWORD cchMin,
                                 BOOL bIsIcon)
{
    HRESULT hr;
    DWORD cchIcon = (unsigned)(lstrlen(pTask->pszDllName) + 9); // 9 = comma + minus + 2*65535 + \0
    DWORD cch = bIsIcon
        ? cchIcon                   // "DLL,-0" string format required for loading icons from DLL resource
        : max(cchIcon + 1, cchMin); // "@DLL,-0" string format required for loading strings from DLL resource
    LPWSTR psz = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));
    if (psz)
    {
        if (bIsIcon)
        {
            wnsprintf(psz, cch, L"%s,-%u", pTask->pszDllName, dwIndex);
            hr = S_OK;
        }
        else
        {
            wnsprintf(psz, cch, L"@%s,-%u", pTask->pszDllName, dwIndex);
            hr = SHLoadIndirectString(psz, psz, cch, NULL);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    *ppsz = psz;
    return hr;
}

#define SS_UNKNOWN      0
#define SS_NOTSUPPORTED 1
#define SS_NONE         2
#define SS_FILE         3
#define SS_FOLDER       4
#define SS_MULTI        5
DWORD CWVTASKITEM::_GetSelectionState(const WVTASKITEM* pTask, IShellItemArray *psiItemArray)
{
    DWORD dwSelectionState;
    
    DWORD cItems = 0;

    if (psiItemArray)
    {
        if (FAILED(psiItemArray->GetCount(&cItems)))
        {
            cItems = 0;
        }
    }

    switch (cItems)
    {
    case 0:
        dwSelectionState = SS_NONE;
        break;
    case 1:
        {
            DWORD dwAttribs = 0;

            if (psiItemArray)
            {
                if (FAILED(psiItemArray->GetAttributes(SIATTRIBFLAGS_AND, SFGAO_FOLDER|SFGAO_STREAM,&dwAttribs)))
                {
                    dwAttribs = 0;
                }
            }

            switch (dwAttribs)
            {
            case SFGAO_FOLDER:
                dwSelectionState = SS_FOLDER;
                break;
            case SFGAO_FOLDER|SFGAO_STREAM:
                // zip and cab files are the only things that get here.
                // we'll call them files unless somebody has a better idea
                // (SS_MULTI has plurality that sounds funny).
                // fall through
            default:
                dwSelectionState = SS_FILE;
                break;
            }
        }
        break;
    default:
        dwSelectionState = SS_MULTI;
        break;
    }

    if ((SS_NONE == dwSelectionState && 0 == pTask->dwTitleIndexNoSelection) ||
        (SS_FILE == dwSelectionState && 0 == pTask->dwTitleIndexFileSelected) ||
        (SS_FOLDER == dwSelectionState && 0 == pTask->dwTitleIndexFolderSelected) ||
        (SS_MULTI == dwSelectionState && 0 == pTask->dwTitleIndexMultiSelected))
    {
        dwSelectionState = SS_NOTSUPPORTED;
    }

    return dwSelectionState;
}

HRESULT CWVTASKITEM::get_Name(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszName)
{
    DWORD dwSelState = _GetSelectionState(pTask, psiItemArray);
    switch (dwSelState)
    {
    case SS_NONE:   return _get_String(pTask, pTask->dwTitleIndexNoSelection,    ppszName, MAX_PATH, FALSE);
    case SS_FILE:   return _get_String(pTask, pTask->dwTitleIndexFileSelected,   ppszName, MAX_PATH, FALSE);
    case SS_FOLDER: return _get_String(pTask, pTask->dwTitleIndexFolderSelected, ppszName, MAX_PATH, FALSE);
    case SS_MULTI:  return _get_String(pTask, pTask->dwTitleIndexMultiSelected,  ppszName, MAX_PATH, FALSE);
    }
    *ppszName = NULL;
    return E_NOTIMPL;
}
HRESULT CWVTASKITEM::get_Icon(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
{
    return _get_String(pTask, pTask->dwIconIndex, ppszIcon, 0, TRUE);
}
HRESULT CWVTASKITEM::get_Tooltip(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
{
    return _get_String(pTask, pTask->dwTooltipIndex, ppszInfotip, INFOTIPSIZE, FALSE);
}

HRESULT CWVTASKITEM::get_CanonicalName(const WVTASKITEM* pTask, GUID* pguidCommandName)
{
    *pguidCommandName = *(pTask->pguidCanonicalName);
    return S_OK;
}
HRESULT CWVTASKITEM::get_State(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = S_OK;

    *puisState = UIS_DISABLED;

    if (_GetSelectionState(pTask, psiItemArray) != SS_NOTSUPPORTED)
    {
        if (pTask->pfn_get_State)
            hr = pTask->pfn_get_State(pv, psiItemArray, fOkToBeSlow, puisState);
        else
            *puisState = UIS_ENABLED;
    }

    return hr;
}
HRESULT CWVTASKITEM::Invoke(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return pTask->pfn_Invoke(pv, psiItemArray, pbc);
}



class CUIElement : public CWVTASKITEM, public IUIElement
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IUIElement
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) {return CWVTASKITEM::get_Name(_pTask, psiItemArray, ppszName);}
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) {return CWVTASKITEM::get_Icon(_pTask, psiItemArray, ppszIcon);}
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) {return CWVTASKITEM::get_Tooltip(_pTask, psiItemArray, ppszInfotip);}

    friend HRESULT Create_IUIElement(const WVTASKITEM* pwvti, IUIElement**ppuie);

protected:
    CUIElement(const WVTASKITEM* pTask) { _cRef = 1; _pTask=pTask; }
    ~CUIElement() {}

    LONG              _cRef;
    const WVTASKITEM* _pTask;
};

HRESULT Create_IUIElement(const WVTASKITEM* pwvti, IUIElement**ppuie)
{
    HRESULT hr;

    if (NULL!=pwvti)
    {
        CUIElement* p = new CUIElement(pwvti);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IUIElement, ppuie));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppuie = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IUIElement: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppuie = NULL;
    }
    return hr;
}

HRESULT CUIElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CUIElement, IUIElement),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
ULONG CUIElement::AddRef()
{
    return InterlockedIncrement(&_cRef);
}
ULONG CUIElement::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


class CUICommand : public CUIElement, public IUICommand
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() { return CUIElement::AddRef(); }
    STDMETHODIMP_(ULONG) Release() { return CUIElement::Release(); }
    // IUICommand
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) { return CUIElement::get_Name(psiItemArray, ppszName); }
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) { return CUIElement::get_Icon(psiItemArray, ppszIcon); }
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) { return CUIElement::get_Tooltip(psiItemArray, ppszInfotip); }
    STDMETHODIMP get_CanonicalName(GUID* pguidCommandName) { return CWVTASKITEM::get_CanonicalName(_pTask, pguidCommandName); }
    STDMETHODIMP get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState) { return CWVTASKITEM::get_State(_pTask, _pv, psiItemArray, fOkToBeSlow, puisState); }
    STDMETHODIMP Invoke(IShellItemArray *psiItemArray, IBindCtx *pbc) { return CWVTASKITEM::Invoke(_pTask, _pv, psiItemArray, pbc); }

    friend HRESULT Create_IUICommand(IUnknown* pv, const WVTASKITEM* pwvti, IUICommand**ppuic);

private:
    CUICommand(IUnknown* pv, const WVTASKITEM* pTask);
    ~CUICommand();

    IUnknown* _pv;
};

HRESULT Create_IUICommand(IUnknown* pv, const WVTASKITEM* pwvti, IUICommand**ppuic)
{
    HRESULT hr;

    if (NULL!=pwvti)
    {
        CUICommand* p = new CUICommand(pv, pwvti);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IUICommand, ppuic));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppuic = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IUICommand: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppuic = NULL;
    }

    return hr;
}

CUICommand::CUICommand(IUnknown* pv, const WVTASKITEM* pTask)
    : CUIElement(pTask)
{
    _pv = pv;
    if (_pv)
        _pv->AddRef();
}
CUICommand::~CUICommand()
{
    if (_pv)
        _pv->Release();
}

HRESULT CUICommand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CUICommand, IUICommand),
        QITABENTMULTI(CUICommand, IUIElement, IUICommand),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


#if 0 // { CUICommandOnPidl is currently not used, may come back for RC1

// a IUICommand wrapper around an IShellItem interface
//
class CUICommandOnPidl : public IUICommand
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IUICommand
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName);
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
    STDMETHODIMP get_CanonicalName(GUID* pguidCommandName);
    STDMETHODIMP get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    STDMETHODIMP Invoke(IShellItemArray *psiItemArray, IBindCtx *pbc);

    friend HRESULT Create_UICommandFromParseName(LPCWSTR pszParseName, REFGUID guidCanonicalName, HINSTANCE hinst, int idsName, int idsTip, IUICommand** ppuiCommand);

private:
    CUICommandOnPidl() { _cRef = 1; }
    ~CUICommandOnPidl();
    HRESULT Initialize(LPCWSTR pszParseName, REFGUID guidCanonicalName, HINSTANCE hinst, int idsName, int idsTip);

    LONG _cRef;

    const GUID* _pguidCanonicalName;

    IShellFolder* _psf;
    LPCITEMIDLIST _pidl;
    LPITEMIDLIST  _pidlAbsolute;

    // optional hinst,idsName,idsTip to override display text for the item
    HINSTANCE _hinst;
    int       _idsName;
    int       _idsTip;
};

HRESULT Create_UICommandFromParseName(LPCWSTR pszParseName, REFGUID guidCanonicalName, HINSTANCE hinst, int idsName, int idsTip, IUICommand** ppuiCommand)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    *ppuiCommand = NULL;

    CUICommandOnPidl* p = new CUICommandOnPidl();
    if (p)
    {
        if (SUCCEEDED(p->Initialize(pszParseName, guidCanonicalName, hinst, idsName, idsTip)))
        {
            hr = p->QueryInterface(IID_PPV_ARG(IUICommand, ppuiCommand));
        }
        p->Release();
    }

    return hr;
}

HRESULT CUICommandOnPidl::Initialize(LPCWSTR pszParseName, REFGUID guidCanonicalName, HINSTANCE hinst, int idsName, int idsTip)
{
    _pguidCanonicalName = &guidCanonicalName;

    IShellFolder* psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        hr = psfDesktop->ParseDisplayName(NULL, NULL, (LPOLESTR)pszParseName, NULL, &_pidlAbsolute, NULL);
        if (SUCCEEDED(hr))
        {
            hr = SHBindToIDListParent(_pidlAbsolute, IID_PPV_ARG(IShellFolder, &_psf), &_pidl);

            _hinst = hinst;
            _idsName = idsName;
            _idsTip = idsTip;
        }
        psfDesktop->Release();
    }

    return hr;
}

CUICommandOnPidl::~CUICommandOnPidl()
{
    if (_psf)
        _psf->Release();

    ILFree(_pidlAbsolute);
}

HRESULT CUICommandOnPidl::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CUICommandOnPidl, IUICommand),
        QITABENTMULTI(CUICommandOnPidl, IUIElement, IUICommand),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
ULONG CUICommandOnPidl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}
ULONG CUICommandOnPidl::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CUICommandOnPidl::get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName)
{
    if (_hinst && _idsName)
    {
        // TODO: load the string... but we have to fix dui to handle direct strings!
        return DisplayNameOfAsOLESTR(_psf, _pidl, SHGDN_INFOLDER, ppszName);
    }
    else
        return DisplayNameOfAsOLESTR(_psf, _pidl, SHGDN_INFOLDER, ppszName);
}
HRESULT CUICommandOnPidl::get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
{
    LPWSTR pszIconPath = NULL;
    
    // TODO: use SHGetIconFromPIDL so we get system imagelist support

    IExtractIcon* pxi;
    HRESULT hr = _psf->GetUIObjectOf(NULL, 1, &_pidl, IID_PPV_ARG_NULL(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        WCHAR szPath[MAX_PATH];
        int iIndex;
        UINT wFlags=0;

        // BUGBUG: assume the location is a proper dll,-id value...
        hr = pxi->GetIconLocation(GIL_FORSHELL, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
        if (SUCCEEDED(hr))
        {
            pszIconPath = (LPWSTR)SHAlloc(sizeof(WCHAR)*(lstrlen(szPath)+1+8));
            if (pszIconPath)
            {
                wsprintf(pszIconPath,L"%s,%d", szPath, iIndex);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        pxi->Release();
    }

    *ppszIcon = pszIconPath;
    return hr;
}
HRESULT CUICommandOnPidl::get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
{
    *ppszInfotip = NULL;

    if (_hinst && _idsName)
    {
        // TODO: load the string... but we have to fix dui to handle direct strings!
        return E_NOTIMPL;
    }
    else
        return E_NOTIMPL;
}

HRESULT CUICommandOnPidl::get_CanonicalName(GUID* pguidCommandName)
{
    *pguidCommandName = *_pguidCanonicalName;
    return S_OK;
}
HRESULT CUICommandOnPidl::get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_ENABLED;
    return S_OK;
}
HRESULT CUICommandOnPidl::Invoke(IIShellItemArray *psiItemArray, IBindCtx *pbc)
{
    SHELLEXECUTEINFO sei = { 0 };
    sei.cbSize = sizeof(sei);
    sei.lpIDList = _pidlAbsolute;
    sei.fMask = SEE_MASK_IDLIST;
    sei.nShow = SW_SHOWNORMAL;

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

#endif // } CUICommandOnPidl may come back for RC1


class CEnumUICommand : public IEnumUICommand
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IEnumUICommand
    STDMETHODIMP Next(ULONG celt, IUICommand** pUICommand, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumUICommand **ppenum);

    friend HRESULT Create_IEnumUICommandWithArray(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IUICommand** rguiCommand, UINT cuiCommand, IEnumUICommand**ppenum);

private:
    CEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, ULONG cwvti, IUICommand** rguiCommand, UINT cuiCommand);
    ~CEnumUICommand();

    LONG              _cRef;
    IUnknown*         _pv;
    const WVTASKITEM* _rgwvti;
    ULONG             _cItems;
    IUICommand**      _prguiCommand;
    ULONG             _cuiCommand;
    ULONG             _ulIndex;
};

HRESULT Create_IEnumUICommandWithArray(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IUICommand** rguiCommand, UINT cuiCommand, IEnumUICommand**ppenum)
{
    HRESULT hr;

    if (NULL!=rgwvti)
    {
        CEnumUICommand* p = new CEnumUICommand(pv, rgwvti, cwvti, rguiCommand, cuiCommand);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumUICommand, ppenum));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppenum = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IEnumUICommand: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppenum = NULL;
    }

    return hr;
}

HRESULT Create_IEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IEnumUICommand**ppenum)
{
    return Create_IEnumUICommandWithArray(pv, rgwvti, cwvti, NULL, 0, ppenum);
}

CEnumUICommand::CEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, ULONG cwvti, IUICommand** rguiCommand, UINT cuiCommand)
{
    if (pv)
    {
        _pv = pv;
        _pv->AddRef();
    }

    _rgwvti = rgwvti;
    _cItems = cwvti;

    if (cuiCommand)
    {
        _prguiCommand = (IUICommand**)LocalAlloc(LPTR, cuiCommand*sizeof(IUICommand*));
        if (_prguiCommand)
        {
            for (UINT i = 0 ; i < cuiCommand && rguiCommand[i]; i++)
            {
                _prguiCommand[i] = rguiCommand[i];
                _prguiCommand[i]->AddRef();
            }
            _cuiCommand = i;
        }
    }

    _cRef = 1;
}
CEnumUICommand::~CEnumUICommand()
{
    if (_pv)
        _pv->Release();

    if (_prguiCommand)
    {
        for (UINT i = 0 ; i < _cuiCommand ; i++)
            _prguiCommand[i]->Release();
        LocalFree(_prguiCommand);
    }
}

HRESULT CEnumUICommand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumUICommand, IEnumUICommand),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
ULONG CEnumUICommand::AddRef()
{
    return InterlockedIncrement(&_cRef);
}
ULONG CEnumUICommand::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CEnumUICommand::Next(ULONG celt, IUICommand** ppUICommand, ULONG *pceltFetched)
{
    HRESULT hr;

    if (_ulIndex < _cItems)
    {
        hr = Create_IUICommand(_pv, &_rgwvti[_ulIndex++], ppUICommand);
    }
    else if (_ulIndex < _cItems + _cuiCommand)
    {
        *ppUICommand = _prguiCommand[_ulIndex++ - _cItems];
        (*ppUICommand)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppUICommand = NULL;
        hr = S_FALSE;
    }
    
    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

HRESULT CEnumUICommand::Skip(ULONG celt)
{
    _ulIndex = min(_cItems, _ulIndex+celt);
    return S_OK;
}

HRESULT CEnumUICommand::Reset()
{
    _ulIndex = 0;
    return S_OK;
}

HRESULT CEnumUICommand::Clone(IEnumUICommand **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\exec2nt.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

const WCHAR szCommdlgHelp[] = L"commdlg_help";

UINT wBrowseHelp = WM_USER; /* Set to an unused value */

const CHAR szGetOpenFileName[] = "GetOpenFileNameW";

/* the defines below should be in windows.h */

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30


/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

/* For Long File Name support */
#define MAX_EXTENSION 64

typedef struct {
   LPWSTR lpszExe;
   LPWSTR lpszPath;
   LPWSTR lpszName;
} FINDEXE_PARAMS, FAR *LPFINDEXE_PARAMS;

typedef INT (APIENTRY *LPFNGETOPENFILENAME)(LPOPENFILENAME);

VOID APIENTRY
CheckEscapesW(LPWSTR szFile, DWORD cch)
{
   LPWSTR szT;
   WCHAR *p, *pT;

   for (p = szFile; *p; p++) {

       switch (*p) {
           case WCHAR_SPACE:
           case WCHAR_COMMA:
           case WCHAR_SEMICOLON:
           case WCHAR_HAT:
           case WCHAR_QUOTE:
           {
               // this path contains an annoying character
               if (cch < (wcslen(szFile) + 2)) {
                   return;
               }
               szT = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
               if (!szT) {
                   return;
               }
               wcscpy(szT,szFile);
               p = szFile;
               *p++ = WCHAR_QUOTE;
               for (pT = szT; *pT; ) {
                    *p++ = *pT++;
                }
                *p++ = WCHAR_QUOTE;
                *p = WCHAR_NULL;
                LocalFree(szT);
                return;
            }
        }
    }
}

VOID APIENTRY
CheckEscapesA(LPSTR lpFileA, DWORD cch)
{
   if (lpFileA && *lpFileA) {
      LPWSTR lpFileW;

      lpFileW = (LPWSTR)LocalAlloc(LPTR, (cch * sizeof(WCHAR)));
      if (!lpFileW) {
         return;
      }

      SHAnsiToUnicode(lpFileA, lpFileW, cch);

      CheckEscapesW(lpFileW, cch);

      try {
         SHUnicodeToAnsi(lpFileW, lpFileA, cch);
      } except(EXCEPTION_EXECUTE_HANDLER) {
         LocalFree(lpFileW);
         return;
      }

      LocalFree(lpFileW);
   }

   return;
}

// Hooks into common dialog to allow size of selected files to be displayed.
BOOL APIENTRY
LocateHookProc(
   HWND hDlg,
   UINT uiMessage,
   WPARAM wParam,
   LONG lParam)
{
   WCHAR szTemp[40];
   WORD wID;

   switch (uiMessage) {
   case WM_INITDIALOG:
           PostMessage(hDlg, WM_COMMAND, ctlLast+1, 0L);
           break;

   case WM_COMMAND:
      switch (GET_WM_COMMAND_ID(wParam, lParam)) {
         case ctlLast+1:
            GetDlgItemText(hDlg, edt1, szTemp, ARRAYSIZE(szTemp));
            if (SendDlgItemMessage(hDlg, lst1, LB_FINDSTRING, (WPARAM)-1,
                  (LONG_PTR)(LPSTR)szTemp) >= 0) {
               wID = IDS_PROGFOUND;
            } else {
               wID = IDS_PROGNOTFOUND;
            }
            LoadString(HINST_THISDLL, wID, szTemp, ARRAYSIZE(szTemp));
            SetDlgItemText(hDlg, ctlLast+2, szTemp);
            break;

         case lst2:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
               PostMessage(hDlg, WM_COMMAND, ctlLast+1, 0L);
               break;

         case cmb2:
            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
               case CBN_SELCHANGE:
                   PostMessage(hDlg, WM_COMMAND, ctlLast+1, 1L);
                   break;

               case CBN_CLOSEUP:
                   PostMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(cmb2,
                   GetDlgItem(hDlg, cmb2), CBN_SELCHANGE));
                   break;
                }
                break;

               case IDOK:
               case IDCANCEL:
               case IDABORT:
                  PostMessage(hDlg, WM_COMMAND, ctlLast+1, 0L);
                  break;
            }
            break;
   }
   UNREFERENCED_PARAMETER(lParam);
   return(FALSE);  // commdlg, do your thing
}

BOOL_PTR APIENTRY
FindExeDlgProcW(
   HWND hDlg,
   register UINT wMsg,
   WPARAM wParam,
   LPARAM lParam)
{
  /* Notice this is OK as a global, because it will be reloaded
   * when needed
   */
   static HANDLE hCommDlg = NULL;

   WCHAR szPath[MAX_PATH]; /* This must be the same size as lpfind->lpszPath */
   WCHAR szBuffer[MAX_PATH + 100];
   LPFINDEXE_PARAMS lpfind;
   int temp;
   LPWSTR lpTemp;

   switch (wMsg) {
      case WM_INITDIALOG:
         wBrowseHelp = RegisterWindowMessage(szCommdlgHelp);

         lpfind = (LPFINDEXE_PARAMS)lParam;

         SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpfind);

         GetDlgItemText(hDlg, IDD_TEXT1, szPath, ARRAYSIZE(szPath));
         wsprintf(szBuffer, szPath, lpfind->lpszExe, lpfind->lpszName);
         SetDlgItemText(hDlg, IDD_TEXT1, szBuffer);
         GetDlgItemText(hDlg, IDD_TEXT2, szPath, ARRAYSIZE(szPath));
         wsprintf(szBuffer, szPath, lpfind->lpszExe);
         SetDlgItemText(hDlg, IDD_TEXT2, szBuffer);

         SetDlgItemText(hDlg, IDD_PATH, lpfind->lpszPath);

         break;

      case WM_DESTROY:
         if (hCommDlg >= (HANDLE)32) {
            FreeLibrary(hCommDlg);
            hCommDlg = NULL;
         }
         break;

      case WM_COMMAND:
         switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDD_BROWSE:
               {
                  LPFNGETOPENFILENAME lpfnGetOpenFileName;
                  WCHAR szExts[MAX_EXTENSION];
                  OPENFILENAME ofn;

                  GetDlgItemText(hDlg, IDD_PATH, szBuffer, ARRAYSIZE(szBuffer));

                  lpfind = (LPFINDEXE_PARAMS)GetWindowLongPtr(hDlg, DWLP_USER);
                  wcscpy(szPath, lpfind->lpszExe);
                  SheRemoveQuotesW(szPath);

                  /* Make up a file types string
                  */
                  // BUG BUG this assumes extensions are of length 3.
                  szExts[0] = WCHAR_CAP_A;
                  szExts[1] = WCHAR_NULL;
                  szExts[2] = WCHAR_STAR;
                  szExts[3] = WCHAR_DOT;
                  szExts[4] = WCHAR_NULL;
                  if (NULL != (lpTemp=StrRChrW(szPath, NULL, WCHAR_DOT)))
                     StrCpyN(szExts+3, lpTemp, ((wcslen(lpTemp) < 60) ? wcslen(lpTemp) : 60));
                  szExts[3+wcslen(szExts+3)+1] = WCHAR_NULL;

                  ofn.lStructSize = sizeof(OPENFILENAME);
                  ofn.hwndOwner = hDlg;
                  ofn.hInstance = HINST_THISDLL;
                  ofn.lpstrFilter = L"A\0\?.?\0";   // a dummy filter
                  ofn.lpstrCustomFilter = NULL;
                  ofn.nMaxCustFilter = 0;
                  ofn.nFilterIndex = 1;
                  ofn.lpstrFile = szPath;
                  ofn.nMaxFile = sizeof(szPath);
                  ofn.lpstrInitialDir = NULL;
                  ofn.lpstrTitle = NULL;
                  ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                  OFN_ENABLETEMPLATE | OFN_SHOWHELP;
                  ofn.lCustData = (LONG_PTR) hDlg;
                  ofn.lpfnHook = NULL;    // AddFileHookProc;
                  ofn.lpTemplateName = MAKEINTRESOURCE(DLG_BROWSE);
                  ofn.nFileOffset = 0;
                  ofn.nFileExtension = 0;
                  ofn.lpstrDefExt = NULL;
                  ofn.lpstrFileTitle = NULL;

                  if (hCommDlg < (HANDLE)32 &&
                     (hCommDlg = LoadLibrary(TEXT("comdlg32.dll"))) < (HANDLE)32) {
                        CommDlgError:
                        LoadString(HINST_THISDLL, IDS_NOCOMMDLG, szBuffer, ARRAYSIZE(szBuffer));
                        GetWindowText(hDlg, szPath, ARRAYSIZE(szPath));
                        MessageBox(hDlg, szBuffer, szPath, MB_ICONHAND|MB_OK);
                        break;
                     }
                  if (!(lpfnGetOpenFileName =
                     (LPFNGETOPENFILENAME)GetProcAddress((HINSTANCE)hCommDlg,
                     (LPSTR)szGetOpenFileName)))
                     goto CommDlgError;

                  temp = (*lpfnGetOpenFileName)(&ofn);

                  if (temp) {
                     LPWSTR lpTemp;

                     lpTemp = StrRChrW(szPath, NULL, WCHAR_BSLASH);
                     *lpTemp = WCHAR_NULL;
                     SetDlgItemText(hDlg, IDD_PATH, szPath);
                  }

                  break;
               }

            case IDOK:
               {
                  HANDLE hFile;

                  lpfind = (LPFINDEXE_PARAMS)GetWindowLongPtr(hDlg, DWLP_USER);
                  if (lpfind) {
                     GetDlgItemText(hDlg, IDD_PATH, lpfind->lpszPath, MAX_PATH);

                     switch (*CharPrev(lpfind->lpszPath,
                           lpTemp=lpfind->lpszPath+lstrlen(lpfind->lpszPath))) {
                        case WCHAR_BSLASH:
                        case WCHAR_COLON:
                           break;

                        default:
                           *lpTemp++ = WCHAR_BSLASH;
                           break;
                     }

                     wcscpy(lpTemp, lpfind->lpszExe);

                     hFile = CreateFile(lpfind->lpszPath, GENERIC_EXECUTE, (FILE_SHARE_READ | FILE_SHARE_WRITE),
                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                     if (hFile == INVALID_HANDLE_VALUE) {
                        LoadString(HINST_THISDLL, IDS_STILLNOTFOUND, szPath, ARRAYSIZE(szPath));
                        wsprintf(szBuffer, szPath, lpfind->lpszPath);
                        GetWindowText(hDlg, szPath, ARRAYSIZE(szPath));
                        MessageBox(hDlg, szBuffer, szPath, MB_ICONHAND|MB_OK);
                        break;
                     }

                     WriteProfileString(TEXT("programs"), lpfind->lpszExe,
                        lpfind->lpszPath);
                  }
               }

            // fall through
            case IDCANCEL:
               EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
               break;
         }

         break;

      default:
         return FALSE;
   }

   return TRUE;
}


// Returns -1 if we found the file (and it was not in an obvious place)
// or an error code which will be returned to the app (see the error
// returns for ShellExecute)

HANDLE APIENTRY
FindAssociatedExeW(
   HWND hwnd,
   LPWSTR lpCommand,
   LPWSTR lpName)
{
   FINDEXE_PARAMS find;
   WCHAR szPath[MAX_PATH];
   WCHAR szExe[MAX_PATH];
   LPWSTR lpSpace, lpTemp;
   HANDLE hFile = NULL;
   BOOL fQuote = FALSE;


   // find the param list
   lpSpace = lpCommand;
   while (*lpSpace)
   {
       if ((*lpSpace == WCHAR_SPACE) && (!fQuote))
       {
           break;
       }
       else if (*lpSpace == WCHAR_QUOTE)
       {
           fQuote = !fQuote;
       }
       lpSpace++;
   }

   if (*lpSpace == WCHAR_SPACE) {
      *lpSpace = 0;
      wcscpy(szPath, lpCommand);
      *lpSpace = WCHAR_SPACE;
   } else {
      lpSpace = TEXT("");
      wcscpy(szPath, lpCommand);
   }
   SheRemoveQuotesW(szPath);

   /* Add ".exe" if there is no extension
    * Check if the file can be opened; if it can, then some DLL could not
    * be found during the WinExec, so return file not found
    */
   if (NULL != (lpTemp=StrRChrW(szPath, NULL, WCHAR_BSLASH))
       || NULL != (lpTemp=StrRChrW(szPath, NULL, WCHAR_COLON))) {
      ++lpTemp;
   } else {
      lpTemp = szPath;
   }

   hFile = CreateFile(szPath, GENERIC_EXECUTE, (FILE_SHARE_READ | FILE_SHARE_WRITE),
       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

   if (hFile != INVALID_HANDLE_VALUE) {
      CloseHandle(hFile);
      return((HANDLE)2);
   }

   // store the file name component
   wcscpy(szExe, lpTemp);

   // make sure there is an extension
   if (!StrChrW(szExe, WCHAR_DOT)) {
      wcscat(szExe, TEXT(".exe"));
   }

   // add back the quotes, if necessary
   CheckEscapesW(szExe, MAX_PATH);

   // look in win.ini
   GetProfileString(TEXT("programs"), szExe, TEXT(""), szPath, ARRAYSIZE(szPath));

   if (szPath[0]) {
      hFile = CreateFile(szPath, GENERIC_EXECUTE, (FILE_SHARE_READ | FILE_SHARE_WRITE),
          NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

      if (hFile != INVALID_HANDLE_VALUE) {

         CloseHandle(hFile);
         wcscat(szPath, lpSpace);       // add the parameters
         wcscpy(lpCommand, szPath);     // return the new path
         return((HANDLE)-1);
      }

      /* Strip off the file part */
      if (NULL != (lpTemp=StrRChrW(szPath, NULL, WCHAR_BSLASH))) {
         if (*CharPrev(szPath, lpTemp) == WCHAR_COLON) {
            ++lpTemp;
         }
         *lpTemp = WCHAR_NULL;
      } else if (NULL != (lpTemp=StrRChrW(szPath, NULL, WCHAR_COLON))) {
         *(lpTemp+1) = WCHAR_NULL;
      }
   } else {
      /* Prompt with the disk that Windows is on */
      GetWindowsDirectory(szPath, ARRAYSIZE(szPath)-1);
      szPath[3] = WCHAR_NULL;
   }

   find.lpszExe = szExe;
   find.lpszPath = szPath;
   find.lpszName = lpName;

   switch(DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_FINDEXE), hwnd,
         FindExeDlgProcW, (LONG_PTR)(LPFINDEXE_PARAMS)&find)) {
      case IDOK:
          wcscat(szPath, lpSpace);      // add the parameters
          wcscpy(lpCommand, szPath);    // return the new path
          return ((HANDLE)-1);

      case IDCANCEL:
          return((HANDLE)15);                   // This is the user cancel return

      default:
          return((HANDLE)2);                    // stick with the file not found
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\extract.c ===
#include "shellprv.h"
#pragma  hdrstop


#define ICON_MAGIC      0
#define ICO_MAGIC1      1
#define CUR_MAGIC1      2
#define BMP_MAGIC       ((WORD)'B'+((WORD)'M'<<8))
#define ANI_MAGIC       ((WORD)'R'+((WORD)'I'<<8))
#define ANI_MAGIC1      ((WORD)'F'+((WORD)'F'<<8))
#define ANI_MAGIC4      ((WORD)'A'+((WORD)'C'<<8))
#define ANI_MAGIC5      ((WORD)'O'+((WORD)'N'<<8))
#define MZMAGIC         ((WORD)'M'+((WORD)'Z'<<8))
#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))
#define LEMAGIC         ((WORD)'L'+((WORD)'E'<<8))

typedef struct new_exe          NEWEXE,      *LPNEWEXE;
typedef struct exe_hdr          EXEHDR,      *LPEXEHDR;
typedef struct rsrc_nameinfo    RESNAMEINFO, *LPRESNAMEINFO;
typedef struct rsrc_typeinfo    RESTYPEINFO, *LPRESTYPEINFO;
typedef struct new_rsrc         RESTABLE,    *LPRESTABLE;

#define RESOURCE_VA(x)        ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)
#define RESOURCE_SIZE(x)      ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size)
#define NUMBER_OF_SECTIONS(x) ((x)->FileHeader.NumberOfSections)

#define FCC(c0,c1,c2,c3) ((DWORD)(c0)|((DWORD)(c1)<<8)|((DWORD)(c2)<<16)|((DWORD)(c3)<<24))

#define COM_FILE        FCC('.', 'c', 'o', 'm')
#define BAT_FILE        FCC('.', 'b', 'a', 't')
#define CMD_FILE        FCC('.', 'c', 'm', 'd')
#define PIF_FILE        FCC('.', 'p', 'i', 'f')
#define LNK_FILE        FCC('.', 'l', 'n', 'k')
#define ICO_FILE        FCC('.', 'i', 'c', 'o')
#define EXE_FILE        FCC('.', 'e', 'x', 'e')

/****************************************************************************
* extract a single icon from a exe file, or get the count.
*
* If nIconIndex != -1
*  Returns:
*      The handle of the icon, if successful.
*      0, if the file does not exist or an icon with the "nIconIndex"
*         does not exist.
*      1, if the given file is not an EXE or ICO file.
*
* If nIconIndex == -1
*  Returns:
*      The number of icons in the file if successful.
*      0, if the file has no icons or isn't an icon file.
*
****************************************************************************/

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCTSTR szFileName, UINT nIconIndex)
{
    HICON hIcon;
    
    if (nIconIndex == (UINT) -1)
        hIcon = (HICON)IntToPtr( ExtractIcons(szFileName, 0, 0, 0, NULL, NULL, 0, 0) );
    else
        ExtractIcons(szFileName, nIconIndex, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), &hIcon, NULL, 1, 0);
    
    return hIcon;
}

/****************************************************************************
*
*  in:
*       lpIconPath      path of thing to extract icon for (may be an exe
*                       or something that is associated)
*       lpiIcon         icon index to use
*
*       lpIconPath      filled in with the real path where the icon came from
*       lpiIcon         filled in with the real icon index
*
*  returns:
*
* note: if the caller is the shell it returns special icons
* from within the shell.dll
*
****************************************************************************/

HICON WINAPI ExtractAssociatedIcon(HINSTANCE hInst, LPTSTR lpIconPath, WORD *lpiIcon)
{
    HICON hIcon = ExtractIcon(hInst, lpIconPath, *lpiIcon);
    
    if (hIcon == NULL)
        hIcon = SHGetFileIcon(NULL, lpIconPath, 0, SHGFI_LARGEICON);
    if (hIcon == NULL)
    {
        *lpiIcon = IDI_DOCUMENT;
        GetModuleFileName(HINST_THISDLL, lpIconPath, 128);
        hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(*lpiIcon));
    }
    
    return hIcon;
}


/****************************************************************************
*
*  extracts 1 or more icons from a file.
*
*  input:
*      szFileName          - EXE/DLL/ICO file to extract from
*      nIconIndex          - what icon to extract
*                              0 = first icon, 1=second icon, etc.
*                             -N = icon with id==N
*      phiconLarge         - place to return extracted icon(s)
*      phiconSmall         - place to return extracted icon(s) (small size)
*      nIcons              - number of icons to extract.
*
*  returns:
*      number of icons extracted, or the count of icons if phiconLarge==NULL
*
*  notes:
*      handles extraction from PE (Win32), NE (Win16), and ICO (Icon) files.
*      only Win16 3.x files are supported (not 2.x)
*
****************************************************************************/

UINT WINAPI ExtractIconExW(LPCWSTR szFileName, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    return PrivateExtractIconExW( szFileName, nIconIndex, phiconLarge, phiconSmall, nIcons );
}

UINT WINAPI ExtractIconExA(LPCSTR szFileName, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    return PrivateExtractIconExA( szFileName, nIconIndex, phiconLarge, phiconSmall, nIcons );
}

/****************************************************************************
*
*  extracts 1 or more icons from a file.
*
*  input:
*      szFileName          - EXE/DLL/ICO/CUR/ANI file to extract from
*      nIconIndex          - what icon to extract
*                              0 = first icon, 1=second icon, etc.
*                             -N = icon with id==N
*      cxIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*      cyIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*                            0,0 means extract at natural size.
*      phicon              - place to return extracted icon(s)
*      nIcons              - number of icons to extract.
*      flags               - LoadImage LR_* flags
*
*  returns:
*      if picon is NULL, number of icons in the file is returned.
*
*  notes:
*      handles extraction from PE (Win32), NE (Win16), ICO (Icon),
*      CUR (Cursor), ANI (Animated Cursor), and BMP (Bitmap) files.
*      only Win16 3.x files are supported (not 2.x)
*
*      cx/cyIcon are the size of the icon to extract, two sizes
*      can be extracted by putting size 1 in the loword and size 2 in the
*      hiword, ie MAKELONG(24, 48) would extract 24 and 48 size icons.
*      yea this is a hack. It is done so IExtractIcon::Extract
*      can be called by outside people with custom large/small icon
*      sizes that are not what the shell uses internaly.
*
****************************************************************************/

UINT WINAPI SHExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
#ifdef UNICODE
    return ExtractIcons(wszFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
#else // UNICODE
    TCHAR sz[MAX_PATH];
    
    SHUnicodeToTChar(wszFileName, sz, ARRAYSIZE(sz));
    return ExtractIcons(sz, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
#endif // UNICODE
}

UINT WINAPI ExtractIcons(LPCTSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
#ifdef UNICODE
    return PrivateExtractIconsW( szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags );
#else
    return PrivateExtractIconsA( szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags );
#endif
}

DWORD HasExtension(LPCTSTR pszPath)
{
    LPCTSTR p = PathFindExtension(pszPath);
    
    //
    //
    // PERF: BobDay - We could make this EXTKEY based like the extension
    // matching stuff elsewhere.  EXTKEY is a QWORD value so UNICODE would fit.
    //
    if (*p == TEXT('.'))
    {
#ifdef UNICODE
        WCHAR   szExt[5];
        
        lstrcpyn(szExt,p,5);
        
        if ( lstrcmpi(szExt,TEXT(".com")) == 0 ) return COM_FILE;
        if ( lstrcmpi(szExt,TEXT(".bat")) == 0 ) return BAT_FILE;
        if ( lstrcmpi(szExt,TEXT(".cmd")) == 0 ) return CMD_FILE;
        if ( lstrcmpi(szExt,TEXT(".pif")) == 0 ) return PIF_FILE;
        if ( lstrcmpi(szExt,TEXT(".lnk")) == 0 ) return LNK_FILE;
        if ( lstrcmpi(szExt,TEXT(".ico")) == 0 ) return ICO_FILE;
        if ( lstrcmpi(szExt,TEXT(".exe")) == 0 ) return EXE_FILE;
        return 0;
#else
        return *((UNALIGNED DWORD *)p) | 0x20202000;  // make lower case
#endif
    }
    else
        return 0;
    
}


/****************************************************************************
* get the EXE type of the passed file (DOS, Win16, Win32)
*
*  returns:
*      0 = not a exe of any type.
*
*      if a windows app
*          LOWORD = NE or PE
*          HIWORD = windows version 3.0, 3.5, 4.0
*
*      if a DOS app (or a .com or batch file on non-NT)
*          LOWORD = MZ
*          HIWORD = 0
*
*      if a Win32 console app (or a batch file on NT)
*          LOWORD = PE
*          HIWORD = 0
*
*  this is so similar to the Win32 API GetBinaryType() too bad Win95
*  kernel does not support it.
*
****************************************************************************/

DWORD WINAPI GetExeType(LPCTSTR szFile)
{
    HANDLE      fh;
    DWORD       dw;
    struct exe_hdr exehdr;
    struct new_exe newexe;
    FILETIME ftAccess;
    DWORD dwRead;
    
    //
    //  check for special extensions, and fail quick
    //
    switch (HasExtension(szFile))
    {
    case COM_FILE:
        // handle the case like \\server.microsoft.com
        // PERF - Bobday - This does the same operation twice, we should really
        // make PathIsUNCServerShare return a code based on what it found...
        if (PathIsUNCServer(szFile) || PathIsUNCServerShare(szFile))
            return 0;
        return MAKELONG(MZMAGIC, 0);  // DOS exe
        
    case BAT_FILE:
    case CMD_FILE:
        return MAKELONG(PEMAGIC, 0);    // NT exe (pretend)
        
    case EXE_FILE:                   // we need to open it.
        break;
        
    default:
        return 0;                    // not a exe, or if it is we dont care
    }
    
    newexe.ne_expver = 0;
    
    fh = CreateFile(szFile, GENERIC_READ | FILE_WRITE_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0, OPEN_EXISTING, 0, 0);
    
    if (fh == INVALID_HANDLE_VALUE)
    {
        //
        // We may be trying to get properties for a file on a volume where
        // we don't have write access, so try opening the file for read
        // only access.  This will mean we can't preserve the access
        // time (those calls will fail), but this is better than not returning
        // the exe type at all...
        //
        
        fh = CreateFile(szFile, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            0, OPEN_EXISTING, 0, 0);
        
        //
        // at this point if we get an INVALID_HANDLE_VALUE, we really
        // can't do much else, so now return a failure...
        //
        
        if (fh == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
    }
    
    // preserve the access time
    
    if (GetFileTime(fh, NULL, &ftAccess, NULL))
        SetFileTime(fh, NULL, &ftAccess, NULL);
    
    if (!ReadFile(fh, &exehdr, sizeof(exehdr), &dwRead, NULL) ||
        (dwRead != sizeof(exehdr)))
        goto error;
    
    if (exehdr.e_magic != EMAGIC)
        goto error;
    
    SetFilePointer(fh, exehdr.e_lfanew, NULL, FILE_BEGIN);
    ReadFile(fh,&newexe, sizeof(newexe), &dwRead, NULL);
    
    if (newexe.ne_magic == PEMAGIC)
    {
        // read the SubsystemVersion
        SetFilePointer(fh, exehdr.e_lfanew+18*4, NULL, FILE_BEGIN);
        ReadFile(fh,&dw,4, &dwRead, NULL);
        newexe.ne_expver = LOBYTE(LOWORD(dw)) << 8 | LOBYTE(HIWORD(dw));
        
        // read the Subsystem
        SetFilePointer(fh, exehdr.e_lfanew+23*4, NULL, FILE_BEGIN);
        ReadFile(fh,&dw,4, &dwRead, NULL);
        
        // if it is not a Win32 GUI app return a version of 0
        if (LOWORD(dw) != 2) // IMAGE_SUBSYSTEM_WINDOWS_GUI
            newexe.ne_expver = 0;
        
        goto exit;
    }
    else if (newexe.ne_magic == LEMAGIC)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }
    else if (newexe.ne_magic == NEMAGIC)
    {
        //
        //  we found a 'NE' it still might not be a windows
        //  app, it could be.....
        //
        //      a OS/2 app      ne_exetyp==NE_OS2
        //      a DOS4 app      ne_exetyp==NE_DOS4
        //      a VxD           ne_exetyp==DEV386
        //
        //      only treat it as a Windows app if the exetype
        //      is NE_WINDOWS or NE_UNKNOWN
        //
        if (newexe.ne_exetyp != NE_WINDOWS && newexe.ne_exetyp != NE_UNKNOWN)
        {
            newexe.ne_magic = MZMAGIC;      // just a DOS exe
            newexe.ne_expver = 0;
        }
        
        //
        //  if could also have a bogus expected windows version
        //  (treat 0 as invalid)
        //
        if (newexe.ne_expver == 0)
        {
            newexe.ne_magic = MZMAGIC;      // just a DOS exe
            newexe.ne_expver = 0;
        }
    }
    else // if (newexe.ne_magic != NEMAGIC)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }
    
exit:
    CloseHandle(fh);
    return MAKELONG(newexe.ne_magic, newexe.ne_expver);
    
error:
    CloseHandle(fh);
    return 0;
}

#define M_llseek(fh, lOff, iOrg)            SetFilePointer((HANDLE)IntToPtr( fh ), lOff, NULL, (DWORD)iOrg)
#define M_lread(fh, lpBuf, cb)              _lread((HFILE)fh, lpBuf, cb)

#define MAGIC_ICON30            0
#define MAGIC_MARKZIBO          ((WORD)'M'+((WORD)'Z'<<8))

typedef struct new_exe          NEWEXEHDR;
typedef NEWEXEHDR               *PNEWEXEHDR;

#define SEEK_FROMZERO           0
#define SEEK_FROMCURRENT        1
#define SEEK_FROMEND            2
#define NSMOVE                  0x0010
#define VER                     0x0300

#define CCHICONPATHMAXLEN 128

typedef struct
{
    HANDLE hAppInst;
    HANDLE hFileName;
    HANDLE hIconList;
    INT    nIcons;
} EXTRACTICONINFO;

EXTRACTICONINFO ExtractIconInfo = {NULL, NULL, NULL, 0};

INT nIcons;

typedef struct 
{
    HICON hIcon;
    INT   iIconId;
} MYICONINFO;

HANDLE APIENTRY InternalExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex, UINT nIcons);

HICON APIENTRY DuplicateIcon(HINSTANCE hInst, HICON hIcon)
{
    ICONINFO  IconInfo;
    
    if (!GetIconInfo(hIcon, &IconInfo))
        return NULL;
    hIcon = CreateIconIndirect(&IconInfo);
    DeleteObject(IconInfo.hbmMask);
    DeleteObject(IconInfo.hbmColor);
    
    UNREFERENCED_PARAMETER(hInst);
    return hIcon;
}

// This returns a pointer to the rsrc_nameinfo of the resource with the
// given index and type, if it is found, otherwise it returns NULL.

LPBYTE FindResWithIndex(LPBYTE lpResTable, INT iResIndex, LPBYTE lpResType)
{
    try 
    {
        LPRESTYPEINFO lpResTypeInfo = (LPRESTYPEINFO)(lpResTable + sizeof(WORD));
        
        while (lpResTypeInfo->rt_id) 
        {
            if ((lpResTypeInfo->rt_id & RSORDID) &&
                (MAKEINTRESOURCE(lpResTypeInfo->rt_id & ~RSORDID) == (LPTSTR)lpResType)) 
            {
                if (lpResTypeInfo->rt_nres > (WORD)iResIndex)
                    return((LPBYTE)(lpResTypeInfo+1) + iResIndex * sizeof(RESNAMEINFO));
                else
                    return NULL;
            }
            
            lpResTypeInfo = (LPRESTYPEINFO)((LPBYTE)(lpResTypeInfo+1) + lpResTypeInfo->rt_nres * sizeof(RESNAMEINFO));
        }
        return NULL;
    }
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return NULL;
    }
}


/* This returns the index (1-relative) of the given resource-id
* in the resource table, if it is found, otherwise it returns NULL.
*/

INT GetResIndex(LPBYTE lpResTable, INT iResId, LPBYTE lpResType)
{
    WORD w;
    LPRESNAMEINFO lpResNameInfo;
    LPRESTYPEINFO lpResTypeInfo = (LPRESTYPEINFO)(lpResTable + sizeof(WORD));
    
    while (lpResTypeInfo->rt_id)
    {
        if ((lpResTypeInfo->rt_id & RSORDID) && (MAKEINTRESOURCE(lpResTypeInfo->rt_id & ~RSORDID) == (LPTSTR)lpResType))
        {
            lpResNameInfo = (LPRESNAMEINFO)(lpResTypeInfo+1);
            for (w=0; w < lpResTypeInfo->rt_nres; w++, lpResNameInfo++)
            {
                if ((lpResNameInfo->rn_id & RSORDID) && ((lpResNameInfo->rn_id & ~RSORDID) == iResId))
                    return(w+1);
            }
            return 0;
        }
        lpResTypeInfo = (LPRESTYPEINFO)((LPBYTE)(lpResTypeInfo+1) + lpResTypeInfo->rt_nres * sizeof(RESNAMEINFO));
    }
    return 0;
}


HANDLE SimpleLoadResource(HFILE fh, LPBYTE lpResTable, INT iResIndex, LPBYTE lpResType)
{
    INT      iShiftCount;
    HICON    hIcon;
    LPBYTE            lpIcon;
    DWORD             dwSize;
    DWORD             dwOffset;
    LPRESNAMEINFO     lpResPtr;
    
    /* The first 2 bytes in ResTable indicate the amount other values should be
    * shifted left.
    */
    iShiftCount = *((WORD *)lpResTable);
    
    lpResPtr = (LPRESNAMEINFO)FindResWithIndex(lpResTable, iResIndex, lpResType);
    
    if (!lpResPtr)
        return NULL;
    
    /* Left shift the offset to form a LONG. */
    dwOffset = MAKELONG(lpResPtr->rn_offset << iShiftCount, (lpResPtr->rn_offset) >> (16 - iShiftCount));
    dwSize = lpResPtr->rn_length << iShiftCount;
    
    if (M_llseek(fh, dwOffset, SEEK_FROMZERO) == -1L)
        return NULL;
    
    if (!(hIcon = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE, dwSize)))
        return NULL;
    
    if (!(lpIcon = GlobalLock(hIcon)))
        goto SLRErr1;
    
    if (_lread(fh, (LPVOID)lpIcon, dwSize) < dwSize)
        goto SLRErr2;
    
    GlobalUnlock(hIcon);
    return hIcon;
    
SLRErr2:
    GlobalUnlock(hIcon);
SLRErr1:
    GlobalFree(hIcon);
    return NULL;
}


INT __cdecl CompareIconId(MYICONINFO *lpIconInfo1, MYICONINFO *lpIconInfo2)
{
    return lpIconInfo1->iIconId - lpIconInfo2->iIconId;
}

VOID FreeIconList(HANDLE hIconList, int iKeepIcon)
{
    MYICONINFO *lpIconList;
    INT i;
    
    if (ExtractIconInfo.hIconList == hIconList) {
        ExtractIconInfo.hIconList = NULL;
    }
    if (NULL != (lpIconList = (MYICONINFO *)GlobalLock(hIconList))) {
        for (i = 0; i < ExtractIconInfo.nIcons; i++) {
            if (i != iKeepIcon) {
                DestroyIcon((lpIconList + i)->hIcon);
            }
        }
        GlobalUnlock(hIconList);
        GlobalFree(hIconList);
    }
}

VOID FreeExtractIconInfo(INT iKeepIcon)
{
    MYICONINFO *lpIconList;
    INT i;
    
    if (ExtractIconInfo.hIconList) {
        if (NULL != (lpIconList = (MYICONINFO *)GlobalLock(ExtractIconInfo.hIconList))) {
            for (i = 0; i < ExtractIconInfo.nIcons; i++) {
                if (i != iKeepIcon) {
                    DestroyIcon((lpIconList + i)->hIcon);
                }
            }
            GlobalUnlock(ExtractIconInfo.hIconList);
        }
        GlobalFree(ExtractIconInfo.hIconList);
        ExtractIconInfo.hIconList = NULL;
    }
    
    ExtractIconInfo.hAppInst = NULL;
    ExtractIconInfo.nIcons = 0;
    
    if (ExtractIconInfo.hFileName) {
        GlobalFree(ExtractIconInfo.hFileName);
        ExtractIconInfo.hFileName = NULL;
    }
}


#ifdef UNICODE
HICON APIENTRY ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex)
{
    if (lpszExeFileName) {
        LPWSTR lpszExeFileNameW;
        WORD wLen  = lstrlenA(lpszExeFileName) + 1;
        
        if (!(lpszExeFileNameW = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (wLen * sizeof(WCHAR))))) {
            return NULL;
        } else {
            HICON hIcon;
            
            MultiByteToWideChar(CP_ACP, 0, lpszExeFileName, -1, lpszExeFileNameW, wLen-1);
            
            hIcon = ExtractIconW(hInst, lpszExeFileNameW, nIconIndex);
            
            LocalFree(lpszExeFileNameW);
            return hIcon;
            
        }
    } else {
        return NULL;
    }
}
#else
HICON APIENTRY ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
    return NULL;
}
#endif

// Returns a handle to a list of icons

#ifdef UNICODE

HANDLE APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons)
{
    UINT cIcons, uiResult, i;
    UINT * lpIDs = NULL;
    HICON * lpIcons = NULL;
    HGLOBAL hIconInfo = NULL;
    MYICONINFO *lpIconInfo = NULL;
    
    
    //
    // Determine the number of icons
    //
    
    cIcons = PtrToUlong( ExtractIconW(hInst, lpszExeFileName, (UINT)-1));
    
    if (cIcons <= 0)
        return NULL;
    
    
    //
    // Allocate space for an array of UINT's and HICON's
    //
    
    lpIDs = GlobalAlloc(GPTR, cIcons * sizeof(UINT));
    if (!lpIDs) {
        goto IconList_Exit;
    }
    
    lpIcons = GlobalAlloc(GPTR, cIcons * sizeof(HICON));
    if (!lpIcons) {
        goto IconList_Exit;
    }
    
    
    //
    // Allocate space for the array of icons
    //
    
    hIconInfo = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, cIcons * sizeof(MYICONINFO));
    if (!hIconInfo) {
        goto IconList_Exit;
    }
    
    
    //
    // This has to be GlobalLock'ed since the handle is going to
    // be passed back to the application.
    //
    
    lpIconInfo = GlobalLock(hIconInfo);
    if (!lpIconInfo) {
        goto IconList_Exit;
    }
    
    
    //
    // Call ExtractIcons to do the real work.
    //
    
    uiResult = ExtractIcons(lpszExeFileName,
        0,
        GetSystemMetrics(SM_CXICON),
        GetSystemMetrics(SM_CYICON),
        lpIcons,
        lpIDs,
        cIcons,
        0);
    
    if (uiResult <= 0) {
        goto IconList_Exit;
    }
    
    
    //
    // Loop through the icons and fill in the array.
    //
    
    for (i=0; i < cIcons; i++) {
        lpIconInfo[i].hIcon   = lpIcons[i];
        lpIconInfo[i].iIconId = lpIDs[i];
    }
    
    
    //
    // Unlock the array handle.
    //
    
    GlobalUnlock(hIconInfo);
    
    
    //
    // Clean up allocations
    //
    
    GlobalFree(lpIDs);
    GlobalFree(lpIcons);
    
    
    //
    // Success.
    //
    
    return hIconInfo;
    
    
IconList_Exit:
    
    //
    // Error case.  Clean up and return NULL
    //
    
    if (lpIconInfo)
        GlobalUnlock(hIconInfo);
    
    if (hIconInfo)
        GlobalFree(hIconInfo);
    
    if (lpIcons)
        GlobalFree(lpIcons);
    
    if (lpIDs)
        GlobalFree(lpIDs);
    
    return NULL;
}

#else  // Unicode

HANDLE APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons)
{
    return NULL;
}

#endif

HANDLE APIENTRY InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons)
{
    return NULL;
}

#ifdef UNICODE
HANDLE APIENTRY InternalExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT wIconIndex, UINT nIcons)
{
    return NULL;
}
#endif

/* ExtractVersionResource16W
* Retrieves a resource from win16 images.  Most of this code
* is stolen from ExtractIconResInfoW in ..\library\extract.c
*
* LPWSTR   lpwstrFilename - file to extract
* LPHANDLE lpData         - return buffer for handle, NULL if not needed
*
* Returns: size of buffer needed
*/

DWORD ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData)
{
    HFILE    fh;
    WORD     wMagic;
    
    INT       iTableSize;
    LPBYTE    lpResTable;
    DWORD     lOffset;
    HANDLE    hResTable;
    NEWEXEHDR NEHeader;
    HANDLE    hRes;
    DWORD     dwSize =0;
    
    //
    // Try to open the specified file.
    //
    
    fh = HandleToLong(CreateFileW(lpwstrFilename,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL));
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE)) {
        fh = HandleToLong(CreateFileW(lpwstrFilename,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE))
        return 0;
    
    //
    // Read the first two bytes in the file.
    //
    if (_lread(fh, (LPVOID)&wMagic, 2) != 2)
        goto EIExit;
    
    switch (wMagic) {
    case MAGIC_MARKZIBO:
        
        //
        // Make sure that the file is in the NEW EXE format.
        //
        if (M_llseek(fh, (LONG)0x3C, SEEK_FROMZERO) == -1L)
            goto EIExit;
        
        if (_lread(fh, (LPVOID)&lOffset, sizeof(LONG)) != sizeof(LONG))
            goto EIExit;
        
        if (lOffset == 0L)
            goto EIExit;
        
        //
        // Read in the EXE header.
        //
        if (M_llseek(fh, lOffset, SEEK_FROMZERO) == -1L)
            goto EIExit;
        
        if (_lread(fh, (LPVOID)&NEHeader, sizeof(NEWEXEHDR)) != sizeof(NEWEXEHDR))
            goto EIExit;
        
        //
        // Is it a NEW EXE?
        //
        if (NE_MAGIC(NEHeader) != NEMAGIC)
            goto EIExit;
        
        if ((NE_EXETYP(NEHeader) != NE_WINDOWS) &&
            (NE_EXETYP(NEHeader) != NE_DEV386) &&
            (NE_EXETYP(NEHeader) != NE_UNKNOWN))  /* Some Win2.X apps have NE_UNKNOWN in this field */
            goto EIExit;
        
        //
        // Are there any resources?
        //
        if (NE_RSRCTAB(NEHeader) == NE_RESTAB(NEHeader))
            goto EIExit;
        
        //
        // Allocate space for the resource table.
        //
        iTableSize = NE_RESTAB(NEHeader) - NE_RSRCTAB(NEHeader);
        hResTable = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, (DWORD)iTableSize);
        
        if (!hResTable)
            goto EIExit;
        
        //
        // Lock down the resource table.
        lpResTable = GlobalLock(hResTable);
        
        if (!lpResTable) {
            GlobalFree(hResTable);
            goto EIExit;
        }
        
        //
        // Copy the resource table into memory.
        //
        if (M_llseek(fh,
            (LONG)(lOffset + NE_RSRCTAB(NEHeader)),
            SEEK_FROMZERO) == -1) {
            
            goto EIErrExit;
        }
        
        if (_lread(fh, (LPBYTE)lpResTable, iTableSize) != (DWORD)iTableSize)
            goto EIErrExit;
        
        //
        // Simply load the specified icon.
        //
        hRes = SimpleLoadResource(fh, lpResTable, 0, (LPBYTE)RT_VERSION);
        
        if (hRes) {
            dwSize = (DWORD) GlobalSize(hRes);
            
            if (lphData) {
                
                *lphData = hRes;
            } else {
                
                GlobalFree(hRes);
            }
        }
        
EIErrExit:
        GlobalUnlock(hResTable);
        GlobalFree(hResTable);
        break;
        
    }
EIExit:
    _lclose(fh);
    
    return dwSize;
}

/*  Returns the file's format: 2 for WIndows 2.X, 3 for WIndows 3.X,        */
/*                             0 if error.                                  */
/*  Returns the handle to the Icon resource corresponding to wIconIndex     */
/*  in lphIconRes, and the size of the resource in lpwSize.                 */
/*  This is used only by Progman which needs to save the icon resource      */
/*  itself in the .GRP files (the actual icon handle is not wanted).        */
/*                                                                          */
/*  08-04-91 JohanneC      Created.                                         */

WORD APIENTRY ExtractIconResInfoW(HANDLE hInst, LPWSTR lpszFileName, WORD wIconIndex, LPWORD lpwSize, LPHANDLE lphIconRes)
{
    HFILE    fh;
    WORD     wMagic;
    BOOL     bNewResFormat;
    HANDLE   hIconDir;         /* Icon directory */
    LPBYTE   lpIconDir;
    HICON    hIcon = NULL;
    BOOL     bFormatOK = FALSE;
    INT      nIconId;
    WCHAR    szFullPath[MAX_PATH];
    int      cbPath;
    
    /* Try to open the specified file. */
    /* Try to open the specified file. */
    cbPath = SearchPathW(NULL, lpszFileName, NULL, MAX_PATH, szFullPath, NULL);
    if (cbPath == 0 || cbPath >= MAX_PATH)
        return 0;
    
    fh = HandleToLong(CreateFileW((LPCWSTR)szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE)) {
        fh = HandleToLong(CreateFileW((LPCWSTR)szFullPath, GENERIC_READ, 0, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE))
        return 0;
    
    /* Read the first two bytes in the file. */
    if (_lread(fh, (LPVOID)&wMagic, 2) != 2)
        goto EIExit;
    
    switch (wMagic) {
    case MAGIC_ICON30:
        {
            INT           i;
            LPVOID        lpIcon;
            NEWHEADER     NewHeader;
            LPNEWHEADER   lpHeader;
            LPRESDIR      lpResDir;
            RESDIRDISK    ResDirDisk;
#define MAXICONS      10
            DWORD Offsets[MAXICONS];
            
            /* Only one icon per .ICO file. */
            if (wIconIndex) {
                break;
            }
            
            /* Read the header and check if it is a valid ICO file. */
            if (_lread(fh, ((LPBYTE)&NewHeader)+2, sizeof(NEWHEADER)-2) != sizeof(NEWHEADER)-2)
                goto EICleanup1;
            
            NewHeader.Reserved = MAGIC_ICON30;
            
            /* Check if the file is in correct format */
            if (NewHeader.ResType != 1)
                goto EICleanup1;
            
            /* Allocate enough space to create a Global Directory Resource. */
            hIconDir = GlobalAlloc(GHND, (LONG)(sizeof(NEWHEADER)+NewHeader.ResCount*sizeof(RESDIR)));
            if (hIconDir == NULL)
                goto EICleanup1;
            
            if ((lpHeader = (LPNEWHEADER)GlobalLock(hIconDir)) == NULL)
                goto EICleanup2;
            
            NewHeader.ResCount = (WORD)min((int)NewHeader.ResCount, MAXICONS);
            
            // fill in this structure for user
            
            *lpHeader = NewHeader;
            
            // read in the stuff from disk, transfer it to a memory structure
            // that user can deal with
            
            lpResDir = (LPRESDIR)(lpHeader + 1);
            for (i = 0; (WORD)i < NewHeader.ResCount; i++) {
                
                if (_lread(fh, (LPVOID)&ResDirDisk, sizeof(RESDIRDISK)) < sizeof(RESDIR))
                    goto EICleanup3;
                
                Offsets[i] = ResDirDisk.Offset;
                
                *lpResDir = *((LPRESDIR)&ResDirDisk);
                lpResDir->idIcon = (WORD)(i+1);         // fill in the id
                
                lpResDir++;
            }
            
            /* Now that we have the Complete resource directory, let us find out the
            * suitable form of icon (that matches the current display driver).
            */
            lpIconDir = GlobalLock(hIconDir);
            if (!lpIconDir) {
                GlobalFree(hIconDir);
                goto EIErrExit;
            }
            wIconIndex = (WORD)(LookupIconIdFromDirectory(lpIconDir, TRUE) - 1);
            GlobalUnlock(hIconDir);
            lpResDir = (LPRESDIR)(lpHeader+1) + wIconIndex;
            
            /* Allocate memory for the Resource to be loaded. */
            if ((hIcon = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE, (DWORD)lpResDir->BytesInRes)) == NULL)
                goto EICleanup3;
            if ((lpIcon = GlobalLock(hIcon)) == NULL)
                goto EICleanup4;
            
            /* Seek to the correct place and read in the resource */
            if (M_llseek(fh, Offsets[wIconIndex], SEEK_FROMZERO) == -1L)
                goto EICleanup5;
            if (_lread(fh, (LPVOID)lpIcon, (DWORD)lpResDir->BytesInRes) < lpResDir->BytesInRes)
                goto EICleanup5;
            GlobalUnlock(hIcon);
            
            *lphIconRes = hIcon;
            *lpwSize = (WORD)lpResDir->BytesInRes;
            bFormatOK = TRUE;
            bNewResFormat = TRUE;
            goto EICleanup3;
            
EICleanup5:
            GlobalUnlock(hIcon);
EICleanup4:
            GlobalFree(hIcon);
            hIcon = (HICON)1;
EICleanup3:
            GlobalUnlock(hIconDir);
EICleanup2:
            GlobalFree(hIconDir);
EICleanup1:
            break;
        }
        
      case MAGIC_MARKZIBO:
          {
              INT           iTableSize;
              LPBYTE         lpResTable;
              DWORD         lOffset;
              HANDLE        hResTable;
              NEWEXEHDR     NEHeader;
              
              /* Make sure that the file is in the NEW EXE format. */
              if (M_llseek(fh, (LONG)0x3C, SEEK_FROMZERO) == -1L)
                  goto EIExit;
              if (_lread(fh, (LPVOID)&lOffset, sizeof(LONG)) != sizeof(LONG))
                  goto EIExit;
              if (lOffset == 0L)
                  goto EIExit;
              
              /* Read in the EXE header. */
              if (M_llseek(fh, lOffset, SEEK_FROMZERO) == -1L)
                  goto EIExit;
              if (_lread(fh, (LPVOID)&NEHeader, sizeof(NEWEXEHDR)) != sizeof(NEWEXEHDR))
                  goto EIExit;
              
              /* Is it a NEW EXE? */
              if (NE_MAGIC(NEHeader) != NEMAGIC)
                  goto EIExit;
              
              if ((NE_EXETYP(NEHeader) != NE_WINDOWS) &&
                  (NE_EXETYP(NEHeader) != NE_DEV386) &&
                  (NE_EXETYP(NEHeader) != NE_UNKNOWN))  /* Some Win2.X apps have NE_UNKNOWN in this field */
                  goto EIExit;
              
              hIcon = NULL;
              
              /* Are there any resources? */
              if (NE_RSRCTAB(NEHeader) == NE_RESTAB(NEHeader))
                  goto EIExit;
              
              /* Remember whether or not this is a Win3.0 EXE. */
              bNewResFormat = (NEHeader.ne_expver >= VER);
              
              /* Allocate space for the resource table. */
              iTableSize = NE_RESTAB(NEHeader) - NE_RSRCTAB(NEHeader);
              hResTable = GlobalAlloc(GMEM_ZEROINIT, (DWORD)iTableSize);
              if (!hResTable)
                  goto EIExit;
              
              /* Lock down the resource table. */
              lpResTable = GlobalLock(hResTable);
              if (!lpResTable) {
                  GlobalFree(hResTable);
                  goto EIExit;
              }
              
              /* Copy the resource table into memory. */
              if (M_llseek(fh, (LONG)(lOffset + NE_RSRCTAB(NEHeader)), SEEK_FROMZERO) == -1)
                  goto EIErrExit;
              if (_lread(fh, (LPBYTE)lpResTable, iTableSize) != (DWORD)iTableSize)
                  goto EIErrExit;
              
              
              /* Is this a Win3.0 EXE? */
              if (bNewResFormat) {
                  /* First, load the Icon directory. */
                  hIconDir = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_GROUP_ICON);
                  
                  if (!hIconDir)
                      goto EIErrExit;
                  lpIconDir = GlobalLock(hIconDir);
                  if (!lpIconDir) {
                      GlobalFree(hIconDir);
                      goto EIErrExit;
                  }
                  nIconId = LookupIconIdFromDirectory(lpIconDir, TRUE);
                  wIconIndex = (WORD)(GetResIndex(lpResTable, nIconId, (LPBYTE)RT_ICON) - 1);
                  GlobalUnlock(hIconDir);
                  /* We're finished with the icon directory. */
                  GlobalFree(hIconDir);
                  
                  
                  /* Now load the selected icon. */
                  *lphIconRes = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_ICON);
              }
              else {
                  /* Simply load the specified icon. */
                  *lphIconRes = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_ICON);
              }
              
              if (*lphIconRes) {
                  *lpwSize = (WORD)GlobalSize(*lphIconRes);
              }
              bFormatOK = TRUE;
              
EIErrExit:
              GlobalUnlock(hResTable);
              GlobalFree(hResTable);
              break;
          }
    }
EIExit:
    _lclose(fh);
    hInst;
    if (bFormatOK)
        return (WORD)(bNewResFormat ? 3 : 2);
    else
        return 0;
}

WORD APIENTRY ExtractIconResInfoA(HANDLE hInst, LPSTR lpszFileName, WORD wIconIndex, LPWORD lpwSize, LPHANDLE lphIconRes)
{
    if (lpszFileName) 
    {
        LPWSTR lpszFileNameW;
        WORD wLen = lstrlenA(lpszFileName) + 1;
        
        if (!(lpszFileNameW = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (wLen * sizeof(WCHAR))))) 
        {
            return 0;
        }
        else
        {
            WORD wRet;
            MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1, lpszFileNameW, wLen - 1);
            wRet = ExtractIconResInfoW(hInst, lpszFileNameW, wIconIndex, lpwSize, lphIconRes);
            
            LocalFree(lpszFileNameW);
            return wRet;
        }
    }
    else 
    {
        return 0;
    }
}


LPCWSTR HasAnyExtension(LPCWSTR lpszPath)
{
    LPCWSTR p;
    
    for (p = lpszPath + lstrlenW(lpszPath); p > lpszPath && *p != L'.' && *p != L'\\'; p--)
    {
        // do nothing
    }
    
    if (*p == L'.')
        return p+1;
    else
        return NULL;
}


//
// in:
//      lpIconPath      path of thing to extract icon for (may be an exe
//                      or something that is associated)
//      lpiIconIndex    icon index to use
//
// out:
//      lpIconPath      filled in with the real path where the icon came from
//      lpiIconIndex    filled in with the real icon index
//      lpiIconId       filled in with the icon id
//
// returns:
//      icon handle
//
// note: if the caller is progman it returns special icons from within progman
//
//
#if defined(UNICODE)

HICON APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIconIndex, LPWORD lpiIconId)
{
    WCHAR wszExePath[MAX_PATH];
    HICON hIcon;
    UINT idIcon = (UINT)-1;     // Don't know value
    BOOL fAssociated = FALSE;
    
    if ((INT)*lpiIconIndex == -1)
        return (HICON)NULL;
    
Retry:
    ExtractIcons(lpIconPath, *lpiIconIndex, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON),
        &hIcon, &idIcon, 1, 0);
    
    if (hIcon == NULL)
    {
        wszExePath[0] = TEXT('\0');
        
        FindExecutable(lpIconPath,NULL,wszExePath);
        
        //
        // If FindExecutable fails, or fAssociated
        // is true, or FindExecutable returns the
        // extact same filename it was looking for,
        // then issue the default icon from progman.
        //
        
        if (!*wszExePath || fAssociated ||
            (*wszExePath && (lstrcmpi(lpIconPath, wszExePath) == 0)))
        {
            LPTSTR lpId;
            WORD wDefIconId;
            HANDLE h;
            LPVOID p;
            //
            // Magic values from NT's old progman
            //
#define ITEMICON          7
#define DOSAPPICON        2
#define ITEMICONINDEX     6
#define DOSAPPICONINDEX   1
            
            if ( *wszExePath && (HasExtension(wszExePath) == 0) )
            {
                //
                // Generic Document icon processing
                //
                lpId = MAKEINTRESOURCE(ITEMICON);
                wDefIconId = ITEMICONINDEX;
            }
            else
            {
                //
                // Generic Program icon processing
                //
                lpId = MAKEINTRESOURCE(DOSAPPICON);
                wDefIconId = DOSAPPICONINDEX;
            }
            GetModuleFileName(hInst, lpIconPath, CCHICONPATHMAXLEN);
            /*
            * Look up the icon id from the directory.
            */
            if (NULL != (h = FindResource(hInst, lpId, RT_GROUP_ICON))) {
                h = LoadResource(hInst, h);
                p = LockResource(h);
                *lpiIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
                UnlockResource(h);
                FreeResource(h);
            }
            *lpiIconIndex = wDefIconId;
            return LoadIcon(hInst, lpId);
        }
        SheRemoveQuotes(wszExePath);
        lstrcpy(lpIconPath,wszExePath);
        fAssociated = TRUE;
        goto Retry;
    }
    
    *lpiIconId = (WORD) idIcon;    // Fill in with whatever we've found (or -1)
    
    return hIcon;
}

#else // defined(UNICODE)

HICON APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIconIndex, LPWORD lpiIconId)
{
    HICON hIcon = NULL;
    WCHAR szIconExe[MAX_PATH];
    HANDLE hIconList = NULL;
    MYICONINFO *lpIconList;
    HANDLE h;
    PBYTE p;
    DWORD dwBinaryType;
    BOOL bRet;
    int cIcons;
    
#define ITEMICON          7               // taken from progman!
#define DOSAPPICON        2
#define ITEMICONINDEX     6
#define DOSAPPICONINDEX   1
    
    if (!lpIconPath)
        return NULL;

    FreeExtractIconInfo(-1);
    
    hIcon = ExtractIconW(hInst, lpIconPath, (UINT)*lpiIconIndex);
    
    if (!hIcon) 
    {
        // lpIconPath is a windows EXE, no icons found
GenericDocument:
        FreeExtractIconInfo(-1);
        GetModuleFileNameW(hInst, lpIconPath, CCHICONPATHMAXLEN);
        // Look up the icon id from the directory.
        if (NULL != (h = FindResource(hInst, MAKEINTRESOURCE(ITEMICON), RT_GROUP_ICON))) 
        {
            h = LoadResource(hInst, h);
            if (h != NULL)
            {
                p = LockResource(h);
                if (p != NULL)
                {
                    *lpiIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
                    UnlockResource(h);
                }
                FreeResource(h);
            }
        }
        *lpiIconIndex = ITEMICONINDEX;
        return LoadIcon(hInst, MAKEINTRESOURCE(ITEMICON));
    }

    if ((int)hIcon == 1) 
    {
        // lpIconPath is not a windows EXE
        // this fills in szIconExe with the thing that would be exected
        // for lpIconPath (applying associations)
        
        FindExecutableW(lpIconPath, NULL, szIconExe);
        
        if (!*szIconExe) 
        {
            // not associated, assume things with extension are
            // programs, things without are documents
            
            if (!HasAnyExtension(lpIconPath))
                goto GenericDocument;
            else
                goto GenericProgram;
        }
        
        //
        // If FindExecutable returned an icon path with quotes, we must
        // remove them because ExtractIcon fails with quoted paths.
        //
        SheRemoveQuotesW(szIconExe);
        
        lstrcpyW(lpIconPath, szIconExe);
        
        if (!HasAnyExtension(lpIconPath))
            lstrcatW(lpIconPath, L".EXE");
        
        hIcon = ExtractIconW(hInst, lpIconPath, (UINT)*lpiIconIndex);
        if (!hIcon)
            goto GenericDocument;
        
        if ((int)hIcon == 1) 
        {
            // this is a DOS exe
GenericProgram:
            FreeExtractIconInfo(-1);
            GetModuleFileNameW(hInst, lpIconPath, CCHICONPATHMAXLEN);
            // Look up the icon id from the directory.
            if (NULL != (h = FindResource(hInst, MAKEINTRESOURCE(DOSAPPICON), RT_GROUP_ICON))) 
            {
                h = LoadResource(hInst, h);
                if (h != NULL)
                {
                    p = LockResource(h);
                    if ( p != NULL)
                    {
                        *lpiIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
                        UnlockResource(h);
                    }
                    FreeResource(h);
                }
            }
            *lpiIconIndex = DOSAPPICONINDEX;
            return LoadIcon(hInst, MAKEINTRESOURCE(DOSAPPICON));
        }
        else 
        {
            goto GotIcon;
        }
    }
    else 
    {
GotIcon:
        bRet = GetBinaryTypeW(lpIconPath, &dwBinaryType);
        if (bRet) 
        {
            if (dwBinaryType != SCS_32BIT_BINARY) 
            {
                *lpiIconId = *lpiIconIndex;
                return hIcon;
            }
        }
    
        ExtractIconW(hInst, lpIconPath, (UINT)-1);
    
        if (NULL == (hIconList = ExtractIconInfo.hIconList))
            return hIcon;
    
        // since the icon exe is a WIN32 app, then we must update *lpiIcon.
        if (NULL != (hIconList = InternalExtractIconListW(hInst, lpIconPath, &cIcons))) 
        {
            if (NULL != (lpIconList = (MYICONINFO *)GlobalLock(hIconList))) 
            {
                hIcon = (lpIconList + *lpiIconIndex)->hIcon;
                *lpiIconId = (lpIconList + *lpiIconIndex)->iIconId;
                GlobalUnlock(hIconList);
            }
            FreeIconList(hIconList, *lpiIconIndex);
            return hIcon;
        }
    }
    return hIcon;
}
#endif

HICON APIENTRY ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIconIndex, LPWORD lpiIconId)
{
    HICON hIcon = NULL;
    
    if (lpIconPath) 
    {
        BOOL fDefCharUsed;
        WCHAR IconPathW[MAX_PATH] = L"";
        
        MultiByteToWideChar(CP_ACP, 0, lpIconPath, -1 , (LPWSTR)IconPathW, MAX_PATH);
        hIcon = ExtractAssociatedIconExW(hInst, (LPWSTR)IconPathW, lpiIconIndex, lpiIconId);
        
        try 
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)IconPathW, -1, lpIconPath, CCHICONPATHMAXLEN,
                NULL, &fDefCharUsed);
        }
        except(EXCEPTION_EXECUTE_HANDLER) 
        {
            hIcon = NULL;
        }
    }
    return hIcon;
}

//
// in:
//      lpIconPath      path of thing to extract icon for (may be an exe
//                      or something that is associated)
//      lpiIcon         icon index to use
//
// out:
//      lpIconPath      filled in with the real path where the icon came from
//      lpiIcon         filled in with the real icon index
//
// returns:
//      icon handle
//
// note: if the caller is progman it returns special icons from within progman
//
//

#ifdef UNICODE
HICON APIENTRY ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hIcon = NULL;
    
    if (lpIconPath) 
    {
        BOOL fDefCharUsed;
        WCHAR IconPathW[MAX_PATH] = L"";
        
        MultiByteToWideChar(CP_ACP, 0, lpIconPath, -1 , (LPWSTR)IconPathW, MAX_PATH);
        hIcon = ExtractAssociatedIconW(hInst, (LPWSTR)IconPathW, lpiIcon);
        
        try 
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)IconPathW, -1, lpIconPath, CCHICONPATHMAXLEN,
                NULL, &fDefCharUsed);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            hIcon = NULL;
        }
    }
    return hIcon;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fassoc.h ===
#ifndef FASSOC_H
#define FASSOC_H

STDAPI RevertLegacyVerb(LPCWSTR pszExt, LPCWSTR pszVerb);
STDAPI RevertLegacyClass(LPCWSTR pszExt);
STDAPI OpenHandlerKeyForExtension(LPCWSTR pszExt, LPCWSTR pszHandler, HKEY *phk);
STDAPI SHAssocEnumHandlers(LPCTSTR pszExtra, IEnumAssocHandlers **ppEnumHandler);

STDAPI CTaskEnumHKCR_Create(IRunnableTask **pptask);
STDAPI GetHandlerForBinary(LPCWSTR pszPath, LPWSTR pszHandler, DWORD cchHandler);

typedef enum
{
    UASET_CLEAR         = 0,
    UASET_APPLICATION,
    UASET_PROGID,
} UASET;

STDAPI UserAssocSet(UASET set, LPCWSTR pszExt, LPCWSTR pszSet);

//  helper class for using IAssocHandler
//  consumed by both fsassoc.cpp and openwith.cpp
class CAppInfo
{
public:
    CAppInfo(IAssocHandler *pah)
        : _pah(pah), _iIcon(-1)
    {
        _pah->AddRef();
    }

    ~CAppInfo()
    {
        if (_pszName)
            CoTaskMemFree(_pszName);
        if (_pszUIName)
            CoTaskMemFree(_pszUIName);

        _pah->Release();
    }

    BOOL Init()
    {
        return SUCCEEDED(_pah->GetName(&_pszName))
            && SUCCEEDED(_pah->GetUIName(&_pszUIName))
            && -1 != IconIndex();
    }
    
    IAssocHandler *Handler() { return _pah; }
    LPCWSTR Name() { return _pszName;}
    LPCWSTR UIName() { return _pszUIName;}
    int IconIndex()
    {
        CSmartCoTaskMem<WCHAR> pszIcon;
        int iIndex;
        if (_iIcon == -1 && SUCCEEDED(_pah->GetIconLocation(&pszIcon, &iIndex)))
        {
            _iIcon = Shell_GetCachedImageIndex(pszIcon, iIndex, 0);
            if (-1 == _iIcon)
            {
                _iIcon = Shell_GetCachedImageIndex(c_szShell32Dll, II_APPLICATION, 0);
            }
        }
        return _iIcon;
    }
            
protected:
    IAssocHandler *_pah;
    LPWSTR _pszName;
    LPWSTR _pszUIName;
    int _iIcon;
};

#endif //FASSOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fassoc.cpp ===
//
//  fassoc.cpp
//
//     IQueryAssociations shell implementations
//
// New storage - move this to a simple database if possible
// 
//  ****************************** User Customizations ********************************
//
// HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts    
//      |
//      |+ ".ext"  // the extension that has been customized
//      |   |- "Application" = "UserNotepad.AnyCo.1"
//      |   |+ "OpenWithList"   //  MRU for the Open With ctx menu
//      |
//    _ ...
//
//
//  ****************************** NoRoam Store **************************
//
// HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\NoRoam    
//      |
//      |+ ".ext"  (the extension that has been customized)
//      |   |- Application = "UserNotepad.AnyCo.1"
//      |
//    _ ...
//
// ***************************** Handlers **************************************
// (store detailed per handler file association info)
//
// HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\NoRoam\Associations
//    |


#include "shellprv.h"
#include <shpriv.h>
#include "clsobj.h"
#include <shstr.h>
#include <msi.h>
#include "fassoc.h"
#include <runtask.h>

BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut)
{
    DWORD cchBase = lstrlen(pszBase);

    //  +1 is one for the whack
    if (cchOut > cchBase + lstrlen(pszAppend) + 1)
    {
        StrCpy(pszOut, pszBase);
        pszOut+=cchBase;
        *pszOut++ = TEXT('\\');
        StrCpy(pszOut, pszAppend);
        return TRUE;
    }
    return FALSE;
}

STDAPI UserAssocSet(UASET set, LPCWSTR pszExt, LPCWSTR pszSet)
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, pszExt, TRUE);
    if (hk)
    {
        //  we should always clear
        SHDeleteValue(hk, NULL, L"Application");
        SHDeleteValue(hk, NULL, L"Progid");

        switch (set)
        {
        case UASET_APPLICATION:
            SHSetValue(hk, NULL, L"Application", REG_SZ, pszSet, CbFromCch(lstrlen(pszSet)+1));
            break;

        case UASET_PROGID:
            SHSetValue(hk, NULL, L"Progid", REG_SZ, pszSet, CbFromCch(lstrlen(pszSet)+1));
            break;
        }
        RegCloseKey(hk);
        return S_OK;
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

void _MakeApplicationsKey(LPCTSTR pszApp, LPTSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(TEXT("Applications"), pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

DWORD _OpenApplicationKey(LPCWSTR pszApp, HKEY *phk, BOOL fCheckCommand = FALSE)
{
    //  look direct
    //  then try indirecting
    //  then try appending .exe
    WCHAR sz[MAX_PATH];
    _MakeApplicationsKey(pszApp, sz, ARRAYSIZE(sz));
    DWORD err = RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, phk);
    if (err == ERROR_SUCCESS && fCheckCommand)
    {
        DWORD cch;
        if (ERROR_SUCCESS == SHQueryValueEx(*phk, TEXT("NoOpenWith"), NULL, NULL, NULL, NULL)
        || FAILED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, *phk, NULL, NULL, &cch)))
        {
            err = ERROR_ACCESS_DENIED;
            RegCloseKey(*phk);
            *phk = NULL;
        }
    }
    return err;
}

STDAPI UserAssocOpenKey(LPCWSTR pszExt, HKEY *phk)
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, pszExt, FALSE);
    DWORD err = 0;
    if (hk)
    {
        WCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        //  first check for a progid
        err = SHGetValue(hk, NULL, L"Progid", NULL, sz, &cb);
        if (err == ERROR_SUCCESS)
        {
            err = RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, phk);
            cb = sizeof(sz);
            //  maybe need to map to CurVer??
        }

        if (err != ERROR_SUCCESS)
        {
            err = SHGetValue(hk, NULL, L"Application", NULL, sz, &cb);
            if (err == ERROR_SUCCESS)
            {
                err = _OpenApplicationKey(sz, phk);
            }
        }

        RegCloseKey(hk);
    }
    else
        err = GetLastError();

    return HRESULT_FROM_WIN32(err);
}

class CVersion
{
public:
    CVersion(LPCWSTR psz) : _pVer(0), _hrInit(S_FALSE) { StrCpyNW(_szPath, psz, ARRAYSIZE(_szPath)); }
    ~CVersion() { if (_pVer) LocalFree(_pVer); }

    HRESULT QueryStringValue(LPCWSTR pszValue, LPWSTR pszOut, DWORD cch);
private:
    HRESULT _Init();
    HRESULT _QueryValue(WORD wLang, WORD wCP, LPCWSTR pszValue, LPWSTR pszOut, DWORD cch);

    WCHAR _szPath[MAX_PATH];
    void *_pVer;
    HRESULT _hrInit;
};

HRESULT CVersion::_Init()
{
    if (_hrInit == S_FALSE)
    {
        _hrInit = E_FAIL;
        DWORD dwAttribs;
        if (PathFileExistsAndAttributes(_szPath, &dwAttribs))
        {
            // bail in the \\server, \\server\share, and directory case or else GetFileVersionInfo() will try
            // to do a LoadLibraryEx() on the path (which will fail, but not before we seach the entire include
            // path which can take a long time)
            if (!(dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
            && !PathIsUNCServer(_szPath)
            && !PathIsUNCServerShare(_szPath))
            {
                DWORD dwHandle;
                DWORD cb = GetFileVersionInfoSizeW(_szPath, &dwHandle);
                if (cb)
                {
                    _pVer = LocalAlloc(LPTR, cb);
                    if (_pVer)
                    {
                        if (GetFileVersionInfoW(_szPath, dwHandle, cb, _pVer))
                            _hrInit = S_OK;
                    }
                }
            }
        }
    }

    return _hrInit;
}

inline BOOL IsAlphaDigit(WCHAR ch)
{
    return ((ch >= L'0' && ch <= L'9')
        || (ch >= L'A' && ch <= L'Z')
        || (ch >= L'a' && ch <= L'z'));
}

typedef struct
{
    WORD wLanguage;
    WORD wCodePage;
} XLATE;

const static XLATE s_px[] =
{
    { 0, 0x04B0 }, // MLGetUILanguage, CP_UNICODE
    { 0, 0x04E4 }, // MLGetUILanguage, CP_USASCII
    { 0, 0x0000 }, // MLGetUILanguage, NULL
    { 0x0409, 0x04B0 }, // English, CP_UNICODE
    { 0x0409, 0x04E4 }, // English, CP_USASCII
    { 0x0409, 0x0000 }, // English, NULL
//    { 0x041D, 0x04B0 }, // Swedish, CP_UNICODE
//    { 0x0407, 0x04E4 }, // German, CP_USASCII
};

HRESULT CVersion::_QueryValue(WORD wLang, WORD wCP, LPCWSTR pszValue, LPWSTR pszOut, DWORD cchOut)
{
    WCHAR szQuery[MAX_PATH];
    LPWSTR pszString;
    UINT cch;

    wnsprintfW(szQuery, ARRAYSIZE(szQuery), L"\\StringFileInfo\\%04X%04X\\%s", 
        wLang, wCP, pszValue);

    if (VerQueryValue(_pVer, szQuery, (void **) &pszString, &cch) 
    && cch && IsAlphaDigit(*pszString))
    {
        StrCpyN(pszOut, pszString, cchOut);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CVersion::QueryStringValue(LPCWSTR pszValue, LPWSTR pszOut, DWORD cchOut)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {   
        hr = E_FAIL;
        for (int i = 0; FAILED(hr) && i < ARRAYSIZE(s_px); i++)
        {
            WORD wL = s_px[i].wLanguage ? s_px[i].wLanguage : MLGetUILanguage();
            hr = _QueryValue(wL, s_px[i].wCodePage, pszValue, pszOut, cchOut);
        }

        if (FAILED(hr))
        {
            // Try first language this supports
            XLATE *px;
            UINT cch;
            if (VerQueryValue(_pVer, TEXT("\\VarFileInfo\\Translation"), (void **)&px, &cch) && cch)
            {
                hr = _QueryValue(px[0].wLanguage, px[0].wCodePage, pszValue, pszOut, cchOut);
            }
        }
    }

    return hr;
}

void _TrimNonAlphaNum(LPWSTR psz)
{
    while (*psz && IsAlphaDigit(*psz))
        psz++;

    *psz = 0;
}


HKEY _OpenSystemFileAssociationsKey(LPCWSTR pszExt)
{
    WCHAR sz[MAX_PATH] = L"SystemFileAssociations\\";
    StrCatBuff(sz, pszExt, ARRAYSIZE(sz));
    HKEY hk = NULL;
    if (NOERROR != RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, &hk))
    {
        DWORD cb = sizeof(sz) - sizeof(L"SystemFileAssociations\\");
        if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszExt, L"PerceivedType", NULL, sz+ARRAYSIZE(L"SystemFileAssociations\\")-1, &cb))
        {
            //  if (PerceivedType != System)
            RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, &hk);
        }
    }
    return hk;
}

BOOL _IsSystemFileAssociations(LPCWSTR pszExt)
{
    HKEY hk = _OpenSystemFileAssociationsKey(pszExt);
    if (hk)
        RegCloseKey(hk);
        
    return hk != NULL;
}

class CTaskEnumHKCR : public CRunnableTask
{
public:
    CTaskEnumHKCR() : CRunnableTask(RTF_DEFAULT) {}
    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void);

private:
    virtual ~CTaskEnumHKCR() {}
    
    void _AddFromHKCR();

};

void _AddProgidForExt(LPCWSTR pszExt)
{
    WCHAR szNew[MAX_PATH];
    DWORD cb = sizeof(szNew);
    if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szNew, &cb))
    {
        WCHAR sz[MAX_PATH];
        wnsprintf(sz, ARRAYSIZE(sz), L"%s\\OpenWithProgids", pszExt);
        SKSetValue(SHELLKEY_HKCU_FILEEXTS, sz, szNew, REG_NONE, NULL, NULL);
    }
}
    
#define IsExtension(s)   (*(s) == TEXT('.'))

void CTaskEnumHKCR::_AddFromHKCR()
{
    int i;
    TCHAR szClass[MAX_PATH];   
    BOOL fInExtensions = FALSE;

    for (i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szClass, ARRAYSIZE(szClass)) == ERROR_SUCCESS; i++)
    {
        //  UNDOCUMENTED feature.  the enum is sorted,
        //  so we can just restrict ourselves to extensions 
        //  for perf and fun!
        if (fInExtensions)
        {
            if (!IsExtension(szClass))
                break;
        }
        else if (IsExtension(szClass))
        {
            fInExtensions = TRUE;
        }
        else
            continue;

        if (_IsSystemFileAssociations(szClass))
        {
            _AddProgidForExt(szClass);
        }
    }
}

HRESULT CTaskEnumHKCR::RunInitRT()
{
    //  delete something??
    _AddFromHKCR();
    return S_OK;
}

STDAPI CTaskEnumHKCR_Create(IRunnableTask **pptask)
{
    CTaskEnumHKCR *pteh = new CTaskEnumHKCR();
    if (pteh)
    {
        HRESULT hr = pteh->QueryInterface(IID_PPV_ARG(IRunnableTask, pptask));
        pteh->Release();
        return hr;
    }
    *pptask = NULL;
    return E_OUTOFMEMORY;
}
typedef enum
{
    AHTYPE_USER_APPLICATION     = -2,
    AHTYPE_ANY_APPLICATION      = -1,
    AHTYPE_UNDEFINED            = 0,
    AHTYPE_CURRENTDEFAULT,
    AHTYPE_PROGID,
    AHTYPE_APPLICATION,
} AHTYPE;

class CAssocHandler : public IAssocHandler
{
public:
    CAssocHandler() : _cRef(1) {}
    BOOL Init(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IAssocHandler methods
    STDMETHODIMP GetName(LPWSTR *ppsz);
    STDMETHODIMP GetUIName(LPWSTR *ppsz);
    STDMETHODIMP GetIconLocation(LPWSTR *ppszPath, int *pIndex);
    STDMETHODIMP IsRecommended() { return _type > AHTYPE_UNDEFINED ? S_OK : S_FALSE; }
    STDMETHODIMP MakeDefault(LPCWSTR pszDescription);
    STDMETHODIMP Exec(HWND hwnd, LPCWSTR pszFile);
    STDMETHODIMP Invoke(void *pici, PCWSTR pszFile);

protected: // methods
    ~CAssocHandler();
    
    HRESULT _Exec(SHELLEXECUTEINFO *pei);
    BOOL _IsNewAssociation();
    void _GenerateAssociateNotify();
    HRESULT _InitKey();
    void _RegisterOWL();

protected: // members
    ULONG _cRef;
    IQueryAssociations *_pqa;
    HKEY _hk;
    ASSOCF _flags;
    AHTYPE _type;
    LPWSTR _pszExt;
    LPWSTR _pszInit;
    BOOL _fRegistered;
};

STDAPI CAssocHandler::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CAssocHandler, IAssocHandler),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CAssocHandler::AddRef()
{
   return ++_cRef;
}

STDAPI_(ULONG) CAssocHandler::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;    
}

BOOL _InList(LPCWSTR pszList, LPCWSTR pszExt, WORD chDelim)
{
    LPCWSTR pszMatch = StrStrI(pszList, pszExt);
    while (pszMatch)
    {
        LPCWSTR pszNext = (pszMatch+lstrlen(pszExt));
        if (chDelim == *pszNext || !*pszNext)
            return TRUE;
        pszMatch = StrStrI(pszNext+1, pszExt);
    }
    return FALSE;
}

// Create a new class key, and set its shell\open\command
BOOL _CreateApplicationKey(LPCTSTR pszPath)
{
    DWORD err = ERROR_FILE_NOT_FOUND;
    if (PathFileExistsAndAttributes(pszPath, NULL))
    {
        WCHAR szKey[MAX_PATH];
        WCHAR szCmd[MAX_PATH * 2];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"Software\\Classes\\Applications\\%s\\shell\\open\\command", PathFindFileName(pszPath));
        //  if it is not an LFN app, pass unquoted args.
        wnsprintf(szCmd, ARRAYSIZE(szCmd), App_IsLFNAware(pszPath) ? L"\"%s\" \"%%1\"" : L"\"%s\" %%1", pszPath);
        err = SHSetValue(HKEY_CURRENT_USER, szKey, NULL, REG_SZ, szCmd, CbFromCchW(lstrlen(szCmd)+1));
    }
    return ERROR_SUCCESS == err;
}

BOOL CAssocHandler::Init(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit)
{
    BOOL fRet = FALSE;
    _type = type;
    _pszExt = StrDup(pszExt);

    if (pszInit)
        _pszInit = StrDup(PathFindFileName(pszInit));

    if (_pszExt && (_pszInit || !pszInit))
    {
        if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa))))
        {
            HKEY hk = NULL;
            _flags = ASSOCF_IGNOREBASECLASS;
            switch (type)
            {
            case AHTYPE_CURRENTDEFAULT:
                _flags |= ASSOCF_NOUSERSETTINGS;
                pszInit = pszExt;
                break;

            case AHTYPE_USER_APPLICATION:
            case AHTYPE_APPLICATION:
            case AHTYPE_ANY_APPLICATION:
                _OpenApplicationKey(_pszInit, &hk, TRUE);
                if (hk)
                {
                    if (type == AHTYPE_APPLICATION)
                    {
                        //  check if this type is supported
                        HKEY hkTypes;
                        if (ERROR_SUCCESS == RegOpenKeyEx(hk, TEXT("SupportedTypes"), 0, MAXIMUM_ALLOWED, &hkTypes))
                        {
                            //  the app only supports specific types
                            if (ERROR_SUCCESS != SHQueryValueEx(hkTypes, _pszExt, NULL, NULL, NULL, NULL))
                            {
                                //  this type is not supported
                                //  so it will be relegated to the not recommended list
                                RegCloseKey(hk);
                                hk = NULL;
                            }
                            RegCloseKey(hkTypes);
                        }
                    }
                }
                else if (type == AHTYPE_USER_APPLICATION)
                {
                    //  need to make up a key
                    if (_CreateApplicationKey(pszInit))
                        _OpenApplicationKey(_pszInit, &hk);
                }

                pszInit = NULL;
                _flags |= ASSOCF_INIT_BYEXENAME;
                break;

            case AHTYPE_PROGID:
            default:
                // _flags |= ...;
                break;
            }

            if (hk || pszInit)
            {
                if (SUCCEEDED(_pqa->Init(_flags, pszInit , hk, NULL)))
                {
                    WCHAR szExe[MAX_PATH];
                    DWORD cchExe = ARRAYSIZE(szExe);
                    //  we want to make sure there is something at the other end
                    fRet = SUCCEEDED(_pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, szExe, &cchExe));
                    //  however, if the EXE has been marked as superhidden, 
                    //  then the consent decree UI has hidden the app
                    //  and it should not show up under the open with either
                    if (fRet)
                    {
                        fRet = !(IS_SYSTEM_HIDDEN(GetFileAttributes(szExe)));
                    }
                }
            }

            if (hk)
                RegCloseKey(hk);
        }
    }
    return fRet;
}
    

CAssocHandler::~CAssocHandler()
{
    if (_pqa)
        _pqa->Release();
    if (_pszExt)
        LocalFree(_pszExt);
    if (_pszInit)
        LocalFree(_pszInit);
    if (_hk)
        RegCloseKey(_hk);
}
HRESULT CAssocHandler::GetName(LPWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppsz);
    }
    return hr;
}

HRESULT CAssocHandler::GetUIName(LPWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppsz);
    }
    return hr;
}
HRESULT CAssocHandler::GetIconLocation(LPWSTR *ppszPath, int *pIndex)
{
//    HRESULT hr = _pqa->GetString(0, ASSOCSTR_DEFAULTAPPICON, NULL, psz, &cchT);
//    if (FAILED(hr))
    
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppszPath);
        if (*ppszPath)
        {
            *pIndex = PathParseIconLocation(*ppszPath);
        }
    }
    return hr;
}

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid);

HRESULT CAssocHandler::_InitKey()
{
    if (!_hk)
    {
        return _pqa->GetKey(_flags, ASSOCKEY_SHELLEXECCLASS, NULL, &_hk);
    }
    return S_OK;
}

void CAssocHandler::_RegisterOWL()
{
    if (!_fRegistered && SUCCEEDED(_InitKey()))
    {
        OpenWithListRegister(0, _pszExt, NULL, _hk);
        _fRegistered = TRUE;
    }
}

HRESULT CAssocHandler::Exec(HWND hwnd, LPCWSTR pszFile)
{
    SHELLEXECUTEINFO ei = {0};    
    ei.cbSize = sizeof(ei);
    ei.hwnd = hwnd;
    ei.lpFile = pszFile;
    ei.nShow = SW_NORMAL;
    
    return _Exec(&ei);
}

HRESULT CAssocHandler::_Exec(SHELLEXECUTEINFO *pei)
{
    HRESULT hr = _InitKey();
    if (SUCCEEDED(hr))
    {
        pei->hkeyClass = _hk;
        pei->fMask |= SEE_MASK_CLASSKEY;
        
        if (ShellExecuteEx(pei))
        {
            _RegisterOWL();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}

HRESULT CAssocHandler::Invoke(void *pici, PCWSTR pszFile)
{
    SHELLEXECUTEINFO ei;    
    HRESULT hr = ICIX2SEI((CMINVOKECOMMANDINFOEX *)pici, &ei);
    ei.lpFile = pszFile;
    if (SUCCEEDED(hr))
        hr = _Exec(&ei);

    return hr;
}

BOOL CAssocHandler::_IsNewAssociation()
{
    BOOL fRet = TRUE;
    WCHAR szOld[MAX_PATH];
    WCHAR szNew[MAX_PATH];
    if (SUCCEEDED(AssocQueryString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, _pszExt, NULL, szOld, (LPDWORD)MAKEINTRESOURCE(ARRAYSIZE(szOld))))
    && SUCCEEDED(_pqa->GetString(ASSOCF_VERIFY | _flags, ASSOCSTR_EXECUTABLE, NULL, szNew, (LPDWORD)MAKEINTRESOURCE(ARRAYSIZE(szNew))))
    && (0 == lstrcmpi(szNew, szOld)))
    {
        //
        //  these have the same executable, trust 
        //  that when the exe installed itself, it did
        //  it correctly, and we dont need to overwrite 
        //  their associations with themselves :)
        //
        fRet = FALSE;
    }

    return fRet;
}

//
// This is a real hack, but for now we generate an idlist that looks
// something like: C:\*.ext which is the extension for the IDList.
// We use the simple IDList as to not hit the disk...
//
void CAssocHandler::_GenerateAssociateNotify()
{
    TCHAR szFakePath[MAX_PATH];
    LPITEMIDLIST pidl;

    GetWindowsDirectory(szFakePath, ARRAYSIZE(szFakePath));

    lstrcpy(szFakePath + 3, c_szStar);      // "C:\*"
    lstrcat(szFakePath, _pszExt);            // "C:\*.foo"
    pidl = SHSimpleIDListFromPath(szFakePath);
    if (pidl)
    {
        // Now call off to the notify function.
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, pidl, NULL);
        ILFree(pidl);
    }
}

// return true if ok to continue
HRESULT CAssocHandler::MakeDefault(LPCWSTR pszDesc)
{
    HRESULT hr = E_FAIL;
    //  if the user is choosing the existing association
    //  or if we werent able to setup an Application ,
    //  then we want to leave it alone,     
    BOOL fForceUserCustomised = (AHTYPE_CURRENTDEFAULT == _type && S_FALSE == _pqa->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL));
    if (fForceUserCustomised || _IsNewAssociation())
    {
        switch (_type)
        {
        case AHTYPE_CURRENTDEFAULT:
            //  if it is reverting to the machine default
            //  then we want to eliminate the user association
            if (!fForceUserCustomised || !_pszInit)
            {
                hr = UserAssocSet(UASET_CLEAR, _pszExt, NULL);
                break;
            }
            //  else fall through to AHTYPE_PROGID
            //  this supports overriding shimgvw's (and others?)
            //  dynamic contextmenu

        case AHTYPE_PROGID:
            hr = UserAssocSet(UASET_PROGID, _pszExt, _pszInit);
            break;

        case AHTYPE_APPLICATION:
        case AHTYPE_ANY_APPLICATION:
        case AHTYPE_USER_APPLICATION:
            //  if there is a current association 
            //  then we just customize the user portion
            //  otherwise we update 
            if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, _pszExt, NULL, NULL, NULL, NULL))
            {
                // we don't overwrite the existing association under HKCR,
                // instead, we put it under HKCU. So now shell knows the new association
                // but third party software that mimics shell or does not use ShellExecute
                // will still use the old association in HKCR, which may confuse users.
                hr = UserAssocSet(UASET_APPLICATION, _pszExt, _pszInit);
            }
            else
            {
                if (SUCCEEDED(_InitKey()))
                {
                    //  there is no current progid
                    ASSERT(lstrlen(_pszExt) > 1); // because we always skip the "." below
                    WCHAR wszProgid[MAX_PATH];
                    WCHAR szExts[MAX_PATH];
                    int iLast = StrCatChainW(szExts, ARRAYSIZE(szExts) -1, 0, _pszExt);
                    //  double null term
                    szExts[++iLast] = 0;
                    wnsprintfW(wszProgid, ARRAYSIZE(wszProgid), L"%ls_auto_file", _pszExt+1);
                    HKEY hkDst;
                    ASSOCPROGID apid = {sizeof(apid), wszProgid, pszDesc, NULL, NULL, szExts};
                    if (SUCCEEDED(AssocMakeProgid(0, _pszInit, &apid, &hkDst)))
                    {
                        hr = AssocCopyVerbs(_hk, hkDst);
                        RegCloseKey(hkDst);
                    }
                }
            }
        }

        _GenerateAssociateNotify();
        _RegisterOWL();
    }
    

    //  if the application already
    //  existed, then it will
    //  return S_FALSE;
    return (S_OK == hr);
}

HRESULT _CreateAssocHandler(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit, IAssocHandler **ppah)
{
    CAssocHandler *pah = new CAssocHandler();
    if (pah)
    {
        if (pah->Init(type, pszExt, pszInit))
        {
            *ppah = pah;
            return S_OK;
        }
        else
            pah->Release();
    }
    return E_FAIL;
}

STDAPI SHCreateAssocHandler(LPCWSTR pszExt, LPCWSTR pszApp, IAssocHandler **ppah)
{
    //  path to app/handler
    return _CreateAssocHandler(pszApp ? AHTYPE_USER_APPLICATION : AHTYPE_CURRENTDEFAULT, pszExt, pszApp, ppah);
}

#define SZOPENWITHLIST                  TEXT("OpenWithList")
#define REGSTR_PATH_EXPLORER_FILEEXTS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts")
#define _OpenWithListMaxItems()         10

class CMRUEnumHandlers 
{
public:
    CMRUEnumHandlers() : _index(0) {}
    ~CMRUEnumHandlers() { FreeMRUList(_hmru);}

    BOOL Init(LPCWSTR pszExt);
    BOOL Next();
    LPCWSTR Curr() { return _szHandler;}

protected:
    HANDLE _hmru;
    int _index;
    WCHAR _szHandler[MAX_PATH];
};

BOOL CMRUEnumHandlers::Init(LPCWSTR pszExt)
{
    TCHAR szSubKey[MAX_PATH];
    //  Build up the subkey string.
    wnsprintf(szSubKey, SIZECHARS(szSubKey), TEXT("%s\\%s\\%s"), REGSTR_PATH_EXPLORER_FILEEXTS, pszExt, SZOPENWITHLIST);

    MRUINFO mi = {sizeof(mi), _OpenWithListMaxItems(), 0, HKEY_CURRENT_USER, szSubKey, NULL};

    _hmru = CreateMRUList(&mi);
    return (_hmru != NULL);
}

BOOL CMRUEnumHandlers::Next()
{
    ASSERT(_hmru);
    return (-1 != EnumMRUListW(_hmru, _index++, _szHandler, ARRAYSIZE(_szHandler)));
}

typedef struct OPENWITHLIST
{
    HKEY hk;
    DWORD dw;
    AHTYPE type;
} OWL;
class CEnumHandlers : public IEnumAssocHandlers
{
    friend HRESULT SHAssocEnumHandlers(LPCTSTR pszExtra, IEnumAssocHandlers **ppEnumHandler);

public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumAssocHandlers methods
    STDMETHODIMP Next(ULONG celt, IAssocHandler **rgelt, ULONG *pcelt);

protected:  // methods
    // Constructor & Destructor
    CEnumHandlers() : _cRef(1) {}
    ~CEnumHandlers();

    BOOL Init(LPCWSTR pszExt);
    
    BOOL _NextDefault(IAssocHandler **ppah);
    BOOL _NextHandler(HKEY hk, DWORD *pdw, BOOL fOpenWith, IAssocHandler **ppah);
    BOOL _NextProgid(HKEY *phk, DWORD *pdw, IAssocHandler **ppah);
    BOOL _NextMru(IAssocHandler **ppah);
    BOOL _NextOpenWithList(OWL *powl, IAssocHandler **ppah);

protected:  // members
    int _cRef;
    LPWSTR _pszExt;
    HKEY _hkProgids;
    DWORD _dwProgids;
    HKEY _hkUserProgids;
    DWORD _dwUserProgids;
    CMRUEnumHandlers _mru;
    BOOL _fMruReady;
    OWL _owlExt;
    OWL _owlType;
    OWL _owlAny;
    BOOL _fCheckedDefault;
};

BOOL CEnumHandlers::Init(LPCWSTR pszExt)
{
    _AddProgidForExt(pszExt);
    _pszExt = StrDup(pszExt);
    if (_pszExt)
    {
        //  known progids
        WCHAR szKey[MAX_PATH];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithProgids", pszExt);
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_hkProgids);
        _hkUserProgids = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, szKey, FALSE);
        //  user's MRU
        _fMruReady = _mru.Init(pszExt);
        
        //  HKCR\.ext\OpenWithList
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithList", pszExt);
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_owlExt.hk);
        _owlExt.type = AHTYPE_APPLICATION;

        WCHAR sz[40];
        DWORD cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, L"PerceivedType", NULL, sz, &cb))
        {
            //  HKCR\SystemFileAssociations\type\OpenWithList
            wnsprintf(szKey, ARRAYSIZE(szKey), L"SystemFileAssociations\\%s\\OpenWithList", sz);
            RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_owlType.hk);
        }
        else
        {
            ASSERT(_owlType.hk == NULL);
        }
        _owlType.type = AHTYPE_APPLICATION;

        //  always append anytype to the end
        RegOpenKeyEx(HKEY_CLASSES_ROOT, L"Applications", 0, MAXIMUM_ALLOWED, &_owlAny.hk);
        _owlAny.type = AHTYPE_ANY_APPLICATION;

        return TRUE;
    }
    return FALSE;
}

//
//  CEnumHandlers implementation
//
CEnumHandlers::~CEnumHandlers()
{
    if (_pszExt)
        LocalFree(_pszExt);

    if (_hkProgids)
        RegCloseKey(_hkProgids);

    if (_hkUserProgids)
        RegCloseKey(_hkUserProgids);
        
    if (_owlExt.hk)
        RegCloseKey(_owlExt.hk);
    if (_owlType.hk)
        RegCloseKey(_owlType.hk);
    if (_owlAny.hk)
        RegCloseKey(_owlAny.hk);
}

STDAPI CEnumHandlers::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CEnumHandlers, IEnumAssocHandlers),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CEnumHandlers::AddRef()
{
   return ++_cRef;
}

STDAPI_(ULONG) CEnumHandlers::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;    
}

BOOL CEnumHandlers::_NextDefault(IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    if (!_fCheckedDefault && _pszExt)
    {
        WCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        //  pass the progid if we have it
        if (ERROR_SUCCESS != SHGetValue(HKEY_CLASSES_ROOT, _pszExt, NULL, NULL, sz, &cb))
            *sz = 0;

        fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_CURRENTDEFAULT, _pszExt, *sz ? sz : NULL, ppah));
        _fCheckedDefault = TRUE;
    }
    return fRet;
}

BOOL CEnumHandlers::_NextProgid(HKEY *phk, DWORD *pdw, IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (*phk && !fRet)
    {
        TCHAR szProgid[MAX_PATH];
        DWORD cchProgid = ARRAYSIZE(szProgid);
        DWORD err = RegEnumValue(*phk, *pdw, szProgid, &cchProgid, NULL, NULL, NULL, NULL);

        if (ERROR_SUCCESS == err)        
        {
            fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_PROGID, _pszExt, szProgid, ppah));
            (*pdw)++;
        }
        else
        {
            RegCloseKey(*phk);
            *phk = NULL;
        }
    }
        
    return fRet;
}

BOOL CEnumHandlers::_NextMru(IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (_fMruReady && !fRet)
    {
        if (_mru.Next())
        {
            fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_APPLICATION, _pszExt, _mru.Curr(), ppah));
        }
        else
        {
            _fMruReady = FALSE;
        }
    }
    return fRet;
}


BOOL CEnumHandlers::_NextOpenWithList(OWL *powl, IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (powl->hk && !fRet)
    {
        TCHAR szHandler[MAX_PATH];
        DWORD cchHandler = ARRAYSIZE(szHandler);
        DWORD err = RegEnumKeyEx(powl->hk, powl->dw, szHandler, &cchHandler, NULL, NULL, NULL, NULL);

        if (err == ERROR_SUCCESS)
        {
            (powl->dw)++;
            fRet = SUCCEEDED(_CreateAssocHandler(powl->type, _pszExt, szHandler, ppah));
        }
        else
        {
            RegCloseKey(powl->hk);
            powl->hk = NULL;
        }
    }
    return fRet;
}

STDAPI CEnumHandlers::Next(ULONG celt, IAssocHandler **rgelt, ULONG *pcelt)
{
    UINT cNum = 0;
    ZeroMemory(rgelt, sizeof(rgelt[0])*celt);
    while (cNum < celt && _NextDefault(&rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextProgid(&_hkProgids, &_dwProgids, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextProgid(&_hkUserProgids, &_dwUserProgids, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextMru(&rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlExt, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlType, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlAny, &rgelt[cNum]))
    {
        cNum++;
    }

    if (pcelt)
       *pcelt = cNum;

    return (0 < cNum) ? S_OK: S_FALSE;
}

//
// pszExtra:    NULL    - enumerate all handlers
//              .xxx    - enumerate handlers by file extension (we might internally map to content type)
//              Others  - not currently supported
//
STDAPI SHAssocEnumHandlers(LPCTSTR pszExt, IEnumAssocHandlers **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CEnumHandlers *penum = new CEnumHandlers();

    *ppenum = NULL;

    if (penum)
    {
        if (penum->Init(pszExt))
        {
            *ppenum = penum;
            hr = S_OK;
        }
        else
            penum->Release();
    }
    return hr;
}

   
STDAPI_(BOOL) IsPathInOpenWithKillList(LPCTSTR pszPath)
{
    // return TRUE for invalid path
    if (!pszPath || !*pszPath)
        return TRUE;

    // get file name
    BOOL fRet = FALSE;
    LPCTSTR pchFile = PathFindFileName(pszPath);
    HKEY hkey;

    //  maybe should use full path for better resolution
    if (ERROR_SUCCESS == _OpenApplicationKey(pchFile, &hkey))
    {
        //  just check for the existence of the value....
        if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoOpenWith"), NULL, NULL, NULL, NULL))
        {
            fRet = TRUE;
        }

        RegCloseKey(hkey);
    }

    LPWSTR pszKillList;
    if (!fRet && SUCCEEDED(SKAllocValue(SHELLKEY_HKLM_EXPLORER, L"FileAssociation", TEXT("KillList"), NULL, (void **)&pszKillList, NULL)))
    {
        fRet = _InList(pszKillList, pchFile, L';');
        LocalFree(pszKillList);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\executil.cpp ===
#include "shellprv.h"
#include "shlexec.h"
#include "netview.h"
extern "C" {
#include <badapps.h>
}
#include <htmlhelp.h>
#include "ole2dup.h"
#include <vdate.h>
#include <newexe.h>
#include "ids.h"

#define REGSTR_PATH_CHECKBADAPPSNEW    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps")
#define REGSTR_PATH_CHECKBADAPPS400NEW TEXT("System\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps400")
#define REGSTR_TEMP_APPCOMPATPATH      TEXT("System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility\\%s")

#define SAFE_DEBUGSTR(str)    ((str) ? (str) : "<NULL>")

HINSTANCE Window_GetInstance(HWND hwnd)
{
    DWORD idProcess;

    GetWindowThreadProcessId(hwnd, &idProcess);
    // HINSTANCEs are pointers valid only within
    // a single process, so 33 is returned to indicate success
    // as 0-32 are reserved for error.  (Actually 32 is supposed
    // to be a valid success return but some apps get it wrong.)

    return (HINSTANCE)(DWORD_PTR)(idProcess ? 33 : 0);
}

// Return TRUE if the window belongs to a 32bit or a Win4.0 app.
// NB We can't just check if it's a 32bit window
// since many apps use 16bit ddeml windows to communicate with the shell
// On NT we can.
BOOL Window_IsLFNAware(HWND hwnd)
{
    // 32-bit window
    return LOWORD(GetWindowLongPtr(hwnd,GWLP_HINSTANCE)) == 0;
}


#define COPYTODST(_szdst, _szend, _szsrc, _ulen, _ret) \
{ \
        UINT _utemp = _ulen; \
        if ((UINT)(_szend-_szdst) <= _utemp) { \
                return(_ret); \
        } \
        lstrcpyn(_szdst, _szsrc, _utemp+1); \
        _szdst += _utemp; \
}

/* Returns NULL if this is the last parm, pointer to next space otherwise
 */
LPTSTR _GetNextParm(LPCTSTR lpSrc, LPTSTR lpDst, UINT cchDst)
{
    LPCTSTR lpNextQuote, lpNextSpace;
    LPTSTR lpEnd = lpDst+cchDst-1;       // dec to account for trailing NULL
    BOOL fQuote;                        // quoted string?
    BOOL fDoubleQuote;                  // is this quote a double quote?
    VDATEINPUTBUF(lpDst, TCHAR, cchDst);

    while (*lpSrc == TEXT(' '))
        ++lpSrc;

    if (!*lpSrc)
        return(NULL);

    fQuote = (*lpSrc == TEXT('"'));
    if (fQuote)
        lpSrc++;   // skip leading quote

    for (;;)
    {
        lpNextQuote = StrChr(lpSrc, TEXT('"'));

        if (!fQuote)
        {
            // for an un-quoted string, copy all chars to first space/null

            lpNextSpace = StrChr(lpSrc, TEXT(' '));

            if (!lpNextSpace) // null before space! (end of string)
            {
                if (!lpNextQuote)
                {
                    // copy all chars to the null
                    if (lpDst)
                    {
                        COPYTODST(lpDst, lpEnd, lpSrc, lstrlen(lpSrc), NULL);
                    }
                    return NULL;
                }
                else
                {
                    // we have a quote to convert.  Fall through.
                }
            }
            else if (!lpNextQuote || lpNextSpace < lpNextQuote)
            {
                // copy all chars to the space
                if (lpDst)
                {
                    COPYTODST(lpDst, lpEnd, lpSrc, (UINT)(lpNextSpace-lpSrc), NULL);
                }
                return (LPTSTR)lpNextSpace;
            }
            else
            {
                // quote before space.  Fall through to convert quote.
            }
        }
        else if (!lpNextQuote)
        {
            // a quoted string without a terminating quote?  Illegal!
            ASSERT(0);
            return NULL;
        }

        // we have a potential quote to convert
        ASSERT(lpNextQuote);

        fDoubleQuote = *(lpNextQuote+1) == TEXT('"');
        if (fDoubleQuote)
            lpNextQuote++;      // so the quote is copied

        if (lpDst)
        {
            COPYTODST(lpDst, lpEnd, lpSrc, (UINT) (lpNextQuote-lpSrc), NULL);
        }

        lpSrc = lpNextQuote+1;

        if (!fDoubleQuote)
        {
            // we just copied the rest of this quoted string.  if this wasn't
            // quoted, it's an illegal string... treat the quote as a space.
            ASSERT(fQuote);
            return (LPTSTR)lpSrc;
        }
    }
}

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

// Returns TRUE is app is LFN aware.
// This assumes all Win32 apps are LFN aware.

BOOL App_IsLFNAware(LPCTSTR pszFile)
{
    BOOL fRet = FALSE;
    
    // Assume Win 4.0 apps and Win32 apps are LFN aware.
    DWORD dw = GetExeType(pszFile);
    // TraceMsg(TF_SHELLEXEC, "s.aila: %s %s %x", pszFile, szFile, dw);
    if ((LOWORD(dw) == PEMAGIC) || ((LOWORD(dw) == NEMAGIC) && (HIWORD(dw) >= 0x0400)))
    {
        TCHAR sz[MAX_PATH];
        PathToAppPathKey(pszFile, sz, ARRAYSIZE(sz));
        
        fRet = (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("UseShortName"), NULL, NULL, NULL));
    }
    
    return fRet;
}

// apps can tag themselves in a way so we know we can pass an URL on the cmd
// line. this uses the existance of a value called "UseURL" under the
// App Paths key in the registry associated with the app that is passed in.

// pszPath is the path to the exe

BOOL DoesAppWantUrl(LPCTSTR pszPath)
{
    TCHAR sz[MAX_PATH];
    PathToAppPathKey(pszPath, sz, ARRAYSIZE(sz));
    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("UseURL"), NULL, NULL, NULL));
}

BOOL _AppIsLFNAware(LPCTSTR pszFile)
{
    TCHAR szFile[MAX_PATH];

    // Does it look like a DDE command?
    if (pszFile && *pszFile && (*pszFile != TEXT('[')))
    {
        // Nope - Hopefully just a regular old command %1 thing.
        lstrcpyn(szFile, pszFile, ARRAYSIZE(szFile));
	    LPTSTR pszArgs = PathGetArgs(szFile);
        if (*pszArgs)
            *(pszArgs - 1) = TEXT('\0');
        PathRemoveBlanks(szFile);   // remove any blanks that may be after the command
        PathUnquoteSpaces(szFile);
        return App_IsLFNAware(szFile);
    }
    return FALSE;
}

// in:
//      lpFile      exe name (used for %0 or %1 in replacement string)
//      lpFrom      string template to sub params and file into "excel.exe %1 %2 /n %3"
//      lpParams    parameter list "foo.txt bar.txt"
// out:
//      lpTo    output string with all parameters replaced
//
// supports:
//      %*      replace with all parameters
//      %0, %1  replace with file
//      %n      use nth parameter
//
// replace parameter placeholders (%1 %2 ... %n) with parameters
//
UINT ReplaceParameters(LPTSTR lpTo, UINT cchTo, LPCTSTR lpFile,
                       LPCTSTR lpFrom, LPCTSTR lpParms, int nShow, DWORD * pdwHotKey, BOOL fLFNAware,
                       LPCITEMIDLIST lpID, LPITEMIDLIST *ppidlGlobal)
{
    int i;
    TCHAR c;
    LPCTSTR lpT;
    TCHAR sz[MAX_PATH];
    BOOL fFirstParam = TRUE;
    LPTSTR lpEnd = lpTo + cchTo - 1;       // dec to allow trailing NULL
    LPTSTR pToOrig = lpTo;
    
    for (; *lpFrom; lpFrom++)
    {
        if (*lpFrom == TEXT('%'))
        {
            switch (*(++lpFrom))
            {
            case TEXT('~'): // Copy all parms starting with nth (n >= 2 and <= 9)
                c = *(++lpFrom);
                if (c >= TEXT('2') && c <= TEXT('9'))
                {
                    for (i = 2, lpT = lpParms; i < c-TEXT('0') && lpT; i++)
                    {
                        lpT = _GetNextParm(lpT, NULL, 0);
                    }
                    
                    if (lpT)
                    {
                        COPYTODST(lpTo, lpEnd, lpT, lstrlen(lpT), SE_ERR_ACCESSDENIED);
                    }
                }
                else
                {
                    lpFrom -= 2;            // Backup over %~ and pass through
                    goto NormalChar;
                }
                break;
                
            case TEXT('*'): // Copy all parms
                if (lpParms)
                {
                    COPYTODST(lpTo, lpEnd, lpParms, lstrlen(lpParms), SE_ERR_ACCESSDENIED);
                }
                break;
                
            case TEXT('0'):
            case TEXT('1'):
                // %0, %1, copy the file name
                // If the filename comes first then we don't need to convert it to
                // a shortname. If it appears anywhere else and the app is not LFN
                // aware then we must.
                if (!(fFirstParam || fLFNAware || _AppIsLFNAware(pToOrig)) &&
                    GetShortPathName(lpFile, sz, ARRAYSIZE(sz)) > 0)
                {
                    TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Getting short version of path.");
                    COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                }
                else
                {
                    TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Using long version of path.");
                    COPYTODST(lpTo, lpEnd, lpFile, lstrlen(lpFile), SE_ERR_ACCESSDENIED);
                }
                break;
                
            case TEXT('2'):
            case TEXT('3'):
            case TEXT('4'):
            case TEXT('5'):
            case TEXT('6'):
            case TEXT('7'):
            case TEXT('8'):
            case TEXT('9'):
                for (i = *lpFrom-TEXT('2'), lpT = lpParms; lpT; --i)
                {
                    if (i)
                        lpT = _GetNextParm(lpT, NULL, 0);
                    else
                    {
                        sz[0] = '\0'; // ensure a valid string, regardless of what happens within _GetNextParm
                        _GetNextParm(lpT, sz, ARRAYSIZE(sz));
                        COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                        break;
                    }
                }
                break;
                
            case TEXT('s'):
            case TEXT('S'):
                wsprintf(sz, TEXT("%ld"), nShow);
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('h'):
            case TEXT('H'):
                wsprintf(sz, TEXT("%X"), pdwHotKey ? *pdwHotKey : 0);
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                if (pdwHotKey)
                    *pdwHotKey = 0;
                break;
                
                // Note that a new global IDList is created for each
            case TEXT('i'):
            case TEXT('I'):
                // Note that a single global ID list is created and used over
                // again, so that it may be easily destroyed if anything
                // goes wrong
                if (ppidlGlobal)
                {
                    if (lpID && !*ppidlGlobal)
                    {
                        *ppidlGlobal = (LPITEMIDLIST)SHAllocShared(lpID,ILGetSize(lpID),GetCurrentProcessId());
                        if (!*ppidlGlobal)
                        {
                            return SE_ERR_OOM;
                        }
                    }
                    wsprintf(sz, TEXT(":%ld:%ld"), *ppidlGlobal,GetCurrentProcessId());
                }
                else
                {
                    lstrcpy(sz,TEXT(":0"));
                }
                
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('l'):
            case TEXT('L'):
                // Like %1 only using the long name.
                // REVIEW UNDONE IANEL Remove the fFirstParam and fLFNAware stuff as soon as this
                // is up and running.
                TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Using long version of path.");
                COPYTODST(lpTo, lpEnd, lpFile, lstrlen(lpFile), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('D'):
            case TEXT('d'):
                {
                    // %D gives the display name of an object.
                    if (lpID && SUCCEEDED(SHGetNameAndFlags(lpID, SHGDN_FORPARSING, sz, ARRAYSIZE(sz), NULL)))
                    {
                        COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                    }
                    else
                        return SE_ERR_ACCESSDENIED;
                    
                    break;
                }
                
            default:
                goto NormalChar;
              }
              // TraceMsg(TF_SHELLEXEC, "s.rp: Past first param (1).");
              fFirstParam = FALSE;
        }
        else
        {
NormalChar:
        // not a "%?" thing, just copy this to the destination
        
        if (lpEnd-lpTo < 2)
        {
            // Always check for room for DBCS char
            return(SE_ERR_ACCESSDENIED);
        }
        
        *lpTo++ = *lpFrom;
        // Special case for things like "%1" ie don't clear the first param flag
        // if we hit a dbl-quote.
        if (*lpFrom != TEXT('"'))
        {
            // TraceMsg(TF_SHELLEXEC, "s.rp: Past first param (2).");
            fFirstParam = FALSE;
        }
        else if (IsDBCSLeadByte(*lpFrom))
        {
            *lpTo++ = *(++lpFrom);
        }
        
        }
    }
    
    // We should always have enough room since we dec'ed cchTo when determining
    // lpEnd
    *lpTo = 0;
    
    // This means success
    return(0);
}

HWND ThreadID_GetVisibleWindow(DWORD dwID)
{
    HWND hwnd;
    for (hwnd = GetWindow(GetDesktopWindow(), GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        DWORD dwIDTmp = GetWindowThreadProcessId(hwnd, NULL);
        TraceMsg(TF_SHELLEXEC, "s.ti_gvw: Hwnd %x Thread ID %x.", hwnd, dwIDTmp);
        if (IsWindowVisible(hwnd) && (dwIDTmp == dwID))
        {
            TraceMsg(TF_SHELLEXEC, "s.ti_gvw: Found match %x.", hwnd);
            return hwnd;
        }
    }
    return NULL;
}

void ActivateHandler(HWND hwnd, DWORD_PTR dwHotKey)
{
    ASSERT(hwnd);
    hwnd = GetTopParentWindow(hwnd); // returns non-NULL for any non-NULL input
    HWND hwndT = GetLastActivePopup(hwnd); // returns non-NULL for any non-NULL input
    if (!IsWindowVisible(hwndT))
    {
        DWORD dwID = GetWindowThreadProcessId(hwnd, NULL);
        TraceMsg(TF_SHELLEXEC, "ActivateHandler: Hwnd %x Thread ID %x.", hwnd, dwID);
        ASSERT(dwID);
        // Find the first visible top level window owned by the
        // same guy that's handling the DDE conversation.
        hwnd = ThreadID_GetVisibleWindow(dwID);
        if (hwnd)
        {
            hwndT = GetLastActivePopup(hwnd);
            if (IsIconic(hwnd))
            {
                TraceMsg(TF_SHELLEXEC, "ActivateHandler: Window is iconic, restoring.");
                ShowWindow(hwnd,SW_RESTORE);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "ActivateHandler: Window is normal, bringing to top.");
                BringWindowToTop(hwnd);
                if (hwndT && hwnd != hwndT)
                    BringWindowToTop(hwndT);

            }

            // set the hotkey
            if (dwHotKey) 
            {
                SendMessage(hwnd, WM_SETHOTKEY, dwHotKey, 0);
            }
        }
    }
}

// Some apps when run no-active steal the focus anyway so we
// we set it back to the previously active window.
void FixActivationStealingApps(HWND hwndOldActive, int nShow)
{
    HWND hwndNew;
    if (nShow == SW_SHOWMINNOACTIVE && (hwndNew = GetForegroundWindow()) != hwndOldActive && IsIconic(hwndNew))
        SetForegroundWindow(hwndOldActive);
}

BOOL FindExistingDrv(LPCTSTR pszUNCRoot, LPTSTR pszLocalName)
{
    int iDrive;

    for (iDrive = 0; iDrive < 26; iDrive++) {
        if (IsRemoteDrive(iDrive)) {
            TCHAR szDriveName[3];
            DWORD cb = MAX_PATH;
            szDriveName[0] = (TCHAR)iDrive + (TCHAR)TEXT('A');
            szDriveName[1] = TEXT(':');
            szDriveName[2] = 0;
            SHWNetGetConnection(szDriveName, pszLocalName, &cb);
            if (lstrcmpi(pszUNCRoot, pszLocalName) == 0) {
                lstrcpy(pszLocalName, szDriveName);
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

// Returns whether the given net path exists.  This fails for NON net paths.
//

BOOL NetPathExists(LPCTSTR lpszPath, DWORD *lpdwType)
{
    BOOL fResult = FALSE;
    NETRESOURCE nr;
    LPTSTR lpSystem;
    DWORD dwRes, dwSize = 1024;
    void * lpv;

    if (!lpszPath || !*lpszPath)
        return FALSE;

    lpv = (void *)LocalAlloc(LPTR, dwSize);
    if (!lpv)
        return FALSE;

TryWNetAgain:
    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwType = RESOURCETYPE_ANY;
    nr.dwDisplayType = 0;
    nr.lpLocalName = NULL;
    nr.lpRemoteName = (LPTSTR)lpszPath;
    nr.lpProvider = NULL;
    nr.lpComment = NULL;
    dwRes = WNetGetResourceInformation(&nr, lpv, &dwSize, &lpSystem);

    // If our buffer wasn't big enough, try a bigger buffer...
    if (dwRes == WN_MORE_DATA)
    {
        void * tmp = LocalReAlloc(lpv, dwSize, LMEM_MOVEABLE);
        if (!tmp)
        {
            LocalFree(lpv);
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        lpv = tmp;
        goto TryWNetAgain;
    }

    fResult = (dwRes == WN_SUCCESS);

    if (fResult && lpdwType)
        *lpdwType = ((LPNETRESOURCE)lpv)->dwType;

    LocalFree(lpv);

    return fResult;
}


HRESULT _CheckExistingNet(LPCTSTR pszFile, LPCTSTR pszRoot, BOOL fPrint)
{
    //
    // This used to be a call to GetFileAttributes(), but
    // GetFileAttributes() doesn't handle net paths very well.
    // However, we need to be careful, because other shell code
    // expects SHValidateUNC to return false for paths that point
    // to print shares.
    //
    HRESULT hr = S_FALSE;

    if (!PathIsRoot(pszFile))
    {
        // if we are checking for a printshare, then it must be a Root
        if (fPrint)
            hr = E_FAIL;
        else if (PathFileExists(pszFile))
            hr = S_OK;
    }

    if (S_FALSE == hr)
    {
        DWORD dwType;
        
        if (NetPathExists(pszRoot, &dwType))
        {
            if (fPrint ? dwType != RESOURCETYPE_PRINT : dwType == RESOURCETYPE_PRINT)
                hr = E_FAIL;
            else
                hr = S_OK;
        }
        else if (-1 != GetFileAttributes(pszRoot))
        {
            //
            // IE 4.01 SP1 QFE #104.  GetFileAttributes now called
            // as a last resort become some clients often fail when using
            // WNetGetResourceInformation.  For example, many NFS clients were
            // broken because of this.
            //
            hr = S_OK;
        }
    }

    if (hr == E_FAIL)
        SetLastError(ERROR_NOT_SUPPORTED);
        
    return hr;
}

HRESULT _CheckNetUse(HWND hwnd, LPTSTR pszShare, UINT fConnect, LPTSTR pszOut, DWORD cchOut)
{
    NETRESOURCE rc;
    DWORD dw, err;
    DWORD dwRedir = CONNECT_TEMPORARY;

    if (!(fConnect & VALIDATEUNC_NOUI))
        dwRedir |= CONNECT_INTERACTIVE;

    if (fConnect & VALIDATEUNC_CONNECT)
        dwRedir |= CONNECT_REDIRECT;

    // VALIDATE_PRINT happens only after a failed attempt to validate for
    // a file. That previous attempt will have given the option to
    // connect to other media -- don't do it here or the user will be
    // presented with the same dialog twice when the first one is cancelled.
    if (fConnect & VALIDATEUNC_PRINT)
        dwRedir |= CONNECT_CURRENT_MEDIA;

    rc.lpRemoteName = pszShare;
    rc.lpLocalName = NULL;
    rc.lpProvider = NULL;
    rc.dwType = (fConnect & VALIDATEUNC_PRINT) ? RESOURCETYPE_PRINT : RESOURCETYPE_DISK;

    err = WNetUseConnection(hwnd, &rc, NULL, NULL, dwRedir, pszOut, &cchOut, &dw);

    TraceMsg(TF_SHELLEXEC, "SHValidateUNC WNetUseConnection(%s) returned %x", pszShare, err);

    if (err)
    {
        SetLastError(err);
        return E_FAIL;
    }
    else if (fConnect & VALIDATEUNC_PRINT)        
    {
        //  just because WNetUse succeeded, doesnt mean 
        //  NetPathExists will.  if it fails then 
        //  we shouldnt succeed this call regardless
        //  because we are only interested in print shares.
        if (!NetPathExists(pszShare, &dw)
        || (dw != RESOURCETYPE_PRINT))
        {
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
        }
    }

    return S_OK;
}

//
// SHValidateUNC
//
//  This function validates a UNC path by calling WNetAddConnection3.
//  It will make it possible for the user to type a remote (RNA) UNC
//  app/document name from Start->Run dialog.
//
//  fConnect    - flags controling what to do
//
//    VALIDATEUNC_NOUI                // dont bring up stinking UI!
//    VALIDATEUNC_CONNECT             // connect a drive letter
//    VALIDATEUNC_PRINT               // validate as print share instead of disk share
//
BOOL WINAPI SHValidateUNC(HWND hwndOwner, LPTSTR pszFile, UINT fConnect)
{
    HRESULT hr;
    TCHAR  szShare[MAX_PATH];
    BOOL fPrint = (fConnect & VALIDATEUNC_PRINT);

    ASSERT(PathIsUNC(pszFile));
    ASSERT((fConnect & ~VALIDATEUNC_VALID) == 0);
    ASSERT((fConnect & VALIDATEUNC_CONNECT) ? !fPrint : TRUE);

    lstrcpyn(szShare, pszFile, ARRAYSIZE(szShare));

    if (!PathStripToRoot(szShare))
    {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (fConnect & VALIDATEUNC_CONNECT)
        hr = S_FALSE;
    else
        hr = _CheckExistingNet(pszFile, szShare, fPrint);

    if (S_FALSE == hr)
    {
        TCHAR  szAccessName[MAX_PATH];

        if (!fPrint && FindExistingDrv(szShare, szAccessName))
        {
            hr = S_OK;
        }
        else 
            hr = _CheckNetUse(hwndOwner, szShare, fConnect, szAccessName, SIZECHARS(szAccessName));


        if (S_OK == hr && !fPrint)
        {
            StrCatBuff(szAccessName, pszFile + lstrlen(szShare), ARRAYSIZE(szAccessName));
            // The name should only get shorter, so no need to check length
            lstrcpy(pszFile, szAccessName);

            // Handle the root case
            if (pszFile[2] == TEXT('\0'))
            {
                pszFile[2] = TEXT('\\');
                pszFile[3] = TEXT('\0');
            }

            hr = _CheckExistingNet(pszFile, szShare, FALSE);
        }
    }

    return (hr == S_OK);
}

HINSTANCE WINAPI RealShellExecuteExA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile,
                                   LPCSTR lpArgs, LPCSTR lpDir, LPSTR lpResult,
                                   LPCSTR lpTitle, LPSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess,
                                   DWORD dwFlags)
{
    SHELLEXECUTEINFOA sei = { sizeof(SHELLEXECUTEINFOA), SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};

    TraceMsg(TF_SHELLEXEC, "RealShellExecuteExA(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX, %d)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess, dwFlags);

    // Pass along the lpReserved parameter to the new process
    if (lpReserved)
    {
        sei.fMask |= SEE_MASK_RESERVED;
        sei.hInstApp = (HINSTANCE)lpReserved;
    }

    // Pass along the lpTitle parameter to the new process
    if (lpTitle)
    {
        sei.fMask |= SEE_MASK_HASTITLE;
        sei.lpClass = lpTitle;
    }

    // Pass along the SEPARATE_VDM flag
    if (dwFlags & EXEC_SEPARATE_VDM)
    {
        sei.fMask |= SEE_MASK_FLAG_SEPVDM;
    }

    // Pass along the NO_CONSOLE flag
    if (dwFlags & EXEC_NO_CONSOLE)
    {
        sei.fMask |= SEE_MASK_NO_CONSOLE;
    }

    if (lphProcess)
    {
        // Return the process handle
        sei.fMask |= SEE_MASK_NOCLOSEPROCESS;
        ShellExecuteExA(&sei);
        *lphProcess = sei.hProcess;
    }
    else
    {
        ShellExecuteExA(&sei);
    }

    return sei.hInstApp;
}

HINSTANCE WINAPI RealShellExecuteExW(HWND hwnd, LPCWSTR lpOp, LPCWSTR lpFile,
                                   LPCWSTR lpArgs, LPCWSTR lpDir, LPWSTR lpResult,
                                   LPCWSTR lpTitle, LPWSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess,
                                   DWORD dwFlags)
{
    SHELLEXECUTEINFOW sei = { sizeof(SHELLEXECUTEINFOW), SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};

    TraceMsg(TF_SHELLEXEC, "RealShellExecuteExW(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX, %d)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess, dwFlags);

    if (lpReserved)
    {
        sei.fMask |= SEE_MASK_RESERVED;
        sei.hInstApp = (HINSTANCE)lpReserved;
    }

    if (lpTitle)
    {
        sei.fMask |= SEE_MASK_HASTITLE;
        sei.lpClass = lpTitle;
    }

    if (dwFlags & EXEC_SEPARATE_VDM)
    {
        sei.fMask |= SEE_MASK_FLAG_SEPVDM;
    }

    if (dwFlags & EXEC_NO_CONSOLE)
    {
        sei.fMask |= SEE_MASK_NO_CONSOLE;
    }

    if (lphProcess)
    {
        // Return the process handle
        sei.fMask |= SEE_MASK_NOCLOSEPROCESS;
        ShellExecuteExW(&sei);
        *lphProcess = sei.hProcess;
    }
    else
    {
        ShellExecuteExW(&sei);
    }

    return sei.hInstApp;
}

HINSTANCE WINAPI RealShellExecuteA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile,
                                   LPCSTR lpArgs, LPCSTR lpDir, LPSTR lpResult,
                                   LPCSTR lpTitle, LPSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess)
{
    TraceMsg(TF_SHELLEXEC, "RealShellExecuteA(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess);

    return RealShellExecuteExA(hwnd,lpOp,lpFile,lpArgs,lpDir,lpResult,lpTitle,lpReserved,nShowCmd,lphProcess,0);
}

HINSTANCE RealShellExecuteW(HWND hwnd, LPCWSTR lpOp, LPCWSTR lpFile,
                                   LPCWSTR lpArgs, LPCWSTR lpDir, LPWSTR lpResult,
                                   LPCWSTR lpTitle, LPWSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess)
{
    TraceMsg(TF_SHELLEXEC, "RealShellExecuteW(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess);

    return RealShellExecuteExW(hwnd,lpOp,lpFile,lpArgs,lpDir,lpResult,lpTitle,lpReserved,nShowCmd,lphProcess,0);
}

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCTSTR lpOp, LPCTSTR lpFile, LPCTSTR lpArgs,
                               LPCTSTR lpDir, int nShowCmd)
{
    // NB The FORCENOIDLIST flag stops us from going through the ShellExecPidl()
    // code (for backwards compatability with progman).
    // DDEWAIT makes us synchronous, and gets around threads without
    // msg pumps and ones that are killed immediately after shellexec()
    
    SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO), 0, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};
    ULONG fMask = SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST;
    if(!(SHGetAppCompatFlags(ACF_WIN95SHLEXEC) & ACF_WIN95SHLEXEC))
        fMask |= SEE_MASK_FLAG_DDEWAIT;
    sei.fMask = fMask;

    TraceMsg(TF_SHELLEXEC, "ShellExecute(%04X, %s, %s, %s, %s, %d)", hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd);

    ShellExecuteEx(&sei);
    return sei.hInstApp;
}

HINSTANCE WINAPI ShellExecuteA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile, LPCSTR lpArgs,
                               LPCSTR lpDir, int nShowCmd)
{
    // NB The FORCENOIDLIST flag stops us from going through the ShellExecPidl()
    // code (for backwards compatability with progman).
    // DDEWAIT makes us synchronous, and gets around threads without
    // msg pumps and ones that are killed immediately after shellexec()
    SHELLEXECUTEINFOA sei = { sizeof(SHELLEXECUTEINFOA), 0, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};
    ULONG fMask = SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST;
    if (!(SHGetAppCompatFlags(ACF_WIN95SHLEXEC) & ACF_WIN95SHLEXEC))
        fMask |= SEE_MASK_FLAG_DDEWAIT;
    sei.fMask = fMask;

    TraceMsg(TF_SHELLEXEC, "ShellExecuteA(%04X, %S, %S, %S, %S, %d)", hwnd,
        SAFE_DEBUGSTR(lpOp), SAFE_DEBUGSTR(lpFile), SAFE_DEBUGSTR(lpArgs),
        SAFE_DEBUGSTR(lpDir), nShowCmd);

    ShellExecuteExA(&sei);
    return sei.hInstApp;
}

// Returns TRUE if the specified app is listed under the specified key
STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey)
{
    HKEY hkey;
    
    // Enum through the list of apps.
    
    if (RegOpenKey(HKEY_CURRENT_USER, pszKey, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szValue[MAX_PATH], szData[MAX_PATH];
        DWORD dwType, cbData = sizeof(szData);
        DWORD cchValue = ARRAYSIZE(szValue);
        int iValue = 0;
        while (RegEnumValue(hkey, iValue, szValue, &cchValue, NULL, &dwType,
            (LPBYTE)szData, &cbData) == ERROR_SUCCESS)
        {
            if (lstrcmpi(szData, pszFileName) == 0)
            {
                RegCloseKey(hkey);
                return TRUE;
            }
            cbData = sizeof(szData);
            cchValue = ARRAYSIZE(szValue);
            iValue++;
        }
        RegCloseKey(hkey);
    }
    return FALSE;
}

#define REGSTR_PATH_POLICIES_EXPLORER REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictRun")
#define REGSTR_PATH_POLICIES_EXPLORER_DISALLOW REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowRun")

//----------------------------------------------------------------------------
// Returns TRUE if the specified app is not on the list of unrestricted apps.
BOOL RestrictedApp(LPCTSTR pszApp)
{
    LPTSTR pszFileName;

    pszFileName = PathFindFileName(pszApp);

    TraceMsg(TF_SHELLEXEC, "RestrictedApp: %s ", pszFileName);

    // Special cases:
    //     Apps you can always run.
    if (lstrcmpi(pszFileName, c_szRunDll) == 0)
        return FALSE;

    if (lstrcmpi(pszFileName, TEXT("systray.exe")) == 0)
        return FALSE;

    return !IsNameListedUnderKey(pszFileName, REGSTR_PATH_POLICIES_EXPLORER);
}

//----------------------------------------------------------------------------
// Returns TRUE if the specified app is on the list of disallowed apps.
BOOL DisallowedApp(LPCTSTR pszApp)
{
    LPTSTR pszFileName;

    pszFileName = PathFindFileName(pszApp);

    TraceMsg(TF_SHELLEXEC, "DisallowedApp: %s ", pszFileName);

    return IsNameListedUnderKey(pszFileName, REGSTR_PATH_POLICIES_EXPLORER_DISALLOW);
}


//----------------------------------------------------------------------------
// Returns TRUE if the system has FAT32 drives.

BOOL HasFat32Drives()
{
    static BOOL fHasFat32Drives = -1; // -1 means unverified.
    int         iDrive;

    if (fHasFat32Drives != -1)
        return fHasFat32Drives;

    // Assume false
    fHasFat32Drives = FALSE;

    for (iDrive = 0; iDrive < 26; iDrive++)
    {
        TCHAR szDriveName[4];

        if (GetDriveType((LPTSTR)PathBuildRoot(szDriveName, iDrive)) == DRIVE_FIXED)
        {
            TCHAR szFileSystemName[12];

            if (GetVolumeInformation(szDriveName, NULL, 0, NULL, NULL, NULL,
                                     szFileSystemName, ARRAYSIZE(szFileSystemName)))
            {
                if (lstrcmpi(szFileSystemName, TEXT("FAT32"))==0)
                {
                    fHasFat32Drives = TRUE;
                    return fHasFat32Drives;
                }
            }
        }
    }

    return fHasFat32Drives;
}


typedef struct {
    // local data
    HWND          hDlg;
    // parameters
    DWORD         dwHelpId;
    LPCTSTR       lpszTitle;
    DWORD         dwResString;
    BOOL          fHardBlock;
    BOOL          fDone;
} APPCOMPATDLG_DATA, *PAPPCOMPATDLG_DATA;


BOOL_PTR CALLBACK AppCompat_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAPPCOMPATDLG_DATA lpdata = (PAPPCOMPATDLG_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD aHelpIDs[4];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szMsgText[2048];

            /* The title will be in the lParam. */
            lpdata = (PAPPCOMPATDLG_DATA)lParam;
            lpdata->hDlg = hDlg;
            if (lpdata->fHardBlock)
            {
                // Disable the "Run" button.
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpdata);
            SetWindowText(hDlg, lpdata->lpszTitle);

            LoadString(HINST_THISDLL, lpdata->dwResString, szMsgText, ARRAYSIZE(szMsgText));
            SetDlgItemText(hDlg, IDD_LINE_1, szMsgText);
            return TRUE;
        }

    case WM_DESTROY:
        break;

    case WM_HELP:
//        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("apps.chm>Proc4"), HELP_CONTEXT, 0);
        HtmlHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("apps.chm>Proc4"), HELP_CONTEXT, 0);        
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            aHelpIDs[0]=IDHELP;
            aHelpIDs[1]=lpdata->dwHelpId;
            aHelpIDs[2]=0;
            aHelpIDs[3]=0;

//            WinHelp(hDlg, TEXT("apps.chm>Proc4"), HELP_CONTEXT, (DWORD)lpdata->dwHelpId);
            HtmlHelp(hDlg, TEXT("apps.chm>Proc4"), HH_HELP_CONTEXT, (DWORD)lpdata->dwHelpId);            
            break;

        case IDD_COMMAND:
            case IDOK:
                if (IsDlgButtonChecked(hDlg, IDD_STATE))
                    EndDialog(hDlg, 0x8000 | IDOK);
                else
                    EndDialog(hDlg, IDOK);
                break;

            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;

            default:
                return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
 
BOOL _GetAppCompatData(LPCTSTR pszAppPath, LPCTSTR pszAppName, LPCTSTR *ppszNewEnvString, HKEY hkApp, APPCOMPATDLG_DATA *pdata, LPTSTR pszValue, DWORD cchValue)
{
    BOOL fRet = FALSE;
    BOOL fBreakOutOfTheLoop=FALSE;
    int iValue;
    
    // Enum keys under this app name and check for dependant files.
    for (iValue = 0; !fBreakOutOfTheLoop; iValue++)
    {
        DWORD cch = cchValue;
        DWORD dwType;
        BYTE *pvData;
        DWORD cbData;
        LONG lResult;
        
        lResult = RegEnumValue(hkApp, iValue, pszValue, &cch, NULL, &dwType, NULL, &cbData);
        if ((lResult != NOERROR) && (lResult != ERROR_MORE_DATA))
        {
            //  no more values
            break;
        }
        
        //  insure this is our kind of data
        if (dwType != REG_BINARY)
            continue;          
        
        pvData = (BYTE *) GlobalAlloc(GPTR, cbData);
        
        if (pvData)
        {
            cch = cchValue;
            if (NOERROR == RegEnumValue(hkApp, iValue, pszValue, &cch, NULL, 
                &dwType, pvData, &cbData))
            {
                BADAPP_DATA badAppData;
                BADAPP_PROP badAppProp;
                badAppProp.Size = sizeof(BADAPP_PROP);
                badAppData.Size = sizeof(BADAPP_DATA);
                badAppData.FilePath = pszAppPath;
                badAppData.Blob = pvData;
                badAppData.BlobSize = cbData;
                
                if (SHIsBadApp(&badAppData, &badAppProp))
                {
                    //
                    // we found a bad app
                    //
                    pdata->dwHelpId = badAppProp.MsgId;
                    pdata->lpszTitle = pszAppName;
                    
                    fRet=TRUE;
                    
                    // Map ids to message strings for the various platforms we run on
                    switch (badAppProp.AppType & APPTYPE_TYPE_MASK) 
                    {
                    case APPTYPE_MINORPROBLEM:
                        pdata->dwResString = IDS_APPCOMPATWIN95L;
                        break;
                    case APPTYPE_INC_HARDBLOCK:
                        pdata->fHardBlock = TRUE;
                        pdata->dwResString = IDS_APPCOMPATWIN95H;
                        break;
                    case APPTYPE_INC_NOBLOCK:
                        pdata->dwResString = IDS_APPCOMPATWIN95;
                        break;
                        
                    case APPTYPE_VERSIONSUB:
                        {
                            static const LPCTSTR VersionFlavors[] = {
                                TEXT("_COMPAT_VER_NNN=4,0,1381,3,0,2,Service Pack 3"),
                                    TEXT("_COMPAT_VER_NNN=4,0,1381,4,0,2,Service Pack 4"),
                                    TEXT("_COMPAT_VER_NNN=4,0,1381,5,0,2,Service Pack 5"),
                                    TEXT("_COMPAT_VER_NNN=4,0,950,0,0,1"),
                                    0};
                                
                                //
                                // Is the ID within the number of strings we have?
                                //
                                if (badAppProp.MsgId <= (sizeof(VersionFlavors) / sizeof(LPTSTR) - 1))
                                {
                                    *ppszNewEnvString = VersionFlavors[badAppProp.MsgId];
                                }
                                
                                fRet = FALSE;
                        }
                        break;
                        
                    case APPTYPE_SHIM:
                        
                        //
                        // If there is a shim for this app do not display
                        // any message
                        //
                        fRet = FALSE;
                        break;
                        
                    default:
                        continue;
                    }
                    
                    //  this will break us out
                    fBreakOutOfTheLoop = TRUE;
                }
            }
            
            GlobalFree((HANDLE)pvData);
        }
    }
    return fRet;
}


typedef enum {
    SEV_DEFAULT = 0,
    SEV_LOW,
    SEV_HARD,
} SEVERITY;

BOOL _GetBadAppData(LPCTSTR pszAppPath, LPCTSTR pszAppName, HKEY hkApp, APPCOMPATDLG_DATA *pdata, LPTSTR pszValue, DWORD cchValue)
{
    BOOL fRet = FALSE;
    int iValue;
    TCHAR szPath[MAX_PATH];
    DWORD cchPath;
    LPTSTR pchCopyToPath;

    // Get directory of this app so that we can check for dependant files.
    StrCpyN(szPath, pszAppPath, ARRAYSIZE(szPath));
    PathRemoveFileSpec(szPath);
    PathAddBackslash(szPath);
    cchPath = lstrlen(szPath);
    pchCopyToPath = &szPath[cchPath];
    cchPath = ARRAYSIZE(szPath) - cchPath;
        
    for (iValue = 0; !fRet; iValue++)
    {
        DWORD cch = cchValue;
        TCHAR szData[MAX_PATH];
        DWORD cbData = sizeof(szData);
        DWORD dwType;
        if (NOERROR == RegEnumValue(hkApp, iValue, pszValue, &cch, NULL, &dwType,
                            (LPBYTE)szData, &cbData))
        {
            // Fully qualified path to dependant file
            StrCpyN(pchCopyToPath, pszValue, cchPath);
            
            // * means match any file.
            if (pszValue[0] == TEXT('*') || PathFileExistsAndAttributes(szPath, NULL))
            {
                DWORD rgData[2];
                DWORD dwHelpId = StrToInt(szData);
                SEVERITY sev = SEV_DEFAULT;

                // Get the flags...
                lstrcpy(szData, TEXT("Flags"));
                StrCatBuff(szData, pszValue, ARRAYSIZE(szData));
                
                cbData = sizeof(szData);
                if (SHQueryValueEx(hkApp, szData, NULL, &dwType, (LPBYTE)szData, &cbData) == ERROR_SUCCESS && cbData >= 1)
                {
                    if (StrChr(szData, TEXT('L')))
                        sev = SEV_LOW;

                    if (StrChr(szData, TEXT('Y')))
                        sev = SEV_HARD;

                    if ((StrChr(szData, TEXT('N')) && !(GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS))
                    ||  (StrChr(szData, TEXT('F')) && !HasFat32Drives()))
                    {
                        continue;
                    }
                }

                // Check the version if any...
                lstrcpy(szData, TEXT("Version"));
                StrCatBuff(szData, pszValue, ARRAYSIZE(szData));
                cbData = sizeof(rgData);
                if (SHQueryValueEx(hkApp, szData, NULL, &dwType, (LPBYTE)rgData, &cbData) == ERROR_SUCCESS 
                && (cbData == 8))
                {
                    DWORD dwVerLen, dwVerHandle;
                    DWORD dwMajorVer, dwMinorVer;
                    DWORD dwBadMajorVer, dwBadMinorVer;
                    LPTSTR lpVerBuffer;
                    BOOL  fBadApp = FALSE;

                    // What is a bad version according to the registry key?
                    dwBadMajorVer = rgData[0];
                    dwBadMinorVer = rgData[1];

                    // If no version resource can be found, assume 0.
                    dwMajorVer = 0;
                    dwMinorVer = 0;

                    // Version data in inf file should be of the form 8 bytes
                    // Major Minor
                    // 3.10  10.10
                    // 40 30 20 10 is 10 20 30 40 in registry
                    // cast const -> non const
                    if (0 != (dwVerLen = GetFileVersionInfoSize((LPTSTR)pszAppPath, &dwVerHandle)))
                    {
                        lpVerBuffer = (LPTSTR)GlobalAlloc(GPTR, dwVerLen);
                        if (lpVerBuffer)
                        {
                            VS_FIXEDFILEINFO *pffi = NULL;
                            UINT             cb;

                            if (GetFileVersionInfo((LPTSTR)pszAppPath, dwVerHandle, dwVerLen, lpVerBuffer) &&
                                VerQueryValue(lpVerBuffer, TEXT("\\"), (void **)&pffi, &cb))
                            {
                                dwMajorVer = pffi->dwProductVersionMS;
                                dwMinorVer = pffi->dwProductVersionLS;
                            }

                            GlobalFree((HANDLE)lpVerBuffer);
                        }
                    }

                    if (dwMajorVer < dwBadMajorVer)
                        fBadApp = TRUE;
                    else if ((dwMajorVer == dwBadMajorVer) && (dwMinorVer <= dwBadMinorVer))
                        fBadApp = TRUE;

                    if (!fBadApp)
                    {
                        // This dude is ok
                        continue;
                    }
                }

                pdata->dwHelpId = dwHelpId;
                pdata->lpszTitle = pszAppName;

                // Map ids to message strings for the various platforms we run on
                switch (sev)
                {
                case SEV_LOW:
                    pdata->dwResString = IDS_APPCOMPATWIN95L;
                    break;

                case SEV_HARD:
                    pdata->fHardBlock = TRUE;
                    pdata->dwResString = IDS_APPCOMPATWIN95H;
                    break;

                default:
                    pdata->dwResString = IDS_APPCOMPATWIN95;
                }

                // this will break us out
                fRet = TRUE;
            }
        }
        else
            break;
    }

    return fRet;
}

HKEY _OpenBadAppKey(LPCTSTR pszApp, LPCTSTR pszName)
{
    HKEY hkBad = NULL;
    DWORD dwAppVersion = GetExeType(pszApp);

    ASSERT(pszApp && *pszApp && pszName && *pszName);

    if (HIWORD(dwAppVersion) < 0x0400)
    {
        // Check the reg key for apps older than 4.00
        RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_CHECKBADAPPSNEW, &hkBad);
    }
    else if (HIWORD(dwAppVersion) == 0x0400)
    {
        // Check the reg key for apps == 4.00
        RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_CHECKBADAPPS400NEW, &hkBad);
    }
    //  else
        // Newer than 4.0 so all should be fine.

    if (hkBad)
    {
        // Check for the app name
        HKEY hkRet = NULL;
        RegOpenKey(hkBad, pszName, &hkRet);
        RegCloseKey(hkBad);
        return hkRet;
    }

    return NULL;
}


HKEY _CheckBadApps(LPCTSTR pszAppPath, LPCTSTR pszAppName, APPCOMPATDLG_DATA *pdata, LPTSTR pszValue, DWORD cchValue)
{
    HKEY hkApp = _OpenBadAppKey(pszAppPath, pszAppName);

    if (hkApp)
    {
        TraceMsg(TF_SHELLEXEC, "CheckBadApps() maybe is bad %s", pszAppName);
        if (_GetBadAppData(pszAppPath, pszAppName, hkApp, pdata, pszValue, cchValue))
            return hkApp;
            
        RegCloseKey(hkApp);
    }

    return NULL;
}

HKEY _OpenAppCompatKey(LPCTSTR pszAppName)
{
    TCHAR sz[MAX_PATH];
    HKEY hkRet = NULL;
    wnsprintf(sz, SIZECHARS(sz), REGSTR_TEMP_APPCOMPATPATH, pszAppName);

    RegOpenKey(HKEY_LOCAL_MACHINE, sz, &hkRet);

    return hkRet;
}

HKEY _CheckAppCompat(LPCTSTR pszAppPath, LPCTSTR pszAppName, LPCTSTR *ppszNewEnvString, APPCOMPATDLG_DATA *pdata, LPTSTR pszValue, DWORD cchValue)
{
    HKEY hkApp = _OpenAppCompatKey(pszAppName);

    if (hkApp)
    {
        TraceMsg(TF_SHELLEXEC, "CheckAppCompat() maybe is bad %s", pszAppName);
        if (_GetAppCompatData(pszAppPath, pszAppName, ppszNewEnvString, hkApp, pdata, pszValue, cchValue))
            return hkApp;
            
        RegCloseKey(hkApp);
    }

    return NULL;
}
        
// Returns FALSE if app is fatally incompatible

BOOL CheckAppCompatibility(LPCTSTR pszApp, LPCTSTR *ppszNewEnvString, BOOL fNoUI, HWND hwnd)
{
    BOOL fRet = TRUE;
    // If no app name, then nothing to check, so pretend it's a good app.
    // Must check now or RegOpenKey will get a null string and behave
    // "nonintuitively".  (If you give RegOpenKey a null string, it
    // returns the same key back and does *not* bump the refcount.)

    if (pszApp && *pszApp)
    {
        LPCTSTR pszFileName = PathFindFileName(pszApp);

        if (pszFileName && *pszFileName)
        {
            APPCOMPATDLG_DATA data = {0};
            TCHAR szValue[MAX_PATH];
            HKEY hkBad = _CheckAppCompat(pszApp, pszFileName, ppszNewEnvString, &data, szValue, ARRAYSIZE(szValue));

            if (!hkBad)
                hkBad = _CheckBadApps(pszApp, pszFileName, &data, szValue, ARRAYSIZE(szValue));


            if (hkBad)
            {
                TraceMsg(TF_SHELLEXEC, "BADAPP %s", pszFileName);
                
                if (fNoUI && !hwnd)
                {
                    //
                    //  LEGACY - we just let soft blocks right on through - ZekeL - 27-MAY-99
                    //  the NOUI flag is usually passed by apps when they 
                    //  have very specific behavior they are looking for.
                    //  if that is the case we should probably just defer to them
                    //  unless we know it is really bad.
                    //
                    if (data.fHardBlock)
                        fRet = FALSE;
                    else
                        fRet = TRUE;
                }
                else
                {
                    int iRet = (int)DialogBoxParam(HINST_THISDLL,
                                            MAKEINTRESOURCE(DLG_APPCOMPAT),
                                            hwnd, AppCompat_DlgProc, (LPARAM)&data);

                    if (iRet & 0x8000)
                    {
                        // Delete so we don't warn again.
                        RegDeleteValue(hkBad, szValue);
                    }

                    if ((iRet & 0x0FFF) != IDOK)
                        fRet = FALSE;
                }

                RegCloseKey(hkBad);
            }
        }

    }

    return fRet;
}

/*
 * Returns:
 *    S_OK or error.
 *    *phrHook is hook result if S_OK is returned, otherwise it is S_FALSE.
 */
HRESULT InvokeShellExecuteHook(REFGUID clsidHook, LPSHELLEXECUTEINFO pei, HRESULT *phrHook)
{
    *phrHook = S_FALSE;
    IUnknown *punk;
    HRESULT hr = SHExtCoCreateInstance(NULL, &clsidHook, NULL, IID_PPV_ARG(IUnknown, &punk));
    if (hr == S_OK)
    {
        IShellExecuteHook *pshexhk;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellExecuteHook, &pshexhk));
        if (hr == S_OK)
        {
            *phrHook = pshexhk->Execute(pei);
            pshexhk->Release();
        }
        else
        {
            IShellExecuteHookA *pshexhkA;
            hr = punk->QueryInterface(IID_PPV_ARG(IShellExecuteHookA, &pshexhkA));
            if (SUCCEEDED(hr))
            {
                SHELLEXECUTEINFOA seia;
                UINT cchVerb = 0;
                UINT cchFile = 0;
                UINT cchParameters = 0;
                UINT cchDirectory  = 0;
                UINT cchClass = 0;
                LPSTR lpszBuffer;

                seia = *(SHELLEXECUTEINFOA*)pei;    // Copy all of the binary data

                if (pei->lpVerb)
                {
                    cchVerb = WideCharToMultiByte(CP_ACP,0,
                                                  pei->lpVerb, -1,
                                                  NULL, 0,
                                                  NULL, NULL) + 1;
                }

                if (pei->lpFile)
                    cchFile = WideCharToMultiByte(CP_ACP,0,
                                                  pei->lpFile, -1,
                                                  NULL, 0,
                                                  NULL, NULL)+1;

                if (pei->lpParameters)
                    cchParameters = WideCharToMultiByte(CP_ACP,0,
                                                        pei->lpParameters, -1,
                                                        NULL, 0,
                                                        NULL, NULL)+1;

                if (pei->lpDirectory)
                    cchDirectory = WideCharToMultiByte(CP_ACP,0,
                                                       pei->lpDirectory, -1,
                                                       NULL, 0,
                                                       NULL, NULL)+1;
                if (_UseClassName(pei->fMask) && pei->lpClass)
                    cchClass = WideCharToMultiByte(CP_ACP,0,
                                                   pei->lpClass, -1,
                                                   NULL, 0,
                                                   NULL, NULL)+1;

                lpszBuffer = (LPSTR) alloca(cchVerb+cchFile+cchParameters+cchDirectory+cchClass);

                seia.lpVerb = NULL;
                seia.lpFile = NULL;
                seia.lpParameters = NULL;
                seia.lpDirectory = NULL;
                seia.lpClass = NULL;

                //
                // Convert all of the strings to ANSI
                //
                if (pei->lpVerb)
                {
                    WideCharToMultiByte(CP_ACP, 0, pei->lpVerb, -1,
                                        lpszBuffer, cchVerb, NULL, NULL);
                    seia.lpVerb = lpszBuffer;
                    lpszBuffer += cchVerb;
                }
                if (pei->lpFile)
                {
                    WideCharToMultiByte(CP_ACP, 0, pei->lpFile, -1,
                                        lpszBuffer, cchFile, NULL, NULL);
                    seia.lpFile = lpszBuffer;
                    lpszBuffer += cchFile;
                }
                if (pei->lpParameters)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpParameters, -1,
                                        lpszBuffer, cchParameters, NULL, NULL);
                    seia.lpParameters = lpszBuffer;
                    lpszBuffer += cchParameters;
                }
                if (pei->lpDirectory)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpDirectory, -1,
                                        lpszBuffer, cchDirectory, NULL, NULL);
                    seia.lpDirectory = lpszBuffer;
                    lpszBuffer += cchDirectory;
                }
                if (_UseClassName(pei->fMask) && pei->lpClass)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpClass, -1,
                                        lpszBuffer, cchClass, NULL, NULL);
                    seia.lpClass = lpszBuffer;
                }

                *phrHook = pshexhkA->Execute(&seia);

                pei->hInstApp = seia.hInstApp;
                // hook may set hProcess (e.g. CURLExec creates dummy process
                // to signal IEAK that IE setup failed -- in browser only mode)
                pei->hProcess = seia.hProcess;

                pshexhkA->Release();
            }
        }
        punk->Release();
    }

    return(hr);
}

const TCHAR c_szShellExecuteHooks[] = REGSTR_PATH_EXPLORER TEXT("\\ShellExecuteHooks");

/*
 * Returns:
 *    S_OK     Execution handled by hook.  pei->hInstApp filled in.
 *    S_FALSE  Execution not handled by hook.  pei->hInstApp not filled in.
 *    E_...    Error during execution by hook.  pei->hInstApp filled in.
 */
HRESULT TryShellExecuteHooks(LPSHELLEXECUTEINFO pei)
{
    HRESULT hr = S_FALSE;
    HKEY hkeyHooks;

    // Enumerate the list of hooks.  A hook is registered as a GUID value of the
    // c_szShellExecuteHooks key.

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szShellExecuteHooks, &hkeyHooks)
        == ERROR_SUCCESS)
    {
        DWORD dwiValue;
        TCHAR szCLSID[GUIDSTR_MAX];
        DWORD cchCLSID;

        // Invoke each hook.  A hook returns S_FALSE if it does not handle the
        // exec.  Stop when a hook returns S_OK (handled) or an error.

        for (cchCLSID = ARRAYSIZE(szCLSID), dwiValue = 0;
             RegEnumValue(hkeyHooks, dwiValue, szCLSID, &cchCLSID, NULL,
                          NULL, NULL, NULL) == ERROR_SUCCESS;
             cchCLSID = ARRAYSIZE(szCLSID), dwiValue++)
        {
            CLSID clsidHook;

            if (SUCCEEDED(SHCLSIDFromString(szCLSID, &clsidHook)))
            {
                HRESULT hrHook;

                if (InvokeShellExecuteHook(clsidHook, pei, &hrHook) == S_OK &&
                    hrHook != S_FALSE)
                {
                    hr = hrHook;
                    break;
                }
            }
        }

        RegCloseKey(hkeyHooks);
    }

    ASSERT(hr == S_FALSE ||
           (hr == S_OK && ISSHELLEXECSUCCEEDED(pei->hInstApp)) ||
           (FAILED(hr) && ! ISSHELLEXECSUCCEEDED(pei->hInstApp)));

    return(hr);
}

BOOL InRunDllProcess(void)
{
    static BOOL s_fInRunDll = -1;

    if (-1 == s_fInRunDll)
    {
        TCHAR sz[MAX_PATH];
        s_fInRunDll = FALSE;
        if (GetModuleFileName(NULL, sz, SIZECHARS(sz)))
        {
            //  
            //  WARNING - rundll often seems to fail to add the DDEWAIT flag, and
            //  it often needs to since it is common to use rundll as a fire
            //  and forget process, and it exits too early.
            //
            
            if (StrStrI(sz, TEXT("rundll")))
                s_fInRunDll = TRUE;
        }
    }

    return s_fInRunDll;
}

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Validation function for SHELLEXECUTEINFO

*/
BOOL IsValidPSHELLEXECUTEINFO(LPSHELLEXECUTEINFO pei)
{
    //
    //  Note that we do *NOT* validate hInstApp, for several reasons.
    //
    //  1.  It is an OUT parameter, not an IN parameter.
    //  2.  It often contains an error code (see documentation).
    //  3.  Even when it contains an HINSTANCE, it's an HINSTANCE
    //      in another process, so we can't validate it anyway.
    //
    return (IS_VALID_WRITE_PTR(pei, SHELLEXECUTEINFO) &&
            IS_VALID_SIZE(pei->cbSize, sizeof(*pei)) &&
            (IsFlagSet(pei->fMask, SEE_MASK_FLAG_NO_UI) ||
             NULL == pei->hwnd ||
             IS_VALID_HANDLE(pei->hwnd, WND)) &&
            (NULL == pei->lpVerb || IS_VALID_STRING_PTR(pei->lpVerb, -1)) &&
            (NULL == pei->lpFile || IS_VALID_STRING_PTR(pei->lpFile, -1)) &&
            (NULL == pei->lpParameters || IS_VALID_STRING_PTR(pei->lpParameters, -1)) &&
            (NULL == pei->lpDirectory || IS_VALID_STRING_PTR(pei->lpDirectory, -1)) &&
            (IsFlagClear(pei->fMask, SEE_MASK_IDLIST) ||
             IsFlagSet(pei->fMask, SEE_MASK_INVOKEIDLIST) ||        // because SEE_MASK_IDLIST is part of SEE_MASK_INVOKEIDLIST this line will
             IS_VALID_PIDL((LPCITEMIDLIST)(pei->lpIDList))) &&      // defer to the next clause if the superset is true
            (IsFlagClear(pei->fMask, SEE_MASK_INVOKEIDLIST) ||
             NULL == pei->lpIDList ||
             IS_VALID_PIDL((LPCITEMIDLIST)(pei->lpIDList))) &&
            (!_UseClassName(pei->fMask) ||
             IS_VALID_STRING_PTR(pei->lpClass, -1)) &&
            (!_UseTitleName(pei->fMask) ||
             NULL == pei->lpClass ||
             IS_VALID_STRING_PTR(pei->lpClass, -1)) &&
            (!_UseClassKey(pei->fMask) ||
             IS_VALID_HANDLE(pei->hkeyClass, KEY)) &&
            (IsFlagClear(pei->fMask, SEE_MASK_ICON) ||
             IS_VALID_HANDLE(pei->hIcon, ICON)));
}

#endif // DEBUG

//
// ShellExecuteEx
//
// returns TRUE if the execute succeeded, in which case
//   hInstApp should be the hinstance of the app executed (>32)
//   NOTE: in some cases the HINSTANCE cannot (currently) be determined.
//   In these cases, hInstApp is set to 42.
//
// returns FALSE if the execute did not succeed, in which case
//   GetLastError will contain error information
//   For backwards compatibility, hInstApp will contain the
//     best SE_ERR_ error information (<=32) possible.
//

BOOL WINAPI ShellExecuteEx(LPSHELLEXECUTEINFO pei)
{
    DWORD err = NOERROR;

    // Don't overreact if CoInitializeEx fails; it just means we
    // can't do our shell hooks.
    HRESULT hrInit = SHCoInitialize();

    if (IS_VALID_STRUCT_PTR(pei, SHELLEXECUTEINFO) &&
        sizeof(*pei) == pei->cbSize)
    {
        // This internal bit prevents error message box reporting
        // when we recurse back into ShellExecuteEx
        ULONG ulOriginalMask = pei->fMask;
        pei->fMask |= SEE_MASK_FLAG_SHELLEXEC;
        if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("MaximizeApps"), 
            FALSE, FALSE)) //  && (GetSystemMetrics(SM_CYSCREEN)<=600))
        {
            switch (pei->nShow)
            {
            case SW_NORMAL:
            case SW_SHOW:
            case SW_RESTORE:
            case SW_SHOWDEFAULT:
                pei->nShow = SW_MAXIMIZE;
            }
        }

        if (!(pei->fMask & SEE_MASK_FLAG_DDEWAIT) && InRunDllProcess())
        {
            //  
            //  WARNING - rundll often seems to fail to add the DDEWAIT flag, and
            //  it often needs to since it is common to use rundll as a fire
            //  and forget process, and it exits too early.
            //
            pei->fMask |= (SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE);
        }

        // ShellExecuteNormal does its own SetLastError
        err = ShellExecuteNormal(pei);

        // Mike's attempt to be consistent in error reporting:
        if (err != ERROR_SUCCESS)
        {
            // we shouldn't put up errors on dll's not found.
            // this is handled WITHIN shellexecuteNormal because
            // sometimes kernel will put up the message for us, and sometimes
            // we need to.  we've put the curtion at ShellExecuteNormal

            //  LEGACY - ERROR_RESTRICTED_APP was never mapped to a valid error - ZekeL 2001-FEB-14
            //  because we always called _ShellExecuteError() before
            //  resetting the mask to ulOriginalMask, we never mapped
            //  ERROR_RESTRICTED_APP (which is -1) to a valid code
            if (err != ERROR_DLL_NOT_FOUND &&
                err != ERROR_CANCELLED)
            {
                _ShellExecuteError(pei, NULL, err);
            }
        }

        pei->fMask = ulOriginalMask;
    }
    else
    {
        // Failed parameter validation
        pei->hInstApp = (HINSTANCE)SE_ERR_ACCESSDENIED;
        err =  ERROR_ACCESS_DENIED;
    }

    SHCoUninitialize(hrInit);

    if (err != ERROR_SUCCESS)
        SetLastError(err);
        
    return err == ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   ShellExecuteExA
//
//  Synopsis:   Thunks ANSI call to ShellExecuteA to ShellExecuteW
//
//  Arguments:  [pei] -- pointer to an ANSI SHELLEXECUTINFO struct
//
//  Returns:    BOOL success value
//
//  History:    2-04-95   bobday   Created
//              2-06-95   davepl   Changed to ConvertStrings
//
//  Notes:
//
//--------------------------------------------------------------------------

inline BOOL _ThunkClass(ULONG fMask)
{
    return (fMask & SEE_MASK_HASLINKNAME) 
        || (fMask & SEE_MASK_HASTITLE)
        || _UseClassName(fMask);
}

BOOL WINAPI ShellExecuteExA(LPSHELLEXECUTEINFOA pei)
{
    if (pei->cbSize != sizeof(SHELLEXECUTEINFOA))
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_ACCESSDENIED;
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    SHELLEXECUTEINFOW seiw = {0};
    seiw.cbSize = sizeof(SHELLEXECUTEINFOW);
    seiw.fMask = pei->fMask;
    seiw.hwnd  = pei->hwnd;
    seiw.nShow = pei->nShow;

    if (_UseClassKey(pei->fMask))
        seiw.hkeyClass = pei->hkeyClass;

    if (pei->fMask & SEE_MASK_IDLIST)
        seiw.lpIDList = pei->lpIDList;

    if (pei->fMask & SEE_MASK_HOTKEY)
        seiw.dwHotKey = pei->dwHotKey;
    if (pei->fMask & SEE_MASK_ICON)
        seiw.hIcon = pei->hIcon;

    // Thunk the text fields as appropriate
    ThunkText *pThunkText = ConvertStrings(6,
                      pei->lpVerb,
                      pei->lpFile,
                      pei->lpParameters,
                      pei->lpDirectory,
                      _ThunkClass(pei->fMask) ? pei->lpClass : NULL,
                      (pei->fMask & SEE_MASK_RESERVED)  ? pei->hInstApp : NULL);

    if (NULL == pThunkText)
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
        return FALSE;
    }

    // Set our UNICODE text fields to point to the thunked strings
    seiw.lpVerb         = pThunkText->m_pStr[0];
    seiw.lpFile         = pThunkText->m_pStr[1];
    seiw.lpParameters   = pThunkText->m_pStr[2];
    seiw.lpDirectory    = pThunkText->m_pStr[3];
    seiw.lpClass        = pThunkText->m_pStr[4];
    seiw.hInstApp       = (HINSTANCE)pThunkText->m_pStr[5];

    // If we are passed the SEE_MASK_FILEANDURL flag, this means that
    // we have a lpFile parameter that has both the CacheFilename and the URL
    // (seperated by a single NULL, eg. "CacheFileName\0UrlName). We therefore
    // need to special case the thunking of pei->lpFile.
    LPWSTR pwszFileAndUrl = NULL;
    if (pei->fMask & SEE_MASK_FILEANDURL)
    {
        int iUrlLength;
        int iCacheFileLength = lstrlenW(pThunkText->m_pStr[1]);
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
        LPSTR pszUrlPart = (LPSTR)&pei->lpFile[iCacheFileLength + 1];


        if (IsBadStringPtrA(pszUrlPart, INTERNET_MAX_URL_LENGTH) || !PathIsURLA(pszUrlPart))
        {
            ASSERT(FALSE);
        }
        else
        {
            // we have a vaild URL, so thunk it
            iUrlLength = lstrlenA(pszUrlPart);

            pwszFileAndUrl = (LPWSTR)LocalAlloc(LPTR, (iUrlLength + iCacheFileLength + 2) * sizeof(WCHAR));
            if (!pwszFileAndUrl)
            {
                pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
                return FALSE;
            }

            SHAnsiToUnicode(pszUrlPart, wszURL, INTERNET_MAX_URL_LENGTH);

            // construct the wide multi-string
            lstrcpyW(pwszFileAndUrl, pThunkText->m_pStr[1]);
            lstrcpyW(&pwszFileAndUrl[iCacheFileLength + 1], wszURL);
            seiw.lpFile = pwszFileAndUrl;
        }
    }

    // Call the real UNICODE ShellExecuteEx

    BOOL fRet = ShellExecuteEx(&seiw);

    pei->hInstApp = seiw.hInstApp;

    if (pei->fMask & SEE_MASK_NOCLOSEPROCESS)
    {
        pei->hProcess = seiw.hProcess;
    }

    LocalFree(pThunkText);
    if (pwszFileAndUrl)
        LocalFree(pwszFileAndUrl);

    return fRet;
}

// To display an error message appropriately, call this if ShellExecuteEx fails.
void _DisplayShellExecError(ULONG fMask, HWND hwnd, LPCTSTR pszFile, LPCTSTR pszTitle, DWORD dwErr)
{

    if (!(fMask & SEE_MASK_FLAG_NO_UI))
    {
        if (dwErr != ERROR_CANCELLED)
        {
            LPCTSTR pszHeader;
            UINT ids;

            // don't display "user cancelled", the user knows that already

            // make sure parent window is the foreground window
            if (hwnd)
                SetForegroundWindow(hwnd);

            if (pszTitle)
                pszHeader = pszTitle;
            else
                pszHeader = pszFile;

            // Use our messages when we can -- they're more descriptive
            switch (dwErr)
            {
            case 0:
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_OUTOFMEMORY:
                ids = IDS_LowMemError;
                break;

            case ERROR_FILE_NOT_FOUND:
                ids = IDS_RunFileNotFound;
                break;

            case ERROR_PATH_NOT_FOUND:
            case ERROR_BAD_PATHNAME:
                ids = IDS_PathNotFound;
                break;

            case ERROR_TOO_MANY_OPEN_FILES:
                ids = IDS_TooManyOpenFiles;
                break;

            case ERROR_ACCESS_DENIED:
                ids = IDS_RunAccessDenied;
                break;

            case ERROR_BAD_FORMAT:
                // NB CreateProcess, when execing a Win16 apps maps just about all of
                // these errors to BadFormat. Not very useful but there it is.
                ids = IDS_BadFormat;
                break;

            case ERROR_SHARING_VIOLATION:
                ids = IDS_ShareError;
                break;

            case ERROR_OLD_WIN_VERSION:
                ids = IDS_OldWindowsVer;
                break;

            case ERROR_APP_WRONG_OS:
                ids = IDS_OS2AppError;
                break;

            case ERROR_SINGLE_INSTANCE_APP:
                ids = IDS_MultipleDS;
                break;

            case ERROR_RMODE_APP:
                ids = IDS_RModeApp;
                break;

            case ERROR_INVALID_DLL:
                ids = IDS_InvalidDLL;
                break;

            case ERROR_NO_ASSOCIATION:
                ids = IDS_NoAssocError;
                break;

            case ERROR_DDE_FAIL:
                ids = IDS_DDEFailError;
                break;

            case ERROR_BAD_NET_NAME:
            case ERROR_SEM_TIMEOUT:
                ids = IDS_REASONS_BADNETNAME;
                break;
                
            //  LEGACY - ERROR_RESTRICTED_APP was never mapped to a valid error - ZekeL 2001-FEB-14
            //  because we always called _ShellExecuteError() before
            //  resetting the mask to ulOriginalMask, we never mapped
            //  ERROR_RESTRICTED_APP (which is -1) to a valid code
            case ERROR_RESTRICTED_APP:
                ids = IDS_RESTRICTIONS;
                // restrictions like to use IDS_RESTRICTIONSTITLE
                if (!pszTitle)
                    pszHeader = MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE);
                break;


            // If we don't get a match, let the system handle it for us
            default:
                ids = 0;
                SHSysErrorMessageBox(
                    hwnd,
                    pszHeader,
                    IDS_SHLEXEC_ERROR,
                    dwErr,
                    pszFile,
                    MB_OK | MB_ICONSTOP);
                break;
            }

            if (ids)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(ids),
                        pszHeader, (ids == IDS_LowMemError)?
                        (MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL):(MB_OK | MB_ICONSTOP),
                        pszFile);
            }
        }
    }

    SetLastError(dwErr); // The message box may have clobbered.

}

void _ShellExecuteError(LPSHELLEXECUTEINFO pei, LPCTSTR lpTitle, DWORD dwErr)
{
    ASSERT(!ISSHELLEXECSUCCEEDED(pei->hInstApp));

    // if dwErr not passed in, get it
    if (dwErr == 0)
        dwErr = GetLastError();

    _DisplayShellExecError(pei->fMask, pei->hwnd, pei->lpFile, lpTitle, dwErr);
}




//----------------------------------------------------------------------------
// Given a file name and directory, get the path to the execuatable that
// would be exec'd if you tried to ShellExecute this thing.
HINSTANCE WINAPI FindExecutable(LPCTSTR lpFile, LPCTSTR lpDirectory, LPTSTR lpResult)
{
    HINSTANCE hInstance = (HINSTANCE)42;    // assume success must be > 32
    TCHAR szOldDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    LPCTSTR dirs[2];

    // Progman relies on lpResult being a ptr to an null string on error.
    *lpResult = TEXT('\0');
    GetCurrentDirectory(ARRAYSIZE(szOldDir), szOldDir);
    if (lpDirectory && *lpDirectory)
        SetCurrentDirectory(lpDirectory);
    else
        lpDirectory = szOldDir;     // needed for PathResolve()

    if (!GetShortPathName(lpFile, szFile, ARRAYSIZE(szFile))) {
        // if the lpFile is unqualified or bogus, let's use it down
        // in PathResolve.
        lstrcpyn(szFile, lpFile, ARRAYSIZE(szFile));
    }

    // get fully qualified path and add .exe extension if needed
    dirs[0] = (LPTSTR)lpDirectory;
    dirs[1] = NULL;
    if (!PathResolve(szFile, dirs, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS | PRF_FIRSTDIRDEF))
    {
        // File doesn't exist, return file not found.
        hInstance = (HINSTANCE)SE_ERR_FNF;
        goto Exit;
    }

    TraceMsg(TF_SHELLEXEC, "FindExecutable: PathResolve -> %s", (LPCSTR)szFile);

    if (PathIsExe(szFile))
    {
        lstrcpy(lpResult, szFile);
        goto Exit;
    }

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_EXECUTABLE, szFile, NULL, szFile, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szFile)))))
    {
        lstrcpy(lpResult, szFile);
    }
    else
    {
        hInstance = (HINSTANCE)SE_ERR_NOASSOC;
    }

Exit:
    TraceMsg(TF_SHELLEXEC, "FindExec(%s) ==> %s", (LPTSTR)lpFile, (LPTSTR)lpResult);
    SetCurrentDirectory(szOldDir);
    return hInstance;
}

HINSTANCE WINAPI FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult)
{
    HINSTANCE   hResult;
    WCHAR       wszResult[MAX_PATH];
    ThunkText * pThunkText = ConvertStrings(2, lpFile, lpDirectory);

    *lpResult = '\0';
    if (NULL == pThunkText)
    {
        return (HINSTANCE)SE_ERR_OOM;
    }

    hResult = FindExecutableW(pThunkText->m_pStr[0], pThunkText->m_pStr[1], wszResult);
    LocalFree(pThunkText);

    // FindExecutableW terminates wszResult for us, so this is safe
    // even if the above call fails

    // Thunk the output result string back to ANSI.  If the conversion fails,
    // or if the default char is used, we fail the API call.

    if (0 == WideCharToMultiByte(CP_ACP, 0, wszResult, -1, lpResult, MAX_PATH, NULL, NULL))
    {
        SetLastError((DWORD)E_FAIL);
        return (HINSTANCE) SE_ERR_FNF;
    }

    return hResult;

}

//----------------------------------------------------------------------------
// Data structures for our wait for file open functions
//
typedef struct _WaitForItem * PWAITFORITEM;

typedef struct _WaitForItem
{
    DWORD           dwSize;
    DWORD           fOperation;    // Operation to perform
    PWAITFORITEM    pwfiNext;
    HANDLE          hEvent;         // Handle to event that was registered.
    UINT            iWaiting;       // Number of clients that are waiting.
    ITEMIDLIST      idlItem;        // pidl to wait for
} WAITFORITEM;

//
//  This is the form of the structure that is shoved into the shared memory
//  block.  It must be the 32-bit version for interoperability reasons.
//
typedef struct _WaitForItem32
{
    DWORD           dwSize;
    DWORD           fOperation;    // Operation to perform
    DWORD           NotUsed1;
    LONG            hEvent;        // Truncated event handle
    UINT            NotUsed2;
    ITEMIDLIST      idlItem;       // pidl to wait for
} WAITFORITEM32, *PWAITFORITEM32;

//
//  These macros enforce type safety so people are forced to use the
//  WAITFORITEM32 structure when accessing the shared memory block.
//
#define SHLockWaitForItem(h, pid) ((PWAITFORITEM32)SHLockShared(h, pid))

__inline void SHUnlockWaitForItem(PWAITFORITEM32 pwfi)
{
    SHUnlockShared(pwfi);
}

PWAITFORITEM g_pwfiHead = NULL;

HANDLE SHWaitOp_OperateInternal(DWORD fOperation, LPCITEMIDLIST pidlItem)
{
    PWAITFORITEM    pwfi;
    HANDLE  hEvent = (HANDLE)NULL;

    for (pwfi = g_pwfiHead; pwfi != NULL; pwfi = pwfi->pwfiNext)
    {
        if (ILIsEqual(&(pwfi->idlItem), pidlItem))
        {
            hEvent = pwfi->hEvent;
            break;
        }
    }

    if (fOperation & WFFO_ADD)
    {
        if (!pwfi)
        {
            UINT uSize;
            UINT uSizeIDList = 0;

            if (pidlItem)
                uSizeIDList = ILGetSize(pidlItem);

            uSize = sizeof(WAITFORITEM) + uSizeIDList;

            // Create an event to wait for
            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

            if (hEvent)
                pwfi = (PWAITFORITEM)SHAlloc(uSize);

            if (pwfi)
            {
                pwfi->dwSize = uSize;
                // pwfi->fOperation = 0;       // Meaningless
                pwfi->hEvent = hEvent;
                pwfi->iWaiting = ((fOperation & WFFO_WAIT) != 0);

                memcpy(&(pwfi->idlItem), pidlItem, uSizeIDList);

                // now link it in
                pwfi->pwfiNext = g_pwfiHead;
                g_pwfiHead = pwfi;
            }
        }
    }

    if (pwfi)
    {
        if (fOperation & WFFO_WAIT)
            pwfi->iWaiting++;

        if (fOperation & WFFO_SIGNAL)
            SetEvent(hEvent);

        if (fOperation & WFFO_REMOVE)
            pwfi->iWaiting--;       // decrement in use count;

        // Only check removal case if not adding
        if ((fOperation & WFFO_ADD) == 0)
        {
            // Remove it if nobody waiting on it
            if (pwfi->iWaiting == 0)
            {
                if (g_pwfiHead == pwfi)
                    g_pwfiHead = pwfi->pwfiNext;
                else
                {
                    PWAITFORITEM pwfiT = g_pwfiHead;
                    while ((pwfiT != NULL) && (pwfiT->pwfiNext != pwfi))
                        pwfiT = pwfiT->pwfiNext;
                    ASSERT(pwfiT != NULL);
                    if (pwfiT != NULL)
                        pwfiT->pwfiNext = pwfi->pwfiNext;
                }

                // Close the handle
                CloseHandle(pwfi->hEvent);

                // Free the memory
                SHFree(pwfi);

                hEvent = NULL;          // NULL indicates nobody waiting... (for remove case)
            }
        }
    }

    return hEvent;
}

void SHWaitOp_Operate(HANDLE hWait, DWORD dwProcId)
{
    PWAITFORITEM32 pwfiFind = SHLockWaitForItem(hWait, dwProcId);
    if (pwfiFind)
    {
        pwfiFind->hEvent = HandleToLong(SHWaitOp_OperateInternal(pwfiFind->fOperation, &(pwfiFind->idlItem)));
        SHUnlockWaitForItem(pwfiFind);
    }
}

HANDLE SHWaitOp_Create(DWORD fOperation, LPCITEMIDLIST pidlItem, DWORD dwProcId)
{
    UINT    uSizeIDList = pidlItem ? ILGetSize(pidlItem) : 0;
    UINT    uSize = sizeof(WAITFORITEM32) + uSizeIDList;
    HANDLE hWaitOp = SHAllocShared(NULL, uSize, dwProcId);
    if (hWaitOp)
    {
        PWAITFORITEM32 pwfi = SHLockWaitForItem(hWaitOp,dwProcId);
        if (pwfi)
        {
            pwfi->dwSize = uSize;
            pwfi->fOperation = fOperation;
            pwfi->NotUsed1 = 0;
            pwfi->hEvent = HandleToLong((HANDLE)NULL);
            pwfi->NotUsed2 = 0;

            if (pidlItem)
                memcpy(&(pwfi->idlItem), pidlItem, uSizeIDList);

            SHUnlockWaitForItem(pwfi);
        }
        else
        {
            //  clean up
            SHFreeShared(hWaitOp, dwProcId);
            hWaitOp = NULL;
        }
    }

    return hWaitOp;
}

// This function allows the cabinet to wait for a
// file (in particular folders) to signal us that they are in an open state.
// This should take care of several synchronazation problems with the shell
// not knowing when a folder is in the process of being opened or not
//
STDAPI_(DWORD) SHWaitForFileToOpen(LPCITEMIDLIST pidl, UINT uOptions, DWORD dwTimeout)
{
    HWND    hwndShell;
    HANDLE  hWaitOp;
    HANDLE  hEvent = NULL;
    DWORD   dwProcIdSrc = GetCurrentProcessId();
    DWORD   dwReturn = WAIT_OBJECT_0; // we need a default

    hwndShell = GetShellWindow();

    if ((uOptions & (WFFO_WAIT | WFFO_ADD)) != 0)
    {
        if (hwndShell)
        {
            DWORD dwProcIdDst;
            GetWindowThreadProcessId(hwndShell, &dwProcIdDst);

            // Do just the add and/or wait portions
            hWaitOp = SHWaitOp_Create(uOptions & (WFFO_WAIT | WFFO_ADD), pidl, dwProcIdSrc);
            if (hWaitOp)
            {
                SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcIdSrc);

                // Now get the hEvent and convert to a local handle
                PWAITFORITEM32 pwfi = SHLockWaitForItem(hWaitOp, dwProcIdSrc);
                if (pwfi)
                {
                    hEvent = SHMapHandle(LongToHandle(pwfi->hEvent),dwProcIdDst, dwProcIdSrc, EVENT_ALL_ACCESS, 0);
                    SHUnlockWaitForItem(pwfi);
                }
                SHFreeShared(hWaitOp,dwProcIdSrc);
            }
        }
        else
        {
            // Do just the add and/or wait portions
            hEvent = SHWaitOp_OperateInternal(uOptions & (WFFO_WAIT | WFFO_ADD), pidl);
        }

        if (hEvent)
        {
            if (uOptions & WFFO_WAIT)
                dwReturn = SHProcessMessagesUntilEvent(NULL, hEvent, dwTimeout);

            if (hwndShell)          // Close the duplicated handle.
                CloseHandle(hEvent);
        }
    }

    if (uOptions & WFFO_REMOVE)
    {
        if (hwndShell)
        {
            hWaitOp = SHWaitOp_Create(WFFO_REMOVE, pidl, dwProcIdSrc);
            if (hWaitOp)
            {
                SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcIdSrc);
                SHFreeShared(hWaitOp,dwProcIdSrc);
            }
        }
        else
        {
            SHWaitOp_OperateInternal(WFFO_REMOVE, pidl);
        }
    }
    return dwReturn;
}


// Signals that the file is open
//
STDAPI_(BOOL) SignalFileOpen(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;
    HWND hwndShell = GetShellWindow();
    if (hwndShell)
    {
        PWAITFORITEM32 pwfi;
        DWORD dwProcId = GetCurrentProcessId();
        HANDLE  hWaitOp = SHWaitOp_Create(WFFO_SIGNAL, pidl, dwProcId);
        if (hWaitOp)
        {
            SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcId);

            // Now get the hEvent to determine return value...
            pwfi = SHLockWaitForItem(hWaitOp, dwProcId);
            if (pwfi)
            {
                fResult = (LongToHandle(pwfi->hEvent) != (HANDLE)NULL);
                SHUnlockWaitForItem(pwfi);
            }
            SHFreeShared(hWaitOp,dwProcId);
        }
    }
    else
    {
        fResult = (SHWaitOp_OperateInternal(WFFO_SIGNAL, pidl) == (HANDLE)NULL);
    }

    // Let everyone know that we opened something
    UINT uMsg = RegisterWindowMessage(SH_FILEOPENED);
    BroadcastSystemMessage(BSF_POSTMESSAGE, BSM_ALLCOMPONENTS, uMsg, NULL, NULL);

    return fResult;
}

//
// Checks to see if darwin is enabled.
//
BOOL IsDarwinEnabled()
{
    static BOOL s_fDarwinEnabled = TRUE;
    static BOOL s_fInit = FALSE;
    if (!s_fInit)
    {
        HKEY hkeyPolicy = 0;
        if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES_EXPLORER, &hkeyPolicy) == ERROR_SUCCESS) 
        {
            if (SHQueryValueEx(hkeyPolicy, TEXT("DisableMSI"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                s_fDarwinEnabled = FALSE;   // policy turns MSI off
            }
            RegCloseKey(hkeyPolicy);
        }
        s_fInit = TRUE;
    }
    return s_fDarwinEnabled;
}

// takes the darwin ID string from the registry, and calls darwin to get the
// full path to the application.
//
// IN:  pszDarwinDescriptor - this has the contents of the darwin key read out of the registry.
//                            it should contain a string like "[Darwin-ID-for-App] /switches".
//
// OUT: pszDarwinComand - the full path to the application to this buffer w/ switches.
//
STDAPI ParseDarwinID(LPTSTR pszDarwinDescriptor, LPTSTR pszDarwinCommand, DWORD cchDarwinCommand)
{
    DWORD dwError = CommandLineFromMsiDescriptor(pszDarwinDescriptor, pszDarwinCommand, &cchDarwinCommand);

    return HRESULT_FROM_WIN32(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\execute.cpp ===
#include "shellprv.h"
#include "shlexec.h"
#include <newexe.h>
#include <appmgmt.h>
#include "ids.h"
#include <shstr.h>
#include "pidl.h"
#include "apithk.h"     // for TermsrvAppInstallMode()
#include "fstreex.h"
#include "uemapp.h"
#include "views.h"      // for SHRunControlPanelEx
#include "control.h"    // for MakeCPLCommandLine, etc
#include <wincrui.h>    // for CredUIInitControls

#include <winsafer.h>   // for ComputeAccessTokenFromCodeAuthzLevel, etc
#include <winsaferp.h>  // for Saferi APIs
#include <softpub.h>    // for WinVerifyTrust constants

#include <lmcons.h>     // for UNLEN (max username length), GNLEN (max groupname length), PWLEN (max password length)

#define DM_MISC     0           // miscellany

#define SZWNDCLASS          TEXT("WndClass")
#define SZTERMEVENT         TEXT("TermEvent")

typedef PSHCREATEPROCESSINFOW PSHCREATEPROCESSINFO;

// stolen from sdk\inc\winbase.h
#define LOGON_WITH_PROFILE              0x00000001

#define IntToHinst(i)     IntToPtr_(HINSTANCE, i)

// the timer id for the kill this DDE window...
#define DDE_DEATH_TIMER_ID  0x00005555

// the timeout value (180 seconds) for killing a dead dde window...
#define DDE_DEATH_TIMEOUT   (1000 * 180)

//  timeout for conversation window terminating with us...
#define DDE_TERMINATETIMEOUT  (10 * 1000)

#define SZCONV            TEXT("ddeconv")
#define SZDDEEVENT        TEXT("ddeevent")

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

void *g_pfnWowShellExecCB = NULL;

class CEnvironmentBlock
{
public:
    ~CEnvironmentBlock() { if (_pszBlock) LocalFree(_pszBlock); }

    void SetToken(HANDLE hToken) { _hToken = hToken; }
    void *GetCustomBlock() { return _pszBlock; }
    HRESULT SetVar(LPCWSTR pszVar, LPCWSTR pszValue);
    HRESULT AppendVar(LPCWSTR pszVar, WCHAR chDelimiter, LPCWSTR pszValue);
private:  //  methods
    HRESULT _InitBlock(DWORD cchNeeded);
    DWORD _BlockLen(LPCWSTR pszEnv);
    DWORD _BlockLenCached();
    BOOL _FindVar(LPCWSTR pszVar, DWORD cchVar, LPWSTR *ppszBlockVar);

private:  //  members
    HANDLE _hToken;
    LPWSTR _pszBlock;
    DWORD _cchBlockSize;
    DWORD _cchBlockLen;
};

typedef enum
{
    CPT_FAILED      = -1,
    CPT_NORMAL      = 0,
    CPT_ASUSER,
    CPT_SANDBOX,
    CPT_INSTALLTS,
    CPT_WITHLOGON,
    CPT_WITHLOGONADMIN,
    CPT_WITHLOGONCANCELLED,
} CPTYPE;

typedef enum {
    TRY_RETRYASYNC      = -1,     //  stop execution (complete on async thread)
    TRY_STOP            = 0,      //  stop execution (completed or failed)
    TRY_CONTINUE,       //  continue exec (did something useful)
    TRY_CONTINUE_UNHANDLED, //  continue exec (did nothing)
} TRYRESULT;

#define KEEPTRYING(tr)      (tr >= TRY_CONTINUE ? TRUE : FALSE)
#define STOPTRYING(tr)      (tr <= TRY_STOP ? TRUE : FALSE)

class CShellExecute
{
public:
    CShellExecute();
    STDMETHODIMP_(ULONG) AddRef()
        {
            return InterlockedIncrement(&_cRef);
        }

    STDMETHODIMP_(ULONG) Release()
        {
            if (InterlockedDecrement(&_cRef))
                return _cRef;

            delete this;
            return 0;
        }

    void ExecuteNormal(LPSHELLEXECUTEINFO pei);
    DWORD Finalize(LPSHELLEXECUTEINFO pei);

    BOOL Init(PSHCREATEPROCESSINFO pscpi);
    void ExecuteProcess(void);
    DWORD Finalize(PSHCREATEPROCESSINFO pscpi);

protected:
    ~CShellExecute();
    // default inits
    HRESULT _Init(LPSHELLEXECUTEINFO pei);

    //  member init methods
    TRYRESULT _InitAssociations(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    HRESULT _InitClassAssociations(LPCTSTR pszClass, HKEY hkClass, DWORD mask);
    HRESULT _InitShellAssociations(LPCTSTR pszFile, LPCITEMIDLIST pidl);
    void _SetMask(ULONG fMask);
    void _SetWorkingDir(LPCTSTR pszIn);
    void _SetFile(LPCTSTR pszIn, BOOL fFileAndUrl);
    void _SetFileAndUrl();
    BOOL _SetDDEInfo(void);
    TRYRESULT _MaybeInstallApp(BOOL fSync);
    TRYRESULT _ShouldRetryWithNewClassKey(BOOL fSync);
    TRYRESULT _SetDarwinCmdTemplate(BOOL fSync);
    BOOL _SetAppRunAsCmdTemplate(void);
    TRYRESULT _SetCmdTemplate(BOOL fSync);
    BOOL _SetCommand(void);
    void _SetStartup(LPSHELLEXECUTEINFO pei);
    void _SetImageName(void);
    IBindCtx *_PerfBindCtx();
    TRYRESULT _PerfPidl(LPCITEMIDLIST *ppidl);

    //  utility methods
    HRESULT _QueryString(ASSOCF flags, ASSOCSTR str, LPTSTR psz, DWORD cch);
    BOOL _CheckForRegisteredProgram(void);
    TRYRESULT _ProcessErrorShouldTryExecCommand(DWORD err, HWND hwnd, BOOL fCreateProcessFailed);
    HRESULT _BuildEnvironmentForNewProcess(LPCTSTR pszNewEnvString);
    void _FixActivationStealingApps(HWND hwndOldActive, int nShow);
    DWORD _GetCreateFlags(ULONG fMask);
    BOOL _Resolve(void);

    //  DDE stuff
    HWND _GetConversationWindow(HWND hwndDDE);
    HWND _CreateHiddenDDEWindow(HWND hwndParent);
    HGLOBAL _CreateDDECommand(int nShow, BOOL fLFNAware, BOOL fNative);
    void _DestroyHiddenDDEWindow(HWND hwnd);
    BOOL _TryDDEShortCircuit(HWND hwnd, HGLOBAL hMem, int nShow);
    BOOL _PostDDEExecute(HWND hwndOurs, HWND hwndTheirs, HGLOBAL hDDECommand, HANDLE hWait);
    BOOL _DDEExecute(BOOL fWillRetry,
                    HWND hwndParent,
                    int   nShowCmd,
                    BOOL fWaitForDDE);

    // exec methods
    TRYRESULT _TryHooks(LPSHELLEXECUTEINFO pei);
    TRYRESULT _TryValidateUNC(LPTSTR pszFile, LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    void _TryOpenExe(void);
    void _TryExecCommand(void);
    void _DoExecCommand(void);
    void _NotifyShortcutInvoke();
    TRYRESULT _TryExecDDE(void);
    TRYRESULT _ZoneCheckFile(PCWSTR pszFile);
    TRYRESULT _VerifyZoneTrust(PCWSTR pszFile);
    TRYRESULT _VerifySaferTrust(PCWSTR pszFile);
    TRYRESULT _VerifyExecTrust(LPSHELLEXECUTEINFO pei);
    TRYRESULT _TryExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    TRYRESULT _DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    BOOL _ShellExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidlExec);
    TRYRESULT _TryInvokeApplication(BOOL fSync);

    //  uninit/error handling methods
    DWORD _FinalMapError(HINSTANCE UNALIGNED64 *phinst);
    BOOL _ReportWin32(DWORD err);
    BOOL _ReportHinst(HINSTANCE hinst);
    DWORD _MapHINSTToWin32Err(HINSTANCE se_err);
    HINSTANCE _MapWin32ErrToHINST(UINT errWin32);

    TRYRESULT _TryWowShellExec(void);
    TRYRESULT _RetryAsync();
    DWORD  _InvokeAppThreadProc();

    static DWORD WINAPI s_InvokeAppThreadProc(void *pv);

    //
    // PRIVATE MEMBERS
    //
    LONG _cRef;
    TCHAR _szFile[INTERNET_MAX_URL_LENGTH];
    TCHAR _szWorkingDir[MAX_PATH];
    TCHAR _szCommand[INTERNET_MAX_URL_LENGTH];
    TCHAR _szCmdTemplate[INTERNET_MAX_URL_LENGTH];
    TCHAR _szDDECmd[MAX_PATH];
    TCHAR _szImageName[MAX_PATH];
    TCHAR _szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD _dwCreateFlags;
    STARTUPINFO _startup;
    int _nShow;
    UINT _uConnect;
    PROCESS_INFORMATION _pi;

    //  used only within restricted scope
    //  to avoid stack usage;
    WCHAR _wszTemp[INTERNET_MAX_URL_LENGTH];
    TCHAR _szTemp[MAX_PATH];

    //  we always pass a UNICODE verb to the _pqa
    WCHAR       _wszVerb[MAX_PATH];
    LPCWSTR     _pszQueryVerb;

    LPCTSTR    _lpParameters;
    LPTSTR     _pszAllocParams;
    LPCTSTR    _lpClass;
    LPCTSTR    _lpTitle;
    LPTSTR     _pszAllocTitle;
    LPCITEMIDLIST _lpID;
    SFGAOF      _sfgaoID;
    LPITEMIDLIST _pidlFree;
    ATOM       _aApplication;
    ATOM       _aTopic;
    LPITEMIDLIST _pidlGlobal;
    IQueryAssociations *_pqa;

    HWND _hwndParent;
    LPSECURITY_ATTRIBUTES _pProcAttrs;
    LPSECURITY_ATTRIBUTES _pThreadAttrs;
    HANDLE _hUserToken;
    HANDLE _hCloseToken;
    CEnvironmentBlock _envblock;
    CPTYPE _cpt;

    //  error state
    HINSTANCE  _hInstance; // hinstance value should only be set with ReportHinst
    DWORD      _err;   //  win32 error value should only be set with ReportWin32

    // FLAGS
    BOOL _fNoUI;                         //  dont show any UI
    BOOL _fUEM;                          //  fire UEM events
    BOOL _fDoEnvSubst;                   // do environment substitution on paths
    BOOL _fUseClass;
    BOOL _fNoQueryClassStore;            // blocks calling darwins class store
    BOOL _fClassStoreOnly;
    BOOL _fIsUrl;                        //_szFile is actually an URL
    BOOL _fActivateHandler;
    BOOL _fTryOpenExe;
    BOOL _fDDEInfoSet;
    BOOL _fDDEWait;
    BOOL _fNoExecPidl;
    BOOL _fNoResolve;                    // unnecessary to resolve this path
    BOOL _fAlreadyQueriedClassStore;     // have we already queried the NT5 class store?
    BOOL _fInheritHandles;
    BOOL _fIsNamespaceObject;            // is namespace object like ::{GUID}, must pidlexec
    BOOL _fWaitForInputIdle;
    BOOL _fUseNullCWD;                   // should we pass NULL as the lpCurrentDirectory param to _SHCreateProcess?
    BOOL _fInvokeIdList;
    BOOL _fAsync;                        // shellexec() switched
};

CShellExecute::CShellExecute() : _cRef(1)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::SHEX Created [%X]", this);
}

CShellExecute::~CShellExecute()
{
    if (_hCloseToken)
        CloseHandle(_hCloseToken);

    // Clean this up if the exec failed
    if (_err != ERROR_SUCCESS && _pidlGlobal)
        SHFreeShared((HANDLE)_pidlGlobal,GetCurrentProcessId());

    if (_aTopic)
        GlobalDeleteAtom(_aTopic);
    if (_aApplication)
        GlobalDeleteAtom(_aApplication);

    if (_pqa)
        _pqa->Release();

    if (_pi.hProcess)
        CloseHandle(_pi.hProcess);

    if (_pi.hThread)
        CloseHandle(_pi.hThread);

    if (_pszAllocParams)
        LocalFree(_pszAllocParams);

    if (_pszAllocTitle)
        LocalFree(_pszAllocTitle);

    ILFree(_pidlFree);

    TraceMsg(TF_SHELLEXEC, "SHEX::SHEX deleted [%X]", this);
}

void CShellExecute::_SetMask(ULONG fMask)
{
    _fDoEnvSubst = (fMask & SEE_MASK_DOENVSUBST);
    _fNoUI       = (fMask & SEE_MASK_FLAG_NO_UI);
    _fUEM        = (fMask & SEE_MASK_FLAG_LOG_USAGE);
    _fNoQueryClassStore = (fMask & SEE_MASK_NOQUERYCLASSSTORE) || !IsOS(OS_DOMAINMEMBER);
    _fDDEWait = fMask & SEE_MASK_FLAG_DDEWAIT;
    _fWaitForInputIdle = fMask & SEE_MASK_WAITFORINPUTIDLE;
    _fUseClass   = _UseClassName(fMask) || _UseClassKey(fMask);
    _fInvokeIdList = _InvokeIDList(fMask);

    _dwCreateFlags = _GetCreateFlags(fMask);
    _uConnect = fMask & SEE_MASK_CONNECTNETDRV ? VALIDATEUNC_CONNECT : 0;
    if (_fNoUI)
        _uConnect |= VALIDATEUNC_NOUI;

    // must be off for this condition to pass.

    // PARTIAL ANSWER (reinerf): the SEE_MASK_FILEANDURL has to be off
    // so we can wait until we find out what the associated App is and query
    // to find out whether they want the the cache filename or the URL name passed
    // on the command line.
#define NOEXECPIDLMASK   (SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_FORCENOIDLIST | SEE_MASK_FILEANDURL)
    _fNoExecPidl = BOOLIFY(fMask & NOEXECPIDLMASK);
}

HRESULT CShellExecute::_Init(LPSHELLEXECUTEINFO pei)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_Init()");

    _SetMask(pei->fMask);

    _lpParameters = pei->lpParameters;
    _lpID        = (LPITEMIDLIST)((pei->fMask) & SEE_MASK_PIDL ? pei->lpIDList : NULL);
    _lpTitle     = _UseTitleName(pei->fMask) ? pei->lpClass : NULL;


    //  default to TRUE;
    _fActivateHandler = TRUE;

    if (pei->lpVerb && *(pei->lpVerb))
    {
        SHTCharToUnicode(pei->lpVerb, _wszVerb, SIZECHARS(_wszVerb));
        _pszQueryVerb = _wszVerb;

        if (0 == lstrcmpi(pei->lpVerb, TEXT("runas")))
            _cpt = CPT_WITHLOGON;
    }

    _hwndParent = pei->hwnd;

    pei->hProcess = 0;

    _nShow = pei->nShow;

    //  initialize the startup struct
    _SetStartup(pei);

    return S_OK;
}

void CShellExecute::_SetWorkingDir(LPCTSTR pszIn)
{
        //  if we were given a directory, we attempt to use it
    if (pszIn && *pszIn)
    {
        StrCpyN(_szWorkingDir, pszIn, SIZECHARS(_szWorkingDir));
        if (_fDoEnvSubst)
            DoEnvironmentSubst(_szWorkingDir, SIZECHARS(_szWorkingDir));

        //
        // if the passed directory is not valid (after env subst) dont
        // fail, act just like Win31 and use whatever the current dir is.
        //
        // Win31 is stranger than I could imagine, if you pass ShellExecute
        // an invalid directory, it will change the current drive.
        //
        if (!PathIsDirectory(_szWorkingDir))
        {
            if (PathGetDriveNumber(_szWorkingDir) >= 0)
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() bad directory %s, using %c:", _szWorkingDir, _szWorkingDir[0]);
                PathStripToRoot(_szWorkingDir);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() bad directory %s, using current dir", _szWorkingDir);
                GetCurrentDirectory(SIZECHARS(_szWorkingDir), _szWorkingDir);
            }
        }
        else
        {
            goto Done;
        }
    }
    else
    {
        // if we are doing a SHCreateProcessAsUser or a normal shellexecute w/ the "runas" verb, and
        // the caller passed NULL for lpCurrentDirectory then we we do NOT want to fall back and use
        // the CWD because the newly logged on user might not have permissions in the current users CWD.
        // We will have better luck just passing NULL and letting the OS figure it out.
        if (_cpt != CPT_NORMAL)
        {
            _fUseNullCWD = TRUE;
            goto Done;
        }
        else
        {
            GetCurrentDirectory(SIZECHARS(_szWorkingDir), _szWorkingDir);
        }
    }

    //  there are some cases where even CD is bad.
    //  and CreateProcess() will then fail.
    if (!PathIsDirectory(_szWorkingDir))
    {
        GetWindowsDirectory(_szWorkingDir, SIZECHARS(_szWorkingDir));
    }

Done:
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() pszIn = %s, NewDir = %s", pszIn, _szWorkingDir);

}

inline BOOL _IsNamespaceObject(LPCTSTR psz)
{
    return (psz[0] == L':' && psz[1] == L':' && psz[2] == L'{');
}

void CShellExecute::_SetFile(LPCTSTR pszIn, BOOL fFileAndUrl)
{
    if (pszIn && pszIn[0])
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileName() Entered pszIn = %s", pszIn);

        _fIsUrl = UrlIs(pszIn, URLIS_URL);
        StrCpyN(_szFile, pszIn, SIZECHARS(_szFile));
        _fIsNamespaceObject = (!_fInvokeIdList && !_fUseClass && _IsNamespaceObject(_szFile));

        if (_fDoEnvSubst)
            DoEnvironmentSubst(_szFile, SIZECHARS(_szFile));

        if (fFileAndUrl)
        {
            ASSERT(!_fIsUrl);
            // our lpFile points to a string that contains both an Internet Cache
            // File location and the URL name that is associated with that cache file
            // (they are seperated by a single NULL). The application that we are
            // about to execute wants the URL name instead of the cache file, so
            // use it instead.
            int iLength = lstrlen(pszIn);
            LPCTSTR pszUrlPart = &pszIn[iLength + 1];

            if (IsBadStringPtr(pszUrlPart, INTERNET_MAX_URL_LENGTH) || !PathIsURL(pszUrlPart))
            {
                ASSERT(FALSE);
            }
            else
            {
                // we have a vaild URL, so use it
                lstrcpy(_szUrl, pszUrlPart);
            }
        }
    }
    else
    {
        //  LEGACY - to support shellexec() of directories.
        if (!_lpID)
            StrCpyN(_szFile, _szWorkingDir, SIZECHARS(_szFile));
    }

    PathUnquoteSpaces(_szFile);

    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileName() exit:  szFile = %s", _szFile);

}

void CShellExecute::_SetFileAndUrl()
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileAndUrl() enter:  pszIn = %s", _szUrl);

    if (*_szUrl && SUCCEEDED(_QueryString(0, ASSOCSTR_EXECUTABLE, _szTemp, SIZECHARS(_szTemp)))
    &&  DoesAppWantUrl(_szTemp))
    {
        // we have a vaild URL, so use it
        lstrcpy(_szFile, _szUrl);
    }
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileAndUrl() exit: szFile = %s",_szFile);

}

//
//  _TryValidateUNC() has queer return values
//
TRYRESULT CShellExecute::_TryValidateUNC(LPTSTR pszFile, LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;

    if (PathIsUNC(pszFile))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC Is UNC: %s", pszFile);
        // Notes:
        //  SHValidateUNC() returns FALSE if it failed. In such a case,
        //   GetLastError will gives us the right error code.
        //
        if (!(_sfgaoID & SFGAO_FILESYSTEM) && !SHValidateUNC(_hwndParent, pszFile, _uConnect))
        {
            tr = TRY_STOP;
            // Note that SHValidateUNC calls SetLastError() and we need
            // to preserve that so that the caller makes the right decision
            DWORD err = GetLastError();

            if (ERROR_CANCELLED == err)
            {
                // Not a print share, use the error returned from the first call
                // _ReportWin32(ERROR_CANCELLED);
                //  we dont need to report this error, it is the callers responsibility
                //  the caller should GetLastError() on E_FAIL and do a _ReportWin32()
                TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC FAILED with ERROR_CANCELLED");
            }
            else if (pei && ERROR_NOT_SUPPORTED == err && PathIsUNC(pszFile))
            {
                //
                // Now check to see if it's a print share, if it is, we need to exec as pidl
                //
                //  we only check for print shares when ERROR_NOT_SUPPORTED is returned
                //  from the first call to SHValidateUNC().  this error means that
                //  the RESOURCETYPE did not match the requested.
                //
                // Note: This call should not display "connect ui" because SHValidateUNC()
                //  will already have shown UI if necessary/possible.
                // CONNECT_CURRENT_MEDIA is not used by any provider (per JSchwart)
                //
                if (SHValidateUNC(_hwndParent, pszFile, VALIDATEUNC_NOUI | VALIDATEUNC_PRINT))
                {
                    tr = TRY_CONTINUE;
                    TraceMsg(TF_SHELLEXEC, "SHEX::TVUNC found print share");
                }
                else
                    // need to reset the orginal error ,cuz SHValidateUNC() has set it again
                    SetLastError(err);

            }
        }
        else
        {
            TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC UNC is accessible");
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC exit: hr = %X", hr);

    switch (tr)
    {
//  TRY_CONTINUE_UNHANDLED  pszFile is not a UNC or is a valid UNC according to the flags
//  TRY_CONTINUE            pszFile is a valid UNC to a print share
//  TRY_STOP                pszFile is a UNC but cannot be validated use GetLastError() to get the real error
        case TRY_CONTINUE:
            //  we got a good UNC
            ASSERT(pei);
            tr = _DoExecPidl(pei, pidl);
            //  if we dont get a pidl we just try something else.
            break;

        case TRY_STOP:
            if (pei)
                _ReportWin32(GetLastError());
            tr = TRY_STOP;
            break;

        default:
            break;
    }

    return tr;
}

HRESULT  _InvokeInProcExec(IContextMenu *pcm, LPSHELLEXECUTEINFO pei)
{
    HRESULT hr = E_OUTOFMEMORY;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        CMINVOKECOMMANDINFOEX ici;
        void * pvFree;
        if (SUCCEEDED(SEI2ICIX(pei, &ici, &pvFree)))
        {
            BOOL fDefVerb (ici.lpVerb == NULL || *ici.lpVerb == 0);
            // This optimization eliminate creating handlers that
            // will not change the default verb
            UINT uFlags = fDefVerb ? CMF_DEFAULTONLY : 0;
            ici.fMask |= CMIC_MASK_FLAG_NO_UI;

            hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, uFlags);
            if (SUCCEEDED(hr))
            {
                if (fDefVerb)
                {
                    UINT idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                    if (-1 == idCmd)
                    {
                        //  i dont think we should ever get here...
                        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(0);  // best guess
                    }
                    else
                        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }

                hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

            }

            if (pvFree)
                LocalFree(pvFree);
        }

        DestroyMenu(hmenu);
    }

    return hr;
}

BOOL CShellExecute::_ShellExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidlExec)
{
    IContextMenu *pcm;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlExec, pei->hwnd, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = _InvokeInProcExec(pcm, pei);

        pcm->Release();
    }

    if (FAILED(hr))
    {
        DWORD errWin32 = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : GetLastError();
        if (!errWin32)
            errWin32 = ERROR_ACCESS_DENIED;

        if (errWin32 != ERROR_CANCELLED)
            _ReportWin32(errWin32);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::_ShellExecPidl() exiting hr = %X", hr);

    return(SUCCEEDED(hr));
}


//
//  BOOL CShellExecute::_DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
//
//  returns TRUE if a pidl was created, FALSE otherwise
//
TRYRESULT CShellExecute::_DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_DoExecPidl enter: szFile = %s", _szFile);

    LPITEMIDLIST pidlFree = NULL;
    if (!pidl)
        pidl = pidlFree = ILCreateFromPath(_szFile);

    if (pidl)
    {
        //
        //  if _ShellExecPidl() FAILS, it does
        //  Report() for us
        //
        _ShellExecPidl(pei, pidl);

        if (pidlFree)
            ILFree(pidlFree);

        return TRY_STOP;
    }
    else
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_DoExecPidl() unhandled cuz ILCreateFromPath() failed");

        return TRY_CONTINUE;
    }
}


/*----------------------------------------------------------
Purpose: This function looks up the given file in "HKLM\Software\
         Microsoft\Windows\CurrentVersion\App Paths" to
         see if it has an absolute path registered.

Returns: TRUE if the file has a registered path
         FALSE if it does not or if the provided filename has
               a relative path already


Cond:    !! Side effect: the szFile field may be changed by
         !! this function.

*/
BOOL CShellExecute::_CheckForRegisteredProgram(void)
{
    TCHAR szTemp[MAX_PATH];
    TraceMsg(TF_SHELLEXEC, "SHEX::CFRP entered");

    // Only supported for files with no paths specified
    if (PathFindFileName(_szFile) != _szFile)
        return FALSE;

    if (PathToAppPath(_szFile, szTemp))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::CFRP Set szFile = %s", szTemp);

        StrCpy(_szFile, szTemp);
        return TRUE;
    }

    return FALSE;
}

BOOL CShellExecute::_Resolve(void)
{
    // No; get the fully qualified path and add .exe extension
    // if needed
    LPCTSTR rgszDirs[2] =  { _szWorkingDir, NULL };
    const UINT uFlags = PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS | PRF_FIRSTDIRDEF;

    // if the Path is not an URL
    // and the path cant be resolved
    //
    //  PathResolve() now does SetLastError() when we pass VERIFYEXISTS
    //  this means that we can be assure if all these tests fail
    //  that LastError is set.
    //
    if (!_fNoResolve && !_fIsUrl && !_fIsNamespaceObject &&
        !PathResolve(_szFile, rgszDirs, uFlags))
    {
        //  _CheckForRegisteredProgram() changes _szFile if
        //  there is a registered program in the registry
        //  so we recheck to see if it exists.
        if (!_CheckForRegisteredProgram() ||
             !PathResolve(_szFile, rgszDirs, uFlags))
        {
            DWORD cchFile = ARRAYSIZE(_szFile);
            if (S_OK != UrlApplyScheme(_szFile, _szFile, &cchFile, URL_APPLY_GUESSSCHEME))
            {
                // No; file not found, bail out
                //
                //  WARNING LEGACY - we must return ERROR_FILE_NOT_FOUND - ZekeL - 14-APR-99
                //  some apps, specifically Netscape Navigator 4.5, rely on this
                //  failing with ERROR_FILE_NOT_FOUND.  so even though PathResolve() does
                //  a SetLastError() to the correct error we cannot propagate that up
                //
                _ReportWin32(ERROR_FILE_NOT_FOUND);
                ASSERT(_err);
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl FAILED %d", _err);

                return FALSE;
            }
            else
                _fIsUrl = TRUE;
        }
    }

    return TRUE;
}


//  this is the SAFER exe detection API
//  only use if this is really a file system file
//  and we are planning on using CreateProcess()
TRYRESULT CShellExecute::_VerifySaferTrust(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    DWORD dwPolicy, cbPolicy;

    if (_cpt == CPT_NORMAL
    && SaferGetPolicyInformation(
                    SAFER_SCOPEID_MACHINE,
                    SaferPolicyEnableTransparentEnforcement,
                    sizeof(dwPolicy), &dwPolicy, &cbPolicy, NULL)
    && dwPolicy != 0
    && SaferiIsExecutableFileType(pszFile, TRUE)
    && (_pszQueryVerb && !StrCmpIW(_pszQueryVerb, L"open")))
    {
        SAFER_LEVEL_HANDLE hAuthzLevel;
        SAFER_CODE_PROPERTIES codeprop;

        // prepare the code properties struct.
        memset(&codeprop, 0, sizeof(codeprop));
        codeprop.cbSize = sizeof(SAFER_CODE_PROPERTIES);
        codeprop.dwCheckFlags = SAFER_CRITERIA_IMAGEPATH |
                                  SAFER_CRITERIA_IMAGEHASH |
                                  SAFER_CRITERIA_AUTHENTICODE;
        codeprop.ImagePath = pszFile;
        codeprop.dwWVTUIChoice = WTD_UI_NOBAD;
        codeprop.hWndParent = _hwndParent;

        //
        // check if file extension is of executable type, don't care on error
        //

        // evaluate all of the criteria and get the resulting level.
        if (SaferIdentifyLevel(
                         1,              // only 1 element in codeprop[]
                         &codeprop,      // pointer to one-element array
                         &hAuthzLevel,   // receives identified level
                         NULL)) 
        {

            //
            // try to log an event in case level != SAFER_LEVELID_FULLYTRUSTED
            //

            // compute the final restricted token that should be used.
            ASSERT(_hCloseToken == NULL);
            if (SaferComputeTokenFromLevel(
                                     hAuthzLevel,        // identified level restrictions
                                     NULL,               // source token
                                     &_hUserToken,       // resulting restricted token
                                     SAFER_TOKEN_NULL_IF_EQUAL,
                                     NULL)) 
            {
                if (_hUserToken) 
                {
                    _cpt = CPT_ASUSER;
                    //  WARNING - runas is needed to circumvent DDE - ZekeL - 31 -JAN-2001
                    //  we must set runas as the verb so that we make sure
                    //  that we are not using a type that is going to do window reuse
                    //  via DDE (or anything else).  if they dont support runas, then the
                    //  the exec will fail, intentionally.
                    _pszQueryVerb = L"runas";
                    tr = TRY_CONTINUE;
                }
                _hCloseToken = _hUserToken;     // potentially NULL
            } 
            else 
            {
                // TODO: add event logging callback here.
                _ReportWin32(GetLastError());
                SaferRecordEventLogEntry(hAuthzLevel, pszFile, NULL);
                tr = TRY_STOP;
            }

            if (tr != TRY_STOP)
            {
                //  we havent added anything to our log
                //  try to log an event in case level != AUTHZLEVELID_FULLYTRUST ED
                DWORD   dwLevelId;
                DWORD   dwBufferSize;
                if (SaferGetLevelInformation(
                        hAuthzLevel,
                        SaferObjectLevelId,
                        &dwLevelId,
                        sizeof(DWORD),
                        &dwBufferSize)) 
                {

                    if ( dwLevelId != SAFER_LEVELID_FULLYTRUSTED ) 
                    {

                        SaferRecordEventLogEntry(hAuthzLevel,
                                                  pszFile,
                                                  NULL);
                    }
                }
            }

            SaferCloseLevel(hAuthzLevel);
        } 
        else 
        {
            _ReportWin32(GetLastError());
            tr = TRY_STOP;
        }
    }

    return tr;
}

HANDLE _GetSandboxToken()
{
    SAFER_LEVEL_HANDLE hConstrainedAuthz;
    HANDLE hSandboxToken = NULL;

    // right now we always use the SAFER_LEVELID_CONSTRAINED to "sandbox" the process
    if (SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                         SAFER_LEVELID_CONSTRAINED,
                         SAFER_LEVEL_OPEN,
                         &hConstrainedAuthz,
                         NULL))
    {
        if (!SaferComputeTokenFromLevel(
                    hConstrainedAuthz,
                    NULL,
                    &hSandboxToken,
                    0,
                    NULL)) {
            hSandboxToken = NULL;
        }

        SaferCloseLevel(hConstrainedAuthz);
    }

    return hSandboxToken;
}

TRYRESULT CShellExecute::_ZoneCheckFile(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_STOP;
    //  now we need to determine if it is intranet or local zone
    DWORD dwPolicy = 0, dwContext = 0;
    ZoneCheckUrlEx(pszFile, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                URLACTION_SHELL_SHELLEXECUTE, PUAF_ISFILE | PUAF_NOUI, NULL);
    dwPolicy = GetUrlPolicyPermissions(dwPolicy);
    switch (dwPolicy)
    {
    case URLPOLICY_ALLOW:
        tr = TRY_CONTINUE_UNHANDLED;
        //  continue
        break;

    case URLPOLICY_QUERY:
        if (SafeOpenPromptForShellExec(_hwndParent, pszFile))
        {
            tr = TRY_CONTINUE;
        }
        else
        {
            //  user cancelled
            tr = TRY_STOP;
            _ReportWin32(ERROR_CANCELLED);
        }
        
        break;

    case URLPOLICY_DISALLOW:
        tr = TRY_STOP;
        _ReportWin32(ERROR_ACCESS_DENIED);
        break;

    default:
        ASSERT(FALSE);
        break;
    
    }
    return tr;
}

TRYRESULT CShellExecute::_VerifyZoneTrust(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    //
    //  pszFile maybe different than _szFile in the case of being invoked by a LNK or URL
    //  in this case we could prompt for either but not both
    //  we only care about the target file's type for determining dangerousness
    //  so that shortcuts to TXT files should never get a prompt.
    //  if (pszFile == internet) prompt(pszFile)
    //  else if (_szFile = internet prompt(_szFile)
    //
    if (AssocIsDangerous(PathFindExtension(_szFile)))
    {
        //  first try 
        tr = _ZoneCheckFile(pszFile);
        if (tr == TRY_CONTINUE_UNHANDLED && pszFile != _szFile)
            tr = _ZoneCheckFile(_szFile);
    }
       
    return tr;
}

TRYRESULT CShellExecute::_VerifyExecTrust(LPSHELLEXECUTEINFO pei)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if ((_sfgaoID & (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_STREAM)) == (SFGAO_FILESYSTEM | SFGAO_STREAM))
    {
        //  if this is a FILE, we check for security implications
        //  if fHasLinkName is set, then this invoke originates from an LNK file
        //  the _lpTitle should have the acual path to the LNK.  we want to verify 
        //  our trust of that more than the trust of the target
        PCWSTR pszFile = (pei->fMask & SEE_MASK_HASLINKNAME && _lpTitle) ? _lpTitle : _szFile;

        BOOL fZoneCheck = !(pei->fMask & SEE_MASK_NOZONECHECKS);
        if (fZoneCheck)
        {
            //  630796 - check the env var for policy scripts - ZekeL - 31-MAY-2002
            //  scripts cannot be updated, and they need to be trusted
            //  since a script can call into more scripts without passing
            //  the SEE_MASK_NOZONECHECKS.
            if (GetEnvironmentVariable(L"SEE_MASK_NOZONECHECKS", _szTemp, ARRAYSIZE(_szTemp)))
            {
                fZoneCheck = (0 != StrCmpICW(_szTemp, L"1"));
                ASSERT(!IsProcessAnExplorer());
            }
        }

        if (fZoneCheck)
            tr = _VerifyZoneTrust(pszFile);

        if (tr == TRY_CONTINUE_UNHANDLED)
            tr = _VerifySaferTrust(pszFile);
    }
    return tr;
}

/*----------------------------------------------------------
Purpose: decide whether it is appropriate to TryExecPidl()

Returns: S_OK        if it should _DoExecPidl()
         S_FALSE     it shouldnt _DoExecPidl()
         E_FAIL      ShellExec should quit  Report*() has the real error


Cond:    !! Side effect: the szFile field may be changed by
         !! this function.

*/
TRYRESULT CShellExecute::_TryExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl entered szFile = %s", _szFile);

    //
    // If we're explicitly given a class then we don't care if the file exists.
    // Just let the handler for the class worry about it, and _TryExecPidl()
    // will return the default of FALSE.
    //

    //  these should never coincide
    RIP(!(_fInvokeIdList && _fUseClass));

    if ((*_szFile || pidl)
    && (!_fUseClass || _fInvokeIdList || _fIsNamespaceObject))
    {
        if (!pidl && !_fNoResolve && !_Resolve())
        {
            tr = TRY_STOP;
        }
        
        if (tr == TRY_CONTINUE_UNHANDLED)
        {
            // The optimal execution path is to check for the default
            // verb and exec the pidl.  It is smarter than all this path
            // code (it calls the context menu handlers, etc...)

            if ((!_pszQueryVerb && !(_fNoExecPidl))
            ||  _fIsUrl
            ||  _fInvokeIdList            //  caller told us to!
            ||  _fIsNamespaceObject      //  namespace objects can only be invoked through pidls
            ||  (_sfgaoID & SFGAO_LINK)
            ||  (!pidl && PathIsShortcut(_szFile, -1))) //  to support LNK files and soon URL files
            {
                //  this means that we can tryexecpidl
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl() succeeded now TEP()");
                tr = _DoExecPidl(pei, pidl);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl dont bother");
            }
        }
    }
    else
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl dont bother");
    }

    if (KEEPTRYING(tr))
    {
        tr = _VerifyExecTrust(pei);
    }

    return tr;
}

HRESULT CShellExecute::_InitClassAssociations(LPCTSTR pszClass, HKEY hkClass, DWORD mask)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::InitClassAssoc enter: lpClass = %s, hkClass = %X", pszClass, hkClass);

    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));
    if (SUCCEEDED(hr))
    {
        if (_UseClassKey(mask))
        {
            hr = _pqa->Init(0, NULL, hkClass, NULL);
        }
        else if (_UseClassName(mask))
        {
            hr = _pqa->Init(0, pszClass, NULL, NULL);
        }
        else
        {
            //  LEGACY - they didnt pass us anything to go on so we default to folder
            //  because of the chaos of the original shellexec() we didnt even notice
            //  when we had nothing to be associated with, and just used
            //  our base key, which turns out to be explorer.
            //  this permitted ShellExecute(NULL, "explore", NULL, NULL, NULL, SW_SHOW);
            //  to succeed.  in order to support this, we will fall back to it here.
            hr = _pqa->Init(0, L"Folder", NULL, NULL);
        }
    }

    return hr;
}

HRESULT CShellExecute::_InitShellAssociations(LPCTSTR pszFile, LPCITEMIDLIST pidl)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::InitShellAssoc enter: pszFile = %s, pidl = %X", pszFile, pidl);

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFree = NULL;
    if (*pszFile)
    {
        if (!pidl)
        {
            hr = SHILCreateFromPath(pszFile, &pidlFree, NULL);

            if (SUCCEEDED(hr))
                pidl = pidlFree;
        }
    }
    else if (pidl)
    {
        // Other parts of CShellExecute expect that _szFile is
        // filled in, so we may as well do it here.
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, _szFile, SIZECHARS(_szFile), NULL);
        _fNoResolve = TRUE;
    }

    if (pidl)
    {
        //  NT#413115 - ShellExec("D:\") does AutoRun.inf instead of Folder.Open - ZekeL - 25-JUN-2001
        //  this is because drivflder now explicitly supports GetUIObjectOf(IQueryAssociations)
        //  whereas it didnt in win2k, so that SHGetAssociations() would fallback to "Folder".
        //  to emulate this, we communicate that this associations object is going to be
        //  used by ShellExec() for invocation, so we dont want all of the keys in the assoc array.
        //
        IBindCtx *pbc;
        TBCRegisterObjectParam(L"ShellExec SHGetAssociations", NULL, &pbc);
        hr = SHGetAssociations(pidl, (void **)&_pqa);
        if (pbc)
            pbc->Release();

        // NOTE: sometimes we can have the extension or even the progid in the registry, but there
        // is no "shell" subkey. An example of this is for .xls files in NT5: the index server guys
        // create HKCR\.xls and HKCR\Excel.Sheet.8 but all they put under Excel.Sheet.8 is the clsid.
        //
        //  so we need to check and make sure that we have a valid command value for
        //  this object.  if we dont, then that means that this is not valid
        //  class to shellexec with.  we need to fall back to the Unknown key
        //  so that we can query the Darwin/NT5 ClassStore and/or
        //  show the openwith dialog box.
        //
        DWORD cch;
        if (FAILED(hr) ||
        (FAILED(_pqa->GetString(0, ASSOCSTR_COMMAND, _pszQueryVerb, NULL, &cch))
        && FAILED(_pqa->GetData(0, ASSOCDATA_MSIDESCRIPTOR, _pszQueryVerb, NULL, &cch))))

        {
            if (!_pqa)
                hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));

            if (_pqa)
            {
                hr = _pqa->Init(0, L"Unknown", NULL, NULL);

                //  this allows us to locate something
                //  in the class store, but restricts us
                //  from using the openwith dialog if the
                //  caller instructed NOUI
                if (SUCCEEDED(hr) && _fNoUI)
                    _fClassStoreOnly = TRUE;
            }
        }

    }
    else
    {
        LPCTSTR pszExt = PathFindExtension(_szFile);
        if (*pszExt)
        {
            hr = _InitClassAssociations(pszExt, NULL, SEE_MASK_CLASSNAME);
            if (S_OK!=hr)
            {
                TraceMsg(TF_WARNING, "SHEX::InitAssoc parsing failed, but there is a valid association for *.%s", pszExt);
            }
        }
    }

    if (pidlFree)
        ILFree(pidlFree);

    return hr;
}

TRYRESULT CShellExecute::_InitAssociations(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    if (pei && (_fUseClass || (!_szFile[0] && !_lpID)))
    {
        hr = _InitClassAssociations(pei->lpClass, pei->hkeyClass, pei->fMask);
    }
    else
    {
        hr = _InitShellAssociations(_szFile, pidl ? pidl : _lpID);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::InitAssoc return %X", hr);

    if (FAILED(hr))
    {
        if (PathIsExe(_szFile))
            _fTryOpenExe = TRUE;
        else
            _ReportWin32(ERROR_NO_ASSOCIATION);
    }

    return SUCCEEDED(hr) ? TRY_CONTINUE : TRY_STOP;
}

void CShellExecute::_TryOpenExe(void)
{
    //
    //  this is the last chance that a file will have
    //  we shouldnt even be here in any case
    //  unless the registry has been thrashed, and
    //  the exe classes are all deleted from HKCR
    //
    ASSERT(PathIsExe(_szFile));

    // even with no association, we know how to open an executable
    if ((!_pszQueryVerb || !StrCmpIW(_pszQueryVerb, L"open")))
    {
        //  _SetCommand() by hand here...

        // NB WinExec can handle long names so there's no need to convert it.
        StrCpy(_szCommand, _szFile);

        //
        // We need to append the parameter
        //
        if (_lpParameters && *_lpParameters)
        {
            StrCatBuff(_szCommand, c_szSpace, ARRAYSIZE(_szCommand));
            StrCatBuff(_szCommand, _lpParameters, ARRAYSIZE(_szCommand));
        }

        TraceMsg(TF_SHELLEXEC, "SHEX::TryOpenExe() command = %s", _szCommand);

        //  _TryExecCommand() sets the fSucceeded if appropriate
        _DoExecCommand();
    }
    else
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::TryOpenExe() wrong verb");
        _ReportWin32(ERROR_INVALID_PARAMETER);
    }
}

TRYRESULT CShellExecute::_ProcessErrorShouldTryExecCommand(DWORD err, HWND hwnd, BOOL fCreateProcessFailed)
{
    TRYRESULT tr = TRY_STOP;

    //  insure that we dont lose this error.
    BOOL fNeedToReport = TRUE;

    TraceMsg(TF_SHELLEXEC, "SHEX::PESTEC() enter : err = %d", err);

    // special case some error returns
    switch (err)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
    case ERROR_BAD_PATHNAME:
    case ERROR_INVALID_NAME:
        if ((_szCmdTemplate[0] != TEXT('%')) && fCreateProcessFailed)
        {
            UINT uAppType = LOWORD(GetExeType(_szImageName));
            if ((uAppType == NEMAGIC))
            {
            }
            else if (uAppType != PEMAGIC && !_fNoUI)   // ie, it was not found
            {
                HKEY hk;

                if (_pqa)
                    _pqa->GetKey(0, ASSOCKEY_CLASS, NULL, &hk);
                else
                    hk = NULL;

                //
                // have user help us find missing exe
                //
                int iret  = FindAssociatedExe(hwnd, _szCommand, ARRAYSIZE(_szCommand), _szFile, hk);

                if (hk)
                    RegCloseKey(hk);

                //
                //  We infinitely retry until either the user cancel it
                // or we find it.
                //
                if (iret == -1)
                {
                    tr = TRY_CONTINUE;
                    TraceMsg(TF_SHELLEXEC, "SHEX::PESTEC() found new exe");
                }
                else
                    _ReportWin32(ERROR_CANCELLED);

                //  either way we dont need to report this error
                fNeedToReport = FALSE;
            }
        }
        break;
    } // switch (errWin32)


    if (fNeedToReport)
        _ReportWin32(err);

    TraceMsg(TF_SHELLEXEC, "SHEX::PESTEC() return %d", tr);

    return tr;
}

void CShellExecute::_SetStartup(LPSHELLEXECUTEINFO pei)
{
    // Was zero filled by Alloc...
    ASSERT(!_startup.cb);
    _startup.cb = sizeof(_startup);
    _startup.dwFlags |= STARTF_USESHOWWINDOW;
    _startup.wShowWindow = (WORD) pei->nShow;
    _startup.lpTitle = (LPTSTR)_lpTitle;

    if (pei->fMask & SEE_MASK_RESERVED)
    {
        _startup.lpReserved = (LPTSTR)pei->hInstApp;
    }

    if ((pei->fMask & SEE_MASK_HASLINKNAME) && _lpTitle)
    {
        _startup.dwFlags |= STARTF_TITLEISLINKNAME;
    }

    if (pei->fMask & SEE_MASK_HOTKEY)
    {
        _startup.hStdInput = LongToHandle(pei->dwHotKey);
        _startup.dwFlags |= STARTF_USEHOTKEY;
    }


// Multi-monitor support (dli) pass a hMonitor to createprocess

#ifndef STARTF_HASHMONITOR
#define STARTF_HASHMONITOR       0x00000400  // same as HASSHELLDATA
#endif

    if (pei->fMask & SEE_MASK_ICON)
    {
        _startup.hStdOutput = (HANDLE)pei->hIcon;
        _startup.dwFlags |= STARTF_HASSHELLDATA;
    }
    else if (pei->fMask & SEE_MASK_HMONITOR)
    {
        _startup.hStdOutput = (HANDLE)pei->hMonitor;
        _startup.dwFlags |= STARTF_HASHMONITOR;
    }
    else if (pei->hwnd)
    {
        _startup.hStdOutput = (HANDLE)MonitorFromWindow(pei->hwnd,MONITOR_DEFAULTTONEAREST);
        _startup.dwFlags |= STARTF_HASHMONITOR;
    }
    TraceMsg(TF_SHELLEXEC, "SHEX::SetStartup() called");

}

DWORD CEnvironmentBlock::_BlockLen(LPCWSTR pszEnv)
{
    LPCWSTR psz = pszEnv;
    while (*psz)
    {
        psz += lstrlen(psz)+1;
    }
    return (DWORD)(psz - pszEnv) + 1;
}

DWORD CEnvironmentBlock::_BlockLenCached()
{
    if (!_cchBlockLen && _pszBlock)
    {
        _cchBlockLen = _BlockLen(_pszBlock);
    }
    return _cchBlockLen;
}

HRESULT CEnvironmentBlock::_InitBlock(DWORD cchNeeded)
{
    if (_BlockLenCached() + cchNeeded > _cchBlockSize)
    {
        if (!_pszBlock)
        {
            //  we need to create a new block.
            LPTSTR pszEnv = GetEnvBlock(_hToken);
            if (pszEnv)
            {
                // Now lets allocate some memory for our block.
                //   -- Why 10 and not 11?  Or 9? --
                // Comment from BobDay: 2 of the 10 come from nul terminators of the
                // pseem->_szTemp and cchT strings added on.  The additional space might
                // come from the fact that 16-bit Windows used to pass around an
                // environment block that had some extra stuff on the end.  The extra
                // stuff had things like the path name (argv[0]) and a nCmdShow value.
                DWORD cchEnv = _BlockLen(pszEnv);
                DWORD cchAlloc = ROUNDUP(cchEnv + cchNeeded + 10, 256);
                _pszBlock = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchAlloc));
                if (_pszBlock)
                {
                    //  copy stuff over
                    CopyMemory(_pszBlock, pszEnv, CbFromCchW(cchEnv));
                    _cchBlockSize = cchAlloc - 10;  // leave the 10 out
                    _cchBlockLen = cchEnv;
                }
                FreeEnvBlock(_hToken, pszEnv);
            }
        }
        else
        {
            //  need to resize the current block
            DWORD cchAlloc = ROUNDUP(_cchBlockSize + cchNeeded + 10, 256);
            LPWSTR pszNew = (LPWSTR)LocalReAlloc(_pszBlock, CbFromCchW(cchAlloc), LMEM_MOVEABLE);
            if (pszNew)
            {
                _cchBlockSize = cchAlloc - 10;  // leave the 10 out
                _pszBlock = pszNew;
            }
        }
    }

    return (_BlockLenCached() + cchNeeded <= _cchBlockSize) ? S_OK : E_OUTOFMEMORY;
}

BOOL CEnvironmentBlock::_FindVar(LPCWSTR pszVar, DWORD cchVar, LPWSTR *ppszBlockVar)
{
    int iCmp = CSTR_LESS_THAN;
    LPTSTR psz = _pszBlock;
    ASSERT(_pszBlock);
    for ( ; *psz && iCmp == CSTR_LESS_THAN; psz += lstrlen(psz)+1)
    {
        iCmp = CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, psz, cchVar, pszVar, cchVar);
        *ppszBlockVar = psz;
    }

    if (iCmp == CSTR_LESS_THAN)
        *ppszBlockVar = psz;

    return iCmp == CSTR_EQUAL;
}

HRESULT CEnvironmentBlock::SetVar(LPCWSTR pszVar, LPCWSTR pszValue)
{
    //  additional size needed in worst case scenario.
    //  var + val + '=' + NULL
    DWORD cchValue = lstrlenW(pszValue);
    DWORD cchVar = lstrlenW(pszVar);
    DWORD cchNeeded = cchVar + cchValue + 2;
    HRESULT hr = _InitBlock(cchNeeded);
    if (SUCCEEDED(hr))
    {
        //  we have enough room in our private block
        //  to copy the whole thing
        LPWSTR pszBlockVar;
        if (_FindVar(pszVar, cchVar, &pszBlockVar))
        {
            //  we need to replace this var
            LPWSTR pszBlockVal = StrChrW(pszBlockVar, L'=');
            DWORD cchBlockVal = lstrlenW(++pszBlockVal);
            LPWSTR pszDst = pszBlockVal + cchValue + 1;
            LPWSTR pszSrc = pszBlockVal + cchBlockVal + 1;
            DWORD cchMove = _BlockLenCached() - (DWORD)(pszSrc - _pszBlock);
            MoveMemory(pszDst, pszSrc, CbFromCchW(cchMove));
            StrCpyW(pszBlockVal, pszValue);
            _cchBlockLen = _cchBlockLen + cchValue - cchBlockVal;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
        else
        {
            //  this means that var doesnt exist yet
            //  however pszBlockVar points to where it
            //  would be alphabetically.  need to make space right here
            LPWSTR pszDst = pszBlockVar + cchNeeded;
            INT cchMove = _BlockLenCached() - (DWORD)(pszBlockVar - _pszBlock);
            MoveMemory(pszDst, pszBlockVar, CbFromCchW(cchMove));
            StrCpyW(pszBlockVar, pszVar);
            pszBlockVar += cchVar;
            *pszBlockVar = L'=';
            StrCpyW(++pszBlockVar, pszValue);
            _cchBlockLen += cchNeeded;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
    }
    return hr;
}

HRESULT CEnvironmentBlock::AppendVar(LPCWSTR pszVar, WCHAR chDelimiter, LPCWSTR pszValue)
{
    //  we could make the delimiter optional
    //  additional size needed in worst case scenario.
    //  var + val + 'chDelim' + '=' + NULL
    DWORD cchValue = lstrlenW(pszValue);
    DWORD cchVar = lstrlenW(pszVar);
    DWORD cchNeeded = cchVar + cchValue + 3;
    HRESULT hr = _InitBlock(cchNeeded);
    if (SUCCEEDED(hr))
    {
        //  we have enough room in our private block
        //  to copy the whole thing
        LPWSTR pszBlockVar;
        if (_FindVar(pszVar, cchVar, &pszBlockVar))
        {
            //  we need to append to this var
            pszBlockVar += lstrlen(pszBlockVar);
            LPWSTR pszDst = pszBlockVar + cchValue + 1;
            int cchMove = _BlockLenCached() - (DWORD)(pszBlockVar - _pszBlock);
            MoveMemory(pszDst, pszBlockVar, CbFromCchW(cchMove));
            *pszBlockVar = chDelimiter;
            StrCpyW(++pszBlockVar, pszValue);
            _cchBlockLen += cchValue + 1;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
        else
            hr = SetVar(pszVar, pszValue);
    }

    return hr;
}

HRESULT CShellExecute::_BuildEnvironmentForNewProcess(LPCTSTR pszNewEnvString)
{
    HRESULT hr = S_FALSE;

    _envblock.SetToken(_hUserToken);
    // Use the _szTemp to build key to the programs specific
    // key in the registry as well as other things...
    PathToAppPathKey(_szImageName, _szTemp, SIZECHARS(_szTemp));

    // Currently only clone environment if we have path.
    DWORD cbTemp = sizeof(_szTemp);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, _szTemp, TEXT("PATH"), NULL, _szTemp, &cbTemp))
    {
        //  setit up to be appended
        hr = _envblock.AppendVar(L"PATH", L';', _szTemp);
    }

    if (SUCCEEDED(hr) && pszNewEnvString)
    {
        StrCpyN(_szTemp, pszNewEnvString, ARRAYSIZE(_szTemp));
        LPTSTR pszValue = StrChrW(_szTemp, L'=');
        if (pszValue)
        {
            *pszValue++ = 0;
            hr = _envblock.SetVar(_szTemp, pszValue);
        }
    }

    if (SUCCEEDED(hr) && SUCCEEDED(TBCGetEnvironmentVariable(L"__COMPAT_LAYER", _szTemp, ARRAYSIZE(_szTemp))))
    {
        hr = _envblock.SetVar(L"__COMPAT_LAYER", _szTemp);
    }

    return hr;
}


// Some apps when run no-active steal the focus anyway so we
// we set it back to the previously active window.

void CShellExecute::_FixActivationStealingApps(HWND hwndOldActive, int nShow)
{
    HWND hwndNew;

    if (nShow == SW_SHOWMINNOACTIVE && (hwndNew = GetForegroundWindow()) != hwndOldActive && IsIconic(hwndNew))
        SetForegroundWindow(hwndOldActive);
}


//
//  The flags that need to passed to CreateProcess()
//
DWORD CShellExecute::_GetCreateFlags(ULONG fMask)
{
    DWORD dwFlags = 0;

    dwFlags |= CREATE_DEFAULT_ERROR_MODE;
    if (fMask & SEE_MASK_FLAG_SEPVDM)
    {
        dwFlags |= CREATE_SEPARATE_WOW_VDM;
    }

    dwFlags |= CREATE_UNICODE_ENVIRONMENT;

    if (!(fMask & SEE_MASK_NO_CONSOLE))
    {
        dwFlags |= CREATE_NEW_CONSOLE;
    }

    return dwFlags;
}

//***   GetUEMAssoc -- approximate answer to 'is path an executable' (etc.)
// ENTRY/EXIT
//  pszFile     thing we asked to run (e.g. foo.xls)
//  pszImage    thing we ultimately ran (e.g. excel.exe)
int GetUEMAssoc(LPCTSTR pszFile, LPCTSTR pszImage, LPCITEMIDLIST pidl)
{
    LPTSTR pszExt, pszExt2;

    // .exe's and associations come thru here
    // folders go thru ???
    // links go thru ResolveLink
    pszExt = PathFindExtension(pszFile);
    if (StrCmpIC(pszExt, c_szDotExe) == 0) {
        // only check .exe (assume .com, .bat, etc. are rare)
        return UIBL_DOTEXE;
    }
    pszExt2 = PathFindExtension(pszImage);
    // StrCmpC (non-I, yes-C) o.k ?  i think so since
    // all we really care about is that they don't match
    if (StrCmpC(pszExt, pszExt2) != 0) {
        TraceMsg(DM_MISC, "gua: UIBL_DOTASSOC file=%s image=%s", pszExt, pszExt2);
        return UIBL_DOTASSOC;
    }

    int iRet = UIBL_DOTOTHER;   // UIBL_DOTEXE?
    if (pidl)
    {
        LPCITEMIDLIST pidlChild;
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
        {
            if (SHGetAttributes(psf, pidlChild, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER)
            {
                iRet = UIBL_DOTFOLDER;
            }
            psf->Release();
        }
    }
    return iRet;
}

typedef struct {
    TCHAR szAppName[MAX_PATH];
    TCHAR szUser[UNLEN + 1];
    TCHAR szDomain[GNLEN + 1];
    TCHAR szPassword[PWLEN + 1];
    CPTYPE cpt;
} LOGONINFO;


// this is what gets called in the normal runas case
void InitUserLogonDlg(LOGONINFO* pli, HWND hDlg, LPCTSTR pszFullUserName)
{
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_USECURRENTACCOUNT), pszFullUserName);

    CheckRadioButton(hDlg, IDC_USECURRENTACCOUNT, IDC_USEOTHERACCOUNT, IDC_USECURRENTACCOUNT);
    CheckDlgButton(hDlg, IDC_SANDBOX, TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), FALSE);
    SetFocus(GetDlgItem(hDlg, IDOK));
}


// this is what gets called in the install app launching as non admin case
void InitSetupLogonDlg(LOGONINFO* pli, HWND hDlg, LPCTSTR pszFullUserName)
{
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_USECURRENTACCOUNT), pszFullUserName);
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_MESSAGEBOXCHECKEX), pszFullUserName);

    CheckRadioButton(hDlg, IDC_USECURRENTACCOUNT, IDC_USEOTHERACCOUNT, IDC_USEOTHERACCOUNT);
    EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), FALSE);
    SetFocus(GetDlgItem(hDlg, IDC_CREDCTL));
}

BOOL_PTR CALLBACK UserLogon_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTemp[UNLEN + 1 + GNLEN + 1];    // enough to hold "reinerf@NTDEV" or "NTDEV\reinerf"
    LOGONINFO *pli= (LOGONINFO*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szName[UNLEN];
            TCHAR szFullName[UNLEN + 1 + GNLEN]; // enough to hold "reinerf@NTDEV" or "NTDEV\reinerf"
            ULONG cchFullName = ARRAYSIZE(szFullName);
            HWND hwndCred = GetDlgItem(hDlg, IDC_CREDCTL);
            WPARAM wparamCredStyles = CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS | CRS_ADMINISTRATORS | CRS_PREFILLADMIN;

            pli = (LOGONINFO*)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pli);

            if (!IsOS(OS_DOMAINMEMBER))
            {
                wparamCredStyles |= CRS_COMPLETEUSERNAME;
            }

            if (!Credential_InitStyle(hwndCred, wparamCredStyles))
            {
                EndDialog(hDlg, IDCANCEL);
            }

            // Limit the user name and password
            Credential_SetUserNameMaxChars(hwndCred, UNLEN + 1 + GNLEN); // enough room for "reinerf@NTDEV" or "NTDEV\reinerf"
            Credential_SetPasswordMaxChars(hwndCred, PWLEN);

            if (!GetUserNameEx(NameSamCompatible, szFullName, &cchFullName))
            {
                ULONG cchName;
                if (GetUserNameEx(NameDisplay, szName, &(cchName = ARRAYSIZE(szName)))  ||
                    GetUserName(szName, &(cchName = ARRAYSIZE(szName)))                 ||
                    (GetEnvironmentVariable(TEXT("USERNAME"), szName, ARRAYSIZE(szName)) > 0))
                {
                    if (GetEnvironmentVariable(TEXT("USERDOMAIN"), szFullName, ARRAYSIZE(szFullName)) > 0)
                    {
                        lstrcatn(szFullName, TEXT("\\"), ARRAYSIZE(szFullName));
                        lstrcatn(szFullName, szName, ARRAYSIZE(szFullName));
                    }
                    else
                    {
                        // use just the username if we cannot get a domain name
                        lstrcpyn(szFullName, szName, ARRAYSIZE(szFullName));
                    }

                }
                else
                {
                    TraceMsg(TF_WARNING, "UserLogon_DlgProc: failed to get the user's name using various methods");
                    szFullName[0] = TEXT('\0');
                }
            }

            // call the proper init function depending on whether this is a setup program launching or the normal runas case
            switch (pli->cpt)
            {
            case CPT_WITHLOGONADMIN:
                {
                    InitSetupLogonDlg(pli, hDlg, szFullName);
                    break;
                }
            case CPT_WITHLOGON:
                {
                    InitUserLogonDlg(pli, hDlg, szFullName);
                    break;
                }
            default:
                {
                    ASSERTMSG(FALSE, "UserLogon_DlgProc: found CPTYPE that is not CPT_WITHLOGON or CPT_WITHLOGONADMIN!");
                }
            }
            break;
        }
        break;

        case WM_COMMAND:
        {
            CPTYPE cptRet = CPT_WITHLOGONCANCELLED;
            int idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            switch (idCmd)
            {
                /* need some way to tell that valid credentials are present so we will only
                   enable the ok button if the user has something that is somewhat valid
                case IDC_USERNAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
                    {
                        EnableOKButtonFromID(hDlg, IDC_USERNAME);
                        GetDlgItemText(hDlg, IDC_USERNAME, szTemp, ARRAYSIZE(szTemp));
                    }
                    break;
                */
                case IDC_USEOTHERACCOUNT:
                case IDC_USECURRENTACCOUNT:
                    if (IsDlgButtonChecked(hDlg, IDC_USECURRENTACCOUNT))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), TRUE);
                        // EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), FALSE);
                        Credential_SetUserNameFocus(GetDlgItem(hDlg, IDC_CREDCTL));
                        // EnableOKButtonFromID(hDlg, IDC_USERNAME);
                    }
                    break;

                case IDOK:
                    if (IsDlgButtonChecked(hDlg, IDC_USEOTHERACCOUNT))
                    {
                        HWND hwndCred = GetDlgItem(hDlg, IDC_CREDCTL);

                        if (Credential_GetUserName(hwndCred, szTemp, ARRAYSIZE(szTemp)) &&
                            Credential_GetPassword(hwndCred, pli->szPassword, ARRAYSIZE(pli->szPassword)))
                        {
                            CredUIParseUserName(szTemp,
                                                pli->szUser,
                                                ARRAYSIZE(pli->szUser),
                                                pli->szDomain,
                                                ARRAYSIZE(pli->szDomain));
                        }
                        cptRet = pli->cpt;
                    }
                    else
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_SANDBOX))
                            cptRet = CPT_SANDBOX;
                        else
                            cptRet = CPT_NORMAL;
                    }
                // fall through

                case IDCANCEL:
                    EndDialog(hDlg, cptRet);
                    return TRUE;
                    break;
            }
            break;
        }

        default:
            return FALSE;
    }

    if (!pli || (pli->cpt == CPT_WITHLOGONADMIN))
    {
        // we want the MessageBoxCheckExDlgProc have a crack at all messages in
        // the CPT_WITHLOGONADMIN case, so return FALSE here
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//  implement this after we figure out what
//  errors that CreateProcessWithLogonW() will return
//  that mean the user should retry the logon.
BOOL _IsLogonError(DWORD err)
{
    static const DWORD s_aLogonErrs[] = {
        ERROR_LOGON_FAILURE,
        ERROR_ACCOUNT_RESTRICTION,
        ERROR_INVALID_LOGON_HOURS,
        ERROR_INVALID_WORKSTATION,
        ERROR_PASSWORD_EXPIRED,
        ERROR_ACCOUNT_DISABLED,
        ERROR_NONE_MAPPED,
        ERROR_NO_SUCH_USER,
        ERROR_INVALID_ACCOUNT_NAME
        };

    for (int i = 0; i < ARRAYSIZE(s_aLogonErrs); i++)
    {
        if (err == s_aLogonErrs[i])
            return TRUE;
    }
    return FALSE;
}


BOOL CheckForAppPathsBoolValue(LPCTSTR pszImageName, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;
    TCHAR szAppPathKeyName[MAX_PATH + ARRAYSIZE(REGSTR_PATH_APPPATHS) + 2]; // +2 = +1 for '\' and +1 for the null terminator
    DWORD cbSize = sizeof(bRet);

    PathToAppPathKey(pszImageName, szAppPathKeyName, ARRAYSIZE(szAppPathKeyName));
    SHGetValue(HKEY_LOCAL_MACHINE, szAppPathKeyName, pszValueName, NULL, &bRet, &cbSize);

    return bRet;
}

__inline BOOL IsRunAsSetupExe(LPCTSTR pszImageName)
{
    return CheckForAppPathsBoolValue(pszImageName, TEXT("RunAsOnNonAdminInstall"));
}

__inline BOOL IsTSSetupExe(LPCTSTR pszImageName)
{
    return CheckForAppPathsBoolValue(pszImageName, TEXT("BlockOnTSNonInstallMode"));
}

typedef BOOL (__stdcall * PFNTERMSRVAPPINSTALLMODE)(void);
// This function is used by hydra (Terminal Server) to see if we
// are in application install mode
//
// exported from kernel32.dll by name but not in kernel32.lib (it is in kernel32p.lib, bogus)

BOOL TermsrvAppInstallMode()
{
    static PFNTERMSRVAPPINSTALLMODE s_pfn = NULL;
    if (NULL == s_pfn)
    {
        s_pfn = (PFNTERMSRVAPPINSTALLMODE)GetProcAddress(LoadLibrary(TEXT("KERNEL32.DLL")), "TermsrvAppInstallMode");
    }

    return s_pfn ? s_pfn() : FALSE;
}

//
// this function checks for the different cases where we need to display a "runas" or warning dialog
// before a program is run.
//
// NOTE: pli->raType is an outparam that tells the caller what type of dialog is needed
//
// return:  TRUE    - we need to bring up a dialog
//          FALSE   - we do not need to prompt the user
//
CPTYPE CheckForInstallApplication(LPCTSTR pszApplicationName, LPCTSTR pszCommandLine, LOGONINFO* pli)
{
    // if we are on a TS "Application Server" machine, AND this is a TS setup exe (eg install.exe or setup.exe)
    // AND we aren't in install mode...
    if (IsOS(OS_TERMINALSERVER) && IsTSSetupExe(pszApplicationName) && !TermsrvAppInstallMode())
    {
        TCHAR szExePath[MAX_PATH];

        lstrcpyn(szExePath, pszCommandLine, ARRAYSIZE(szExePath));
        PathRemoveArgs(szExePath);
        PathUnquoteSpaces(szExePath);

        // ...AND the app we are launching is not TS aware, then we block the install and tell the user to go
        // to Add/Remove Programs.
        if (!IsExeTSAware(szExePath))
        {
            TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: blocking the install on TS because the machine is not in install mode for %s", pszApplicationName);
            return CPT_INSTALLTS;
        }
    }

    // the hyrda case failed, so we check for the user not running as an admin but launching a setup exe (eg winnt32.exe, install.exe, or setup.exe)
    if (!SHRestricted(REST_NORUNASINSTALLPROMPT) && IsRunAsSetupExe(pszApplicationName) && !IsUserAnAdmin())
    {
        BOOL bPromptForInstall = TRUE;

        if (!SHRestricted(REST_PROMPTRUNASINSTALLNETPATH))
        {
            TCHAR szFullPathToApp[MAX_PATH];

            // we want to disable runas on unc and net shares for now since the Administrative account might not
            // have privlidges to the network path
            lstrcpyn(szFullPathToApp, pszCommandLine, ARRAYSIZE(szFullPathToApp));
            PathRemoveArgs(szFullPathToApp);
            PathUnquoteSpaces(szFullPathToApp);

            if (PathIsUNC(szFullPathToApp) || IsNetDrive(PathGetDriveNumber(szFullPathToApp)))
            {
                TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: not prompting for runas install on unc/network path %s", szFullPathToApp);
                bPromptForInstall = FALSE;
            }
        }

        if (bPromptForInstall)
        {
            TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: bringing up the Run As... dialog for %s", pszApplicationName);
            return CPT_WITHLOGONADMIN;
        }
    }

    return CPT_NORMAL;
}


typedef HRESULT (__stdcall * PFN_INSTALLONTERMINALSERVERWITHUI)(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  LPCWSTR lpCommandLine,       // command line string
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,       // handle inheritance flag
  DWORD dwCreationFlags,      // creation flags
  void *lpEnvironment,       // new environment block
  LPCWSTR lpCurrentDirectory, // current directory name
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation);

HRESULT InstallOnTerminalServerWithUIDD(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN void *lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo,
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hDll = LoadLibrary(TEXT("appwiz.cpl"));

    if (hDll)
    {
        PFN_INSTALLONTERMINALSERVERWITHUI pfnInstallOnTerminalServerWithUI = NULL;

        pfnInstallOnTerminalServerWithUI = (PFN_INSTALLONTERMINALSERVERWITHUI) GetProcAddress(hDll, "InstallOnTerminalServerWithUI");
        if (pfnInstallOnTerminalServerWithUI)
        {
            hr = pfnInstallOnTerminalServerWithUI(hwnd, lpApplicationName, lpCommandLine, lpProcessAttributes,
                        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
                        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        }

        FreeLibrary(hDll);
    }

    return hr;
}

CPTYPE _LogonUser(HWND hwnd, CPTYPE cpt, LOGONINFO *pli)
{
    if (CredUIInitControls())
    {
        pli->cpt = cpt;
        switch (cpt)
        {
        case CPT_WITHLOGON:
            // this is the normal "Run as..." verb dialog
            cpt = (CPTYPE) DialogBoxParam(HINST_THISDLL,
                                    MAKEINTRESOURCE(DLG_RUNUSERLOGON),
                                    hwnd,
                                    UserLogon_DlgProc,
                                    (LPARAM)pli);
            break;

        case CPT_WITHLOGONADMIN:
            // in the non-administrator setup app case. we want the "don't show me
            // this again" functionality, so we use the SHMessageBoxCheckEx function
            cpt = (CPTYPE) SHMessageBoxCheckEx(hwnd,
                                         HINST_THISDLL,
                                         MAKEINTRESOURCE(DLG_RUNSETUPLOGON),
                                         UserLogon_DlgProc,
                                         (void*)pli,
                                         CPT_NORMAL, // if they checked the "dont show me this again", we want to just launch it as the current user
                                         TEXT("WarnOnNonAdminInstall"));
            break;

        default:
            {
                ASSERTMSG(FALSE, "_SHCreateProcess: pli->raType not recognized!");
            }
            break;
        }
        return cpt;
    }
    return CPT_FAILED;
}

//
//  SHCreateProcess()
//  WARNING: lpApplicationName is not actually passed to CreateProcess() it is
//            for internal use only.
//
BOOL _SHCreateProcess(HWND hwnd,
                      HANDLE hToken,
                      LPCTSTR lpApplicationName,
                      LPTSTR lpCommandLine,
                      DWORD dwCreationFlags,
                      LPSECURITY_ATTRIBUTES  lpProcessAttributes,
                      LPSECURITY_ATTRIBUTES  lpThreadAttributes,
                      BOOL  bInheritHandles,
                      void *lpEnvironment,
                      LPCTSTR lpCurrentDirectory,
                      LPSTARTUPINFO lpStartupInfo,
                      LPPROCESS_INFORMATION lpProcessInformation,
                      CPTYPE cpt,
                      BOOL fUEM)
{
    LOGONINFO li = {0};

    //  maybe we should do this for all calls
    //  except CPT_ASUSER??
    if (cpt == CPT_NORMAL)
    {
        // see if we need to put up a warning prompt either because the user is not an
        // admin or this is hydra and we are not in install mode.
        cpt = CheckForInstallApplication(lpApplicationName, lpCommandLine, &li);
    }

    if ((cpt == CPT_WITHLOGON || cpt == CPT_WITHLOGONADMIN) && lpApplicationName)
    {
        AssocQueryString(ASSOCF_VERIFY | ASSOCF_INIT_BYEXENAME, ASSOCSTR_FRIENDLYAPPNAME,
            lpApplicationName, NULL, li.szAppName, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(li.szAppName)));

RetryUserLogon:
        cpt = _LogonUser(hwnd, cpt, &li);

    }

    BOOL fRet = FALSE;
    DWORD err = NOERROR;

    switch(cpt)
    {
    case CPT_NORMAL:
        {
            // DEFAULT use CreateProcess
            fRet = CreateProcess(NULL, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
                                 dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                                 lpProcessInformation);
        }
        break;


    case CPT_SANDBOX:
        {
            ASSERT(!hToken);
            hToken = _GetSandboxToken();
            if (hToken)
            {
                //  using our special token
                fRet = CreateProcessAsUser(hToken, NULL, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
                                     dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                                     lpProcessInformation);
                CloseHandle(hToken);
            }

            // no token means failure.
        }
        break;


    case CPT_ASUSER:
        {
            if (hToken)
            {
                // using our special token
                fRet = CreateProcessAsUser(hToken, NULL, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
                                           dwCreationFlags | CREATE_PRESERVE_CODE_AUTHZ_LEVEL,
                                           lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            else
            {
                // no token means normal create process, but with the "preserve authz level" flag.
                fRet = CreateProcess(NULL, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
                                     dwCreationFlags | CREATE_PRESERVE_CODE_AUTHZ_LEVEL,
                                     lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
        }
        break;


    case CPT_INSTALLTS:
        {
            HRESULT hr = InstallOnTerminalServerWithUIDD(hwnd,
                                                         NULL,
                                                         lpCommandLine,
                                                         lpProcessAttributes,
                                                         lpThreadAttributes,
                                                         bInheritHandles,
                                                         dwCreationFlags,
                                                         lpEnvironment,
                                                         lpCurrentDirectory,
                                                         lpStartupInfo,
                                                         lpProcessInformation);
            fRet = SUCCEEDED(hr);
            err = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : ERROR_ACCESS_DENIED;
        }
        break;

    case CPT_WITHLOGON:
    case CPT_WITHLOGONADMIN:
        {
            LPTSTR pszDesktop = lpStartupInfo->lpDesktop;
            // 99/08/19 #389284 vtan: clip username and domain to 125
            // characters each to avoid hitting the combined MAX_PATH
            // limit in AllowDesktopAccessToUser in advapi32.dll which
            // is invoked by CreateProcessWithLogonW.
            // This can be removed when the API is fixed. Check:
            // %_ntbindir%\mergedcomponents\advapi\cseclogn.cxx
            li.szUser[125] = li.szDomain[125] = 0;

            //  we are attempting logon the user. NOTE: pass LOGON_WITH_PROFILE so that we ensure that the profile is loaded
            fRet = CreateProcessWithLogonW(li.szUser, li.szDomain, li.szPassword, LOGON_WITH_PROFILE, NULL, lpCommandLine,
                                  dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                                  lpProcessInformation);

            if (!fRet)
            {
                // HACKHACK: When CreateProcessWithLogon fails, it munges the desktop. This causes
                // the next call to "Appear" to fail because the app show up on another desktop...
                //     Why? I don't know...
                // I'm going to assign the bug back to them and have them fix it on their end, this is just to
                // work around their bug.

                if (lpStartupInfo)
                    lpStartupInfo->lpDesktop = pszDesktop;

                //  ShellMessageBox can alter LastError
                err = GetLastError();
                if (_IsLogonError(err))
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(HINST_THISDLL, IDS_CANTLOGON, szTemp, SIZECHARS(szTemp));

                    SHSysErrorMessageBox(
                        hwnd,
                        li.szAppName,
                        IDS_SHLEXEC_ERROR,
                        err,
                        szTemp,
                        MB_OK | MB_ICONSTOP);

                    err = NOERROR;
                    goto RetryUserLogon;
                }
            }
        }
        break;

    case CPT_WITHLOGONCANCELLED:
        err = ERROR_CANCELLED;
        break;
    }

    // fire *after* the actual process since:
    //  - if there's a bug we at least get the process started (hopefully)
    //  - don't want to log failed events (for now at least)
    if (fRet)
    {
        if (fUEM && UEMIsLoaded())
        {
            // skip the call if stuff isn't there yet.
            // the load is expensive (forces ole32.dll and browseui.dll in
            // and then pins browseui).
            UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)lpApplicationName);
            // we do the UIBW_RUNASSOC elsewhere.  this can cause slight
            // inaccuracies since there's no guarantees the 2 places are
            // 'paired'.  however it's way easier to do UIBW_RUNASSOC
            // elsewhere so we'll live w/ it.
        }
    }
    else if (err)
    {
        SetLastError(err);
    }
    else
    {
        //  somebody is responsible for setting this...
        ASSERT(GetLastError());
    }

    return fRet;
}

__inline BOOL IsConsoleApp(PCWSTR pszApp)
{
    return GetExeType(pszApp) == PEMAGIC;
}

BOOL IsCurrentProcessConsole()
{
    static TRIBIT s_tbConsole = TRIBIT_UNDEFINED;
    if (s_tbConsole == TRIBIT_UNDEFINED)
    {
        WCHAR sz[MAX_PATH];
        if (GetModuleFileNameW(NULL, sz, ARRAYSIZE(sz))
            && IsConsoleApp(sz))
        {
            s_tbConsole = TRIBIT_TRUE;
        }
        else
        {
            s_tbConsole = TRIBIT_FALSE;
        }
    }
    return s_tbConsole == TRIBIT_TRUE;
}

BOOL CShellExecute::_SetCommand(void)
{
    if (_szCmdTemplate[0])
    {
        // parse arguments into command line
        DWORD se_err = ReplaceParameters(_szCommand, ARRAYSIZE(_szCommand),
            _szFile, _szCmdTemplate, _lpParameters,
            _nShow, NULL, FALSE, _lpID, &_pidlGlobal);

        if (se_err)
            _ReportHinst(IntToHinst(se_err));
        else
        {
            return TRUE;
        }
    }
    else if (PathIsExe(_szFile))
    {
        _fTryOpenExe = TRUE;
    }
    else
        _ReportWin32(ERROR_NO_ASSOCIATION);

    return FALSE;
}

void CShellExecute::_TryExecCommand(void)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::TryExecCommand() entered CmdTemplate = %s", _szCmdTemplate);

    if (!_SetCommand())
        return;

    _DoExecCommand();
}

void CShellExecute::_SetImageName(void)
{
    if (SUCCEEDED(_QueryString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, _szImageName, SIZECHARS(_szImageName))))
    {
        if (0 == lstrcmp(_szImageName, TEXT("%1")))
            StrCpyN(_szImageName, _szFile, SIZECHARS(_szImageName));
    }
    else if (PathIsExe(_szFile))
    {
        StrCpyN(_szImageName, _szFile, SIZECHARS(_szImageName));
    }
    if (!_fInheritHandles && SHRestricted(REST_INHERITCONSOLEHANDLES))
    {
        _fInheritHandles = IsCurrentProcessConsole() && IsConsoleApp(_szImageName);
    }
}

//
//  TryExecCommand() is the most common and default way to get an app started.
//  mostly it uses CreateProcess() with a command line composed from
//  the pei and the registry.  it can also do a ddeexec afterwards.
//

void CShellExecute::_DoExecCommand(void)
{
    BOOL fCreateProcessFailed;
    TraceMsg(TF_SHELLEXEC, "SHEX::DoExecCommand() entered szCommand = %s", _szCommand);

    do
    {
        HWND hwndOld = GetForegroundWindow();
        LPTSTR pszEnv = NULL;
        LPCTSTR pszNewEnvString = NULL;
        fCreateProcessFailed = FALSE;

        _SetImageName();

        // Check exec restrictions.
        if (SHRestricted(REST_RESTRICTRUN) && RestrictedApp(_szImageName))
        {
            _ReportWin32(ERROR_RESTRICTED_APP);
            break;
        }
        if (SHRestricted(REST_DISALLOWRUN) && DisallowedApp(_szImageName))
        {
            _ReportWin32(ERROR_RESTRICTED_APP);
            break;
        }


        // Check if app is incompatible in some fashion...
        if (!CheckAppCompatibility(_szImageName, &pszNewEnvString, _fNoUI, _hwndParent))
        {
            _ReportWin32(ERROR_CANCELLED);
            break;
        }

        //  try to validate the image if it is on a UNC share
        //  we dont need to check for Print shares, so we
        //  will fail if it is on one.
        if (STOPTRYING(_TryValidateUNC(_szImageName, NULL, NULL)))
        {
            // returns TRUE if it failed or handled the operation
            // Note that SHValidateUNC calls SetLastError
            // this continue will test based on GetLastError()
            continue;
        }

        //
        // WOWShellExecute sets a global variable
        //     The cb is only valid when we are being called from wow
        //     If valid use it
        //
        if (STOPTRYING(_TryWowShellExec()))
            break;

        // See if we need to pass a new environment to the new process
        _BuildEnvironmentForNewProcess(pszNewEnvString);

        TraceMsg(TF_SHELLEXEC, "SHEX::DoExecCommand() CreateProcess(NULL,%s,...)", _szCommand);

        //  CreateProcess will SetLastError() if it fails
        if (_SHCreateProcess(_hwndParent,
                             _hUserToken,
                             _szImageName,
                             _szCommand,
                             _dwCreateFlags,
                             _pProcAttrs,
                             _pThreadAttrs,
                             _fInheritHandles,
                             _envblock.GetCustomBlock(),
                             _fUseNullCWD ? NULL : _szWorkingDir,
                             &_startup,
                             &_pi,
                             _cpt,
                             _fUEM))
        {
            // If we're doing DDE we'd better wait for the app to be up and running
            // before we try to talk to them.
            if (_fDDEInfoSet || _fWaitForInputIdle)
            {
                // Yep, How long to wait? For now, try 60 seconds to handle
                // pig-slow OLE apps.
                WaitForInputIdle(_pi.hProcess, 60*1000);
            }

            // Find the "hinstance" of whatever we just created.
            // PEIOUT - hinst reported for pei->hInstApp
            HINSTANCE hinst = 0;

            // Now fix the focus and do any dde stuff that we need to do
            _FixActivationStealingApps(hwndOld, _nShow);

            if (_fDDEInfoSet)
            {
                //  this will _Report() any errors for us if necessary
                _DDEExecute(NULL, _hwndParent, _nShow, _fDDEWait);
            }
            else
                _ReportHinst(hinst);

            //
            // Tell the taskbar about this application so it can re-tickle
            // the associated shortcut if the app runs for a long time.
            // This keeps long-running apps from aging off your Start Menu.
            //
            if (_fUEM && (_startup.dwFlags & STARTF_TITLEISLINKNAME))
            {
                _NotifyShortcutInvoke();
            }

            break;  // out of retry loop
        }
        else
        {
            fCreateProcessFailed = TRUE;

        }

        //  clean up the loop
        if (pszEnv)
            LocalFree(pszEnv);


    // **WARNING** this assumes that SetLastError() has been called - zekel - 20-NOV-97
    //  right now we only reach here after CreateProcess() fails or
    //  SHValidateUNC() fails.  both of these do SetLastError()
    }
    while (KEEPTRYING(_ProcessErrorShouldTryExecCommand(GetLastError(), _hwndParent, fCreateProcessFailed)));

    // (we used to do a UIBW_RUNASSOC here, but moved it higher up)
}

void CShellExecute::_NotifyShortcutInvoke()
{
    SHShortcutInvokeAsIDList sidl;
    sidl.cb = FIELD_OFFSET(SHShortcutInvokeAsIDList, cbZero);
    sidl.dwItem1 = SHCNEE_SHORTCUTINVOKE;
    sidl.dwPid = _pi.dwProcessId;

    if (_startup.lpTitle)
    {
        lstrcpynW(sidl.szShortcutName, _startup.lpTitle, ARRAYSIZE(sidl.szShortcutName));
    }
    else
    {
        sidl.szShortcutName[0] = TEXT('\0');
    }
    lstrcpynW(sidl.szTargetName, _szImageName, ARRAYSIZE(sidl.szTargetName));
    sidl.cbZero = 0;
    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_IDLIST, (LPCITEMIDLIST)&sidl, NULL);
}

HGLOBAL CShellExecute::_CreateDDECommand(int nShow, BOOL fLFNAware, BOOL fNative)
{
    // Now that we can handle ShellExec for URLs, we need to have a much bigger
    // command buffer. Explorer's DDE exec command even has two file names in
    // it. (WHY?) So the command buffer have to be a least twice the size of
    // INTERNET_MAX_URL_LENGTH plus room for the command format.
    SHSTR strTemp;
    HGLOBAL hRet = NULL;

    if (SUCCEEDED(strTemp.SetSize((2 * INTERNET_MAX_URL_LENGTH) + 64)))
    {
        if (0 == ReplaceParameters(strTemp.GetInplaceStr(), strTemp.GetSize(), _szFile,
            _szDDECmd, _lpParameters, nShow, ((DWORD*) &_startup.hStdInput), fLFNAware, _lpID, &_pidlGlobal))
        {

            TraceMsg(TF_SHELLEXEC, "SHEX::_CreateDDECommand(%d, %d) : %s", fLFNAware, fNative, strTemp.GetStr());

            //  we only have to thunk on NT
            if (!fNative)
            {
                SHSTRA stra;
                if (SUCCEEDED(stra.SetStr(strTemp)))
                {
                    // Get dde memory for the command and copy the command line.

                    hRet = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, CbFromCch(lstrlenA(stra.GetStr()) + 1));

                    if (hRet)
                    {
                        LPSTR psz = (LPSTR) GlobalLock(hRet);
                        lstrcpyA(psz, stra.GetStr());
                        GlobalUnlock(hRet);
                    }
                }
            }
            else
            {
                // Get dde memory for the command and copy the command line.

                hRet = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, CbFromCch(lstrlen(strTemp.GetStr()) + 1));

                if (hRet)
                {
                    LPTSTR psz = (LPTSTR) GlobalLock(hRet);
                    lstrcpy(psz, strTemp.GetStr());
                    GlobalUnlock(hRet);
                }
            }
        }
    }

    return hRet;
}

// Short cut all DDE commands with a WM_NOTIFY
//  returns true if this was handled...or unrecoverable error.
BOOL CShellExecute::_TryDDEShortCircuit(HWND hwnd, HGLOBAL hMem, int nShow)
{
    if (hwnd  && IsWindowInProcess(hwnd))
    {
        HINSTANCE hret = (HINSTANCE)SE_ERR_FNF;

        // get the top most owner.
        hwnd = GetTopParentWindow(hwnd);

        if (IsWindowInProcess(hwnd))
        {
            LPNMVIEWFOLDER lpnm = (LPNMVIEWFOLDER)LocalAlloc(LPTR, sizeof(NMVIEWFOLDER));

            if (lpnm)
            {
                lpnm->hdr.hwndFrom = NULL;
                lpnm->hdr.idFrom = 0;
                lpnm->hdr.code = SEN_DDEEXECUTE;
                lpnm->dwHotKey = HandleToUlong(_startup.hStdInput);
                if ((_startup.dwFlags & STARTF_HASHMONITOR) != 0)
                    lpnm->hMonitor = reinterpret_cast<HMONITOR>(_startup.hStdOutput);
                else
                    lpnm->hMonitor = NULL;

                StrCpyN(lpnm->szCmd, (LPTSTR) GlobalLock(hMem), ARRAYSIZE(lpnm->szCmd));
                GlobalUnlock(hMem);

                if (SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)lpnm))
                    hret =  Window_GetInstance(hwnd);

                LocalFree(lpnm);
            }
            else
                hret = (HINSTANCE)SE_ERR_OOM;
        }

        TraceMsg(TF_SHELLEXEC, "SHEX::_TryDDEShortcut hinst = %d", hret);

        if ((UINT_PTR)hret != SE_ERR_FNF)
        {
            _ReportHinst(hret);
            return TRUE;
        }
    }

    return FALSE;
}


// _WaiteForDDEMsg()
// this does a message loop until DDE msg or a timeout occurs
//
STDAPI_(void) _WaitForDDEMsg(HWND hwnd, DWORD dwTimeout, UINT wMsg)
{
    //  termination event
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    SetProp(hwnd, SZTERMEVENT, hEvent);

    for (;;)
    {
        MSG msg;
        DWORD dwEndTime = GetTickCount() + dwTimeout;
        LONG lWait = (LONG)dwTimeout;

        DWORD dwReturn = MsgWaitForMultipleObjects(1, &hEvent,
                FALSE, lWait, QS_POSTMESSAGE);

        //  if we time out or get an error or get our EVENT!!!
        //  we just bag out
        if (dwReturn != (WAIT_OBJECT_0 + 1))
        {
            break;
        }

        // we woke up because of messages.
        while (PeekMessage(&msg, NULL, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE))
        {
            ASSERT(msg.message != WM_QUIT);
            DispatchMessage(&msg);

            if (msg.hwnd == hwnd && msg.message == wMsg)
                goto Quit;
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }

Quit:
    if (hEvent)
        CloseHandle(hEvent);
    RemoveProp(hwnd, SZTERMEVENT);

    return;
}

LRESULT CALLBACK DDESubClassWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndConv = (HWND) GetProp(hWnd, SZCONV);
    WPARAM nLow;
    WPARAM nHigh;
    HANDLE hEvent;

    switch (wMsg)
    {
      case WM_DDE_ACK:
        if (!hwndConv)
        {
            // this is the first ACK for our INITIATE message
            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd get ACK on INITIATE");
            return SetProp(hWnd, SZCONV, (HANDLE)wParam);
        }
        else if (((UINT_PTR)hwndConv == 1) || ((HWND)wParam == hwndConv))

        {
            // this is the ACK for our EXECUTE message
            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd got ACK on EXECUTE");

            if (UnpackDDElParam(wMsg, lParam, &nLow, &nHigh))
            {
                GlobalFree((HGLOBAL)nHigh);
                FreeDDElParam(wMsg, lParam);
            }

            // prevent us from destroying again....
            if ((UINT_PTR) hwndConv != 1)
                DestroyWindow(hWnd);
        }

        // This is the ACK for our INITIATE message for all servers
        // besides the first.  We return FALSE, so the conversation
        // should terminate.
        break;

      case WM_DDE_TERMINATE:
        if (hwndConv == (HANDLE)wParam)
        {
            // this TERMINATE was originated by another application
            // (otherwise, hwndConv would be 1)
            // they should have freed the memory for the exec message

            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd got TERMINATE from hwndConv");

            PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hWnd, 0L);

            RemoveProp(hWnd, SZCONV);
            DestroyWindow(hWnd);
        }
        // Signal the termination event to ensure nested dde calls will terminate the
        // appropriate _WaitForDDEMsg loop properly...
        if (hEvent = GetProp(hWnd, SZTERMEVENT))
            SetEvent(hEvent);

        // This is the TERMINATE response for our TERMINATE message
        // or a random terminate (which we don't really care about)
        break;

      case WM_TIMER:
        if (wParam == DDE_DEATH_TIMER_ID)
        {
            // The conversation will be terminated in the destroy code
            DestroyWindow(hWnd);

            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd TIMER closing DDE Window due to lack of ACK");
            break;
        }
        else
          return DefWindowProc(hWnd, wMsg, wParam, lParam);

      case WM_DESTROY:
        TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd WM_DESTROY'd");

        // kill the timer just incase.... (this may fail if we never set the timer)
        KillTimer(hWnd, DDE_DEATH_TIMER_ID);
        if (hwndConv)
        {
            // Make sure the window is not destroyed twice
            SetProp(hWnd, SZCONV, (HANDLE)1);

            /* Post the TERMINATE message and then
             * Wait for the acknowledging TERMINATE message or a timeout
             */
            PostMessage(hwndConv, WM_DDE_TERMINATE, (WPARAM)hWnd, 0L);

            _WaitForDDEMsg(hWnd, DDE_TERMINATETIMEOUT, WM_DDE_TERMINATE);

            RemoveProp(hWnd, SZCONV);
        }

        // the DDE conversation is officially over, let ShellExec know if it was waiting
        hEvent = RemoveProp(hWnd, SZDDEEVENT);
        if (hEvent)
        {
            SetEvent(hEvent);
        }

        /* Fall through */
      default:
        return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}

HWND CShellExecute::_CreateHiddenDDEWindow(HWND hwndParent)
{
    // lets be lazy and not create a class for it
    HWND hwnd = SHCreateWorkerWindow(DDESubClassWndProc, GetTopParentWindow(hwndParent),
        0, 0, NULL, NULL);

    TraceMsg(TF_SHELLEXEC, "SHEX::_CreateHiddenDDEWindow returning hwnd = 0x%X", hwnd);
    return hwnd;
}

void CShellExecute::_DestroyHiddenDDEWindow(HWND hwnd)
{
    if (IsWindow(hwnd))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_DestroyHiddenDDEWindow on hwnd = 0x%X", hwnd);
        DestroyWindow(hwnd);
    }
}

BOOL CShellExecute::_PostDDEExecute(HWND hwndOurs, HWND hwndTheirs, HGLOBAL hDDECommand, HANDLE hWait)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute(0x%X, 0x%X) entered", hwndTheirs, hwndOurs);
    DWORD dwProcessID = 0;
    GetWindowThreadProcessId(hwndTheirs, &dwProcessID);
    if (dwProcessID)
    {
        AllowSetForegroundWindow(dwProcessID);
    }

    if (PostMessage(hwndTheirs, WM_DDE_EXECUTE, (WPARAM)hwndOurs, (LPARAM)PackDDElParam(WM_DDE_EXECUTE, 0,(UINT_PTR)hDDECommand)))
    {
        _ReportHinst(Window_GetInstance(hwndTheirs));
        TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() connected");

        // everything's going fine so far, so return to the application
        // with the instance handle of the guy, and hope he can execute our string
        if (hWait)
        {
            // We can't return from this call until the DDE conversation terminates.
            // Otherwise the thread may go away, nuking our hwndConv window,
            // messing up the DDE conversation, and Word drops funky error messages on us.
            TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() waiting for termination");
            SetProp(hwndOurs, SZDDEEVENT, hWait);
            SHProcessMessagesUntilEvent(NULL, hWait, INFINITE);
            //  it is removed during WM_DESTROY (before signaling)
        }
        else if (IsWindow(hwndOurs))
        {
            // set a timer to tidy up the window incase we never get a ACK....
            TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() setting DEATH timer");

            SetTimer(hwndOurs, DDE_DEATH_TIMER_ID, DDE_DEATH_TIMEOUT, NULL);
        }

        return TRUE;
    }

    return FALSE;
}

#define DDE_TIMEOUT             30000       // 30 seconds.
#define DDE_TIMEOUT_LOW_MEM     80000       // 80 seconds - Excel takes 77.87 on 486.33 with 8mb

typedef struct {
    WORD  aName;
    HWND  hwndDDE;
    LONG  lAppTopic;
    UINT  timeout;
} INITDDECONV;



HWND CShellExecute::_GetConversationWindow(HWND hwndDDE)
{
    ULONG_PTR dwResult;  //unused
    HWND hwnd = NULL;
    INITDDECONV idc = { NULL,
                        hwndDDE,
                        MAKELONG(_aApplication, _aTopic),
                        SHIsLowMemoryMachine(ILMM_IE4) ? DDE_TIMEOUT_LOW_MEM : DDE_TIMEOUT
                        };

    //  if we didnt find him, then we better default to the old way...
    if (!hwnd)
    {

        //  we found somebody who used to like us...
        // Send the initiate message.
        // NB This doesn't need packing.
        SendMessageTimeout((HWND) -1, WM_DDE_INITIATE, (WPARAM)hwndDDE,
                idc.lAppTopic, SMTO_ABORTIFHUNG,
                idc.timeout,
                &dwResult);

        hwnd = (HWND) GetProp(hwndDDE, SZCONV);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::GetConvWnd returns [%X]", hwnd);
    return hwnd;
}

BOOL CShellExecute::_DDEExecute(
    BOOL fWillRetry,
    HWND hwndParent,
    int   nShowCmd,
    BOOL fWaitForDDE
)
{
    LONG err = ERROR_OUTOFMEMORY;
    BOOL fReportErr = TRUE;

    // Get the actual command string.
    // NB We'll assume the guy we're going to talk to is LFN aware. If we're wrong
    // we'll rebuild the command string a bit later on.
    HGLOBAL hDDECommand = _CreateDDECommand(nShowCmd, TRUE, TRUE);
    if (hDDECommand)
    {
        //  we have a DDE command to try
        if (_TryDDEShortCircuit(hwndParent, hDDECommand, nShowCmd))
        {
            //  the shortcut tried and now we have an error reported
            fReportErr = FALSE;
        }
        else
        {
            HANDLE hWait = fWaitForDDE ? CreateEvent(NULL, FALSE, FALSE, NULL) : NULL;
            if (hWait || !fWaitForDDE)
            {
                // Create a hidden window for the conversation
                HWND hwndDDE = _CreateHiddenDDEWindow(hwndParent);
                if (hwndDDE)
                {
                    HWND hwndConv = _GetConversationWindow(hwndDDE);
                    if (hwndConv)
                    {
                        //  somebody answered us.
                        // This doesn't work if the other guy is using ddeml.
                        if (_fActivateHandler)
                            ActivateHandler(hwndConv, (DWORD_PTR) _startup.hStdInput);

                        // Can the guy we're talking to handle LFNs?
                        BOOL fLFNAware = Window_IsLFNAware(hwndConv);
                        BOOL fNative = IsWindowUnicode(hwndConv);
                        if (!fLFNAware || !fNative)
                        {
                            //  we need to redo the command string.
                            // Nope - App isn't LFN aware - redo the command string.
                            GlobalFree(hDDECommand);

                            //  we may need a new _pidlGlobal too.
                            if (_pidlGlobal)
                            {
                                SHFreeShared((HANDLE)_pidlGlobal,GetCurrentProcessId());
                                _pidlGlobal = NULL;

                            }

                            hDDECommand = _CreateDDECommand(nShowCmd, fLFNAware, fNative);
                        }


                        // Send the execute message to the application.
                        err = ERROR_DDE_FAIL;

                        if (_PostDDEExecute(hwndDDE, hwndConv, hDDECommand, hWait))
                        {
                            fReportErr = FALSE;
                            hDDECommand = NULL;

                            //  hwnd owns itself now
                            if (!hWait)
                                hwndDDE = NULL;
                        }
                    }
                    else
                    {
                        err = (ERROR_FILE_NOT_FOUND);
                    }

                    //  cleanup
                    _DestroyHiddenDDEWindow(hwndDDE);

                }

                if (hWait)
                    CloseHandle(hWait);
            }

        }

        //  cleanup
        if (hDDECommand)
            GlobalFree(hDDECommand);
    }


    if (fReportErr)
    {
        if (fWillRetry && ERROR_FILE_NOT_FOUND == err)
        {
            //  this means that we need to update the
            //  command so that we can try DDE again after
            //  starting the app up...
            // if it wasn't found, determine the correct command

            _QueryString(0, ASSOCSTR_DDEIFEXEC, _szDDECmd, SIZECHARS(_szDDECmd));

            return FALSE;
        }
        else
        {

            _ReportWin32(err);
        }
    }

    return TRUE;
}

BOOL CShellExecute::_SetDDEInfo(void)
{
    ASSERT(_pqa);

    if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDECOMMAND, _szDDECmd, SIZECHARS(_szDDECmd))))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo command: %s", _szDDECmd);

        // Any activation info?
        _fActivateHandler = FAILED(_pqa->GetData(0, ASSOCDATA_NOACTIVATEHANDLER, _pszQueryVerb, NULL, NULL));

        if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDEAPPLICATION, _szTemp, SIZECHARS(_szTemp))))
        {
            TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo application: %s", _szTemp);

            if (_aApplication)
                GlobalDeleteAtom(_aApplication);

            _aApplication = GlobalAddAtom(_szTemp);

            if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDETOPIC, _szTemp, SIZECHARS(_szTemp))))
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo topic: %s", _szTemp);

                if (_aTopic)
                    GlobalDeleteAtom(_aTopic);
                _aTopic = GlobalAddAtom(_szTemp);

                _fDDEInfoSet = TRUE;
            }
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo returns %d", _fDDEInfoSet);

    return _fDDEInfoSet;
}

TRYRESULT CShellExecute::_TryExecDDE(void)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    TraceMsg(TF_SHELLEXEC, "SHEX::TryExecDDE entered ");

    if (_SetDDEInfo())
    {
        //  try the real deal here.  we pass TRUE for fWillRetry because
        //  if this fails to find the app, we will attempt to start
        //  the app and then use DDE again.
        if (_DDEExecute(TRUE, _hwndParent, _nShow, _fDDEWait))
            tr = TRY_STOP;
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::TryDDEExec() returning %d", tr);

    return tr;
}

TRYRESULT CShellExecute::_SetDarwinCmdTemplate(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (SUCCEEDED(_pqa->GetData(0, ASSOCDATA_MSIDESCRIPTOR, _pszQueryVerb, (void *)_wszTemp, (LPDWORD)MAKEINTRESOURCE(sizeof(_wszTemp)))))
    {
        if (fSync)
        {
            // call darwin to give us the real location of the app.
            //
            // Note: this call could possibly fault the application in thus
            // installing it on the users machine.
            HRESULT hr = ParseDarwinID(_wszTemp, _szCmdTemplate, ARRAYSIZE(_szCmdTemplate));
            if (SUCCEEDED(hr))
            {
                tr = TRY_CONTINUE;
            }
            else
            {
                _ReportWin32(hr);
                tr = TRY_STOP;
            }
        }
        else
            tr = TRY_RETRYASYNC;
    }

    return tr;
}

HRESULT CShellExecute::_QueryString(ASSOCF flags, ASSOCSTR str, LPTSTR psz, DWORD cch)
{
    if (_pqa)
    {
        HRESULT hr = _pqa->GetString(flags, str, _pszQueryVerb, _wszTemp, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(_wszTemp)));

        if (SUCCEEDED(hr))
            SHUnicodeToTChar(_wszTemp, psz, cch);

        return hr;
    }
    return E_FAIL;
}

BOOL CShellExecute::_SetAppRunAsCmdTemplate(void)
{
    DWORD cb = sizeof(_szCmdTemplate);
    //  we want to use a special command
    PathToAppPathKey(_szFile, _szTemp, SIZECHARS(_szTemp));

    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, _szTemp, TEXT("RunAsCommand"), NULL, _szCmdTemplate, &cb) && *_szCmdTemplate);
}

#if DBG && defined(_X86_)
#pragma optimize("", off) // work around compiler bug
#endif


TRYRESULT CShellExecute::_MaybeInstallApp(BOOL fSync)
{
    // we check darwin first since it should override everything else
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (IsDarwinEnabled())
    {
        // if darwin is enabled, then check for the darwin ID in
        // the registry and set the value based on that.
        tr = _SetDarwinCmdTemplate(fSync);
    }
    if (TRY_CONTINUE_UNHANDLED == tr)
    {
        // no darwin information in the registry
        // so now we have to check to see if the NT5 class store will populate our registry
        // with some helpful information (darwin or otherwise)
        tr = _ShouldRetryWithNewClassKey(fSync);
    }
    return tr;
}


TRYRESULT CShellExecute::_SetCmdTemplate(BOOL fSync)
{
    TRYRESULT tr = _MaybeInstallApp(fSync);
    if (tr == TRY_CONTINUE_UNHANDLED)
    {
        //
        //  both darwin and the class store were unsuccessful, so fall back to
        //  the good ole' default command value.
        //
        //  but if we the caller requested NOUI and we
        //  decided to use Unknown as the class
        //  then we should fail here so that
        //  we dont popup the OpenWith dialog box.
        //
        HRESULT hr = E_FAIL;
        if (!_fClassStoreOnly)
        {
            if ((_cpt != CPT_NORMAL)
            || !PathIsExe(_szFile)
            || !_SetAppRunAsCmdTemplate())
            {
                hr = _QueryString(0, ASSOCSTR_COMMAND, _szCmdTemplate, SIZECHARS(_szCmdTemplate));
            }
        }

        if (SUCCEEDED(hr))
        {
            tr = TRY_CONTINUE;
        }
        else
        {
            _ReportWin32(ERROR_NO_ASSOCIATION);
            tr = TRY_STOP;
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::SetCmdTemplate() value = %s", _szCmdTemplate);
    return tr;
}

#if DBG && defined(_X86_)
#pragma optimize("", on) // return to previous optimization level
#endif

TRYRESULT CShellExecute::_TryWowShellExec(void)
{
    // WOWShellExecute sets this global variable
    //     The cb is only valid when we are being called from wow
    //     If valid use it

    if (g_pfnWowShellExecCB)
    {
        SHSTRA strCmd;
        SHSTRA strDir;

        HINSTANCE hinst = (HINSTANCE)SE_ERR_OOM;
        if (SUCCEEDED(strCmd.SetStr(_szCommand)) && SUCCEEDED(strDir.SetStr(_szWorkingDir)))
        {
            hinst = IntToHinst((*(LPFNWOWSHELLEXECCB)g_pfnWowShellExecCB)(strCmd.GetInplaceStr(), _startup.wShowWindow, strDir.GetInplaceStr()));
        }

        if (!_ReportHinst(hinst))
        {
            //  SUCCESS!

            //
            // If we were doing DDE, then retry now that the app has been
            // exec'd.  Note we don't keep HINSTANCE returned from _DDEExecute
            // because it will be constant 33 instead of the valid WOW HINSTANCE
            // returned from *g_pfnWowShellExecCB above.
            //
            if (_fDDEInfoSet)
            {
                _DDEExecute(NULL, _hwndParent, _nShow, _fDDEWait);
            }
        }

        TraceMsg(TF_SHELLEXEC, "SHEX::TryWowShellExec() used Wow");

        return TRY_STOP;
    }
    return TRY_CONTINUE_UNHANDLED;
}

TRYRESULT CShellExecute::_ShouldRetryWithNewClassKey(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    // If this is an app who's association is unknown, we might need to query the ClassStore if
    // we have not already done so.

    // The easiest way we can tell if the file we are going to execute is "Unknown" is by looking for
    // the "QueryClassStore" string value under the hkey we have. DllInstall in shell32 writes this key
    // so that we know when we are dealing with HKCR\Unknown (or any other progid that always wants to
    // do a classtore lookup)
    if (!_fAlreadyQueriedClassStore && !_fNoQueryClassStore &&
        SUCCEEDED(_pqa->GetData(0, ASSOCDATA_QUERYCLASSSTORE, NULL, NULL, NULL)))
    {
        if (fSync)
        {
            // go hit the NT5 Directory Services class store
            if (_szFile[0])
            {
                INSTALLDATA id;
                LPTSTR pszExtPart;
                WCHAR szFileExt[MAX_PATH];

                // all we have is a filename so whatever PathFindExtension
                // finds, we will use
                pszExtPart = PathFindExtension(_szFile);
                lstrcpy(szFileExt, pszExtPart);

                // Need to zero init id (can't do a = {0} when we declated it, because it has a non-zero enum type)
                ZeroMemory(&id, sizeof(INSTALLDATA));

                id.Type = FILEEXT;
                id.Spec.FileExt = szFileExt;

                // call the DS to lookup the file type in the class store
                if (ERROR_SUCCESS == InstallApplication(&id))
                {
                    // Since InstallApplication succeeded, it could have possibly installed and app
                    // or munged the registry so that we now have the necesssary reg info to
                    // launch the app. So basically re-read the class association to see if there is any
                    // new darwin info or new normal info, and jump back up and retry to execute.
                    LPITEMIDLIST pidlUnkFile = ILCreateFromPath(_szFile);

                    if (pidlUnkFile)
                    {
                        IQueryAssociations *pqa;
                        if (SUCCEEDED(SHGetAssociations(pidlUnkFile, (void **)&pqa)))
                        {
                            _pqa->Release();
                            _pqa = pqa;

                            if (_pszQueryVerb && (lstrcmpi(_pszQueryVerb, TEXT("openas")) == 0))
                            {
                                // Since we just sucessfully queried the class store, if our verb was "openas" (meaning
                                // that we used the Unknown key to do the execute) we always reset the verb to the default.
                                // If we do not do this, then we could fail the execute since "openas" is most likely not a
                                // supported verb of the application
                                _pszQueryVerb = NULL;
                            }
                        }

                        ILFree(pidlUnkFile);

                        _fAlreadyQueriedClassStore = TRUE;
                        _fClassStoreOnly = FALSE;
                    }

                } // CoGetClassInfo

            } // _szFile[0]
        }
        else
            tr = TRY_RETRYASYNC;
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::ShouldRWNCK() returning %d", tr);

    return tr;
}

TRYRESULT CShellExecute::_TryHooks(LPSHELLEXECUTEINFO pei)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (_UseHooks(pei->fMask))
    {
        //  REARCHITECT: the only client of this are URLs.
        //  if we change psfInternet to return IID_IQueryAssociations,
        //  then we can kill the urlexechook  (our only client)

        if (S_FALSE != TryShellExecuteHooks(pei))
        {
            //  either way we always exit.  should get TryShellhook to use SetLastError()
            _ReportHinst(pei->hInstApp);
            tr = TRY_STOP;;
        }
    }

    return tr;
}

void _PathStripTrailingDots(LPTSTR psz)
{
    // don't strip "." or ".."
    if (!PathIsDotOrDotDot(psz))
    {
        // remove any trailing dots
        TCHAR *pchLast = psz + lstrlen(psz) - 1;
        while (*pchLast == TEXT('.'))
        {
            *pchLast = 0;
            pchLast = CharPrev(psz, pchLast);
        }
    }
}

#define STR_PARSE_REQUIRE_REAL_NETWORK  L"Parse Require Real Network"
#define STR_PARSE_INTERNET_DONT_ESCAPE_SPACES   L"Parse Internet Dont Escape Spaces"

IBindCtx *CShellExecute::_PerfBindCtx()
{
    //
    //  180557 - make sure that we prefer the EXE to the folder - ZekeL - 9-SEP-2000
    //  this so that if both "D:\Setup" and "D:\Setup.exe" exist
    //  and the user types "D:\Setup" we will prefer to use "D:\Setup.exe"
    //  we also have to be careful not to send URLs down to SimpleIDList
    //  because of the weird results we get with the DavRedir
    //
    //  360353 - dont do resolve if we are passed the class key - ZekeL - 9-APR-2001
    //  if the caller passes us a key or class name then we must assume that 
    //  the item is already fully qualified.  specifically this can result in 
    //  a double resolve when doing an Open With....
    //
    //  206795 - dont use simple if the path is a root - ZekeL - 12-APR-2001
    //  specifically \\server\share needs this for printer shares with '.' to work.
    //  (eg \\printsvr\printer.first) this fails since a simple share will 
    //  be interpreted as SFGAO_FILESYSTEM always which will cause us to avoid
    //  the SHValidateUNC() which is what forces us to use the pidl for print shares.
    //  i think there are some similar issues with other shares that are not on the 
    //  default provider for the server (ie DAV shares).
    //
    IBindCtx *pbc = NULL;
    if (_fIsUrl)
    {
        //  403781 - avoid escaping spaces in URLs from ShellExec() - ZekeL - 25-May-2001
        //  this is because of removing the ShellExec hooks as the mechanism 
        //  for invoking URLs and switching to just using Parse/Invoke().
        //  however, the old code evidently avoided doing the UrlEscapeSpaces() 
        //  which the InternetNamespace typically does on parse.
        //  force xlate even though we are doing simple parse
        static BINDCTX_PARAM rgUrlParams[] = 
        { 
            { STR_PARSE_TRANSLATE_ALIASES, NULL},
            { STR_PARSE_INTERNET_DONT_ESCAPE_SPACES, NULL},
        };
        BindCtx_RegisterObjectParams(NULL, rgUrlParams, ARRAYSIZE(rgUrlParams), &pbc);
    }
    else if (!_fUseClass && !PathIsRoot(_szFile))
    {
        DWORD dwAttribs;
        if (PathFileExistsDefExtAndAttributes(_szFile, PFOPEX_DEFAULT | PFOPEX_OPTIONAL, &dwAttribs))
        {
            //  we found this with the extension.
            //  avoid hitting the disk again to do the parse
            WIN32_FIND_DATA wfd = {0};
            wfd.dwFileAttributes = dwAttribs;
            _PathStripTrailingDots(_szFile);
            IBindCtx *pbcFile;
            if (SUCCEEDED(SHCreateFileSysBindCtx(&wfd, &pbcFile)))
            {
                //  force xlate even though we are doing simple parse
                static BINDCTX_PARAM rgSimpleParams[] = 
                { 
                    { STR_PARSE_TRANSLATE_ALIASES, NULL},
                    //{ STR_PARSE_REQUIRE_REAL_NETWORK, NULL},
                };

                BindCtx_RegisterObjectParams(pbcFile, rgSimpleParams, ARRAYSIZE(rgSimpleParams), &pbc);
                pbcFile->Release();
            }
        }
    }

    return pbc;
}        

TRYRESULT CShellExecute::_PerfPidl(LPCITEMIDLIST *ppidl)
{
    *ppidl = _lpID;
    if (!_lpID)
    {
        IBindCtx *pbc = _PerfBindCtx();
        HRESULT hr = SHParseDisplayName(_szFile, pbc, &_pidlFree, SFGAO_STORAGECAPMASK, &_sfgaoID);

        if (pbc)
            pbc->Release();
            
        if (FAILED(hr) && !pbc && UrlIs(_szFile, URLIS_FILEURL))
        {
            DWORD err = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : ERROR_FILE_NOT_FOUND;
            _ReportWin32(err);
            return TRY_STOP;
        }

        *ppidl = _lpID = _pidlFree;
    }
    else
    {
        _sfgaoID = SFGAO_STORAGECAPMASK;
        if (FAILED(SHGetNameAndFlags(_lpID, 0, NULL, 0, &_sfgaoID)))
            _sfgaoID = 0;
    }
    return TRY_CONTINUE;
}

DWORD CShellExecute::_InvokeAppThreadProc()
{
    _fDDEWait = TRUE;
    _TryInvokeApplication(TRUE);
    Release();
    return 0;
}

DWORD WINAPI CShellExecute::s_InvokeAppThreadProc(void *pv)
{
    return ((CShellExecute *)pv)->_InvokeAppThreadProc();
}

TRYRESULT CShellExecute::_RetryAsync()
{
    if (_lpID && !_pidlFree)
        _lpID = _pidlFree = ILClone(_lpID);

    if (_lpParameters)
        _lpParameters = _pszAllocParams = StrDup(_lpParameters);

    if (_lpTitle)
        _lpTitle = _startup.lpTitle = _pszAllocTitle = StrDup(_lpTitle);

    _fAsync = TRUE;
    AddRef();
    if (!SHCreateThread(s_InvokeAppThreadProc, this, CTF_FREELIBANDEXIT | CTF_COINIT, NULL))
    {
        _ReportWin32(GetLastError());
        Release();
        return TRY_STOP;
    }
    return TRY_RETRYASYNC;
}

TRYRESULT CShellExecute::_TryInvokeApplication(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;

    if (fSync)
        tr = _SetCmdTemplate(fSync);

    if (KEEPTRYING(tr))
    {
        // check for both the CacheFilename and URL being passed to us,
        // if this is the case, we need to check to see which one the App
        // wants us to pass to it.
        _SetFileAndUrl();

        tr = _TryExecDDE();

        // check to see if darwin is enabled on the machine
        if (KEEPTRYING(tr))
        {
            if (!fSync)
                tr = _SetCmdTemplate(fSync);

            if (KEEPTRYING(tr))
            {
                // At this point, the _szFile should have been determined one way
                // or another.
                ASSERT(_szFile[0] || _szCmdTemplate[0]);

                // do we have the necessary RegDB info to do an exec?

                _TryExecCommand();
                tr = TRY_STOP;
            }
        }

    }

    if (tr == TRY_RETRYASYNC)
    {
        //  install this on another thread
        tr = _RetryAsync();
    }

    return tr;
}

void CShellExecute::ExecuteNormal(LPSHELLEXECUTEINFO pei)
{

    SetAppStartingCursor(pei->hwnd, TRUE);

    _Init(pei);

    //
    //  Copy the specified directory in _szWorkingDir if the working
    // directory is specified; otherwise, get the current directory there.
    //
    _SetWorkingDir(pei->lpDirectory);

    //
    //  Copy the file name to _szFile, if it is specified. Then,
    // perform environment substitution.
    //
    _SetFile(pei->lpFile, pei->fMask & SEE_MASK_FILEANDURL);

    LPCITEMIDLIST pidl;
    if (STOPTRYING(_PerfPidl(&pidl)))
        goto Quit;

    //  If the specified filename is a UNC path, validate it now.
    if (STOPTRYING(_TryValidateUNC(_szFile, pei, pidl)))
        goto Quit;

    if (STOPTRYING(_TryHooks(pei)))
        goto Quit;

    if (STOPTRYING(_TryExecPidl(pei, pidl)))
        goto Quit;

    // Is the class key provided?
    if (STOPTRYING(_InitAssociations(pei, pidl)))
        goto Quit;

    _TryInvokeApplication(_fDDEWait || (pei->fMask & SEE_MASK_NOCLOSEPROCESS));

Quit:

    //
    //  we should only see this if the registry is corrupted.
    //  but we still want to be able to open EXE's
#ifdef DEBUG
    if (_fTryOpenExe)
        TraceMsg(TF_WARNING, "SHEX - trying EXE with no Associations - %s", _szFile);
#endif // DEBUG

    if (_fTryOpenExe)
        _TryOpenExe();

    if (_err == ERROR_SUCCESS && UEMIsLoaded())
    {
        // skip the call if stuff isn't there yet.
        // the load is expensive (forces ole32.dll and browseui.dll in
        // and then pins browseui).

        // however we ran the app (exec, dde, etc.), we succeeded.  do our
        // best to guess the association etc. and log it.
        int i = GetUEMAssoc(_szFile, _szImageName, _lpID);
        TraceMsg(DM_MISC, "cse.e: GetUEMAssoc()=%d", i);
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, (LPARAM)i);
    }

    SetAppStartingCursor(pei->hwnd, FALSE);
}

DWORD CShellExecute::_FinalMapError(HINSTANCE UNALIGNED64 *phinst)
{
    if (_err != ERROR_SUCCESS)
    {
        // REVIEW: if errWin32 == ERROR_CANCELLED, we may want to
        // set hInstApp to 42 so people who don't check the return
        // code properly won't put up bogus messages. We should still
        // return FALSE. But this won't help everything and we should
        // really evangelize the proper use of ShellExecuteEx. In fact,
        // if we do want to do this, we should do it in ShellExecute
        // only. (This will force new people to do it right.)

        // Map FNF for drives to something slightly more sensible.
        if (_err == ERROR_FILE_NOT_FOUND && PathIsRoot(_szFile) &&
            !PathIsUNC(_szFile))
        {
            // NB CD-Rom drives with disk missing will hit this.
            if ((DriveType(DRIVEID(_szFile)) == DRIVE_CDROM) ||
                (DriveType(DRIVEID(_szFile)) == DRIVE_REMOVABLE))
                _err = ERROR_NOT_READY;
            else
                _err = ERROR_BAD_UNIT;
        }

        SetLastError(_err);

        if (phinst)
            *phinst = _MapWin32ErrToHINST(_err);

    }
    else if (phinst)
    {
        if (!_hInstance)
        {
            *phinst = (HINSTANCE) 42;
        }
        else
            *phinst = _hInstance;

        ASSERT(ISSHELLEXECSUCCEEDED(*phinst));
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::FinalMapError() returning err = %d, hinst = %d", _err, _hInstance);

    return _err;
}

DWORD CShellExecute::Finalize(LPSHELLEXECUTEINFO pei)
{
    ASSERT(!_fAsync || !(pei->fMask & SEE_MASK_NOCLOSEPROCESS));

    if (!_fAsync
    && _pi.hProcess
    && _err == ERROR_SUCCESS
    && (pei->fMask & SEE_MASK_NOCLOSEPROCESS))
    {
        //
        //  change from win95 behavior - zekel 3-APR-98
        //  in win95 we would close the proces but return a handle.
        //  the handle was invalid of course, but some crazy app could be
        //  using this value to test for success.  i am assuming that they
        //  are using one of the other three ways to determine success,
        //  and we can follow the spec and return NULL if we close it.
        //
        //  PEIOUT - set the hProcess if they are going to use it.
        pei->hProcess = _pi.hProcess;
        _pi.hProcess = NULL;
    }

    //
    //  NOTE:  _FinalMapError() actually calls SetLastError() with our best error
    //  if any win32 apis are called after this, they can reset LastError!!
    //
    return _FinalMapError(&(pei->hInstApp));
}

//
//  Both the Reports return back TRUE if there was an error
//  or FALSE if it was a Success.
//
BOOL CShellExecute::_ReportWin32(DWORD err)
{
    ASSERT(!_err);
    TraceMsg(TF_SHELLEXEC, "SHEX::ReportWin32 reporting err = %d", err);

    _err = err;
    return (err != ERROR_SUCCESS);
}

BOOL CShellExecute::_ReportHinst(HINSTANCE hinst)
{
    ASSERT(!_hInstance);
    TraceMsg(TF_SHELLEXEC, "SHEX::ReportHinst reporting hinst = %d", hinst);
    if (ISSHELLEXECSUCCEEDED(hinst) || !hinst)
    {
        _hInstance = hinst;
        return FALSE;
    }
    else
        return _ReportWin32(_MapHINSTToWin32Err(hinst));
}

typedef struct {
    DWORD errWin32;
    UINT se_err;
} SHEXERR;

// one to one errs
//  ERROR_FILE_NOT_FOUND             SE_ERR_FNF              2       // file not found
//  ERROR_PATH_NOT_FOUND             SE_ERR_PNF              3       // path not found
//  ERROR_ACCESS_DENIED              SE_ERR_ACCESSDENIED     5       // access denied
//  ERROR_NOT_ENOUGH_MEMORY          SE_ERR_OOM              8       // out of memory
#define ISONE2ONE(e)   (e == SE_ERR_FNF || e == SE_ERR_PNF || e == SE_ERR_ACCESSDENIED || e == SE_ERR_OOM)

//  no win32 mapping SE_ERR_DDETIMEOUT               28
//  no win32 mapping SE_ERR_DDEBUSY                  30
//  but i dont see any places where this is returned.
//  before they became the win32 equivalent...ERROR_OUT_OF_PAPER or ERROR_READ_FAULT
//  now they become ERROR_DDE_FAIL.
//  but we wont preserve these errors in the pei->hInstApp
#define ISUNMAPPEDHINST(e)   (e == 28 || e == 30)

//  **WARNING** .  ORDER is IMPORTANT.
//  if there is more than one mapping for an error,
//  (like SE_ERR_PNF) then the first
const SHEXERR c_rgShexErrs[] = {
    {ERROR_SHARING_VIOLATION, SE_ERR_SHARE},
    {ERROR_OUTOFMEMORY, SE_ERR_OOM},
    {ERROR_BAD_PATHNAME,SE_ERR_PNF},
    {ERROR_BAD_NETPATH,SE_ERR_PNF},
    {ERROR_PATH_BUSY,SE_ERR_PNF},
    {ERROR_NO_NET_OR_BAD_PATH,SE_ERR_PNF},
    {ERROR_OLD_WIN_VERSION,10},
    {ERROR_APP_WRONG_OS,12},
    {ERROR_RMODE_APP,15},
    {ERROR_SINGLE_INSTANCE_APP,16},
    {ERROR_INVALID_DLL,20},
    {ERROR_NO_ASSOCIATION,SE_ERR_NOASSOC},
    {ERROR_DDE_FAIL,SE_ERR_DDEFAIL},
    {ERROR_DDE_FAIL,SE_ERR_DDEBUSY},
    {ERROR_DDE_FAIL,SE_ERR_DDETIMEOUT},
    {ERROR_DLL_NOT_FOUND,SE_ERR_DLLNOTFOUND}
};

DWORD CShellExecute::_MapHINSTToWin32Err(HINSTANCE hinst)
{
    DWORD errWin32 = 0;
    UINT_PTR se_err = (UINT_PTR) hinst;

    ASSERT(se_err);
    ASSERT(!ISSHELLEXECSUCCEEDED(se_err));

    // i actually handle these, but it used to be that these
    // became mutant win32s.  now they will be lost
    // i dont think these occur anymore
    AssertMsg(!ISUNMAPPEDHINST(se_err), TEXT("SHEX::COMPATIBILITY SE_ERR = %d, Get ZekeL!!!"), se_err);

    if (ISONE2ONE(se_err))
    {
        errWin32 = (DWORD) se_err;
    }
    else for (int i = 0; i < ARRAYSIZE(c_rgShexErrs) ; i++)
    {
        if (se_err == c_rgShexErrs[i].se_err)
        {
            errWin32= c_rgShexErrs[i].errWin32;
            break;
        }
    }

    ASSERT(errWin32);

    return errWin32;
}


HINSTANCE CShellExecute::_MapWin32ErrToHINST(UINT errWin32)
{
    ASSERT(errWin32);

    UINT se_err = 0;
    if (ISONE2ONE(errWin32))
    {
        se_err = errWin32;
    }
    else for (int i = 0; i < ARRAYSIZE(c_rgShexErrs) ; i++)
    {
        if (errWin32 == c_rgShexErrs[i].errWin32)
        {
            se_err = c_rgShexErrs[i].se_err;
            break;
        }
    }

    if (!se_err)
    {
        //  NOTE legacy error handling  - zekel - 20-NOV-97
        //  for any unhandled win32 errors, we default to ACCESS_DENIED
        se_err = SE_ERR_ACCESSDENIED;
    }

    return IntToHinst(se_err);
}


DWORD ShellExecuteNormal(LPSHELLEXECUTEINFO pei)
{
    DWORD err;
    TraceMsg(TF_SHELLEXEC, "ShellExecuteNormal Using CShellExecute");

    //  WARNING Dont use up Stack Space
    //  we allocate because of win16 stack issues
    //  and the shex is a big object
    CShellExecute *shex = new CShellExecute();

    if (shex)
    {
        shex->ExecuteNormal(pei);
        err = shex->Finalize(pei);
        shex->Release();
    }
    else
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
        err = ERROR_OUTOFMEMORY;
    }

    TraceMsg(TF_SHELLEXEC, "ShellExecuteNormal returning win32 = %d, hinst = %d", err, pei->hInstApp);

    return err;
}

BOOL CShellExecute::Init(PSHCREATEPROCESSINFO pscpi)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::Init(pscpi)");

    _SetMask(pscpi->fMask);

    _lpParameters= pscpi->pszParameters;

    //  we always do "runas"
    _pszQueryVerb = _wszVerb;
    _cpt = pscpi->hUserToken ? CPT_ASUSER : CPT_WITHLOGON;

    if (pscpi->lpStartupInfo)
    {
        _nShow = pscpi->lpStartupInfo->wShowWindow;
        _startup = *(pscpi->lpStartupInfo);
    }
    else    // require startupinfo
        return !(_ReportWin32(ERROR_INVALID_PARAMETER));

    //
    //  Copy the specified directory in _szWorkingDir if the working
    // directory is specified; otherwise, get the current directory there.
    //
    _SetWorkingDir(pscpi->pszCurrentDirectory);

    //
    //  Copy the file name to _szFile, if it is specified. Then,
    // perform environment substitution.
    //
    _SetFile(pscpi->pszFile, FALSE);

    _pProcAttrs = pscpi->lpProcessAttributes;
    _pThreadAttrs = pscpi->lpThreadAttributes;
    _fInheritHandles = pscpi->bInheritHandles;
    _hUserToken = pscpi->hUserToken;
    //  createflags already inited by _SetMask() just
    //  add the users in.
    _dwCreateFlags |= pscpi->dwCreationFlags;
    _hwndParent = pscpi->hwnd;

    return TRUE;
}


void CShellExecute::ExecuteProcess(void)
{
    SetAppStartingCursor(_hwndParent, TRUE);

    //
    //  If the specified filename is a UNC path, validate it now.
    //
    if (STOPTRYING(_TryValidateUNC(_szFile, NULL, NULL)))
        goto Quit;

    if (STOPTRYING(_Resolve()))
        goto Quit;

    if (STOPTRYING(_InitAssociations(NULL, NULL)))
        goto Quit;

    // check to see if darwin is enabled on the machine
    if (STOPTRYING(_SetCmdTemplate(TRUE)))
        goto Quit;

    // At this point, the _szFile should have been determined one way
    // or another.
    ASSERT(_szFile[0] || _szCmdTemplate[0]);

    // do we have the necessary RegDB info to do an exec?

    _TryExecCommand();

Quit:

    //
    //  we should only see this if the registry is corrupted.
    //  but we still want to be able to open EXE's
    RIP(!_fTryOpenExe);
    if (_fTryOpenExe)
        _TryOpenExe();

    if (_err == ERROR_SUCCESS && UEMIsLoaded())
    {
        int i;
        // skip the call if stuff isn't there yet.
        // the load is expensive (forces ole32.dll and browseui.dll in
        // and then pins browseui).

        // however we ran the app (exec, dde, etc.), we succeeded.  do our
        // best to guess the association etc. and log it.
        i = GetUEMAssoc(_szFile, _szImageName, NULL);
        TraceMsg(DM_MISC, "cse.e: GetUEMAssoc()=%d", i);
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, (LPARAM)i);
    }

    SetAppStartingCursor(_hwndParent, FALSE);

}

DWORD CShellExecute::Finalize(PSHCREATEPROCESSINFO pscpi)
{
    if (!_fAsync && _pi.hProcess)
    {
        if (!(pscpi->fMask & SEE_MASK_NOCLOSEPROCESS))
        {
            CloseHandle(_pi.hProcess);
            _pi.hProcess = NULL;
            CloseHandle(_pi.hThread);
            _pi.hThread = NULL;
        }

        if (_err == ERROR_SUCCESS
        && pscpi->lpProcessInformation)
        {
            *(pscpi->lpProcessInformation) = _pi;
        }

    }
    else if (pscpi->lpProcessInformation)
        ZeroMemory(pscpi->lpProcessInformation, sizeof(_pi));

    //
    //  NOTE:  _FinalMapError() actually calls SetLastError() with our best error
    //  if any win32 apis are called after this, they can reset LastError!!
    //
    return _FinalMapError(NULL);
}

SHSTDAPI_(BOOL) SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi)
{
    DWORD err;
    TraceMsg(TF_SHELLEXEC, "SHCreateProcess using CShellExecute");

    //  WARNING Don't use up Stack Space
    //  we allocate because of win16 stack issues
    //  and the shex is a big object
    CShellExecute *pshex = new CShellExecute();

    if (pshex)
    {
        if (pshex->Init(pscpi))
            pshex->ExecuteProcess();

        err = pshex->Finalize(pscpi);

        pshex->Release();
    }
    else
        err = ERROR_OUTOFMEMORY;

    TraceMsg(TF_SHELLEXEC, "SHCreateProcess returning win32 = %d", err);

    if (err != ERROR_SUCCESS)
    {
        _DisplayShellExecError(pscpi->fMask, pscpi->hwnd, pscpi->pszFile, NULL, err);
        SetLastError(err);
    }

    return err == ERROR_SUCCESS;
}

HINSTANCE  APIENTRY WOWShellExecute(
    HWND  hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd,
    void *lpfnCBWinExec)
{
   g_pfnWowShellExecCB = lpfnCBWinExec;

   if (!lpParameters)
       lpParameters = "";

   HINSTANCE hinstRet = RealShellExecuteExA(hwnd, lpOperation, lpFile, lpParameters,
      lpDirectory, NULL, "", NULL, (WORD)nShowCmd, NULL, 0);

   g_pfnWowShellExecCB = NULL;

   return hinstRet;
}

void _ShellExec_RunDLL(HWND hwnd, HINSTANCE hAppInstance, LPCTSTR pszCmdLine, int nCmdShow)
{
    TCHAR szQuotedCmdLine[MAX_PATH * 2];
    SHELLEXECUTEINFO ei = {0};
    ULONG fMask = SEE_MASK_FLAG_DDEWAIT;
    LPTSTR pszArgs;

    // Don't let empty strings through, they will endup doing something dumb
    // like opening a command prompt or the like
    if (!pszCmdLine || !*pszCmdLine)
        return;

    //
    //   the flags are prepended to the command line like:
    //   "?0x00000001?" "cmd line"
    //
    if (pszCmdLine[0] == TEXT('?'))
    {
        //  these are the fMask flags
        int i;
        if (StrToIntEx(++pszCmdLine, STIF_SUPPORT_HEX, &i))
        {
            fMask |= i;
        }

        pszCmdLine = StrChr(pszCmdLine, TEXT('?'));

        if (!pszCmdLine)
            return;

        pszCmdLine++;
    }

    // Gross, but if the process command fails, copy the command line to let
    // shell execute report the errors
    if (PathProcessCommand(pszCmdLine, szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine),
                           PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) == -1)
        StrCpyN(szQuotedCmdLine, pszCmdLine, SIZECHARS(szQuotedCmdLine));

    pszArgs = PathGetArgs(szQuotedCmdLine);
    if (*pszArgs)
        *(pszArgs - 1) = 0; // Strip args

    PathUnquoteSpaces(szQuotedCmdLine);

    ei.cbSize          = sizeof(SHELLEXECUTEINFO);
    ei.hwnd            = hwnd;
    ei.lpFile          = szQuotedCmdLine;
    ei.lpParameters    = pszArgs;
    ei.nShow           = nCmdShow;
    ei.fMask           = fMask;

    //  if shellexec() fails we want to pass back the error.
    if (!ShellExecuteEx(&ei))
    {
        DWORD err = GetLastError();

        if (InRunDllProcess())
            ExitProcess(err);
    }
}

STDAPI_(void) ShellExec_RunDLLA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    SHSTR str;
    if (SUCCEEDED(str.SetStr(pszCmdLine)))
        _ShellExec_RunDLL(hwnd, hAppInstance, str, nCmdShow);
}


STDAPI_(void) ShellExec_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    SHSTR str;
    if (SUCCEEDED(str.SetStr(pszCmdLine)))
        _ShellExec_RunDLL(hwnd, hAppInstance, str, nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\expenv.c ===
/****************************************************************************/
/*                                                                          */
/*  enpenv.c -                                                              */
/*                                                                          */
/*      Routines for expanding environment strings                          */
/*                                                                          */
/****************************************************************************/

#include "shellprv.h"

//-------------------------------------------------------------------------
// The given string is parsed and all environment variables
// are expanded. If the expansion doesn't over fill the buffer
// then the length of the new string will be returned in the
// hiword and TRUE in the low word.  If the expansion would over
// fill the buffer then the original string is left unexpanded,
// the original length in the high word and FALSE in the low word.
// The length of the string is in bytes and excludes the terminating
// NULL.
//
// NOTE 1: This function must now handle environment variables in Quotes
//
// NOTE 2: There is no need for this API since NT has the equivalent APIs such
//       as ExpandEnvironmentStrings. But must keep it since it is a public
//       API in Win3.1.
//       Instead of doing all the work here, just call ExpandEnvironmentStrings.
//-------------------------------------------------------------------------

DWORD  APIENTRY DoEnvironmentSubstA(
   LPSTR pszSrc,    // The input string.
   UINT cchSrc)  // The limit of characters in the input string inc null.
{
    LPSTR pszExp;
    DWORD cchExp;
    BOOL fRet = FALSE;
        
    pszExp = (LPSTR)LocalAlloc(LPTR, cchSrc);
    if (pszExp)
    {
        cchExp = SHExpandEnvironmentStringsA(pszSrc, pszExp, cchSrc);
        if (cchExp)
        {
            StrCpyA(pszSrc, pszExp);
            fRet = TRUE;
        }
        LocalFree(pszExp);
    }

    if (fRet)
        return MAKELONG(cchExp,TRUE);
    else
        return MAKELONG(cchSrc,FALSE);
}

#ifdef UNICODE // on Win9x platform, shlunimp.c provides the implementation
DWORD  APIENTRY DoEnvironmentSubstW(
   LPWSTR pszSrc,    // The input string.
   UINT cchSrc)    // The limit of characters in the input string inc null.
{
    LPWSTR pszExp;
    DWORD cchExp;
    BOOL fRet = FALSE;
        
    pszExp = (LPWSTR)LocalAlloc(LPTR, cchSrc * sizeof(WCHAR));
    if (pszExp)
    {
        cchExp = SHExpandEnvironmentStringsW(pszSrc, pszExp, cchSrc);
        if (cchExp)
        {
            StrCpyW(pszSrc, pszExp);
            fRet = TRUE;
        }
        LocalFree(pszExp);
    }

    if (fRet)
        return MAKELONG(cchExp,TRUE);
    else
        return MAKELONG(cchSrc,FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fileenum.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include "recdocs.h"
#include "ids.h"
#include "mtpt.h"

class CFileSysEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CFileSysEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags);
    HRESULT Init();

private:
    ~CFileSysEnum();
    BOOL _FindNextFile();
    void _HideFiles();   // operates on _fd data

    LONG _cRef;

    CFSFolder *_pfsf;
    DWORD _grfFlags;
    HWND _hwnd;

    HANDLE _hfind;
    TCHAR _szFolder[MAX_PATH];
    BOOL _fMoreToEnum;
    WIN32_FIND_DATA _fd;
    int _cHiddenFiles;
    ULONGLONG _cbSize;

    IMruDataList *_pmruRecent;
    int _iIndexMRU;

    BOOL _fShowSuperHidden;
    BOOL _fIsRootDrive;
    BOOL _fIsCDFS;
};

CFileSysEnum::CFileSysEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags) : 
    _cRef(1), _pfsf(pfsf), _hwnd(hwnd), _grfFlags(grfFlags), _hfind(INVALID_HANDLE_VALUE)
{
    _fShowSuperHidden = ShowSuperHidden();

    _pfsf->AddRef();
}

CFileSysEnum::~CFileSysEnum()
{
    if (_hfind != INVALID_HANDLE_VALUE)
    {
        //  this handle can be the find file or MRU list in the case of RECENTDOCSDIR
        ATOMICRELEASE(_pmruRecent);
        FindClose(_hfind);

        _hfind = INVALID_HANDLE_VALUE;
    }
    _pfsf->Release();
}

HRESULT CFileSysEnum::Init()
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = _pfsf->_GetPath(_szFolder);

    if (SUCCEEDED(hr) && !PathIsUNC(_szFolder))
    {
        TCHAR szRoot[] = TEXT("A:\\");
        _fIsRootDrive = PathIsRoot(_szFolder);
        // For mapped net drives, register a change
        // notify alias for the corresponding UNC path.

        szRoot[0] = _szFolder[0];

        if (DRIVE_REMOTE == GetDriveType(szRoot))
        {
            MountPoint_RegisterChangeNotifyAlias(DRIVEID(_szFolder));
        }

        TCHAR szFileSystem[6];
        _fIsCDFS = (DRIVE_CDROM == GetDriveType(szRoot)) &&
                   GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)) &&
                   (StrCmpI(L"CDFS", szFileSystem) == 0);
    }

    if (SUCCEEDED(hr) &&
        PathCombine(szPath, _szFolder, c_szStarDotStar))
    {
        // let name mapper see the path/PIDL pair (for UNC root mapping)
        // skip the My Net Places entry when passing it to NPTRegisterNameToPidlTranslation.
        LPCITEMIDLIST pidlToMap = _pfsf->_pidlTarget ? _pfsf->_pidlTarget:_pfsf->_pidl;
        if (IsIDListInNameSpace(pidlToMap, &CLSID_NetworkPlaces))
        {
            NPTRegisterNameToPidlTranslation(_szFolder, _ILNext(pidlToMap));
        }

        if (_grfFlags == SHCONTF_FOLDERS)
        {
            // use mask to only find folders, mask is in the hi byte of dwFileAttributes
            // algorithm: (((attrib_on_disk & mask) ^ mask) == 0)
            // signature to tell SHFindFirstFileRetry() to use the attribs specified

            _fd.dwFileAttributes = (FILE_ATTRIBUTE_DIRECTORY << 8) |
                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY;
            _fd.dwReserved0 = 0x56504347;      
        }

        hr = SHFindFirstFileRetry(_hwnd, NULL, szPath, &_fd, &_hfind, SHPPFW_NONE);
        if (SUCCEEDED(hr))
        {
            _HideFiles();

            ASSERT(hr == S_OK ? (_hfind != INVALID_HANDLE_VALUE) : TRUE);

            _fMoreToEnum = (hr == S_OK);

            if (!(_grfFlags & SHCONTF_INCLUDEHIDDEN))
            {
                if (_pfsf->_IsCSIDL(CSIDL_RECENT))
                {
                    CreateRecentMRUList(&_pmruRecent);
                }
            }
            hr = S_OK;  // convert S_FALSE to S_OK to match ::EnumObjects() returns
        }
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        // Tracking target doesn't exist; return an empty enumerator
        _fMoreToEnum = FALSE;
        hr = S_OK;
    }
    else
    {
        // _GetPathForItem & PathCombine() fail when path is too long
        if (_hwnd)
        {
            ShellMessageBox(HINST_THISDLL, _hwnd, MAKEINTRESOURCE(IDS_ENUMERR_PATHTOOLONG),
                NULL, MB_OK | MB_ICONHAND);
        }

        // This error value tells callers that we have already displayed error UI so skip
        // displaying errors.
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}

STDMETHODIMP CFileSysEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

const LPCWSTR c_rgFilesToHideInRoot[] = 
{
    L"AUTOEXEC.BAT",    // case sensitive
    L"CONFIG.SYS",
    L"COMMAND.COM"
};

const LPCWSTR c_rgFilesToHideOnCDFS[] =
{
    L"thumbs.db",
    L"desktop.ini"
};

void CFileSysEnum::_HideFiles()
{
    // only do this if HIDDEN and SYSTEM attributes are not set on the file
    // (we assume if the file has these bits these files are setup properly)
    if (0 == (_fd.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)))
    {
        // only do this for root drives
        if (_fIsRootDrive)
        {
            for (int i = 0; i < ARRAYSIZE(c_rgFilesToHideInRoot); i++)
            {
                // case sensitive to make it faster
                if (0 == StrCmpC(c_rgFilesToHideInRoot[i], _fd.cFileName))
                {
                    _fd.dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
                    break;
                }
            }
        }

        // only do this if we're on a normal CD filesystem
        if (_fIsCDFS)
        {
            for (int i = 0; i < ARRAYSIZE(c_rgFilesToHideOnCDFS); i++)
            {
                // dont share code from above since these can be upper or lower
                if (0 == StrCmpI(c_rgFilesToHideOnCDFS[i], _fd.cFileName))
                {
                    _fd.dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
                    break;
                }
            }
        }
    }
}

BOOL CFileSysEnum::_FindNextFile()
{
    BOOL fMoreToEnum = FALSE;

    if (_pmruRecent)
    {
        LPITEMIDLIST pidl;

        while (SUCCEEDED(RecentDocs_Enum(_pmruRecent, _iIndexMRU, &pidl)))
        {
            // confirm that the item stil exists in the file system, fill in the _fd data
            TCHAR szPath[MAX_PATH];
            HANDLE h;

            _pfsf->_GetPathForItem(_pfsf->_IsValidID(pidl), szPath);
            ILFree(pidl);

            h = FindFirstFile(szPath, &_fd);
            if (h != INVALID_HANDLE_VALUE)
            {
                fMoreToEnum = TRUE;
                _iIndexMRU++;
                FindClose(h);
                break;
            }
            else
            {
                //
                //  WARNING - if the list is corrupt we torch it - ZekeL 19-JUN-98
                //  we could do some special stuff, i guess, to weed out the bad
                //  items, but it seems simpler to just blow it away.
                //  the only reason this should happen is if somebody
                //  has been mushing around with RECENT directory directly,
                //  which they shouldnt do since it is hidden...
                //
                
                //  kill this invalid entry, and then try the same index again...
                _pmruRecent->Delete(_iIndexMRU);
            }
        }
    }
    else
    {
        fMoreToEnum = FindNextFile(_hfind, &_fd);
        _HideFiles();
    }

    return fMoreToEnum;
}

STDMETHODIMP CFileSysEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    for (; _fMoreToEnum; _fMoreToEnum = _FindNextFile())
    {
        if (_fMoreToEnum == (BOOL)42)
            continue;   // we already processed the current item, skip it now

        if (PathIsDotOrDotDot(_fd.cFileName))
            continue;

        if (!(_grfFlags & SHCONTF_STORAGE))
        {
            if (_fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!(_grfFlags & SHCONTF_FOLDERS))
                    continue;   // item is folder but client does not want folders
            }
            else if (!(_grfFlags & SHCONTF_NONFOLDERS))
                continue;   // item is file, but client only wants folders

            // skip hidden and system things unconditionally, don't even count them
            if (!_fShowSuperHidden && IS_SYSTEM_HIDDEN(_fd.dwFileAttributes))
                continue;
        }

        _cbSize += MAKELONGLONG(_fd.nFileSizeLow, _fd.nFileSizeHigh);

        if (!(_grfFlags & (SHCONTF_INCLUDEHIDDEN | SHCONTF_STORAGE)) &&
             (_fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            _cHiddenFiles++;
            continue;
        }
        break;
    }

    if (_fMoreToEnum)
    {
        hr = _pfsf->_CreateIDList(&_fd, NULL, ppidl);
        _fMoreToEnum = (BOOL)42;    // we have processed the current item, skip it next time
    }
    else
    {
        *ppidl = NULL;
        hr = S_FALSE; // no more items
        // completed the enum, stash some items back into the folder 
        // PERF ??: we could QueryService for the view callback at this point and
        // poke these in directly there instead of pushing these into the folder
        _pfsf->_cHiddenFiles = _cHiddenFiles;
        _pfsf->_cbSize = _cbSize;
    }

    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}


STDMETHODIMP CFileSysEnum::Skip(ULONG celt) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSysEnum::Reset() 
{
    return S_OK;
}

STDMETHODIMP CFileSysEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDAPI CFSFolder_CreateEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    HRESULT hr;
    CFileSysEnum *penum = new CFileSysEnum(pfsf, hwnd, grfFlags);
    if (penum)
    {
        hr = penum->Init();
        if (SUCCEEDED(hr))
            hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        penum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\exedrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ids.h"
#include "defview.h"
#include "datautil.h"
#include <cowsite.h>    // base class for IObjectWithSite
#include "idlcomm.h"

// shlexec.c
STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszFullPathToApp);


// drop target impl for .exe files


class CExeDropTarget : public IDropTarget, IPersistFile, CObjectWithSite
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFile
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName);

    // IObjectWithSite
    // STDMETHOD(SetSite)(IUnknown *punkSite);
    // STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    CExeDropTarget();

private:
    ~CExeDropTarget();
    void _FillSEIFromLinkSite(SHELLEXECUTEINFO *pei);
    void _CleanupSEIFromLinkSite(SHELLEXECUTEINFO *pei);

    LONG _cRef;
    DWORD _dwEffectLast;
    DWORD _grfKeyStateLast;
    TCHAR _szFile[MAX_PATH];
};

CExeDropTarget::CExeDropTarget() : _cRef(1)
{
}

CExeDropTarget::~CExeDropTarget()
{
}

STDMETHODIMP CExeDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CExeDropTarget, IDropTarget),
        QITABENT(CExeDropTarget, IPersistFile), 
        QITABENTMULTI(CExeDropTarget, IPersist, IPersistFile),
        QITABENT(CExeDropTarget, IObjectWithSite),              // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExeDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExeDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CExeDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if ((S_OK == pdtobj->QueryGetData(&fmte)) ||
        (S_OK == DataObj_GetShellURL(pdtobj, NULL, NULL)))
    {
        *pdwEffect &= (DROPEFFECT_COPY | DROPEFFECT_LINK);
    }
    else
        *pdwEffect = 0;

    _dwEffectLast = *pdwEffect;
    _grfKeyStateLast = grfKeyState;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = _dwEffectLast;
    _grfKeyStateLast = grfKeyState;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::DragLeave()
{
    return S_OK;
}

//
//  See if we were created from a shortcut.  If so, then pull the exec
//  parameters from the shortcut.
//
void CExeDropTarget::_FillSEIFromLinkSite(SHELLEXECUTEINFO *pei)
{
    ASSERT(pei->lpParameters == NULL);
    ASSERT(pei->lpDirectory == NULL);

    IShellLink *psl;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_LinkSite, IID_IShellLink, (void **)&psl)))
    {
        TCHAR szBuf[MAX_PATH];

        psl->GetShowCmd(&pei->nShow);

        // Hotkeys are annoying because IShellLink::GetHotkey uses a
        // WORD as the hotkey, but SHELLEXECUTEINFO uses a DWORD.

        WORD wHotkey;
        if (SUCCEEDED(psl->GetHotkey(&wHotkey)))
        {
            pei->dwHotKey = wHotkey;
            pei->fMask |= SEE_MASK_HOTKEY;
        }

        if (SUCCEEDED(psl->GetWorkingDirectory(szBuf, ARRAYSIZE(szBuf))) &&
            szBuf[0])
        {
            Str_SetPtr(const_cast<LPTSTR *>(&pei->lpDirectory), szBuf);
        }

        if (SUCCEEDED(psl->GetArguments(szBuf, ARRAYSIZE(szBuf))) &&
            szBuf[0])
        {
            Str_SetPtr(const_cast<LPTSTR *>(&pei->lpParameters), szBuf);
        }

        psl->Release();
    }

}

void CExeDropTarget::_CleanupSEIFromLinkSite(SHELLEXECUTEINFO *pei)
{
    Str_SetPtr(const_cast<LPTSTR *>(&pei->lpDirectory), NULL);
    Str_SetPtr(const_cast<LPTSTR *>(&pei->lpParameters), NULL);
}

BOOL GetAppDropTarget(LPCTSTR pszPath, CLSID *pclsid)
{
    TCHAR sz[MAX_PATH];

    // NOTE this assumes that this is a path to the exe
    // and not a command line
    PathToAppPathKey(pszPath, sz, ARRAYSIZE(sz));
    TCHAR szClsid[64];
    DWORD cb = sizeof(szClsid);
    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("DropTarget"), NULL, szClsid, &cb)) &&
            GUIDFromString(szClsid, pclsid);
}


STDMETHODIMP CExeDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectPerformed = 0;

    if (!(_grfKeyStateLast & MK_LBUTTON))
    {
        HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, POPUP_DROPONEXE);
        if (hmenu)
        {
            HWND hwnd;
            IUnknown_GetWindow(_punkSite, &hwnd);

            UINT idCmd = SHTrackPopupMenu(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pt.x, pt.y, 0, hwnd, NULL);
            DestroyMenu(hmenu);
            if (idCmd != DDIDM_COPY)
            {
                *pdwEffect = 0; // canceled
            }
        }
    }

    if (*pdwEffect)
    {
        CLSID clsidDropTarget;
        if (GetAppDropTarget(_szFile, &clsidDropTarget))
        {
            if (SUCCEEDED(SHSimulateDropOnClsid(clsidDropTarget, _punkSite, pdtobj)))
            {
                dwEffectPerformed = DROPEFFECT_COPY;  // what we did
            }
        }
        else
        {
            SHELLEXECUTEINFO ei = {
                sizeof(ei),
                    0, NULL, NULL, _szFile, NULL, NULL, SW_SHOWNORMAL, NULL 
            };
            
            _FillSEIFromLinkSite(&ei);
            
            LPCTSTR pszLinkParams = ei.lpParameters;
            
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;
            HRESULT hr = pdtobj->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];
                int cchParam = ei.lpParameters ? lstrlen(ei.lpParameters) + 1 : 0;
                BOOL fLFNAware = App_IsLFNAware(_szFile);
                
                for (UINT i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                {
                    if (fLFNAware)
                        PathQuoteSpaces(szPath);
                    else
                        GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));
                    cchParam += lstrlen(szPath) + 2;    // space and NULL
                }
                
                if (cchParam)
                {
                    LPTSTR pszParam = (LPTSTR)LocalAlloc(LPTR, cchParam * sizeof(*pszParam));
                    if (pszParam)
                    {
                        // If the link had parameters, then put our filenames after
                        // the parameters (with an intervening space)
                        
                        if (ei.lpParameters)
                        {
                            lstrcpyn(pszParam, ei.lpParameters, cchParam);
                            lstrcat(pszParam, c_szSpace);
                        }
                        
                        for (i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                        {
                            if (fLFNAware)
                                PathQuoteSpaces(szPath);
                            else
                                GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));
                            if (i > 0)
                                lstrcat(pszParam, c_szSpace);
                            lstrcat(pszParam, szPath);
                        }
                        
                        ei.lpParameters = pszParam;
                        
                        ShellExecuteEx(&ei);
                        
                        LocalFree((HLOCAL)pszParam);
                        
                        dwEffectPerformed = DROPEFFECT_COPY;  // what we did
                    }
                }
                ReleaseStgMedium(&medium);
            }
            else
            {
                LPCSTR pszURL;
                
                if (SUCCEEDED(DataObj_GetShellURL(pdtobj, &medium, &pszURL)))
                {
                    if (DoesAppWantUrl(_szFile))
                    {
                        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                        SHAnsiToTChar(pszURL, szURL, ARRAYSIZE(szURL));
                        
                        ei.lpParameters = szURL;
                        
                        ShellExecuteEx(&ei);
                        
                        dwEffectPerformed = DROPEFFECT_LINK;  // what we did
                    }
                    ReleaseStgMediumHGLOBAL(NULL, &medium);
                }
            }
            
            // The process of building the ShellExecuteEx parameters may have
            // messed up the ei.lpParameters, so put the original back so the
            // cleanup function won't get confused.
            ei.lpParameters = pszLinkParams;
            _CleanupSEIFromLinkSite(&ei);
        }
        
        *pdwEffect = dwEffectPerformed;
    }
    
    return S_OK;
}

STDMETHODIMP CExeDropTarget::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ExeDropTarget;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::IsDirty(void)
{
    return S_OK;        // no
}

STDMETHODIMP CExeDropTarget::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    SHUnicodeToTChar(pszFileName, _szFile, ARRAYSIZE(_szFile));
    return S_OK;
}

STDMETHODIMP CExeDropTarget::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return S_OK;
}

STDMETHODIMP CExeDropTarget::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

STDMETHODIMP CExeDropTarget::GetCurFile(LPOLESTR *ppszFileName)
{
    *ppszFileName = NULL;
    return E_NOTIMPL;
}

STDAPI CExeDropTarget_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CExeDropTarget* pdt = new CExeDropTarget();
    if (pdt)
    {
        hr = pdt->QueryInterface(riid, ppv);
        pdt->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fileop.h ===
//----------------------------------------------------------------------------
// Exports from fileop.
//----------------------------------------------------------------------------

BOOL  ExtendedCreate(LPTSTR pName, DWORD dwFileAttributes, HFILE *pfh);
void  SetDateTime(HFILE fh, WORD wDate, WORD wTime);

#ifdef WIN32
#define SetFileRaw(fh)
#define IsSerialDevice(fh) FALSE
#else
void  SetFileRaw(HFILE fh);
BOOL  IsSerialDevice(HFILE fh);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filefldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ole2dup.h"
#include "copy.h"

#include <regstr.h>
#include <comcat.h>
#include <intshcut.h>
#include "_security.h"

#include "ovrlaymn.h"

#include "filefldr.h"
#include "drives.h"
#include "netview.h"

#include <filetype.h>
#include "shitemid.h"

#include "infotip.h"
#include "recdocs.h"
#include <idhidden.h>
#include "datautil.h"
#include "deskfldr.h"
#include "prop.h"           // COLUMN_INFO

#include <oledb.h>          // IFilter stuff
#include <query.h>
#include <ntquery.h>
#include <filterr.h>
#include <ciintf.h>

#include "folder.h"
#include "ids.h"
#include "category.h"
#include "stgenum.h"
#include "clsobj.h"
#include "stgutil.h"
#include "sfstorage.h"
#include "mtpt.h"

#include "defcm.h"

STDAPI CFolderInfoTip_CreateInstance(IUnknown *punkOutter, LPCTSTR pszFolder, REFIID riid, void **ppv);

#define SHCF_IS_BROWSABLE           (SHCF_IS_SHELLEXT | SHCF_IS_DOCOBJECT)

#define CSIDL_NORMAL    ((UINT)-2)  // has to not be -1

// File-scope pointer to a ShellIconOverlayManager
// Callers access this pointer through GetIconOverlayManager().
static IShellIconOverlayManager * g_psiom = NULL;

// #define FULL_DEBUG

TCHAR const c_szCLSIDSlash[] = TEXT("CLSID\\");
TCHAR const c_szShellOpenCmd[] = TEXT("shell\\open\\command");

TCHAR g_szFolderTypeName[32] = TEXT("");    // "Folder" 
TCHAR g_szFileTypeName[32] = TEXT("");      // "File"
TCHAR g_szFileTemplate[32] = TEXT("");      // "ext File"

enum
{
    FS_ICOL_NAME = 0,
    FS_ICOL_SIZE,
    FS_ICOL_TYPE,
    FS_ICOL_WRITETIME,
    FS_ICOL_CREATETIME,
    FS_ICOL_ACCESSTIME,
    FS_ICOL_ATTRIB,
    FS_ICOL_CSC_STATUS,
};

const COLUMN_INFO c_fs_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,            30, IDS_NAME_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_SIZE,               IDS_SIZE_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,            20, IDS_TYPE_COL),
    DEFINE_COL_DATE_ENTRY(SCID_WRITETIME,          IDS_MODIFIED_COL),
    // these are off by default (don't have SHCOLSTATE_ONBYDEFAULT) set
    DEFINE_COL_ENTRY(SCID_CREATETIME, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE, IDS_EXCOL_CREATE),
    DEFINE_COL_ENTRY(SCID_ACCESSTIME, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_SECONDARYUI, IDS_EXCOL_ACCESSTIME),
    DEFINE_COL_ENTRY(SCID_ATTRIBUTES, VT_LPWSTR, LVCFMT_LEFT, 10, SHCOLSTATE_TYPE_STR, IDS_ATTRIB_COL),
    DEFINE_COL_STR_DLG_ENTRY(SCID_CSC_STATUS, 10, IDS_CSC_STATUS),
};

//
// List of file attribute bit values.  The order (with respect
// to meaning) must match that of the characters in g_szAttributeChars[].
//
const DWORD g_adwAttributeBits[] =
{
    FILE_ATTRIBUTE_READONLY,
    FILE_ATTRIBUTE_HIDDEN,
    FILE_ATTRIBUTE_SYSTEM,
    FILE_ATTRIBUTE_ARCHIVE,
    FILE_ATTRIBUTE_COMPRESSED,
    FILE_ATTRIBUTE_ENCRYPTED,
    FILE_ATTRIBUTE_OFFLINE
};

//
// Buffer for characters that represent attributes in Details View attributes
// column.  Must provide room for 1 character for each bit a NUL.  The current 5
// represent Read-only, Archive, Compressed, Hidden and System in that order.
// This can't be const because we overwrite it using LoadString.
//
TCHAR g_szAttributeChars[ARRAYSIZE(g_adwAttributeBits) + 1] = { 0 } ;

// order here is important, first one found will terminate the search
const int c_csidlSpecial[] = {
    CSIDL_STARTMENU | TEST_SUBFOLDER,
    CSIDL_COMMON_STARTMENU | TEST_SUBFOLDER,
    CSIDL_RECENT,
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_PERSONAL,
    CSIDL_FONTS
};

BOOL CFSFolder::_IsCSIDL(UINT csidl)
{
    BOOL bRet = (_csidl == csidl);
    if (!bRet)
    {
        TCHAR szPath[MAX_PATH];

        _GetPath(szPath);
        bRet = PathIsEqualOrSubFolder(MAKEINTRESOURCE(csidl), szPath);
        if (bRet)
            _csidl = csidl;
    }
    return bRet;
}

UINT CFSFolder::_GetCSIDL()
{
    // Cache the special folder ID, if it is not cached yet.
    if (_csidl == -1)
    {
        TCHAR szPath[MAX_PATH];

        _GetPath(szPath);

        // Always cache the real Csidl.
        _csidl = GetSpecialFolderID(szPath, c_csidlSpecial, ARRAYSIZE(c_csidlSpecial));         

        if (_csidl == -1)
        {
            _csidl = CSIDL_NORMAL;   // default
        }
    }

    return _csidl;
}

STDAPI_(LPCIDFOLDER) CFSFolder::_IsValidID(LPCITEMIDLIST pidl)
{

    if (pidl && pidl->mkid.cb && (((LPCIDFOLDER)pidl)->bFlags & SHID_GROUPMASK) == SHID_FS)
        return (LPCIDFOLDER)pidl;

    return NULL;
}

// folder.{guid} or file.{guid}
// system | readonly folder with desktop.ini and CLSID={guid} in the desktop.ini
// file.ext where ext corresponds to a shell extension (such as .cab/.zip)
// see _MarkAsJunction

inline BOOL CFSFolder::_IsJunction(LPCIDFOLDER pidf)
{
    return pidf->bFlags & SHID_JUNCTION;
}

inline BYTE CFSFolder::_GetType(LPCIDFOLDER pidf)
{ 
    return pidf->bFlags & SHID_FS_TYPEMASK; 
}

// this tests for old simple pidls that use SHID_FS
// typically this only happens with persisted pidls in upgrade scenarios (shortcuts in the start menu)
inline BOOL CFSFolder::_IsSimpleID(LPCIDFOLDER pidf)
{ 
    return _GetType(pidf) == SHID_FS; 
}

inline LPIDFOLDER CFSFolder::_FindLastID(LPCIDFOLDER pidf)
{
    return (LPIDFOLDER)ILFindLastID((LPITEMIDLIST)pidf); 
}

inline LPIDFOLDER CFSFolder::_Next(LPCIDFOLDER pidf)
{
    return (LPIDFOLDER)_ILNext((LPITEMIDLIST)pidf); 
}

// special marking for "All Users" items on the desktop (this is a hack to support the desktop
// folder delegating to the approprate shell folder and is not generally useful)

BOOL CFSFolder::_IsCommonItem(LPCITEMIDLIST pidl)
{
    if (pidl && pidl->mkid.cb && (((LPCIDFOLDER)pidl)->bFlags & (SHID_GROUPMASK | SHID_FS_COMMONITEM)) == SHID_FS_COMMONITEM)
        return TRUE;
    return FALSE;
}

// a win32 file (might be a shell extension .cab/.zip that behaves like a folder)
BOOL CFSFolder::_IsFile(LPCIDFOLDER pidf)
{
    BOOL bRet = _GetType(pidf) == SHID_FS_FILE || _GetType(pidf) == SHID_FS_FILEUNICODE;
    // if it's a file, it shouldn't be a folder.
    // if it's not a file, usually it's a folder -- except if the type is SHID_FS,
    // that's okay too because it's a simple pidl in a .lnk from a downlevel shell.
    ASSERT(bRet ? !_IsFolder(pidf) : (_IsFolder(pidf) || _IsSimpleID(pidf)));
    return bRet;
}

// it is a win32 file system folder (maybe a junction, maybe not)
BOOL CFSFolder::_IsFolder(LPCIDFOLDER pidf)
{
    BOOL bRet = _GetType(pidf) == SHID_FS_DIRECTORY || _GetType(pidf) == SHID_FS_DIRUNICODE;
    ASSERT(bRet ? (pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY) : !(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY));
    return bRet;
}

// is it a file system folder that is not a junction
BOOL CFSFolder::_IsFileFolder(LPCIDFOLDER pidf)
{
    return _IsFolder(pidf) && !_IsJunction(pidf);
}

// non junction, but has the system or readonly bit (regular folder marked special for us)
BOOL CFSFolder::_IsSystemFolder(LPCIDFOLDER pidf)
{
    return _IsFileFolder(pidf) && (pidf->wAttrs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
}

// this is a heuristic to determine if the IDList was created
// normally or with a simple bind context (null size/mod date)

BOOL CFSFolder::_IsReal(LPCIDFOLDER pidf)
{
    return pidf->dwSize || pidf->dateModified ? TRUE : FALSE;
}

DWORD CFSFolder::_GetUID(LPCIDFOLDER pidf)
{
    return pidf->dwSize + ((DWORD)pidf->dateModified << 8) + ((DWORD)pidf->timeModified << 12);
}

void CFSFolder::_GetSize(LPCITEMIDLIST pidlParent, LPCIDFOLDER pidf, ULONGLONG *pcbSize)
{
    ULONGLONG cbSize = pidf->dwSize;
    if (cbSize != 0xFFFFFFFF)
        *pcbSize = cbSize;
    else if (pidlParent == NULL)
        *pcbSize = 0;
    else
    {
        HANDLE hfind;
        WIN32_FIND_DATA wfd = {0};
        TCHAR szPath[MAX_PATH];

        // Get the real size by asking the file system
        SHGetPathFromIDList(pidlParent, szPath);
        _AppendItemToPath(szPath, pidf);

        if (SHFindFirstFileRetry(NULL, NULL, szPath, &wfd, &hfind, SHPPFW_NONE) != S_OK)
        {
            *pcbSize = 0;
        }
        else
        {
            FindClose(hfind);

            ULARGE_INTEGER uli;
            uli.LowPart = wfd.nFileSizeLow;
            uli.HighPart = wfd.nFileSizeHigh;

            *pcbSize = uli.QuadPart;
        }
    }
}

ULONGLONG CFSFolder::_Size(LPCIDFOLDER pidf)
{
    ULONGLONG cbSize;
    _GetSize(_pidl, pidf, &cbSize);
    return cbSize;
}

LPWSTR CFSFolder::_CopyName(LPCIDFOLDER pidf, LPWSTR pszName, UINT cchName)
{
    CFileSysItem fsi(pidf);
    return (LPWSTR) fsi.MayCopyFSName(TRUE, pszName, cchName);
}

BOOL CFSFolder::_ShowExtension(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    return fsi.ShowExtension(_DefaultShowExt());
}

BOOL CFSFolder::_DefaultShowExt()
{
    if (_tbDefShowExt == TRIBIT_UNDEFINED)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
        _tbDefShowExt = ss.fShowExtensions ? TRIBIT_TRUE : TRIBIT_FALSE;
    }
    return _tbDefShowExt == TRIBIT_TRUE;
}

BOOL CFileSysItemString::ShowExtension(BOOL fDefaultShowExt)
{
    DWORD dwFlags = ClassFlags(FALSE);

    if (dwFlags & SHCF_NEVER_SHOW_EXT)
        return FALSE;

    if (fDefaultShowExt)
        return TRUE;

    return dwFlags & (SHCF_ALWAYS_SHOW_EXT | SHCF_UNKNOWN);
}

//
// get the type name from the registry, if the name is blank make
// up a default.
//
//      directory       ==> "Folder"
//      foo             ==> "File"
//      foo.xyz         ==> "XYZ File"
//
void SHGetTypeName(LPCTSTR pszFile, HKEY hkey, BOOL fFolder, LPTSTR pszName, int cchNameMax)
{
    LONG cb = cchNameMax * sizeof(TCHAR);
    
    if (hkey == NULL || SHRegQueryValue(hkey, NULL, pszName, &cb) != ERROR_SUCCESS || pszName[0] == 0)
    {
        if (fFolder)
        {
            // NOTE the registry doesn't have a name for Folder
            // because old apps would think it was a file type.
            lstrcpy(pszName, g_szFolderTypeName);
        }
        else
        {
            LPTSTR pszExt = PathFindExtension(pszFile);

            ASSERT(pszExt);
            
            if (*pszExt == 0)
            {
                // Probably don't need the cchmax here, but...
                lstrcpyn(pszName, g_szFileTypeName, cchNameMax);
            }
            else
            {
                TCHAR szExt[_MAX_EXT];
                int cchMaxExtCopy = (int)min((cchNameMax - lstrlen(g_szFileTemplate)), ARRAYSIZE(szExt));

                // Compose '<ext> File' (or what ever the template defines we do)

                lstrcpyn(szExt, pszExt + 1, cchMaxExtCopy);
                CharUpperNoDBCS(szExt);
                wsprintf(pszName, g_szFileTemplate, szExt);
            }
        }
    }
}

//
// return a pointer to the type name for the given PIDL
// the pointer is only valid while in a critical section
//
LPCTSTR CFSFolder::_GetTypeName(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    
    ASSERTCRITICAL

    LPCTSTR pszClassName = LookupFileClassName(fsi.Class());
    if (pszClassName == NULL)
    {
        WCHAR sz[80];
        IQueryAssociations *pqa;
        HRESULT hr = fsi.AssocCreate(NULL, FALSE, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            DWORD cch = ARRAYSIZE(sz);
            hr = pqa->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, sz, &cch);
            if (SUCCEEDED(hr))
            {
                pszClassName = AddFileClassName(fsi.Class(), sz);
            }
            pqa->Release();
        }
    }

    return pszClassName;
}

//
// return the type name for the given PIDL
//
HRESULT CFSFolder::_GetTypeNameBuf(LPCIDFOLDER pidf, LPTSTR pszName, int cchNameMax)
{
    HRESULT hr = S_OK;
    
    ENTERCRITICAL;
    LPCTSTR pszSource = _GetTypeName(pidf);

    // pszSource will be NULL if the file does not have an extension.
    if (!pszSource)
    {
        pszSource = TEXT(""); // Terminate Buffer
        hr = E_FAIL;
    }

    StrCpyN(pszName, pszSource, cchNameMax);
    LEAVECRITICAL;
    
    return hr;
}

//
// Build a text string containing characters that represent attributes of a file.
// The attribute characters are assigned as follows:
// (R)eadonly, (H)idden, (S)ystem, (A)rchive, (H)idden.
//
void BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars)
{
    // Make sure we have attribute chars to build this string out of
    if (!g_szAttributeChars[0])
        LoadString(HINST_THISDLL, IDS_ATTRIB_CHARS, g_szAttributeChars, ARRAYSIZE(g_szAttributeChars));

    // Make sure buffer is big enough to hold worst-case attributes
    ASSERT(nChars >= ARRAYSIZE(g_adwAttributeBits) + 1);

    for (int i = 0; i < ARRAYSIZE(g_adwAttributeBits); i++)
    {
        if (dwAttributes & g_adwAttributeBits[i])
            *pszString++ = g_szAttributeChars[i];
    }
    *pszString = 0;     // null terminate

}

// BryanSt: This doesn't work with FRAGMENTs.  We should return the path
// without the Fragment for backward compatibility and then callers that care,
// can later determine that and take care of it.
//

// in/out:
//      pszPath path to append pidf names to
// in:
//      pidf        relative pidl fragment

HRESULT CFSFolder::_AppendItemToPath(LPTSTR pszPath, LPCIDFOLDER pidf)
{
    HRESULT hr = S_OK;
    LPTSTR pszPathCur = pszPath + lstrlen(pszPath);

    //  e want to do this, but we stil have broken code in SHGetPathFromIDList
    // ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra goo please

    for (; SUCCEEDED(hr) && !ILIsEmpty((LPITEMIDLIST)pidf); pidf = _Next(pidf))
    {
        CFileSysItemString fsi(pidf);
        int cchName = lstrlen(fsi.FSName());    // store the length of szName, to avoid calculating it twice

        // mil 142338: handle bogus pidls that have multiple "C:"s in them
        // due to bad shortcut creation.
        if ((cchName == 2) && (fsi.FSName()[1] == TEXT(':')))
        {
            pszPathCur = pszPath;
        }
        else
        {
            // ASSERT(lstrlen(pszPath)+lstrlen(szName)+2 <= MAX_PATH);
            if (((pszPathCur - pszPath) + cchName + 2) > MAX_PATH)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW); // FormatMessage = "The file name is too long"
                break;
            }

            LPTSTR pszTmp = CharPrev(pszPath, pszPathCur);
            if (*pszTmp != TEXT('\\'))
                *(pszPathCur++) = TEXT('\\');
        }

        // don't need lstrncpy cause we verified size above
        lstrcpy(pszPathCur, fsi.FSName());

        pszPathCur += cchName;
    }

    if (FAILED(hr))
        *pszPath = 0;

    return hr;
}

// get the file system folder path for this
//
// HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) is returned if we are a tracking
// folder that does not (yet) have a valid target.
HRESULT CFSFolder::_GetPath(LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    if (_csidlTrack >= 0)
    {
        hr =  SHGetFolderPath(NULL, _csidlTrack | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, pszPath);
        if (hr == S_FALSE || FAILED(hr))
            hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    }
    else if (_pszPath)
    {
        lstrcpyn(pszPath, _pszPath, MAX_PATH);
        hr = S_OK;
    }
    else
    {
        if (_pidlTarget &&  
                SUCCEEDED(SHGetNameAndFlags(_pidlTarget, SHGDN_FORPARSING, pszPath, MAX_PATH, NULL)))
        {
            _pszPath = StrDup(pszPath);
            hr = S_OK;
        }
        else if (SUCCEEDED(SHGetNameAndFlags(_pidl, SHGDN_FORPARSING, pszPath, MAX_PATH, NULL)))
        {
            _pszPath = StrDup(pszPath);
            hr = S_OK;
        }
    }

    if (hr==S_OK && !(*pszPath))
        hr= E_FAIL; // old behavior was to fail if pszPath was empty
    return hr;
}

// Will fail (return FALSE) if not a mount point
BOOL CFSFolder::_GetMountingPointInfo(LPCIDFOLDER pidf, LPTSTR pszMountPoint, DWORD cchMountPoint)
{
    BOOL bRet = FALSE;
    // Is this a reparse point?
    if (FILE_ATTRIBUTE_REPARSE_POINT & pidf->wAttrs)
    {
        TCHAR szLocalMountPoint[MAX_PATH];

        if (SUCCEEDED(_GetPathForItem(pidf, szLocalMountPoint)))
        {
            int iDrive = PathGetDriveNumber(szLocalMountPoint);
            if (-1 != iDrive)
            {
                TCHAR szDrive[4];
                if (DRIVE_REMOTE != GetDriveType(PathBuildRoot(szDrive, iDrive)))
                {
                    TCHAR szVolumeName[50]; //50 according to doc
                    PathAddBackslash(szLocalMountPoint);

                    // Check if it is a mounting point
                    if (GetVolumeNameForVolumeMountPoint(szLocalMountPoint, szVolumeName,
                        ARRAYSIZE(szVolumeName)))
                    {
                        bRet = TRUE;

                        if (pszMountPoint && cchMountPoint)
                            lstrcpyn(pszMountPoint, szLocalMountPoint, cchMountPoint);
                    }
                }
            }
        }
    }
    return bRet;
}

// in:
//      pidf    may be NULL, or multi level item to append to path for this folder
// out:
//      pszPath MAX_PATH buffer to receive the fully qualified file path for the item
//

HRESULT CFSFolder::_GetPathForItem(LPCIDFOLDER pidf, LPWSTR pszPath)
{
    if (SUCCEEDED(_GetPath(pszPath)))
    {
        if (pidf)
        {
            return _AppendItemToPath(pszPath, pidf);
        }
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CFSFolder::_GetPathForItems(LPCIDFOLDER pidfParent, LPCIDFOLDER pidfLast, LPTSTR pszPath)
{
    HRESULT hr = _GetPathForItem(pidfParent ? pidfParent : pidfLast, pszPath);
    if (SUCCEEDED(hr) && pidfParent)
        hr = _AppendItemToPath(pszPath, pidfLast);

    return hr;
}

BOOL _GetIniPath(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszPath)
{
    BOOL fExists = FALSE;
    
    PathCombine(pszPath, pszFolder, c_szDesktopIni);

    // CHECK for PathFileExists BEFORE calling to GetPrivateProfileString
    // because if the file isn't there (which is the majority of cases)
    // GetPrivateProfileString hits the disk twice looking for the file

    if (pszProvider && *pszProvider)
    {
        union {
            NETRESOURCE nr;
            TCHAR buf[512];
        } nrb;
        LPTSTR lpSystem;
        DWORD dwRes, dwSize = sizeof(nrb);

        nrb.nr.dwType = RESOURCETYPE_ANY;
        nrb.nr.lpRemoteName = pszPath;
        nrb.nr.lpProvider = (LPTSTR)pszProvider;    // const -> non const
        dwRes = WNetGetResourceInformation(&nrb.nr, &nrb, &dwSize, &lpSystem);

        fExists = (dwRes == WN_SUCCESS) || (dwRes == WN_MORE_DATA);
    }
    else
    {
        fExists = PathFileExists(pszPath);
    }

    if (fCreate && !fExists)
    {
        //  we need to touch this file first
        HANDLE h = CreateFile(pszPath, 0, FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (INVALID_HANDLE_VALUE != h)
        {
            PathMakeSystemFolder(pszFolder);
            fExists = TRUE;
            CloseHandle(h);
        }
    }

    return fExists;
}

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData)
{
    TCHAR szPath[MAX_PATH];
    if (_GetIniPath(fCreate, pszFolder, pszProvider, szPath))
    {
        return SHSetIniStringUTF7(pszSection, pszKey, pszData, szPath);
    }
    return FALSE;
}

//
// This function retrieves the private profile strings from the desktop.ini file and
// return it through pszOut
//
// This function uses SHGetIniStringUTF7 to get the string, so it is valid
// to use SZ_CANBEUNICODE on the key name.

BOOL GetFolderStringEx(LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPTSTR pszOut, int cch)
{
    BOOL fRet = FALSE;
    TCHAR szPath[MAX_PATH];

    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        TCHAR szTemp[INFOTIPSIZE];
        fRet = SHGetIniStringUTF7(pszSection, pszKey, szTemp, ARRAYSIZE(szTemp), szPath);
        if (fRet)
        {
            SHExpandEnvironmentStrings(szTemp, pszOut, cch);   // This could be a path, so expand the env vars in it
        }
    }
    return fRet;
}

int GetFolderInt(LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, int iDefault)
{
    BOOL fRet = FALSE;
    TCHAR szPath[MAX_PATH];

    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        return GetPrivateProfileInt(pszSection, pszKey, iDefault, szPath);
    }
    return iDefault;
}
    
STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszOut, int cch, LPCTSTR pszKey)
{
    return GetFolderStringEx(pszFolder, pszProvider, STRINI_CLASSINFO, pszKey, pszOut, cch);
}

// This function retrieves the specifice GUID from desktop.ini file.
// replace this with property bag access on the folder
STDAPI_(BOOL) GetFolderGUID(LPCTSTR pszFolder, LPCTSTR pszProvider, CLSID* pclsid, LPCTSTR pszKey)
{
    TCHAR szCLSID[40];
    if (GetFolderString(pszFolder, pszProvider, szCLSID, ARRAYSIZE(szCLSID), pszKey))
    {
        return SUCCEEDED(SHCLSIDFromString(szCLSID, pclsid));
    }
    return FALSE;
}

//
// This function retrieves the correct CLSID from desktop.ini file.
//
BOOL _GetFolderCLSID(LPCTSTR pszFolder, LPCTSTR pszProvider, CLSID* pclsid)
{
    BOOL bFound = FALSE;
    WCHAR szPath[MAX_PATH];
    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        DWORD dwChars;
        WCHAR szSectionValue[1024];
        dwChars = GetPrivateProfileSection(STRINI_CLASSINFO, szSectionValue, sizeof(szSectionValue), szPath);
        if (dwChars != (sizeof(szSectionValue) - 2) && (dwChars != 0))
        {
            static WCHAR *const c_rgpsz[] = {TEXT("CLSID2"),
                                             TEXT("CLSID"),
                                             TEXT("UICLSID")};
            int iFoundIndex = ARRAYSIZE(c_rgpsz);
            // We look for CLSID2, CLSID, then UICLSID, since there could be multiple kes in this section.
            // CLSID2 makes folders work on Win95 if the CLSID does not exist on the machine
            for (WCHAR *pNextKeyPointer = szSectionValue; *pNextKeyPointer; pNextKeyPointer += lstrlen(pNextKeyPointer) + 1)
            {
                PWCHAR pBuffer = pNextKeyPointer;
                PWCHAR pEqual  = StrChrW(pBuffer, L'=');
                if (pEqual && (*(pEqual+1) != L'\0'))
                {
                    *pEqual = L'\0';
                    for (int i = 0; i < ARRAYSIZE(c_rgpsz); i++)
                    {
                        if (StrCmpIC(c_rgpsz[i], pBuffer) == 0)
                        {
                            CLSID clsid;
                            if ((iFoundIndex < i) && bFound)
                            {
                                break;
                            }
                            pBuffer += lstrlen(pBuffer) + 1;
                            if (SUCCEEDED(SHCLSIDFromString(pBuffer, &clsid)))
                            {
                                if (i == ARRAYSIZE(c_rgpsz) - 1)
                                {
                                    // hack for "Temporary Internet Files"
                                    if (clsid == CLSID_CacheFolder)
                                    {
                                        *pclsid = CLSID_CacheFolder2;
                                        bFound = TRUE;
                                    }
                                }
                                else
                                {
                                    *pclsid = clsid;
                                    bFound = TRUE;
                                }
                                iFoundIndex = i;
                            }
                            break;
                        }
                    } // end of for
                } // end of if
            } //end of for
        }
    }

    return bFound;

}

LPTSTR PathFindCLSIDExtension(LPCTSTR pszFile, CLSID *pclsid)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);

    ASSERT(pszExt);

    if (*pszExt == TEXT('.') && *(pszExt + 1) == TEXT('{') /* '}' */)
    {
        CLSID clsid;

        if (pclsid == NULL)
            pclsid = &clsid;

        if (SUCCEEDED(SHCLSIDFromString(pszExt + 1, pclsid)))
            return (LPTSTR)pszExt;      // const -> non const
    }
    return NULL;
}

//
// This function retrieves the CLSID from a filename
// file.{GUID}
//
BOOL _GetFileCLSID(LPCTSTR pszFile, CLSID* pclsid)
{
    return PathFindCLSIDExtension(pszFile, pclsid) != NULL;
}

// test pidf for properties that make make it a junction, mark it as a junction
// as needed, see _IsJunction usage

BOOL _ClsidExists(REFGUID clsid)
{
    HKEY hk;
    if (SUCCEEDED(SHRegGetCLSIDKey(clsid, NULL, FALSE, FALSE, &hk)))
    {
        RegCloseKey(hk);
        return TRUE;
    }
    return FALSE;
}

LPIDFOLDER CFSFolder::_MarkAsJunction(LPCIDFOLDER pidfSimpleParent, LPIDFOLDER pidf, LPCTSTR pszName)
{
    CLSID clsid;
    BOOL fJunction = FALSE;
    // check for a junction point, junctions are either
    // Folder.{guid} or File.{guid} both fall into this case
    if (_GetFileCLSID(pszName, &clsid))
    {
        fJunction = TRUE;
    }
    else if (_IsSystemFolder(pidf))
    {
        // system (read only or system bit) look for the desktop.ini in a folder
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(_GetPathForItems(pidfSimpleParent, pidf, szPath)))
        {
            // CLSID2 makes folders work on Win95 if the CLSID does not exist on the machine
            if (_GetFolderCLSID(szPath, _pszNetProvider, &clsid))
            {
                fJunction = TRUE;
            }
        }
    }

    if (fJunction && _ClsidExists(clsid))
    {
        pidf->bFlags |= SHID_JUNCTION;
        pidf = (LPIDFOLDER) ILAppendHiddenClsid((LPITEMIDLIST)pidf, IDLHID_JUNCTION, &clsid);
    }

    return pidf;
}

BOOL CFSFolder::_GetJunctionClsid(LPCIDFOLDER pidf, CLSID *pclsid)
{
    CFileSysItemString fsi(pidf);
    return fsi.GetJunctionClsid(pclsid, TRUE);
}
    
BOOL CFileSysItemString::GetJunctionClsid(CLSID *pclsid, BOOL fShellExtOk)
{
    BOOL bRet = FALSE;
    *pclsid = CLSID_NULL;

    if (CFSFolder::_IsJunction(_pidf))
    {
        // if this is a junction point that was created with a hidden CLSID
        // then it should be stored with IDLHID_JUNCTION
        if (ILGetHiddenClsid((LPCITEMIDLIST)_pidf, IDLHID_JUNCTION, pclsid))
            bRet = TRUE;
        else
        {
            // it might be an oldstyle JUNCTION point that was persisted out or a ROOT_REGITEM
            if (SIL_GetType((LPITEMIDLIST)_pidf) == SHID_ROOT_REGITEM)
            {
                const UNALIGNED CLSID *pc = (UNALIGNED CLSID *)(((BYTE *)_pidf) + _pidf->cb - sizeof(CLSID));
                *pclsid = *pc;
                bRet = TRUE;
            }
        }
    }
    else if (fShellExtOk)
    {
        if (ClassFlags(FALSE) & SHCF_IS_SHELLEXT)
        {
            IAssociationArray *paa;
            //  must pass NULL for CFSFolder to avoid recursion
            if (SUCCEEDED(AssocCreate(NULL, FALSE, IID_PPV_ARG(IAssociationArray, &paa))))
            {
                CSmartCoTaskMem<WCHAR> spsz;
                if (SUCCEEDED(paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_CLSID, NULL, &spsz)))
                {
                    bRet = GUIDFromString(spsz, pclsid);
                }
                paa->Release();
            }
        }
    }
    else if (CFSFolder::_IsFolder(_pidf))
    {
        //  directory.{guid} is always of Class() {guid}
        bRet = _GetFileCLSID(FSName(), pclsid);
    }
        
    return bRet;
}

//
//  returns a unique name for a class, dont use this function to get
//  the ProgID for a class call SHGetClassKey() for that
//
// Returns: class name in pszClass
//
//  foo.ext             ".ext"
//  foo                 "."
//  (empty)             "Folder"
//  directory           "Directory"
//  junction            "CLSID\{clsid}"
//

BOOL CFSFolder::_GetClass(LPCIDFOLDER pidf, LPTSTR pszClass, UINT cch)
{
    CFileSysItemString fsi(pidf);
    StrCpyN(pszClass, fsi.Class(), cch);
    return TRUE;
}

LPCWSTR CFileSysItemString::_Class()
{
    if (_pidf->cb == 0)      // ILIsEmpty()
    {
        // the desktop. Always use the "Folder" class.
        _pszClass = c_szFolderClass;
    }
    //  else if (ILGetHiddenString(IDLHID_TREATASCLASS))
    else
    {
        CLSID clsid;
        if (GetJunctionClsid(&clsid, FALSE))
        {
            // This is a junction point, get the CLSID from it.
            CSmartCoTaskMem<OLECHAR> spsz;
            if (SUCCEEDED(ProgIDFromCLSID(clsid, &spsz)))
            {
                StrCpyN(_sz, spsz, ARRAYSIZE(_sz));
            }
            else
                SHStringFromGUID(clsid, _sz , ARRAYSIZE(_sz));
            _fsin = FSINAME_CLASS;
        }
        else if (CFSFolder::_IsFolder(_pidf))
        {
            // This is a directory. Always use the "Directory" class.
            // This can also be a Drive id.
            _pszClass = TEXT("Directory");
        }
        else
        {
            // This is a file. Get the class based on the extension.
            LPCWSTR pszFile = FSName();
            LPCWSTR pszExt = PathFindExtension(pszFile);
            ASSERT(pszExt);
            ASSERT(!(_pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY));
            if (*pszExt == 0)
            {
                if (_pidf->wAttrs & FILE_ATTRIBUTE_SYSTEM)
                    _pszClass = TEXT(".sys");
                else
                    _pszClass = TEXT(".");
            }
            else if (pszFile == _sz)
            {
                //  we need the buffer to be setup correctly
                MoveMemory(_sz, pszExt, CbFromCchW(lstrlen(pszExt) + 1));
                _fsin = FSINAME_CLASS;
            }
            else
                _pszClass = pszExt;
        }
    }
    ASSERT(_pszClass || *_sz);
    return _pszClass ? _pszClass : _sz;
}

LPCWSTR CFileSysItemString::Class()
{
    if (!_pszClass)
    {
        if (!(_fsin & FSINAME_CLASS))
        {
            return _Class();
        }
        else
        {
            return _sz;
        }
    }
    return _pszClass;
}

CFSAssocEnumData::CFSAssocEnumData(BOOL fIsUnknown, CFSFolder *pfs, LPCIDFOLDER pidf) : _fIsUnknown(fIsUnknown)
{
    _fIsSystemFolder = pfs->_IsSystemFolder(pidf);
    pfs->_GetPathForItem(pidf, _szPath);
    if (_fIsUnknown)
        _fIsUnknown = !(FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs);
    else
    {
        if (CFSFolder::_IsFileFolder(pidf))
            _pidl = ILCombine(pfs->_GetIDList(), (LPCITEMIDLIST)pidf);
    }
}

LPCWSTR _GetDirectoryClass(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder);

BOOL CFSAssocEnumData::_Next(IAssociationElement **ppae)
{
    HRESULT hr = E_FAIL;
    if (_fIsUnknown)
    {
        CLSID clsid;
        hr = GetClassFile(_szPath, &clsid);
        if (SUCCEEDED(hr))
        {
            CSmartCoTaskMem<OLECHAR> spszProgid;
            hr = ProgIDFromCLSID(clsid, &spszProgid);
            if (SUCCEEDED(hr))
            {
                hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, spszProgid, ppae);
            }

            if (FAILED(hr))
            {
                WCHAR sz[GUIDSTR_MAX];
                SHStringFromGUIDW(clsid, sz, ARRAYSIZE(sz));
                hr = AssocElemCreateForClass(&CLSID_AssocClsidElement, sz, ppae);
            }
        }
       
        if (FAILED(hr))
        {
            hr = AssocElemCreateForClass(&CLSID_AssocShellElement, L"Unknown", ppae);
        }

        _fIsUnknown = FALSE;
    }

    if (FAILED(hr) && _pidl)
    {
        PCWSTR psz = _GetDirectoryClass(_szPath, _pidl, _fIsSystemFolder);
        if (psz)
            hr = AssocElemCreateForClass(&CLSID_AssocSystemElement, psz, ppae);
        ILFree(_pidl);
        _pidl = NULL;
    }
    
    return SUCCEEDED(hr);
}


class CFSAssocEnumExtra : public CEnumAssociationElements
{
public:

protected:
    BOOL _Next(IAssociationElement **ppae);

protected:
};

BOOL CFSAssocEnumExtra::_Next(IAssociationElement **ppae)
{
    if (_cNext == 0)
    {
        // corel wp suite 7 relies on the fact that send to menu is hard coded
        // not an extension so do not insert it (and the similar items)
        if (!(SHGetAppCompatFlags(ACF_CONTEXTMENU) & ACF_CONTEXTMENU))
        {
            AssocElemCreateForClass(&CLSID_AssocShellElement, L"AllFilesystemObjects", ppae);
        }
    }

    return *ppae != NULL;
}

HRESULT CFileSysItemString::AssocCreate(CFSFolder *pfs, BOOL fForCtxMenu, REFIID riid, void **ppv)
{
    //  WARNING - the pfs keeps us from recursing.
    *ppv = NULL;
    IAssociationArrayInitialize *paai;
    HRESULT hr = ::AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paai));
    if (SUCCEEDED(hr))
    {
        //  the base class for directory's is always Folder
        ASSOCELEM_MASK base;
        if (CFSFolder::_IsFolder(_pidf))
            base = ASSOCELEM_BASEIS_FOLDER;
        else
        {
            //  for files it is always *
            base = ASSOCELEM_BASEIS_STAR;
            if (pfs)
            {
                CLSID clsid;
                if (GetJunctionClsid(&clsid, TRUE))
                {
                    //  but if this file is also a folder (like .zip and .cab)
                    //  then we should also use Folder
                    if (SHGetAttributesFromCLSID2(&clsid, 0, SFGAO_FOLDER) & SFGAO_FOLDER)
                        base |= ASSOCELEM_BASEIS_FOLDER;
                }
            }
        }
        
        hr = paai->InitClassElements(base, Class());
        if (SUCCEEDED(hr) && pfs)
        {
            BOOL fIsLink = fForCtxMenu && (_ClassFlags(paai, FALSE) & SHCF_IS_LINK);
            if (fIsLink)
            {
                //  we dont like to do everything for LINK, but 
                //  maybe we should be adding BASEIS_STAR?
                paai->FilterElements(ASSOCELEM_DEFAULT | ASSOCELEM_EXTRA);
            }

            IEnumAssociationElements *penum = new CFSAssocEnumExtra();
            if (penum)
            {
                paai->InsertElements(ASSOCELEM_EXTRA, penum);
                penum->Release();
            }

            if (!fIsLink)
            {
                penum = new CFSAssocEnumData(hr == S_FALSE, pfs, _pidf);
                if (penum)
                {
                    paai->InsertElements(ASSOCELEM_DATA | ASSOCELEMF_INCLUDE_SLOW, penum);
                    penum->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = paai->QueryInterface(riid, ppv);
        paai->Release();
    }

    return hr;
}

HRESULT CFSFolder::_AssocCreate(LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    CFileSysItemString fsi(pidf);
    return fsi.AssocCreate(this, FALSE, riid, ppv);
}

//
//  Description: This simulates the ComponentCategoryManager
//  call which checks to see if a CLSID is a member of a CATID.
//
STDAPI_(BOOL) IsMemberOfCategory(IAssociationArray *paa, REFCATID rcatid)
{
    BOOL fRet = FALSE;
    CSmartCoTaskMem<WCHAR> spsz;
    if (SUCCEEDED(paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_CLSID, NULL, &spsz)))
    {
        TCHAR szKey[GUIDSTR_MAX * 4], szCATID[GUIDSTR_MAX];
        // Construct the registry key that detects if
        // a CLSID is a member of a CATID.
        SHStringFromGUID(rcatid, szCATID, ARRAYSIZE(szCATID));
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\Implemented Categories\\%s"), spsz, szCATID);

        // See if it's there.
        fRet = SHRegQueryValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL) == ERROR_SUCCESS;
    }

    return fRet;
}


// get flags for a file class.
//
// given a FS PIDL returns a DWORD of flags, or 0 for error
//
//      SHCF_ICON_INDEX         this is this sys image index for per class
//      SHCF_ICON_PERINSTANCE   icons are per instance (one per file)
//      SHCF_ICON_DOCICON       icon is in shell\open\command (simulate doc icon)
//
//      SHCF_HAS_ICONHANDLER    set if class has a IExtractIcon handler
//
//      SHCF_UNKNOWN            set if extenstion is not registered
//
//      SHCF_IS_LINK            set if class is a link
//      SHCF_ALWAYS_SHOW_EXT    always show the extension
//      SHCF_NEVER_SHOW_EXT     never show the extension
//

DWORD CFSFolder::_GetClassFlags(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    return fsi.ClassFlags(FALSE);
}

void CFileSysItemString::_QueryIconIndex(IAssociationArray *paa)
{
    // check for the default icon under HKCU for this file extension.
    //  null out the icon index
    _dwClass &= ~SHCF_ICON_INDEX;
    PWSTR pszIcon;
    HRESULT hr = E_FAIL;
    if (paa)
    {
        // check for icon in ProgID
        // Then, check if the default icon is specified in OLE-style.
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_DEFAULTICON, NULL, &pszIcon);
        if (SUCCEEDED(hr))
        {
            //  hijack these icons
            //  office XP has really ugly icons for images
            //  and ours are so beautiful...office wont mind
            static const struct 
            { 
                PCWSTR pszUgly; 
                PCWSTR pszPretty; 
            } s_hijack[] = 
            {
                { L"PEicons.exe,1",     L"shimgvw.dll,2" }, // PNG
                { L"PEicons.exe,4",     L"shimgvw.dll,2" }, // GIF
                { L"PEicons.exe,5",     L"shimgvw.dll,3" }, // JPEG
                { L"MSPVIEW.EXE,1",     L"shimgvw.dll,4" }, // TIF
                { L"wordicon.exe,8",    L"moricons.dll,-109"},  
                { L"xlicons.exe,13",    L"moricons.dll,-110"},  
                { L"accicons.exe,57",   L"moricons.dll,-111"},  
                { L"pptico.exe,6",      L"moricons.dll,-112"},  
                { L"fpicon.exe,2",      L"moricons.dll,-113"},  
            };
            PCWSTR pszName = PathFindFileName(pszIcon);
            for (int i = 0; i < ARRAYSIZE(s_hijack); i++)
            {
                if (0 == StrCmpIW(pszName, s_hijack[i].pszUgly))
                {
                    //  replace this ugly chicken
                    CoTaskMemFree(pszIcon);
                    hr = SHStrDupW(s_hijack[i].pszPretty, &pszIcon);
                    break;
                }
            }
        }
        else if (!CFSFolder::_IsFolder(_pidf))
        {
            hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQVS_APPLICATION_PATH, NULL, &pszIcon);
            if (SUCCEEDED(hr))
                _dwClass |= SHCF_ICON_DOCICON;
        }
    }

    // Check if this is a per-instance icon

    if (SUCCEEDED(hr) && (lstrcmp(pszIcon, TEXT("%1")) == 0 ||
        lstrcmp(pszIcon, TEXT("\"%1\"")) == 0))
    {
        _dwClass &= ~SHCF_ICON_DOCICON;
        _dwClass |= SHCF_ICON_PERINSTANCE;
    }
    else 
    {
        int iIcon, iImage;
        if (SUCCEEDED(hr))
        {
            iIcon = PathParseIconLocation(pszIcon);
            iImage = Shell_GetCachedImageIndex(pszIcon, iIcon, _dwClass & SHCF_ICON_DOCICON ? GIL_SIMULATEDOC : 0);

            if (iImage == -1)
            {
                iIcon = _dwClass & SHCF_ICON_DOCICON ? II_DOCUMENT : II_DOCNOASSOC;
                iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
            }
        }
        else
        {
            iIcon = CFSFolder::_IsFolder(_pidf) ? II_FOLDER : II_DOCNOASSOC;
            iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
            _dwClass |= SHCF_ICON_DOCICON;   // make _dwClass non-zero
        }

        // Shell_GetCachedImageIndex can return -1 for failure cases. We
        // dont want to or -1 in, so check to make sure the index is valid.
        if ((iImage & ~SHCF_ICON_INDEX) == 0)
        {
            // no higher bits set so its ok to or the index in
            _dwClass |= iImage;
        }
    }

    if (SUCCEEDED(hr))
        CoTaskMemFree(pszIcon);
}    

#define ASSOCELEM_GETBITS   (ASSOCELEM_USER | ASSOCELEM_DEFAULT | ASSOCELEM_SYSTEM)
BOOL _IsKnown(IAssociationArray *paa)
{
    BOOL fRet = FALSE;
    CComPtr<IEnumAssociationElements> spenum;
    if (paa && SUCCEEDED(paa->EnumElements(ASSOCELEM_GETBITS, &spenum)))
    {
        CComPtr<IAssociationElement> spae;
        ULONG c;
        fRet = S_OK == spenum->Next(1, &spae, &c);
    }
    return fRet;
}

void CFileSysItemString::_QueryClassFlags(IAssociationArray *paa)
{
    // always hide extension for .{guid} junction points:
    // unless ShowSuperHidden() is on.  since this means the user wants to see system stuff
    if (!ShowSuperHidden() && _GetFileCLSID(FSName(), NULL))
        _dwClass = SHCF_NEVER_SHOW_EXT;
    else if (CFSFolder::_IsFolder(_pidf))
        _dwClass = SHCF_ALWAYS_SHOW_EXT;
    else
        _dwClass = 0;

    if (_IsKnown(paa))
    {
        // see what handlers exist
        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQNS_SHELLEX_HANDLER, TEXT("IconHandler"))))
            _dwClass |= SHCF_HAS_ICONHANDLER;

        // check for browsability
        if (!(SHGetAppCompatFlags(ACF_DOCOBJECT) & ACF_DOCOBJECT))
        {
            if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("DocObject")))
            || SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("BrowseInPlace"))))
                _dwClass |= SHCF_IS_DOCOBJECT;
        }   
        
        if (IsMemberOfCategory(paa, CATID_BrowsableShellExt))
            _dwClass |= SHCF_IS_SHELLEXT;

        //  get attributes
        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("IsShortcut"))))
            _dwClass |= SHCF_IS_LINK;

        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("AlwaysShowExt"))))
            _dwClass |= SHCF_ALWAYS_SHOW_EXT;

        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("NeverShowExt"))))
            _dwClass |= SHCF_NEVER_SHOW_EXT;

        // figure out what type of icon this type of file uses.
        if (_dwClass & SHCF_HAS_ICONHANDLER)
        {
            _dwClass |= SHCF_ICON_PERINSTANCE;
        }
    }
    else
    {
        // unknown type - pick defaults and get out.
        _dwClass |= SHCF_UNKNOWN | SHCF_ALWAYS_SHOW_EXT;
    }
}

CFSFolder * GetFSFolderFromShellFolder(IShellFolder *psf)
{
    CFSFolder *pfs = NULL;
    if (psf)
        psf->QueryInterface(IID_INeedRealCFSFolder, (void **)&pfs);
    return pfs;
}

PERCEIVED GetPerceivedType(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    PERCEIVED gen = GEN_UNKNOWN;
    CFSFolder *pfsf = GetFSFolderFromShellFolder(psf);
    if (pfsf)
    {
        LPCIDFOLDER pidf = CFSFolder_IsValidID(pidl);
        if (pidf)
        {
            CFileSysItemString fsi(pidf);
            gen = fsi.PerceivedType();
        }
    }
    return gen;
}

const struct {
    PERCEIVED gen;
    LPCWSTR psz;
} c_rgPerceivedTypes[] = {
    {GEN_TEXT, L"text"},
    {GEN_IMAGE, L"image"},
    {GEN_AUDIO,  L"audio"},
    {GEN_VIDEO,  L"video"},
    {GEN_COMPRESSED, L"compressed"},
};

PERCEIVED CFileSysItemString::PerceivedType()
{
    // look up the file type in the cache.
    PERCEIVED gen = LookupFilePerceivedType(Class());
    if (gen == GEN_UNKNOWN)
    {
        WCHAR sz[40];
        DWORD cb = sizeof(sz);
        if (NOERROR == SHGetValueW(HKEY_CLASSES_ROOT, Class(), L"PerceivedType", NULL, sz, &cb))
        {
            gen = GEN_CUSTOM;
            for (int i = 0; i < ARRAYSIZE(c_rgPerceivedTypes); i++)
            {
                if (0 == StrCmpC(c_rgPerceivedTypes[i].psz, sz))
                {
                    gen = c_rgPerceivedTypes[i].gen;
                    break;
                }
            }
        }
        else if (CFSFolder::_IsFolder(_pidf))
        {
            gen = GEN_FOLDER;
        }
        else
        {
            gen = GEN_UNSPECIFIED;
        }

        AddFilePerceivedType(Class(), gen);
    }
    return gen;
}

BOOL _IsImageExt(PCWSTR psz);
 
BOOL CFileSysItemString::IsShimgvwImage()
{
    return _IsImageExt(Class());
}

DWORD CFileSysItemString::_ClassFlags(IUnknown *punkAssoc, BOOL fNeedsIconBits)
{
    // look up the file type in the cache.
    if (!_dwClass)
        _dwClass = LookupFileClass(Class());
    if (_dwClass)
    {
        if (!fNeedsIconBits || (_dwClass & SHCF_ICON_INDEX) != SHCF_ICON_INDEX)
            return _dwClass;    
    }

    IAssociationArray *paa;
    HRESULT hr;
    if (punkAssoc)
        hr = punkAssoc->QueryInterface(IID_PPV_ARG(IAssociationArray, &paa));
    else
        hr = AssocCreate(NULL, FALSE, IID_PPV_ARG(IAssociationArray, &paa));

    if (!_dwClass)
        _QueryClassFlags(paa);

    if (fNeedsIconBits && !(_dwClass & SHCF_ICON_PERINSTANCE))
        _QueryIconIndex(paa);
    else
    {
        //  set it to be not init'd
        _dwClass |= SHCF_ICON_INDEX;
    }

    if (SUCCEEDED(hr))
    {
        paa->Release();

        if (0 == _dwClass)
        {
            // If we hit this, the extension for this file type is incorrectly installed
            // and it will cause double clicking on such files to open the "Open With..."
            // file associatins dialog.
            //
            // IF YOU HIT THIS:
            // 1. Find the file type by checking szClass.
            // 2. Contact the person that installed that file type and have them fix
            //    the install to have an icon and an associated program.
            TraceMsg(TF_WARNING, "_GetClassFlags() has detected an improperly registered class: '%s'", Class());
        }
        
    }

    AddFileClass(Class(), _dwClass);

    return _dwClass;
}

//
// this function checks for flags in desktop.ini
//

#define GFF_DEFAULT_TO_FS          0x0001      // the shell-xtension permits FS as the default where it cannot load
#define GFF_ICON_FOR_ALL_FOLDERS   0x0002      // use the icon specified in the desktop.ini for all sub folders

BOOL CFSFolder::_GetFolderFlags(LPCIDFOLDER pidf, UINT *prgfFlags)
{
    TCHAR szPath[MAX_PATH];

    *prgfFlags = 0;

    if (FAILED(_GetPathForItem(pidf, szPath)))
        return FALSE;

    if (PathAppend(szPath, c_szDesktopIni))
    {
        if (GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("DefaultToFS"), 1, szPath))
        {
            *prgfFlags |= GFF_DEFAULT_TO_FS;
        }
#if 0
        if (GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("SubFoldersUseIcon"), 1, szPath))
        {
            *prgfFlags |= GFF_ICON_FOR_ALL_FOLDERS;
        }
#endif
    }
    return TRUE;
}

//
// This funtion retrieves the ICONPATh from desktop.ini file.
// It takes a pidl as an input.
// NOTE: There is code in SHDOCVW--ReadIconLocation that does almost the same thing
// only that code looks in .URL files instead of desktop.ini
BOOL CFSFolder::_GetFolderIconPath(LPCIDFOLDER pidf, LPTSTR pszIcon, int cchMax, UINT *pIndex)
{
    TCHAR szPath[MAX_PATH], szIcon[MAX_PATH];
    BOOL fSuccess = FALSE;
    UINT iIndex;

    if (pszIcon == NULL)
    {
        pszIcon = szIcon;
        cchMax = ARRAYSIZE(szPath);
    }

    if (pIndex == NULL)
        pIndex = &iIndex;

    *pIndex = _GetDefaultFolderIcon();    // Default the index to II_FOLDER (default folder icon)

    if (SUCCEEDED(_GetPathForItem(pidf, szPath)))
    {
        if (GetFolderString(szPath, _pszNetProvider, pszIcon, cchMax, SZ_CANBEUNICODE TEXT("IconFile")))
        {
            // Fix the relative path
            PathCombine(pszIcon, szPath, pszIcon);
            fSuccess = PathFileExistsAndAttributes(pszIcon, NULL);
            if (fSuccess)
            {
                TCHAR szIndex[16];
                if (GetFolderString(szPath, _pszNetProvider, szIndex, ARRAYSIZE(szIndex), TEXT("IconIndex")))
                {
                    StrToIntEx(szIndex, 0, (int *)pIndex);
                }
            }
        }
    }

    return fSuccess;
}

// IDList factory
CFileSysItem::CFileSysItem(LPCIDFOLDER pidf)
    : _pidf(pidf), _pidp((PCIDPERSONALIZED)-1)
{
    _pidfx = (PCIDFOLDEREX) ILFindHiddenIDOn((LPCITEMIDLIST)pidf, IDLHID_IDFOLDEREX, FALSE);

    if (_pidfx && _pidfx->hid.wVersion < IDFX_V1)
        _pidfx = NULL;
}

BOOL CFileSysItem::_IsPersonalized()
{
    if (_pidp == (PCIDPERSONALIZED) -1)
    {
        _pidp = (PCIDPERSONALIZED) ILFindHiddenIDOn((LPCITEMIDLIST)_pidf, IDLHID_PERSONALIZED, FALSE);
        if (_pidp && 0 >= (signed short) _pidp->hid.wVersion)
            _pidp = NULL;
    }
    return _pidp != NULL;
}
        
CFileSysItemString::CFileSysItemString(LPCIDFOLDER pidf)
    : CFileSysItem(pidf), _pszFSName(NULL), _pszUIName(NULL), _pszClass(NULL), _dwClass(0), _fsin(FSINAME_NONE)
{
    *_sz = 0;
}

LPCWSTR CFileSysItemString::FSName()
{
    if (!_pszFSName)
    {
        if (!(_fsin & FSINAME_FS))
        {
            LPCWSTR psz = MayCopyFSName(FALSE, _sz, ARRAYSIZE(_sz));
            if (psz == _sz)
                _fsin = FSINAME_FS;
            else
                _pszFSName = psz;
        }
    }
    return _pszFSName ? _pszFSName : _sz;
}

LPCWSTR CFileSysItem::MayCopyFSName(BOOL fMustCopy, LPWSTR psz, DWORD cch)
{
    if (_pidfx)
    {
        LPNWSTR pnsz = UASTROFFW(_pidfx, _pidfx->offNameW);
        //  return back a pointer inside the pidfx
        //  if we can...
        if (fMustCopy || ((INT_PTR)pnsz & 1))
        {
            ualstrcpynW(psz, pnsz, cch);
        }
        else
            psz = (LPWSTR) pnsz;
    }
    else
    {
        if ((CFSFolder::_GetType(_pidf) & SHID_FS_UNICODE) == SHID_FS_UNICODE)
        {
            ualstrcpynW(psz, (LPCWSTR)_pidf->cFileName, cch);
        }
        else
        {
            MultiByteToWideChar(CP_ACP, 0, _pidf->cFileName, -1, psz, cch);
        }

    }
    return psz;
}

LPCSTR CFileSysItemString::AltName()
{
    UINT cbName;
    if (_pidfx)
    {
        //  we put the altname in cFileName
        cbName = 0;
    }
    else if ((CFSFolder::_GetType(_pidf) & SHID_FS_UNICODE) == SHID_FS_UNICODE)
    {
        cbName = (ualstrlenW((LPCWSTR)_pidf->cFileName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbName = lstrlenA(_pidf->cFileName) + 1;
    }

    return _pidf->cFileName + cbName;
}

LPCWSTR CFileSysItemString::UIName(CFSFolder *pfs)
{
    if (!_pszUIName)
    {
        if (!(_fsin & FSINAME_UI))
        {
            if (!_pidfx || !_LoadResource(pfs))
            {
                if (!ShowExtension(pfs->_DefaultShowExt()))
                {
                    //  we need to have a buffer
                    if (!(_fsin & FSINAME_FS))
                        MayCopyFSName(TRUE, _sz, ARRAYSIZE(_sz));

                    PathRemoveExtension(_sz);
                    //  lose the FSINAME_FS bit
                    _fsin = FSINAME_UI;
                }
                else
                {
                    //  the FSName and the UIName are the same
                    if (_sz == FSName())
                    {
                        //  the FSName and the UIName are the same
                        //  pidl is unaligned so the buffer gets double work
                        _fsin = FSINAME_FSUI;
                    }
                    else
                    {
                        //  and we are aligned so we can use the same name
                        //  directories are often this way.
                        _pszUIName = _pszFSName;
                    }
                }
            }
        }
    }
    return _pszUIName ? _pszUIName : _sz;
}

UINT UnicodeToAscii(LPCWSTR pwsz, LPSTR psz, UINT cch)
{
    //  always at least copy the NULL
    UINT cchRet = 1;
    while (cch-- && (*psz++ = (CHAR) *pwsz++))
    {
        ASSERT(!(*pwsz & 0xff00));
        cchRet++;
    }

    if (0 > (INT)cch)
        psz[cchRet - 1] = 0;

    return cchRet;
}

UINT AsciiToUnicode(LPCSTR psz, LPWSTR pwsz, UINT cch)
{
    UINT cchRet = 1;
    while (cch-- && (*pwsz++ = (WCHAR) *psz++))
    {
        cchRet++;
    }

    if (0 > (INT)cch)
        pwsz[cchRet - 1] = 0;

    return cchRet;
}

BOOL CFileSysItemString::_ResourceName(LPWSTR psz, DWORD cch, BOOL fIsMine)
{
    BOOL fRet = FALSE;
    if (_IsPersonalized())
    {
        int ids = _GetPersonalizedRes((int)_pidp->hid.wVersion, fIsMine);
        if (ids != -1)
        {
            wnsprintf(psz, cch, L"@shell32.dll,-%d", ids);
            fRet = TRUE;
        }
    }
    else if (_pidfx && _pidfx->offResourceA)
    {
        SHAnsiToUnicode(UASTROFFA(_pidfx, _pidfx->offResourceA), psz, cch);
        fRet = TRUE;
    }
    return fRet;        
}

LPCWSTR CFileSysItemString::ResourceName()
{
    if (!(_fsin & FSINAME_RESOURCE))
    {
        if (!_ResourceName(_sz, ARRAYSIZE(_sz), FALSE))
            *_sz = 0;
    }
    _fsin = FSINAME_RESOURCE;
    return _sz;
}
HRESULT CFileSysItemString::GetFindDataSimple(WIN32_FIND_DATAW *pfd)
{
    ZeroMemory(pfd, sizeof(*pfd));

    // Note that COFSFolder doesn't provide any times _but_ COFSFolder
    DosDateTimeToFileTime(_pidf->dateModified, _pidf->timeModified, &pfd->ftLastWriteTime);
    pfd->dwFileAttributes = _pidf->wAttrs;
    pfd->nFileSizeLow = _pidf->dwSize;

    StrCpyN(pfd->cFileName, FSName(), ARRAYSIZE(pfd->cFileName));
    SHAnsiToUnicode(AltName(), pfd->cAlternateFileName, ARRAYSIZE(pfd->cAlternateFileName));

    if (_pidfx)
    {
        DosDateTimeToFileTime(_pidfx->dsCreate.wDate, _pidfx->dsCreate.wTime, &pfd->ftCreationTime);
        DosDateTimeToFileTime(_pidfx->dsAccess.wDate, _pidfx->dsAccess.wTime, &pfd->ftLastAccessTime);
    }

    return S_OK;
}

HRESULT CFileSysItemString::GetFindData(WIN32_FIND_DATAW *pfd)
{
    HRESULT hr;
    // if its a simple ID, there's no data in it
    if (CFSFolder::_IsReal(_pidf))
    {
        hr = GetFindDataSimple(pfd);
    }
    else
    {
        ZeroMemory(pfd, sizeof(*pfd));
        hr = E_INVALIDARG;
    }
    return hr;
}

typedef struct
{
    int csidl;
    int idsMine;
    int idsTheirs;
} PERSONALIZEDNAME;

int CFileSysItemString::_GetPersonalizedRes(int csidl, BOOL fIsMine)
{
static const PERSONALIZEDNAME s_pnames[] = 
    {
        { CSIDL_PERSONAL, -1, IDS_LOCALGDN_FLD_THEIRDOCUMENTS},
        { CSIDL_MYPICTURES, IDS_LOCALGDN_FLD_MYPICTURES, IDS_LOCALGDN_FLD_THEIRPICTURES},
        { CSIDL_MYMUSIC, IDS_LOCALGDN_FLD_MYMUSIC, IDS_LOCALGDN_FLD_THEIRMUSIC},
        { CSIDL_MYVIDEO, IDS_LOCALGDN_FLD_MYVIDEOS, IDS_LOCALGDN_FLD_THEIRVIDEOS},
    };

    for (int i = 0; i < ARRAYSIZE(s_pnames); i++)
    {
        if (s_pnames[i].csidl == csidl)
        {
            return fIsMine ? s_pnames[i].idsMine : s_pnames[i].idsTheirs;
        }
    }
    AssertMsg(FALSE, TEXT("Personalized Resource not in table"));
    return -1;
}

TRIBIT CFileSysItem::_IsMine(CFSFolder *pfs)
{
    TRIBIT tb = TRIBIT_UNDEFINED;
    if (_IsPersonalized())
    {
        WCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, (int)_pidp->hid.wVersion | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)))
        {
            WCHAR szThis[MAX_PATH];
            if (SUCCEEDED(pfs->_GetPathForItem(_pidf, szThis)))
            {
                //  if they match then its ours
                //  if they dont then it still personalized (theirs)
                if (0 == StrCmpI(szThis, szPath))
                    tb = TRIBIT_TRUE;
                else
                {
                    tb = TRIBIT_FALSE;
                }
            }
        }
    }
    return tb;
}

void CFileSysItemString::_FormatTheirs(LPCWSTR pszFormat)
{
    WCHAR szOwner[UNLEN];
    ualstrcpynW(szOwner, _pidp->szUserName, ARRAYSIZE(szOwner));
    if (!IsOS(OS_DOMAINMEMBER))
    {
        //  maybe we should do caching here???
        //  pfs->GetUserName(szOwner, szOwner, ARRAYSIZE(szOwner));
        USER_INFO_10 *pui;
        if (NERR_Success == NetUserGetInfo(NULL, szOwner, 10, (LPBYTE*)&pui))
        {
            LPTSTR pszName = (*pui->usri10_full_name) ? pui->usri10_full_name: pui->usri10_name;
            if (*pszName)
            {
                StrCpyN(szOwner, pszName, ARRAYSIZE(szOwner));
            }
            NetApiBufferFree(pui);
        }
    }
    wnsprintf(_sz, ARRAYSIZE(_sz), pszFormat, szOwner);
}

BOOL CFileSysItemString::_LoadResource(CFSFolder *pfs)
{
    WCHAR szResource[MAX_PATH];
    BOOL fRet = FALSE;
    TRIBIT tbIsMine = _IsMine(pfs);
    if (_ResourceName(szResource, ARRAYSIZE(szResource), tbIsMine == TRIBIT_TRUE))
    {
        DWORD cb = sizeof(_sz);
        //  first check the registry for overrides
        if (S_OK == SKGetValueW(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", szResource, NULL, _sz, &cb)
              && *_sz)
        {
            fRet = TRUE;
        }
        else if (szResource[0] == TEXT('@'))
        {
            //  it does caching for us
            fRet = SUCCEEDED(SHLoadIndirectString(szResource, _sz, ARRAYSIZE(_sz), NULL));
            //  If the call fails, this means that the
            //  localized string belongs to a DLL that has been uninstalled.
            //  Just return the failure code so we act as if the MUI string
            //  isn't there.  (Don't show the user "@DLLNAME.DLL,-5" as the
            //  name!)
            if (fRet && tbIsMine == TRIBIT_FALSE)
            {
                //  reuse szResource as the format string
                StrCpyN(szResource, _sz, ARRAYSIZE(szResource));
                _FormatTheirs(szResource);
            }
        }
    }
    
    if (fRet)
        _fsin = FSINAME_UI;

    ASSERT(!_fsin || *_sz);

    return fRet;
}

BOOL CFileSysItem::CantRename(CFSFolder *pfs)
{
    //  BOOL fRest = SHRestricted(REST_NORENAMELOCALIZED);
    if (_IsPersonalized())
    {
        if (!_IsMine(pfs))
            return TRUE;

        // return fRest;
    }
    else if (_pidfx && _pidfx->offResourceA)
    {
        //  return fRest;
    }
    return FALSE;
}

UINT _CopyResource(LPWSTR pszSrc, LPSTR pszRes, UINT cchRes)
{
    ASSERT(*pszSrc == L'@');
    LPWSTR pszS32 = StrStrIW(pszSrc, L"shell32.dll");
    if (pszS32)
    {
        *(--pszS32) = L'@';
        pszSrc = pszS32;
    }
        
    return SHUnicodeToAnsi(pszSrc, pszRes, cchRes);
}

UINT CFSFolder::_GetItemExStrings(LPCIDFOLDER pidfSimpleParent, const WIN32_FIND_DATA *pfd, EXSTRINGS *pxs)
{
    UINT cbRet = 0;
    TCHAR szTemp[MAX_PATH];
    if ((pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    && (pfd->dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
    {
        if (SUCCEEDED(_GetPathForItem(pidfSimpleParent, szTemp)))
        {
            PathAppend(szTemp, pfd->cFileName);
            if (GetFolderStringEx(szTemp, _pszNetProvider, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("Owner"), pxs->idp.szUserName, ARRAYSIZE(pxs->idp.szUserName)))
            {
                pxs->idp.hid.cb = sizeof(pxs->idp.hid) + CbFromCchW(lstrlenW(pxs->idp.szUserName) + 1);
                pxs->idp.hid.id = IDLHID_PERSONALIZED;
                WCHAR szFile[MAX_PATH];
                if (GetFolderStringEx(szTemp, _pszNetProvider, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("PersonalizedName"), szFile, ARRAYSIZE(szFile)))
                {
                    if (0 == StrCmpI(pfd->cFileName, szFile))
                        pxs->idp.hid.wVersion = (WORD) GetFolderInt(szTemp, _pszNetProvider, L"DeleteOnCopy", TEXT("Personalized"), -1);
                }
            }
            else if (GetFolderString(szTemp, _pszNetProvider, szTemp, ARRAYSIZE(szTemp), TEXT("LocalizedResourceName")))
            {
                pxs->cbResource = _CopyResource(szTemp, pxs->szResource, ARRAYSIZE(pxs->szResource));
                cbRet += pxs->cbResource;
            }
            
        }
    }
    else if (!pidfSimpleParent && _IsSelfSystemFolder())
    {
        if (_HasLocalizedFileNames() && SUCCEEDED(_GetPath(szTemp)))
        {
            if (GetFolderStringEx(szTemp, _pszNetProvider, TEXT("LocalizedFileNames"), pfd->cFileName, szTemp, ARRAYSIZE(szTemp)))
            {
                pxs->cbResource = _CopyResource(szTemp, pxs->szResource, ARRAYSIZE(pxs->szResource));
                cbRet += pxs->cbResource;
            }
        }
    }    

    return cbRet;
}

BOOL _PrepIDFName(const WIN32_FIND_DATA *pfd, LPSTR psz, DWORD cch, const void **ppvName, UINT *pcbName)
{
    //  the normal case:
    //  the altname should only not be filled in
    //  in the case of the name being a shortname (ASCII)
    LPCWSTR pwsz = *pfd->cAlternateFileName && !(SHGetAppCompatFlags(ACF_FORCELFNIDLIST) & ACF_FORCELFNIDLIST)
        ? pfd->cAlternateFileName : pfd->cFileName;
    
    if (DoesStringRoundTrip(pwsz, psz, cch))
    {
        *pcbName = lstrlenA(psz) + 1;
        *ppvName = psz;
    }
    else
    {
        *pcbName = CbFromCchW(lstrlenW(pwsz) + 1);
        *ppvName = pfd->cFileName;
    }

    return *ppvName != psz;
}

HRESULT CFSFolder::_CreateIDList(const WIN32_FIND_DATA *pfd, LPCIDFOLDER pidfSimpleParent, LPITEMIDLIST *ppidl)
{
    //  for the idf
    CHAR szNameIDF[MAX_PATH];
    UINT cbNameIDF;
    const void *pvNameIDF;
    BOOL fNeedsUnicode = _PrepIDFName(pfd, szNameIDF, ARRAYSIZE(szNameIDF), &pvNameIDF, &cbNameIDF);
    UINT cbIDF = FIELD_OFFSET(IDFOLDER, cFileName) + cbNameIDF;
    ASSERT(*((char *)pvNameIDF));

    //  for the idfx
    UINT cbNameIDFX = CbFromCchW(lstrlenW(pfd->cFileName) + 1);
    EXSTRINGS xs = {0};
    UINT cbIDFX = sizeof(IDFOLDEREX) + cbNameIDFX + _GetItemExStrings(pidfSimpleParent, pfd, &xs);

    //  try to align these babies
    cbIDF = ROUNDUP(cbIDF, 2);
    cbIDFX = ROUNDUP(cbIDFX, 2);
    //  ILCreateWithHidden() fills in the cb values
    LPIDFOLDER pidf = (LPIDFOLDER)ILCreateWithHidden(cbIDF, cbIDFX);
    if (pidf)
    {
        //  initialize the idf
        // tag files > 4G so we can do a full find first when we need to know the real size
        pidf->dwSize = pfd->nFileSizeHigh ? 0xFFFFFFFF : pfd->nFileSizeLow;
        pidf->wAttrs = (WORD)pfd->dwFileAttributes;

        // Since the idf entry is not aligned, we cannot just send the address
        // of one of its members blindly into FileTimeToDosDateTime.
        WORD date, time;
        if (FileTimeToDosDateTime(&pfd->ftLastWriteTime, &date, &time))
        {
            *((UNALIGNED WORD *)&pidf->dateModified) = date;
            *((UNALIGNED WORD *)&pidf->timeModified) = time;
        }

        //  copy the short name
        memcpy(pidf->cFileName, pvNameIDF, cbNameIDF);

        //  setup bFlags
        pidf->bFlags = pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? SHID_FS_DIRECTORY : SHID_FS_FILE;
        if (CSIDL_COMMON_DESKTOPDIRECTORY == _csidlTrack)
            pidf->bFlags |= SHID_FS_COMMONITEM;

        if (fNeedsUnicode)
            pidf->bFlags |= SHID_FS_UNICODE;
            
        //  now initialize the hidden idfx
        PIDFOLDEREX pidfx = (PIDFOLDEREX) _ILSkip((LPITEMIDLIST)pidf, cbIDF);
        pidfx->hid.id = IDLHID_IDFOLDEREX;
        pidfx->hid.wVersion = IDFX_CV;

        if (FileTimeToDosDateTime(&pfd->ftCreationTime, &date, &time))
        {
            pidfx->dsCreate.wDate = date;
            pidfx->dsCreate.wTime = time;
        }
        if (FileTimeToDosDateTime(&pfd->ftLastAccessTime, &date, &time))
        {
            pidfx->dsAccess.wDate = date;
            pidfx->dsAccess.wTime = time;
        }

        //  append the strings
        pidfx->offNameW = (USHORT) sizeof(IDFOLDEREX);
        ualstrcpyW(UASTROFFW(pidfx, pidfx->offNameW), pfd->cFileName);
        USHORT offNext = (USHORT) sizeof(IDFOLDEREX) + cbNameIDFX;
        if (xs.cbResource)
        {
            pidfx->offResourceA = offNext;
            ualstrcpyA(UASTROFFA(pidfx, pidfx->offResourceA), xs.szResource);
            //  offNext += (USHORT) xs.cbResource; if we have more offsets...
        }
        
        pidf = _MarkAsJunction(pidfSimpleParent, pidf, pfd->cFileName);

        if (pidf && xs.idp.hid.cb)
            pidf = (LPIDFOLDER) ILAppendHiddenID((LPITEMIDLIST)pidf, &xs.idp.hid);
    }

    *ppidl = (LPITEMIDLIST)pidf;
    return *ppidl != NULL ? S_OK : E_OUTOFMEMORY;
}

BOOL _ValidPathSegment(LPCTSTR pszSegment)
{
    if (*pszSegment && !PathIsDotOrDotDot(pszSegment))
    {
        for (LPCTSTR psz = pszSegment; *psz; psz = CharNext(psz))
        {
            if (!PathIsValidChar(*psz, PIVC_LFN_NAME))
                return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}



// used to parse up file path like strings:
//      "folder\folder\file.txt"
//      "file.txt"
//
// in/out:
//      *ppszIn   in: pointer to start of the buffer, 
//                output: advanced to next location, NULL on last segment
// out:
//      *pszSegment NULL if nothing left
//
// returns:
//      S_OK            got a segment
//      S_FALSE         loop done, *pszSegment emtpy
//      E_INVALIDARG    invalid input "", "\foo", "\\foo", "foo\\bar", "?<>*" chars in seg
 
HRESULT _NextSegment(LPCWSTR *ppszIn, LPTSTR pszSegment, UINT cchSegment, BOOL bValidate)
{
    HRESULT hr;

    *pszSegment = 0;

    if (*ppszIn)
    {
        // WARNING!  Do not use StrPBrkW(*ppszIn, L"\\/"), because
        // Trident passes fully-qualified URLs to
        // SHGetFileInfo(USEFILEATTRIBUTES) and relies on the fact that
        // we won't choke on the embedded "//" in "http://".

        LPWSTR pszSlash = StrChrW(*ppszIn, L'\\');
        if (pszSlash)
        {
            if (pszSlash > *ppszIn) // make sure well formed (no dbl slashes)
            {
                OleStrToStrN(pszSegment, cchSegment, *ppszIn, (int)(pszSlash - *ppszIn));

                //  make sure that there is another segment to return
                if (!*(++pszSlash))
                    pszSlash = NULL;
                hr = S_OK;       
            }
            else
            {
                pszSlash = NULL;
                hr = E_INVALIDARG;    // bad input
            }
        }
        else
        {
            SHUnicodeToTChar(*ppszIn, pszSegment, cchSegment);
            hr = S_OK;       
        }
        *ppszIn = pszSlash;

        if (hr == S_OK && bValidate && !_ValidPathSegment(pszSegment))
        {
            *pszSegment = 0;
            hr = E_INVALIDARG;
        }
    }
    else
        hr = S_FALSE;     // done with loop

    return hr;
}

//  this makes a fake wfd and then uses the normal
//  FillIDFolder as if it were a real found path.

HRESULT CFSFolder::_ParseSimple(LPCWSTR pszPath, const WIN32_FIND_DATA *pfdLast, LPITEMIDLIST *ppidl)
{
    WIN32_FIND_DATA wfd = {0};
    HRESULT hr = S_OK;

    *ppidl = NULL;

    ASSERT(*pszPath);
    
    while (SUCCEEDED(hr) && (S_OK == (hr = _NextSegment((LPCWSTR *)&pszPath, wfd.cFileName, ARRAYSIZE(wfd.cFileName), FALSE))))
    {
        LPITEMIDLIST pidl;

        if (pszPath)
        {
            // internal componets must be folders
            wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        }
        else
        {
            // last segment takes the find data from that passed in
            // copy everything except the cFileName field
            memcpy(&wfd, pfdLast, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));
            lstrcpyn(wfd.cAlternateFileName, pfdLast->cAlternateFileName, ARRAYSIZE(wfd.cAlternateFileName));
        }

        hr = _CreateIDList(&wfd, (LPCIDFOLDER)*ppidl, &pidl);
        if (SUCCEEDED(hr))
            hr = SHILAppend(pidl, ppidl);
    }

    if (FAILED(hr))
    {
        if (*ppidl)
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
    }
    else
        hr = S_OK;      // pin all success to S_OK
    return hr;
}


BOOL IsAllWhiteSpace(LPCTSTR pszString)
{
    while (*pszString)
    {
        if ((TEXT(' ')  == *pszString) ||
            (TEXT('\t') == *pszString))
        {
            pszString++;    // keep walking the string
        }
        else
        {
            return FALSE;   // something other than a space or tab, done
        }
    }
    return TRUE;    // made it through the loop, just spaces or tabs in this string
}

HRESULT _CheckPortName(LPCTSTR pszName)
{
    if (PathIsInvalid(pszName))
        return HRESULT_FROM_WIN32(ERROR_BAD_DEVICE);
    else
        return S_OK;
}

class CFindFirstWithTimeout
{
public:
    CFindFirstWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow);
    HRESULT FindFirstWithTimeout(WIN32_FIND_DATA *pfd);

    ULONG AddRef();
    ULONG Release();

private:
    static DWORD WINAPI _FindFistThreadProc(void *pv);

    LONG _cRef;
    DWORD _dwTicksToAllow;
    TCHAR _szPath[MAX_PATH];
    WIN32_FIND_DATA _fd;
};

CFindFirstWithTimeout::CFindFirstWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow) : _cRef(1), _dwTicksToAllow(dwTicksToAllow)
{
    lstrcpyn(_szPath, pszPath, ARRAYSIZE(_szPath));
}

ULONG CFindFirstWithTimeout::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFindFirstWithTimeout::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

DWORD CFindFirstWithTimeout::_FindFistThreadProc(void *pv)
{
    CFindFirstWithTimeout *pffwt = (CFindFirstWithTimeout *)pv;
    
    HRESULT hr = SHFindFirstFileRetry(NULL, NULL, pffwt->_szPath, &pffwt->_fd, NULL, SHPPFW_NONE);
    
    pffwt->Release();
    return hr;          // retrieved via GetExitCodeThread()
}

HRESULT CFindFirstWithTimeout::FindFirstWithTimeout(WIN32_FIND_DATA *pfd)
{
    HRESULT hr;

    AddRef();   // ref for the thread

    DWORD dwID;
    HANDLE hThread = CreateThread(NULL, 0, _FindFistThreadProc, this, 0, &dwID);
    if (hThread)
    {
        // assume timeout...
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); // timeout return value

        if (WAIT_OBJECT_0 == WaitForSingleObject(hThread, _dwTicksToAllow))
        {
            // thread finished with an HRESULT for us
            DWORD dw;
            if (GetExitCodeThread(hThread, &dw))
            {
                *pfd = _fd;
                hr = dw;    // HRESULT returned by _FindFistThreadProc
            }
        }
        CloseHandle(hThread);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        Release();  // thread create failed, remove that ref
    }
    return hr;
}

HRESULT SHFindFirstFileWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow, WIN32_FIND_DATA *pfd)
{
    HRESULT hr;

    CFindFirstWithTimeout *pffwt = new CFindFirstWithTimeout(pszPath, dwTicksToAllow);
    if (pffwt)
    {
        hr = pffwt->FindFirstWithTimeout(pfd);
        pffwt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CFSFolder::_FindDataFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, WIN32_FIND_DATA **ppfd)
{
    *ppfd = NULL;

    HRESULT hr = _CheckPortName(pszName);
    if (SUCCEEDED(hr))
    {    
        hr = SHLocalAlloc(sizeof(**ppfd), ppfd);
        if (SUCCEEDED(hr))
        {
            if (-1 == dwAttribs)
            {
                TCHAR szPath[MAX_PATH];
                hr = _GetPath(szPath);
                if (SUCCEEDED(hr))
                {
                    PathAppend(szPath, pszName);

                    DWORD dwTicksToAllow;
                    if (SUCCEEDED(BindCtx_GetTimeoutDelta(pbc, &dwTicksToAllow)) && PathIsNetworkPath(szPath))
                    {
                        hr = SHFindFirstFileWithTimeout(szPath, dwTicksToAllow, *ppfd);
                    }
                    else
                    {
                        hr = SHFindFirstFileRetry(NULL, NULL, szPath, *ppfd, NULL, SHPPFW_NONE);
                    }
                }
            }
            else
            {
                //  make a simple one up
                StrCpyN((*ppfd)->cFileName, pszName, ARRAYSIZE((*ppfd)->cFileName));
                (*ppfd)->dwFileAttributes = dwAttribs;
            }
            if (FAILED(hr))
            {
                LocalFree(*ppfd);
                *ppfd = NULL;
            }
        }
    }

    ASSERT(SUCCEEDED(hr) ? NULL != *ppfd : NULL == *ppfd);
    return hr;
}

//
// This function returns a relative pidl for the specified file/folder
//
HRESULT CFSFolder::_CreateIDListFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, LPITEMIDLIST *ppidl)
{
    WIN32_FIND_DATA *pfd;
    HRESULT hr = _FindDataFromName(pszName, dwAttribs, pbc, &pfd);
    if (SUCCEEDED(hr))
    {
        hr = _CreateIDList(pfd, NULL, ppidl);
        LocalFree(pfd);
    }
    else
        *ppidl = NULL;

    return hr;
}

// used to detect if a name is a folder. this is used in the case that the
// security for this folders parent is set so you can't enum it's contents

BOOL CFSFolder::_CanSeeInThere(LPCTSTR pszName)
{
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPath(szPath)))
    {
        HANDLE hfind;
        WIN32_FIND_DATA fd;

        PathAppend(szPath, pszName);
        PathAppend(szPath, TEXT("*.*"));

        hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
            FindClose(hfind);
        return hfind != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}

HRESULT CFSFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFSFolder, IShellFolder, IShellFolder2),
        QITABENT(CFSFolder, IShellFolder2),
        QITABENT(CFSFolder, IShellIconOverlay),
        QITABENT(CFSFolder, IShellIcon),
        QITABENTMULTI(CFSFolder, IPersist, IPersistFolder3),
        QITABENTMULTI(CFSFolder, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CFSFolder, IPersistFolder2, IPersistFolder3),
        QITABENT(CFSFolder, IPersistFolder3),
        QITABENT(CFSFolder, IStorage),
        QITABENT(CFSFolder, IPropertySetStorage),
        QITABENT(CFSFolder, IItemNameLimits),
        QITABENT(CFSFolder, IContextMenuCB),
        QITABENT(CFSFolder, ISetFolderEnumRestriction),
        QITABENT(CFSFolder, IOleCommandTarget),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        if (IsEqualIID(IID_INeedRealCFSFolder, riid))
        {
            *ppv = this;                // not ref counted
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IPersistFreeThreadedObject))
        {
            if (_GetInner() == _GetOuter()) // not aggregated
            {
                hr = QueryInterface(IID_IPersist, ppv);
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
    }
    return hr;
}

// briefcase and file system folder call to reset data

HRESULT CFSFolder::_Reset()
{
    _DestroyColHandlers();

    if (_pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    if (_pidlTarget)
    {
        ILFree(_pidlTarget);
        _pidlTarget = NULL;   
    }

    if (_pszPath)
    {
        LocalFree(_pszPath);
        _pszPath = NULL;
    }

    if (_pszNetProvider)
    {
        LocalFree(_pszNetProvider);
        _pszNetProvider = NULL;
    }

    _csidl = -1;
    _dwAttributes = -1;

    _csidlTrack = -1;

    ATOMICRELEASE(_pstg);
    return S_OK;
}

#define INVALID_PATHSPEED   (-100)

CFSFolder::CFSFolder(IUnknown *punkOuter) : CAggregatedUnknown(punkOuter)
{
    _csidl = -1;
    _iFolderIcon = -1;
    _dwAttributes = -1;
    _csidlTrack = -1;
    _nFolderType = FVCBFT_DOCUMENTS;
    _bSlowPath = INVALID_PATHSPEED; // some non-common value
                                    // Note: BOOL is not bool
    _tbOfflineCSC = TRIBIT_UNDEFINED;

    DllAddRef();
}

CFSFolder::~CFSFolder()
{
    _Reset();
    DllRelease();
}

// we need to fail relative type paths since we use PathCombine
// and we don't want that and the Win32 APIs to give us relative path behavior
// ShellExecute() depends on this so it falls back and resolves the relative paths itself

HRESULT CFSFolder::ParseDisplayName(HWND hwnd, IBindCtx *pbc, WCHAR *pszName, ULONG *pchEaten, 
                                    LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    HRESULT hr;
    WIN32_FIND_DATA *pfd;

    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;   // assume error
    if (pszName == NULL)
        return E_INVALIDARG;

    if (S_OK == SHIsFileSysBindCtx(pbc, &pfd))
    {
        hr = _ParseSimple(pszName, pfd, ppidl);
        if (SUCCEEDED(hr) && pdwAttributes && *pdwAttributes)
        {
            // while strictly not a legit thing to do here, we
            // pass the last IDList because 1) this is a simple IDList
            // 2) we hope that callers don't ask for bits that
            // require a full path to be valid inside the impl of
            // ::GetAttributesOf()
            LPCITEMIDLIST pidlLast = ILFindLastID(*ppidl);  
            GetAttributesOf(1, &pidlLast, pdwAttributes);
        }
        LocalFree(pfd);
    }
    else
    {
        DWORD cchNext = lstrlen(pszName) + 1;
        WCHAR *pszNext = (WCHAR *)alloca(CbFromCchW(cchNext));

        hr = _NextSegment((LPCWSTR *)&pszName, pszNext, cchNext, TRUE);
        if (SUCCEEDED(hr))
        {
            hr = _CreateIDListFromName(pszNext, -1, pbc, ppidl);

            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                // security "List folder contents" may be disabled for
                // this items parent. so see if this is really there
                if (pszName || _CanSeeInThere(pszNext))
                {
                    hr = _CreateIDListFromName(pszNext, FILE_ATTRIBUTE_DIRECTORY, pbc, ppidl);
                }
            }
            else if (((hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))) && 
                     (pszName == NULL) && 
                     (BindCtx_GetMode(pbc, 0) & STGM_CREATE) &&
                     !_fDontForceCreate)
            {
                // create a pidl to something that doesnt exist.
                hr = _CreateIDListFromName(pszNext, FILE_ATTRIBUTE_NORMAL, pbc, ppidl);
            }

            if (SUCCEEDED(hr))
            {
                if (pszName) // more stuff to parse?
                {
                    IShellFolder *psfFolder;
                    hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psfFolder));
                    if (SUCCEEDED(hr))
                    {
                        ULONG chEaten;
                        LPITEMIDLIST pidlNext;

                        hr = psfFolder->ParseDisplayName(hwnd, pbc, 
                            pszName, &chEaten, &pidlNext, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILAppend(pidlNext, ppidl);
                        }
                        psfFolder->Release();
                    }
                }
                else
                {
                    if (pdwAttributes && *pdwAttributes)
                        GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
                }
            }
        }
    }

    if (FAILED(hr) && *ppidl)
    {
        // This is needed if psfFolder->ParseDisplayName() or BindToObject()
        // fails because the pidl is already allocated.
        ILFree(*ppidl);
        *ppidl = NULL;
    }
    ASSERT(SUCCEEDED(hr) ? (*ppidl != NULL) : (*ppidl == NULL));

    // display this only as a warning, this can get hit during mergfldr or IStorage::Create probes
    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CFSFolder::ParseDisplayName(), hr:%x %ls", hr, pszName);
    return hr;
}

STDAPI InitFileFolderClassNames(void)
{
    if (g_szFileTemplate[0] == 0)    // test last one to avoid race
    {
        LoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, g_szFolderTypeName,  ARRAYSIZE(g_szFolderTypeName));
        LoadString(HINST_THISDLL, IDS_FILETYPENAME, g_szFileTypeName, ARRAYSIZE(g_szFileTypeName));
        LoadString(HINST_THISDLL, IDS_EXTTYPETEMPLATE, g_szFileTemplate, ARRAYSIZE(g_szFileTemplate));
    }
    return S_OK;
}

HRESULT CFSFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    InitFileFolderClassNames();
    grfFlags |= _dwEnumRequired;
    grfFlags &= ~_dwEnumForbidden;

    return CFSFolder_CreateEnum(this, hwnd, grfFlags, ppenum);
}

HRESULT CFSFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    // MIL 117282 - Enroute Imaging QuickStitch depends on pre-Jan'97 behavior of us
    // *not* nulling ppv out on !_IsValidID(pidl).  (They pass in a perfectly valid
    // IShellFolder* interfacing asking for IID_IShellFolder on the empty PIDL.)
    //
    if (!(SHGetAppCompatFlags(ACF_WIN95BINDTOOBJECT) & ACF_WIN95BINDTOOBJECT))
        *ppv = NULL;

    HRESULT hr;
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        LPCITEMIDLIST pidlRight;
        LPIDFOLDER pidfBind;

        hr = _GetJunctionForBind(pidf, &pidfBind, &pidlRight);
        if (SUCCEEDED(hr))
        {
            if (hr == S_OK)
            {
                IShellFolder *psfJunction;
                hr = _Bind(pbc, pidfBind, IID_PPV_ARG(IShellFolder, &psfJunction));
                if (SUCCEEDED(hr))
                {
                    // now bind to the stuff below the junction point
                    hr = psfJunction->BindToObject(pidlRight, pbc, riid, ppv);
                    psfJunction->Release();
                }
                ILFree((LPITEMIDLIST)pidfBind);
            }
            else
            {
                ASSERT(pidfBind == NULL);
                hr = _Bind(pbc, pidf, riid, ppv);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CFSFolder::BindToObject(), hr:%x bad PIDL %s", hr, DumpPidl(pidl));
    }
    return hr;
}

HRESULT CFSFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CFSFolder::_CheckDriveRestriction(HWND hwnd, REFIID riid)
{
    HRESULT hr = S_OK;
    DWORD dwRest = SHRestricted(REST_NOVIEWONDRIVE);
    if (dwRest)
    {
        TCHAR szPath[MAX_PATH];

        hr = _GetPath(szPath);
        if (SUCCEEDED(hr))
        {
            int iDrive = PathGetDriveNumber(szPath);
            if (iDrive != -1)
            {
                // is the drive restricted
                if (dwRest & (1 << iDrive))
                {
                    // don't show the error message on droptarget -- just fail silently
                    if (hwnd && !IsEqualIID(riid, IID_IDropTarget))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                                        MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK | MB_ICONSTOP);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error
                    }
                    else
                        hr = E_ACCESSDENIED;
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_CreateUIHandler(REFIID riid, void **ppv)
{
    HRESULT hr;

    // Cache the view CLSID if not cached.
    if (!_fCachedCLSID)
    {
        if (_IsSelfSystemFolder())
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(_GetPath(szPath)))
                _fHasCLSID = GetFolderGUID(szPath, _pszNetProvider, &_clsidView, TEXT("UICLSID"));
            _fCachedCLSID = TRUE;
        }
    }

    // Use the handler if it exists
    if (_fHasCLSID)
    {
        IPersistFolder *ppf;
        hr = SHExtCoCreateInstance(NULL, &_clsidView, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Initialize(_pidl);
            if (FAILED(hr) && _pidlTarget)
            {
                // It may have failed because the _pidl is an alias (not a file folder). if so try
                // again with _pidlTarget (that will be a file system folder)
                // this was required for the Fonts FolderShortcut in the ControlPanel (stephstm)

                hr = ppf->Initialize(_pidlTarget);
            }

            if (SUCCEEDED(hr))
                hr = ppf->QueryInterface(riid, ppv);
            ppf->Release();
        }
    }
    else
        hr = E_FAIL;        // no handler
    return hr;
}

HRESULT CFSFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView) || 
        IsEqualIID(riid, IID_IDropTarget))
    {
        hr = _CheckDriveRestriction(hwnd, riid);
        if (SUCCEEDED(hr))
        {
            hr = _CreateUIHandler(riid, ppv);
            if (FAILED(hr))
            {
                if (IsEqualIID(riid, IID_IDropTarget))
                {
                    hr = CFSDropTarget_CreateInstance(this, hwnd, (IDropTarget **)ppv);
                }
                else
                {
                    SFV_CREATE csfv = { sizeof(csfv), 0 };

                    hr = QueryInterface(IID_PPV_ARG(IShellFolder, &csfv.pshf));
                    if (SUCCEEDED(hr))
                    {
                        CFSFolderCallback_Create(this, &csfv.psfvcb);

                        hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

                        if (csfv.psfvcb)
                            csfv.psfvcb->Release();

                        csfv.pshf->Release();
                    }
                }
            }
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        // do background menu.
        IShellFolder *psfToPass;        // May be an Aggregate...
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlMenuTarget = (_pidlTarget ? _pidlTarget : _pidl);
            HKEY hkNoFiles;
            RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), &hkNoFiles);

            IContextMenuCB *pcmcb = new CDefBackgroundMenuCB(pidlMenuTarget);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(pidlMenuTarget, hwnd, 0, NULL, psfToPass, pcmcb, 
                                              1, &hkNoFiles, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            psfToPass->Release();
            if (hkNoFiles)                          // CDefFolderMenu_Create can handle NULL ok
                RegCloseKey(hkNoFiles);
        }
    }
    else if (IsEqualIID(riid, IID_ICategoryProvider))
    {
        HKEY hk = NULL;
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\shellex\\Category"), &hk);
        hr = CCategoryProvider_Create(NULL, NULL, hk, NULL, this, riid, ppv);
        if (hk)
            RegCloseKey(hk);
    }
    else
    {
        ASSERT(*ppv == NULL);
        hr = E_NOINTERFACE;
    }
    return hr;
}

#define LOGICALXOR(a, b) (((a) && !(b)) || (!(a) && (b)))

HRESULT CFSFolder::_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2, BOOL fCaseSensitive, BOOL fCanonical)
{
    CFileSysItemString fsi1(pidf1), fsi2(pidf2);

    int iRet = StrCmpICW(fsi1.FSName(), fsi2.FSName());

    if (iRet)
    {
        // 
        //  additional check for identity using the 8.3 or AltName()
        //  if we are then the identity compare is better based off
        //  the AltName() which should be the same regardless of 
        //  platform or CP.
        //
        if (LOGICALXOR(fsi1.IsLegacy(), fsi2.IsLegacy()))
        {
            if (lstrcmpiA(fsi1.AltName(), fsi2.AltName()) == 0)
                iRet = 0;
        }

        if (iRet && !fCanonical)
        {
            //  they are definitely not the same item
            // Sort it based on the primary (long) name -- ignore case.
            int iUI = StrCmpLogicalRestricted(fsi1.UIName(this), fsi2.UIName(this));

            //  if they are the same we might want case sensitive instead
            if (iUI == 0 && fCaseSensitive)
            {
                iUI = ustrcmp(fsi1.UIName(this), fsi2.UIName(this));
            }

            if (iUI)
                iRet = iUI;
        }
    }
    
    return ResultFromShort((short)iRet);
}

HRESULT CFSFolder::_CompareFileTypes(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    short result;

    ENTERCRITICAL;
    LPCTSTR psz1 = _GetTypeName(pidf1);
    LPCTSTR psz2 = _GetTypeName(pidf2);

    if (psz1 != psz2)
        result = (short) ustrcmpi(psz1, psz2);
    else
        result = 0;

    LEAVECRITICAL;

    return ResultFromShort(result);
}

HRESULT CFSFolder::_CompareModifiedDate(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    if ((DWORD)MAKELONG(pidf1->timeModified, pidf1->dateModified) <
        (DWORD)MAKELONG(pidf2->timeModified, pidf2->dateModified))
    {
        return ResultFromShort(-1);
    }
    if ((DWORD)MAKELONG(pidf1->timeModified, pidf1->dateModified) >
        (DWORD)MAKELONG(pidf2->timeModified, pidf2->dateModified))
    {
        return ResultFromShort(1);
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareCreateTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    WIN32_FIND_DATAW wfd1, wfd2;

    if (SUCCEEDED(_FindDataFromIDFolder(pidf1, &wfd1, FALSE)) && SUCCEEDED(_FindDataFromIDFolder(pidf2, &wfd2, FALSE)))
    {
        return ResultFromShort(CompareFileTime(&wfd1.ftCreationTime, &wfd2.ftCreationTime));
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareAccessTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    WIN32_FIND_DATAW wfd1, wfd2;

    if (SUCCEEDED(_FindDataFromIDFolder(pidf1, &wfd1, FALSE)) && SUCCEEDED(_FindDataFromIDFolder(pidf2, &wfd2, FALSE)))
    {
        return ResultFromShort(CompareFileTime(&wfd1.ftLastAccessTime, &wfd2.ftLastAccessTime));
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareAttribs(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    const DWORD mask = FILE_ATTRIBUTE_READONLY  |
                       FILE_ATTRIBUTE_HIDDEN    |
                       FILE_ATTRIBUTE_SYSTEM    |
                       FILE_ATTRIBUTE_ARCHIVE   |
                       FILE_ATTRIBUTE_COMPRESSED|
                       FILE_ATTRIBUTE_ENCRYPTED |
                       FILE_ATTRIBUTE_OFFLINE;

    // Calculate value of desired bits in attribute DWORD.
    DWORD dwValueA = pidf1->wAttrs & mask;
    DWORD dwValueB = pidf2->wAttrs & mask;

    if (dwValueA != dwValueB)
    {
        // If the values are not equal,
        // sort alphabetically based on string representation.
        TCHAR szTempA[ARRAYSIZE(g_adwAttributeBits) + 1];
        TCHAR szTempB[ARRAYSIZE(g_adwAttributeBits) + 1];

        // Create attribute string for objects A and B.
        BuildAttributeString(pidf1->wAttrs, szTempA, ARRAYSIZE(szTempA));
        BuildAttributeString(pidf2->wAttrs, szTempB, ARRAYSIZE(szTempB));

        // Compare attribute strings and determine difference.
        int diff = ustrcmp(szTempA, szTempB);

        if (diff > 0)
           return ResultFromShort(1);
        if (diff < 0)
           return ResultFromShort(-1);
    }
    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareFolderness(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    if (_IsReal(pidf1) && _IsReal(pidf2))
    {
        // Always put the folders first
        if (_IsFolder(pidf1))
        {
            if (!_IsFolder(pidf2))
                return ResultFromShort(-1);
        }
        else if (_IsFolder(pidf2))
            return ResultFromShort(1);
    }
    return ResultFromShort(0);    // same
}

HRESULT CFSFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr;
    LPCIDFOLDER pidf1 = _IsValidID(pidl1);
    LPCIDFOLDER pidf2 = _IsValidID(pidl2);

    if (!pidf1 || !pidf2)
    {
        // ASSERT(0);      // we hit this often... who is the bad guy?
        return E_INVALIDARG;
    }

    hr = _CompareFolderness(pidf1, pidf2);
    if (hr != ResultFromShort(0))
        return hr;

    // SHCIDS_ALLFIELDS means to compare absolutely, ie: even if only filetimes
    // are different, we rule file pidls to be different
    int iColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);

    switch (iColumn)
    {
    case FS_ICOL_SIZE:
        {
            ULONGLONG ull1 = _Size(pidf1);
            ULONGLONG ull2 = _Size(pidf2);

            if (ull1 < ull2)
                return ResultFromShort(-1);
            if (ull1 > ull2)
                return ResultFromShort(1);
        }
        goto DoDefault;

    case FS_ICOL_TYPE:
        hr = _CompareFileTypes(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_WRITETIME:
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_NAME:
        hr = _CompareNames(pidf1, pidf2, TRUE, BOOLIFY((SHCIDS_CANONICALONLY & lParam)));
        if (hr == ResultFromShort(0))
        {
            // pidl1 is not simple
            hr = ILCompareRelIDs(this, pidl1, pidl2, lParam);
            goto DoDefaultModification;
        }
        break;

    case FS_ICOL_CREATETIME:
        hr = _CompareCreateTime(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_ACCESSTIME:
        hr = _CompareAccessTime(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_ATTRIB:
        hr = _CompareAttribs(pidf1, pidf2);
        if (hr)
            return hr;

        goto DoDefault;

    default:
        iColumn -= ARRAYSIZE(c_fs_cols);

        // 99/03/24 #295631 vtan: If not one of the standard columns then
        // it's probably an extended column. Make a check for dates.

        // 99/05/18 #341468 vtan: But also fail if it is an extended column
        // because this implementation of IShellFolder::CompareIDs only
        // understands basic file system columns and extended date columns.

        if (iColumn >= 0) 
        {
            hr = _CompareExtendedProp(iColumn, pidf1, pidf2);
            if (hr)
                return hr;
        }
DoDefault:
        hr = _CompareNames(pidf1, pidf2, FALSE, BOOLIFY((SHCIDS_CANONICALONLY & lParam)));
    }

DoDefaultModification:

    // If they were equal so far, but the caller wants SHCIDS_ALLFIELDS,
    // then look closer.
    if ((S_OK == hr) && (lParam & SHCIDS_ALLFIELDS)) 
    {
        // Must sort by modified date to pick up any file changes!
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            hr = _CompareAttribs(pidf1, pidf2);
    }

    return hr;
}

// test to see if this folder object is a net folder

BOOL CFSFolder::_IsNetPath()
{
    BOOL fRemote = FALSE;       // assume no
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPath(szPath)))
    {
        fRemote = PathIsRemote(szPath);
    }
    return fRemote;
}

BOOL _CanRenameFolder(LPCTSTR pszFolder)
{
    static const UINT c_aiNoRenameFolders[] = {
        CSIDL_WINDOWS, 
        CSIDL_SYSTEM, 
        CSIDL_PROGRAM_FILES, 
        CSIDL_FONTS, 
    };
    return !PathIsOneOf(pszFolder, c_aiNoRenameFolders, ARRAYSIZE(c_aiNoRenameFolders));
}

STDAPI_(LPCIDFOLDER) CFSFolder::_IsValidIDHack(LPCITEMIDLIST pidl)
{
    if (!(ACF_NOVALIDATEFSIDS & SHGetAppCompatFlags(ACF_NOVALIDATEFSIDS)))
    {
        return _IsValidID(pidl);
    }
    else if (pidl)
    {
        //  old behavior was that we didnt validate, we just
        //  looked for the last id and casted it
        return (LPCIDFOLDER)ILFindLastID(pidl);
    }
    return NULL;
}

#define SFGAO_NOT_RECENT    (SFGAO_CANRENAME | SFGAO_CANLINK)
#define SFGAO_REQ_MASK      (SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_FOLDER | SFGAO_DROPTARGET | SFGAO_LINK | SFGAO_STREAM | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE | SFGAO_READONLY)

HRESULT CFSFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    LPCIDFOLDER pidf = cidl ? _IsValidIDHack(apidl[0]) : NULL;

    ULONG rgfOut = SFGAO_CANDELETE | SFGAO_CANMOVE | SFGAO_CANCOPY | SFGAO_HASPROPSHEET
                    | SFGAO_FILESYSTEM | SFGAO_DROPTARGET | SFGAO_CANRENAME | SFGAO_CANLINK;

    ASSERT(cidl ? apidl[0] == ILFindLastID(apidl[0]) : TRUE); // should be single level IDs only
    ASSERT(cidl ? BOOLFROMPTR(pidf) : TRUE); // should always be FS PIDLs

    //  the RECENT folder doesnt like items in it renamed or linked to.
    if ((*prgfInOut & (SFGAO_NOT_RECENT)) && _IsCSIDL(CSIDL_RECENT))
    {
        rgfOut &= ~SFGAO_NOT_RECENT;
    }
        
    if (cidl == 1 && pidf)
    {
        CFileSysItemString fsi(pidf);
        TCHAR szPath[MAX_PATH];

        if (*prgfInOut & (SFGAO_VALIDATE | SFGAO_CANRENAME | SFGAO_REMOVABLE | SFGAO_SHARE))
        {
            HRESULT hr = _GetPathForItem(pidf, szPath);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            // just in case -- if somebody else needs the path they should add to the check above
            szPath[0] = 0;
        }

        if (*prgfInOut & SFGAO_VALIDATE)
        {
            DWORD dwAttribs;
            if (!PathFileExistsAndAttributes(szPath, &dwAttribs))
                return E_FAIL;

            // Tell the extended columns to update when someone request validation of a pidl
            // This allows a client of the shell folder who uses extended columns without a
            // view to force an update on stale information (i.e. Start Menu with InfoTips)
            // - lamadio 6.11.99
            _bUpdateExtendedCols = TRUE;

            // hackhack.  if they pass in validate, we party into it and update
            // the attribs
            if (!IsBadWritePtr((void *)&pidf->wAttrs, sizeof(pidf->wAttrs)))
                ((LPIDFOLDER)pidf)->wAttrs = (WORD)dwAttribs;
        }

        if (*prgfInOut & SFGAO_COMPRESSED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_COMPRESSED)
            {
                rgfOut |= SFGAO_COMPRESSED;
            }
        }

        if (*prgfInOut & SFGAO_ENCRYPTED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_ENCRYPTED)
            {
                rgfOut |= SFGAO_ENCRYPTED;
            }
        }

        if (*prgfInOut & SFGAO_READONLY)
        {
            if ((pidf->wAttrs & FILE_ATTRIBUTE_READONLY) && !(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY))
            {
                rgfOut |= SFGAO_READONLY;
            }
        }

        if (*prgfInOut & SFGAO_HIDDEN)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
            {
                rgfOut |= SFGAO_HIDDEN;
            }
        }

        if (*prgfInOut & SFGAO_NONENUMERATED)
        {
            if (IsSuperHidden(pidf->wAttrs))
            {
                // mark superhidden as nonenumerated, IsSuperHidden checks current settings
                rgfOut |= SFGAO_NONENUMERATED;
            }
            else if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
            {
                // mark normal hidden as nonenumerated if necessary
                SHELLSTATE ss;
                SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
                if (!ss.fShowAllObjects)
                {
                    rgfOut |= SFGAO_NONENUMERATED;
                }
            }
        }

        if (_IsFolder(pidf))
        {
            rgfOut |= SFGAO_FOLDER | SFGAO_STORAGE | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;
            if ((*prgfInOut & SFGAO_CANRENAME) && (fsi.CantRename(this) || !_CanRenameFolder(szPath)))
                rgfOut &= ~SFGAO_CANRENAME;

            if ((*prgfInOut & SFGAO_REMOVABLE) && PathIsRemovable(szPath))
            {
                rgfOut |= SFGAO_REMOVABLE;
            }

            if ((*prgfInOut & SFGAO_SHARE) && IsShared(szPath, FALSE))
            {
                rgfOut |= SFGAO_SHARE;
            }
        }
        else
        {
            rgfOut |= SFGAO_STREAM;
        }

        if (*prgfInOut & SFGAO_LINK)
        {
            DWORD dwFlags = fsi.ClassFlags(FALSE);
            if (dwFlags & SHCF_IS_LINK)
            {
                rgfOut |= SFGAO_LINK;
            }
        }

        CLSID clsid;
        if (fsi.GetJunctionClsid(&clsid, TRUE))
        {
            // NOTE: here we are always including SFGAO_FILESYSTEM. this was not the original
            // shell behavior. but since these things will succeeded on SHGetPathFromIDList()
            // it is the right thing to do. to filter out SFGAO_FOLDER things that might 
            // have files in them use SFGAO_FILESYSANCESTOR.
            //
            // clear out the things we want the extension to be able to optionally have
            rgfOut &= ~(SFGAO_DROPTARGET | SFGAO_STORAGE | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR);

            // let folder shortcuts yank the folder bit too for bad apps.
            if (IsEqualGUID(clsid, CLSID_FolderShortcut) &&
                (SHGetAppCompatFlags(ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT))
            {
                rgfOut &= ~SFGAO_FOLDER;
            }

            // and let him add some bits in
            rgfOut |= SHGetAttributesFromCLSID2(&clsid, SFGAO_HASSUBFOLDER, SFGAO_REQ_MASK) & SFGAO_REQ_MASK;
            
            // Mill #123708
            // prevent zips, cabs and other files with SFGAO_FOLDER set
            // from being treated like folders inside bad file open dialogs.
            if (!(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY) &&
                (SHGetAppCompatFlags (ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT))
            {
                rgfOut &= ~SFGAO_FOLDER;
            }

            // Check if this folder needs File System Ancestor bit
            if ((rgfOut & SFGAO_FOLDER) && !(rgfOut & SFGAO_FILESYSANCESTOR)
            && SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_NEEDSFILESYSANCESTOR)
            {
                rgfOut |= SFGAO_FILESYSANCESTOR;
            }
        }

        // it can only have subfolders if we've first found it's a folder
        if ((rgfOut & SFGAO_FOLDER) && (*prgfInOut & SFGAO_HASSUBFOLDER))
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                rgfOut |= SFGAO_HASSUBFOLDER;   // DFS junction, local mount point, assume sub folders
            }
            else if (_IsNetPath())
            {
                // it would be nice to not assume this. this messes up
                // home net cases where we get the "+" wrong
                rgfOut |= SFGAO_HASSUBFOLDER;   // assume yes because these are slow
            }
            else if (!(rgfOut & SFGAO_HASSUBFOLDER))
            {
                IShellFolder *psf;
                if (SUCCEEDED(_Bind(NULL, pidf, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    IEnumIDList *peunk;
                    if (S_OK == psf->EnumObjects(NULL, SHCONTF_FOLDERS, &peunk))
                    {
                        LPITEMIDLIST pidlT;
                        if (peunk->Next(1, &pidlT, NULL) == S_OK)
                        {
                            rgfOut |= SFGAO_HASSUBFOLDER;
                            SHFree(pidlT);
                        }
                        peunk->Release();
                    }
                    psf->Release();
                }
            }
        }

        if (*prgfInOut & SFGAO_GHOSTED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
                rgfOut |= SFGAO_GHOSTED;
        }

        if ((*prgfInOut & SFGAO_BROWSABLE) &&
            (_IsFile(pidf)) &&
            (fsi.ClassFlags(FALSE) & SHCF_IS_BROWSABLE))
        {
            rgfOut |= SFGAO_BROWSABLE;
        }
    }

    *prgfInOut = rgfOut;
    return S_OK;
}

// load handler for an item based on the handler type:
//     DropHandler, IconHandler, etc.
// in:
//      pidf            type of this object specifies the type of handler - can be multilevel
//      pszHandlerType  handler type name "DropTarget", may be NULL
//      riid            interface to talk on
// out:
//      ppv             output object
//
HRESULT CFSFolder::_LoadHandler(LPCIDFOLDER pidf, DWORD grfMode, LPCTSTR pszHandlerType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;    
    TCHAR szIID[40];

    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra non file sys goo please

    *ppv = NULL;

    // empty handler type, use the stringized IID as the handler name
    if (NULL == pszHandlerType)
    {
        szIID[0] = 0;
        SHStringFromGUID(riid, szIID, ARRAYSIZE(szIID));
        pszHandlerType = szIID;
    }

    CFileSysItemString fsi(_FindLastID(pidf));
    IAssociationArray *paa;
    hr = fsi.AssocCreate(this, FALSE, IID_PPV_ARG(IAssociationArray, &paa));    
    if (SUCCEEDED(hr))
    {
        CSmartCoTaskMem<WCHAR> spszClsid;
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQNS_SHELLEX_HANDLER, pszHandlerType, &spszClsid);
        if (SUCCEEDED(hr))
        {
            hr = _HandlerCreateInstance(pidf, spszClsid, grfMode, riid, ppv);
        }
        paa->Release();
    }
    return hr;
}

HRESULT CFSFolder::_HandlerCreateInstance(LPCIDFOLDER pidf, PCWSTR pszClsid, DWORD grfMode, REFIID riid, void **ppv)
{
    IPersistFile *ppf;
    HRESULT hr = SHExtCoCreateInstance(pszClsid, NULL, NULL, IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        WCHAR wszPath[MAX_PATH];
        hr = _GetPathForItem(pidf, wszPath);
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(wszPath, grfMode);
            if (SUCCEEDED(hr))
            {
                hr = ppf->QueryInterface(riid, ppv);
            }
        }
        ppf->Release();
    }
    return hr;
}

HRESULT CFSFolder::_CreateShimgvwExtractor(LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    CFileSysItemString fsi(pidf);
    if (fsi.IsShimgvwImage())
    {
        //  cocreate CLSID_GdiThumbnailExtractor implemented in shimgvw.dll
        hr = _HandlerCreateInstance(pidf, L"{3F30C968-480A-4C6C-862D-EFC0897BB84B}", STGM_READ, riid, ppv);
    }
    return hr;
}

int CFSFolder::_GetDefaultFolderIcon()
{
    int iIcon = II_FOLDER;
    UINT csidlFolder = _GetCSIDL();

    // We're removing the icon distinction between per user and common folders.
    switch (csidlFolder)
    {
    case CSIDL_STARTMENU:
    case CSIDL_COMMON_STARTMENU:
    case CSIDL_PROGRAMS:
    case CSIDL_COMMON_PROGRAMS:
        iIcon = II_STSPROGS;
        break;
    }

    return iIcon;
}

DWORD CFSFolder::_Attributes()
{
    if (_dwAttributes == -1)
    {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(_GetPath(szPath)))
            _dwAttributes = GetFileAttributes(szPath);
        if (_dwAttributes == -1)
            _dwAttributes = FILE_ATTRIBUTE_DIRECTORY;     // assume this on failure
    }
    return _dwAttributes;
}

// non junction, but has the system or readonly bit (regular folder marked special for us)
BOOL CFSFolder::_IsSelfSystemFolder()
{
    return (_Attributes() & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
}

// Determine if there is a LocalizedFileName section in our desktop.ini file
BOOL CFSFolder::_HasLocalizedFileNames()
{
    if (_tbHasLocalizedFileNamesSection == TRIBIT_UNDEFINED)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szName[MAX_PATH];
        TCHAR szBuf[4];

        _GetPath(szPath);

        if (_GetIniPath(FALSE, szPath, _pszNetProvider, szName) && 
            GetPrivateProfileSection(TEXT("LocalizedFileNames"), szBuf, sizeof(szBuf)/sizeof(TCHAR), szName) > 0)
            _tbHasLocalizedFileNamesSection = TRIBIT_TRUE;
        else
            _tbHasLocalizedFileNamesSection = TRIBIT_FALSE;
    }
    return (_tbHasLocalizedFileNamesSection == TRIBIT_TRUE);
}


// This function creates a default IExtractIcon object for either
// a file or a junction point. We should not supposed to call this function
// for a non-junction point directory (we don't want to hit the disk!).

HRESULT CFSFolder::_CreateDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppxicon)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwFlags;

    // WARNING: don't replace this if-statement with _IsFolder(pidf))!!!
    // otherwise all junctions (like briefcase) will get the Folder icon.
    //
    if (_IsFileFolder(pidf))
    {
        UINT iIcon = _GetDefaultFolderIcon();
        UINT iIconOpen = II_FOLDEROPEN;

        TCHAR szPath[MAX_PATH], szModule[MAX_PATH];

        szModule[0] = 0;

        if (_GetMountingPointInfo(pidf, szPath, ARRAYSIZE(szPath)))
        {
            // We want same icon for open and close moun point (kind of drive)
            iIconOpen = iIcon = GetMountedVolumeIcon(szPath, szModule, ARRAYSIZE(szModule));
        }
        else if (_IsSystemFolder(pidf))
        {
            if (_GetFolderIconPath(pidf, szPath, ARRAYSIZE(szPath), &iIcon))
            {
                return SHCreateDefExtIcon(szPath, iIcon, iIcon, GIL_PERINSTANCE, II_FOLDER, riid, ppxicon);
            }
        }

        return SHCreateDefExtIcon(szModule, iIcon, iIconOpen, GIL_PERCLASS, II_FOLDER, riid, ppxicon);
    }

    //  not a folder, get IExtractIcon and extract it.
    //  (might be a ds folder)
    CFileSysItemString fsi(pidf);
    dwFlags = fsi.ClassFlags(TRUE);
    if (dwFlags & SHCF_ICON_PERINSTANCE)
    {
        if (dwFlags & SHCF_HAS_ICONHANDLER)
        {
            IUnknown *punk;
            hr = _LoadHandler(pidf, STGM_READ, TEXT("IconHandler"), IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hr))
            {
                hr = punk->QueryInterface(riid, ppxicon);
                punk->Release();
            }
            else
            {
                *ppxicon = NULL;
            }
        }
        else
        {
            DWORD uid = _GetUID(pidf);
            TCHAR szPath[MAX_PATH];

            hr = _GetPathForItem(pidf, szPath);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateDefExtIcon(szPath, uid, uid, GIL_PERINSTANCE | GIL_NOTFILENAME, -1, riid, ppxicon);
            }
        }
    }
    else
    {
        UINT iIcon = (dwFlags & SHCF_ICON_INDEX);
        if (II_FOLDER == iIcon)
        {
            iIcon = _GetDefaultFolderIcon();
        }
        hr = SHCreateDefExtIcon(c_szStar, iIcon, iIcon, GIL_PERCLASS | GIL_NOTFILENAME, -1, riid, ppxicon);
    }
    return hr;
}

DWORD CALLBACK CFSFolder::_PropertiesThread(void *pv)
{
    PROPSTUFF * pps = (PROPSTUFF *)pv;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);
    LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
        if (pidl)
        {
            TCHAR szPath[MAX_PATH];
            LPTSTR pszCaption;
            HKEY rgKeys[MAX_ASSOC_KEYS] = {0};
            DWORD cKeys = SHGetAssocKeysForIDList(pidl, rgKeys, ARRAYSIZE(rgKeys));

            // REVIEW: psb?
            pszCaption = SHGetCaption(medium.hGlobal);
            SHOpenPropSheet(pszCaption, rgKeys, cKeys,
                                &CLSID_ShellFileDefExt, pps->pdtobj, NULL, pps->pStartPage);
            if (pszCaption)
                SHFree(pszCaption);

            SHRegCloseKeys(rgKeys, cKeys);

            if (SHGetPathFromIDList(pidl, szPath))
            {
                if (lstrcmpi(PathFindExtension(szPath), TEXT(".pif")) == 0)
                {
                    DebugMsg(TF_FSTREE, TEXT("cSHCNRF_pt: DOS properties done, generating event."));
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                }
            }

            ILFree(pidl);
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return 0;
}



//
// Display a property sheet for a set of files.
// The data object supplied must provide the "Shell IDList Array"
// clipboard format.
// The dwFlags argument is provided for future expansion.  It is
// currently unused.
//
STDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags)
{
    return SHLaunchPropSheet(CFSFolder::_PropertiesThread, pdtobj, 0, NULL, NULL);
}

HMENU FindMenuBySubMenuID(HMENU hmenu, UINT id, LPINT pIndex)
{
    HMENU hmenuReturn = NULL;
    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID;
    mii.cch = 0;        // just in case...

    for (int cMax = GetMenuItemCount(hmenu) - 1 ; cMax >= 0 ; cMax--)
    {
        HMENU hmenuSub = GetSubMenu(hmenu, cMax);
        if (hmenuSub && GetMenuItemInfo(hmenuSub, 0, TRUE, &mii))
        {
            if (mii.wID == id) 
            {
                // found it!
                hmenuReturn = hmenuSub;
                break;
            }
        }
    }
    if (hmenuReturn && pIndex)
        *pIndex = cMax;
    return hmenuReturn;
}

void DeleteMenuBySubMenuID(HMENU hmenu, UINT id)
{
    int i;

    if (FindMenuBySubMenuID(hmenu, id, &i))
    {
        DeleteMenu(hmenu, i, MF_BYPOSITION);
    }
}

// fMask is from CMIC_MASK_*
STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetIDListFromUnk(psf, &pidl);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];

        if (SHGetPathFromIDList(pidl, szPath))
        {
            UINT fCreateLinkFlags;
            int cItems = DataObj_GetHIDACount(pdtobj);
            LPITEMIDLIST *ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * cItems);
            // passing ppidl == NULL is correct in failure case

            if ((pszDir == NULL) || (lstrcmpi(pszDir, szPath) == 0))
            {
                // create the link in the current folder
                fCreateLinkFlags = SHCL_USETEMPLATE;
            }
            else
            {
                // this is a sys menu, ask to create on desktop
                fCreateLinkFlags = SHCL_USETEMPLATE | SHCL_USEDESKTOP;
                if (!(fMask & CMIC_MASK_FLAG_NO_UI))
                {
                    fCreateLinkFlags |= SHCL_CONFIRM;
                }
            }

            hr = SHCreateLinks(hwnd, szPath, pdtobj, fCreateLinkFlags, ppidl);

            if (ppidl)
            {
                // select those objects;
                HWND hwndSelect = ShellFolderViewWindow(hwnd);

                // select the new links, but on the first one deselect all other selected things

                for (int i = 0; i < cItems; i++)
                {
                    if (ppidl[i])
                    {
                        SendMessage(hwndSelect, SVM_SELECTITEM,
                            i == 0 ? SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED :
                                     SVSI_SELECT,
                            (LPARAM)ILFindLastID(ppidl[i]));
                        ILFree(ppidl[i]);
                    }
                }
                LocalFree((HLOCAL)ppidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
        ILFree(pidl);
    }
    return hr;
}

// Parameter to the "Delete" thread.
//
typedef struct {
    IDataObject     *pDataObj;      // null on entry to thread proc
    IStream         *pstmDataObj;   // marshalled data object
    HWND            hwndOwner;
    UINT            uFlags;
    UINT            fOptions;
} FSDELTHREADPARAM;

void FreeFSDELThreadParam(FSDELTHREADPARAM * pfsthp)
{
    ATOMICRELEASE(pfsthp->pDataObj);
    ATOMICRELEASE(pfsthp->pstmDataObj);
    LocalFree(pfsthp);
}

DWORD CALLBACK FileDeleteThreadProc(void *pv)
{
    FSDELTHREADPARAM *pfsthp = (FSDELTHREADPARAM *)pv;

    CoGetInterfaceAndReleaseStream(pfsthp->pstmDataObj, IID_PPV_ARG(IDataObject, &pfsthp->pDataObj));
    pfsthp->pstmDataObj = NULL;

    if (pfsthp->pDataObj)
        DeleteFilesInDataObject(pfsthp->hwndOwner, pfsthp->uFlags, pfsthp->pDataObj, pfsthp->fOptions);

    FreeFSDELThreadParam(pfsthp);

    return 0;
}

//
// IContextMenuCB
// right click context menu for items handler
//
// Returns:
//      S_OK, if successfully processed.
//      S_FALSE, if default code should be used.
//
STDMETHODIMP CFSFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;

            // corel relies on the hard coded send to menu so we give them one
            BOOL bCorelSuite7Hack = (SHGetAppCompatFlags(ACF_CONTEXTMENU) & ACF_CONTEXTMENU);
            if (bCorelSuite7Hack)
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_FSVIEW_ITEM_COREL7_HACK, 0, pqcm);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMANDEX:
        {
            DFMICS *pdfmics = (DFMICS *)lParam;
            switch (wParam)
            {
            case DFM_CMD_DELETE:

                // try not to do delete on the UI thread
                // with System Restore it may be slow
                //
                // NOTE: we need to test to make sure this is acceptable as the data
                // object may have come from a data object extension, for example a
                // scrap file. but that is a very rare case (DataObj_CanGoAsync() will almost always
                // return true).

                hr = E_FAIL;
                if ((pdfmics->fMask & CMIC_MASK_ASYNCOK) && DataObj_CanGoAsync(pdtobj))
                {
                    FSDELTHREADPARAM *pfsthp;
                    hr = SHLocalAlloc(sizeof(*pfsthp), &pfsthp);
                    if (SUCCEEDED(hr))
                    {
                        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pfsthp->pstmDataObj);
                        if (SUCCEEDED(hr))
                        {
                            pfsthp->hwndOwner = hwnd;
                            pfsthp->uFlags = pdfmics->fMask;
                            //  dont allow undo in the recent folder.
                            pfsthp->fOptions = _IsCSIDL(CSIDL_RECENT) ? SD_NOUNDO : 0;

                            // create another thread to avoid blocking the source thread.
                            if (!SHCreateThread(FileDeleteThreadProc, pfsthp, CTF_COINIT, NULL))
                            {
                                hr = E_FAIL;
                            }
                        }

                        if (FAILED(hr))
                        {
                            FreeFSDELThreadParam(pfsthp);  // cleanup
                        }
                    }
                }

                if (S_OK != hr)
                {
                    // could not go async, do it sync here
                    // dont allow undo in the recent folder.
                    hr = DeleteFilesInDataObject(hwnd, pdfmics->fMask, pdtobj,
                        _IsCSIDL(CSIDL_RECENT) ? SD_NOUNDO : 0);
                }
            
                break;

            case DFM_CMD_LINK:
                hr = CFSFolder_CreateLinks(hwnd, psf, pdtobj, (LPCTSTR)pdfmics->lParam, pdfmics->fMask);
                break;

            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(_PropertiesThread, pdtobj, (LPCTSTR)pdfmics->lParam, NULL, _pidl);
                break;

            default:
                // This is common menu items, use the default code.
                hr = S_FALSE;
                break;
            }
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

HRESULT CFSFolder::_CreateContextMenu(HWND hwnd, LPCIDFOLDER pidf, LPCITEMIDLIST *apidl, UINT cidl, IContextMenu **ppcm)
{
    //  we need a key for each
    //  1. UserCustomized
    //  2. default Progid
    //  3. SFA\.ext
    //  4. SFA\PerceivedType
    //  5. * or Folder
    //  6. AllFileSystemObjects
    //  (?? 7. maybe pszProvider ??)
    IAssociationArray *paa;
    CFileSysItemString fsi(pidf);
    fsi.AssocCreate(this, TRUE, IID_PPV_ARG(IAssociationArray, &paa));

    IShellFolder *psfToPass;        // May be an Aggregate...
    HRESULT hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
    if (SUCCEEDED(hr))
    {
        DEFCONTEXTMENU dcm = {
            hwnd,
            SAFECAST(this, IContextMenuCB *),
            _pidl,
            psfToPass,
            cidl,
            apidl,
            paa,
            0,
            NULL};

        hr = CreateDefaultContextMenu(&dcm, ppcm);
        psfToPass->Release();
    }

    if (paa)
        paa->Release();

    return hr;
}

HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);


HRESULT CFSFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                 REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDFOLDER pidf = cidl ? _IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if (pidf &&
        (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
    {
        hr = _CreateDefExtIcon(pidf, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu) && pidf)
    {
        hr = _CreateContextMenu(hwnd, pidf, apidl, cidl, (IContextMenu **)ppv);
    }
    else if (IsEqualIID(riid, IID_IDataObject) && cidl)
    {
        IDataObject *pdtInner = NULL;
        if ((cidl == 1) && pidf)
        {
            _LoadHandler(pidf, STGM_READ, TEXT("DataHandler"), IID_PPV_ARG(IDataObject, &pdtInner));
        }

        hr = SHCreateFileDataObject(_pidl, cidl, apidl, pdtInner, (IDataObject **)ppv);

        if (pdtInner)
            pdtInner->Release();
    }
    else if (IsEqualIID(riid, IID_IDropTarget) && pidf)
    {
        CLSID clsid;
        if (_IsFolder(pidf) || (_GetJunctionClsid(pidf, &clsid) && !SHQueryShellFolderValue(&clsid, L"UseDropHandler")))
        {
            IShellFolder *psfT;
            hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psfT));
            if (SUCCEEDED(hr))
            {
                hr = psfT->CreateViewObject(hwnd, riid, ppv);
                psfT->Release();
            }
        }
        else
        {
            // old code supported absolute PIDLs here. that was bogus...
            ASSERT(ILIsEmpty(apidl[0]) || (ILFindLastID(apidl[0]) == apidl[0]));
            ASSERT(_IsFile(pidf) || _IsSimpleID(pidf));

            hr = _LoadHandler(pidf, STGM_READ, TEXT("DropHandler"), riid, ppv);
        }
    }
    else if (IsEqualIID(riid, IID_ICustomIconManager) && pidf)
    {
        if (_IsFileFolder(pidf))
        {
            TCHAR szItemPath[MAX_PATH];
            szItemPath[0] = NULL;
            hr = _GetPath(szItemPath);
            if (SUCCEEDED(hr))
            {
                // No support in ICustomIconManager for remote shares.
                if (PathIsNetworkPath(szItemPath))
                    hr = E_NOTIMPL;
                else
                {
                    hr = CFileFolderIconManager_Create(this, (LPCITEMIDLIST)pidf, riid, ppv);
                }
            }
         }
         else
         {
            hr = E_NOTIMPL;
         }
    }
    else if (pidf)
    {
        //  too many people bogusly register extractors that
        //  dont work as well as ours for images
        //  we hard code our list of supported types.
        if (IsEqualIID(riid, IID_IExtractImage))
        {
            hr = _CreateShimgvwExtractor(pidf, riid, ppv);
        }

        if (FAILED(hr))
            hr = _LoadHandler(pidf, STGM_READ, NULL, riid, ppv);
        
        if (FAILED(hr))
        {
            if (IsEqualIID(riid, IID_IQueryInfo))
            {
                hr = _GetToolTipForItem(pidf, riid, ppv);
            }
            else if (IsEqualIID(riid, IID_IQueryAssociations)
                   || IsEqualIID(riid, IID_IAssociationArray))
            {
                hr = _AssocCreate(pidf, riid, ppv);
            }
            else if ((IsEqualIID(riid, IID_IExtractImage) || 
                     IsEqualIID(riid, IID_IExtractLogo)) && _IsFileFolder(pidf))
            {
                    // default handler type, use the IID_ as the key to open for the handler
                    // if it is an image extractor, then check to see if it is a per-folder logo...
                    hr = CFolderExtractImage_Create(this, (LPCITEMIDLIST)pidf, riid, ppv);
            }
        }
    }

    return hr;
}

HRESULT CFSFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return E_NOTIMPL;
}

HRESULT CFSFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

LPCIDFOLDER CFSFolder::_FindJunction(LPCIDFOLDER pidf)
{
    for (; pidf->cb; pidf = _Next(pidf))
    {
        if (_IsJunction(pidf))
            return pidf;        // true junction (folder.{guid} folder\desktop.ini)

        if (_IsFile(pidf))
        {
            DWORD dwFlags = _GetClassFlags(pidf);
            if (dwFlags & (SHCF_IS_BROWSABLE | SHCF_IS_SHELLEXT))
                return pidf;    // browsable file (.HTM)
        }
    }

    return NULL;
}

// return IDLIST of item just past the junction point (if there is one)
// if there's no next pointer, return NULL.

LPCITEMIDLIST CFSFolder::_FindJunctionNext(LPCIDFOLDER pidf)
{
    pidf = _FindJunction(pidf);
    if (pidf)
    {
        // cast here represents the fact that this data is opaque
        LPCITEMIDLIST pidl = (LPCITEMIDLIST)_Next(pidf);
        if (!ILIsEmpty(pidl))
            return pidl;        // first item past junction
    }
    return NULL;
}

void CFSFolder::_UpdateItem(LPCIDFOLDER pidf)
{
    LPITEMIDLIST pidlAbs = ILCombine(_pidl, (LPCITEMIDLIST)pidf);
    if (pidlAbs)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_FLUSH | SHCNF_IDLIST, pidlAbs, NULL);
        ILFree(pidlAbs);
    }
}

HRESULT CFSFolder::_SetLocalizedDisplayName(LPCIDFOLDER pidf, LPCWSTR pszName)
{
    HRESULT hr = E_FAIL;
    WCHAR sz[MAX_PATH];
    CFileSysItemString fsi(pidf);
    if (*pszName == TEXT('@') && SUCCEEDED(SHLoadIndirectString(pszName, sz, ARRAYSIZE(sz), NULL)))
    {
        TCHAR szPath[MAX_PATH];
        //
        //  this is a localized resource.  
        //  save this off as the items UI name.
        //
        if (_IsFolder(pidf))
        {
            if (SUCCEEDED(_GetPathForItem(pidf, szPath))
            && SetFolderString(TRUE, szPath, _pszNetProvider, STRINI_CLASSINFO, TEXT("LocalizedResourceName"), pszName))
            {
                //  we need to insure the bits are set for MUI on upgraded users
                //  PathMakeSystemFolder(szPath);
                hr = S_OK;
            }
        }
        else
        {
            _GetPath(szPath);
            if (SetFolderString(TRUE, szPath, _pszNetProvider, TEXT("LocalizedFileNames"), fsi.FSName(), pszName))
                hr = S_OK;
        }
    }
    else 
    {
        if (fsi.HasResourceName())
        {
            if (*pszName)
            {
                DWORD cb = CbFromCch(lstrlen(pszName)+1);
                //  set the registry overrides
                if (S_OK == SKSetValueW(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", fsi.ResourceName(), REG_SZ, pszName, cb))
                {
                    hr = S_OK;
                }
            }
            else 
            {
                SKDeleteValue(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", fsi.ResourceName());            
                hr = S_OK;
            }
        }
    }
    
    if (SUCCEEDED(hr))
        _UpdateItem(pidf);

    return hr;
}

HRESULT CFSFolder::_NormalGetDisplayNameOf(LPCIDFOLDER pidf, STRRET *pStrRet)
{
    //
    //  WARNING - Some apps (e.g., Norton Uninstall Deluxe)
    //  don't handle STRRET_WSTR properly.  NT4's shell32
    //  returned STRRET_WSTR only if it had no choice, so these apps
    //  seemed to run just fine on NT as long as you never had any
    //  UNICODE filenames.  We must preserve the NT4 behavior or
    //  these buggy apps start blowing chunks.
    //
    //  if this is still important, we will apphack these guys
    CFileSysItemString fsi(pidf);
    if (SHGetAppCompatFlags(ACF_ANSIDISPLAYNAMES) & ACF_ANSIDISPLAYNAMES)
    {
        pStrRet->uType = STRRET_CSTR;
        SHUnicodeToAnsi(fsi.UIName(this), pStrRet->cStr, ARRAYSIZE(pStrRet->cStr));
        return S_OK;
    }
    return StringToStrRet(fsi.UIName(this), pStrRet);
}

HRESULT CFSFolder::_NormalDisplayName(LPCIDFOLDER pidf, LPTSTR psz, UINT cch)
{
    CFileSysItemString fsi(pidf);
    StrCpyN(psz, fsi.UIName(this), cch);
    return S_OK;
}

HRESULT CFSFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTRRET pStrRet)
{
    HRESULT hr = S_FALSE;
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        TCHAR szPath[MAX_PATH];
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                _CopyName(pidf, szPath, ARRAYSIZE(szPath));
                if (dwFlags & SHGDN_FORADDRESSBAR)
                {
                    LPTSTR pszExt = PathFindCLSIDExtension(szPath, NULL);
                    if (pszExt)
                        *pszExt = 0;
                }

                if (ILIsEmpty(pidlNext))    // single level idlist
                    hr = StringToStrRet(szPath, pStrRet);
                else
                    hr = ILGetRelDisplayName(this, pStrRet, pidl, szPath, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_BACKSLASH), dwFlags);
            }
            else
            {
                LPIDFOLDER pidfBind;
                LPCITEMIDLIST pidlRight;

                hr = _GetJunctionForBind(pidf, &pidfBind, &pidlRight);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_OK)
                    {
                        IShellFolder *psfJctn;
                        hr = _Bind(NULL, pidfBind, IID_PPV_ARG(IShellFolder, &psfJctn));
                        if (SUCCEEDED(hr))
                        {
                            hr = psfJctn->GetDisplayNameOf(pidlRight, dwFlags, pStrRet);
                            psfJctn->Release();
                        }
                        ILFree((LPITEMIDLIST)pidfBind);
                    }
                    else
                    {
                        hr = _GetPathForItem(pidf, szPath);
                        if (SUCCEEDED(hr))
                        {
                            if (dwFlags & SHGDN_FORADDRESSBAR)
                            {
                                LPTSTR pszExt = PathFindCLSIDExtension(szPath, NULL);
                                if (pszExt)
                                    *pszExt = 0;
                            }
                            hr = StringToStrRet(szPath, pStrRet);
                        }
                    }
                }
            }
        }
        else if (_IsCSIDL(CSIDL_RECENT) && 
                 SUCCEEDED(RecentDocs_GetDisplayName((LPCITEMIDLIST)pidf, szPath, SIZECHARS(szPath))))
        {
            LPITEMIDLIST pidlRecent;
            WIN32_FIND_DATA wfd = {0};

            StrCpyN(wfd.cFileName, szPath, SIZECHARS(wfd.cFileName));

            if (SUCCEEDED(_CreateIDList(&wfd, NULL, &pidlRecent)))
            {
                hr = _NormalGetDisplayNameOf((LPCIDFOLDER)pidlRecent, pStrRet);
                ILFree(pidlRecent);
            }
                        
        }
        else
        {
            ASSERT(ILIsEmpty(pidlNext));    // this variation should be single level

            hr = _NormalGetDisplayNameOf(pidf, pStrRet);
        }
    }
    else
    {
        if (IsSelf(1, &pidl) && 
            ((dwFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
        {
            TCHAR szPath[MAX_PATH];
            hr = _GetPath(szPath);
            if (SUCCEEDED(hr))
                hr = StringToStrRet(szPath, pStrRet);
        }
        else
        {
            hr = E_INVALIDARG;
            TraceMsg(TF_WARNING, "CFSFolder::GetDisplayNameOf() failing on PIDL %s", DumpPidl(pidl));
        }
    }
    return hr;
}

void DoSmartQuotes(LPTSTR pszName)
{
    LPTSTR pszFirst = StrChr(pszName, TEXT('"'));
    if (pszFirst)
    {
        LPTSTR pszSecond = StrChr(pszFirst + 1, TEXT('"'));
        if (pszSecond)
        {
            if (NULL == StrChr(pszSecond + 1, TEXT('"')))
            {
                *pszFirst  = 0x201C;    // left double quotation
                *pszSecond = 0x201D;    // right double quotation
            }
        }
    }
}

HRESULT _PrepareNameForRename(LPTSTR pszName)
{
    if (*pszName)
    {
        HRESULT hr = _CheckPortName(pszName);
        if (SUCCEEDED(hr))
        {
            DoSmartQuotes(pszName);
        }
        return hr;
    }
    // avoid a bogus error msg with blank name (treat as user cancel)
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);
}

HRESULT CFSFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                             DWORD dwFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl) 
        *ppidl = NULL;

    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        CFileSysItemString fsi(pidf);
        TCHAR szNewName[MAX_PATH];

        SHUnicodeToTChar(pszName, szNewName, ARRAYSIZE(szNewName));

        PathRemoveBlanks(szNewName);    // leading and trailing blanks

        if (dwFlags == SHGDN_NORMAL || dwFlags == SHGDN_INFOLDER)
        {
            hr = _SetLocalizedDisplayName(pidf, pszName);

            if (SUCCEEDED(hr))
            {
                // Return the new pidl if ppidl is specified.
                if (ppidl)
                    return _CreateIDListFromName(fsi.FSName(), -1, NULL, ppidl);
            }
            else if (*pszName == TEXT('@') && PathParseIconLocation(szNewName + 1))
            {
                // this is a localized string (eg "@C:\WINNT\System32\shell32.dll,-3")
                // so do not go on and try to call SHRenameFileEx 
                return hr;
            }
        }

        if (FAILED(hr))
        {
            hr = _PrepareNameForRename(szNewName);
            if (SUCCEEDED(hr))
            {
                TCHAR szDir[MAX_PATH], szOldName[MAX_PATH];
                _CopyName(pidf, szOldName, ARRAYSIZE(szOldName));

                // If the extension is hidden
                if (!(dwFlags & SHGDN_FORPARSING) && !fsi.ShowExtension(_DefaultShowExt()))
                {
                    // copy it from the old name
                    StrCatBuff(szNewName, PathFindExtension(szOldName), ARRAYSIZE(szNewName));
                }

                hr = _GetPath(szDir);
                if (SUCCEEDED(hr))
                {
                    UINT cchDirLen = lstrlen(szDir);

                    // There are cases where the old name exceeded the maximum path, which
                    // would give a bogus error message.  To avoid this we should check for
                    // this case and see if using the short name for the file might get
                    // around this...
                    //
                    if (cchDirLen + lstrlen(szOldName) + 2 > MAX_PATH)
                    {
                        if (cchDirLen + lstrlenA(fsi.AltName()) + 2 <= MAX_PATH)
                            SHAnsiToTChar(fsi.AltName(), szOldName, ARRAYSIZE(szOldName));
                    }

                    // do a binary compare, locale insenstive compare to avoid mappings of
                    // single chars into multiple and the reverse. specifically german
                    // sharp-S and "ss"

                    if (StrCmpC(szOldName, szNewName) == 0)
                    {
                        // when the before and after strings are identical we're okay with that.
                        // SHRenameFileEx would return -1 in that case -- we check here to save
                        // some stack.
                        hr = S_OK;
                    }
                    else
                    {
                        //  We need to impl ::SetSite() and pass it to SHRenameFile
                        //  to go modal if we display UI.

                        int iRes = SHRenameFileEx(hwnd, NULL, szDir, szOldName, szNewName);
                        hr = HRESULT_FROM_WIN32(iRes);
                    }
                    if (SUCCEEDED(hr) && ppidl)
                    {
                        // Return the new pidl if ppidl is specified.
                        hr = _CreateIDListFromName(szNewName, -1, NULL, ppidl);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_FindDataFromIDFolder(LPCIDFOLDER pidf, WIN32_FIND_DATAW *pfd, BOOL fAllowSimplePid)
{
    HRESULT hr;

    CFileSysItemString fsi(pidf);
    if (!fAllowSimplePid)
    {
        hr = fsi.GetFindData(pfd);
    }
    else
    {
        hr = fsi.GetFindDataSimple(pfd);
    }

    return hr;
}


/***

To avoid registry explosion, each pidl is passed to each handler.

    HKCR\Folder\ColumnHandlers
      <clsid>
        "" = "Docfile handler"
      <clsid>
        "" = "Imagefile handler"

***/

void CFSFolder::_DestroyColHandlers()
{
    if (_hdsaColHandlers)
    {
        for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
        {
            COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
            if (pcle->pcp)
                pcle->pcp->Release();
        }
        DSA_Destroy(_hdsaColHandlers);
        _hdsaColHandlers = NULL;
    }
}

// returns the n'th handler for a given column
BOOL CFSFolder::_FindColHandler(UINT iCol, UINT iN, COLUMNLISTENTRY *pcle)
{
    for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
    {
        COLUMNLISTENTRY *pcleWalk = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
        if (pcleWalk->iColumnId == iCol)
        {
            if (iN-- == 0)
            {
                *pcle = *pcleWalk;
                return TRUE;
            }
        }
    }
    return FALSE;
}

HRESULT CFSFolder::_LoadColumnHandlers()
{
    //  Have we been here?
    if (NULL != _hdsaColHandlers)
        return S_OK;   // nothing to do.
    
    ASSERT(0 == _dwColCount);

    SHCOLUMNINIT shci = {0};
    //  retrieve folder path for provider init
    HRESULT hr = _GetPathForItem(NULL, shci.wszFolder);
    if (SUCCEEDED(hr))
    {
        _hdsaColHandlers = DSA_Create(sizeof(COLUMNLISTENTRY), 5);
        if (_hdsaColHandlers)
        {        
            int iUniqueColumnCount = 0;
            HKEY hkCH;
            // Enumerate HKCR\Folder\Shellex\ColumnProviders
            // note: this really should have been "Directory", not "Folder"
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Folder\\shellex\\ColumnHandlers"), &hkCH))
            {
                TCHAR szHandlerCLSID[GUIDSTR_MAX];
                int iHandler = 0;

                while (ERROR_SUCCESS == RegEnumKey(hkCH, iHandler++, szHandlerCLSID, ARRAYSIZE(szHandlerCLSID)))
                {
                    CLSID clsid;
                    IColumnProvider *pcp;

                    if (SUCCEEDED(SHCLSIDFromString(szHandlerCLSID, &clsid)) && 
                        SUCCEEDED(SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IColumnProvider, &pcp))))
                    {
                        if (SUCCEEDED(pcp->Initialize(&shci)))
                        {
                            int iCol = 0;
                            COLUMNLISTENTRY cle;

                            cle.pcp = pcp;
                            while (S_OK == pcp->GetColumnInfo(iCol++, &cle.shci))
                            {
                                cle.pcp->AddRef();
                                cle.iColumnId = iUniqueColumnCount++;

                                // Check if there's already a handler for this column ID,
                                for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
                                {
                                    COLUMNLISTENTRY *pcleLoop = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
                                    if (IsEqualSCID(pcleLoop->shci.scid, cle.shci.scid))
                                    {
                                        cle.iColumnId = pcleLoop->iColumnId;    // set the iColumnId to the same as the first one
                                        iUniqueColumnCount--; // so our count stays right
                                        break;
                                    }
                                }
                                DSA_AppendItem(_hdsaColHandlers, &cle);
                            }
                        }
                        pcp->Release();
                    }
                }
                RegCloseKey(hkCH);
            }

            // Sanity check
            if (!DSA_GetItemCount(_hdsaColHandlers))
            {
                // DSA_Destroy(*phdsa);
                ASSERT(iUniqueColumnCount==0);
                iUniqueColumnCount = 0;
            }
            _dwColCount = (DWORD)iUniqueColumnCount;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//  Initializes a SHCOLUMNDATA block.
HRESULT CFSFolder::_InitColData(LPCIDFOLDER pidf, SHCOLUMNDATA* pscd)
{
    ZeroMemory(pscd, sizeof(*pscd));

    HRESULT hr = _GetPathForItem(pidf, pscd->wszFile);
    if (SUCCEEDED(hr))
    {
        pscd->pwszExt = PathFindExtensionW(pscd->wszFile);
        pscd->dwFileAttributes = pidf->wAttrs;

        if (FILE_ATTRIBUTE_OFFLINE & pscd->dwFileAttributes)
            hr = E_FAIL;
        else if (_bUpdateExtendedCols)
        {
            // set the dwFlags member to tell the col handler to
            // not take data from it's cache
            pscd->dwFlags = SHCDF_UPDATEITEM;
            _bUpdateExtendedCols = FALSE;   // only do this once!
        }
    }
    return hr;
}

// Note:
//  Setting _tbOfflineCSC = TRIBIT_UNDEFINED will retest the connection (good for a refresh).
//  Setting _tbOfflineCSC = { other } will use a little cache hooey for perf.
//
// Return:
//  TRUE    pidl is offline
//  FALSE   otherwise
//
BOOL CFSFolder::_IsOfflineCSC(LPCIDFOLDER pidf)
{
    TCHAR szPath[MAX_PATH];

    // Update local cached answer for _pidl (folder).
    if (_tbOfflineCSC == TRIBIT_UNDEFINED)
    {
        if (SUCCEEDED(_GetPath(szPath)) && _IsOfflineCSC(szPath))
            _tbOfflineCSC = TRIBIT_TRUE;
        else
            _tbOfflineCSC = TRIBIT_FALSE;
    }
    ASSERT(_tbOfflineCSC != TRIBIT_UNDEFINED);

    // Calculate answer for pidl.
    BOOL bIsOffline;
    if (_tbOfflineCSC == TRIBIT_TRUE)
        bIsOffline = TRUE;
    else
    {
        bIsOffline = _IsFolder(pidf) && SUCCEEDED(_GetPathForItem(pidf, szPath)) && _IsOfflineCSC(szPath);
    }

    return bIsOffline;
}

// Make sure we have a UNC \\server\share path.  Do this before checking
// whether CSC is enabled, to avoid loading CSCDLL.DLL unless absolutely
// necessary.

BOOL CFSFolder::_IsOfflineCSC(LPCTSTR pszPath)
{
    BOOL bUNC = FALSE;
    TCHAR szUNC[MAX_PATH];
    szUNC[0] = 0;

    if (PathIsUNC(pszPath))
    {
        StrCpyN(szUNC, pszPath, ARRAYSIZE(szUNC));
    }
    else if (pszPath[1] == TEXT(':'))
    {
        TCHAR szLocalName[3] = { pszPath[0], pszPath[1], TEXT('\0') };

        // Call GetDriveType() before WNetGetConnection(), to
        // avoid loading MPR.DLL unless absolutely necessary.
        if (DRIVE_REMOTE == GetDriveType(szLocalName))
        {
            // ignore return, szUNC filled in on success
            DWORD cch = ARRAYSIZE(szUNC);
            WNetGetConnection(szLocalName, szUNC, &cch);
        }
    }

    return szUNC[0] && 
           PathStripToRoot(szUNC) &&
           (GetOfflineShareStatus(szUNC) == OFS_OFFLINE);
}

HRESULT CFSFolder::_ExtendedColumn(LPCIDFOLDER pidf, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = _LoadColumnHandlers();
    if (SUCCEEDED(hr))
    {
        if (iColumn < _dwColCount)
        {
            if (NULL == pidf)
            {
                COLUMNLISTENTRY cle;
                if (_FindColHandler(iColumn, 0, &cle))
                {
                    pDetails->fmt = cle.shci.fmt;
                    pDetails->cxChar = cle.shci.cChars;
                    hr = StringToStrRet(cle.shci.wszTitle, &pDetails->str);
                }
                else
                {
                    hr = E_NOTIMPL;
                }
            }
            else
            {
                SHCOLUMNDATA shcd;
                hr = _InitColData(pidf, &shcd);
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;    // loop below will try to reset this

                    // loop through all the column providers, breaking when one succeeds
                    COLUMNLISTENTRY cle;
                    for (int iTry = 0; _FindColHandler(iColumn, iTry, &cle); iTry++)
                    {
                        VARIANT var = {0};

                        hr = cle.pcp->GetItemData(&cle.shci.scid, &shcd, &var);
                        if (SUCCEEDED(hr))
                        {
                            if (S_OK == hr)
                            {
                                PROPERTYUI_FORMAT_FLAGS puiff = PUIFFDF_DEFAULT;
                                if (pDetails->fmt == LVCFMT_RIGHT_TO_LEFT)
                                {
                                    puiff = PUIFFDF_RIGHTTOLEFT;
                                }

                                TCHAR szTemp[MAX_PATH];
                                hr = SHFormatForDisplay(cle.shci.scid.fmtid,
                                                        cle.shci.scid.pid,
                                                        (PROPVARIANT*)&var,
                                                        puiff,
                                                        szTemp,
                                                        ARRAYSIZE(szTemp));
                                if (SUCCEEDED(hr))
                                {
                                    hr = StringToStrRet(szTemp, &pDetails->str);
                                }

                                VariantClear(&var);
                                break;
                            }
                            VariantClear(&var);
                        }
                    }

                    // if we failed to find a value here return empty success so we don't
                    // endlessly pester all column handlers for this column/item.
                    if (S_OK != hr)
                    {
                        pDetails->str.uType = STRRET_CSTR;
                        pDetails->str.cStr[0] = 0;
                        hr = S_FALSE; 
                    }
                }
            }
        }
        else
            hr = E_NOTIMPL; // the bogus return value defview expects...
    }

    return hr;
}

HRESULT CFSFolder::_CompareExtendedProp(int iColumn, LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    HRESULT hr = _LoadColumnHandlers();
    if (SUCCEEDED(hr))
    {
        if ((DWORD)iColumn < _dwColCount)
        {
            COLUMNLISTENTRY cle;
            if (_FindColHandler(iColumn, 0, &cle))
            {
                int iRet = CompareBySCID(this, &cle.shci.scid, (LPCITEMIDLIST)pidf1, (LPCITEMIDLIST)pidf2);
                hr = ResultFromShort(iRet);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CFSFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    LPCIDFOLDER pidf = _IsValidID(pidl);

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;

    if (iColumn >= ARRAYSIZE(c_fs_cols))
    {
        return _ExtendedColumn(pidf, iColumn - ARRAYSIZE(c_fs_cols), pDetails);
    }

    if (!pidf)
    {
        return GetDetailsOfInfo(c_fs_cols, ARRAYSIZE(c_fs_cols), iColumn, pDetails);
    }

    TCHAR szTemp[MAX_PATH];
    szTemp[0] = 0;

    switch (iColumn)
    {
    case FS_ICOL_NAME:
        _NormalDisplayName(pidf, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_SIZE:
        if (!_IsFolder(pidf))
        {
            ULONGLONG cbSize = _Size(pidf);
            StrFormatKBSize(cbSize, szTemp, ARRAYSIZE(szTemp));
        }
        break;

    case FS_ICOL_TYPE:
        _GetTypeNameBuf(pidf, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_WRITETIME:
        DosTimeToDateTimeString(pidf->dateModified, pidf->timeModified, szTemp, ARRAYSIZE(szTemp), pDetails->fmt & LVCFMT_DIRECTION_MASK);
        break;

    case FS_ICOL_CREATETIME:
    case FS_ICOL_ACCESSTIME:
        {
            WIN32_FIND_DATAW wfd;
            if (SUCCEEDED(_FindDataFromIDFolder(pidf, &wfd, FALSE)))
            {
                DWORD dwFlags = FDTF_DEFAULT;

                switch (pDetails->fmt)
                {
                case LVCFMT_LEFT_TO_RIGHT:
                    dwFlags |= FDTF_LTRDATE;
                    break;

                case LVCFMT_RIGHT_TO_LEFT:
                    dwFlags |= FDTF_RTLDATE;
                    break;
                }
                FILETIME ft = (iColumn == FS_ICOL_CREATETIME) ? wfd.ftCreationTime : wfd.ftLastAccessTime;
                SHFormatDateTime(&ft, &dwFlags, szTemp, ARRAYSIZE(szTemp));
            }
        }
        break;

    case FS_ICOL_ATTRIB:
        BuildAttributeString(pidf->wAttrs, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_CSC_STATUS:
        LoadString(HINST_THISDLL, _IsOfflineCSC(pidf) ? IDS_CSC_STATUS_OFFLINE : IDS_CSC_STATUS_ONLINE, szTemp, ARRAYSIZE(szTemp)); 
        break;
    }
    return StringToStrRet(szTemp, &pDetails->str);
}

HRESULT CFSFolder::_GetIntroText(LPCIDFOLDER pidf, WCHAR* pwszIntroText, UINT cchIntroText)
{
    HRESULT hr = E_FAIL;
    
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPathForItem(pidf, szPath)))
    {
        // Keep the order in csidlIntroText and IntroTextCSIDLFolders, the same
        const int csidlIntroText[] = {
            CSIDL_STARTMENU,
            CSIDL_COMMON_DOCUMENTS,
            CSIDL_COMMON_PICTURES,
            CSIDL_COMMON_MUSIC
        };
        UINT csidl = GetSpecialFolderID(szPath, csidlIntroText, ARRAYSIZE(csidlIntroText));         
        if (csidl != -1)
        {
            // Keep the order in csidlIntroText and IntroTextCSIDLFolders, the same
            static struct
            {
                UINT csidl;
                UINT resid;
            } IntroTextCSIDLFolders[] = { {CSIDL_STARTMENU,         IDS_INTRO_STARTMENU},
                                          {CSIDL_COMMON_DOCUMENTS,  IDS_INTRO_SHAREDDOCS},
                                          {CSIDL_COMMON_PICTURES,   IDS_INTRO_SHAREDPICTURES},
                                          {CSIDL_COMMON_MUSIC,      IDS_INTRO_SHAREDMUSIC} };

            UINT residIntroText = 0;
            for (int i = 0; i < ARRAYSIZE(IntroTextCSIDLFolders); i++)
            {
                if (IntroTextCSIDLFolders[i].csidl == csidl)
                {
                    residIntroText = IntroTextCSIDLFolders[i].resid;
                    break;
                }
            }
            
            if (residIntroText)
            {
                if (LoadString(HINST_THISDLL, residIntroText, pwszIntroText, cchIntroText))
                {
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

DEFINE_SCID(SCID_HTMLINFOTIPFILE, PSGUID_MISC, PID_HTMLINFOTIPFILE);

BOOL GetShellClassInfoHTMLInfoTipFile(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer)
{
    TCHAR szHTMLInfoTipFile[MAX_PATH];

    BOOL fRet = GetShellClassInfo(pszPath, TEXT("HTMLInfoTipFile"),
        szHTMLInfoTipFile, ARRAYSIZE(szHTMLInfoTipFile));

    if (fRet)
    {
        LPTSTR psz = szHTMLInfoTipFile;

        if (StrCmpNI(TEXT("file://"), psz, 7) == 0) // ARRAYSIZE(TEXT("file://"))
        {
            psz += 7;   // ARRAYSIZE(TEXT("file://"))
        }

        PathCombine(psz, pszPath, psz);
        lstrcpyn(pszBuffer, psz, cchBuffer);
    }

    return fRet;
}


// These next functions are for the shell OM script support

HRESULT CFSFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    BOOL fFound;
    HRESULT hr = AssocGetDetailsOfSCID(this, pidl, pscid, pv, &fFound);
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (FAILED(hr) && !fFound && pidf)
    {
        if (IsEqualSCID(*pscid, SCID_FINDDATA))
        {
            WIN32_FIND_DATAW wfd;
            hr = _FindDataFromIDFolder(pidf, &wfd, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromBuffer(pv, &wfd, sizeof(wfd));
            }
        }
        else if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
        {
            SHDESCRIPTIONID did = {0};
            switch (((SIL_GetType(pidl) & SHID_TYPEMASK) & ~(SHID_FS_UNICODE | SHID_FS_COMMONITEM)) | SHID_FS)
            {
            case SHID_FS_FILE:      did.dwDescriptionId = SHDID_FS_FILE;      break;
            case SHID_FS_DIRECTORY: did.dwDescriptionId = SHDID_FS_DIRECTORY; break;
            default:                did.dwDescriptionId = SHDID_FS_OTHER;     break;
            }
            _GetJunctionClsid(pidf, &did.clsid);

            hr = InitVariantFromBuffer(pv, &did, sizeof(did));
        }
        else if (IsEqualSCID(*pscid, SCID_FolderIntroText))
        {
            WCHAR wszIntroText[INFOTIPSIZE];
            hr = _GetIntroText(pidf, wszIntroText, ARRAYSIZE(wszIntroText));
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStr(pv, wszIntroText);
            }
        }
        else if (IsEqualSCID(*pscid, SCID_SIZE))
        {
            TCHAR szMountPoint[MAX_PATH];

            // In case we fail
            pv->ullVal = 0;
            pv->vt = VT_UI8;

            if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
            {
                ULARGE_INTEGER uliFreeToCaller, uliTotal, uliTotalFree;

                if (SHGetDiskFreeSpaceExW(szMountPoint, &uliFreeToCaller, &uliTotal,
                    &uliTotalFree))
                {
                    pv->ullVal = uliTotal.QuadPart;
                }                
            }
            else
            {
                pv->ullVal = _Size(pidf);   // note, size for folder is 0
                pv->vt = VT_UI8;
            }

            hr = S_OK;
        }
        else if (IsEqualSCID(*pscid, SCID_FREESPACE))
        {
            TCHAR szMountPoint[MAX_PATH];
            if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
            {
                ULARGE_INTEGER uliFreeToCaller, uliTotal, uliTotalFree;

                if (SHGetDiskFreeSpaceExW(szMountPoint, &uliFreeToCaller, &uliTotal, &uliTotalFree))
                {
                    pv->ullVal = uliFreeToCaller.QuadPart;
                    pv->vt = VT_UI8;
                    hr = S_OK;
                }
            }
        }
        else if (IsEqualSCID(*pscid, SCID_WRITETIME) ||
                 IsEqualSCID(*pscid, SCID_CREATETIME) ||
                 IsEqualSCID(*pscid, SCID_ACCESSTIME))
        {
            WIN32_FIND_DATAW wfd;
            hr = _FindDataFromIDFolder(pidf, &wfd, FALSE);
            if (SUCCEEDED(hr))
            {
                FILETIME ft;
                if (pscid->pid == PID_STG_WRITETIME)
                {
                    ft = wfd.ftLastWriteTime;
                } 
                else if (pscid->pid == PID_STG_CREATETIME)
                {
                    ft = wfd.ftCreationTime;
                }
                else
                {
                    ft = wfd.ftLastAccessTime;
                }

                hr = InitVariantFromFileTime(&ft, pv);
            }
        }
        else if (IsEqualSCID(*pscid, SCID_DIRECTORY))
        {
            TCHAR szTemp[MAX_PATH];
            hr = _GetPath(szTemp);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStr(pv, szTemp);
            }
        }
        else if (IsEqualSCID(*pscid, SCID_ATTRIBUTES_DESCRIPTION))
        {
            hr = _GetAttributesDescription(pidf, pv);
        }
        else if (IsEqualSCID(*pscid, SCID_LINKTARGET))
        {
            hr = _GetLinkTarget(pidl, pv);
        }
        else if (IsEqualSCID(*pscid, SCID_CSC_STATUS))
        {
            hr = _GetCSCStatus(pidf, pv);
        }
        else if ((IsEqualSCID(*pscid, SCID_Comment) || IsEqualSCID(*pscid, SCID_HTMLINFOTIPFILE)) && 
                 _IsSystemFolder(pidf))
        {
            TCHAR szPath[MAX_PATH];
            hr = _GetPathForItem(pidf, szPath);
            if (SUCCEEDED(hr))
            {
                TCHAR szText[MAX_PATH];
                if (IsEqualSCID(*pscid, SCID_Comment))
                    GetShellClassInfoInfoTip(szPath, szText, ARRAYSIZE(szText));
                else
                    GetShellClassInfoHTMLInfoTipFile(szPath, szText, ARRAYSIZE(szText));

                hr = InitVariantFromStr(pv, szText);
            }
        }
        else if (IsEqualSCID(*pscid, SCID_COMPUTERNAME))
        {
            hr = _GetComputerName(pidf, pv);
        }
        else if (IsEqualSCID(*pscid, SCID_NETWORKLOCATION))
        {
            hr = _GetNetworkLocation(pidf, pv);
        }
        else // if (Column Handler)
        {
            int iCol = FindSCID(c_fs_cols, ARRAYSIZE(c_fs_cols), pscid);
            if (iCol >= 0)
            {
                SHELLDETAILS sd;
                hr = GetDetailsOf(pidl, iCol, &sd);
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                }
            }
            else
            {
                hr = _LoadColumnHandlers();
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                    for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
                    {
                        COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);

                        if (IsEqualSCID(*pscid, pcle->shci.scid))
                        {
                            SHCOLUMNDATA shcd;
                            hr = _InitColData(pidf, &shcd);
                            if (SUCCEEDED(hr))
                            {
                                hr = pcle->pcp->GetItemData(pscid, &shcd, pv);
                                if (S_OK == hr)
                                    break;
                                else if (SUCCEEDED(hr))
                                    VariantClear(pv);
                            }
                            else
                                break;
                        }
                    }
                }
            }
        }
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetAttributesDescription(LPCIDFOLDER pidf, VARIANT *pv)
{
    static WCHAR szR[32] = {0}; // read-only
    static WCHAR szH[32] = {0}; // hidden
    static WCHAR szS[32] = {0}; // system
    static WCHAR szC[32] = {0}; // compressed
    static WCHAR szE[32] = {0}; // encrypted
    static WCHAR szO[32] = {0}; // offline
    WCHAR szAttributes[256] = {0};
    size_t cchAttributes = ARRAYSIZE(szAttributes);
    BOOL bIsFolder = _IsFolder(pidf);

    //
    // Initialize cached values once 'n only once.
    //

    if (!szR[0])
    {
        ASSERT(!szH[0] && !szS[0] && !szC[0] && !szE[0] && !szO[0]);
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_READONLY,   szR, ARRAYSIZE(szR));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_HIDDEN,     szH, ARRAYSIZE(szH));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_SYSTEM,     szS, ARRAYSIZE(szS));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_COMPRESSED, szC, ARRAYSIZE(szC));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_ENCRYPTED,  szE, ARRAYSIZE(szE));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_OFFLINE,    szO, ARRAYSIZE(szO));
    }
    else
    {
        ASSERT(szH[0] && szS[0] && szC[0] && szE[0] && szO[0]);
    }

    //
    // Create attribute description string.
    //

    // read-only
    if ((pidf->wAttrs & FILE_ATTRIBUTE_READONLY) && !bIsFolder)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szR);

    // hidden
    if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szH);

    // system
    if ((pidf->wAttrs & FILE_ATTRIBUTE_SYSTEM) && !bIsFolder)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szS);

    // archive
    //  By design, archive is not exposed as an attribute description.  It is
    //  used by "backup applications" and in general is a loose convention no
    //  one really cares about (chrisg).  The decision to hide archive stems
    //  from a desire to keep the Details pane free of useless gargabe.  Note
    //  that in Windows 2000, archive was not exposed through the web view.

    // compressed
    if (pidf->wAttrs & FILE_ATTRIBUTE_COMPRESSED)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szC);

    // encrypted
    if (pidf->wAttrs & FILE_ATTRIBUTE_ENCRYPTED)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szE);

    // offline
    if (pidf->wAttrs & FILE_ATTRIBUTE_OFFLINE)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szO);

    return InitVariantFromStr(pv, szAttributes);
}
HRESULT CFSFolder::_GetAttributesDescriptionBuilder(LPWSTR szAttributes, size_t cchAttributes, LPWSTR szAttribute)
{
    static WCHAR szDelimiter[4] = {0};

    // Initialize cached delimiter once 'n only once.
    if (!szDelimiter[0])
    {
        LoadString(HINST_THISDLL, IDS_COMMASPACE, szDelimiter, ARRAYSIZE(szDelimiter));
    }

    // Build attribute description.
    if (!szAttributes[0])
    {
        StrNCpy(szAttributes, szAttribute, cchAttributes);
    }
    else
    {
        StrCatBuff(szAttributes, szDelimiter, cchAttributes);
        StrCatBuff(szAttributes, szAttribute, cchAttributes);
    }

    return S_OK;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetLinkTarget(LPCITEMIDLIST pidl, VARIANT *pv)
{
    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            hr = SHGetNameAndFlags(pidlTarget, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            if (SUCCEEDED(hr))
                hr = InitVariantFromStr(pv, szPath);
            ILFree(pidlTarget);
        }
        psl->Release();
    }
    return hr;
}


// GetDetailsEx() helper.
HRESULT CFSFolder::_GetNetworkLocation(LPCIDFOLDER pidf, VARIANT *pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pidf;

    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            hr = SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            if (SUCCEEDED(hr))
            {
                DWORD dwZone;
                hr = GetZoneFromUrl(szPath, NULL, &dwZone);
                if (SUCCEEDED(hr))
                {
                    TCHAR szBuffer[MAX_PATH];
                    switch (dwZone)
                    {
                        case URLZONE_LOCAL_MACHINE:
                        case URLZONE_INTRANET:
                           LoadString(g_hinst, IDS_NETLOC_LOCALNETWORK, szBuffer, ARRAYSIZE(szBuffer));
                           hr = InitVariantFromStr(pv, szBuffer);
                           break;

                        case URLZONE_INTERNET:
                           LoadString(g_hinst, IDS_NETLOC_INTERNET, szBuffer, ARRAYSIZE(szBuffer));
                           hr = InitVariantFromStr(pv, szBuffer);
                           break;

                        default:
                           hr = S_FALSE;
                           break;
                    }
                }
            }
            ILFree(pidlTarget);
        }       
        psl->Release();
    }
    return hr;
}

// GetDetailsEx() helper.

HRESULT CFSFolder::_GetComputerName(LPCIDFOLDER pidf, VARIANT *pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pidf;

    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
            {
                if (PathIsURL(szPath))
                {
                    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];

                    URL_COMPONENTS urlComps = {0};
                    urlComps.dwStructSize = sizeof(urlComps);
                    urlComps.lpszHostName = szServer;
                    urlComps.dwHostNameLength = ARRAYSIZE(szServer);

                    BOOL fResult = InternetCrackUrl(szPath, 0, ICU_DECODE, &urlComps);
                    if (fResult)
                    {
                        hr = InitVariantFromStr(pv, szServer);   
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else if (PathIsUNC(szPath))
                {
                    hr = _GetComputerName_FromPath(szPath, pv);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
            ILFree(pidlTarget);
        }
        psl->Release();
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetPath(szPath);
        if (SUCCEEDED(hr))
        {
            hr = _GetComputerName_FromPath(szPath, pv);
        }
    }
    
    if (FAILED(hr))
    {
        WCHAR sz[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_UNKNOWNGROUP, sz, ARRAYSIZE(sz));
        hr = InitVariantFromStr(pv, sz);
    }

    return hr;
}

HRESULT CFSFolder::_GetComputerName_FromPath(LPCWSTR pszPath, VARIANT *pv)
{
    HRESULT hr;

    TCHAR szPath[MAX_PATH];

    lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
    PathStripToRoot(szPath);

    if (PathIsUNC(szPath))
    {
        hr = _GetComputerName_FromUNC(szPath, pv);
    }
    else
    {
        CMountPoint* pMtPt = CMountPoint::GetMountPoint(szPath, FALSE);
        if (pMtPt)
        {
            if (pMtPt->IsRemote())
            {
                WCHAR szRemotePath[MAX_PATH];
                hr = pMtPt->GetRemotePath(szRemotePath, ARRAYSIZE(szRemotePath));
                if (SUCCEEDED(hr))
                {
                    hr = _GetComputerName_FromPath(szRemotePath, pv);
                }
            }
            else
            {
                WCHAR sz[MAX_PATH];
                LoadString(HINST_THISDLL, IDS_THISCOMPUTERGROUP, sz, ARRAYSIZE(sz));
                hr = InitVariantFromStr(pv, sz);
            }
            pMtPt->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CFSFolder::_GetComputerName_FromUNC(LPWSTR pszPath, VARIANT *pv)
{
    // strip to "\\server"
    LPWSTR psz = pszPath;
    while (*psz && *psz==L'\\')
        psz++;
    while (*psz && *psz!=L'\\')
        psz++;
    *psz = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pszPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        WCHAR szName[MAX_PATH];
        hr = SHGetNameAndFlagsW(pidl, SHGDN_INFOLDER, szName, ARRAYSIZE(szName), NULL);
        if (SUCCEEDED(hr))
        {
            hr = InitVariantFromStr(pv, szName);
        }

        ILFree(pidl);
    }

    return hr;
}

            
// GetDetailsEx() helper.
HRESULT CFSFolder::_GetCSCStatus(LPCIDFOLDER pidf, VARIANT *pv)
{
    HRESULT hr;

    // Note:
    //  Only display the status in the Details task pane if it is "Offline".

    if (_IsOfflineCSC(pidf))
    {
        WCHAR wszStatus[MAX_PATH];
        if (LoadString(HINST_THISDLL, IDS_CSC_STATUS_OFFLINE, wszStatus, ARRAYSIZE(wszStatus)))
            hr = InitVariantFromStr(pv, wszStatus);
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        VariantInit(pv);
        pv->vt = VT_NULL;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return E_NOTIMPL;
}

#define FVCBFT_MUSICFOLDER(ft)  (FVCBFT_MUSIC == ft || FVCBFT_MYMUSIC == ft || FVCBFT_MUSICARTIST == ft || FVCBFT_MUSICALBUM == ft)

BOOL CFSFolder::_ShouldNotShowColumn(UINT iColumn)
{
    BOOL fRet = FALSE;  // show by default

    if (FVCBFT_MUSICFOLDER(_nFolderType))
    {
        fRet = (iColumn == FS_ICOL_WRITETIME);  // hide this one in the music case
    }

    return fRet;
}

BOOL CFSFolder::_ShouldShowExtendedColumn(const SHCOLUMNID* pscid)
{
    BOOL fRet;

    switch(_nFolderType)
    {
    case FVCBFT_PICTURES:
    case FVCBFT_MYPICTURES:
    case FVCBFT_PHOTOALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_WhenTaken) || IsEqualSCID(*pscid, SCID_ImageDimensions));
        break;

    case FVCBFT_MUSIC:
    case FVCBFT_MYMUSIC:
    case FVCBFT_MUSICARTIST:
    case FVCBFT_MUSICALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_MUSIC_Artist) || IsEqualSCID(*pscid, SCID_MUSIC_Year)  ||
                IsEqualSCID(*pscid, SCID_MUSIC_Album)  || IsEqualSCID(*pscid, SCID_MUSIC_Track) ||
                IsEqualSCID(*pscid, SCID_AUDIO_Duration));
        break;

    case FVCBFT_VIDEOS:
    case FVCBFT_MYVIDEOS:
    case FVCBFT_VIDEOALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_AUDIO_Duration) || IsEqualSCID(*pscid, SCID_ImageDimensions));
        break;

    default:
        fRet = FALSE;
        break;
    }

    return fRet;
}

HRESULT CFSFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr = S_OK;

    *pdwState = 0;

    if (iColumn < ARRAYSIZE(c_fs_cols))
    {
        *pdwState = c_fs_cols[iColumn].csFlags;

        if (_ShouldNotShowColumn(iColumn))
        {
            *pdwState &= ~SHCOLSTATE_ONBYDEFAULT;   // flip stuff off
        }
    }
    else
    {
        iColumn -= ARRAYSIZE(c_fs_cols);
        hr = _LoadColumnHandlers();
        if (SUCCEEDED(hr))
        {
            hr = E_INVALIDARG;
            if (iColumn < _dwColCount)
            {
                COLUMNLISTENTRY cle;

                if (_FindColHandler(iColumn, 0, &cle))
                {
                    *pdwState |= (cle.shci.csFlags | SHCOLSTATE_EXTENDED | SHCOLSTATE_SLOW);
                    if (_ShouldShowExtendedColumn(&cle.shci.scid))
                    {
                        *pdwState |= SHCOLSTATE_ONBYDEFAULT;
                    }
                    else
                    {
                        *pdwState &= ~SHCOLSTATE_ONBYDEFAULT;    // strip this one
                    }
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr = MapColumnToSCIDImpl(c_fs_cols, ARRAYSIZE(c_fs_cols), iColumn, pscid);
    if (hr != S_OK)
    {
        COLUMNLISTENTRY cle;
        if (SUCCEEDED(_LoadColumnHandlers()))
        {
            iColumn -= ARRAYSIZE(c_fs_cols);

            if (_FindColHandler(iColumn, 0, &cle))
            {
                *pscid = cle.shci.scid;
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_MapSCIDToColumn(const SHCOLUMNID* pscid, UINT* puCol)
{
    HRESULT hr;

    int iCol = FindSCID(c_fs_cols, ARRAYSIZE(c_fs_cols), pscid);
    if (iCol >= 0)
    {
        *puCol = iCol;
        hr = S_OK;
    }
    else
    {
        hr = _LoadColumnHandlers();
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
            {
                COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);

                if (IsEqualSCID(*pscid, pcle->shci.scid))
                {
                    *puCol = pcle->iColumnId;
                    hr = S_OK;
                    break;
                }
            }
        }

    }

    return hr;
}

//
// N ways to get a clasid for an item
//
BOOL CFSFolder::_GetBindCLSID(IBindCtx *pbc, LPCIDFOLDER pidf, CLSID *pclsid)
{
    CFileSysItemString fsi(pidf);
    DWORD dwClassFlags = fsi.ClassFlags(FALSE);
    if (dwClassFlags & SHCF_IS_DOCOBJECT)
    {
        *pclsid = CLSID_CDocObjectFolder;
    }
    else if (fsi.GetJunctionClsid(pclsid, TRUE))
    {
        // *pclsid has the value

        // HACK: CLSID_Briefcase is use to identify the briefcase
        // but it's InProcServer is syncui.dll. we need to map that CLSID
        // to the object implemented in shell32 (CLSID_BriefcaseFolder)
        // ZEKELTODO - why isnt this a COM "TreatAs"?
        if (IsEqualCLSID(*pclsid, CLSID_Briefcase))
            *pclsid = CLSID_BriefcaseFolder;
    }
    else if (!IsEqualCLSID(CLSID_NULL, _clsidBind))
    {
        *pclsid = _clsidBind;  // briefcase forces all children this way
    }
    else
    {
        return FALSE;   // do normal binding
    }

    // TRUE -> special binding, FALSE -> normal file system binding
    return !SHSkipJunctionBinding(pbc, pclsid);
}


// initalize shell folder handlers
// in:
//      pidf  multi level file system pidl
//
// in/out:
//      *ppunk
//
// note: on failure this frees *ppunk 

HRESULT CFSFolder::_InitFolder(IBindCtx *pbc, LPCIDFOLDER pidf, IUnknown **ppunk)
{
    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra goo please
            
    LPITEMIDLIST pidlInit;
    HRESULT hr = SHILCombine(_pidl, (LPITEMIDLIST)pidf, &pidlInit);
    if (SUCCEEDED(hr))
    {
        IPersistFolder3 *ppf3;
        hr = (*ppunk)->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
        if (SUCCEEDED(hr))
        {
            PERSIST_FOLDER_TARGET_INFO pfti = {0};

            if (_csidlTrack >= 0)
            {
                // SHGetSpecialFolderlocation will return error if the target
                // doesn't exist (which is good, since that means there's
                // nothing to bind to).
                LPITEMIDLIST pidl;
                hr = SHGetSpecialFolderLocation(NULL, _csidlTrack, &pidl);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidl, (LPITEMIDLIST)pidf, &pfti.pidlTargetFolder);
                    ILFree(pidl);
                }
            }
            else if (_pidlTarget)
                hr = SHILCombine(_pidlTarget, (LPITEMIDLIST)pidf, &pfti.pidlTargetFolder);

            if (SUCCEEDED(hr))
            {
                hr = _GetPathForItem(pidf, pfti.szTargetParsingName);
                if (SUCCEEDED(hr))
                {
                    if (_pszNetProvider)
                        SHTCharToUnicode(_pszNetProvider, pfti.szNetworkProvider, ARRAYSIZE(pfti.szNetworkProvider));

                    pfti.dwAttributes = _FindLastID(pidf)->wAttrs;
                    pfti.csidl = -1;

                    hr = ppf3->InitializeEx(pbc, pidlInit, &pfti);
                }
                ILFree(pfti.pidlTargetFolder);
            }
            ppf3->Release();
        }
        else
        {
            IPersistFolder *ppf;
            hr = (*ppunk)->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Initialize(pidlInit);
                ppf->Release();

                if (hr == E_NOTIMPL)  // map E_NOTIMPL into success, the folder does not care
                    hr = S_OK;
            }
        }
        ILFree(pidlInit);
    }

    if (FAILED(hr))
    {
        ((IUnknown *)*ppunk)->Release();
        *ppunk = NULL;
    }

    return hr;
}


HRESULT CFSFolder::_InitStgFolder(LPCIDFOLDER pidf, LPCWSTR wszPath, DWORD grfMode, REFIID riid, void **ppv)
{
    IStorage *pstg;
    // pick up the storage from the pidl.
    // TODO: make this work on stuff other than docfiles
    HRESULT hr = StgGetStorageFromFile(wszPath, grfMode, &pstg);
    if (SUCCEEDED(hr))
    {
        hr = CStgFolder_CreateInstance(NULL, riid, ppv);
        if (SUCCEEDED(hr))
        {
            // we need to init CStgFolder with an IStorage that it
            // wraps, so pass it in through the bind context.
            IBindCtx *pbc;
            hr = CreateBindCtx(0, &pbc);
            if (SUCCEEDED(hr))
            {
                hr = pbc->RegisterObjectParam(STGSTR_STGTOBIND, pstg);
                if (SUCCEEDED(hr))
                    hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);
                pbc->Release();
            }

            if (FAILED(hr))
                ATOMICRELEASE(*((IUnknown **)ppv));
        }
        pstg->Release();
    }
    return hr;
}

CFSFolderPropertyBag::CFSFolderPropertyBag(CFSFolder *pFSFolder, DWORD grfMode) : 
    _cRef(1), _grfMode(grfMode), _pFSFolder(pFSFolder)
{
    _pFSFolder->AddRef();
}

CFSFolderPropertyBag::~CFSFolderPropertyBag()
{
    _pFSFolder->Release();

    // Release all the property bags
    for (int i = 0; i < ARRAYSIZE(_pPropertyBags); i++)
    {
        if (_pPropertyBags[i])
        {
            _pPropertyBags[i]->Release();
        }
    }
}

STDMETHODIMP CFSFolderPropertyBag::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFSFolderPropertyBag, IPropertyBag),       // IID_IPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
    
STDMETHODIMP_(ULONG) CFSFolderPropertyBag::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSFolderPropertyBag::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFSFolderPropertyBag::_Init(LPCIDFOLDER pidfLast)
{
    TCHAR szFolderPath[MAX_PATH];
    HRESULT hr = _pFSFolder->_GetPathForItem(pidfLast, szFolderPath);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        if (_GetIniPath((_grfMode == STGM_WRITE) || (_grfMode == STGM_READWRITE), szFolderPath, NULL, szPath))
        {
            // This is a customized folder (likely).
            // Get an IPropertyBag on it's desktop.ini.
            if (SUCCEEDED(SHCreatePropertyBagOnProfileSection(szPath, STRINI_CLASSINFO, _grfMode,
                IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_DESKTOPINI]))))
            {
                TCHAR szFolderType[128];
                if (SUCCEEDED(SHPropertyBag_ReadStr(_pPropertyBags[INDEX_PROPERTYBAG_DESKTOPINI], 
                    L"FolderType", szFolderType, ARRAYSIZE(szFolderType))))
                {
                    TCHAR szRegPath[256];

                    StrCpyN(szRegPath, REGSTR_PATH_EXPLORER L"\\FolderClasses\\", ARRAYSIZE(szRegPath));
                    StrCatN(szRegPath, szFolderType, ARRAYSIZE(szRegPath));
                    SHCreatePropertyBagOnRegKey(HKEY_CURRENT_USER, szRegPath,
                            _grfMode, IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_HKCU]));
                    SHCreatePropertyBagOnRegKey(HKEY_LOCAL_MACHINE, szRegPath,
                            _grfMode, IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_HKLM]));
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CFSFolderPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    // We first try reading HKCU\RegKeySpecifiedInDesktopIniForTheFolder,
    // then HKLM\RegKeySpecifiedInDesktopIniForTheFolder and finally
    // the desktop.ini
    HRESULT hr = E_FAIL;
    for (int i = 0; FAILED(hr) && (i < ARRAYSIZE(_pPropertyBags)); i++)
    {
        if (_pPropertyBags[i])
        {
            hr = _pPropertyBags[i]->Read(pszPropName, pvar, pErrorLog);
        }
    }
    return hr;
}

HRESULT CFSFolderPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    // We first try writing to HKCU\RegKeySpecifiedInDesktopIniForTheFolder,
    // then to HKLM\RegKeySpecifiedInDesktopIniForTheFolder and finally
    // to desktop.ini
    HRESULT hr = E_FAIL;
    for (int i = 0; FAILED(hr) && (i < ARRAYSIZE(_pPropertyBags)); i++)
    {
        if (_pPropertyBags[i])
        {
            hr = _pPropertyBags[i]->Write(pszPropName, pvar);
        }
    }
    return hr;
}

// pidfLast can be NULL, if so create the bag on this folder
HRESULT CFSFolder::_CreateFolderPropertyBag(DWORD grfMode, LPCIDFOLDER pidfLast, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFSFolderPropertyBag *pbag = new CFSFolderPropertyBag(this, grfMode);
    if (pbag)
    {
        hr = pbag->_Init(pidfLast);
        if (SUCCEEDED(hr))
        {
            hr = pbag->QueryInterface(riid, ppv);
        }

        pbag->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//
// pidfLast and pszIniPath can be NULL.
// If not NULL, pidfLast is an IN param - specifies the relative pidl of a subfolder
// inside the CFSFolder object.
// If not NULL, pszIniPath is an OUT param (pointer to a buffer atleast MAX_PATH long)
// - receives the path to desktop.ini
//
BOOL CFSFolder::_CheckDefaultIni(LPCIDFOLDER pidfLast, LPTSTR pszIniPath)
{
    BOOL fForceIni = FALSE;

    TCHAR szPath[MAX_PATH];
    if (!pszIniPath)
        pszIniPath = szPath;

    HRESULT hr = _GetPathForItem(pidfLast, pszIniPath);

    if (SUCCEEDED(hr) && PathIsRoot(pszIniPath))
    {   // Desktop.ini has to be checked for the root folders
        // even if the RO or SYSTEM bits are not set on them
        fForceIni = TRUE;
    }
    else
    {
        UINT csidl;
        if (!pidfLast)
        {
            csidl = _GetCSIDL();    // Get the cached value for the current folder
        }
        else
        {   // For subfolders, we don't have any cached values. So, compute.
            _csidl = GetSpecialFolderID(pszIniPath, c_csidlSpecial, ARRAYSIZE(c_csidlSpecial));
        }
        
        switch (csidl)
        {   // Desktop.ini has to be checked for the following special folders
            // even if the RO or SYSTEM bits are not set on them
        case CSIDL_SYSTEM:
        case CSIDL_WINDOWS:
        case CSIDL_PERSONAL:
            fForceIni = TRUE;
            break;
        }
    }
    
    if (!fForceIni)
    {   // Is the RO or SYSTEM bit set?
        fForceIni = (_Attributes() & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
    }

    // Append desktop.ini to the path
    if (SUCCEEDED(hr))
    {
        PathAppend(pszIniPath, c_szDesktopIni);
    }
    
    return fForceIni;
}

LPCTSTR CFSFolder::_BindHandlerName(REFIID riid)
{
    LPCTSTR pszHandler = NULL;
    if (IsEqualIID(riid, IID_IPropertySetStorage))
        pszHandler = TEXT("PropertyHandler");
    else if (IsEqualIID(riid, IID_IStorage))
        pszHandler = TEXT("StorageHandler");

    return pszHandler;
}

const CLSID CLSID_CTextIFilter = {
    0xc1243ca0,
    0xbf96,
    0x11cd,
    { 0xb5, 0x79, 0x08, 0x00, 0x2b, 0x30, 0xbf, 0xeb }};

HRESULT LoadIFilterWithTextFallback(
    WCHAR const *pwcsPath,
    IUnknown *pUnkOuter,
    void **ppIUnk)
{
    HRESULT hr = LoadIFilter(pwcsPath, pUnkOuter, ppIUnk);

    if (FAILED(hr))
    {
        DWORD dwFilterUnknown = 0;
        DWORD cb = sizeof(dwFilterUnknown);
        SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\ContentIndex"),
                        TEXT("FilterFilesWithUnknownExtensions"), NULL, &dwFilterUnknown, &cb);
        if (dwFilterUnknown != 0)
        {
            IPersistFile *ppf;
            hr = CoCreateInstance(CLSID_CTextIFilter, pUnkOuter, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pwcsPath, STGM_READ);
                if (SUCCEEDED(hr))
                {
                    hr = ppf->QueryInterface(IID_IFilter, ppIUnk);
                }
                ppf->Release();
            }
        }
    }
    return hr;
}


//  pidf - multi level file system only item 
HRESULT CFSFolder::_Bind(LPBC pbc, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra non file sys goo please

    *ppv = NULL;

    HRESULT hr;
    CLSID clsid;
    LPCIDFOLDER pidfLast = _FindLastID(pidf);

    if (_GetBindCLSID(pbc, pidfLast, &clsid))
    {
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, riid, ppv);

        if (SUCCEEDED(hr))
            hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);

        if (FAILED(hr) && (E_NOINTERFACE != hr) && _IsFolder(pidfLast))
        {
            // the IShellFolder extension failed to load (might not be installed
            // on this machine), so check if we should fall back to default to CFSFolder
            UINT dwFlags;
            if (_GetFolderFlags(pidf, &dwFlags) && (dwFlags & GFF_DEFAULT_TO_FS))
            {
                hr = CFSFolder_CreateInstance(NULL, riid, ppv);
                if (SUCCEEDED(hr))
                    hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);
            }
        }
    }
    else if (_IsFolder(pidfLast) || _IsSimpleID(pidfLast))
    {
        hr = CFSFolder_CreateInstance(NULL, riid, ppv);
        if (SUCCEEDED(hr))
            hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);
    }
    else
        hr = E_FAIL;

    if (FAILED(hr))
    {
        // this handler has a string version
        DWORD grfMode = BindCtx_GetMode(pbc, STGM_READ | STGM_SHARE_DENY_WRITE);
        LPCTSTR pszHandler = _BindHandlerName(riid);

        hr = _LoadHandler(pidf, grfMode, pszHandler, riid, ppv);
        if (FAILED(hr))
        {
            WCHAR wszPath[MAX_PATH];
            if (SUCCEEDED(_GetPathForItem(pidf, wszPath)))
            {
                if (IsEqualIID(riid, IID_IStream) && _IsFile(pidfLast))
                {
                    hr = SHCreateStreamOnFileEx(wszPath, grfMode, FILE_ATTRIBUTE_NORMAL, FALSE, NULL, (IStream **)ppv);
                }
                else if (IsEqualIID(riid, IID_IPropertyBag) && _IsFolder(pidfLast))
                {
                    hr = _CreateFolderPropertyBag(grfMode, pidf, riid, ppv);
                }
                else if (IsEqualIID(riid, IID_IPropertySetStorage))
                {
                    // this is questionable at best. the caller
                    // should be filtering offline files, not this code.
                    // legacy support, I don't think anyone depends on this
                    // avoid offline files...
                    if (FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs)
                        hr = STG_E_INVALIDFUNCTION; 
                    else
                    {
                        hr = StgOpenStorageEx(wszPath, grfMode, STGFMT_ANY, 0, NULL, NULL, riid, ppv);
                    }
                }
                else if (IsEqualIID(riid, IID_IStorage))
                {
                    hr = _InitStgFolder(pidf, wszPath, grfMode, riid, ppv);
                }
                else if (IsEqualIID(riid, IID_IMoniker))
                {
                    hr = CreateFileMoniker(wszPath, (IMoniker **)ppv);
                }
                else if (IsEqualIID(riid, IID_IFilter))
                {
                    hr = LoadIFilterWithTextFallback(wszPath, NULL, ppv);
                }
            }
        }
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && (NULL == *ppv)));   // Assert hr is consistent w/out param.
    return hr;
}

// returns:
//      *ppidfBind - multi level file system pidl part (must free this on S_OK return)
//      *ppidlRight - non file system part of pidl, continue bind down to this
//
//  S_OK
//      *ppidfBind needs to be freed
//  S_FALSE
//      pidf is a multi level file system only, bind to him
//  FAILED()    out of meory errors

HRESULT CFSFolder::_GetJunctionForBind(LPCIDFOLDER pidf, LPIDFOLDER *ppidfBind, LPCITEMIDLIST *ppidlRight)
{
    *ppidfBind = NULL;

    *ppidlRight = _FindJunctionNext(pidf);
    if (*ppidlRight)
    {
        *ppidfBind = (LPIDFOLDER)ILClone((LPITEMIDLIST)pidf);
        if (*ppidfBind)
        {
            // remove the part below the junction point
            _ILSkip(*ppidfBind, (ULONG)((ULONG_PTR)*ppidlRight - (ULONG_PTR)pidf))->mkid.cb = 0;
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
    return S_FALSE; // nothing interesting
}

HRESULT CFSFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        CFileSysItemString fsi(pidf);
        DWORD dwFlags;
        int iIcon = -1;

        // WARNING: don't include junctions (_IsFileFolder(pidf))
        // so junctions like briefcase get their own cusotm icon.
        //
        if (_IsFileFolder(pidf))
        {
            TCHAR szMountPoint[MAX_PATH];
            TCHAR szModule[MAX_PATH];

            iIcon = II_FOLDER;
            if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
            {
                iIcon = GetMountedVolumeIcon(szMountPoint, szModule, ARRAYSIZE(szModule));

                *piIndex = Shell_GetCachedImageIndex(szModule[0] ? szModule : c_szShell32Dll, iIcon, 0);
                return S_OK;
            }
            else
            {
                if (!_IsSystemFolder(pidf) && (_GetCSIDL() == CSIDL_NORMAL))
                {
                    if (flags & GIL_OPENICON)
                        iIcon = II_FOLDEROPEN;
                    else
                        iIcon = II_FOLDER;

                    *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
                    return S_OK;
                }
                iIcon = II_FOLDER;
                dwFlags = SHCF_ICON_PERINSTANCE;
            }
        }
        else
            dwFlags = fsi.ClassFlags(TRUE);

        // the icon is per-instance, try to look it up
        if (dwFlags & SHCF_ICON_PERINSTANCE)
        {
            TCHAR szFullPath[MAX_PATH];
            DWORD uid = _GetUID(pidf);    // get a unique identifier for this file.

            if (uid == 0)
                return S_FALSE;

            if (FAILED(_GetPathForItem(pidf, szFullPath)))
            {
                // fall back to the relative name if we can't get the full path
                lstrcpyn(szFullPath, fsi.FSName(), ARRAYSIZE(szFullPath));
            }

            *piIndex = LookupIconIndex(szFullPath, uid, flags | GIL_NOTFILENAME);

            if (*piIndex != -1)
                return S_OK;

            //  async extract (GIL_ASYNC) support
            //
            //  we cant find the icon in the icon cache, we need to do real work
            //  to get the icon.  if the caller specified GIL_ASYNC
            //  dont do the work, return E_PENDING forcing the caller to call
            //  back later to get the real icon.
            //
            //  when returing E_PENDING we must fill in a default icon index
            if (flags & GIL_ASYNC)
            {
                // come up with a default icon and return E_PENDING
                if (_IsFolder(pidf))
                    iIcon = II_FOLDER;
                else if (!(dwFlags & SHCF_HAS_ICONHANDLER) && PathIsExe(fsi.FSName()))
                    iIcon = II_APPLICATION;
                else
                    iIcon = II_DOCNOASSOC;

                *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);

                TraceMsg(TF_IMAGE, "Shell_GetCachedImageIndex(%d) returned = %d", iIcon, *piIndex);

                return E_PENDING;   // we will be called back later for the real one
            }

            // If this is a folder, see if this folder has Per-Instance folder icon
            // we do this here because it's too expensive to open a desktop.ini
            // file and see what's in there. Most of the cases we will just hit
            // the above cases
            if (_IsSystemFolder(pidf))
            {
                if (!_GetFolderIconPath(pidf, NULL, 0, NULL))
                {
                    // Note: the iIcon value has already been computed at the start of this funciton
                    ASSERT(iIcon != -1);
                    *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
                    return S_OK;
                }
            }

            //
            // look up icon using IExtractIcon, this will load handler iff needed
            // by calling ::GetUIObjectOf
            //
            IShellFolder *psf;
            HRESULT hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = SHGetIconFromPIDL(psf, NULL, (LPCITEMIDLIST)pidf, flags, piIndex);
                psf->Release();
            }

            //
            // remember this perinstance icon in the cache so we dont
            // need to load the handler again.
            //
            // SHGetIconFromPIDL will always return a valid image index
            // (it may default to a standard one) but it will fail
            // if the file cant be accessed or some other sort of error.
            // we dont want to cache in this case.
            //
            if (*piIndex != -1 && SUCCEEDED(hr) && (dwFlags & SHCF_HAS_ICONHANDLER))
            {
                int iIndexRetry;

                ENTERCRITICAL;

                //
                // Inside the critical section, make sure the icon isn't already
                // loaded, and if its not, then add it.
                //
                iIndexRetry = LookupIconIndex(szFullPath, uid, flags | GIL_NOTFILENAME);
                if (iIndexRetry == -1)
                {
                    AddToIconTable(szFullPath, uid, flags | GIL_NOTFILENAME, *piIndex);
                }

                LEAVECRITICAL;
            }

            return *piIndex == -1 ? S_FALSE : S_OK;
        }

        // icon is per-class dwFlags has the image index
        *piIndex = (dwFlags & SHCF_ICON_INDEX);
        return S_OK;
    }
    else
    {
        ASSERT(ILIsEmpty(pidl) || SIL_GetType(pidl) == SHID_ROOT_REGITEM); // regitems gives us these
        return S_FALSE;
    }
}

HANDLE g_hOverlayMgrCounter = NULL;   // Global count of Overlay Manager changes.
int g_lOverlayMgrPerProcessCount = 0; // Per process count of Overlay Manager changes.

//
// Use this function to obtain address of the singleton icon overlay manager.
// If the function succeeds, caller is responsible for calling Release() through
// the returned interface pointer.
// The function ensures that the manager is initialized and up to date.
//
STDAPI GetIconOverlayManager(IShellIconOverlayManager **ppsiom)
{
    HRESULT hr = E_FAIL;

    if (IconOverlayManagerInit())
    { 
        //
        // Is a critsec for g_psiom required here you ask?
        //
        // No.  The first call to IconOverlayInit in any process creates
        // the overlay manager object and initializes g_psiom.  This creation
        // contributes 1 to the object's ref count.  Subsequent calls to
        // GetIconOverlayManager add to the ref count and the caller is
        // responsible for decrementing the count through Release().
        // The original ref count of 1 is not removed until 
        // IconOverlayManagerTerminate is called which happens only
        // during PROCESS_DETACH.  Therefore, the manager referenced by g_psiom
        // in this code block will always be valid and a critsec is not
        // required.
        //

        //
        // ID for the global overlay manager counter.
        //
        static const GUID GUID_Counter = { /* 090851a5-eb96-11d2-8be4-00c04fa31a66 */
                                           0x090851a5,
                                           0xeb96,
                                           0x11d2,
                                           {0x8b, 0xe4, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x66}
                                         };
    
        g_psiom->AddRef();
    
        HANDLE hCounter = SHGetCachedGlobalCounter(&g_hOverlayMgrCounter, &GUID_Counter);
        long lGlobalCount = SHGlobalCounterGetValue(hCounter);

        if (lGlobalCount != g_lOverlayMgrPerProcessCount)
        {
            //
            // Per-process counter is out of sync with the global counter.
            // This means someone called SHLoadNonloadedIconOverlayIdentifiers
            // so we must load any non-loaded identifiers from the registry.
            //
            g_psiom->LoadNonloadedOverlayIdentifiers();
            g_lOverlayMgrPerProcessCount = lGlobalCount;
        }
        *ppsiom = g_psiom;
        hr = S_OK;
    }
    return hr;
}

BOOL IconOverlayManagerInit()
{
    if (!g_psiom)
    {
        IShellIconOverlayManager* psiom;
        if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_CFSIconOverlayManager, NULL, IID_PPV_ARG(IShellIconOverlayManager, &psiom))))
        {
            if (SHInterlockedCompareExchange((void **)&g_psiom, psiom, 0))
                psiom->Release();
        }
    }
    return BOOLFROMPTR(g_psiom);
}

void IconOverlayManagerTerminate()
{
    ASSERTDLLENTRY;      // does not require a critical section

    IShellIconOverlayManager *psiom = (IShellIconOverlayManager *)InterlockedExchangePointer((void **)&g_psiom, 0);
    if (psiom)
        psiom->Release();

    if (NULL != g_hOverlayMgrCounter)
    {
        CloseHandle(g_hOverlayMgrCounter);
        g_hOverlayMgrCounter = NULL;
    }
}


STDAPI SHLoadNonloadedIconOverlayIdentifiers(void)
{
    //
    // This will cause the next call GetIconOverlayManager() call in each process
    // to load any non-loaded icon overlay identifiers.
    //
    if (g_hOverlayMgrCounter)
        SHGlobalCounterIncrement(g_hOverlayMgrCounter);

    return S_OK;
}


HRESULT CFSFolder::_GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    LPCIDFOLDER pidf = _IsValidID(pidl);

    *pIndex = 0;
    
    if (!pidf)
    {
        ASSERT(SIL_GetType(pidl) != SHID_ROOT_REGITEM); // CRegFolder should have handled it
        return S_FALSE;
    }

    ASSERT(pidl == ILFindLastID(pidl));

    if (IconOverlayManagerInit())
    {
        int iReservedID = -1;
        WCHAR wszPath[MAX_PATH];

        hr = _GetPathForItem(pidf, wszPath);
        if (SUCCEEDED(hr))
        {
            IShellIconOverlayManager *psiom;
            // The order of the "if" statements here is significant

            if (_IsFile(pidf) && (_GetClassFlags(pidf) & SHCF_IS_LINK))
                iReservedID = SIOM_RESERVED_LINK;
            else
            {
                USES_CONVERSION;
                LPCTSTR szPath = W2CT(wszPath);

                if (_IsFolder(pidf) && (IsShared(szPath, FALSE)))
                    iReservedID = SIOM_RESERVED_SHARED;
                else if (FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs)
                    iReservedID = SIOM_RESERVED_SLOWFILE;
            }

            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                if (iReservedID != -1)
                    hr = psiom->GetReservedOverlayInfo(wszPath, pidf->wAttrs, pIndex, dwFlags, iReservedID);
                else
                    hr = psiom->GetFileOverlayInfo(wszPath, pidf->wAttrs, pIndex, dwFlags);

                psiom->Release();
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT(pIndex);
    if (pIndex)
        hr = (*pIndex == OI_ASYNC) ? E_PENDING :
               _GetOverlayInfo(pidl, pIndex, SIOM_OVERLAYINDEX);

    return hr;
}

HRESULT CFSFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIconIndex)
{
    return _GetOverlayInfo(pidl, pIconIndex, SIOM_ICONINDEX);
}


// CFSFolder : IPersist, IPersistFolder, IPersistFolder2, IPersistFolderAlias Members

HRESULT CFSFolder::GetClassID(CLSID *pclsid)
{
    if (!IsEqualCLSID(_clsidBind, CLSID_NULL))
    {
        *pclsid = _clsidBind;
    }
    else
    {
        *pclsid = CLSID_ShellFSFolder;
    }
    return S_OK;
}

HRESULT CFSFolder::Initialize(LPCITEMIDLIST pidl)
{
    _Reset();
    return SHILClone(pidl, &_pidl);
}

HRESULT CFSFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

LPTSTR StrDupUnicode(const WCHAR *pwsz)
{
    if (*pwsz)
    {
        USES_CONVERSION;
        return StrDup(W2CT(pwsz));
    }
    return NULL;
}


HRESULT CFSFolder::_SetStgMode(DWORD grfFlags)
{
    HRESULT hr = S_OK;

    if (grfFlags & STGM_TRANSACTED)
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        _grfFlags = grfFlags;

    return hr;
}


HRESULT CFSFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, 
                                const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = Initialize(pidlRoot);
    if (SUCCEEDED(hr))
    {
        if (pfti)
        {
            _dwAttributes = pfti->dwAttributes;
            if (pfti->pidlTargetFolder ||
                pfti->szTargetParsingName[0] ||
                (pfti->csidl != -1))
            {

                if ((pfti->csidl != -1) && (pfti->csidl & CSIDL_FLAG_PFTI_TRACKTARGET))
                {
                    //  For tracking target, all other fields must be null.
                    if (!pfti->pidlTargetFolder &&
                        !pfti->szTargetParsingName[0] &&
                        !pfti->szNetworkProvider[0])
                    {
                        _csidlTrack = pfti->csidl & (~CSIDL_FLAG_MASK | CSIDL_FLAG_CREATE);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    _pidlTarget = ILClone(pfti->pidlTargetFolder);  // on NULL returns NULL
                    _pszPath = StrDupUnicode(pfti->szTargetParsingName);
                    _pszNetProvider = StrDupUnicode(pfti->szNetworkProvider);
                    if (pfti->csidl != -1)
                        _csidl = pfti->csidl & (~CSIDL_FLAG_MASK | CSIDL_FLAG_CREATE);
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = _SetStgMode(BindCtx_GetMode(pbc, STGM_READ | STGM_SHARE_DENY_WRITE));
        }
        if (SUCCEEDED(hr) && pbc)
        {
            _fDontForceCreate = BindCtx_ContainsObject(pbc, STR_DONT_FORCE_CREATE);
        }
    }
    return hr;
}

HRESULT CFSFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;
    ZeroMemory(pfti, sizeof(*pfti)); 

    _GetPathForItem(NULL, pfti->szTargetParsingName);
    if (_pidlTarget)
        hr = SHILClone(_pidlTarget, &pfti->pidlTargetFolder);
    if (_pszNetProvider)
        SHTCharToUnicode(_pszNetProvider, pfti->szNetworkProvider, ARRAYSIZE(pfti->szNetworkProvider));

    pfti->dwAttributes = _dwAttributes;
    if (_csidlTrack >= 0)
        pfti->csidl = _csidlTrack | CSIDL_FLAG_PFTI_TRACKTARGET;
    else
        pfti->csidl = _GetCSIDL();

    return hr;
}

STDAPI CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pfti, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFSFolder *pfolder = new CFSFolder(punkOuter);
    if (pfolder)
    {
        hr = pfolder->InitializeEx(pbc, pidl, pfti);
        if (SUCCEEDED(hr))
            hr = pfolder->_GetInner()->QueryInterface(riid, ppv);
        pfolder->_GetInner()->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// COM object creation entry point for CLSID_ShellFSFolder
STDAPI CFSFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CFSFolder_CreateFolder(punkOuter, NULL, &c_idlDesktop, NULL, riid, ppv);
}

BOOL CFSFolder::_IsSlowPath()
{
    if (_bSlowPath == INVALID_PATHSPEED)
    {
        TCHAR szPath[MAX_PATH];
        _GetPath(szPath);
        _bSlowPath = PathIsSlow(szPath, _Attributes()) ? TRUE : FALSE;
    }
    return _bSlowPath;
}

HRESULT CFSFolder::_GetToolTipForItem(LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    IQueryAssociations *pqa;
    HRESULT hr = _AssocCreate(pidf, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        WCHAR szText[INFOTIPSIZE];

        // If we are looking at a folder over a slow connection,
        // show only quickly accessible properties
        ASSOCSTR assocstr = _IsSlowPath() ? ASSOCSTR_QUICKTIP : ASSOCSTR_INFOTIP;

        hr = pqa->GetString(0, assocstr, NULL, szText, (DWORD *)MAKEINTRESOURCE(SIZECHARS(szText)));
        if (SUCCEEDED(hr))
        {
            hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2 *), (LPCITEMIDLIST)pidf, szText, riid, ppv);
            if (SUCCEEDED(hr) && _IsFileFolder(pidf))
            {
                IUnknown *punk = (IUnknown *)*ppv;
                *ppv = NULL;
                WCHAR szPath[MAX_PATH];
                hr = _GetPathForItem(pidf, szPath);
                if (SUCCEEDED(hr))
                    hr = CFolderInfoTip_CreateInstance(punk, szPath, riid, ppv);
                punk->Release();
            }
        }
        pqa->Release();
    }

    return hr;
}

//
// Call the shell file operation code to delete recursively the given directory,
// don't show any UI.
//

HRESULT CFSFolder::_Delete(LPCWSTR pszFile)
{
    SHFILEOPSTRUCT fos = { 0 };
    TCHAR szFile[MAX_PATH + 1];

    SHUnicodeToTChar(pszFile, szFile, MAX_PATH);

    // szFile is a double-zero terminated list of files.
    // we can't just zero-init the szFile string to start with,
    // since in debug SHUnicodeToTChar will bonk the uncopied part
    // of the string with noise.
    szFile[lstrlen(szFile) + 1] = 0;

    fos.wFunc = FO_DELETE;
    fos.pFrom = szFile;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;

    return SHFileOperation(&fos) ? E_FAIL : S_OK;
}

//
// Do a path combine thunking accordingly
//

HRESULT CFSFolder::_GetFullPath(LPCWSTR pszRelPath, LPWSTR pszFull)
{
    WCHAR szPath[MAX_PATH];
    _GetPathForItem(NULL, szPath);
    PathCombineW(pszFull, szPath, pszRelPath);
    return S_OK;    // for now
}

HRESULT _FileExists(LPCWSTR pszPath, DWORD *pdwAttribs)
{
    return PathFileExistsAndAttributesW(pszPath, pdwAttribs) ? S_OK : STG_E_FILENOTFOUND;
}

// IStorage

STDMETHODIMP CFSFolder::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    HRESULT hr = _OpenCreateStream(pwcsName, grfMode, ppstm, TRUE);
    if (SUCCEEDED(hr))
    {
        WCHAR szFullPath[MAX_PATH];
        _GetFullPath(pwcsName, szFullPath);
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szFullPath, NULL);
    }
    return hr;
}

STDMETHODIMP CFSFolder::OpenStream(LPCWSTR pwcsName, void *res1, DWORD grfMode, DWORD res2, IStream **ppstm)
{
    return _OpenCreateStream(pwcsName, grfMode, ppstm, FALSE);
}


HRESULT CFSFolder::_OpenCreateStream(LPCWSTR pwcsName, DWORD grfMode, IStream **ppstm, BOOL fCreate)
{
    *ppstm = NULL;

    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    HRESULT hr = SHCreateStreamOnFileEx(szFullPath, grfMode, FILE_ATTRIBUTE_NORMAL, fCreate, NULL, ppstm);

    return MapWin32ErrorToSTG(hr);
}


STDMETHODIMP CFSFolder::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    return _OpenCreateStorage(pwcsName, grfMode, ppstg, TRUE);
}

STDMETHODIMP CFSFolder::OpenStorage(LPCWSTR pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD res, IStorage **ppstg)
{
    return _OpenCreateStorage(pwcsName, grfMode, ppstg, FALSE);
}

HRESULT CFSFolder::_OpenCreateStorage(LPCWSTR pwcsName, DWORD grfMode, IStorage **ppstg, BOOL fCreate)
{
    *ppstg = NULL;

    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    if (grfMode &
        ~(STGM_READ             |
          STGM_WRITE            |
          STGM_READWRITE        |
          STGM_SHARE_DENY_NONE  |
          STGM_SHARE_DENY_READ  |
          STGM_SHARE_DENY_WRITE |
          STGM_SHARE_EXCLUSIVE  |
          STGM_CREATE        ))
    {
        return STG_E_INVALIDPARAMETER;
    }
    
    // if the storage doesn't exist then lets create it, then drop into the
    // open storage to do the right thing.

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    DWORD dwAttributes;
    HRESULT hr = _FileExists(szFullPath, &dwAttributes);
    if (SUCCEEDED(hr))
    {
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCreate)
            {
                // an object exists, we must fail grfMode == STGM_FAILIFTHERE, or
                // the object that exists is not a directory.  
                //        
                // if the STGM_CREATE flag is set and the object exists we will
                // delete the existing storage.

                // Check to make sure only one existence flag is specified
                // FAILIFTHERE is zero so it can't be checked
                if (STGM_FAILIFTHERE == (grfMode & (STGM_CREATE | STGM_CONVERT)))
                    hr = STG_E_FILEALREADYEXISTS;
                else if (grfMode & STGM_CREATE)
                {
                    // If they have not passed STGM_FAILIFTHERE, we'll replace an existing
                    // folder even if its readonly or system.  Its up to the caller to make
                    // such filesystem-dependant checks first if they want to prevent that,
                    // as there's no way to pass information about whether we should or not
                    // down into CreateStorage

                    if (dwAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
                        SetFileAttributes(szFullPath, dwAttributes & ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));

                    hr = _Delete(szFullPath);

                    //
                    // I don't trust the result from SHFileOperation, so I consider success
                    // to be iff the directory is -gone-
                    //

                    if (FAILED(_FileExists(szFullPath, &dwAttributes)))
                    {
                        DWORD err = SHCreateDirectoryExW(NULL, szFullPath, NULL); 
                        hr = HRESULT_FROM_WIN32(err);
                    }
                    else
                    {
                        // We couldn't remove the existing directory, so return an error,
                        // using what _Delete() said or, it if didn't return an error, E_FAIL

                        return (FAILED(hr) ? hr : E_FAIL);
                    }
                }
                else
                    hr = STG_E_INVALIDPARAMETER;
            }
        }
        else
            hr = E_FAIL;    // a file, not a folder!
    }
    else
    {
        // the object doesn't exist, and they have not set the STGM_CREATE, nor
        // is this a ::CreateStorage call.
        hr = STG_E_FILENOTFOUND;

        if (fCreate)
        {
            DWORD err = SHCreateDirectoryExW(NULL, szFullPath, NULL); 
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    // create a directory (we assume this will always succeed)

    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = ParseDisplayName(NULL, NULL, (LPWSTR)pwcsName, NULL, &pidl, NULL); // const -> non const
        if (SUCCEEDED(hr))
        {
            hr = BindToObject(pidl, NULL, IID_PPV_ARG(IStorage, ppstg));
            ILFree(pidl);
        }
    }

    return hr;
}

STDMETHODIMP CFSFolder::CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
{
    return E_NOTIMPL;
}

// CFSFolder::MoveElementTo
//
// Copies or moves a source file (stream) to a destination storage.  The stream
// itself, in this case our filestream object, does the actual work of moving
// the data around.

STDMETHODIMP CFSFolder::MoveElementTo(LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    return StgMoveElementTo(SAFECAST(this, IShellFolder *), SAFECAST(this, IStorage *), pwcsName, pstgDest, pwcsNewName, grfFlags);
}

STDMETHODIMP CFSFolder::Commit(DWORD grfCommitFlags)
{
    return S_OK;        // changes are commited as we go, so return S_OK;
}

STDMETHODIMP CFSFolder::Revert()
{
    return E_NOTIMPL;   // changes are commited as we go, so cannot implement this.
}

STDMETHODIMP CFSFolder::EnumElements(DWORD res1, void *res2, DWORD res3, IEnumSTATSTG **ppenum)
{
    HRESULT hr;
    CFSFolderEnumSTATSTG *penum = new CFSFolderEnumSTATSTG(this);
    if (penum)
    {
        *ppenum = (IEnumSTATSTG *) penum;
        hr = S_OK;
    }
    else
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFSFolder::DestroyElement(LPCWSTR pwcsName)
{
    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    return _Delete(szFullPath);
}

STDMETHODIMP CFSFolder::RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
{
    if (!pwcsOldName || !pwcsNewName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szOldPath[MAX_PATH];
    _GetFullPath(pwcsOldName, szOldPath);

    HRESULT hr = _FileExists(szOldPath, NULL);
    if (SUCCEEDED(hr))
    {
        WCHAR szNewPath[MAX_PATH];
        _GetFullPath(pwcsNewName, szNewPath);

        hr = _FileExists(szNewPath, NULL);
        if (FAILED(hr))
        {
            if (MoveFileW(szOldPath, szNewPath))
                hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
            hr = STG_E_FILEALREADYEXISTS;
    }
    return hr;
}

STDMETHODIMP CFSFolder::SetElementTimes(LPCWSTR pwcsName, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
{
    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    HRESULT hr = S_OK;
    HANDLE hFile = CreateFileW(szFullPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!SetFileTime(hFile, pctime, patime, pmtime))
            hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(hFile);
    }
    else
    {
        hr = STG_E_FILENOTFOUND;
    }

    return hr;
}

STDMETHODIMP CFSFolder::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = E_FAIL;

    ZeroMemory(pstatstg, sizeof(STATSTG));  // per COM conventions

    TCHAR szPath[MAX_PATH];
    _GetPath(szPath);

    HANDLE hFile = CreateFile(szPath, FILE_READ_ATTRIBUTES,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        BY_HANDLE_FILE_INFORMATION bhfi;
    
        if (GetFileInformationByHandle(hFile, &bhfi))
        {
            ASSERT(bhfi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            pstatstg->type = STGTY_STORAGE;

            pstatstg->mtime = bhfi.ftLastWriteTime;
            pstatstg->ctime = bhfi.ftCreationTime;
            pstatstg->atime = bhfi.ftLastAccessTime;

            pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
            pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;

            pstatstg->grfMode = _grfFlags;

            pstatstg->reserved = bhfi.dwFileAttributes;

            hr = S_OK;
            if (!(grfStatFlag & STATFLAG_NONAME))
            {
                hr = SHStrDup(PathFindFileName(szPath), &pstatstg->pwcsName);
            }
        }
        CloseHandle(hFile);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
    return hr;
}

// ITransferDest

STDMETHODIMP CFSFolder::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    if (_pAdvise)
        return E_FAIL;

    _pAdvise = pAdvise;
    _pAdvise->AddRef();

    if (pdwCookie)
        *pdwCookie = 1;

    return S_OK;
}

STDMETHODIMP CFSFolder::Unadvise(DWORD dwCookie)
{
    if (1 != dwCookie)
        return E_INVALIDARG;

    if (_pAdvise)
    {
        ATOMICRELEASE(_pAdvise);
        return S_OK;
    }

    return S_FALSE;
}

HRESULT CFSFolder::_GetStatStgFromItemName(LPCTSTR szName, STATSTG * pstat)
{
    WIN32_FIND_DATA fd;
    HRESULT hr = STG_E_FILENOTFOUND;
    HANDLE hFile = FindFirstFile(szName, &fd);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        hr = StatStgFromFindData(&fd, STATFLAG_DEFAULT, pstat);
        FindClose(hFile);
    }

    return hr;
}

STDMETHODIMP CFSFolder::OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::MoveElement(IShellItem *psiItem, WCHAR *pwcsNewName, STGXMOVE grfOptions)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::DestroyElement(const WCHAR * pwcsName, STGXDESTROY grfOptions)
{
    return E_NOTIMPL;
}

//   Create a storage object for the specified path, returning a suitable
//   IStorage (or error).
//
// In:
//   pwszPath -> directory
//   grfMode -> flags passed to IStorage::CreateStorage
//   ppstg -> receieves the storage object
//
// Out:
//   HRESULT

STDAPI SHCreateStorageOnDirectory(LPCWSTR pszPath, DWORD grfMode, IStorage **ppstg)
{
    *ppstg = NULL;

    TCHAR szPath[MAX_PATH];
    SHUnicodeToTChar(pszPath, szPath, ARRAYSIZE(szPath));

    LPITEMIDLIST pidl;
    HRESULT hr = SHILCreateFromPath(szPath, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IStorage, pidl, ppstg));
        ILFree(pidl);
    }
    return hr;
}



STDAPI SHCreatePropStgOnFolder(LPCTSTR pszFolder, DWORD grfMode, IPropertySetStorage **ppss);

HRESULT CFSFolder::_LoadPropHandler()
{
    HRESULT hr = S_OK;
    if (_pstg)
    {
        hr = S_OK;
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        _GetPath(szPath);
        hr = StgOpenStorageOnFolder(szPath, _grfFlags, IID_PPV_ARG(IPropertySetStorage, &_pstg));
        // if (FAILED(hr))
        //    hr = SHCreatePropStgOnFolder(szPath, _grfFlags, &_pstg);
    }
    return hr;
}

STDMETHODIMP CFSFolder::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, 
                               DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Create(fmtid, pclsid, grfFlags, grfMode, pppropstg);
    return hr;
}

STDMETHODIMP CFSFolder::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Open(fmtid, grfMode, pppropstg);
    return hr;
}

STDMETHODIMP CFSFolder::Delete(REFFMTID fmtid)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Delete(fmtid);
    return hr;
}

STDMETHODIMP CFSFolder::Enum(IEnumSTATPROPSETSTG ** ppenum)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Enum(ppenum);
    return hr;
}

// IItemNameLimits methods

#define INVALID_NAME_CHARS      L"\\/:*?\"<>|"
STDMETHODIMP CFSFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    *ppwszValidChars = NULL;
    return SHStrDup(INVALID_NAME_CHARS, ppwszInvalidChars);
}

STDMETHODIMP CFSFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    TCHAR szPath[MAX_PATH];
    BOOL fShowExtension = _DefaultShowExt();
    LPITEMIDLIST pidl;

    StrCpyN(szPath, pszName, ARRAYSIZE(szPath));
    HRESULT hr = ParseDisplayName(NULL, NULL, szPath, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        LPCIDFOLDER pidf = _IsValidID(pidl);
        if (pidf)
        {
            fShowExtension = _ShowExtension(pidf);
        }
        ILFree(pidl);
    }

    hr = _GetPath(szPath);
    if (SUCCEEDED(hr))
    {
        if (PathAppend(szPath, pszName))
            hr = GetCCHMaxFromPath(szPath, (UINT *)piMaxNameLen, fShowExtension);
        else
            hr = E_FAIL;
    }
    return hr;
}


// ISetFolderEnumRestriction methods

STDMETHODIMP CFSFolder::SetEnumRestriction(DWORD dwRequired, DWORD dwForbidden)
{
    _dwEnumRequired = dwRequired;
    _dwEnumForbidden = dwForbidden;
    return S_OK;
}

// IOleCommandTarget stuff 
STDMETHODIMP CFSFolder::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup == NULL)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_REFRESH:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CFSFolder::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _dwAttributes = -1;
            _bUpdateExtendedCols = TRUE;
            _tbDefShowExt = TRIBIT_UNDEFINED;
            _tbOfflineCSC = TRIBIT_UNDEFINED;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

// global hook in the SHChangeNotify() dispatcher. note we get all change notifies
// here so be careful!
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    switch (lEvent)
    {
    case SHCNE_ASSOCCHANGED:
        {
            FlushFileClass();   // flush them all
            HWND hwnd = GetDesktopWindow();
            if (IsWindow(hwnd))
                PostMessage(hwnd, DTM_SETUPAPPRAN, 0, 0);
        }
        break;
    }
    return S_OK;
}

//
//  317617 - Hacky update for the icon cache - ZekeL - 19-APR-2001
//  this is for defview to invalidate icon indeces that are indirected
//  specifically if you have a LNK file and its target changes icons
//  (like a CD will), then the LNK is updated by defview processing the 
//  SHCNE_UPDATEIMAGE and noticing that one of its items also matches
//  this image index.
//  
//  the righteous fix is to make SCN call into the fileicon cache
//  and reverse lookup any entries that match the icon index and invalidate
//  them.  that way we wouldnt miss anything.
//
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    LPCIDFOLDER pidf = CFSFolder::_IsValidID(pidl);
    if (pidf)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName))))
        {
            RemoveFromIconTable(szName);
        }
    }
}
        

// ugly wrappers for external clients, remove these as possible


STDAPI CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    CFileSysItemString fsi1(pidf1), fsi2(pidf2);
    return ResultFromShort((short)lstrcmpi(fsi1.FSName(), fsi2.FSName()));
}

STDAPI_(DWORD) CFSFolder_PropertiesThread(void *pv)
{
    return CFSFolder::_PropertiesThread(pv);
}

STDAPI_(LPCIDFOLDER) CFSFolder_IsValidID(LPCITEMIDLIST pidl)
{
    return CFSFolder::_IsValidID(pidl);
}

STDAPI_(BOOL) CFSFolder_IsCommonItem(LPCITEMIDLIST pidl)
{
    return CFSFolder::_IsCommonItem(pidl);
}

CFSIconManager::CFSIconManager()
{
    _wszPath[0] = NULL;
    _cRef = 1;
}

HRESULT CFSIconManager::_Init(LPCITEMIDLIST pidl, IShellFolder *psf)
{
    HRESULT hr = S_OK;

    if ((psf == NULL) || (pidl == NULL))
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _wszPath, ARRAYSIZE(_wszPath));
    return hr;
}

HRESULT CFSIconManager::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFSIconManager, ICustomIconManager),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFSIconManager::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFSIconManager::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP CFSIconManager::GetDefaultIconHandle(HICON *phIcon)
{
    HRESULT hr = S_OK;

    if (phIcon == NULL)
        hr = E_INVALIDARG;
        
    if (SUCCEEDED(hr))
    {
        WCHAR szCustomizedIconPath[MAX_PATH];
        int nCustomizedIconIndex;
        *phIcon = NULL;
        if (SUCCEEDED(hr = GetIcon(szCustomizedIconPath, ARRAYSIZE(szCustomizedIconPath), &nCustomizedIconIndex)))
        {
            _SetDefaultIconEx(FALSE);
        }
        SHFILEINFOW sfiw;
        if (SHGetFileInfoW(_wszPath, 0, &sfiw, sizeof(sfiw), SHGFI_ICON | SHGFI_LARGEICON))
        {
            *phIcon = sfiw.hIcon;
            hr = S_OK;
        }
        else
            hr = E_FAIL;

        if (szCustomizedIconPath[0] != NULL)
            _SetIconEx(szCustomizedIconPath, nCustomizedIconIndex, FALSE);
    }

    return hr;
}

STDMETHODIMP CFSIconManager::SetIcon(LPCWSTR pwszIconPath, int iIcon)
{
    return _SetIconEx(pwszIconPath, iIcon, TRUE);
}

STDMETHODIMP CFSIconManager::SetDefaultIcon()
{
    return _SetDefaultIconEx(TRUE);
}

HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;
    CFileFolderIconManager *pffim = new CFileFolderIconManager;
    if (pffim)
    {
        hr =  pffim->_Init(pidl, psf);  
        if (SUCCEEDED(hr))
            hr = pffim->QueryInterface(riid, ppv);
        pffim->Release();
    }
    else
    {       
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFileFolderIconManager::_SetIconEx(LPCWSTR pwszIconPath, int iIcon, BOOL fChangeNotify)
{
    HRESULT hr = S_OK;
    WCHAR wszExpandedIconPath[MAX_PATH];
    if (SHExpandEnvironmentStrings(pwszIconPath, wszExpandedIconPath, ARRAYSIZE(wszExpandedIconPath)) == 0)
        hr = E_FAIL;

    if (SUCCEEDED(hr))
    {
        SHFOLDERCUSTOMSETTINGS fcs;
        ZeroMemory(&fcs, sizeof(fcs));
        fcs.dwSize = sizeof(fcs);
        fcs.dwMask = FCSM_ICONFILE;
        fcs.pszIconFile = (LPWSTR) wszExpandedIconPath;
        fcs.cchIconFile = ARRAYSIZE(wszExpandedIconPath);
        fcs.iIconIndex = iIcon;

        hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_FORCEWRITE);

        if (SUCCEEDED(hr) && fChangeNotify)
        {
        /*
            // Work Around - We need to pump a image change message for the folder icon change.
            // The right way is the following. But for some reason, the shell views which 
            // display the folder, don't update there images. So as a work around, we pump a
            // SHCNE_RENAMEFOLDER message. This works!. 
        
            SHFILEINFO sfi;
            if (SHGetFileInfo(pfpsp->szPath, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION))
            {
                int iIconIndex = Shell_GetCachedImageIndex(sfi.szDisplayName, sfi.iIcon, 0);
                SHUpdateImage(PathFindFileName(sfi.szDisplayName), sfi.iIcon, 0, iIconIndex);
            }
        */
            SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _wszPath, _wszPath);
        }            
    }
    return hr;
}

STDMETHODIMP CFileFolderIconManager::_SetDefaultIconEx(BOOL fChangeNotify)
{
    HRESULT hr = E_FAIL;
    SHFOLDERCUSTOMSETTINGS fcs;
    
    ZeroMemory(&fcs, sizeof(fcs));
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_ICONFILE;    
    fcs.pszIconFile = NULL;
    fcs.cchIconFile = 0;
    fcs.iIconIndex = 0;

    hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_FORCEWRITE);

    if (SUCCEEDED(hr) && fChangeNotify)
    {
    /*
        // Work Around - We need to pump a image change message for the folder icon change.
        // The right way is the following. But for some reason, the shell views which 
        // display the folder, don't update there images. So as a work around, we pump a
        // SHCNE_RENAMEFOLDER message. This works!. 

        SHFILEINFO sfi;
        if (SHGetFileInfo(pfpsp->szPath, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION))
        {
            int iIconIndex = Shell_GetCachedImageIndex(sfi.szDisplayName, sfi.iIcon, 0);
            SHUpdateImage(PathFindFileName(sfi.szDisplayName), sfi.iIcon, 0, iIconIndex);
        }
    */
        SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _wszPath, _wszPath);
    }
    return hr;
}

HRESULT CFileFolderIconManager::GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex)
{
    HRESULT hr = S_OK;
    if ((pszIconPath == NULL) || (cchszIconPath < MAX_PATH) || (piIconIndex == NULL))
        hr = E_INVALIDARG;
        
    if (SUCCEEDED(hr))
    {
        SHFOLDERCUSTOMSETTINGS fcs;
        ZeroMemory(&fcs, sizeof(fcs));
        fcs.dwSize = sizeof(fcs);
        fcs.dwMask = FCSM_ICONFILE;  
        fcs.pszIconFile = pszIconPath;
        fcs.cchIconFile = cchszIconPath;

        hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_READ);   
        if (SUCCEEDED(hr))
        {
            *piIconIndex = fcs.iIconIndex;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filetbl.h ===
#ifndef _FILETBL_H
#define _FILETBL_H

#define SHIL_COUNT  (SHIL_LAST + 1)

// fileicon.c
STDAPI_(int) SHAddIconsToCache(HICON rghicon[SHIL_COUNT], LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);

STDAPI AddToIconTable(LPCTSTR szFile, int iIconIndex, UINT uFlags, int iIndex);
STDAPI_(void) RemoveFromIconTable(LPCTSTR szFile);
STDAPI_(void) FlushIconCache(void);
STDAPI_(int)  GetFreeImageIndex(void);

STDAPI_(void) IconCacheFlush(BOOL fForce);
STDAPI_(BOOL) IconCacheSave(void);
STDAPI_(BOOL) IconCacheRestore(SIZE rgsize[SHIL_COUNT], UINT flags);
STDAPI_(void) _IconCacheDump(void);       // DEBUG ONLY

STDAPI_(int) LookupIconIndex(LPCTSTR pszFile, int iIconIndex, UINT uFlags);
STDAPI_(DWORD) LookupFileClass(LPCTSTR szClass);
STDAPI_(void)  AddFileClass(LPCTSTR szClass, DWORD dw);
STDAPI_(void)  FlushFileClass(void);
STDAPI_(BOOL)  IconIndexInFileClassTable(int iIndex);
STDAPI_(LPCTSTR) LookupFileClassName(LPCTSTR szClass);
STDAPI_(LPCTSTR) AddFileClassName(LPCTSTR szClass, LPCTSTR szClassName);
STDAPI_(UINT) LookupFileSCIDs(LPCTSTR pszClass, SHCOLUMNID *pascidOut[]);
STDAPI_(void) AddFileSCIDs(LPCTSTR pszClass, SHCOLUMNID ascidIn[], UINT cProps);

//  OpenAsTypes
typedef enum {
    GEN_CUSTOM          = -3,
    GEN_UNSPECIFIED     = -2,
    GEN_FOLDER          = -1,
    GEN_UNKNOWN         = 0,
    GEN_TEXT,
    GEN_IMAGE,
    GEN_AUDIO,
    GEN_VIDEO,
    GEN_COMPRESSED,
} PERCEIVED;

STDAPI_(PERCEIVED) LookupFilePerceivedType(LPCTSTR pszClass);
STDAPI_(void) AddFilePerceivedType(LPCTSTR pszClass, PERCEIVED gen);

PERCEIVED GetPerceivedType(IShellFolder *psf, LPCITEMIDLIST pidl);

//  g_MaxIcons is limit on the number of icons in the cache
//  when we reach this limit we will start to throw icons away.
//
extern int g_MaxIcons;               // panic limit for cache size
#ifdef DEBUG
#define DEF_MAX_ICONS   200         // to test the flush code more offten
#else
#define DEF_MAX_ICONS   500         // normal end user number
#endif

// refreshes g_MaxIcons from registry.  returns TRUE if value changed.
BOOL QueryNewMaxIcons(void);

// g_iLastSysIcon is an indicator that is used to help determine which icons
// should be flushed and which icons shouldn't.  In the EXPLORER.EXE process,
// the first 40 or so icons should be saved.  On all other processes, only
// the icon overlay's should be saved.
extern UINT g_iLastSysIcon;

typedef struct
{
    SIZE size;          // icon size
    HIMAGELIST himl;
} SHIMAGELIST;

EXTERN_C SHIMAGELIST g_rgshil[SHIL_COUNT];

BOOL _IsSHILInited();
int _GetSHILImageCount();

void _DestroyIcons(HICON *phicons, int cIcons);

// NOTE these are the size of the icons in our ImageList, not the system
// icon size.

#define g_cxIcon        ((int)g_rgshil[SHIL_LARGE].size.cx)
#define g_cyIcon        ((int)g_rgshil[SHIL_LARGE].size.cy)
#define g_cxSmIcon      ((int)g_rgshil[SHIL_SMALL].size.cx)
#define g_cySmIcon      ((int)g_rgshil[SHIL_SMALL].size.cy)

#endif  // _FILETBL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fileicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "ovrlaymn.h"
#include "fstreex.h"
#include "filetbl.h"
#include "ids.h"

// REVIEW: More clean up should be done.

BOOL _ShellImageListInit(UINT flags, BOOL fRestore);

int g_ccIcon = 0;                // color depth of ImageLists
int g_MaxIcons = DEF_MAX_ICONS;  // panic limit for icons in cache
int g_lrFlags = 0;

int g_ccIconDEBUG = -1;
int g_resDEBUG = -1;

int GetRegInt(HKEY hk, LPCTSTR szKey, int def)
{
    TCHAR ach[20];
    DWORD cb = sizeof(ach);
    if (ERROR_SUCCESS == SHQueryValueEx(hk, szKey, NULL, NULL, (LPBYTE)ach, &cb)
    && (ach[0] >= TEXT('0') && ach[0] <= TEXT('9')))
    {
        return (int)StrToLong(ach);
    }
    else
        return def;
}

int _GetMetricsRegInt(LPCTSTR pszKey, int iDefault)
{
    HKEY hkey;
    if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_METRICS, &hkey) == 0)
    {
        iDefault = GetRegInt(hkey, pszKey, iDefault);
        RegCloseKey(hkey);
    }
    return iDefault;
}

typedef void (*PSIZECALLBACK)(SIZE *psize);

void WINAPI _GetLargeIconSizeCB(SIZE *psize)
{
    int cxIcon = GetSystemMetrics(SM_CXICON);

    //
    //  get the user prefered icon size from the registry.
    //
    cxIcon = _GetMetricsRegInt(TEXT("Shell Icon Size"), cxIcon);

    psize->cx = psize->cy = cxIcon;
}

void WINAPI _GetSmallIconSizeCB(SIZE *psize)
{
    int cxIcon = GetSystemMetrics(SM_CXICON)/2;

    //
    //  get the user prefered icon size from the registry.
    //
    cxIcon = _GetMetricsRegInt(TEXT("Shell Small Icon Size"), cxIcon);

    psize->cx = psize->cy = cxIcon;
}

void WINAPI _GetSysSmallIconSizeCB(SIZE *psize)
{
    psize->cx = GetSystemMetrics(SM_CXSMICON);
    psize->cy = GetSystemMetrics(SM_CYSMICON);
}

void WINAPI _GetXLIconSizeCB(SIZE *psize)
{
    psize->cx = 3 * GetSystemMetrics(SM_CXICON) / 2;
    psize->cy = 3 * GetSystemMetrics(SM_CYICON) / 2;
}

static const PSIZECALLBACK c_rgSizeCB[SHIL_COUNT] =
{
    _GetLargeIconSizeCB,        // SHIL_LARGE
    _GetSmallIconSizeCB,        // SHIL_SMALL
    _GetXLIconSizeCB,           // SHIL_EXTRALARGE
    _GetSysSmallIconSizeCB,     // SHIL_SYSSMALL 
};

EXTERN_C SHIMAGELIST g_rgshil[SHIL_COUNT] = {0};


BOOL _IsSHILInited()
{
#ifdef DEBUG
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        // If allocation of any one image list failed, all should be NULL.  So
        // make sure they're either all NULL or all non-NULL.
        ASSERTMSG((g_rgshil[0].himl == NULL) == (g_rgshil[i].himl == NULL),
            "_IsSHILInited: g_rgshil is inconsistent.  g_rgshil[0].himl %x, g_rgshil[%x].himl %x", g_rgshil[0].himl, i, g_rgshil[i].himl);
    }
#endif
    return (g_rgshil[0].himl != NULL);
}

int _GetSHILImageCount()
{
#ifdef DEBUG
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        // If insertion of an image into one image list failed, insertion of an
        // image into all image lists should have failed.  So make sure the image
        // counts are all the same.
        ASSERTMSG(ImageList_GetImageCount(g_rgshil[0].himl) == ImageList_GetImageCount(g_rgshil[i].himl),
            "_GetSHILImageCount: g_rgshil is inconsistent.  image counts don't line up.");
    }
#endif
    return ImageList_GetImageCount(g_rgshil[0].himl);
}

//
// System imagelist - Don't change the order of this list.
// If you need to add a new icon, add it to the end of the
// array, and update shellp.h.
//
EXTERN_C UINT const c_SystemImageListIndexes[] = { IDI_DOCUMENT,
                                          IDI_DOCASSOC,
                                          IDI_APP,
                                          IDI_FOLDER,
                                          IDI_FOLDEROPEN,
                                          IDI_DRIVE525,
                                          IDI_DRIVE35,
                                          IDI_DRIVEREMOVE,
                                          IDI_DRIVEFIXED,
                                          IDI_DRIVENET,
                                          IDI_DRIVENETDISABLED,
                                          IDI_DRIVECD,
                                          IDI_DRIVERAM,
                                          IDI_WORLD,
                                          IDI_NETWORK,
                                          IDI_SERVER,
                                          IDI_PRINTER,
                                          IDI_MYNETWORK,
                                          IDI_GROUP,

                                          IDI_STPROGS,
                                          IDI_STDOCS,
                                          IDI_STSETNGS,
                                          IDI_STFIND,
                                          IDI_STHELP,
                                          IDI_STRUN,
                                          IDI_STSUSPEND,
                                          IDI_STEJECT,
                                          IDI_STSHUTD,

                                          IDI_SHARE,
                                          IDI_LINK,
                                          IDI_SLOWFILE,
                                          IDI_RECYCLER,
                                          IDI_RECYCLERFULL,
                                          IDI_RNA,
                                          IDI_DESKTOP,

                                          IDI_CPLFLD,
                                          IDI_STSPROGS,
                                          IDI_PRNFLD,
                                          IDI_STFONTS,
                                          IDI_STTASKBR,

                                          IDI_CDAUDIO,
                                          IDI_TREE,
                                          IDI_STCPROGS,
                                          IDI_STFAV,
                                          IDI_STLOGOFF,
                                          IDI_STFLDRPROP,
                                          IDI_WINUPDATE

                                          ,IDI_MU_SECURITY,
                                          IDI_MU_DISCONN
                                          };


// get g_MaxIcons from the registry, returning TRUE if it has changed

BOOL QueryNewMaxIcons(void)
{
    int MaxIcons = -1;
    HKEY hk = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, NULL, FALSE);
    if (hk)
    {
        MaxIcons = GetRegInt(hk, TEXT("Max Cached Icons"), DEF_MAX_ICONS);
        RegCloseKey(hk);
    }

    if (MaxIcons < 0)
        MaxIcons = DEF_MAX_ICONS;

    int OldMaxIcons = InterlockedExchange((LONG*)&g_MaxIcons, MaxIcons);

    return (OldMaxIcons != MaxIcons);
}

// Initializes shared resources for Shell_GetIconIndex and others

STDAPI_(BOOL) FileIconInit(BOOL fRestoreCache)
{
    BOOL fNotify = FALSE;
    static int s_res = 32;

    QueryNewMaxIcons(); // in case the size of the icon cache has changed

    SIZE rgsize[ARRAYSIZE(g_rgshil)];

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        c_rgSizeCB[i](&rgsize[i]);
    }

    //
    //  get the user prefered color depth from the registry.
    //
    int ccIcon = _GetMetricsRegInt(TEXT("Shell Icon Bpp"), 0);
    g_ccIconDEBUG = ccIcon;

    int res = (int)GetCurColorRes();
    g_resDEBUG = res;

    if (res == 0)
        res = s_res;
    s_res = res;

    if (ccIcon > res)
        ccIcon = 0;

    if (res >= 24)           // Match User32. They will extract 32bpp icons in 24bpp.
        ccIcon = 32;

    if (res <= 8)
        ccIcon = 0; // wouldn't have worked anyway

    ENTERCRITICAL;

    //
    // if we already have a icon cache make sure it is the right size etc.
    //
    BOOL fHadCache = _IsSHILInited();

    BOOL fCacheValid = fHadCache && (ccIcon == g_ccIcon);
    for (int i = 0; fCacheValid && i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].size.cx != rgsize[i].cx ||
            g_rgshil[i].size.cy != rgsize[i].cy)
        {
            fCacheValid = FALSE;
        }
    }

    if (!fCacheValid)
    {
        fNotify = fHadCache;

        FlushIconCache();
        FlushFileClass();

        // if we are the desktop process (explorer.exe), then force us to re-init the cache, so we get
        // the basic set of icons in the right order....
        if (!fRestoreCache && _IsSHILInited() && IsWindowInProcess(GetShellWindow()))
        {
            fRestoreCache = TRUE;
        }

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            g_rgshil[i].size.cx = rgsize[i].cx;
            g_rgshil[i].size.cy = rgsize[i].cy;
        }

        g_ccIcon = ccIcon;

        if (res > 4 && g_ccIcon <= 4)
            g_lrFlags = LR_VGACOLOR;
        else
            g_lrFlags = 0;

        if (g_iLastSysIcon == 0)        // Keep track of which icons are perm.
        {
            if (fRestoreCache)
                g_iLastSysIcon = II_LASTSYSICON;
            else
                g_iLastSysIcon = (II_OVERLAYLAST - II_OVERLAYFIRST) + 1;
        }

        //
        // if
        //   1) we already have the icon cache but want to flush and re-initialize it because of size/color depth change, or
        //   2) we don't have icon cache but want to initialize it, instead of restoring it from disk, or
        //   3) we failed to restore icon cache from disk
        // then, initialize the icon cache with c_SystemImageListIndexes
        //
        if (_IsSHILInited() || !fRestoreCache || !IconCacheRestore(rgsize, g_ccIcon))
        {
            fCacheValid = _ShellImageListInit(g_ccIcon, fRestoreCache);
        }
        else
        {
            fCacheValid = TRUE;
        }
    }

    LEAVECRITICAL;

    if (fCacheValid && fNotify)
    {
        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }

    return fCacheValid;
}


void _ShellImageListTerm()
{
    ASSERTCRITICAL;

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl)
        {
            ImageList_Destroy(g_rgshil[i].himl);
            g_rgshil[i].himl = NULL;
        }
    }
}

void FileIconTerm()
{
    ENTERCRITICAL;

    _ShellImageListTerm();

    LEAVECRITICAL;
}

void _DestroyIcons(HICON *phicons, int cIcons)
{
    for (int i = 0; i < cIcons; i++)
    {
        if (phicons[i])
        {
            DestroyIcon(phicons[i]);
            phicons[i] = NULL;
        }
    }
}

BOOL _ShellImageListInit(UINT flags, BOOL fRestore)
{
    ASSERTCRITICAL;

    //
    // Check if we need to create a mirrored imagelist. [samera]
    //
    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        flags |= ILC_MIRROR;
    }

    BOOL fFailedAlloc = FALSE;
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl == NULL)
        {
            g_rgshil[i].himl = ImageList_Create(g_rgshil[i].size.cx, g_rgshil[i].size.cy, ILC_MASK|ILC_SHARED|flags, 0, 32);
            fFailedAlloc |= (g_rgshil[i].himl == NULL);
        }
        else
        {
            // set the flags incase the colour depth has changed...
            // ImageList_setFlags already calls ImageList_remove on success
            if (!ImageList_SetFlags(g_rgshil[i].himl, ILC_MASK|ILC_SHARED|flags))
            {
                // Couldn't change flags; tough.  At least remove them all.
                ImageList_Remove(g_rgshil[i].himl, -1);
            }
            ImageList_SetIconSize(g_rgshil[i].himl, g_rgshil[i].size.cx, g_rgshil[i].size.cy);
        }

        // set the bk colors to COLOR_WINDOW since this is what will
        // be used most of the time as the bk for these lists (cabinet, tray)
        // this avoids having to do ROPs when drawing, thus making it fast

        if (g_rgshil[i].himl)
        {
            ImageList_SetBkColor(g_rgshil[i].himl, GetSysColor(COLOR_WINDOW));
        }
    }

    // If any imagelist allocation failed, fail the whole initialization
    if (fFailedAlloc)
    {
        _ShellImageListTerm();
        return FALSE;
    }
    else
    {
        // Load all of the icons with fRestore == TRUE
        if (fRestore)
        {
            TCHAR szModule[MAX_PATH];
            HKEY hkeyIcons;

            GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

            // WARNING: this code assumes that these icons are the first in
            // our RC file and are in this order and these indexes correspond
            // to the II_ constants in shell.h.

            hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);

            for (i = 0; i < ARRAYSIZE(c_SystemImageListIndexes); i++) 
            {
                HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

                // check to see if icon is overridden in the registry

                if (hkeyIcons)
                {
                    TCHAR val[10];
                    TCHAR ach[MAX_PATH];
                    DWORD cb = sizeof(ach);

                    wsprintf(val, TEXT("%d"), i);

                    ach[0] = 0;
                    SHQueryValueEx(hkeyIcons, val, NULL, NULL, (LPBYTE)ach, &cb);

                    if (ach[0])
                    {
                        int iIcon = PathParseIconLocation(ach);

                        for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                        {
                            ExtractIcons(ach, iIcon, g_rgshil[j].size.cx, g_rgshil[j].size.cy,
                                            &rghicon[j], NULL, 1, g_lrFlags);
                        }
                    }
                }

                // if we got a large icon, run with that for everyone.  otherwise fall back to loadimage.
                if (rghicon[SHIL_LARGE] == NULL)
                {
                    for (int j = 0; j < ARRAYSIZE(rghicon); j++)
                    {
                        if (rghicon[j] == NULL)
                        {
                            rghicon[j] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(c_SystemImageListIndexes[i]),
                                                IMAGE_ICON, g_rgshil[j].size.cx, g_rgshil[j].size.cy, g_lrFlags);
                        }
                    }
                }

                int iIndex = SHAddIconsToCache(rghicon, szModule, i, 0);
                ASSERT(iIndex == i || iIndex == -1);     // assume index
                _DestroyIcons(rghicon, ARRAYSIZE(rghicon));

                if (iIndex == -1)
                {
                    fFailedAlloc = TRUE;
                    break;
                }
            }

            if (hkeyIcons)
                RegCloseKey(hkeyIcons);

            if (fFailedAlloc)
            {
                FlushIconCache();
                _ShellImageListTerm();
                return FALSE;
            }
        }

        //
        // Refresh the overlay image so that the overlays are added to the imaglist.
        // GetIconOverlayManager() will initialize the overlay manager if necessary.
        //
        IShellIconOverlayManager *psiom;
        if (SUCCEEDED(GetIconOverlayManager(&psiom)))
        {
            psiom->RefreshOverlayImages(SIOM_OVERLAYINDEX | SIOM_ICONINDEX);
            psiom->Release();
        }

        return TRUE;
    }
}

// get a hold of the system image lists

BOOL WINAPI Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall)
{
    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return FALSE;
    }

    if (phiml)
        *phiml = g_rgshil[SHIL_LARGE].himl;

    if (phimlSmall)
        *phimlSmall = g_rgshil[SHIL_SMALL].himl;

    return TRUE;
}

HRESULT SHGetImageList(int iImageList, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return hr;
    }

    ENTERCRITICAL;

    if (iImageList >=0 && iImageList < ARRAYSIZE(g_rgshil))
    {
        hr = HIMAGELIST_QueryInterface(g_rgshil[iImageList].himl, riid, ppvObj);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    LEAVECRITICAL;

    return hr;
}

void WINAPI Shell_SysColorChange(void)
{
    COLORREF clrWindow = GetSysColor(COLOR_WINDOW);

    ENTERCRITICAL;
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        ImageList_SetBkColor(g_rgshil[i].himl, clrWindow);
    }
    LEAVECRITICAL;
}

// simulate the document icon by crunching a copy of an icon and putting it in the
// middle of our default document icon, then add it to the passsed image list
//
// in:
//      hIcon   icon to use as a basis for the simulation
//
// returns:
//      hicon
HBITMAP CreateDIB(HDC h, WORD depth, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = depth;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

BOOL HasAlpha(RGBQUAD* prgb, int cx, int cy)
{
    int iTotal = cx * cy;

    for (int i = 0; i < iTotal; i++)
    {
        if (prgb[i].rgbReserved != 0)
            return TRUE;
    }

    return FALSE;
}

void DorkAlpha(RGBQUAD* prgb, int x, int y, int cx, int cy, int cxTotal)
{
    for (int dy = y; dy < (cy + y); dy++)
    {
        for (int dx = x; dx < (cx + x); dx++)
        {
            prgb[dx + dy * cxTotal].rgbReserved = 255;
        }
    }
}


HICON SimulateDocIcon(HIMAGELIST himl, HICON hIcon, int cx, int cy)
{
    if (himl == NULL || hIcon == NULL)
        return NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        RGBQUAD* prgb;

        // If the display is in 24 or 32bpp mode, we may have alpha icons, so we'll need to create a dib section
        BOOL fAlphaIcon = (GetDeviceCaps(hdc, BITSPIXEL) >= 24)? TRUE: FALSE;
        HBITMAP hbmColor;
        if (fAlphaIcon)
        {
            hbmColor = CreateDIB(hdc, 32, cx, cy, &prgb);
        }
        else
        {
            hbmColor = CreateCompatibleBitmap(hdc, cx, cy);
        }

        if (hbmColor)
        {
            HBITMAP hbmMask = CreateBitmap(cx, cy, 1, 1, NULL);
            if (hbmMask)
            {
                HDC hdcMem = CreateCompatibleDC(hdc);
                if (hdcMem)
                {
                    HBITMAP hbmT = (HBITMAP)SelectObject(hdcMem, hbmMask);
                    UINT iIndex = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
                    ImageList_Draw(himl, iIndex, hdcMem, 0, 0, ILD_MASK);

                    SelectObject(hdcMem, hbmColor);
                    ImageList_DrawEx(himl, iIndex, hdcMem, 0, 0, 0, 0, RGB(0,0,0), CLR_DEFAULT, ILD_NORMAL);

                    // Check to see if the parent has alpha. If so, we'll have to dork with the child's alpha later on.
                    BOOL fParentHasAlpha = fAlphaIcon?HasAlpha(prgb, cx, cy):FALSE;

                    HDC hdcMemChild = CreateCompatibleDC(hdcMem);
                    if (hdcMemChild)
                    {
                        // Notes:
                        // First: create a 24bpp Dibsection. We want to merge the alpha channel into the final image,
                        //        not preserve it.
                        // Second: The document icon has "Goo" in it. We remove this goo by blitting white into it, then 
                        //         merging the child bitmap
                        HBITMAP hbmp = CreateDIB(hdc, 24, cx/2 + 2, cy/2 + 2, NULL);
                        if (hbmp)
                        {
                            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMemChild, hbmp);

                            RECT rc;
                            rc.left = 0;
                            rc.top = 0;
                            rc.right = cx/2 + 3;    // Extra space to remove goo in the document icon
                            rc.bottom = cy/2 + 3;

                            // Fill with white. NOTE: don't use PatBlt because it actually adds an alpha channel!
                            SHFillRectClr(hdcMemChild, &rc, RGB(255,255,255));

                            DrawIconEx(hdcMemChild, 1, 1, hIcon, cx/2, cy/2, 0, NULL, DI_NORMAL);

                            BitBlt(hdcMem, cx/4-1, cy/4-1, cx/2+3, cy/2+3, hdcMemChild, 0, 0, SRCCOPY);
                            SelectObject(hdcMemChild, hbmpOld);
                            DeleteObject(hbmp);
                        }
                        DeleteDC(hdcMemChild);
                    }

                    if (fParentHasAlpha)
                    {
                        // If the parent had alpha, we need to bring the child alpha to opaqe
                        DorkAlpha(prgb, cx/4, cy/4, cx/2, cy/2, cx);
                    }

                    SelectBitmap(hdcMem, hbmT);
                    DeleteDC(hdcMem);
                }

                ICONINFO ii = {0};
                ii.fIcon    = TRUE;
                ii.hbmColor = hbmColor;
                ii.hbmMask  = hbmMask;
                hIcon = CreateIconIndirect(&ii);

                DeleteObject(hbmMask);
            }
            DeleteObject(hbmColor);
        }
        ReleaseDC(NULL, hdc);
    }

    return hIcon;
}

// Check if the same number of images is present in all of the image lists.
// If any of the imagelists have less icons than the others, fill the imagelist
// in with the document icon to make them all consistent.
//
// Eg:  WebZip v3.80 and v4.00 queries for the large and small image lists,
// and adds 2 icons to it.  However, it doesn't know to add these icons to the
// newer image lists.  Hence, the image lists are out of sync, and later on,
// the wrong icon appears in their treeview.
//
// Allaire Homesite 4.5 does the same thing.

void CheckConsistencyOfImageLists(void)
{
    // This has to be done under the critical section to avoid race conditions.
    // Otherwise, if another thread is adding icons to the image list,
    // we will think it is corrupted when in fact it is just fine, and
    // then our attempts to repair it will corrupt it!

    ASSERTCRITICAL;

    int i, iMax = 0, iImageListsCounts[ARRAYSIZE(g_rgshil)];
    BOOL bIdentical = TRUE;


    // Loop through all the image lists getting:
    //
    // 1) the image count for each list
    // 2) Compare the count against the count of the first (large)
    //    imagelist to see if there are any differences.
    // 3) Determine the max number of images (in a single list) across all the image lists

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        iImageListsCounts[i] = ImageList_GetImageCount (g_rgshil[i].himl);

        if (iImageListsCounts[i] != iImageListsCounts[0])
        {
            bIdentical = FALSE;
        }

        if (iImageListsCounts[i] > iMax)
        {
            iMax = iImageListsCounts[i];
        }
    }

    if (bIdentical)
    {
        return;
    }


    // For each imagelist, add the document icon as filler to bring it upto iMax in size

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (iImageListsCounts[i] < iMax)
        {
            HICON hIcon = (HICON) LoadImage (HINST_THISDLL, MAKEINTRESOURCE(IDI_DOCUMENT),
                                             IMAGE_ICON, g_rgshil[i].size.cx,
                                             g_rgshil[i].size.cy, LR_DEFAULTCOLOR);
            if (hIcon)
            {
                while (iImageListsCounts[i] < iMax)
                {
                    ImageList_ReplaceIcon (g_rgshil[i].himl, -1, hIcon);
                    iImageListsCounts[i]++;
                }

                DestroyIcon (hIcon);
            }
        }
    }
}

// add icons to the system imagelist (icon cache) and put the location
// in the location cache
//
// in:
//      hIcon, hIconSmall       the icons, hIconSmall can be NULL
//      pszIconPath             locations (for location cache)
//      iIconIndex              index in pszIconPath (for location cache)
//      uIconFlags              GIL_ flags (for location cahce)
// returns:
//      location in system image list
//
int SHAddIconsToCache(HICON rghicon[SHIL_COUNT], LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    int iImage = -1;

    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return iImage;
    }

    //
    // NOTE: user should call SHLookupIconIndex or RemoveFromIconTable first to make sure 
    // it isn't already in shell icon cache, or use Shell_GetCachedImageIndex to add icons to
    // the cache. Adding the same icon to icon cache several times may cause shell to flash.
    //
    if (!(uIconFlags & GIL_DONTCACHE))
    {
        iImage = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
        if (-1 != iImage)
        {
            return iImage;
        }
    }

    HICON rghiconT[ARRAYSIZE(g_rgshil)] = {0};

    BOOL fFailure = FALSE;
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (rghicon == NULL)
        {
            SHDefExtractIcon(pszIconPath, iIconIndex, uIconFlags, &rghiconT[i], NULL, g_rgshil[i].size.cx);
        }
        else
        {
            if (rghicon[i])
            {
                rghiconT[i] = rghicon[i];
            }
            else
            {
                rghiconT[i] = rghicon[SHIL_LARGE];
            }
        }

        if (rghiconT[i] == NULL)
        {
            fFailure = TRUE;
            break;
        }
    }

    ENTERCRITICAL;

    // test again in case there was a race between the test at the top and the
    // icon loading code.

    if (!(uIconFlags & GIL_DONTCACHE))
    {
        iImage = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
    }

    if (!fFailure && _IsSHILInited() && (-1 == iImage))
    {
        // still not in the table so we

        CheckConsistencyOfImageLists();

        int iImageFree = GetFreeImageIndex();

        TraceMsg(TF_IMAGE, "FreeImageIndex = %d", iImageFree);

        for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            int iImageT = ImageList_ReplaceIcon(g_rgshil[i].himl, iImageFree, rghiconT[i]);

            TraceMsg(TF_IMAGE, "ImageList_ReplaceIcon(%d) returned = %d", i, iImageT);

            if (iImageT < 0)
            {
                // failure -- break and undo changes
                break;
            }
            else
            {
                ASSERT(iImage == -1 || iImage == iImageT);
                iImage = iImageT;
            }
        }

        if (i < ARRAYSIZE(g_rgshil))
        {
            // failure
            if (iImageFree == -1)
            {
                // only remove it if it was added at the end otherwise all the
                // index's above iImage will change.
                // ImageList_ReplaceIcon should only fail on the end anyway.
                for (int j = 0; j < i; j++)
                {
                    ImageList_Remove(g_rgshil[j].himl, iImage);
                }
            }
            iImage = -1;
        }
        else
        {
            // success
            ASSERT(iImage >= 0);
            AddToIconTable(pszIconPath, iIconIndex, uIconFlags, iImage);
        }
    }

    LEAVECRITICAL;

    if (rghicon == NULL)
    {
        // destroy the icons we allocated
        _DestroyIcons(rghiconT, ARRAYSIZE(rghiconT));
    }

    return iImage;
}

//
//  default handler to extract a icon from a file
//
//  supports GIL_SIMULATEDOC
//
//  returns S_OK if success
//  returns S_FALSE if the file has no icons (or not the asked for icon)
//  returns E_FAIL for files on a slow link.
//  returns E_FAIL if cant access the file
//
//  LOWORD(nIconSize) = normal icon size
//  HIWORD(nIconSize) = smal icon size
//
STDAPI SHDefExtractIcon(LPCTSTR pszIconFile, int iIndex, UINT uFlags,
                        HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HICON hIcons[2] = {0, 0};

    UINT u;

#ifdef DEBUG
    TCHAR ach[128];
    GetModuleFileName(HINST_THISDLL, ach, ARRAYSIZE(ach));

    if (lstrcmpi(pszIconFile, ach) == 0 && iIndex >= 0)
    {
        TraceMsg(TF_WARNING, "Re-extracting %d from SHELL32.DLL", iIndex);
    }
#endif

    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);

    //
    //  get the icon from the file
    //
    if (PathIsSlow(pszIconFile, -1))
    {
        DebugMsg(DM_TRACE, TEXT("not extracting icon from '%s' because of slow link"), pszIconFile);
        return E_FAIL;
    }

#ifdef XXDEBUG
    TraceMsg(TF_ALWAYS, "Extracting icon %d from %s.", iIndex, pszIconFile);
    Sleep(500);
#endif

    //
    // nIconSize == 0 means use the default size.
    // Backup is passing nIconSize == 1 need to support them too.
    //
    if (nIconSize <= 2)
        nIconSize = MAKELONG(g_cxIcon, g_cxSmIcon);

    if (uFlags & GIL_SIMULATEDOC)
    {
        HICON hIconSmall;

        u = ExtractIcons(pszIconFile, iIndex, g_cxSmIcon, g_cySmIcon,
            &hIconSmall, NULL, 1, g_lrFlags);

        if (u == -1)
            return E_FAIL;

        hIcons[0] = SimulateDocIcon(himlLarge, hIconSmall, g_cxIcon, g_cyIcon);
        hIcons[1] = SimulateDocIcon(himlSmall, hIconSmall, g_cxSmIcon, g_cySmIcon);

        if (hIconSmall)
            DestroyIcon(hIconSmall);
    }
    else
    {
        u = ExtractIcons(pszIconFile, iIndex, nIconSize, nIconSize,
            hIcons, NULL, 2, g_lrFlags);

        if (-1 == u)
            return E_FAIL;

#ifdef DEBUG
        if (0 == u)
        {
            TraceMsg(TF_WARNING, "Failed to extract icon %d from %s.", iIndex, pszIconFile);    
        }
#endif
    }

    if (phiconLarge)
        *phiconLarge = hIcons[0];
    else if (hIcons[0])
        DestroyIcon(hIcons[0]);

    if (phiconSmall)
        *phiconSmall = hIcons[1];
    else if (hIcons[1])
        DestroyIcon(hIcons[1]);

    return u == 0 ? S_FALSE : S_OK;
}


#ifdef UNICODE

STDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_STRING_PTRA(pszIconFile, -1))
    {
        WCHAR wsz[MAX_PATH];

        SHAnsiToUnicode(pszIconFile, wsz, ARRAYSIZE(wsz));
        hr = SHDefExtractIcon(wsz, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }
    return hr;
}

#else

STDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_STRING_PTRW(pszIconFile, -1))
    {
        char sz[MAX_PATH];

        SHUnicodeToAnsi(pszIconFile, sz, ARRAYSIZE(sz));
        hr = SHDefExtractIcon(sz, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }
    return hr;
}

#endif

//
// in:
//      pszIconPath     file to get icon from (eg. cabinet.exe)
//      iIconIndex      icon index in pszIconPath to get
//      uIconFlags      GIL_ values indicating simulate doc icon, etc.

int WINAPI Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    // lots of random codepaths from APIs end up here before init
    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);
        if (!_IsSHILInited())
        {
            return -1;
        }
    }

    int iImageIndex = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
    if (iImageIndex == -1)
    {
        iImageIndex = SHAddIconsToCache(NULL, pszIconPath, iIconIndex, uIconFlags);
    }

    return iImageIndex;
}

STDAPI_(void) FixPlusIcons()
{
    // nuke all of the shell internal icons
    HKEY hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);
    if (hkeyIcons)
    {
        for (int i = 0; i < ARRAYSIZE(c_SystemImageListIndexes); i++) 
        {
            TCHAR szRegPath[10], szBuf[MAX_PATH];
            DWORD cb = sizeof(szBuf);

            wsprintf(szRegPath, TEXT("%d"), i);

            if (SHQueryValueEx(hkeyIcons, szRegPath, NULL, NULL, (LPBYTE)szBuf, &cb) == ERROR_SUCCESS &&
                StrStrI(szBuf, TEXT("cool.dll")))
            {
                RegDeleteValue(hkeyIcons, szRegPath);
            }
        }
        RegCloseKey(hkeyIcons);
    }
    static const struct
    {
        const CLSID* pclsid;
        LPCTSTR pszIcon;
    }
    c_rgCLSID[] =
    {
        { &CLSID_NetworkPlaces,     TEXT("shell32.dll,17") },
        { &CLSID_ControlPanel,      TEXT("shell32.dll,-137") },
        { &CLSID_Printers,          TEXT("shell32.dll,-138") },
        { &CLSID_MyComputer,        TEXT("explorer.exe,0") },
        { &CLSID_Remote,            TEXT("rnaui.dll,0") },
        { &CLSID_CFonts,            TEXT("fontext.dll,-101") },
        { &CLSID_RecycleBin,        NULL },
        { &CLSID_Briefcase,         NULL },
    };

    for (int i = 0; i < ARRAYSIZE(c_rgCLSID); i++)
    {
        TCHAR szCLSID[64], szRegPath[128], szBuf[MAX_PATH];
        LONG cb = sizeof(szBuf);

        SHStringFromGUID(*c_rgCLSID[i].pclsid, szCLSID, ARRAYSIZE(szCLSID));
        wsprintf(szRegPath, TEXT("CLSID\\%s\\DefaultIcon"), szCLSID);

        if (SHRegQueryValue(HKEY_CLASSES_ROOT, szRegPath, szBuf, &cb) == ERROR_SUCCESS &&
            StrStrI(szBuf, TEXT("cool.dll")))
        {
            if (IsEqualGUID(*c_rgCLSID[i].pclsid, CLSID_RecycleBin))
            {
                RegSetValueString(HKEY_CLASSES_ROOT, szRegPath, TEXT("Empty"), TEXT("shell32.dll,31"));
                RegSetValueString(HKEY_CLASSES_ROOT, szRegPath, TEXT("Full"), TEXT("shell32.dll,32"));
                if (StrStr(szBuf, TEXT("20")))
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, TEXT("shell32.dll,31")); // empty
                else
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, TEXT("shell32.dll,32")); // full
            }
            else
            {
                if (c_rgCLSID[i].pszIcon)
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, c_rgCLSID[i].pszIcon);
                else
                    RegDeleteValue(HKEY_CLASSES_ROOT, szRegPath);
            }
        }
    }

    static const struct
    {
        LPCTSTR pszProgID;
        LPCTSTR pszIcon;
    }
    c_rgProgID[] =
    {
        { TEXT("Folder"),   TEXT("shell32.dll,3") },
        { TEXT("Directory"),TEXT("shell32.dll,3") },
        { TEXT("Drive"),    TEXT("shell32.dll,8") },
        { TEXT("drvfile"),  TEXT("shell32.dll,-154") },
        { TEXT("vxdfile"),  TEXT("shell32.dll,-154") },
        { TEXT("dllfile"),  TEXT("shell32.dll,-154") },
        { TEXT("sysfile"),  TEXT("shell32.dll,-154") },
        { TEXT("txtfile"),  TEXT("shell32.dll,-152") },
        { TEXT("inifile"),  TEXT("shell32.dll,-151") },
        { TEXT("inffile"),  TEXT("shell32.dll,-151") },
    };

    for (i = 0; i < ARRAYSIZE(c_rgProgID); i++)
    {
        TCHAR szRegPath[128], szBuf[MAX_PATH];
        LONG cb = sizeof(szBuf);

        wsprintf(szRegPath, TEXT("%s\\DefaultIcon"), c_rgProgID[i].pszProgID);

        if (SHRegQueryValue(HKEY_CLASSES_ROOT, szRegPath, szBuf, &cb) == ERROR_SUCCESS &&
            StrStrI(szBuf, TEXT("cool.dll")))
        {
            RegSetString(HKEY_CLASSES_ROOT, szRegPath, c_rgProgID[i].pszIcon);
        }
    }

    FlushIconCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filetbl.cpp ===
// routines for managing the icon cache tables, and file type tables.
// Jan 95, ToddLa
//
//  icon cache
//
//      the icon cache is n ImageLists
//      and a table mapping a name/icon number/flags to a ImageList
//      index, the global hash table (pht==NULL) is used to hold
//      the names.
//
//          AddToIconTable      - associate a name/number/flags with a image index
//          SHLookupIconIndex   - return a image index, given name/number/flags
//          RemoveFromIconTable - remove all entries with the given name
//          FlushIconCache      - remove all entries.
//          GetFreeImageIndex   - return a free ImageList index.
//
//      the worst part about the whole icon cache design is that people
//      can add or lookup a image index (given a name/number/flags) but
//      they never have to release it.  we never know if a ImageList index
//      is currently in use or not.  this should be the first thing
//      fixed about the shell.  currently we use a MRU type scheme when
//      we need to remove a entry from the icon cache, it is far from
//      perfect.
//
//  file type cache
//
//      the file type cache is a hash table with two DWORDs of extra data.
//      DWORD #0 holds flags, DWORD #1 holds a pointer to the name of
//      the class.
//
//          LookupFileClass     - given a file class (ie ".doc" or "Directory")
//                                maps it to a DWORD of flags, return 0 if not found.
//
//          AddFileClass        - adds a class (and flags) to cache
//
//          LookupFileClassName - given a file class, returns it name.
//          AddFileClassName    - sets the name of a class.
//          FlushFileClass      - removes all items in cache.
//

#include "shellprv.h"
#pragma  hdrstop

#include "filetbl.h"
#include "fstreex.h"
#include <ntverp.h>
#include "ovrlaymn.h"
#include "dpa.h"

typedef struct {
    DWORD cbSize;         // size of this header.
    DWORD dwMagic;        // magic number
    DWORD dwVersion;      // version of this saved icon cache
    DWORD dwBuild;        // windows build number
    DWORD dwNumIcons;     // number of icons in cache
    DWORD dwColorRes;     // color resolution of device at last save
    DWORD dwFlags;        // ILC_* flags
    DWORD dwTimeSave;     // icon time this file was saved
    DWORD dwTimeFlush;    // icon time we last flushed.
    DWORD dwFreeImageCount;
    DWORD dwFreeEntryCount;
    SIZE rgsize[SHIL_COUNT];  // array of sizes of cached icons
    DWORD cImageLists;      // equal to ARRAYSIZE(IC_HEAD.size)
} IC_HEAD;

#define ICONCACHE_MAGIC  (TEXT('W') + (TEXT('i') << 8) + (TEXT('n') << 16) + (TEXT('4') << 24))
#define ICONCACHE_VERSION 0x0505        // Unicode file names + lower case hash items + v6 imagelist

typedef struct {
    LPCTSTR  szName;     // key: file name
    int     iIconIndex; // key: icon index (or random DWORD for GIL_NOTFILE)
    UINT    uFlags;     // GIL_* flags
    int     iILIndex;   // data: system image list index
    UINT    Access;     // last access.
} LOCATION_ENTRY;

// LOCATION_ENTRY32 is the version of LOCATION_ENTRY that gets written to disk
// It must be declared explicitly 32-bit for Win32/Win64 interop.
typedef struct {
    DWORD   dwszName;   // (garbage in file)
    int     iIconIndex; // key: icon index (or random DWORD for GIL_NOTFILE)
    UINT    uFlags;     // GIL_* flags
    int     iILIndex;     // data: system image list index
    UINT    Access;     // last access.
} LOCATION_ENTRY32;

//
//  MIN_FLUSH is the minimum time interval between flushing the icon cache
//  this number is in IconTime
//
#ifdef DEBUG
#define MIN_FLUSH   60          // 60 == 1 min
#else
#define MIN_FLUSH   900         // 900 == 15min
#endif

//  all file/icons in the location table are "time stamped"
//  each time they are accessed.
//
//  this way we know the most important ones (MRU)
//
//  when the icon cache get tooooo big we sort them all
//  and throw out the old ones.

#define ICONTIME_ZERO   0

//  GetIconTime() returns the "clock" used to timestamp icons
//  in the icon table for MRU.  the clock incrments once every 1024ms
//  (about once every second)

#define GetIconTime()   (g_dwIconTimeBase + (GetTickCount() >> 10))


extern int g_ccIcon;

TIMEVAR(LookupFileClass);
TIMEVAR(AddFileClass);

TIMEVAR(LookupFileClassName);
TIMEVAR(AddFileClassName);

TIMEVAR(LookupFileSCIDs);
TIMEVAR(AddFileSCIDs);

TIMEVAR(LookupIcon);
TIMEVAR(RemoveIcon);
TIMEVAR(AddIcon);
TIMEVAR(IconFlush);

DWORD g_dwIconTimeBase      = ICONTIME_ZERO;
DWORD g_dwIconTimeFlush     = ICONTIME_ZERO;
DWORD g_dwFreeImageCount    = 0;
DWORD g_dwFreeEntryCount    = 0;

CDSA<LOCATION_ENTRY> *g_pdsaLocationEntries = NULL;
BOOL g_fDirtyIcons = FALSE;
UINT g_iLastSysIcon = 0;

typedef struct
{
    PCTSTR pszClassName;
    DWORD dwFlags;
    PERCEIVED gen;
    UINT cSCID;
    SHCOLUMNID* ascid;
} FILECLASSENTRY;

// these GIL_ (GetIconLocation) flags are used when searching for a
// match in the icon table. all other flags are ignored (when searching
// for a match)
//
// NOTE! If you change this definition, you also have to update the
// documentation for SHUpdateImage (since these are the bits that
// SHUpdateImage uses, too)
#define GIL_COMPARE (GIL_SIMULATEDOC | GIL_NOTFILENAME)

void _InitIconOverlayIndices(void);
BOOL _IconIndexInOverlayManager(int iILIndex);


LOCATION_ENTRY* _LookupIcon(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    ASSERTCRITICAL

    TCHAR szLower[MAX_PATH];
    lstrcpy(szLower, pszName);
    CharLower(szLower);

    pszName = FindHashItem(NULL, szLower);

    LOCATION_ENTRY *pFound = NULL;
    if (pszName && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if ((p->szName == pszName) &&
                ((UINT)(p->uFlags & GIL_COMPARE) == (uFlags & GIL_COMPARE)) &&
                (p->iIconIndex == iIconIndex))
            {
                p->Access = GetIconTime();
                pFound = p;
                break;  // we are done
            }
        }
    }
    return pFound;
}


int LookupIconIndex(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    ENTERCRITICAL;
    TIMESTART(LookupIcon);

    LOCATION_ENTRY *p = _LookupIcon(pszName, iIconIndex, uFlags);
    int iILIndex = p ? p->iILIndex : -1;

    TIMESTOP(LookupIcon);
    LEAVECRITICAL;

    return iILIndex;
}

STDAPI_(int) SHLookupIconIndex(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    return LookupIconIndex(pszName, iIconIndex, uFlags);
}

#ifdef UNICODE

STDAPI_(int) SHLookupIconIndexA(LPCSTR pszName, int iIconIndex, UINT uFlags)
{
    WCHAR wsz[MAX_PATH];

    SHAnsiToUnicode(pszName, wsz, ARRAYSIZE(wsz));
    return SHLookupIconIndex(wsz, iIconIndex, uFlags);
}    

#else

STDAPI_(int) SHLookupIconIndexW(LPCWSTR pszName, int iIconIndex, UINT uFlags)
{
    char sz[MAX_PATH];
    
    SHUnicodeToAnsi(pszName, sz, ARRAYSIZE(sz));
    return SHLookupIconIndex(sz, iIconIndex, uFlags);
}    

#endif

// returns a free image index, or -1 if none

int GetFreeImageIndex(void)
{
    int iILIndex = -1;

    ASSERTCRITICAL

    if (g_dwFreeImageCount && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == NULL && p->iILIndex != 0)
            {
                iILIndex = p->iILIndex;         // get free index
                p->iILIndex = 0;            // claim it.
                p->Access = ICONTIME_ZERO;  // mark unused entry.
                g_dwFreeImageCount--;
                g_dwFreeEntryCount++;
                break;
            }
        }
    }

    return iILIndex;
}

int GetImageIndexUsage(int iILIndex)
{
    int usage = 0;

    ASSERTCRITICAL

    if (g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->iILIndex == iILIndex)
            {
                usage++;
            }
        }
    }

    return usage;
}

//
// free specified icon table entry. If this makes a system image list index available
// for reuse, check whether this index is cached by file class table. If it is, return
// the image index and caller is responsible for updating file class table and display.
// O/w return -1.
// 
int _FreeEntry(LOCATION_ENTRY *p)
{
    int iUsageCount;

    ASSERTCRITICAL

    TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is freed",
        p->szName, p->iIconIndex, p->uFlags, p->iILIndex, p->Access);

    g_fDirtyIcons = TRUE;        // we need to save now.

    ASSERT(p->szName);
    DeleteHashItem(NULL, p->szName);
    p->szName = 0;

    iUsageCount = GetImageIndexUsage(p->iILIndex);
    if (iUsageCount > 1)
    {
        TraceMsg(TF_IMAGE, "Icon cache: count for %d was %d (is now minus 1)", p->iILIndex, iUsageCount);
        g_dwFreeEntryCount++;
        p->iILIndex = 0;              // unused entry
        p->Access = ICONTIME_ZERO;
    }
    else
    {
        TraceMsg(TF_IMAGE, "Icon cache: count for %d was %d (is now free)", p->iILIndex, iUsageCount);
        g_dwFreeImageCount++;
        p->Access = ICONTIME_ZERO;

        if (IconIndexInFileClassTable(p->iILIndex) || _IconIndexInOverlayManager(p->iILIndex))
        {
            TraceMsg(TF_IMAGE, "Icon cache: system imagelist index %d is released for reuse", p->iILIndex);
            return p->iILIndex;
        }
    }

    return -1;
}

LOCATION_ENTRY *GetFreeEntry(void)
{
    ASSERTCRITICAL

    if (g_dwFreeEntryCount && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == NULL && p->iILIndex == 0)
            {
                g_dwFreeEntryCount--;
                return p;
            }
        }
    }

    return NULL;
}

//  add a item the the cache
//
//      lpszIconFile    - filename to add
//      iIconIndex      - icon index in file.
//      uFlags          - flags
//                          GIL_SIMULATEDOC - this is a simulated doc icon
//                          GIL_NOTFILENAME - file is not a path/index that
//                                            ExtractIcon can deal with
//      iIndex          - image index to use.
//
//  returns:
//      image index for new entry.
//
//  notes:
//      if the item already exists it is replaced.
//
HRESULT AddToIconTable(LPCTSTR pszName, int iIconIndex, UINT uFlags, int iILIndex)
{
    HRESULT hr = E_FAIL;
    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    if (pszName)
    {
        ENTERCRITICAL;
        TIMESTART(AddIcon);

        if (g_pdsaLocationEntries == NULL)
        {
            g_pdsaLocationEntries = CDSA_Create<LOCATION_ENTRY>(8);

            g_dwFreeEntryCount = 0;
            g_dwFreeImageCount = 0;
            g_dwIconTimeBase   = 0;
            g_dwIconTimeBase   = 0-GetIconTime();
            g_dwIconTimeFlush  = 0;
        }

        if (g_pdsaLocationEntries)
        {
            g_fDirtyIcons = TRUE;        // we need to save now.

            LOCATION_ENTRY *ple;

            if (0 == (uFlags & GIL_DONTCACHE))
            {
                ple = _LookupIcon(pszName, iIconIndex, uFlags);
                if (ple)
                {
                    if (ple->iILIndex == iILIndex)
                    {
                        hr = S_FALSE;       // We've already got this guy, no problem
                    }
                    else
                    {
                        AssertMsg(ple == NULL,TEXT("Don't call AddToIconTable with somebody who is already there!\n"));
                    }
                }
            }

            if (FAILED(hr))
            {
                TCHAR szLower[MAX_PATH];
                lstrcpy(szLower, pszName);
                CharLower(szLower);
                pszName = AddHashItem(NULL, szLower);
                if (pszName)
                {
                    LOCATION_ENTRY le;
                    le.szName = pszName;
                    le.iIconIndex = iIconIndex;
                    le.iILIndex = iILIndex;
                    le.uFlags = uFlags;
                    le.Access = GetIconTime();

                    ple = GetFreeEntry();

                    if (NULL != ple)
                    {
                        TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is added (unfreed)",
                            le.szName, le.iIconIndex, le.uFlags, le.iILIndex, le.Access);

                        *ple = le;
                        hr = S_OK;
                    }
                    else
                    {
                        if (g_pdsaLocationEntries->AppendItem(&le) != -1)
                        {
                            TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is added",
                                le.szName, le.iIconIndex, le.uFlags, le.iILIndex, le.Access);

                            hr = S_OK;
                        }
                    }
                }
            }
        }

        TIMESTOP(AddIcon);
        LEAVECRITICAL;
    }

    return hr;
}

void RemoveFromIconTable(LPCTSTR pszName)
{
    BOOL fUpdateFileClass = FALSE;

    ENTERCRITICAL;
    TIMESTART(RemoveIcon);

    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    TCHAR szLower[MAX_PATH];
    lstrcpy(szLower, pszName);
    CharLower(szLower);
    pszName = FindHashItem(NULL, szLower);
    if (pszName && g_pdsaLocationEntries)
    {
        TraceMsg(TF_IMAGE, "IconCache: flush \"%s\"", pszName);
        LOCATION_ENTRY *p;
        UINT i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == pszName && i > g_iLastSysIcon)
            {
                if (-1 != _FreeEntry(p))
                    fUpdateFileClass = TRUE;
            }
        }
    }

    TIMESTOP(RemoveIcon);
    LEAVECRITICAL;

    if (fUpdateFileClass)
    {
        TraceMsg(TF_IMAGE, "Icon cache deleted some class items, broadcasting SHCNE_UPDATEIMAGE");

        FlushFileClass();
        _InitIconOverlayIndices();  // Tell overlay manager to re-determine icon indices

        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }

    return;
}

//
// empties the icon cache
//
void FlushIconCache(void)
{
    ENTERCRITICAL;

    if (g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName)
                DeleteHashItem(NULL, p->szName);
        }

        g_pdsaLocationEntries->DeleteAllItems();
        g_dwFreeEntryCount = 0;
        g_dwFreeImageCount = 0;
        g_dwIconTimeBase   = 0;
        g_dwIconTimeBase   = 0-GetIconTime();
        g_dwIconTimeFlush  = 0;
        g_fDirtyIcons   = TRUE;        // we need to save now.
    }

    LEAVECRITICAL;
}

//
// if the icon cache is too big get rid of some old items.
//
// remember FlushIconCache() removes *all* items from the
// icon table, and this function gets rid of *some* old items.
//
STDAPI_(void) IconCacheFlush(BOOL fForce)
{
    int nuked = 0;

    ENTERCRITICAL;

    if (g_pdsaLocationEntries)
    {
        // conpute the time from the last flush call
        DWORD dt = GetIconTime() - g_dwIconTimeFlush;

        // compute the number of "active" table entries.
        int active = g_pdsaLocationEntries->GetItemCount() - g_dwFreeEntryCount - g_dwFreeImageCount;
        ASSERT(active >= 0);

        if (fForce || (dt > MIN_FLUSH && active >= g_MaxIcons))
        {
            TraceMsg(TF_IMAGE, "_IconCacheFlush: removing all items older than %d. %d icons in cache", dt/2, active);

            LOCATION_ENTRY *p;
            UINT i, n = g_pdsaLocationEntries->GetItemCount();

            for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
            {
                if (i <= g_iLastSysIcon)
                    continue;

                if (p->szName)
                {
                    TraceMsg(TF_IMAGE, "_IconCacheFlush: \"%s,%d\" old enough? %d v %d", p->szName, p->iIconIndex, g_dwIconTimeFlush + dt/2, p->Access);
                }

                if (p->szName && p->Access < (g_dwIconTimeFlush + dt/2))
                {
                    nuked++;
                    _FreeEntry(p);
                }
            }

            if (nuked > 0)
            {
                g_dwIconTimeFlush = GetIconTime();
                g_fDirtyIcons  = TRUE;        // we need to save now.
            }
        }
    }

    LEAVECRITICAL;

    if (nuked > 0)
    {
        FlushFileClass();
        _InitIconOverlayIndices();  // Tell overlay manager to re-determine icon indices

        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }
}

#ifdef DEBUG

void _IconCacheDump()
{
    TCHAR szBuffer[MAX_PATH];

    ENTERCRITICAL;
    if (g_pdsaLocationEntries && _IsSHILInited() && (g_dwDumpFlags & DF_ICONCACHE))
    {
        int cItems = g_pdsaLocationEntries->GetItemCount();

        TraceMsg(TF_IMAGE, "Icon cache: %d icons  (%d free)", cItems, g_dwFreeEntryCount);
        TraceMsg(TF_IMAGE, "Icon cache: %d images (%d free)", _GetSHILImageCount(), g_dwFreeImageCount);

        for (int i = 0; i < cItems; i++)
        {
            LOCATION_ENTRY *pLocEntry = g_pdsaLocationEntries->GetItemPtr(i);

            if (pLocEntry->szName)
                GetHashItemName(NULL, pLocEntry->szName, szBuffer, ARRAYSIZE(szBuffer));
            else
                lstrcpy(szBuffer, TEXT("(free)"));

            TraceMsg(TF_ALWAYS, "%s;%d%s%s\timage=%d access=%d",
                (LPTSTR)szBuffer,
                pLocEntry->iIconIndex,
                ((pLocEntry->uFlags & GIL_SIMULATEDOC) ? TEXT(" doc"):TEXT("")),
                ((pLocEntry->uFlags & GIL_NOTFILENAME) ? TEXT(" not file"):TEXT("")),
                pLocEntry->iILIndex, pLocEntry->Access);
        }
    }
    LEAVECRITICAL;
}
#endif

DWORD GetBuildNumber()
{
    // Need to use DLL version as we are updating this dll plus others and
    // we need the cache to be invalidated as we may change the icons...
    return VER_PRODUCTVERSION_DW;
}

#ifdef _WIN64

//
//  ps        - stream to which to save
//  hda       - DSA of LOCATION_ENTRY structures
//  cle       - count of LOCATION_ENTRY32's to write
//
//  The structures are stored as LOCATION_ENTRY32 on disk.
//

HRESULT _IconCacheWriteLocations(IStream *pstm, HDSA hdsa, int cle)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Convert from LOCATION_ENTRY to LOCATION_ENTRY32, then write out
    // the LOCATION_ENTRY32 structures.

    LOCATION_ENTRY32 *rgle32 = (LOCATION_ENTRY32*)LocalAlloc(LPTR, cle * sizeof(LOCATION_ENTRY32));
    if (rgle32)
    {
        LOCATION_ENTRY *rgle = (LOCATION_ENTRY*)DSA_GetItemPtr(hdsa, 0);
        for (int i = 0; i < cle; i++)
        {
            rgle32[i].iIconIndex = rgle[i].iIconIndex;
            rgle32[i].uFlags     = rgle[i].uFlags;
            rgle32[i].iILIndex   = rgle[i].iILIndex;
            rgle32[i].Access     = rgle[i].Access;
        }

        hr = IStream_Write(pstm, rgle32, cle * sizeof(LOCATION_ENTRY32));
        LocalFree(rgle32);
    }
    return hr;
}

#else

__inline HRESULT _IconCacheWriteLocations(IStream *pstm, HDSA hdsa, int cle)
{
    // LOCATION_ENTRY and LOCATION_ENTRY32 are the same, so we can
    // read straight into the DSA data block
    COMPILETIME_ASSERT(sizeof(LOCATION_ENTRY) == sizeof(LOCATION_ENTRY32));
    return IStream_Write(pstm, DSA_GetItemPtr(hdsa, 0), cle * sizeof(LOCATION_ENTRY));
}
#endif

HRESULT GetIconCachePath(LPTSTR pszPath)
{
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, pszPath);
    if (SUCCEEDED(hr))
    {
        if (!PathAppend(pszPath, TEXT("IconCache.db")))
            hr = E_FAIL;
    }
    return hr;
}


// TODO: Make this function compute the actual required size.
ULONG _GetIconCacheSize()
{
    // Set the initial size to 6MB to prevent excessive fragmentation on the disk
    ULONG uSize = 6*1024*1024;

    return uSize;
}

// persist the icon cache to a file

STDAPI_(BOOL) IconCacheSave()
{
    HRESULT hr = S_OK;  // assume OK

    // if the icon cache is not dirty no need to save anything
    if (IsMainShellProcess() && g_pdsaLocationEntries && g_fDirtyIcons)
    {
        // if the icon cache is way too big dont save it.
        // reload g_MaxIcons in case the user set it before shutting down.

        QueryNewMaxIcons();
        if ((UINT)g_pdsaLocationEntries->GetItemCount() <= (UINT)g_MaxIcons)
        {
            TCHAR szPath[MAX_PATH];
            hr = GetIconCachePath(szPath);
            if (SUCCEEDED(hr))
            {
                IStream *pstm;
                hr = SHCreateStreamOnFileEx(szPath, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, FILE_ATTRIBUTE_HIDDEN, TRUE, NULL, &pstm);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER size;
                    size.LowPart = _GetIconCacheSize();
                    size.HighPart = 0;
                    // Set the right size initially so that the file system gives us contigous space on the disk
                    // This avoid fragmentation and improves our startup time.
                    hr = pstm->SetSize(size);
                    if (SUCCEEDED(hr))
                    {
                        ENTERCRITICAL;

                        IC_HEAD ich = {0};
                        // ich.cbSize, don't set this until we re-write the header
                        ich.dwMagic    = ICONCACHE_MAGIC;
                        ich.dwVersion  = ICONCACHE_VERSION;
                        ich.dwNumIcons = GetSystemMetrics(SM_CLEANBOOT) ? 0 : g_pdsaLocationEntries->GetItemCount();
                        ich.dwColorRes = GetCurColorRes();
                        ich.dwFlags    = g_ccIcon;
                        ich.dwBuild    = GetBuildNumber();
                        ich.dwTimeSave  = GetIconTime();
                        ich.dwTimeFlush = g_dwIconTimeFlush;
                        ich.dwFreeImageCount = g_dwFreeImageCount;
                        ich.dwFreeEntryCount = g_dwFreeEntryCount;
                        ich.cImageLists = ARRAYSIZE(g_rgshil);

                        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
                        {
                            ImageList_GetIconSize(g_rgshil[i].himl, (int*)&ich.rgsize[i].cx, (int*)&ich.rgsize[i].cy);
                        }

                        hr = IStream_Write(pstm, &ich, sizeof(ich));
                        if (SUCCEEDED(hr))
                        {
                            // write out entries (assumes all entries are contigious in memory)
                            hr = _IconCacheWriteLocations(pstm, *g_pdsaLocationEntries, ich.dwNumIcons);
                            // write out the path names
                            for (i = 0; SUCCEEDED(hr) && (i < (int)ich.dwNumIcons); i++)
                            {
                                TCHAR ach[MAX_PATH];
                                LOCATION_ENTRY *p = g_pdsaLocationEntries->GetItemPtr(i);

                                if (p->szName)
                                    GetHashItemName(NULL, p->szName, ach, ARRAYSIZE(ach));
                                else
                                    ach[0] = 0;

                                hr = Stream_WriteString(pstm, ach, TRUE);
                            }

                            // write out the imagelist of the icons
                            for (i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(g_rgshil)); i++)
                            {
                                hr = ImageList_Write(g_rgshil[i].himl, pstm) ? S_OK : E_FAIL;
                            }


                            if (SUCCEEDED(hr))
                            {
                                hr = pstm->Commit(0);
                                if (SUCCEEDED(hr))
                                {
                                    // This is where the file pointer is at the end of the file.
                                    ULARGE_INTEGER liSize;
                                    if (SUCCEEDED(pstm->Seek(g_li0, STREAM_SEEK_CUR, &liSize)))
                                    {
                                        // Trim the file size now. Ignore the return code 
                                        pstm->SetSize(liSize);
                                    }

                                    hr = pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        ich.cbSize = sizeof(ich);   // not valid until this is set
                                        hr = IStream_Write(pstm, &ich, sizeof(ich));
                                        if (SUCCEEDED(hr))
                                        {
                                            g_fDirtyIcons = FALSE;  // reset dirty state
                                        }
                                    }
                                }
                            }
                        }
                        pstm->Release();

                        LEAVECRITICAL;
                    }
                }
            }
            if (FAILED(hr))
                DeleteFile(szPath); // saving failed, cleanup
        }
    }

    return SUCCEEDED(hr);
}

#ifdef _WIN64

//
//  ps        - stream from which to load
//  hda       - DSA of LOCATION_ENTRY structures
//  cle       - count of LOCATION_ENTRY32's to read
//
//  The structures are stored as LOCATION_ENTRY32 on disk.
//

HRESULT _IconCacheReadLocations(IStream *pstm, HDSA hdsa, int cle)
{
    HRESULT hr = E_OUTOFMEMORY;

    // read into a scratch buffer, then convert
    // LOCATION_ENTRY32 into LOCATION_ENTRY.

    LOCATION_ENTRY32 *rgle32 = (LOCATION_ENTRY32*)LocalAlloc(LPTR, cle * sizeof(LOCATION_ENTRY32));
    if (rgle32)
    {
        hr = IStream_Read(pstm, rgle32, cle * sizeof(LOCATION_ENTRY32));
        if (SUCCEEDED(hr))
        {
            LOCATION_ENTRY *rgle = (LOCATION_ENTRY*)DSA_GetItemPtr(hdsa, 0);
            for (int i = 0; i < cle; i++)
            {
                rgle[i].iIconIndex = rgle32[i].iIconIndex;
                rgle[i].uFlags     = rgle32[i].uFlags;
                rgle[i].iILIndex   = rgle32[i].iILIndex;
                rgle[i].Access     = rgle32[i].Access;
            }
        }
        LocalFree(rgle32);
    }
    return hr;
}

#else

__inline HRESULT _IconCacheReadLocations(IStream *pstm, HDSA hdsa, int cle)
{
    // LOCATION_ENTRY and LOCATION_ENTRY32 are the same, so we can
    // read straight into the DSA data block
    COMPILETIME_ASSERT(sizeof(LOCATION_ENTRY) == sizeof(LOCATION_ENTRY32));
    return IStream_Read(pstm, DSA_GetItemPtr(hdsa, 0), cle * sizeof(LOCATION_ENTRY));
}
#endif

void _InitIconOverlayIndices(void)
{
    IShellIconOverlayManager *psiom;

    if (SUCCEEDED(GetIconOverlayManager(&psiom)))
    {
        psiom->RefreshOverlayImages(SIOM_OVERLAYINDEX | SIOM_ICONINDEX);
        psiom->Release();
    }
}

BOOL _IconIndexInOverlayManager(int iILIndex)
{
    BOOL fInOverlayManager = FALSE;

    ENTERCRITICAL;

    IShellIconOverlayManager *psiom;

    if (SUCCEEDED(GetIconOverlayManager(&psiom)))
    {
        int iOverlayIndex;

        if (SUCCEEDED(psiom->OverlayIndexFromImageIndex(iILIndex, &iOverlayIndex, FALSE)))
        {
            fInOverlayManager = TRUE;
        }
        psiom->Release();
    }

    LEAVECRITICAL;

    return fInOverlayManager;
}

BOOL _ReadImageLists(IStream *pstrm, HIMAGELIST rghiml[SHIL_COUNT], SIZE rgsize[SHIL_COUNT])
{
    BOOL fSuccess = TRUE;
    for (int i = 0; fSuccess && i < ARRAYSIZE(g_rgshil); i++)
    {
        rghiml[i] = ImageList_Read(pstrm);
        if (rghiml[i])
        {
            // If we read the list from disk and it does not contain the
            // parallel mirrored list while we are on a mirrored system,
            // let's not use the cache in this case
            // Example of this is ARA/HEB MUI on US W2k

            if (IS_BIDI_LOCALIZED_SYSTEM() && !(ImageList_GetFlags(rghiml[i]) & ILC_MIRROR))
            {
                fSuccess = FALSE;
            }
            else
            {
                int cx, cy;
                ImageList_GetIconSize(rghiml[i], &cx, &cy);
                if (cx != rgsize[i].cx || cy != rgsize[i].cy)
                {
                    fSuccess = FALSE;
                }
            }
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if (fSuccess == FALSE)
    {
        // free any imagelists we allocated
        for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            if (rghiml[i])
            {
                ImageList_Destroy(rghiml[i]);
                rghiml[i] = NULL;
            }
        }
    }

    return fSuccess;
}

// psz and cch passed in for efficiency (avoid using another MAX_PATH stack buffer)
BOOL _ReadLocationEntries(const IC_HEAD *pich, IStream *pstrm, CDSA<LOCATION_ENTRY> *pdsaTemp, LPTSTR psz, int cch)
{
    LOCATION_ENTRY dummy;

    // grow the array out so we can read data into it
    if (pdsaTemp->SetItem(pich->dwNumIcons - 1, &dummy))
    {
        ASSERT(pdsaTemp->GetItemCount() == (int)pich->dwNumIcons);
        if (SUCCEEDED(_IconCacheReadLocations(pstrm, *pdsaTemp, pich->dwNumIcons)))
        {
            // read the paths, patching up the table with the hashitem info
            for (int i = 0; i < (int)pich->dwNumIcons; i++)
            {
                LOCATION_ENTRY *pLocation = pdsaTemp->GetItemPtr(i);

                if (SUCCEEDED(Stream_ReadString(pstrm, psz, cch, TRUE)) && *psz)
                    pLocation->szName = AddHashItem(NULL, psz);
                else
                    pLocation->szName = 0;
            }
            
            // restore the image lists
            return TRUE;
        }
    }
    return FALSE;
}

BOOL _ValidateIconCacheHeader(const IC_HEAD *pich, SIZE rgsize[SHIL_COUNT], UINT flags)
{
    if (pich->cbSize      == sizeof(*pich) &&
        pich->dwVersion   == ICONCACHE_VERSION &&
        pich->dwMagic     == ICONCACHE_MAGIC &&
        pich->dwBuild     == GetBuildNumber() &&
        pich->dwFlags     == (DWORD)flags &&
        pich->cImageLists == ARRAYSIZE(g_rgshil) &&
        (0 == memcmp(pich->rgsize, rgsize, sizeof(pich->rgsize))))
    {
        UINT cres = GetCurColorRes();

        // dont load a mono image list on a color device, and
        // dont load a color image list on a mono device, get it?
        if (pich->dwColorRes == 1 && cres != 1 ||
            pich->dwColorRes != 1 && cres == 1)
        {
            return FALSE;
        }
        else if (pich->dwNumIcons > (UINT)g_MaxIcons)
        {
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

void _SetNewGlobals(const IC_HEAD *pich, CDSA<LOCATION_ENTRY> *pdsaTemp, HIMAGELIST rghiml[SHIL_COUNT])
{
    ASSERTCRITICAL;

    if (g_pdsaLocationEntries)
    {
        g_pdsaLocationEntries->Destroy();
        delete g_pdsaLocationEntries;
    }
    g_pdsaLocationEntries = pdsaTemp;

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl)
            ImageList_Destroy(g_rgshil[i].himl);
        g_rgshil[i].himl = rghiml[i];
    }

    //
    // we want GetIconTime() to pick up
    // where it left off when we saved.
    //
    g_dwIconTimeBase   = 0;     // GetIconTime() uses g_dwIconTimeBase
    g_dwIconTimeBase   = pich->dwTimeSave - GetIconTime();
    g_dwIconTimeFlush  = pich->dwTimeFlush;
    g_dwFreeImageCount = pich->dwFreeImageCount;
    g_dwFreeEntryCount = pich->dwFreeEntryCount;
    g_fDirtyIcons   = FALSE;
}

//
//  get the icon cache back from disk, it must be the requested size and
//  bitdepth or we will not use it.
//
STDAPI_(BOOL) IconCacheRestore(SIZE rgsize[SHIL_COUNT], UINT flags)
{
    ASSERTCRITICAL;

    BOOL fSuccess = FALSE;

    if (!GetSystemMetrics(SM_CLEANBOOT))
    {
        TCHAR szPath[MAX_PATH];

        IStream *pstm;
        if (SUCCEEDED(GetIconCachePath(szPath)) &&
            SUCCEEDED(SHCreateStreamOnFile(szPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm)))
        {
            IC_HEAD ich;
            if (SUCCEEDED(IStream_Read(pstm, &ich, sizeof(ich))) &&
                _ValidateIconCacheHeader(&ich, rgsize, flags))
            {
                CDSA<LOCATION_ENTRY> *pdsaTemp = CDSA_Create<LOCATION_ENTRY>(8);

                // load the icon table
                if (pdsaTemp)
                {
                    HIMAGELIST rghiml[ARRAYSIZE(g_rgshil)] = {0};

                    fSuccess = _ReadLocationEntries(&ich, pstm, pdsaTemp, szPath, ARRAYSIZE(szPath)) &&
                               _ReadImageLists(pstm, rghiml, rgsize);

                    if (fSuccess)
                    {
                        // Make it so, number one.
                        _SetNewGlobals(&ich, pdsaTemp, rghiml);
                        _InitIconOverlayIndices();
                    }
                    else
                    {
                        // failure, clean up
                        pdsaTemp->Destroy();
                        delete pdsaTemp;
                    }
                }
            }
            pstm->Release();
        }
    }

    return fSuccess;
}


//------------------ file class table ------------------------

HHASHTABLE g_hhtClass = NULL;

BOOL InitFileClassTable(void)
{
    ASSERTCRITICAL;

    if (!g_hhtClass)
    {
        if (!g_hhtClass)
            g_hhtClass = CreateHashItemTable(0, sizeof(FILECLASSENTRY));
    }

    return BOOLIFY(g_hhtClass);
}
        
    
void FlushFileClass(void)
{
    ENTERCRITICAL;

#ifdef DEBUG
    if (g_hhtClass != NULL) 
    {
        DebugMsg(DM_TRACE, TEXT("Flushing file class table"));
        TIMEOUT(LookupFileClass);
        TIMEOUT(AddFileClass);
        TIMEOUT(LookupFileClassName);
        TIMEOUT(AddFileClassName);
        TIMEOUT(LookupFileSCIDs);
        TIMEOUT(AddFileSCIDs);
        TIMEOUT(LookupIcon);
        TIMEOUT(AddIcon);
        TIMEOUT(RemoveIcon);

        TIMEIN(LookupFileClass);
        TIMEIN(AddFileClass);
        TIMEIN(LookupFileClassName);
        TIMEIN(AddFileClassName);
        TIMEIN(LookupFileSCIDs);
        TIMEIN(AddFileSCIDs);
        TIMEIN(LookupIcon);
        TIMEIN(AddIcon);
        TIMEIN(RemoveIcon);

        DumpHashItemTable(g_hhtClass);
    }
#endif
    if (g_hhtClass != NULL)
    {
        DestroyHashItemTable(g_hhtClass);
        g_hhtClass = NULL;
    }

    TraceMsg(TF_IMAGE, "Flushed class maps");

    LEAVECRITICAL;
}


DWORD LookupFileClass(LPCTSTR pszClass)
{
    DWORD dw = 0;

    ENTERCRITICAL;
    TIMESTART(LookupFileClass);
    
    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))   
        dw = ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->dwFlags;

    TIMESTOP(LookupFileClass);
    LEAVECRITICAL;

    return dw;
}

void AddFileClass(LPCTSTR pszClass, DWORD dw)
{
    ENTERCRITICAL;
    TIMESTART(AddFileClass);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->dwFlags = dw;

    TraceMsg(TF_IMAGE, "Mapped %s to image %d", pszClass, (dw & SHCF_ICON_INDEX));

    TIMESTOP(AddFileClass);
    LEAVECRITICAL;
    return;
}

//======================================================================

typedef struct _IconIndexCountParam
{
    int       iILIndex; // hash item data
    int       cItems;   // number of hash items found
} ICONINDEXCOUNTPARAM;

//======================================================================

void _IconIndexInFileClassTableCallback(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR dwParam)
{
    ICONINDEXCOUNTPARAM *lpParam = (ICONINDEXCOUNTPARAM *)dwParam;

    FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(hht, sz);

    if (pfce && (pfce->dwFlags & SHCF_ICON_INDEX) == lpParam->iILIndex)
    {
        lpParam->cItems++;
    }
} 

//======================================================================

BOOL IconIndexInFileClassTable(int iILIndex)
{
    ICONINDEXCOUNTPARAM param;

    param.iILIndex = iILIndex;
    param.cItems = 0;

    ENTERCRITICAL;

    if (g_hhtClass)
    {
        EnumHashItems(g_hhtClass, _IconIndexInFileClassTableCallback, (DWORD_PTR)&param);
    }

    LEAVECRITICAL;

    return param.cItems;
}

LPCTSTR LookupFileClassName(LPCTSTR pszClass)
{
    LPCTSTR pszClassName = NULL;

    ASSERTCRITICAL
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        pszClassName = pfce->pszClassName;
    }
    TIMESTOP(LookupFileClassName);

    return pszClassName;
}

// If the return value is greater than zero,
// it is up to the caller to free the array that is passed out.
// If the return value is zero, the value of papProps is undefined.
UINT LookupFileSCIDs(LPCTSTR pszClass, SHCOLUMNID *pascidOut[])
{
    SHCOLUMNID *ascid = NULL;
    UINT cCount = 0;

    ASSERTCRITICAL
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        cCount = pfce->cSCID;
        if (cCount > 0)
        {
            // Make a local copy of the scid array
            ascid = (SHCOLUMNID*)LocalAlloc(LMEM_FIXED, sizeof(SHCOLUMNID) * cCount);
            if (ascid)
                CopyMemory(ascid, pfce->ascid, sizeof(SHCOLUMNID) * cCount);
            else
                cCount = 0;
        }
    }
    TIMESTOP(LookupFileClassName);

    *pascidOut = ascid;
    return cCount;

}

LPCTSTR AddFileClassName(LPCTSTR pszClass, LPCTSTR pszClassName)
{
    ASSERTCRITICAL
    TIMESTART(AddFileClassName);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        pszClassName = AddHashItem(g_hhtClass, pszClassName);
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->pszClassName = pszClassName;
    }

    TIMESTOP(AddFileClassName);
    return pszClassName;
}

// The array of SHCOLUMNIDs passed in is copied
void AddFileSCIDs(LPCTSTR pszClass, SHCOLUMNID ascidIn[], UINT cSCID)
{
    ASSERTCRITICAL
    TIMESTART(AddFileSCIDs);

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        // Make a copy of the array.
        SHCOLUMNID *ascid = (SHCOLUMNID*)LocalAlloc(LMEM_FIXED, sizeof(SHCOLUMNID) * cSCID);

        if (ascid)
        {
            FILECLASSENTRY *pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
            // Free any previous scid array first
            if (pfce->ascid)
                LocalFree(pfce->ascid);
            // Note, we never free the last scid array -- freed on process exit.

            pfce->ascid = ascid;
            CopyMemory(ascid, ascidIn, cSCID * sizeof(SHCOLUMNID));
            pfce->cSCID = cSCID;
        }
    }

    TIMESTOP(AddFileSCIDs);
}

PERCEIVED LookupFilePerceivedType(LPCTSTR pszClass)
{
    PERCEIVED gen = GEN_UNKNOWN;
    

    ENTERCRITICAL;
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        gen = pfce->gen;
    }
    TIMESTOP(LookupFileClassName);
    LEAVECRITICAL;
    return gen;
}

void AddFilePerceivedType(LPCTSTR pszClass, PERCEIVED gen)
{
    ENTERCRITICAL;
    TIMESTART(AddFileClassName);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->gen = gen;
    }

    TIMESTOP(AddFileClassName);
    LEAVECRITICAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filtgrep.cpp ===
//  10/12/99    scotthan    created

#include "shellprv.h"
#include "filtgrep.h"
#include <ntquery.h>
#include <filterr.h>


class CGrepTokens // maintains an index of unicode and ansi grep tokens.
{
public:
    STDMETHODIMP            Initialize(UINT nCodepage, LPCWSTR pwszMatch, LPCWSTR pwszExclude, BOOL bCaseSensitive);
    STDMETHODIMP_(void)     Reset();
    STDMETHODIMP_(BOOL)     GrepW(LPCWSTR pwszText);
    STDMETHODIMP_(BOOL)     GrepA(LPCSTR pwszText);
    
    STDMETHODIMP GetCodePage(UINT* pnCodepage) const;
    STDMETHODIMP GetMatchTokens(OUT LPWSTR pszTokens, UINT cchTokens) const;
    STDMETHODIMP GetExcludeTokens(OUT LPWSTR pszTokens, UINT cchTokens) const;

private:
    UINT    _nCodepage;
    LPWSTR  _pszMatchW, _pszExcludeW;   // raw strings, unicode
    LPSTR   _pszMatchA, _pszExcludeA;   // raw strings, ansi

    LPCWSTR *_rgpszMatchW, *_rgpszExcludeW; // token index, unicode
    LPCSTR  *_rgpszMatchA, *_rgpszExcludeA; // token index, ansi

    LONG    _cMatch, _cExclude; // token counts
    
    LPWSTR  (__stdcall * _pfnStrStrW)(LPCWSTR, LPCWSTR);
    LPSTR   (__stdcall * _pfnStrStrA)(LPCSTR, LPCSTR);

public:
    //  Ctor, Dtor
    CGrepTokens()
        :   _nCodepage(0), _cMatch(0), _cExclude(0), _pfnStrStrW(StrStrIW), _pfnStrStrA(StrStrIA),
            _pszMatchW(NULL), _pszExcludeW(NULL), _rgpszMatchW(NULL), _rgpszExcludeW(NULL),
            _pszMatchA(NULL), _pszExcludeA(NULL), _rgpszMatchA(NULL), _rgpszExcludeA(NULL) {}
    ~CGrepTokens()    { Reset(); }

};


class CGrepBuffer // auxilliary class: per-thread grep buffer
{
public:
    CGrepBuffer(ULONG dwThreadID)  :  _dwThreadID(dwThreadID), _pszBuf(NULL), _cchBuf(0) {}
    virtual ~CGrepBuffer()  {delete [] _pszBuf;}
    
    STDMETHODIMP          Alloc(ULONG cch);
    STDMETHODIMP_(BOOL)   IsThread(ULONG dwThread) const {return dwThread == _dwThreadID;}
    STDMETHODIMP_(LPWSTR) Buffer()  { return _pszBuf; }

    #define DEFAULT_GREPBUFFERSIZE  0x00FF  // +1 = 1 page.

private:
    LPWSTR _pszBuf;
    ULONG  _cchBuf;
    ULONG  _dwThreadID;
};


//  Makes a heap copy of a widechar string
LPWSTR _AllocAndCopyString(LPCWSTR pszSrc, UINT cch = -1)
{
    if (pszSrc)
    {
        if ((int)cch < 0) // must cast to "int" since cch is a UINT
            cch = lstrlenW(pszSrc);
        LPWSTR pszRet = new WCHAR[cch + 1];
        if (pszRet)
        {
            CopyMemory(pszRet, pszSrc, sizeof(*pszSrc) * cch);
            pszRet[cch] = 0;
            return pszRet;
        }
    }
    return NULL;
}


//  Makes an ansi copy of a widechar string
LPSTR _AllocAndCopyAnsiString(UINT nCodepage, LPCWSTR pszSrc, UINT cch = -1)
{
    if (pszSrc)
    {
        if ((int)cch < 0) // must cast to "int" since cch is a UINT
            cch = lstrlenW(pszSrc);
        int cchBuf = WideCharToMultiByte(nCodepage, 0, pszSrc, cch, NULL, 0, NULL, NULL);
        LPSTR pszRet = new CHAR[cchBuf+1];
        if (pszRet)
        {
            int cchRet = WideCharToMultiByte(nCodepage, 0, pszSrc, cch, pszRet, cchBuf, NULL, NULL);
            pszRet[cchRet] = 0;
            return pszRet;
        }
    }
    return NULL;
}


//  CGrepBuffer impl



STDMETHODIMP CGrepBuffer::Alloc(ULONG cch)
{
    LPWSTR pszBuf = NULL;
    if (cch)
    {
        if (_pszBuf && _cchBuf >= cch)
            return S_OK;

        pszBuf = new WCHAR[cch+1];
        if (NULL == pszBuf)
            return E_OUTOFMEMORY;

        *pszBuf = 0;
    }

    delete [] _pszBuf;
    _pszBuf = pszBuf;
    _cchBuf = cch;
    
    return _pszBuf != NULL ? S_OK : S_FALSE ;
}


//  CGrepTokens impl



//  Counts the number of characters in a string containing NULL-delimited tokens ("foo\0bloke\0TheEnd\0\0")
LONG _GetTokenListLength(LPCWSTR pszList, LONG* pcTokens = NULL)
{
    LONG cchRet = 0;
    if (pcTokens) *pcTokens = 0;

    if (pszList && *pszList)
    {
        LPCWSTR pszToken, pszPrev; 
        int     i = 0;
        
        for (pszToken = pszPrev = pszList;
             pszToken && *pszToken;)
        {
            if (pcTokens) 
                (*pcTokens)++;
            
            pszToken += lstrlenW(pszToken) + 1, 
            cchRet += (DWORD)(pszToken - pszPrev) ;
            pszPrev = pszToken;
        }
    }
        
    return cchRet;
}



//  wide version: Counts and/or indexes NULL-delimited string tokens ("foo\0bloke\0TheEnd\0\0")
LONG _IndexTokensW(LPCWSTR pszList, LPCWSTR* prgszTokens = NULL)
{
    LONG cRet = 0;
    if (pszList && *pszList)
    {
        LPCWSTR psz = pszList;
        int i = 0;
        for (; psz && *psz; psz += (lstrlenW(psz) + 1), i++)
        {
            if (prgszTokens)
                prgszTokens[i] = psz;
            cRet++;
        }
    }
    return cRet;
}


//  ansi version: Counts and/or indexes NULL-delimited string tokens ("foo\0bloke\0TheEnd\0\0")
LONG _IndexTokensA(LPCSTR pszList, LPCSTR* prgszTokens = NULL)
{
    LONG cRet = 0;
    if (pszList && *pszList)
    {
        LPCSTR psz = pszList;
        int i = 0;
        for (; psz && *psz; psz += (lstrlenA(psz) + 1), i++)
        {
            if (prgszTokens)
                prgszTokens[i] = psz;
            cRet++;
        }
    }
    return cRet;
}


//  wide version: Allocates a string token index and indexes a string of NULL-delimited tokens.
STDMETHODIMP _AllocAndIndexTokensW(LONG cTokens, LPCWSTR pszList, LPCWSTR** pprgszTokens)
{
    if (cTokens)
    {
        if (NULL == (*pprgszTokens = new LPCWSTR[cTokens]))
            return E_OUTOFMEMORY;
    
        if (cTokens != _IndexTokensW(pszList, *pprgszTokens))
        {
            delete [] (*pprgszTokens);
            *pprgszTokens = NULL;
            return E_FAIL;
        }
    }
    return S_OK;
}


//  ansi version: Allocates a string token index and indexes a string of NULL-delimited tokens.
STDMETHODIMP _AllocAndIndexTokensA(LONG cTokens, LPCSTR pszList, LPCSTR** pprgszTokens)
{
    if (cTokens)
    {
        if (NULL == (*pprgszTokens = new LPCSTR[cTokens]))
            return E_OUTOFMEMORY;
    
        if (cTokens != _IndexTokensA(pszList, *pprgszTokens))
        {
            delete [] (*pprgszTokens);
            *pprgszTokens = NULL;
            return E_FAIL;
        }
    }
    return S_OK;
}


//  Frees unicode and ansi token lists and corresponding indices.
void _FreeUniAnsiTokenList(
    OUT LPWSTR*   ppszListW,
    OUT LPSTR*    ppszListA,
    OUT LPCWSTR** pprgTokensW,
    OUT LPCSTR**  pprgTokensA)
{
    delete [] *ppszListW;   *ppszListW = NULL;
    delete [] *ppszListA;   *ppszListA = NULL;
    delete [] *pprgTokensW; *pprgTokensW = NULL;
    delete [] *pprgTokensA; *pprgTokensA = NULL;
}


//  Allocates unicode and ansi token lists and corresponding indices.
STDMETHODIMP _AllocUniAnsiTokenList(
    UINT          nCodepage,
    LPCWSTR       pszList, 
    OUT LPWSTR*   ppszListW,
    OUT LPSTR*    ppszListA,
    OUT LONG*     pcTokens,
    OUT LPCWSTR** pprgTokensW,
    OUT LPCSTR**  pprgTokensA)
{
    HRESULT hr = S_FALSE;
    LONG cTokens = 0;
    UINT cch = _GetTokenListLength(pszList, &cTokens);

    *ppszListW   = NULL;
    *ppszListA   = NULL;
    *pprgTokensW = NULL;
    *pprgTokensA = NULL;
    *pcTokens    = 0;

    if (cTokens)
    {
        hr = E_OUTOFMEMORY;
        
        if (NULL == (*ppszListW = _AllocAndCopyString(pszList, cch)))
            goto failure_exit;

        if (NULL == (*ppszListA = _AllocAndCopyAnsiString(nCodepage, pszList, cch)))
            goto failure_exit;

        if (FAILED((hr = _AllocAndIndexTokensW(cTokens, *ppszListW, pprgTokensW))))
            goto failure_exit;

        if (FAILED((hr = _AllocAndIndexTokensA(cTokens, *ppszListA, pprgTokensA))))
            goto failure_exit;

        *pcTokens = cTokens;
        hr = S_OK;
    }
    return hr;

failure_exit:
    _FreeUniAnsiTokenList(ppszListW, ppszListA, pprgTokensW, pprgTokensA);
    return hr;
}


STDMETHODIMP CGrepTokens::Initialize(UINT nCodepage, LPCWSTR pszMatch, LPCWSTR pszExclude, BOOL bCaseSensitive)
{
    HRESULT hr = E_INVALIDARG;
    Reset();

    BOOL bMatchString   = (pszMatch && *pszMatch);
    BOOL bExcludeString = (pszExclude && *pszExclude);

    if (!(bMatchString || bExcludeString))
        return E_INVALIDARG;

    _nCodepage = nCodepage;

    if (bCaseSensitive)
    {
        _pfnStrStrW = StrStrW;
        _pfnStrStrA = StrStrA;
    }
    else
    {
        _pfnStrStrW = StrStrIW;
        _pfnStrStrA = StrStrIA;
    }

    if (bMatchString)
    {
        if (FAILED((hr = _AllocUniAnsiTokenList(nCodepage, pszMatch,
            &_pszMatchW, &_pszMatchA, &_cMatch, &_rgpszMatchW, &_rgpszMatchA))))
        {
            return hr;
        }
    }
    
    if (bExcludeString)
    {
        if (FAILED((hr = _AllocUniAnsiTokenList(nCodepage, pszExclude,
            &_pszExcludeW, &_pszExcludeA, &_cExclude, &_rgpszExcludeW, &_rgpszExcludeA))))
        {
            return hr;
        }
    }

    return hr;
}

STDMETHODIMP CGrepTokens::GetCodePage(UINT* pnCodepage) const
{
    HRESULT hr = _nCodepage ? S_OK : S_FALSE;
    if (pnCodepage)
        *pnCodepage = _nCodepage;
    return hr;
}

// S_OK we have some match tokens, S_FALSE otherwise

STDMETHODIMP CGrepTokens::GetMatchTokens(OUT LPWSTR pszMatch, UINT cchMatch) const
{
    HRESULT hr = (_pszMatchW && *_pszMatchW) ? S_OK : S_FALSE;
    if (pszMatch)
        lstrcpynW(pszMatch, _pszMatchW ? _pszMatchW : L"", cchMatch);
    return hr;
}

// S_OK we have some exclude tokens, S_FALSE otherwise

STDMETHODIMP CGrepTokens::GetExcludeTokens(OUT LPWSTR pszExclude, UINT cchExclude) const
{
    HRESULT hr = (_pszExcludeW && *_pszExcludeW) ? S_OK : S_FALSE;
    if (pszExclude)
        lstrcpynW(pszExclude, _pszExcludeW ? _pszExcludeW : L"", cchExclude);
    return hr;
}

void CGrepTokens::Reset()
{
    _FreeUniAnsiTokenList(&_pszMatchW, &_pszMatchA, &_rgpszMatchW, &_rgpszMatchA);
    _FreeUniAnsiTokenList(&_pszExcludeW, &_pszExcludeA, &_rgpszExcludeW, &_rgpszExcludeA);
    _cMatch = _cExclude = 0;
    _nCodepage = 0;
}


STDMETHODIMP_(BOOL) CGrepTokens::GrepW(LPCWSTR pszText)
{
    BOOL bMatch = FALSE;
    if (pszText)
    {
        BOOL bExclude = FALSE;
     
        for (int i = 0; i < _cMatch; i++)
        {
            if (_pfnStrStrW(pszText, _rgpszMatchW[i]))
            {
                bMatch = TRUE;
                break;
            }
        }

        for (i = 0; i < _cExclude; i++)
        {
            if (_pfnStrStrW(pszText, _rgpszExcludeW[i]))
            {
                bExclude = TRUE;
                break;
            }
        }
    
        if (_cMatch && _cExclude)
            return bMatch || !_cExclude;
        if (_cExclude)
            return !bExclude;
    }
    return bMatch;
}

STDMETHODIMP_(BOOL) CGrepTokens::GrepA(LPCSTR pszText)
{
    BOOL bMatch = FALSE;
    if (pszText)
    {
        BOOL bExclude = FALSE;
        for (int i = 0; i < _cMatch; i++)
        {
            if (_pfnStrStrA(pszText, _rgpszMatchA[i]))
            {
                bMatch = TRUE;
                break;
            }
        }

        for (i = 0; i < _cExclude; i++)
        {
            if (_pfnStrStrA(pszText, _rgpszExcludeA[i]))
            {
                bExclude = TRUE;
                break;
            }
        }
    
        if (_cMatch && _cExclude)
            return bMatch || !_cExclude;
        if (_cExclude)
            return !bExclude;
    }
    return bMatch;
}

inline STDMETHODIMP_(BOOL) _IsEqualAttribute(const FULLPROPSPEC& fps, REFFMTID fmtid, PROPID propid)
{
    return IsEqualGUID(fmtid, fps.guidPropSet) && 
                        PRSPEC_PROPID == fps.psProperty.ulKind &&
                        propid == fps.psProperty.propid;
}


STDMETHODIMP_(BOOL) _PropVariantGrep(PROPVARIANT* pvar, CGrepTokens* pTokens)
{
    BOOL bRet = FALSE;

    switch(pvar->vt)
    {
    case VT_LPWSTR:
        bRet = pTokens->GrepW(pvar->pwszVal);
        break;

    case VT_BSTR:
        bRet = pTokens->GrepW(pvar->bstrVal);
        break;

    case VT_LPSTR:
        bRet = pTokens->GrepA(pvar->pszVal);
        break;

    case VT_VECTOR|VT_LPWSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->calpwstr.cElems; i++)
                bRet = pTokens->GrepW(pvar->calpwstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_BSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->cabstr.cElems; i++)
                bRet = pTokens->GrepW(pvar->cabstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_LPSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->calpstr.cElems; i++)
                bRet = pTokens->GrepA(pvar->calpstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_VARIANT:
        {
            for (UINT i = 0; !bRet && i < pvar->capropvar.cElems; i++)
                bRet = _PropVariantGrep(pvar->capropvar.pElems + i, pTokens);
            break;
        }

    case VT_BSTR|VT_ARRAY:
        {
            //  Only grep 1-dimensional arrays.
            UINT cDims = SafeArrayGetDim(pvar->parray);
            if (cDims == 1)
            {
                LONG lBound, uBound;
                if (SUCCEEDED(SafeArrayGetLBound(pvar->parray, 1, &lBound)) &&
                    SUCCEEDED(SafeArrayGetUBound(pvar->parray, 1, &uBound)) && 
                    uBound > lBound)
                {
                    BSTR *rgpbstr;
                    if (SUCCEEDED(SafeArrayAccessData(pvar->parray, (void **)&rgpbstr)))
                    {
                        for (int i = 0; !bRet && i <= (uBound - lBound); i++)
                        {
                            bRet = pTokens->GrepW(rgpbstr[i]);
                        }
                        SafeArrayUnaccessData(pvar->parray);
                    }
                }
            }
            else if (cDims > 1)
            {
                ASSERT(FALSE);    // we didn't expect > 1 dimension on bstr arrays!
            }
            break;
        }
    }
    return bRet;
}

//  Retrieves grep restriction settings 
STDMETHODIMP_(BOOL) _FetchRestrictionSettings(LPCWSTR pwszVal, LPWSTR* ppwszSettings, BOOL bRefresh)
{
    ASSERT(ppwszSettings);
    
    if (bRefresh)
    {
        delete [] *ppwszSettings;
        *ppwszSettings = NULL;
    }

    if (NULL == *ppwszSettings)
    {
        HKEY hkeyPolicy = NULL;
        if (RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Search\\ExcludedFileTypes", 0, 
                           KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
        {
            DWORD dwType, cbData = 0;
            if (RegQueryValueExW(hkeyPolicy, pwszVal, NULL, &dwType, NULL, &cbData) == ERROR_SUCCESS && 
                REG_MULTI_SZ == dwType)
            {
                if ((*ppwszSettings = new WCHAR[(cbData/sizeof(WCHAR))+ 1]) != NULL)
                {
                    if (RegQueryValueExW(hkeyPolicy, pwszVal, NULL,
                                         &dwType, (LPBYTE)*ppwszSettings, &cbData) != ERROR_SUCCESS)
                    {
                        *ppwszSettings = 0;
                    }
                }
            }
            RegCloseKey(hkeyPolicy);
        }

        if (NULL == *ppwszSettings) // we found no restriction key or value.
        {
            if ((*ppwszSettings = new WCHAR[1]))
                **ppwszSettings = 0;
        }
    }
    return *ppwszSettings != NULL;
}


//  Scans restriction entries for a match against the specified filename extension
STDMETHODIMP_(BOOL) _ScanRestrictionSettings(LPCWSTR pwszSettings, LPCWSTR pwszExt)
{
    ASSERT(pwszSettings);
    ASSERT(pwszExt);

    for (LPCWSTR psz = pwszSettings; *psz; psz += (lstrlenW(psz) + 1))
    {
        if (0 == StrCmpIW(psz, pwszExt))
            return TRUE;
    }
    return FALSE;
}

CFilterGrep::CFilterGrep() 
    :   _hdpaGrepBuffers(NULL),
        _pTokens(NULL),
        _dwFlags(0),
        _pwszContentRestricted(NULL),
        _pwszPropertiesRestricted(NULL)
{ 
    InitializeCriticalSection(&_critsec);
}

CFilterGrep::~CFilterGrep()  
{ 
    _ClearGrepBuffers();
    delete [] _pwszContentRestricted;
    delete [] _pwszPropertiesRestricted;
    delete _pTokens;
    DeleteCriticalSection(&_critsec);
}


STDMETHODIMP CFilterGrep::Initialize(UINT nCodepage, LPCWSTR pszMatch, LPCWSTR pszExclude, DWORD dwFlags)
{
    Reset();
    
    if ((0 == (dwFlags & (FGIF_BLANKETGREP|FGIF_GREPFILENAME))) ||
        !((pszMatch && *pszMatch) || (pszExclude && *pszExclude)))
        return E_INVALIDARG;

    if (!(_pTokens || (_pTokens = new CGrepTokens) != NULL))
        return E_OUTOFMEMORY;

    _dwFlags = dwFlags;

    return _pTokens->Initialize(nCodepage, pszMatch, pszExclude, BOOLIFY(dwFlags & FGIF_CASESENSITIVE));
}


STDMETHODIMP CFilterGrep::Reset()
{
    if (_pTokens)
        _pTokens->Reset();
    _dwFlags = 0;
    return S_OK;
}

// converts non critical errors into S_FALSE, other return as FAILED(hr)
HRESULT _MapFilterCriticalError(HRESULT hr)
{
    switch (hr)
    {
    case FILTER_E_END_OF_CHUNKS:
    case FILTER_E_NO_MORE_TEXT:
    case FILTER_E_NO_MORE_VALUES:
    case FILTER_W_MONIKER_CLIPPED:
    case FILTER_E_NO_TEXT:
    case FILTER_E_NO_VALUES:
    case FILTER_E_EMBEDDING_UNAVAILABLE:
    case FILTER_E_LINK_UNAVAILABLE:
        hr = S_FALSE;
        break;
    }
    return hr;
}

// returns:
// S_OK match
// S_FALSE did not match

STDMETHODIMP CFilterGrep::Grep(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszName)
{
    HRESULT hr = S_FALSE;
    BOOL bHit = FALSE;
    ULONG ulFlags = IFILTER_FLAGS_OLE_PROPERTIES;   // default to try to use pss
    ULONG dwThread = GetCurrentThreadId();
    
    if (NULL == _pTokens)
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (_IsRestrictedFileType(pszName))
        return S_FALSE;

    // Grep the filename.
    if ((_dwFlags & FGIF_GREPFILENAME) && _pTokens->GrepW(pszName))
    {
        return S_OK;
    }

    IFilter *pFilter;
    if (SUCCEEDED(psf->BindToStorage(pidl, NULL, IID_PPV_ARG(IFilter, &pFilter))))
    {
        __try
        {
            hr = pFilter->Init(IFILTER_INIT_CANON_PARAGRAPHS |
                IFILTER_INIT_CANON_HYPHENS |
                IFILTER_INIT_CANON_SPACES |
                IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
                IFILTER_INIT_INDEXING_ONLY,
                0, 0, &ulFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_ABORT;
        }

        while (!bHit && (S_OK == hr))
        {
            STAT_CHUNK stat;
    
            __try
            {
                hr = pFilter->GetChunk(&stat);
                while ((S_OK == hr) && (0 == (stat.flags & (CHUNK_TEXT | CHUNK_VALUE))))
                {
                    TraceMsg(TF_WARNING, "CFilterGrep::Grep encountered bad/unknown type for chunk; skipping.");
                    hr = pFilter->GetChunk(&stat);
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_ABORT;
            }
    
            hr = _MapFilterCriticalError(hr);   // convert filter errors into S_FALSE
    
            if (S_OK == hr)
            {
                ULONG grfDescriminate = (_dwFlags & FGIF_BLANKETGREP);
        
                if (FGIF_BLANKETGREP == grfDescriminate ||
                    (_IsEqualAttribute(stat.attribute, FMTID_Storage, PID_STG_CONTENTS) ?
                    FGIF_GREPPROPERTIES == grfDescriminate : FGIF_GREPCONTENT == grfDescriminate))
                {
                    if (((stat.flags & CHUNK_VALUE) && S_OK == _GrepValue(pFilter, &stat)) ||
                        ((stat.flags & CHUNK_TEXT) && S_OK == _GrepText(pFilter, &stat, dwThread)))
                    {
                        bHit = TRUE;
                    }
                }
            }
        }
        pFilter->Release();
    }
    
    // Grep OLE/NFF properties if appropriate
    if (SUCCEEDED(hr))
    {
        if (!bHit && (ulFlags & IFILTER_FLAGS_OLE_PROPERTIES) && (_dwFlags & FGIF_BLANKETGREP))
        {
            IPropertySetStorage *pps;
            if (SUCCEEDED(psf->BindToStorage(pidl, NULL, IID_PPV_ARG(IPropertySetStorage, &pps))))
            {
                hr = _GrepProperties(pps);
                bHit = (S_OK == hr);
                pps->Release();
            }
        }
    }
    
    if (SUCCEEDED(hr))
        hr = bHit ? S_OK : S_FALSE;
    return hr;
}


STDMETHODIMP CFilterGrep::_GrepValue(IFilter* pFilter, STAT_CHUNK* pstat)
{
    PROPVARIANT* pvar = NULL;
    HRESULT      hr;

    __try
    {
        hr = pFilter->GetValue(&pvar);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_ABORT;
    }

    if (SUCCEEDED(hr))
    {
        hr = _PropVariantGrep(pvar, _pTokens) ? S_OK : S_FALSE;
        PropVariantClear(pvar);
        CoTaskMemFree(pvar);
    }
    return hr;
}

//  Greps OLE/NFF properties.
STDMETHODIMP CFilterGrep::_GrepProperties(IPropertySetStorage *pss)
{
    BOOL bHit = FALSE;
    
    IEnumSTATPROPSETSTG* pEnumSet;
    
    if (SUCCEEDED(pss->Enum(&pEnumSet)))
    {
        STATPROPSETSTG statSet[8];
        DWORD cSets = 0;
        while (!bHit && 
               SUCCEEDED(pEnumSet->Next(ARRAYSIZE(statSet), statSet, &cSets)) && cSets)
        {
            for (UINT i = 0; !bHit && i < cSets; i++)
            {
                IPropertyStorage *pstg;
                if (SUCCEEDED(pss->Open(statSet[i].fmtid, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, &pstg)))
                {
                     bHit = (S_OK == _GrepEnumPropStg(pstg));
                     pstg->Release();
                }
            }
        }
        pEnumSet->Release();
    }
    
    return bHit ? S_OK : S_FALSE;
}

#define PROPGREPBUFSIZE  16

//  Reads and greps a block of properties described by a 
//  caller-supplied array of PROPSPECs.
STDMETHODIMP CFilterGrep::_GrepPropStg(IPropertyStorage *pstg, ULONG cspec, PROPSPEC rgspec[])
{
    PROPVARIANT rgvar[PROPGREPBUFSIZE] = {0}, // stack buffer
                *prgvar = rgvar;
    BOOL        bHit = FALSE;

    if (cspec > ARRAYSIZE(rgvar)) // stack buffer large enough?
    {
        if (NULL == (prgvar = new PROPVARIANT[cspec]))
            return E_OUTOFMEMORY;
        ZeroMemory(prgvar, sizeof(PROPVARIANT) * cspec);
    }

    //  Read properties:

    HRESULT hr = pstg->ReadMultiple(cspec, rgspec, prgvar);
    if (SUCCEEDED(hr))
    {
        for (UINT i = 0; i < cspec; i++)
        {
            if (!bHit)
                bHit = _PropVariantGrep(prgvar + i, _pTokens);
            PropVariantClear(rgvar + i);
        }
    }

    if (prgvar != rgvar)
        delete [] prgvar;

    if (SUCCEEDED(hr))
        return bHit ? S_OK : S_FALSE;

    return hr;
}

//  Enumerates and greps all properties in a property set
STDMETHODIMP CFilterGrep::_GrepEnumPropStg(IPropertyStorage* pstg)
{
    BOOL bHit = FALSE;
    IEnumSTATPROPSTG* pEnumStg;
    if (SUCCEEDED(pstg->Enum(&pEnumStg)))
    {
        STATPROPSTG statProp[PROPGREPBUFSIZE];
        DWORD cProps;

        while (!bHit && 
               SUCCEEDED(pEnumStg->Next(ARRAYSIZE(statProp), statProp, &cProps)) && cProps)
        {
            PROPSPEC rgspec[PROPGREPBUFSIZE] = {0};
            for (UINT i = 0; i < cProps; i++)
            {
                rgspec[i].ulKind = PRSPEC_PROPID;
                rgspec[i].propid = statProp[i].propid;
                CoTaskMemFree(statProp[i].lpwstrName);
            }

            bHit = (S_OK == _GrepPropStg(pstg, cProps, rgspec));
        }
        
        pEnumStg->Release();
    }

    return bHit ? S_OK : S_FALSE;
}


//  Reports whether the indicated unicode character is a 
//  word-breaking character.
inline BOOL _IsWordBreakCharW(IN LPWSTR pszBuf, IN ULONG ich)
{
    WORD wChar;
    return GetStringTypeW(CT_CTYPE1, pszBuf + ich, 1, &wChar) 
           && (wChar & (C1_SPACE|C1_PUNCT|C1_CNTRL|C1_BLANK));
}


//  Finds the last word-breaking character.
LPWSTR _FindLastWordBreakW(IN LPWSTR pszBuf, IN ULONG cch)
{
    while(--cch)
    {
        if (_IsWordBreakCharW(pszBuf, cch))
            return pszBuf + cch;
    }
    return NULL;
}


// {c1243ca0-bf96-11cd-b579-08002b30bfeb}
const CLSID CLSID_PlainTextFilter = {0xc1243ca0, 0xbf96, 0x11cd, {0xb5, 0x79, 0x08, 0x00, 0x2b, 0x30, 0xbf, 0xeb}};

STDMETHODIMP CFilterGrep::_GrepText(IFilter* pFilter, STAT_CHUNK* pstat, DWORD dwThreadID)
{
    ASSERT(pstat);

    LPWSTR  pszBuf = NULL;
    ULONG   cchBuf = pstat->cwcLenSource ? 
                pstat->cwcLenSource : DEFAULT_GREPBUFFERSIZE;
    
    HRESULT hr = _GetThreadGrepBuffer(dwThreadID, cchBuf, &pszBuf);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszFetch = pszBuf, 
               pszTail  = NULL;
        ULONG  cchFetch = cchBuf, 
               cchTail  = 0;
   
        //  Fetch first block of text

        __try
        {
            hr = pFilter->GetText(&cchFetch, pszFetch);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_ABORT;
        }

        CLSID clsid = {0};    
        IUnknown_GetClassID(pFilter, &clsid);   // to workaround a bug in the text filter

        while (SUCCEEDED(hr) && cchFetch)
        {
            ASSERT((cchFetch + cchTail) <= cchBuf);

            pszBuf[cchFetch + cchTail] = 0; // don't trust filter to zero-terminate buffer.

            // When you get the FILTER_S_LAST_TEXT, that's it, you'll get no more text, so treat the tail part as part of the text
            if (hr == FILTER_S_LAST_TEXT)
            {
                pszTail = NULL;
                cchTail = 0;
            }
            else if (CLSID_PlainTextFilter == clsid)
            {
                // CLSID_PlainText filter always returns S_OK, instead of FILTER_S_LAST_TEXT, this forces us to scan
                // the entire chunk now, AND (see below) to pass it off as a tail for scanning next chunk too.
                // pszTail and cchTail are set below.
            }
            else
            {
                pszTail = _FindLastWordBreakW(pszBuf, cchFetch + cchTail);
                if (pszTail)
                {
                    // Break on word boundary and leave remainder (tail) for next iteration
                    *pszTail = TEXT('\0');
                    pszTail++;
                    cchTail = lstrlenW(pszTail);
                }
                else
                {
                    // Wow, big block, with no word break, search its entirety.
                    // REVIEW:  cross chunk items won't be found
                    pszTail = NULL;
                    cchTail = 0;
                }
            }

            //  do the string scan
            if (_pTokens->GrepW(pszBuf))
            {
                *pszBuf = 0;
                return S_OK;
            }
            else if (FILTER_S_LAST_TEXT == hr)
            {
                *pszBuf = 0;
                return S_FALSE;
            }

            //  prepare for next fetch...

            // If it is the plaintext filter, grab the tail anyway, even though we've tested it already
            // WinSE 25867

            if (CLSID_PlainTextFilter == clsid)
            {
                pszTail = _FindLastWordBreakW(pszBuf, cchFetch + cchTail);
                if (pszTail)
                {
                    *pszTail = TEXT('\0');
                    pszTail++;
                    cchTail = lstrlenW(pszTail);
                }
                else
                {
                    pszTail = NULL;
                    cchTail = 0;
                }
            }

            *pszBuf  = 0;
            pszFetch = pszBuf;
            cchFetch = cchBuf;

            //  If there is a tail to deal with, move it to the front of
            //  the buffer and prepare to have the next block of incoming text
            //  appended to the tail..
            if (pszTail && cchTail)
            {
                MoveMemory(pszBuf, pszTail, cchTail * sizeof(*pszTail));
                pszBuf[cchTail] = 0;
                pszFetch += cchTail;
                cchFetch -= cchTail;
            }

            //  Fetch next block of text.
            __try
            {
                hr = pFilter->GetText(&cchFetch, pszFetch);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_ABORT;
            }
        }
    }

    if (SUCCEEDED(hr) || FILTER_E_NO_MORE_TEXT == hr || FILTER_E_NO_TEXT == hr)
        return S_FALSE;

    return hr;
}


//  Returns a grep buffer of the requested size for the specified thread.
STDMETHODIMP CFilterGrep::_GetThreadGrepBuffer(
    DWORD dwThreadID, 
    ULONG cchNeed, 
    LPWSTR* ppszBuf)
{
    ASSERT(dwThreadID);
    ASSERT(cchNeed > 0);
    ASSERT(ppszBuf);

    HRESULT hr = E_FAIL;
    *ppszBuf = NULL;
    
    _EnterCritical();
    
    if (_hdpaGrepBuffers || (_hdpaGrepBuffers = DPA_Create(4)) != NULL)
    {
        CGrepBuffer *pgb, *pgbCached = NULL;

        for (int i = 0, cnt = DPA_GetPtrCount(_hdpaGrepBuffers); i < cnt; i++)
        {
            pgb = (CGrepBuffer*)DPA_FastGetPtr(_hdpaGrepBuffers, i);
            if (pgb->IsThread(dwThreadID))
            {
                pgbCached = pgb;
                hr = pgbCached->Alloc(cchNeed);
                if (S_OK == hr)
                    *ppszBuf = pgbCached->Buffer();
                break;
            }
        }
        
        if (NULL == pgbCached) //  not cached?
        {
            if ((pgb = new CGrepBuffer(dwThreadID)) != NULL)
            {
                hr = pgb->Alloc(cchNeed);
                if (S_OK == hr)
                {
                    *ppszBuf = pgb->Buffer();
                    DPA_AppendPtr(_hdpaGrepBuffers, pgb);
                }
                else
                    delete pgb;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    _LeaveCritical();
    return hr;
}


//  Frees grep buffer for the specified thread
STDMETHODIMP CFilterGrep::_FreeThreadGrepBuffer(DWORD dwThreadID)
{
    HRESULT hr = S_FALSE;
    _EnterCritical();

    for (int i = 0, cnt = DPA_GetPtrCount(_hdpaGrepBuffers); i < cnt; i++)
    {
        CGrepBuffer* pgb = (CGrepBuffer*) DPA_FastGetPtr(_hdpaGrepBuffers, i);
        if (pgb->IsThread(dwThreadID))
        {
            DPA_DeletePtr(_hdpaGrepBuffers, i);
            hr = S_OK;
            break;
        }
    }

    _LeaveCritical();
    return hr;
}


//  Clears grep buffer for all threads
STDMETHODIMP_(void) CFilterGrep::_ClearGrepBuffers()
{
    _EnterCritical();

    if (_hdpaGrepBuffers)
    {
        while(DPA_GetPtrCount(_hdpaGrepBuffers))
        {
            CGrepBuffer* pgb = (CGrepBuffer*)DPA_DeletePtr(_hdpaGrepBuffers, 0);
            delete pgb;
        }

        DPA_Destroy(_hdpaGrepBuffers);
        _hdpaGrepBuffers = NULL;
    }

    _LeaveCritical();
}


//#define _USE_GREP_RESTRICTIONS_  // Check for registered list of excluded files types

//  Reports whether the file type is restricted from full-text grep.
STDMETHODIMP_(BOOL) CFilterGrep::_IsRestrictedFileType(LPCWSTR pwszFile)
{
#ifdef _USE_GREP_RESTRICTIONS_
    LPCWSTR pwszExt = PathFindExtensionW(pwszFile);
    if (pwszExt && *pwszExt)
    {
        if (_dwFlags & FGIF_GREPCONTENT && 
            _FetchRestrictionSettings(L"Content", &_pwszContentRestricted, FALSE))
        {
            if (_ScanRestrictionSettings(_pwszContentRestricted, pwszExt))
                return TRUE;
        }
            
        if (_dwFlags & FGIF_GREPCONTENT && 
            _FetchRestrictionSettings(L"Properties", &_pwszPropertiesRestricted, FALSE))
        {
            if (_ScanRestrictionSettings(_pwszPropertiesRestricted, pwszExt))
                return TRUE;
        }
    }
#endif
    return FALSE;
}

STDMETHODIMP CFilterGrep::GetMatchTokens(OUT LPWSTR pszTokens, UINT cchTokens) const
{
    HRESULT hr = _pTokens ? _pTokens->GetMatchTokens(pszTokens, cchTokens) : S_FALSE;
    if (S_OK != hr && pszTokens)
        *pszTokens = 0;
    return hr;
}


STDMETHODIMP CFilterGrep::GetExcludeTokens(OUT LPWSTR pszTokens, UINT cchTokens) const
{
    HRESULT hr = _pTokens ? _pTokens->GetExcludeTokens(pszTokens, cchTokens) : S_FALSE;
    if (S_OK != hr && pszTokens)
        *pszTokens = 0;
    return hr;
}


STDMETHODIMP CFilterGrep::GetCodePage(UINT* pnCodepage) const
{
    HRESULT hr = _pTokens ? _pTokens->GetCodePage(pnCodepage) : S_FALSE;
    if (S_OK != hr && pnCodepage)
        *pnCodepage = 0;
    return hr;
}


STDMETHODIMP CFilterGrep::GetFlags(DWORD* pdwFlags) const
{ 
    if (*pdwFlags)
        *pdwFlags = _dwFlags;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filefldr.h ===
#include "fstreex.h"    // public stuff
#include "filetbl.h"
#include <caggunk.h>
#include <idhidden.h>
#include "lmcons.h"
#include "pidl.h"
#include <enumt.h>

class CFSDropTarget;
class CFSFolderViewCB;
class CFileSysEnum;
class CFSFolderEnumSTATSTG;
class CFSFolder;
class CFileSysItemString;

#define INDEX_PROPERTYBAG_HKCU          0
#define INDEX_PROPERTYBAG_HKLM          1
#define INDEX_PROPERTYBAG_DESKTOPINI    2

class CFSFolderPropertyBag : public IPropertyBag
{
    friend CFSFolder;
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:
    CFSFolderPropertyBag(CFSFolder *pff, DWORD grfMode);
    HRESULT _Init(LPCIDFOLDER pidfLast);

private:
    virtual ~CFSFolderPropertyBag();

    LONG _cRef;
    DWORD _grfMode;
    CFSFolder* _pFSFolder;
    IPropertyBag* _pPropertyBags[3];
};

#define UASTROFFW(pfsi, cb) (LPNWSTR)(((LPBYTE)(pfsi)) + (cb))
#define UASTROFFA(pfsi, cb) (LPSTR)(((LPBYTE)(pfsi)) + (cb))

// This enum is simply an index into c_rgFolderType and c_wvContent (TODO: merge these),
// therefore this *is* the Folder Type:
typedef enum {
    FVCBFT_NOTSPECIFIED = -1,
    FVCBFT_DOCUMENTS = 0,   // "0" is default until otherwise specified
    FVCBFT_MYDOCUMENTS,
    FVCBFT_PICTURES,
    FVCBFT_MYPICTURES,
    FVCBFT_PHOTOALBUM,
    FVCBFT_MUSIC,
    FVCBFT_MYMUSIC,
    FVCBFT_MUSICARTIST,
    FVCBFT_MUSICALBUM,
    FVCBFT_VIDEOS,
    FVCBFT_MYVIDEOS,
    FVCBFT_VIDEOALBUM,
    FVCBFT_USELEGACYHTT,
    FVCBFT_COMMONDOCUMENTS,
    FVCBFT_NUM_FOLDERTYPES
} FVCBFOLDERTYPE;


typedef enum
{
    FSINAME_NONE        = 0x0000,
    FSINAME_FS          = 0x0001,
    FSINAME_UI          = 0x0002,
    FSINAME_FSUI        = 0x0003,
    FSINAME_RESOURCE    = 0x0004,
    FSINAME_CLASS       = 0x0008,
} FSINAME;

class CFileSysItem
{
public:
    CFileSysItem(LPCIDFOLDER pidf);
    BOOL HasResourceName() { return ((_pidfx && _pidfx->offResourceA)); }
    BOOL IsLegacy() { return _pidfx == NULL; }
    BOOL CantRename(CFSFolder *pfs);
    LPCWSTR MayCopyFSName(BOOL fMustCopy, LPWSTR psz, DWORD cch);
    LPCWSTR MayCopyClassName(BOOL fMustCopy, LPTSTR pszClass, UINT cch);

protected:  // methods
    TRIBIT _IsMine(CFSFolder *pfs);
    BOOL _IsPersonalized();

protected:  // members
    LPCIDFOLDER _pidf;
    PCIDFOLDEREX _pidfx;
    PCIDPERSONALIZED _pidp;
};

class CFileSysItemString : public CFileSysItem
{
public:
    CFileSysItemString(LPCIDFOLDER pidf);
    LPCWSTR FSName();
    LPCSTR AltName();
    LPCWSTR UIName(CFSFolder *pfs);
    LPCWSTR ResourceName();
    LPCWSTR Class();
    HRESULT GetFindData(WIN32_FIND_DATAW *pfd);
    HRESULT GetFindDataSimple(WIN32_FIND_DATAW *pfd);
    BOOL ShowExtension(BOOL fDefShowExt);
    PERCEIVED PerceivedType();
    BOOL IsShimgvwImage();
    BOOL GetJunctionClsid(CLSID *pclsid, BOOL fShellExtOk);
    HRESULT AssocCreate(CFSFolder *pfs, BOOL fForCtxMenu, REFIID riid, void **ppv);
    DWORD ClassFlags(BOOL fNeedsIconBits) 
        { return _ClassFlags(NULL, fNeedsIconBits); }
    
protected:  // methods
    BOOL _LoadResource(CFSFolder *pfs);
    BOOL _MakePossessiveName(LPCWSTR pszFormat);
    int _GetPersonalizedRes(int csidl, BOOL fIsMine);
    void _FormatTheirs(LPCWSTR pszFormat);
    BOOL _ResourceName(LPWSTR psz, DWORD cch, BOOL fIsTheirs);
    LPCWSTR _Class();
    DWORD _ClassFlags(IUnknown *punkAssoc, BOOL fNeedsIconBits);
    void _QueryClassFlags(IAssociationArray *paa);
    void _QueryIconIndex(IAssociationArray *paa);

protected:  // members
    LPCWSTR _pszFSName;     // points inside the pidfx
    LPCWSTR _pszUIName;     // points inside the pidfx
    LPCWSTR _pszClass;      // points inside the pidfx
    DWORD _dwClass;
    FSINAME _fsin;
    WCHAR _sz[MAX_PATH];
};

class CFSAssocEnumData : public CEnumAssociationElements 
{
public:
    CFSAssocEnumData(BOOL fIsUnknown, CFSFolder *pfs, LPCIDFOLDER pidf);
    ~CFSAssocEnumData() { if (_pidl) ILFree(_pidl); }
    
protected:
    virtual BOOL _Next(IAssociationElement **ppae);
    
protected:
    BOOL _fIsUnknown;
    BOOL _fIsSystemFolder;
    WCHAR _szPath[MAX_PATH];
    LPITEMIDLIST _pidl;
};


// This struct is used for caching the column info
typedef struct {
    SHCOLUMNINFO shci;
    IColumnProvider *pcp;
    UINT iColumnId;  // This is the 'real' column number, think of it as an index to the scid, which can be provided multiple times
                     //  ie 3 column handlers each provide the same 5 cols, this goes from 0-4
} COLUMNLISTENTRY;

typedef struct
{
    UINT cbResource;
    CHAR szResource[MAX_PATH];
    IDPERSONALIZED idp;
} EXSTRINGS;

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData);
STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszOut, int cch, LPCTSTR pszKey);

STDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);
STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);

class CFSFolder : public CAggregatedUnknown,
                  public IShellFolder2,
                  public IShellIcon,
                  public IShellIconOverlay,
                  public IPersistFolder3,
                  public IStorage,
                  public ITransferDest,
                  public IPropertySetStorage,
                  public IItemNameLimits,
                  public IContextMenuCB,
                  public ISetFolderEnumRestriction,
                  public IOleCommandTarget
{
    friend CFSFolderViewCB;
    friend CFSDropTarget;
    friend CFileSysEnum;
    friend CFSFolderEnumSTATSTG;
    friend CFSFolderPropertyBag;
    friend CFileSysItem;
    friend CFileSysItemString;
    friend CFSAssocEnumData;
    
    // these are evil, get rid of as many of these as possible
    friend HRESULT SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);
    friend HRESULT CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
    friend HRESULT CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
    friend void CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);
    friend HRESULT CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    friend DWORD CFSFolder_PropertiesThread(void *pv);
    friend HRESULT CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pf, REFIID riid, void **ppv);
    friend LPCIDFOLDER CFSFolder_IsValidID(LPCITEMIDLIST pidl);
    friend BOOL CFSFolder_IsCommonItem(LPCITEMIDLIST pidl);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CAggregatedUnknown::QueryInterface(riid, ppv); };
    STDMETHODIMP_(ULONG) AddRef(void)   { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)  { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IPersistFolder3
    STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti);
    STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti);

    // IShellIcon methods
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay methods
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);

    // IStorage
    STDMETHODIMP CreateStream(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);                
    STDMETHODIMP CreateStorage(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage **ppstg);        
    STDMETHODIMP OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);;
    STDMETHODIMP CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest);        
    STDMETHODIMP MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);        
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);        
    STDMETHODIMP DestroyElement(LPCWSTR pszRel);        
    STDMETHODIMP RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName);        
    STDMETHODIMP SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime);
    STDMETHODIMP SetClass(REFCLSID clsid);        
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask);        
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);

    // ITransferDest
    STDMETHODIMP Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie);
    STDMETHODIMP Unadvise(DWORD dwCookie);
    STDMETHODIMP OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk);
    STDMETHODIMP CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk);
    STDMETHODIMP MoveElement(IShellItem *psiItem, WCHAR  *pwcsNewName, STGXMOVE grfOptions);
    STDMETHODIMP DestroyElement(const WCHAR *pwcsName, STGXDESTROY grfOptions);

    // IPropertySetStorage methods
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IItemNameLimits
    STDMETHODIMP GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHODIMP GetMaxLength(LPCWSTR pszName, int *piMaxNameLen);

    // ISetFolderEnumRestriction
    STDMETHODIMP SetEnumRestriction(DWORD dwRequired, DWORD dwForbidden);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CFSFolder(IUnknown *punkOuter);

protected:
    LPCITEMIDLIST _GetIDList() { return _pidl; };

    HRESULT v_InternalQueryInterface(REFIID riid, void **ppv);
    virtual ~CFSFolder();

    HRESULT _GetPathForItems(LPCIDFOLDER pidfParent, LPCIDFOLDER pidf, LPTSTR pszPath);
    HRESULT _GetPathForItem(LPCIDFOLDER pidf, LPWSTR pszPath);
    HRESULT _GetPath(LPTSTR pszPath);
    static HRESULT _GetAltDisplayName(LPCIDFOLDER pidf, LPTSTR pszName, DWORD cchName);
    static HRESULT _MakePossessiveName(LPCTSTR pszFile, LPCTSTR pszOwner, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetUsersDisplayName(LPCTSTR pszOwner, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _SetLocalizedDisplayName(LPCIDFOLDER pidf, LPCTSTR pszName);
    void _UpdateItem(LPCIDFOLDER pidf);

    DWORD _Attributes();
    UINT _GetCSIDL();
    BOOL _IsCSIDL(UINT csidl);
    UINT _GetItemExStrings(LPCIDFOLDER pidfSimpleParent, const WIN32_FIND_DATA *pfd, EXSTRINGS *pxs);
    HRESULT _CreateIDList(const WIN32_FIND_DATA *pfd, LPCIDFOLDER pidfSimpleParent, LPITEMIDLIST *ppidl);
    HRESULT _Properties(LPCITEMIDLIST pidlParent, IDataObject *pdtobj, LPCTSTR pStartPage);
    HRESULT _Reset();
    HRESULT _CreateInstance(HWND hwnd, IDropTarget** ppdt);
    HRESULT _CreateEnum(IUnknown *punk, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum);
    HRESULT _GetJunctionForBind(LPCIDFOLDER pidf, LPIDFOLDER *ppidfBind, LPCITEMIDLIST *ppidlRight);
    LPCTSTR _BindHandlerName(REFIID riid);
    HRESULT _Bind(LPBC pbc, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _LoadHandler(LPCIDFOLDER pidf, DWORD grfMode, LPCTSTR pszHandlerType, REFIID riid, void **ppv);
    HRESULT _HandlerCreateInstance(LPCIDFOLDER pidf, PCWSTR pszClsid, DWORD grfMode, REFIID riid, void **ppv);
    HRESULT _CreateShimgvwExtractor(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    BOOL _IsSlowPath();
    HRESULT _GetToolTipForItem(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetIntroText(LPCIDFOLDER pidf, WCHAR* pwszIntroText, UINT cchIntroText);

    // GetDetailsEx() helpers.
    HRESULT _GetAttributesDescription(LPCIDFOLDER pidf, VARIANT *pv);
    HRESULT _GetAttributesDescriptionBuilder(LPWSTR szAttributes, size_t cchAttributes, LPWSTR szAttribute);
    HRESULT _GetLinkTarget(LPCITEMIDLIST pidl, VARIANT *pv);
    HRESULT _GetNetworkLocation(LPCIDFOLDER pidf, VARIANT *pv);
    HRESULT _GetComputerName(LPCIDFOLDER pidf, VARIANT *pv);
    HRESULT _GetComputerName_FromPath(LPCWSTR pszPath, VARIANT *pv);
    HRESULT _GetComputerName_FromUNC(LPWSTR pszPath, VARIANT *pv);
    HRESULT _GetCSCStatus(LPCIDFOLDER pidf, VARIANT *pv);

    BOOL _GetFolderFlags(LPCIDFOLDER pidf, UINT *prgfFlags);
    BOOL _GetFolderIconPath(LPCIDFOLDER pidf, LPTSTR pszIcon, int cchMax, UINT *pIndex);
    static DWORD   CALLBACK _PropertiesThread(void *pv);
    static DWORD _GetClassFlags(LPCIDFOLDER pidf);
    static BOOL _GetClass(LPCIDFOLDER pidf, LPTSTR pszClass, UINT cch);
    UINT _GetContextMenuKeys(LPCIDFOLDER pidf, HKEY *aKeys, UINT cKeys, IAssociationArray **ppaa);
    BOOL _CheckDefaultIni(LPCIDFOLDER pidfLast, LPTSTR pszIniPath);

    HRESULT _CompareExtendedProp(int iColumn, LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareModifiedDate(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareCreateTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareAccessTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareAttribs(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareFileTypes(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    HRESULT _CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2, BOOL fCaseSensitive, BOOL fCanonical);
    static HRESULT _CompareFolderness(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);

    BOOL _DefaultShowExt();
    BOOL _ShowExtension(LPCIDFOLDER pidf);
    static HRESULT _GetClassKey(LPCIDFOLDER pidf, HKEY *phkeyProgID);

    // file system, non junction point folder
    static BOOL _IsJunction(LPCIDFOLDER pidf);
    static BYTE _GetType(LPCIDFOLDER pidf);
    static BOOL _IsSimpleID(LPCIDFOLDER pidf);
    static LPIDFOLDER _FindLastID(LPCIDFOLDER pidf);
    static LPIDFOLDER _Next(LPCIDFOLDER pidf);
    static LPCIDFOLDER _IsValidID(LPCITEMIDLIST pidl);
    static LPCIDFOLDER _IsValidIDHack(LPCITEMIDLIST pidl);
    static BOOL _IsCommonItem(LPCITEMIDLIST pidl);

    static BOOL _IsFile(LPCIDFOLDER pidf);
    static BOOL _IsFolder(LPCIDFOLDER pidf);
    static BOOL _IsFileFolder(LPCIDFOLDER pidf);
    static BOOL _IsSystemFolder(LPCIDFOLDER pidf);
    static BOOL _IsReal(LPCIDFOLDER pidf);

    BOOL _IsSelfSystemFolder();
    BOOL _HasLocalizedFileNames();

    BOOL _IsOfflineCSC(LPCIDFOLDER pidf);
    BOOL _IsOfflineCSC(LPCTSTR pszPath);

    HRESULT _InitFolder(IBindCtx *pbc, LPCIDFOLDER pidf, IUnknown **ppunk);
    HRESULT _InitStgFolder(LPCIDFOLDER pidf, LPCWSTR wszPath, DWORD grfMode, REFIID riid, void **ppv);
    BOOL _GetMountingPointInfo(LPCIDFOLDER pidf, LPTSTR pszMountPoint, DWORD cchMountPoint);
    HRESULT _CreateContextMenu(HWND hwnd, LPCIDFOLDER pidf, LPCITEMIDLIST *apidl, UINT cidl, IContextMenu **ppcm);
    HRESULT _AssocCreate(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    static BOOL _GetJunctionClsid(LPCIDFOLDER pidf, CLSID *pclsidRet);
    static LPCTSTR _GetTypeName(LPCIDFOLDER pidf);
    static HRESULT _GetTypeNameBuf(LPCIDFOLDER pidf, LPTSTR pszName, int cchNameMax);
    static LPWSTR _CopyName(LPCIDFOLDER pidf, LPWSTR pszName, UINT cchName);
    static int _CopyUIName(LPCIDFOLDER pidf, LPTSTR pszName, UINT cchName);
    static HRESULT _AppendItemToPath(LPTSTR pszPath, LPCIDFOLDER pidf);
    static LPTSTR _CopyAltName(LPCIDFOLDER pidf, LPTSTR pszName, UINT cchName);
    static void _GetSize(LPCITEMIDLIST pidlParent, LPCIDFOLDER pidf, ULONGLONG *pcbSize);
    static LPCSTR _GetAltName(LPCIDFOLDER pidf);
    static HRESULT _FindDataFromIDFolder(LPCIDFOLDER pidf, WIN32_FIND_DATAW *pfd, BOOL fAllowSimplePid);
    static DWORD _GetUID(LPCIDFOLDER pidf);
    static LPCIDFOLDER _FindJunction(LPCIDFOLDER pidf);
    static LPCITEMIDLIST _FindJunctionNext(LPCIDFOLDER pidf);

    ULONGLONG _Size(LPCIDFOLDER pidf);
    HRESULT _NormalGetDisplayNameOf(LPCIDFOLDER pidf, STRRET *pStrRet);
    HRESULT _NormalDisplayName(LPCIDFOLDER pidf, LPWSTR psz, UINT cch);
    BOOL _GetBindCLSID(IBindCtx *pbc, LPCIDFOLDER pidf, CLSID *pclsid);
    HRESULT _InitColData(LPCIDFOLDER pidf, SHCOLUMNDATA* pscd);
    LPIDFOLDER _MarkAsJunction(LPCIDFOLDER pidfSimpleParent, LPIDFOLDER pidf, LPCTSTR pszName);
    HRESULT _CreateIDListFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, LPITEMIDLIST *ppidl);
    BOOL _CanSeeInThere(LPCTSTR pszName);
    HRESULT _ParseSimple(LPCWSTR pszPath, const WIN32_FIND_DATA *pfdLast, LPITEMIDLIST *ppidl);
    HRESULT _FindDataFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, WIN32_FIND_DATA **ppfd);
    HRESULT _CheckDriveRestriction(HWND hwnd, REFIID riid);
    HRESULT _CreateUIHandler(REFIID riid, void **ppv);
    BOOL _IsNetPath();
    int _GetDefaultFolderIcon();
    HRESULT _CreateDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    BOOL _FindColHandler(UINT iCol, UINT iN, COLUMNLISTENTRY *pcle);
    BOOL _ShouldNotShowColumn(UINT iColumn);
    BOOL _ShouldShowExtendedColumn(const SHCOLUMNID* pscid);
    HRESULT _MapSCIDToColumn(const SHCOLUMNID* pscid, UINT* puCol);
    HRESULT _ExtendedColumn(LPCIDFOLDER pidf, UINT iColumn, SHELLDETAILS *pDetails);
    HRESULT _LoadColumnHandlers();
    HRESULT _GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);
    void _DestroyColHandlers();

    HRESULT _GetFullPath(LPCWSTR pszRelPath, LPWSTR pszFull);
    HRESULT _Delete(LPCWSTR pszFile);
    HRESULT _OpenCreateStorage(LPCWSTR pwcsName, DWORD grfMode, IStorage **ppstg, BOOL fCreate);
    HRESULT _OpenCreateStream(LPCWSTR pwcsName, DWORD grfMode, IStream **ppstm, BOOL fCreate);
    HRESULT _SetStgMode(DWORD grfMode);

    HRESULT _LoadPropHandler();
    HRESULT _GetStatStgFromItemName(LPCTSTR szName, STATSTG * pstat);

    HRESULT _CreateFolderPropertyBag(DWORD grfMode, LPCIDFOLDER pidfLast, REFIID riid, void **ppv);

    HRESULT _GetPropertyUI();

    LPITEMIDLIST        _pidl;                  // Absolute IDList (location in the name space)
    LPITEMIDLIST        _pidlTarget;            // Absolute IDList for folder target (location in namespace to enumerate)
                                                // WARNING: _csidlTrack overrides _pidlTarget
    LPTSTR              _pszPath;               // file system path (may be different from _pidl)
    LPTSTR              _pszNetProvider;        // network provider (for net calls we may need to make)

    CLSID               _clsidBind;             // use CLSID_NULL for normal case

    int                 _cHiddenFiles;          // view callback and enumerator share these
    ULONGLONG           _cbSize;

    UINT                _csidl;                 // CSIDL_ value of this folder (if known)
    DWORD               _dwAttributes;          // attributes of this folder (if known)
    int                 _csidlTrack;            // CSIDL_ that we follow dynamically

    BOOL                _fCachedCLSID : 1;      // clsidView is already cached
    BOOL                _fHasCLSID    : 1;      // clsidView has a valid CLSID
    CLSID               _clsidView;             // CLSID for View object
    HDSA                _hdsaColHandlers;       // cached list of columns and handlers
    DWORD               _dwColCount;            // count of unique columns
    int                 _iFolderIcon;           // icon for sub folders to inherit
    BOOL                _bUpdateExtendedCols;   // set to TRUE in response to SFVM_INSERTITEM callback, passed to IColumnProvider::GetItemData then cleared 
    BOOL                _bSlowPath;             // Lazy-calculated value of whether the folder is on a slow path
    BOOL                _fDontForceCreate;      // don't succeed with STGM_CREATE passed to ParseDisplayName for a non-existent item
    FVCBFOLDERTYPE      _nFolderType;
  
    TRIBIT _tbHasLocalizedFileNamesSection; // Lazy-calculated value of whether the folder has a desktop.ini with a LocalizedFileNames section
    TRIBIT _tbDefShowExt; // cache of SHGetSetSettings(SSF_SHOWEXTENSIONS)
    TRIBIT _tbOfflineCSC; // cache of _IsOfflineCSC(_pidl)

    DWORD _grfFlags;

    DWORD               _dwEnumRequired;        // SetEnumRestriction
    DWORD               _dwEnumForbidden;       // SetEnumRestriction

    IPropertySetStorage *_pstg;
    IPropertyUI         *_pPropertyUI;
    ITransferAdviseSink * _pAdvise;
};

// fstree.cpp
STDAPI CFSFolderCallback_Create(CFSFolder *pFSFolder, IShellFolderViewCB **ppsfvcb);
STDAPI CFSDropTarget_CreateInstance(CFSFolder* pFSFolder, HWND hwnd, IDropTarget** ppdt);
STDAPI CFSFolder_CreateEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum);
STDAPI CFolderExtractImage_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppvObj);

class CFSIconManager : public ICustomIconManager
{
public:

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICustomIconManager
    STDMETHODIMP SetIcon(LPCWSTR pszIconPath,int iIcon);
    STDMETHODIMP SetDefaultIcon();
    STDMETHODIMP GetDefaultIconHandle(HICON *phIcon);
    STDMETHODIMP GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex) = 0;
   
protected:
    HRESULT _Init(LPCITEMIDLIST pidl, IShellFolder *psf);
    WCHAR _wszPath[MAX_PATH];
    CFSIconManager();
    virtual STDMETHODIMP _SetIconEx(LPCWSTR pszIconPath,int iIconIndex, BOOL fChangeNotify) = 0;
    virtual STDMETHODIMP _SetDefaultIconEx(BOOL fChangeNotify) = 0;

private:
    long _cRef;
};

class CFileFolderIconManager : public CFSIconManager
{
public:
    friend HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    
    // ICustomIconManager
    STDMETHODIMP GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex);
protected:
    STDMETHODIMP _SetIconEx(LPCWSTR pszIconPath,int iIconIndex, BOOL fChangeNotify);
    STDMETHODIMP _SetDefaultIconEx(BOOL fChangeNotify);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filetype.cpp ===
#include "shellprv.h"

#include "filetype.h"
#include "ftprop.h"
#include "ids.h"

HRESULT CreateFileTypePage(HPROPSHEETPAGE *phpsp)
{
    *phpsp = NULL;

    HRESULT hr;
    CFTPropDlg* pPropDlg = new CFTPropDlg();            
    if (pPropDlg)
    {
        PROPSHEETPAGE psp;

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
        psp.hInstance   = g_hinst;
        psp.pfnCallback = CFTDlg::BaseDlgPropSheetCallback;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_FILETYPEOPTIONS);
        psp.pfnDlgProc  = CFTDlg::BaseDlgWndProc;
        psp.lParam = (LPARAM)pPropDlg;

        *phpsp = CreatePropertySheetPage(&psp);
        
        if (*phpsp)
        {
            pPropDlg->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pPropDlg->Release();            
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

class CFileTypes : public IShellPropSheetExt
{
public:
    CFileTypes() : _cRef(1) {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc, LPARAM lParam);

private:    
    LONG _cRef;
};


STDMETHODIMP CFileTypes::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFileTypes, IShellPropSheetExt),          // IID_IShellPropSheetExt
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileTypes::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileTypes::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IShellPropSheetExt::AddPages
STDMETHODIMP CFileTypes::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hpsp;
    
    // Make sure the FileIconTable is init properly.  If brought in
    // by inetcpl we need to set this true...
    FileIconInit(TRUE);
    
    // We need to run the unicode version on NT, to avoid all bugs
    // that occur with the ANSI version (due to unicode-to-ansi 
    // conversions of file names).
    
    HRESULT hr = CreateFileTypePage(&hpsp);
    if (SUCCEEDED(hr) && !pfnAddPage(hpsp, lParam))
    {
        DestroyPropertySheetPage(hpsp);
        hr = E_FAIL;
    }
    
    return hr;
}

// IShellPropSheetExt::ReplacePage
STDMETHODIMP CFileTypes::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;

    if (EXPPS_FILETYPES == uPageID)
    {
        HPROPSHEETPAGE hpsp;
        
        // We need to run the unicode version on NT, to avoid all bugs
        // that occur with the ANSI version (due to unicode-to-ansi 
        // conversions of file names).
        
        hr = CreateFileTypePage(&hpsp);
        if (SUCCEEDED(hr) && !pfnReplaceWith(hpsp, lParam))
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}

STDAPI CFileTypes_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;   
    CFileTypes * pft = new CFileTypes;
    if (pft)
    {
        hr = pft->QueryInterface(riid, ppv);
        pft->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\filtgrep.h ===
//  10/12/99    scotthan    created

#ifndef __FILTGREP_H__
#define __FILTGREP_H__

#if WINNT

#ifndef _USE_FILTERGREP_
#define _USE_FILTERGREP_
#endif//_USE_FILTERGREP_

#include <filter.h> // STAT_CHUNK

//  CFilterGrep::Initialize() dwFlags values:
#define FGIF_CASESENSITIVE      0x00000001  // grep in case-sensitive manner
#define FGIF_GREPFILENAME       0x00000002  // grep filename
#define FGIF_GREPCONTENT        0x00000004  // grep content
#define FGIF_GREPPROPERTIES     0x00000008  // grep properties
#define FGIF_BLANKETGREP        (FGIF_GREPCONTENT|FGIF_GREPPROPERTIES)

#ifdef __cplusplus

class CGrepTokens;

class CFilterGrep  // filtergrep state engine
{
public:
    //  Methods
    STDMETHODIMP Initialize(UINT nCodePage, LPCWSTR pszMatch, LPCWSTR pszExclude, DWORD dwFlags);
    STDMETHODIMP Grep(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszName);
    STDMETHODIMP Reset();

    //  Properties
    STDMETHODIMP GetCodePage( UINT* pnCodePage ) const;
    STDMETHODIMP GetMatchTokens( OUT LPWSTR pszMatch, UINT cchMatch ) const;
    STDMETHODIMP GetExcludeTokens( OUT LPWSTR pszMatch, UINT cchMatch ) const;
    STDMETHODIMP GetFlags( DWORD* pdwFlags ) const;

private:
    //  Helpers
    STDMETHODIMP _GetThreadGrepBuffer( DWORD dwThreadID, ULONG cchNeed, LPWSTR* ppszBuf );
    STDMETHODIMP _FreeThreadGrepBuffer( DWORD dwThreadID );
    STDMETHODIMP_(void)     _ClearGrepBuffers();

    STDMETHODIMP _GrepText( IFilter* pFilter, STAT_CHUNK* pstat, DWORD dwThreadID );
    STDMETHODIMP _GrepValue( IFilter* pFilter, STAT_CHUNK* pstat );
    
    STDMETHODIMP _GrepProperties(IPropertySetStorage *pss);
    STDMETHODIMP _GrepPropStg(IPropertyStorage* pstg, ULONG cspec, PROPSPEC rgspec[]);
    STDMETHODIMP _GrepEnumPropStg(IPropertyStorage* pstg);
    STDMETHODIMP_(BOOL) _IsRestrictedFileType(LPCWSTR pwszFile);

    void         _EnterCritical()   { EnterCriticalSection( &_critsec ); }
    void         _LeaveCritical()   { LeaveCriticalSection( &_critsec ); }

    //  Data
    HDPA             _hdpaGrepBuffers;
    CRITICAL_SECTION _critsec;
    CGrepTokens*     _pTokens;
    DWORD            _dwFlags;
    LPWSTR           _pwszContentRestricted,
                     _pwszPropertiesRestricted;

public:
    //  Ctor, Dtor
    CFilterGrep(); 
    ~CFilterGrep();
};

#endif //__cplusplus

#define FACILITY_FILTERGREP         77 // arbitrary
#define MAKE_FILTGREP_ERROR(sc)     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_FILTERGREP,sc)
#define MAKE_FILTGREP_WARNING(sc)   MAKE_HRESULT(SEVERITY_SUCCESS,FACILITY_FILTERGREP,sc)

#define FG_E_NOFILTER               MAKE_FILTGREP_ERROR(0x0001) 


#endif WINNT

#endif __FILTGREP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findband.cpp ===
// findband.cpp : Implementation of CFileSearchBand
#include "shellprv.h"
#include "findband.h"
#include "findfilter.h"
#include <ciodm.h>      // AdminIndexServer custom interface

#define  CGID_FileSearchBand      CLSID_FileSearchBand

extern int IsVK_TABCycler(MSG *pMsg);


enum {  // toolbar image list indices:
    iFSTBID_NEW,
    iFSTBID_HELP,
};
#define  MAKE_FSTBID(ilIndex)    (100 /*arbitrary*/ + (ilIndex))

// toolbar button IDs
#define  FSTBID_NEW        MAKE_FSTBID(iFSTBID_NEW)
#define  FSTBID_HELP       MAKE_FSTBID(iFSTBID_HELP)

static const TBBUTTON _rgtb[] =
{
    {  iFSTBID_NEW,  FSTBID_NEW,  TBSTATE_ENABLED,  BTNS_AUTOSIZE | BTNS_SHOWTEXT,{0, 0}, 0, 0},
    {  -1,          0,            TBSTATE_ENABLED,  BTNS_SEP,                     {0, 0}, 0, 0},
    {  iFSTBID_HELP, FSTBID_HELP, TBSTATE_ENABLED,  BTNS_AUTOSIZE,                {0, 0}, 0, 1},
};


inline BOOL _IsEditWindowClass(HWND hwndTest)
{
    return IsWindowClass(hwndTest, TEXT("Edit"));
}

inline BOOL _IsComboWindowClass(HWND hwndTest)
{
    #define COMBO_CLASS  TEXT("ComboBox")
    return _IsEditWindowClass(hwndTest) ?
                IsWindowClass(GetParent(hwndTest), COMBO_CLASS) :
                IsWindowClass(hwndTest, COMBO_CLASS);
}


// CFileSearchBand impl



CWndClassInfo& CFileSearchBand::GetWndClassInfo()
{
    static CWndClassInfo wc =   { 
        { sizeof(WNDCLASSEX), CS_SAVEBITS, StartWindowProc, 
          0, 0, 0, 0, 0, 0, 0, 
          FILESEARCHCTL_CLASS, 0 }, 
          NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
    };
    return wc;
}

CFileSearchBand::CFileSearchBand()  
    :   _dlgFSearch(this),
        _dlgCSearch(this),
#ifdef __PSEARCH_BANDDLG__
        _dlgPSearch(this),
#endif __PSEARCH_BANDDLG__
        _fValid(TRUE),
        _dwBandID(-1),
        _dwBandViewMode(DBIF_VIEWMODE_VERTICAL)
{
    // Verify that it initialized correctly:
    ASSERT(_pBandDlg == NULL);
    ASSERT(_psb == NULL);
    ASSERT(_guidSearch == GUID_NULL);
    ASSERT(_fDirty == FALSE);
    ASSERT(_fDeskBand == FALSE);
    ASSERT(_punkSite == NULL);
    ASSERT(_bSendFinishedDisplaying == FALSE);
    

    m_bWindowOnly = TRUE;

    ZeroMemory(&_siHorz, sizeof(_siHorz));
    ZeroMemory(&_siVert, sizeof(_siVert));
    _siHorz.cbSize = _siVert.cbSize = sizeof(SCROLLINFO);
    _sizeMin.cx = _sizeMin.cy = 0;
    _sizeMax.cx = _sizeMax.cy = 32000; // arbitrarily large.
}

CFileSearchBand::~CFileSearchBand()
{
    ImageList_Destroy(_hilDefault);
    ImageList_Destroy(_hilHot);
}


HWND CFileSearchBand::Create(
    HWND hWndParent, 
    RECT& rcPos, 
    LPCTSTR szWindowName, 
    DWORD dwStyle, 
    DWORD dwExStyle, 
    UINT nID)
{
    INITCOMMONCONTROLSEX icc;
    TCHAR       szCaption[128];

    icc.dwSize = sizeof(icc);
    icc.dwICC =  ICC_DATE_CLASSES|ICC_UPDOWN_CLASS|ICC_USEREX_CLASSES|ICC_ANIMATE_CLASS;

    EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_CAPTION, szCaption, ARRAYSIZE(szCaption)));

    InitCommonControlsEx(&icc);

    dwExStyle |= WS_EX_CONTROLPARENT;
    dwStyle |= WS_CLIPCHILDREN;

    return CWindowImpl<CFileSearchBand>::Create(hWndParent, rcPos, szCaption,
                                                 dwStyle, dwExStyle, nID);
}


LRESULT CFileSearchBand::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (FAILED(ShowBandDialog(SRCID_SFileSearch)))
        return -1;
    return 0;
}


CBandDlg* CFileSearchBand::GetBandDialog(REFGUID guidSearch)
{
    if (IsEqualGUID(guidSearch, SRCID_SFileSearch))
    {
        return &_dlgFSearch;
    }
#ifdef __PSEARCH_BANDDLG__
    else if (IsEqualGUID(guidSearch, SRCID_SFindPrinter))
    {
        return &_dlgPSearch;
    }
#endif __PSEARCH_BANDDLG__
    else if (IsEqualGUID(guidSearch, SRCID_SFindComputer))
    {
        return &_dlgCSearch;
    }

    return NULL;
}


//  IFileSearchBand::SetSearchParameters()
STDMETHODIMP CFileSearchBand::SetSearchParameters(
    IN BSTR* pbstrSearchID,
    IN VARIANT_BOOL bNavToResults, 
    IN OPTIONAL VARIANT *pvarScope, 
    IN OPTIONAL VARIANT *pvarQueryFile)
{
    USES_CONVERSION;
    HRESULT hr;
    
    GUID guidSearch;
    if (SUCCEEDED(SHCLSIDFromString(W2T(*pbstrSearchID), &guidSearch)))
    {
        hr = ShowBandDialog(guidSearch, bNavToResults, TRUE);
        if (SUCCEEDED(hr))
        {
            CBandDlg* pBandDlg = GetBandDialog(guidSearch);
            ASSERT(pBandDlg);

            if (pvarScope && pvarScope->vt != VT_EMPTY)
                pBandDlg->SetScope(pvarScope, TRUE);

            if (pvarQueryFile && pvarQueryFile->vt != VT_EMPTY)
                pBandDlg->SetQueryFile(pvarQueryFile);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CFileSearchBand::ShowBandDialog(
    REFGUID guidSearch, 
    BOOL bNavigateToResults,
    BOOL bDefaultFocusCtl)
{
    CBandDlg  *pDlgNew = NULL, 
              *pDlgOld = _pBandDlg;
    GUID      guidOld  = _guidSearch;
    BOOL      bNewWindow = FALSE;

    if (NULL == (pDlgNew = GetBandDialog(guidSearch)))
        return E_INVALIDARG;

    _pBandDlg   = pDlgNew;
    _guidSearch = guidSearch;
    
    //  If the dialog window has not been created, do so now.
    if (!::IsWindow(pDlgNew->Hwnd()))
    {
        if (NULL == pDlgNew->Create(*this))
        {
            _pBandDlg = pDlgOld;
            _guidSearch = guidOld;
            return E_FAIL;
        }
        bNewWindow = TRUE;
    }

    if (pDlgNew != pDlgOld)
    {
        //  If we have an active dialog, hide it
        if (pDlgOld && ::IsWindow(pDlgOld->Hwnd()))
        {
            ::ShowWindow(pDlgOld->Hwnd(), SW_HIDE);
            pDlgOld->OnBandDialogShow(FALSE);
        }
        
        bNewWindow = TRUE;
    }

    if (bNewWindow)
    {
        //  Show the new dialog window
        UpdateLayout(BLF_ALL);
        _pBandDlg->OnBandDialogShow(TRUE);
        ::ShowWindow(_pBandDlg->Hwnd(), SW_SHOW);
        ::UpdateWindow(_pBandDlg->Hwnd());

        if (bDefaultFocusCtl)
            _pBandDlg->SetDefaultFocus();
    }

    if (bNavigateToResults)
    {
        //  Navigate to results shell folder.
        IWebBrowser2* pwb2;
        HRESULT hr = IUnknown_QueryService(GetTopLevelBrowser(), SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pwb2));
        if (SUCCEEDED(hr))
        {
            _pBandDlg->NavigateToResults(pwb2);
            pwb2->Release();
        }
    }

    return S_OK;
}

void CFileSearchBand::AddButtons(BOOL fAdd)
{
    if (_fDeskBand)
    {
        ASSERT(BandSite());
        IExplorerToolbar* piet;
        if (SUCCEEDED(BandSite()->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            if (fAdd)
            {
                HRESULT hr = piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CGID_FileSearchBand, 0);
                if (hr == S_OK)
                {
                    if (!_fStrings)
                    {
                        piet->AddString(&CGID_SearchBand, HINST_THISDLL, IDS_FSEARCH_TBLABELS, &_cbOffset);
                        _fStrings = TRUE;
                    }

                    if (LoadImageLists())
                        piet->SetImageList(&CGID_FileSearchBand, _hilDefault, _hilHot, NULL);

                    TBBUTTON rgtb[ARRAYSIZE(_rgtb)];
                    memcpy(rgtb, _rgtb, sizeof(_rgtb));
                    for (int i = 0; i < ARRAYSIZE(rgtb); i++)
                        rgtb[i].iString += _cbOffset;

                    piet->AddButtons(&CGID_FileSearchBand, ARRAYSIZE(rgtb), rgtb);
                }
            }
            else
                piet->SetCommandTarget(NULL, NULL, 0);

            piet->Release();
        }
    }
}


BOOL CFileSearchBand::LoadImageLists()
{
    if (_hilDefault == NULL)
    {
        _hilDefault = ImageList_LoadImage(HINST_THISDLL, 
                                            MAKEINTRESOURCE(IDB_FSEARCHTB_DEFAULT), 
                                            18, 0, CLR_DEFAULT, IMAGE_BITMAP, 
                                            LR_CREATEDIBSECTION);
    }

    if (_hilHot == NULL)
    {
        _hilHot = ImageList_LoadImage(HINST_THISDLL, 
                                        MAKEINTRESOURCE(IDB_FSEARCHTB_HOT), 
                                        18, 0, CLR_DEFAULT, IMAGE_BITMAP, 
                                        LR_CREATEDIBSECTION);
    }
    return _hilDefault != NULL && _hilHot != NULL;
}


STDMETHODIMP CFileSearchBand::get_Scope(OUT VARIANT *pvarScope)
{
    if (BandDlg())
        return _pBandDlg->GetScope(pvarScope);

    VariantInit(pvarScope);
    return E_FAIL;
}


STDMETHODIMP CFileSearchBand::get_QueryFile(OUT VARIANT *pvarFile)
{
    if (BandDlg())
        return _pBandDlg->GetQueryFile(pvarFile);

    VariantInit(pvarFile);
    return E_FAIL;
}


STDMETHODIMP CFileSearchBand::get_SearchID(OUT BSTR* pbstrSearchID)
{
    if (!pbstrSearchID)
        return E_POINTER;

    WCHAR wszGuid[GUIDSTR_MAX+1];

    SHStringFromGUIDW(_guidSearch, wszGuid, ARRAYSIZE(wszGuid));
    *pbstrSearchID = SysAllocString(wszGuid);

    return IsEqualGUID(GUID_NULL, _guidSearch) ? S_FALSE : S_OK;
}


CBandDlg* CFileSearchBand::BandDlg()
{
    return _pBandDlg;
}


HRESULT CFileSearchBand::SetFocus()
{
    HRESULT hr = AutoActivate();
    if (SUCCEEDED(hr))
    {
        if (!IsChild(GetFocus()))
            ::SetFocus(BandDlg()->Hwnd());
    }
    return hr;
}


LRESULT CFileSearchBand::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    LRESULT lRet = CWindowImpl<CFileSearchBand>::DefWindowProc(uMsg, wParam, lParam);
    AutoActivate();
    return lRet;
}


LRESULT CFileSearchBand::OnWinIniChange(UINT, WPARAM, LPARAM, BOOL&)
{
    _metrics.OnWinIniChange(BandDlg()->Hwnd());
    BandDlg()->OnWinIniChange();
    UpdateLayout();
    return 0;
}

HRESULT CFileSearchBand::AutoActivate()
{
    HRESULT hr = S_OK;

    if (!::IsWindow(m_hWnd))
        return hr;

    if (_fDeskBand)
    {
        if (_punkSite)
        {
            IInputObjectSite* pios;
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IInputObjectSite, &pios));
            if (SUCCEEDED(hr))
            {
                hr = pios->OnFocusChangeIS(SAFECAST(this, IInputObject*), TRUE);
                pios->Release();
            }
        }
    }
    else if (!m_bUIActive)
    {
        RECT rc;
        ::GetWindowRect(m_hWnd, &rc);
        ::MapWindowPoints(HWND_DESKTOP, GetParent(), (LPPOINT)&rc, 2);
        hr = DoVerb(OLEIVERB_UIACTIVATE, NULL, NULL, 0, GetParent(), &rc);
    }

    return hr;
}


void  CFileSearchBand::SetDirty(BOOL bDirty)  
{ 
    _fDirty = bDirty; 
    _dlgFSearch.UpdateSearchCmdStateUI(); 
}


LRESULT CFileSearchBand::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);
    LayoutControls(pts.x, pts.y, BLF_ALL);
    return 0;
}


LRESULT CFileSearchBand::OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&)  
{
    return TRUE; 
}


HRESULT CFileSearchBand::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
    return IOleInPlaceObjectWindowlessImpl<class CFileSearchBand>::SetObjectRects(prcPos, prcClip);  
}


STDMETHODIMP CFileSearchBand::PrivateQI(REFIID iid, void **ppvObject) 
{ 
    return _InternalQueryInterface(iid, ppvObject);
}


STDMETHODIMP CFileSearchBand::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent) 
{
    //  Patch in shell32 logic.
    return CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>::
        DoVerbUIActivate(prcPosRect, hwndParent, m_hWnd);
}


void CFileSearchBand::UpdateLayout(ULONG fLayoutFlags)
{
    RECT rc;
    GetClientRect(&rc);
    LayoutControls(RECTWIDTH(rc), RECTHEIGHT(rc), fLayoutFlags);
}


void CFileSearchBand::LayoutControls(int cx, int cy, ULONG fLayoutFlags)
{
    if (/*NULL == BandDlg() ||*/ !::IsWindow(BandDlg()->Hwnd()))
        return;

    SIZE sizeMin;
    BandDlg()->GetMinSize(m_hWnd, &sizeMin); // size of dialog

    if (fLayoutFlags & BLF_CALCSCROLL)
    {
        //  Stash pos before recalculating
        POINT pos;
        pos.x = _siHorz.nPos;
        pos.y = _siVert.nPos;

        _siHorz.fMask = _siVert.fMask = (SIF_RANGE|SIF_PAGE);

        _siHorz.nPage = cx; // thumb width
        _siVert.nPage = cy; // thumb height

        SIZE sizeDelta; // difference between what we have to show and what is shown.
        sizeDelta.cx = sizeMin.cx - _siHorz.nPage;
        sizeDelta.cy = sizeMin.cy - _siVert.nPage;

        //  establish maximum scroll positions
        _siHorz.nMax = sizeDelta.cx > 0 ? sizeMin.cx - 1 : 0;
        _siVert.nMax = sizeDelta.cy > 0 ? sizeMin.cy - 1 : 0;

        //  establish horizontal scroll pos
        if (sizeDelta.cx <= 0)   
            _siHorz.nPos = 0;  // scroll to extreme left if we're removing scroll bar
        else if (sizeDelta.cx < _siHorz.nPos) 
            _siHorz.nPos = sizeDelta.cx; // remove right-hand vacancy

        if (_siHorz.nPos != pos.x)
            _siHorz.fMask |= SIF_POS;

        //  establish vertical scroll pos
        if (sizeDelta.cy <= 0)  
            _siVert.nPos = 0; // scroll to top if we're removing scroll bar
        else if (sizeDelta.cy < _siVert.nPos) 
            _siVert.nPos = sizeDelta.cy; // remove lower-portion vacancy

        if (_siVert.nPos != pos.y)
            _siVert.fMask |= SIF_POS; 

        //  Note: can't call SetScrollInfo here, as it may generate
        //  a WM_SIZE and recurse back to this function before we had a 
        //  chance to SetWindowPos() our subdlg.  So defer it until after 
        //  we've done this.
    }

    DWORD fSwp = SWP_NOZORDER | SWP_NOACTIVATE;

    if (0 == (fLayoutFlags & BLF_RESIZECHILDREN))
        fSwp |= SWP_NOSIZE;

    if (0 == (fLayoutFlags & BLF_SCROLLWINDOW))
        fSwp |= SWP_NOMOVE;

     //  Move or size the main subdialog as requested...
    if (0 == (fSwp & SWP_NOMOVE) || 0 == (fSwp & SWP_NOSIZE))
        ::SetWindowPos(BandDlg()->Hwnd(), NULL, -_siHorz.nPos, -_siVert.nPos, 
                        max(cx, sizeMin.cx), max(cy, sizeMin.cy), fSwp);

    //  Update scroll parameters
    if (fLayoutFlags & BLF_CALCSCROLL)
    {
        SetScrollInfo(SB_HORZ, &_siHorz, TRUE);
        SetScrollInfo(SB_VERT, &_siVert, TRUE);
    }
}


void CFileSearchBand::Scroll(int nBar, UINT uSBCode, int nNewPos /*optional*/)
{
    int         nDeltaMax;
    SCROLLINFO  *psbi;
    const LONG  nLine = 8;

    psbi = (SB_HORZ == nBar) ? &_siHorz : &_siVert;
    nDeltaMax = (psbi->nMax - psbi->nPage) + 1;
    
    switch (uSBCode)
    {
        case SB_LEFT:
            psbi->nPos--;
            break;
        case SB_RIGHT:
            psbi->nPos++;
            break;
        case SB_LINELEFT:
            psbi->nPos = max(psbi->nPos - nLine, 0);
            break;
        case SB_LINERIGHT:
            psbi->nPos = min(psbi->nPos + nLine, nDeltaMax);
            break;
        case SB_PAGELEFT:
            psbi->nPos = max(psbi->nPos - (int)psbi->nPage, 0);
            break;
        case SB_PAGERIGHT:
            psbi->nPos = min(psbi->nPos + (int)psbi->nPage, nDeltaMax);
            break;
        case SB_THUMBTRACK:
            psbi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psbi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psbi->fMask = SIF_POS;
    SetScrollInfo(nBar, psbi, TRUE);
    UpdateLayout(BLF_ALL &~ BLF_CALCSCROLL /*no need to recalc scroll state data*/);
}


//  WM_HSCROLL/WM_VSCROLL handler
LRESULT CFileSearchBand::OnScroll(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Scroll((WM_HSCROLL == nMsg) ? SB_HORZ : SB_VERT, 
            LOWORD(wParam), HIWORD(wParam));
    return 0;
}


void CFileSearchBand::EnsureVisible(LPCRECT lprc /* in screen coords */)
{
    ASSERT(lprc);
    RECT rc = *lprc;
    RECT rcClient;
    RECT vertexDeltas;
    SIZE scrollDelta;
    
    ::MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT)&rc, POINTSPERRECT);
    GetClientRect(&rcClient);

    BOOL fTaller = RECTHEIGHT(rc) > RECTHEIGHT(rcClient);
    BOOL fFatter = RECTWIDTH(rc) > RECTWIDTH(rcClient);

    //  Store deltas at each vertex
    SetRect(&vertexDeltas, 
             rc.left   - rcClient.left,
             rc.top    - rcClient.top,
             rc.right  - rcClient.right,
             rc.bottom - rcClient.bottom);

    //  Compute scroll deltas
    scrollDelta.cx = (vertexDeltas.left < 0) ? vertexDeltas.left :
                     (vertexDeltas.right > 0 && !fFatter) ? vertexDeltas.right :
                     0;

    scrollDelta.cy = (vertexDeltas.top < 0) ? vertexDeltas.top :
                     (vertexDeltas.bottom > 0 && !fTaller) ? vertexDeltas.bottom :
                     0;
    
    //  Scroll into view as necessary.
    if (scrollDelta.cx)
    {
        _siHorz.fMask = SIF_POS;
        _siHorz.nPos  += scrollDelta.cx;
        SetScrollInfo(SB_HORZ, &_siHorz, TRUE);
    }

    if (scrollDelta.cy)
    {
        _siVert.fMask = SIF_POS;
        _siVert.nPos  += scrollDelta.cy;
        SetScrollInfo(SB_VERT, &_siVert, TRUE);
    }

    UpdateLayout(BLF_ALL &~ BLF_CALCSCROLL);
}


HRESULT CFileSearchBand::TranslateAccelerator(MSG *pmsg)
{
    return CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
            ::TranslateAcceleratorPriv(this, pmsg, m_spClientSite);
}


HRESULT CFileSearchBand::TranslateAcceleratorInternal(MSG *pmsg, IOleClientSite * pocs)
{
    CBandDlg* pdlg = BandDlg();
    ASSERT(pdlg);

    if (::IsChild(pdlg->Hwnd(), pmsg->hwnd))
    {
        //  Permit tabbing out of pane:
        int nDir;
        if ((nDir = IsVK_TABCycler(pmsg)) != 0)
        {
            if (nDir > 0 && (pmsg->hwnd == pdlg->GetLastTabItem()))
                return S_FALSE;
            if (nDir < 0 && (pmsg->hwnd == pdlg->GetFirstTabItem()))
                return S_FALSE;
        }

        //  try base class handler
        if (S_OK == pdlg->TranslateAccelerator(pmsg))
            return S_OK;
    }
    else if (IsDialogMessage(pmsg))
        return S_OK;

    return IOleInPlaceActiveObjectImpl<CFileSearchBand>::TranslateAccelerator(pmsg);
}


//  Determines whether the the specified message is keyboard input intended
//  to scroll the pane.    If the pane is scrolled as a result of the
//  message, the function returns TRUE; otherwise it returns FALSE.
BOOL CFileSearchBand::IsKeyboardScroll(MSG* pmsg)
{
    if (pmsg->message == WM_KEYDOWN && 
        (GetKeyState(VK_CONTROL) & 0x8000) != 0 &&
        pmsg->wParam != VK_CONTROL)
    {
        int     nBar    = SB_VERT;
        UINT    uSBCode;
        int     nNewPos = 0;
        BOOL    bEditCtl = _IsEditWindowClass(pmsg->hwnd);
        BOOL    bScroll = TRUE;

        //  Some of the following CTRL-key combinations are
        //  not valid pane scroll keys if the target child window is an
        //  edit control.

        switch (pmsg->wParam)
        {
            case VK_UP:
                uSBCode = SB_LINELEFT;
                break;
            case VK_DOWN:
                uSBCode = SB_LINERIGHT;
                break;
            case VK_PRIOR:
                uSBCode = SB_PAGELEFT;
                break;
            case VK_NEXT:
                uSBCode = SB_PAGERIGHT;
                break;
            case VK_END:
                uSBCode = SB_THUMBPOSITION;
                nNewPos = _siVert.nMax - _siVert.nPage;
                break;
            case VK_HOME:
                uSBCode = SB_THUMBPOSITION;
                nNewPos = 0;
                break;
            case VK_LEFT:
                bScroll = !bEditCtl;
                nBar    = SB_HORZ;
                uSBCode = SB_LINELEFT;
                break;
            case VK_RIGHT:
                bScroll = !bEditCtl;
                nBar = SB_HORZ;
                uSBCode = SB_LINERIGHT;
                break;

            default:
                return FALSE;
        }

        //  scroll only if we have to; reduce flicker.
        if (bScroll && ((SB_VERT == nBar && _siVert.nMax != 0) ||
                        (SB_HORZ == nBar && _siHorz.nMax != 0)))
        {
            Scroll(nBar, uSBCode, nNewPos);
            return TRUE; 
        }
    }
    return FALSE;
}


//  Determines whether the indicated key should be passed to the top
//  level browser frame.
BOOL CFileSearchBand::IsBrowserAccelerator(MSG *pmsg)
{
    if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
    {
        BOOL bCombobox     = _IsComboWindowClass(pmsg->hwnd);
        BOOL bComboDropped = (BOOL)(bCombobox ? ::SendMessage(pmsg->hwnd, CB_GETDROPPEDSTATE, 0, 0) : FALSE);
        BOOL bEditCtl      = _IsEditWindowClass(pmsg->hwnd);

        //  Keys that we treat WITHOUT regard to state of CTRL key:
        if (VK_F4 == pmsg->wParam && bCombobox) // should toggle dropped/close-up of combo.
            return FALSE;

        //  Keys that we treat WITH regard to state of CTRL key:
        if ((GetKeyState(VK_CONTROL) & 0x8000) != 0)
        {
            //  Edit cut copy paste?
            if (bEditCtl)
            {
                switch (pmsg->wParam)  {
                    case 'C': case 'X': case 'V': case 'Z':
                        return FALSE;
                }
            }
            return TRUE; // all other CTRL-key combinations are browser keys.
        }
        else
        {
            switch (pmsg->wParam)
            {
            //  browser accelerators that may be shunted by edit controls.
            case VK_BACK:
                return !bEditCtl;

            if (VK_ESCAPE == pmsg->wParam)  // should close up the combo.
                return bComboDropped;

            default:
                if (pmsg->wParam >= VK_F1 && pmsg->wParam <= VK_F24)
                    return TRUE;
            }
        }
    }
    return FALSE;
}


HRESULT CFileSearchBand::IsDlgMessage(HWND hwnd, MSG *pmsg)
{
    //  handle tab cycling (Let browser handle F6)
    if (!IsVK_TABCycler(pmsg) || pmsg->wParam == VK_F6)
    {
        if (IsBrowserAccelerator(pmsg))
        {
            IShellBrowser* psb = GetTopLevelBrowser();
            return (psb && S_OK == psb->TranslateAcceleratorSB(pmsg, 0)) ?
                S_OK : S_FALSE;
        }
    }
    
    //  send through dialog manager
    if (::IsDialogMessage((hwnd != NULL ? hwnd : m_hWnd), pmsg))
        return S_OK;
        
    //  not handled.
    return S_FALSE ;
}

IShellBrowser* CFileSearchBand::GetTopLevelBrowser()
{
    if (NULL == _psb)
        IUnknown_QueryService(BandSite(), SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &_psb));

    return _psb;
}

void CFileSearchBand::FinalRelease()
{
    //  ATL 2.1 has a bug in class unregistration.  Here's
    //  the work around:
    UnregisterClass(GetWndClassInfo().m_wc.lpszClassName, 
                     GetWndClassInfo().m_wc.hInstance);
    GetWndClassInfo().m_atom = 0;

    SetSite(NULL);
}

//-----------------------------//
//  IDeskBand : IDockingWindow


STDMETHODIMP CFileSearchBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
    _dwBandID = dwBandID;
    _dwBandViewMode = dwViewMode;

    if (pdbi->dwMask & DBIM_MINSIZE)
    {
        pdbi->ptMinSize.x = _sizeMin.cx;
        pdbi->ptMinSize.y = _sizeMin.cy;
    }

    if (pdbi->dwMask & DBIM_MAXSIZE)
    {
        pdbi->ptMaxSize.x = _sizeMax.cx;
        pdbi->ptMaxSize.y = _sizeMax.cy;
    }

    if (pdbi->dwMask & DBIM_INTEGRAL)
    {
        pdbi->ptIntegral.x = 
        pdbi->ptIntegral.y = 1;
    }

    if (pdbi->dwMask & DBIM_ACTUAL)
    {
        pdbi->ptActual.x =
        pdbi->ptActual.y = 0;
    }

    if (pdbi->dwMask & DBIM_TITLE)
    {
        TCHAR szTitle[256];
        EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_BANDCAPTION, 
                           szTitle, ARRAYSIZE(szTitle)));
        SHTCharToUnicode(szTitle, pdbi->wszTitle, ARRAYSIZE(szTitle));
    }

    if (pdbi->dwMask & DBIM_MODEFLAGS)
    {
        pdbi->dwModeFlags = DBIMF_NORMAL|DBIMF_VARIABLEHEIGHT|DBIMF_DEBOSSED|DBIMF_BKCOLOR;
    }

    if (pdbi->dwMask & DBIM_BKCOLOR)
    {
        pdbi->crBkgnd = GetSysColor(COLOR_3DFACE);
    }

    return S_OK;
}


BOOL CFileSearchBand::IsBandDebut()
{
    HKEY hkey;
    BOOL bRet = TRUE;
    if (NULL == (hkey = GetBandRegKey(FALSE)))
        return bRet;

    BYTE rgData[128];
    DWORD cchData = sizeof(rgData);
    DWORD dwType;

    //  Hack alert:  we should maintain our own initialization reg value rather than using IE's
    //  barsize entry.
    DWORD dwRet = RegQueryValueEx(hkey, TEXT("BarSize"), NULL, &dwType, rgData, &cchData);
   
    if ((ERROR_SUCCESS == dwRet || ERROR_MORE_DATA == dwRet) && cchData > 0)
        bRet = FALSE;
        
    RegCloseKey(hkey);
    return bRet;    
}


//  Hack alert:  we should maintain our own reg key rather than using IE's
#define FSB_REGKEYFMT TEXT("Software\\Microsoft\\Internet Explorer\\Explorer Bars\\%s")

int CFileSearchBand::MakeBandKey(OUT LPTSTR pszKey, IN UINT cchKey)
{
    TCHAR   szClsid[GUIDSTR_MAX+1];
    SHStringFromGUID(CLSID_FileSearchBand, szClsid, ARRAYSIZE(szClsid));
    return wnsprintf(pszKey, cchKey, FSB_REGKEYFMT, szClsid);
}


int CFileSearchBand::MakeBandSubKey(IN LPCTSTR pszSubKey, OUT LPTSTR pszKey, IN UINT cchKey)
{
    TCHAR szBandKey[MAX_PATH];
    int cchRet = MakeBandKey(szBandKey, ARRAYSIZE(szBandKey));

    if (cchRet > 0)
    {
        StrCpyN(pszKey, szBandKey, cchKey);
        if (pszSubKey && *pszSubKey && (cchKey - cchRet) > 1)
        {
            StrCat(pszKey, TEXT("\\"));
            cchRet++;
            cchKey -= cchRet;

            StrCpyN(pszKey + cchRet, pszSubKey, cchKey);
            return lstrlen(pszKey);
        }
    }
    return 0;
}


HKEY CFileSearchBand::GetBandRegKey(BOOL bCreateAlways)
{
    HKEY    hkey = NULL;
    TCHAR   szKey[MAX_PATH];

    if (MakeBandKey(szKey, ARRAYSIZE(szKey)) > 0)
    {
        if (bCreateAlways)
        {
            DWORD dwDisp;
            if (ERROR_SUCCESS != 
                RegCreateKeyEx(HKEY_CURRENT_USER, szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS, NULL, &hkey, &dwDisp))
                hkey = NULL;
        }
        else
        {
            if (ERROR_SUCCESS != 
                RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_ALL_ACCESS, &hkey))
                hkey = NULL;
        }
    }

    return hkey;
}


void CFileSearchBand::SetDeskbandWidth(int cx)
{
    SIZE sizeMin = _sizeMin, 
         sizeMax = _sizeMax;
    RECT rc;

    //  Bandsite hack: make sizemin == sizemax equal to
    //  explicitly set band width:
    GetWindowRect(&rc);

    //  note: you shouldn't be setting width if we're not a band.
    ASSERT(DBIF_VIEWMODE_VERTICAL == _dwBandViewMode);

    //  note: height and width are reversed for vertical bands like us.
    _sizeMin.cx = _sizeMax.cx = -1; // ignore height
    _sizeMin.cy = _sizeMax.cy = cx; // assign new width.

    BandInfoChanged(); // force the site to enforce the desired size.

    _sizeMin = sizeMin;
    _sizeMax = sizeMax;

    // restore previous min/max.   If we're to do it right now,
    // we'd be overrided by bandsite, who tries to establish the 
    // infoband width after we're done.
    PostMessage(WMU_BANDINFOUPDATE, 0, 0); 
}


//  WMU_BANDINFOUPDATE handler
LRESULT CFileSearchBand::OnBandInfoUpdate(UINT, WPARAM, LPARAM, BOOL&)
{
    BandInfoChanged();
    return 0;
}


//  Notifies the band site that DESKBANDINFO has changed
HRESULT CFileSearchBand::BandInfoChanged()
{
    ASSERT(_dwBandID != (DWORD)-1);
    VARIANTARG v = {0};
    v.vt = VT_I4;
    v.lVal = _dwBandID;
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, &v, NULL);
}


STDMETHODIMP CFileSearchBand::ShowDW(BOOL fShow)
{
    if (::IsWindow(m_hWnd))
    {
        ShowWindow(fShow ? SW_SHOW : SW_HIDE);
        AddButtons(fShow);
        if (fShow && BandDlg() && ::IsWindow(BandDlg()->Hwnd()))
            BandDlg()->RemoveToolbarTurds(_siVert.nPos);
        
        BandDlg()->OnBandShow(fShow);
    }

    // Since we are now ready to display the band, we will send the
    // message that sub dialogs can begin their delayed initialization
    if (fShow && !_bSendFinishedDisplaying)
    {
        HWND hwndFindFiles = _dlgFSearch.Hwnd();
        if (hwndFindFiles)
        {
            if (::PostMessage(hwndFindFiles, WMU_BANDFINISHEDDISPLAYING, 0, 0))
            {
                _bSendFinishedDisplaying = TRUE;
            }
        }
    }
    return S_OK;
}


STDMETHODIMP CFileSearchBand::CloseDW(DWORD dwReserved)
{
    if (::IsWindow(m_hWnd))
        DestroyWindow();

    return S_OK;
}

STDMETHODIMP CFileSearchBand::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved)
{
    return S_OK;
}

//  IObjectWithSite

STDMETHODIMP CFileSearchBand::SetSite(IUnknown* pSite)
{
    ATOMICRELEASE(_psb);    // free this guy just in case

    AdvertiseBand(pSite ? TRUE : FALSE);

    IUnknown_Set(&_punkSite, pSite);

    if (_punkSite)
    {
        HWND hwndSite;
        if (SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwndSite)))
        {
            RECT rcPos;
            SetRect(&rcPos, 0, 0, 100, 400);
            m_hWnd = Create(hwndSite, rcPos, NULL, 
                             WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_HSCROLL|WS_VSCROLL, 0, 0);
        }
        _fDeskBand = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CFileSearchBand::FindFilesOrFolders(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
    return ShowBandDialog(SRCID_SFileSearch,  
                           bNavigateToResults, bDefaultFocusCtl);
}


STDMETHODIMP CFileSearchBand::FindComputer(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
    return ShowBandDialog(SRCID_SFindComputer,
                           bNavigateToResults, bDefaultFocusCtl);
}


STDMETHODIMP CFileSearchBand::FindPrinter(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
#ifdef __PSEARCH_BANDDLG__
    return ShowBandDialog(SRCID_SFindPrinter,
                           bNavigateToResults, bDefaultFocusCtl);

#else  __PSEARCH_BANDDLG__

    HRESULT hr = E_FAIL;
    ASSERT(BandSite());

    IShellDispatch2* psd2;
    hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                           IID_PPV_ARG(IShellDispatch2, &psd2));
    if (SUCCEEDED(hr))
    {
        hr = psd2->FindPrinter(NULL, NULL, NULL) ;
        psd2->Release();
    }
    return hr ;

#endif __PSEARCH_BANDDLG__
}

STDMETHODIMP CFileSearchBand::FindPeople(BOOL bNavigateToResults, BOOL bDefaultFocusCtl)
{
    IObjectWithSite* pows;
    HRESULT hr = CoCreateInstance(CLSID_SearchAssistantOC, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows));
    if (SUCCEEDED(hr))
    {
        hr = pows->SetSite(BandSite());
        if (SUCCEEDED(hr))
        {
            ISearchAssistantOC* psaoc;
            hr = pows->QueryInterface(IID_PPV_ARG(ISearchAssistantOC, &psaoc));
            if (SUCCEEDED(hr))
            {
                hr = psaoc->FindPeople();
                psaoc->Release();
            }
        }
        pows->Release();
    }
    return hr;
}


STDMETHODIMP CFileSearchBand::FindOnWeb(BOOL bNavigateToResults, BOOL bDefaultFocusCtl)
{
    IObjectWithSite* pows;
    HRESULT hr = CoCreateInstance(CLSID_SearchAssistantOC, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows));
    if (SUCCEEDED(hr))
    {
        hr = pows->SetSite(BandSite());
        if (SUCCEEDED(hr))
        {
            ISearchAssistantOC* psaoc;
            hr = pows->QueryInterface(IID_PPV_ARG(ISearchAssistantOC, &psaoc));
            if (SUCCEEDED(hr))
            {
                hr = psaoc->FindOnWeb();
                psaoc->Release();
            }
        }
        pows->Release();
    }
    return hr;
}

//  Make ourself available to clients of IWebBrowser2 by assigning
//  a VT_UNKNOWN property to the browser.
HRESULT CFileSearchBand::AdvertiseBand(BOOL bAdvertise)
{
    if (!BandSite())
        return E_UNEXPECTED;

    HRESULT hr = E_FAIL;
    IShellBrowser* psb = GetTopLevelBrowser();
    if (psb) 
    {
        IWebBrowser2* pwb;
        hr = IUnknown_QueryService(psb, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pwb));
        if (SUCCEEDED(hr))
        {
            BSTR bstrFileSearchBand;
            hr = BSTRFromCLSID(CLSID_FileSearchBand, &bstrFileSearchBand);
            if (SUCCEEDED(hr))
            {
                if (bAdvertise)
                {
                    IUnknown *punk;
                    hr = QueryInterface(IID_PPV_ARG(IUnknown, &punk));
                    if (SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_UNKNOWN;
                        var.punkVal = punk;
                        hr = pwb->PutProperty(bstrFileSearchBand, var);

                        punk->Release();
                    }
                }
                else
                {
                    VARIANT var;
                    hr = pwb->GetProperty(bstrFileSearchBand, &var);
                    if (SUCCEEDED(hr))
                    {
                        if (VT_UNKNOWN == var.vt)
                        {
                            VARIANT varTmp = {0};
                            hr = pwb->PutProperty(bstrFileSearchBand, varTmp);
                        }
                        VariantClear(&var);
                    }
                }
                SysFreeString(bstrFileSearchBand);
            }
            pwb->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFileSearchBand::GetSite(REFIID riid, void **ppvSite)
{
    *ppvSite = NULL;
    return _punkSite ? _punkSite->QueryInterface(riid, ppvSite) : E_FAIL;
}

//  IInputObject
STDMETHODIMP CFileSearchBand::HasFocusIO()
{
    HWND hwndFocus = GetFocus();
    return (::IsWindow(m_hWnd) && (m_hWnd == hwndFocus || IsChild(hwndFocus))) ?
           S_OK : S_FALSE;
}

STDMETHODIMP CFileSearchBand::TranslateAcceleratorIO(MSG *pmsg)
{
    return TranslateAccelerator(pmsg);
}

STDMETHODIMP CFileSearchBand::UIActivateIO(BOOL fActivate, MSG *pmsg)
{
    if (fActivate)
        AutoActivate();
    
    CBandDlg* pdlg = BandDlg();
    if (pdlg)
    {
        if (fActivate)
        {
            //  Handle tabbing into pane
            int  nDir = IsVK_TABCycler(pmsg);
            HWND hwndTarget = (nDir < 0) ? pdlg->GetLastTabItem() :
                              (nDir > 0) ? pdlg->GetFirstTabItem() :
                                           NULL;
            if (hwndTarget)
                ::SetFocus(hwndTarget);
            else if (!pdlg->RestoreFocus())
                ::SetFocus(pdlg->Hwnd());
        }
        else
        {
            pdlg->RememberFocus(NULL);
        }
    }
    return S_OK;
}

//  IOleCommandTarget
STDMETHODIMP CFileSearchBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup)
    {    
        if (IsEqualGUID(*pguidCmdGroup, CGID_FileSearchBand))
        {
            switch (nCmdID)
            {
            case FSTBID_NEW:
                if (_pBandDlg)
                {
                    _pBandDlg->Clear();
                    _pBandDlg->LayoutControls(); 
                    UpdateLayout(BLF_ALL);
                    SetFocus();
                    _pBandDlg->SetDefaultFocus();

                }
                return S_OK;

            case FSTBID_HELP:
                if (_pBandDlg)
                    _pBandDlg->ShowHelp(NULL);
                return S_OK;
            }
        }
    }
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CFileSearchBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_FileSearchBand))
    {
        //  Infotip text for toolbar buttons:
        if (pCmdText)
        {
            ASSERT(1 == cCmds);
            UINT nIDS = 0;
            pCmdText->cwActual = 0;
            switch (prgCmds[0].cmdID)
            {
                case iFSTBID_NEW:
                case FSTBID_NEW:
                    nIDS = IDS_FSEARCH_NEWINFOTIP;
                    break;
                case iFSTBID_HELP:
                case FSTBID_HELP:
                    nIDS = IDS_FSEARCH_HELPINFOTIP;
                    break;
            }
            if (nIDS)
                pCmdText->cwActual = LoadStringW(HINST_THISDLL, nIDS, pCmdText->rgwz, pCmdText->cwBuf);
                    
            return pCmdText->cwActual > 0 ? S_OK : E_FAIL;
        }
    }
    return OLECMDERR_E_UNKNOWNGROUP;
}


//  IServiceProvider
STDMETHODIMP CFileSearchBand::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

//  IPersistStream
STDMETHODIMP CFileSearchBand::IsDirty(void)
{
    return S_FALSE;
}

STDMETHODIMP CFileSearchBand::Load(IStream *pStm) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSearchBand::Save(IStream *pStm, BOOL fClearDirty) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSearchBand::GetSizeMax(ULARGE_INTEGER *pcbSize) 
{
    return E_NOTIMPL;
}


//  IPersist
STDMETHODIMP CFileSearchBand::GetClassID(CLSID *pClassID) 
{
    *pClassID = CLSID_FileSearchBand;
    return S_OK;
}

// CMetrics impl

CMetrics::CMetrics()
    :   _hbrBkgnd(NULL),
        _hbrBorder(NULL),
        _hfBold(NULL)
{ 
    ZeroMemory(&_ptExpandOrigin, sizeof(_ptExpandOrigin));
    ZeroMemory(&_rcCheckBox, sizeof(_rcCheckBox));
    ZeroMemory(_rghiconCaption, sizeof(_rghiconCaption));
    CreateResources(); 
}


void CMetrics::Init(HWND hwndDlg)
{
    _cyTightMargin = _PixelsForDbu(hwndDlg, 3, FALSE);
    _cyLooseMargin = 2 * _cyTightMargin;
    _cxCtlMargin   = _PixelsForDbu(hwndDlg, 7, TRUE);
}


BOOL CMetrics::CreateResources()
{
    _hbrBkgnd = CreateSolidBrush(BkgndColor());
    _hbrBorder= CreateSolidBrush(BorderColor());
    return _hbrBkgnd != NULL && _hbrBorder != NULL;
}


BOOL CMetrics::GetWindowLogFont(HWND hwnd, OUT LOGFONT* plf)
{
    HFONT hf = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
    
    if (hf)
    {
        if (sizeof(*plf) == GetObject(hf, sizeof(*plf), plf))
            return TRUE;
    }
    return FALSE;
}


HFONT CMetrics::BoldFont(HWND hwndDlg)
{
    if (NULL == _hfBold)
    {
        LOGFONT lf;
        if (GetWindowLogFont(hwndDlg, &lf))
        {
            lf.lfWeight = FW_BOLD;
            SHAdjustLOGFONT(&lf); // locale-specific adjustments
            _hfBold = CreateFontIndirect(&lf);
        }
    }
    return _hfBold;
}


HICON CMetrics::CaptionIcon(UINT nIDIconResource)
{
    for (int i = 0; i < ARRAYSIZE(_icons); i++)
    {
        if (_icons[i] == nIDIconResource)
        {
            if (NULL == _rghiconCaption[i])
            {
                _rghiconCaption[i] = (HICON)LoadImage(
                    HINST_THISDLL, MAKEINTRESOURCE(nIDIconResource), 
                    IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
            }
            return _rghiconCaption[i];
        }
    }
    return NULL;
}


void CMetrics::DestroyResources()
{
    if (_hbrBkgnd)
    {
        DeleteObject(_hbrBkgnd);
        _hbrBkgnd = NULL;
    }

    if (_hbrBorder)
    {
        DeleteObject(_hbrBorder);
        _hbrBorder = NULL;
    }

    if (_hfBold)
    {
        DeleteObject(_hfBold);
        _hfBold = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(_icons); i++)
    {
        if (_rghiconCaption[i])
        {
            DestroyIcon(_rghiconCaption[i]);
            _rghiconCaption[i] = NULL;
        }
    }
}


void CMetrics::OnWinIniChange(HWND hwndDlg)
{
    DestroyResources();

    //  Force resource regen
    CreateResources();
    
    //  Force font regen
    BoldFont(hwndDlg);

    Init(hwndDlg);
}

// returns:
//      S_OK        -> uptodate
//      S_FALSE     -> not up to date
//      FAILED()    -> volume not CIed

STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine)
{
    HRESULT hr = E_FAIL;
    CI_STATE state = {0};
    state.cbStruct = sizeof(state);
    if (SUCCEEDED(CIState(pszCatalog, pszMachine, &state)))
    {
        BOOL fUpToDate = ((0 == state.cDocuments) &&
                          (0 == (state.eState & CI_STATE_SCANNING)) &&
                          (0 == (state.eState & CI_STATE_READING_USNS)) &&
                          (0 == (state.eState & CI_STATE_STARTING)) &&
                          (0 == (state.eState & CI_STATE_RECOVERING)));
        if (fUpToDate)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

// returns:
//      S_OK        -> uptodate
//      S_FALSE     -> not up to date
//      FAILED()    -> volume not CIed

STDAPI PathUptodate(LPCWSTR pszPath)
{
    HRESULT hr = E_FAIL;

    WCHAR wszMachine[32], wszCatalog[MAX_PATH];
    DWORD cchMachine = ARRAYSIZE(wszMachine), cchCatalog = ARRAYSIZE(wszCatalog);

    if (S_OK == LocateCatalogsW(pszPath, 0, wszMachine, &cchMachine, wszCatalog, &cchCatalog))
    {
        hr = CatalogUptodate(wszCatalog, wszMachine);
    }
    return hr;
}

HRESULT LocalDrivesContentUpToDate()
{
    HRESULT hr = S_OK;      // assume yes
    DWORD dwDriveMask = GetLogicalDrives();
    
    for (int i = 0; i < 26; i++)
    {
        if (dwDriveMask & 1)
        {
            if (!IsRemovableDrive(i) && !IsRemoteDrive(i))
            {
                WCHAR wszPath[4];
                PathBuildRoot(wszPath, i);

                if (S_FALSE == PathUptodate(wszPath))
                {
                    hr = S_FALSE;
                    break;
                }
            }
        }
        dwDriveMask >>= 1;
    }
    return hr;
}

HRESULT QueryCIStatus(DWORD *pdwStatus, BOOL *pbConfigAccess)
{
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(pdwStatus);
    *pdwStatus = 0;
    if (pbConfigAccess)
        *pbConfigAccess = FALSE;
    
    SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm)
    {
        SC_HANDLE hService = NULL;
        //  Test permission to muck around with service
        if (pbConfigAccess)
        {
            hService = OpenService(hScm, L"cisvc", 
                SERVICE_START |SERVICE_STOP | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS);
            if (hService)
            {
                *pbConfigAccess = TRUE;
            }
        }
        //  Query service status
        if (NULL == hService)
            hService = OpenService(hScm, L"cisvc", SERVICE_QUERY_STATUS);

        if (hService)
        {
            SERVICE_STATUS status;
            if (!QueryServiceStatus(hService, &status))
                dwErr = GetLastError();
            else
                *pdwStatus = status.dwCurrentState;

            CloseServiceHandle(hService); 
        }
        else
            dwErr = GetLastError();

        CloseServiceHandle(hScm); 
    }
    else
        dwErr = GetLastError();

    return HRESULT_FROM_WIN32(dwErr);
}

STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission)
{
    *pbRunning = *pbIndexed = *pbPermission = FALSE;

    DWORD dwStatus = 0;
    HRESULT hr = QueryCIStatus(&dwStatus, pbPermission);
    if (SUCCEEDED(hr))
    {
        switch (dwStatus)
        {
        case SERVICE_START_PENDING:
        case SERVICE_RUNNING:
        case SERVICE_CONTINUE_PENDING:
            *pbRunning = TRUE;
        }
    }

    if (*pbRunning)
        *pbIndexed = *pbPermission ? (S_OK == LocalDrivesContentUpToDate()) : TRUE;

    return hr;
}

STDAPI StartStopCI(BOOL bStart)
{
    DWORD dwErr = ERROR_SUCCESS;
    SERVICE_STATUS  status;

    SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm)
    {
        DWORD dwAccess = SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | (bStart ? SERVICE_START : SERVICE_STOP);
        SC_HANDLE hService = OpenService(hScm, L"cisvc", dwAccess);
        if (hService)
        {
            if (QueryServiceStatus(hService, &status))
            {
                dwErr = ChangeServiceConfig(hService, SERVICE_NO_CHANGE,
                                             bStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                                             SERVICE_NO_CHANGE, NULL, NULL, 
                                             NULL, NULL, NULL, NULL, NULL);
                // we'll ignore return value
        
                if (bStart)
                {
                    if (SERVICE_PAUSED == status.dwCurrentState ||
                        SERVICE_PAUSE_PENDING == status.dwCurrentState)
                        dwErr = ControlService(hService, SERVICE_CONTROL_CONTINUE, &status) ? 
                                    ERROR_SUCCESS : GetLastError();
                    else
                    {
                        dwErr = StartService(hService, 0, NULL) ? ERROR_SUCCESS : GetLastError();
                        if (ERROR_SERVICE_ALREADY_RUNNING == dwErr)
                            dwErr = ERROR_SUCCESS;
                    }
                }
                else
                {
                    dwErr = ControlService(hService, SERVICE_CONTROL_STOP, &status) ? 
                                    ERROR_SUCCESS : GetLastError();
                }
            }
            else
                dwErr = GetLastError();

            CloseServiceHandle(hService); 
        }
        else
            dwErr = GetLastError();

        CloseServiceHandle(hScm); 
    }
    else
        dwErr = GetLastError();

    return HRESULT_FROM_WIN32(dwErr);
}


inline BOOL IsWhite(WCHAR ch)
{
    return L' ' == ch || L'\t' == ch || L'\n' == ch || L'\r' == ch;
}

inline BOOL IsParens(WCHAR ch)
{
    return L'(' == ch || L')' == ch;
}


//  Skips whitespace
static LPCWSTR SkipWhiteAndParens(IN LPCWSTR pwszTest)
{
    while(pwszTest && *pwszTest && 
           (IsWhite(*pwszTest) || IsParens(*pwszTest)))
        pwszTest = CharNextW(pwszTest);

    return (pwszTest && *pwszTest) ? pwszTest : NULL;
}


//  Determines whether the indicated keyword is found in the specified
//  prefix and/or suffix context.  If successful, return value is address
//  of first character beyond the keyword context; otherwise NULL.
static LPCWSTR IsKeywordContext(
    IN LPCWSTR pwszTest, 
    IN OPTIONAL WCHAR chPrefix, 
    IN OPTIONAL LPCWSTR pwszKeyword, 
    IN OPTIONAL WCHAR chSuffix,
    IN OPTIONAL WCHAR chSuffix2)
{
    if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
        return NULL;
    
    if (chPrefix)
    {
        if (chPrefix != *pwszTest)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }

    if (pwszKeyword)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (StrStrIW(pwszTest, pwszKeyword) != pwszTest)
            return NULL;
        pwszTest += lstrlenW(pwszKeyword);
    }

    if (chSuffix)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (*pwszTest != chSuffix)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }

    if (chSuffix2)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (*pwszTest != chSuffix2)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }
    return pwszTest;
}

BOOL IsTripoliV1Token(LPCWSTR pwszQuery, LPCWSTR *ppwszOut /* trailing text */)
{
    *ppwszOut = NULL;
    LPCWSTR pwsz;

    //  Find the token
    if ((pwsz = IsKeywordContext(pwszQuery, L'#', NULL, 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'$', L"contents", 0, 0)) != NULL)
    {
        *ppwszOut = pwsz;
        return TRUE;
    }

    return FALSE;
}


BOOL IsTripoliV2Token(LPCWSTR pwszQuery, LPCWSTR *ppwszOut /* trailing text */)
{
    *ppwszOut = NULL;
    LPCWSTR pwsz;

    //  Find the token
    if ((pwsz = IsKeywordContext(pwszQuery, L'{', L"phrase", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"freetext", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"prop", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"regex", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"coerce", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"ve", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"weight", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"vector", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"generate", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'@', NULL, 0, 0)) != NULL)
    {
        *ppwszOut = pwsz;
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) IsCiQuery(const VARIANT *pvarRaw, VARIANT *pvarQuery, ULONG *pulDialect)
{
    BOOL bBang = FALSE;

    VariantInit(pvarQuery);

    *pulDialect = 0;        // invalid value (valid values are > 0)

    if (pvarRaw->vt != VT_BSTR || NULL == pvarRaw->bstrVal || 0 == *pvarRaw->bstrVal)
        return FALSE;

    LPCWSTR pwsz = pvarRaw->bstrVal;
    //  text beginning w/ '!' indicates that this text is a CI query.
    //  but it must be very first character (not even spaces are allowed)
    if (pwsz && *pwsz)
    {
        if (L'!' == *pwsz)
        {
            //  skip over '!'
            bBang = TRUE;
            
            if ((pwsz = CharNextW(pwsz)) == NULL || 0 == *pwsz)
                return FALSE;
                
            //  fall through...
        }
    }

    pwsz = SkipWhiteAndParens(pwsz);

    if (pwsz && *pwsz)
    {
        //  text looking like a query token
        if (pwsz && *pwsz)
        {
            LPCWSTR pwszMore, pwszTemp;
            // @ is valid in both tripoli v1 & v2 but it has extended usage in v2 so 
            // we put it as v2 token only
            if (IsTripoliV2Token(pwsz, &pwszMore))
                *pulDialect = ISQLANG_V2;
            // no else here because if @ is used in combination w/ some v1 token
            // we want the query to be v1.
            if (IsTripoliV1Token(pwsz, &pwszTemp))
            {
                *pulDialect = ISQLANG_V1;
                pwszMore  = pwszTemp;
            }

            if (*pulDialect)
            {
                // See if there is anything substantial past the query tokens
                pwszMore = SkipWhiteAndParens(pwszMore);
                if (pwszMore && *pwszMore)
                {
                    InitVariantFromStr(pvarQuery, pwsz);
                    return TRUE;
                }
            }
            else
            {
                if (bBang)
                {
                    InitVariantFromStr(pvarQuery, pwsz);
                    *pulDialect = ISQLANG_V1; // just pick one
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

// needed for ATL goo
LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

STDAPI CFileSearchBand_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = CreateFromRegKey(REGSTR_PATH_EXPLORER, TEXT("FileFindBandHook"), riid, ppv);
    if (FAILED(hr))
        hr = CComCreator< CComObject< CFileSearchBand > >::CreateInstance((void *)pUnkOuter, IID_IUnknown, (void **)ppv);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findband.h ===
// findband.h : Declaration of the CFileSearchBand

#ifndef __FSEARCH_H__
#define __FSEARCH_H__

#include "unicpp/stdafx.h"
#include "atldisp.h"    
#include "shcombox.h"   // shell combo methods
#include "finddlg.h"

class CFindFilesDlg;

#define FILESEARCHCTL_CLASS     TEXT("ShellFileSearchControl")

//  Band layout flags passed thru CFileSearchBand::UpdateLayout().
#define BLF_CALCSCROLL       0x00000001 // recalc scroll bars
#define BLF_SCROLLWINDOW     0x00000002 // scroll subdialog
#define BLF_RESIZECHILDREN   0x00000004 // resize subdialog
#define BLF_ALL              0xFFFFFFFF // do all layout ops

const UINT _icons[] = {
    //  replaced icons for fsearch, csearch with riff animations.
    IDI_PSEARCH,
};


//  CMetrics: maintains ctl metrics and resources.
class CMetrics
{
public:
    CMetrics();
    ~CMetrics() 
    { 
        DestroyResources(); 
    }

    void  Init(HWND hwndDlg);
    void  OnWinIniChange(HWND hwndDlg);
    static COLORREF TextColor()   { return GetSysColor(COLOR_WINDOWTEXT); }
    static COLORREF BkgndColor()  { return GetSysColor(COLOR_WINDOW); }
    static COLORREF BorderColor() { return GetSysColor(COLOR_WINDOWTEXT); }
    const HBRUSH&   BkgndBrush() const  { return _hbrBkgnd; }
    const HBRUSH&   BorderBrush() const { return _hbrBorder; }

    POINT&  ExpandOrigin() { return _ptExpandOrigin; }
    RECT&   CheckBoxRect() { return _rcCheckBox; }
    int&    TightMarginY() { return _cyTightMargin; }
    int&    LooseMarginY() { return _cyLooseMargin; }
    int&    CtlMarginX()   { return _cxCtlMargin; }
    HFONT   BoldFont(HWND hwndDlg);
    HICON   CaptionIcon(UINT nIDIconResource);

protected:
    BOOL    CreateResources();
    VOID    DestroyResources();
    static  BOOL GetWindowLogFont(HWND hwnd, OUT LOGFONT* plf);

    
    HBRUSH  _hbrBkgnd;
    HBRUSH  _hbrBorder;
    POINT   _ptExpandOrigin; // left-top origin of subdlg expansion 
    RECT    _rcCheckBox;     // size of a check box
    int     _cyTightMargin;  // v. distance between two tightly associated controls.
    int     _cyLooseMargin;  // v. distance between two loosely associated controls.
    int     _cxCtlMargin;    // distance between left or right dlg border and child window border.
    HFONT   _hfBold;         // Bold font
    HICON   _rghiconCaption[ARRAYSIZE(_icons)];
};

class ATL_NO_VTABLE CFileSearchBand : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFileSearchBand, &CLSID_FileSearchBand>,
    public CComControl<CFileSearchBand>,
    public CStockPropImpl<CFileSearchBand, IFileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32>,
    public IProvideClassInfo2Impl<&CLSID_FileSearchBand, NULL, &LIBID_Shell32>,
    public IPersistStreamInitImpl<CFileSearchBand>,
    public IPersistStorageImpl<CFileSearchBand>,
    public IQuickActivateImpl<CFileSearchBand>,
    public IOleControlImpl<CFileSearchBand>,
    public IOleInPlaceActiveObjectImpl<CFileSearchBand>,
    public IViewObjectExImpl<CFileSearchBand>,
    public IOleInPlaceObjectWindowlessImpl<CFileSearchBand>,
    public IDataObjectImpl<CFileSearchBand>,
    public ISpecifyPropertyPagesImpl<CFileSearchBand>,

    public IDeskBand,
    public IObjectWithSite,
    public IPersistStream,
    public IInputObject,
    public IServiceProvider,
    public IOleCommandTarget,

    //  Must derive from CShell32AtlIDispatch<> and not IOleObjecImpl 
    //  if this control resides in shell32.dll
    public CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
{
public:
    CFileSearchBand();
    ~CFileSearchBand();
    static  CWndClassInfo& GetWndClassInfo();
    HWND    Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL, 
                    DWORD dwStyle = WS_CHILD|WS_VISIBLE, DWORD dwExStyle = 0, UINT nID = 0);
    void    SetDeskbandWidth(int cx);
    void    FinalRelease();

public:
    BOOL        IsDeskBand() const       { return _fDeskBand; }
    static BOOL IsBandDebut();
    CMetrics&   GetMetrics()             { return _metrics; }
    static int  MakeBandKey(OUT LPTSTR pszKey, IN UINT cchKey);
    static int  MakeBandSubKey(IN LPCTSTR pszSubKey, OUT LPTSTR pszKey, IN UINT cchKey);
    static HKEY GetBandRegKey(BOOL bForceCreate = FALSE);
    void        UpdateLayout(ULONG fLayoutFlags = BLF_ALL);
    void        EnsureVisible(LPCRECT lprc /* in screen coords */);
    BOOL        IsKeyboardScroll(MSG* pmsg);
    HRESULT     IsDlgMessage(HWND hwnd, LPMSG pmsg);
    HRESULT     AutoActivate();

    void        SetDirty(BOOL bDirty = TRUE);
    BOOL        IsDirty() const          { return _fDirty; }
    BOOL        IsValid() const          { return _fValid; }

    IUnknown*       BandSite()           { return _punkSite ? _punkSite : (IUnknown*)m_spClientSite; }
    IOleClientSite* OleClientSite()      { return m_spClientSite; }

    DECLARE_NO_REGISTRY();

    BEGIN_COM_MAP(CFileSearchBand)
        COM_INTERFACE_ENTRY(IFileSearchBand)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IViewObjectEx)
        COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY(IOleControl)
        COM_INTERFACE_ENTRY(IOleObject)
        COM_INTERFACE_ENTRY(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistStorage)
        //COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)

        COM_INTERFACE_ENTRY_IID(IID_IDeskBand,IDeskBand)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY_IID(IID_IInputObject,IInputObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
        COM_INTERFACE_ENTRY(IPersistStream)
    END_COM_MAP()


public:
    BEGIN_PROPERTY_MAP(CFileSearchBand)
        // PROP_ENTRY("Property Description", dispid, clsid)
        PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    //  message map
    BEGIN_MSG_MAP(CFileSearchBand)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
        MESSAGE_HANDLER(WM_SETTINGCHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WM_WININICHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WMU_BANDINFOUPDATE, OnBandInfoUpdate)
    END_MSG_MAP()

    //---------------------//
    //  Message handling
protected:
    LRESULT OnCreate(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnScroll(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnMouseActivate(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnWinIniChange(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBandInfoUpdate(UINT, WPARAM, LPARAM, BOOL&);

public:
    // IFileSearchBand methods
    STDMETHOD (SetFocus)();
    STDMETHOD (SetSearchParameters)(IN BSTR* pbstrSearchID, 
                                     IN VARIANT_BOOL bNavToResults,
                                     IN OPTIONAL VARIANT *pvarScope, 
                                     IN OPTIONAL VARIANT* pvarQueryFile);
    STDMETHOD (get_SearchID)(OUT BSTR* pbstrSearchID);
    STDMETHOD (get_Scope)(OUT VARIANT *pvarScope);
    STDMETHOD (get_QueryFile)(OUT VARIANT *pvarFile);

    STDMETHOD (FindFilesOrFolders)(BOOL bNavigateToResults = FALSE, 
                                    BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindComputer)(BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindPrinter) (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindPeople)  (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindOnWeb)   (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);

    HRESULT OnDraw(ATL_DRAWINFO& di)    { return S_OK; }
    STDMETHOD (SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect); 

    //  CShell32AtlIDispatch/IOleObject methods
    STDMETHOD (PrivateQI)(REFIID iid, void** ppvObject);
    STDMETHOD (DoVerbUIActivate)(LPCRECT prcPosRect, HWND hwndParent);
    STDMETHOD (TranslateAcceleratorInternal)(MSG *pMsg, IOleClientSite * pocs);

    // IViewObjectEx methods
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    //  IOleInPlaceActiveObject methods
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg);

    //  IDeskBand
    STDMETHOD (GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);

    //  IDockingWindow
    STDMETHOD (ShowDW)(BOOL fShow);
    STDMETHOD (CloseDW)(DWORD dwReserved);
    STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);
    
    //  IOleWindow
    STDMETHOD (GetWindow)(HWND * lphwnd)              { *lphwnd = m_hWnd; return ::IsWindow(m_hWnd) ? S_OK : S_FALSE; }
    STDMETHOD (ContextSensitiveHelp)(BOOL fEnterMode) { return E_NOTIMPL; }

    //  IObjectWithSite
    STDMETHOD (SetSite)(IUnknown* punkSite);
    STDMETHOD (GetSite)(REFIID riid, void** ppunkSite);

    //  IInputObject
    STDMETHOD (HasFocusIO)(void);
    STDMETHOD (TranslateAcceleratorIO)(LPMSG lpMsg);
    STDMETHOD (UIActivateIO)(BOOL fActivate, LPMSG lpMsg);

    //  IOleCommandTarget
    STDMETHOD (QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHOD (Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    //  IServiceProvider
    STDMETHOD (QueryService)(REFGUID guidService, REFIID riid, void** ppv);

    //  IPersist
    STDMETHOD (GetClassID)(CLSID *pClassID); //

    //  IPersistStream
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(IStream *pStm); //
    STDMETHOD (Save)(IStream *pStm, BOOL fClearDirty); //
    STDMETHOD (GetSizeMax)(ULARGE_INTEGER *pcbSize);

    BOOL  SearchInProgress() const 
    {   
        if (_pBandDlg)
            return _pBandDlg->SearchInProgress();
        return FALSE;
    };
    void  StopSearch() 
    {
        if (_pBandDlg)
            _pBandDlg->StopSearch();
    };

private:
    CBandDlg*           GetBandDialog(REFGUID guidSearch);
    HRESULT             ShowBandDialog(REFGUID guidSearch, 
                                        BOOL bNavigateToResults = FALSE, 
                                        BOOL bDefaultFocusCtl = FALSE /* force focus to the band's default control */);
    HRESULT             AdvertiseBand(BOOL bAdvertise);
    HRESULT             BandInfoChanged();
    void                AddButtons(BOOL);
    BOOL                LoadImageLists();
    void                LayoutControls(int cx, int cy, ULONG fLayoutFlags = BLF_ALL);
    void                EnableControls();
    void                Scroll(int nBar, UINT uSBCode, int nNewPos = 0);
    IShellBrowser*      GetTopLevelBrowser();
    BOOL                IsBrowserAccelerator(LPMSG pmsg);

    CBandDlg*           BandDlg();

    CFindFilesDlg       _dlgFSearch;
    CFindComputersDlg   _dlgCSearch;
#ifdef __PSEARCH_BANDDLG__
    CFindPrintersDlg    _dlgPSearch;
#endif __PSEARCH_BANDDLG__
    CBandDlg*           _pBandDlg;     // the active/visible band.
    GUID                _guidSearch;   // the GUID of the active/visible band.

    CMetrics            _metrics;
    SIZE                _sizeMin,
                        _sizeMax;
    IUnknown*           _punkSite;
    SCROLLINFO          _siHorz,
                        _siVert;
    BITBOOL             _fValid : 1,
                        _fDirty : 1,
                        _fDeskBand : 1,
                        _fStrings : 1;
    DWORD               _dwBandID,
                        _dwBandViewMode;
    HIMAGELIST          _hilHot,       // toolbar image lists
                        _hilDefault;
    IShellBrowser*      _psb;          // top-level browser.
    LONG_PTR            _cbOffset;
    BOOL                _bSendFinishedDisplaying;   // Have we sent FileType box message to start new thread?
};

// Index Server control

// these are in ntquery.h

//  Query dialects:
#ifndef ISQLANG_V1
#define ISQLANG_V1 1 
#endif  //ISQLANG_V1

#ifndef ISQLANG_V2
#define ISQLANG_V2 2
#endif  //ISQLANG_V2

STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission);
STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine);
STDAPI StartStopCI(BOOL bStart);
STDAPI_(BOOL) IsCiQuery(const VARIANT* pvarRaw, OUT VARIANT* pvarQuery, OUT ULONG* pulDialect);

#endif //__FSEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findfilter.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "findhlp.h"
#include "fstreex.h"
#include "findfilter.h"
#include "prop.h"
#include "filtgrep.h"
#include "shstr.h"
#include "mtpt.h"
#include "idltree.h"
#include "enumidlist.h"

// Can't put this in varutil.cpp since a delay-load thunk for VariantTimeToDosDateTime
// pulls in the floating point init code, which pulls in _wWinMainCRTStartup which
// requires a _wWinMain which shlwapi does not have
//
STDAPI VariantToDosDateTime(VARIANT varIn, WORD *pwDate, WORD *pwTime)
{
    VARIANT varResult = {0};
    HRESULT hr = VariantChangeType(&varResult, &varIn, 0, VT_DATE);
    if (SUCCEEDED(hr))
    {
        VariantTimeToDosDateTime(varResult.date, pwDate, pwTime); 
    }
    return hr;
}

STDAPI InitVariantFromDosDateTime(VARIANT *pvar, WORD wDate, WORD wTime)
{
    pvar->vt = VT_DATE;
    return DosDateTimeToVariantTime(wDate, wTime, &pvar->date) ? S_OK : S_FALSE;
}

// {DBEC1000-6AB8-11d1-B758-00A0C90564FE}
const IID IID_IFindFilter = {0xdbec1000, 0x6ab8, 0x11d1, {0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe}};

// constants to define types of date we are searching on
#define DFF_DATE_ALL        (IDD_MDATE_ALL-IDD_MDATE_ALL)
#define DFF_DATE_DAYS       (IDD_MDATE_DAYS-IDD_MDATE_ALL)
#define DFF_DATE_MONTHS     (IDD_MDATE_MONTHS-IDD_MDATE_ALL)
#define DFF_DATE_BETWEEN    (IDD_MDATE_BETWEEN-IDD_MDATE_ALL)
#define DFF_DATE_RANGEMASK  0x00ff

// Define new criteria to be saved in file...
#define DFSC_SEARCHFOR      0x5000

#define DFSLI_VER                   0
#define DFSLI_TYPE_PIDL             0   // Pidl is streamed after this
#define DFSLI_TYPE_STRING           1   // cb follows this for length then string...
// Document folders and children - Warning we assume the order of items after Document Folders
#define DFSLI_TYPE_DOCUMENTFOLDERS  0x10
#define DFSLI_TYPE_DESKTOP          0x11
#define DFSLI_TYPE_PERSONAL         0x12
// My computer and children...
#define DFSLI_TYPE_MYCOMPUTER       0x20
#define DFSLI_TYPE_LOCALDRIVES      0x21

#define DFPAGE_INIT     0x0001          /* This page has been initialized */
#define DFPAGE_CHANGE   0x0002          /*  The user has modified the page */

#define SFGAO_FS_SEARCH (SFGAO_FILESYSANCESTOR | SFGAO_FOLDER)

// Use same enum and string table between updatefield and getting the constraints
// back out...
typedef enum
{
    CDFFUFE_IndexedSearch = 0,
    CDFFUFE_LookIn,
    CDFFUFE_IncludeSubFolders,
    CDFFUFE_Named,
    CDFFUFE_ContainingText,
    CDFFUFE_FileType,
    CDFFUFE_WhichDate,
    CDFFUFE_DateLE,
    CDFFUFE_DateGE,
    CDFFUFE_DateNDays,
    CDFFUFE_DateNMonths,
    CDFFUFE_SizeLE,
    CDFFUFE_SizeGE,
    CDFFUFE_TextCaseSen,
    CDFFUFE_TextReg,
    CDFFUFE_SearchSlowFiles,
    CDFFUFE_QueryDialect,
    CDFFUFE_WarningFlags,
    CDFFUFE_StartItem,
    CDFFUFE_SearchSystemDirs,
    CDFFUFE_SearchHidden,
} CDFFUFE;

static const struct
{
    LPCWSTR     pwszField;
    int         cdffufe;
}
s_cdffuf[] = // Warning: index of fields is used below in case...
{
    {L"IndexedSearch",       CDFFUFE_IndexedSearch},
    {L"LookIn",              CDFFUFE_LookIn},           // VARIANT: pidl, string or IEnumIDList object
    {L"IncludeSubFolders",   CDFFUFE_IncludeSubFolders},
    {L"Named",               CDFFUFE_Named},
    {L"ContainingText",      CDFFUFE_ContainingText},
    {L"FileType",            CDFFUFE_FileType},
    {L"WhichDate",           CDFFUFE_WhichDate},
    {L"DateLE",              CDFFUFE_DateLE},
    {L"DateGE",              CDFFUFE_DateGE},
    {L"DateNDays",           CDFFUFE_DateNDays},
    {L"DateNMonths",         CDFFUFE_DateNMonths},
    {L"SizeLE",              CDFFUFE_SizeLE},
    {L"SizeGE",              CDFFUFE_SizeGE},
    {L"CaseSensitive",       CDFFUFE_TextCaseSen},
    {L"RegularExpressions",  CDFFUFE_TextReg},
    {L"SearchSlowFiles",     CDFFUFE_SearchSlowFiles},
    {L"QueryDialect",        CDFFUFE_QueryDialect},
    {L"WarningFlags",        CDFFUFE_WarningFlags}, /*DFW_xxx bits*/
    {L"StartItem",           CDFFUFE_LookIn},           // VARIANT: pidl, string or IEnumIDList object
    {L"SearchSystemDirs",    CDFFUFE_SearchSystemDirs},
    {L"SearchHidden",        CDFFUFE_SearchHidden},
};

// internal support functions
STDAPI_(BOOL) SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR *ppszSpecOut);

// data filter object
class CFindFilter : public IFindFilter
{
public:
    CFindFilter();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindFilter
    STDMETHODIMP GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex);
    STDMETHODIMP GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu);
    STDMETHODIMP FFilterChanged();
    STDMETHODIMP GenerateTitle(LPTSTR *ppszTile, BOOL fFileName);
    STDMETHODIMP PrepareToEnumObjects(HWND hwnd, DWORD * pdwFlags);
    STDMETHODIMP ClearSearchCriteria();
    STDMETHODIMP EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, DWORD grfFlags, int iColSort, 
                             LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppdfenum);
    STDMETHODIMP GetColumnsFolder(IShellFolder2 **ppsf);
    STDMETHODIMP_(BOOL) MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP SaveCriteria(IStream * pstm, WORD fCharType);   
    STDMETHODIMP RestoreCriteria(IStream * pstm, int cCriteria, WORD fCharType);
    STDMETHODIMP DeclareFSNotifyInterest(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetColSaveStream(WPARAM wParam, LPSTREAM *ppstm);
    STDMETHODIMP GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwGQRFlags);
    STDMETHODIMP ReleaseQuery();
    STDMETHODIMP UpdateField(LPCWSTR pszField, VARIANT vValue);
    STDMETHODIMP ResetFieldsToDefaults();
    STDMETHODIMP GetItemContextMenu(HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu** ppcm);
    STDMETHODIMP GetDefaultSearchGUID(IShellFolder2 *psf2, LPGUID lpGuid);
    STDMETHODIMP EnumSearches(IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetSearchFolderClassId(LPGUID lpGuid);
    STDMETHODIMP GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound);
    STDMETHODIMP GetQueryLanguageDialect(ULONG * pulDialect);
    STDMETHODIMP GetWarningFlags(DWORD *pdwWarningFlags);

    STDMETHODIMP_(BOOL) TopLevelOnly() const   { return _fTopLevelOnly; }

private:
    ~CFindFilter();
    HRESULT _GetDetailsFolder();
    void _GenerateQuery(LPWSTR pwszQuery, DWORD *pcchQuery);
    void _UpdateTypeField(const VARIANT *pvar);
    static int _SaveCriteriaItem(IStream * pstm, WORD wNum, LPCTSTR psz, WORD fCharType);
    DWORD _QueryDosDate(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, WORD wDate, BOOL bBefore);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);
    DWORD _CIQuerySize(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, DWORD dwSize, int iSizeType);
    DWORD _CIQueryFilePatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPCWSTR pszFilePatterns);
    DWORD _CIQueryTextPatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText, BOOL bTextReg);
    DWORD _CIQueryShellSettings(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent);
    DWORD _CIQueryIndex(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText);
    DWORD _AddToQuery(LPWSTR *ppszBuf, DWORD *pcchBuf, LPWSTR pszAdd);
    void _DosDateToSystemtime(WORD wFatDate, LPSYSTEMTIME pst);
    WORD _GetTodaysDosDateMinusNMonths(int nMonths);
    WORD _GetTodaysDosDateMinusNDays(int nDays);
    HRESULT _ScopeEnumerator(IEnumIDList **ppenum);
    void _ResetRoots();

    LONG                _cRef;
    IFindEnum           *_penumAsync; // Added support for Query results to be async...

    // Data associated with the file name.
    LPTSTR              _pszFileSpec;        // $$ the one we do compares with
    LPTSTR              _pszSpecs;           // same as pszFileSpec but with '\0's for ';'s
    LPTSTR *            _apszFileSpecs;      // pointers into pszSpecs for each token
    int                 _cFileSpecs;         // count of specs

    TCHAR               _szPath[MAX_URL_STRING];   // Location of where to start search from
    TCHAR               _szUserInputFileSpec[MAX_PATH];  // File pattern.
    TCHAR               _szText[128];        // Limit text to max editable size

    BOOL                _fTopLevelOnly;      // Search on top level only?
    BOOL                _fSearchHidden;      // $$ Should we show all files?
    BOOL                _fFilterChanged;     // Something in the filter changed.
    BOOL                _fWeRestoredSomeCriteria; // We need to initilize the pages...
    BOOL                _fANDSearch;         // Perform search using AND vs OR?

    // Fields associated with the file type
    BOOL                _fTypeChanged;       // Type changed;
    int                 _iType;              // Index of the type.
    TCHAR               _szTypeName[80];     // The display name for type
    SHSTR               _strTypeFilePatterns;// $$ The file patterns associated with type
    LPTSTR              _pszIndexedSearch;   // what to search for... (Maybe larger than MAX_PATH because it's a list of paths.
    ULONG               _ulQueryDialect;     // ISQLANG_V1 or ISQLANG_V2
    DWORD               _dwWarningFlags;     // Warning bits (DFW_xxx).

    CFilterGrep         _filtgrep;

    int                 _iSizeType;          // $$ What type of size 0 - none, 1 > 2 <
    DWORD               _dwSize;             // $$ Size comparison
    WORD                _wDateType;          // $$ 0 - none, 1 days before, 2 months before...
    WORD                _wDateValue;         //  (Num of months or days)
    WORD                _dateModifiedBefore; // $$
    WORD                _dateModifiedAfter;  // $$
    BOOL                _fFoldersOnly;       // $$ Are we searching for folders?
    BOOL                _fTextCaseSen;       // $$ Case sensitive searching...
    BOOL                _fTextReg;           // $$ regular expressions.
    BOOL                _fSearchSlowFiles;   // && probably missleading as file over a 300baud modem is also slow
    BOOL                _fSearchSystemDirs;  //    Search system directories?
    int                 _iNextConstraint;    // which constraint to look at next...
    HWND                _hwnd;               // for enum UI
    SHCOLUMNID          _scidDate;           // which date property to operate on
    SHCOLUMNID          _scidSize;           // which numeric property to operate on
    IEnumIDList         *_penumRoots;        // idlist enumerator for search roots
    IPropertyUI         *_ppui;
};

//  Target folder queue.
class CFolderQueue
{
public:
    CFolderQueue() : _hdpa(NULL) {}
    ~CFolderQueue();

    HRESULT Add(IShellFolder *psf, LPCITEMIDLIST pidl);

    IShellFolder *Remove();

private:
    HRESULT _AddFolder(IShellFolder *psf);
    HDPA    _hdpa;
};

class CNamespaceEnum : public IFindEnum
{
public:
    CNamespaceEnum(IFindFilter *pfilter, IShellFolder *psf, IFindEnum *pdfEnumAsync,
                   IEnumIDList *penumScopes, HWND hwnd, DWORD grfFlags, LPTSTR pszProgressText);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP StopSearch();
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCol, BOOL fAscending);

private:
    ~CNamespaceEnum();
    BOOL _ShouldPushItem(LPCITEMIDLIST pidl);
    BOOL _IsSystemFolderByCLSID(LPCITEMIDLIST pidlFull);
    IShellFolder *_NextRootScope();

    LONG            _cRef;
    IFindFilter     *_pfilter;          // parent filter object

    IFindFolder     *_pff;              // docfind folder interface over results
    HWND             _hwnd;             // for enum UI
    DWORD            _grfFlags;         // docfind enumeration flags (DFOO_xxx).

    // Recursion state...
    IShellFolder*    _psf;              // current shell folder
    LPITEMIDLIST     _pidlFolder;       // current shell folder, as pidl
    LPITEMIDLIST     _pidlCurrentRootScope; // the last scope pulled out of _penumScopes
    IEnumIDList      *_penum;           // current enumerator.
    int              _iFolder;          // index of current folder in docfind results' folder list.

    // filter info...
    LPTSTR           _pszProgressText;  // path buffer pointer; caller-owned (evil!)

    // enumeration state
    IEnumIDList      *_penumScopes;     // Queue of target folders passed as arguments.
    CFolderQueue      _queSubFolders;   // Queue of subfolders to search in next recursive pass.

    // tree to store the exclude items (i.e. already seached)
    CIDLTree         _treeExcludeFolders;

    // We may have an Async Enum that does some of the scopes...
    IFindEnum         *_penumAsync;
};

// Constants used to keep track of how/why an item was added to the
// exclude tree.
enum 
{
    EXCLUDE_SEARCHED  = 1,
    EXCLUDE_SYSTEMDIR = 2,
};
    

// Create the default filter for our find code...  They should be completly
// self contained...

STDAPI CreateNameSpaceFindFilter(IFindFilter **ppff)
{
    *ppff = new CFindFilter();
    return *ppff ? S_OK : E_OUTOFMEMORY;
}

HRESULT CFolderQueue::Add(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IShellFolder *psfNew;
    HRESULT hr = SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfNew));
    if (SUCCEEDED(hr))
    {
        hr = _AddFolder(psfNew);
        psfNew->Release();
    }
    return hr;
}

HRESULT CFolderQueue::_AddFolder(IShellFolder *psf)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(4);
    }

    if (_hdpa)
    {
        if (DPA_AppendPtr(_hdpa, psf) >= 0)
        {
            psf->AddRef();
            hr = S_OK;
        }
    }
    return hr;
}

// remove the folder from the queue
// give the caller the ownership of this folder
IShellFolder *CFolderQueue::Remove()
{
    IShellFolder *psf = NULL;
    if (_hdpa && DPA_GetPtrCount(_hdpa))
        psf = (IShellFolder *)DPA_DeletePtr(_hdpa, 0);
    return psf;
}

CFolderQueue::~CFolderQueue()
{ 
    if (_hdpa) 
    { 
        while (TRUE)
        {
            IShellFolder *psf = Remove();
            if (psf)
            {
                psf->Release();
            }
            else
            {
                break;
            }
        }
        DPA_Destroy(_hdpa); 
    } 
}

CFindFilter::CFindFilter() : _cRef(1), _wDateType(DFF_DATE_ALL), _ulQueryDialect(ISQLANG_V2)
{
}

CFindFilter::~CFindFilter()
{
    Str_SetPtr(&_pszFileSpec, NULL);
    Str_SetPtr(&_pszSpecs, NULL);
    LocalFree(_apszFileSpecs); // elements point to pszSpecs so no free for them
    
    Str_SetPtr(&_pszIndexedSearch, NULL);

    if (_ppui)
        _ppui->Release();

    if (_penumRoots)
        _penumRoots->Release();
}


STDMETHODIMP CFindFilter::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindFilter, IFindFilter),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindFilter::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindFilter::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}

// Retrieves the string resource index number that is proper for the
// current type of search.
STDMETHODIMP CFindFilter::GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex)
{
    // Currently context is not used
    *puMsgIndex = IDS_FILESFOUND;
    return S_OK;
}

// Retrieves which menu to load to merge for the folder
STDMETHODIMP CFindFilter::GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu)
{
    *puBGMainMergeMenu = POPUP_DOCFIND_MERGE;
    *puBGPopupMergeMenu = 0;
    return S_OK;
}

STDMETHODIMP CFindFilter::GetItemContextMenu(HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu **ppcm)
{
    return CFindItem_Create(hwndOwner, pdfFolder, ppcm);
}

STDMETHODIMP CFindFilter::GetDefaultSearchGUID(IShellFolder2 *psf2, GUID *pGuid)
{
    return DefaultSearchGUID(pGuid);
}

STDMETHODIMP CFindFilter::EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return  E_NOTIMPL;
}

STDMETHODIMP CFindFilter::GetSearchFolderClassId(GUID *pGuid)
{
    *pGuid = CLSID_DocFindFolder;
    return S_OK;
}

// (returns S_OK if nothing changed.)
STDMETHODIMP CFindFilter::FFilterChanged()
{
    BOOL fFilterChanged = _fFilterChanged;
    this->_fFilterChanged = FALSE;
    return fFilterChanged ? S_FALSE : S_OK;
}

// Generates the title given the current search criteria.
STDMETHODIMP CFindFilter::GenerateTitle(LPTSTR *ppszTitle, BOOL fFileName)
{
    BOOL   fFilePattern;
    int    iRes;
    TCHAR  szFindName[80];    // German should not exceed this find: ->???
    LPTSTR pszFileSpec = _szUserInputFileSpec;
    LPTSTR pszText     = _szText;

    //
    // Lets generate a title for the search.  The title will depend on
    // the file patern(s), the type field and the containing text field
    // Complicate this a bit with the search for field...
    //

    fFilePattern = (pszFileSpec[0] != 0) &&
                (lstrcmp(pszFileSpec, c_szStarDotStar) != 0);

    if (!fFilePattern && (_penumAsync == NULL) && _pszIndexedSearch)
    {
        pszFileSpec = _pszIndexedSearch;
        fFilePattern = (pszFileSpec[0] != 0) &&
                    (lstrcmp(pszFileSpec, c_szStarDotStar) != 0);
    }

    if ((pszText[0] == 0) && (_penumAsync != NULL) && _pszIndexedSearch)
        pszText = _pszIndexedSearch;

    // First see if there is a type field
    if (_iType > 0)
    {
        // We have a type field no check for content...
        if (pszText[0] != 0)
        {
            // There is text!
            // Should now use type but...
            // else see if the name field is not NULL and not *.*
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_TYPE_NAME_TEXT;
            else
                iRes = IDS_FIND_TITLE_TYPE_TEXT;
        }
        else
        {
            // No type or text, see if file pattern
            // Containing not found, first search for type then named
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_TYPE_NAME;
            else
                iRes = IDS_FIND_TITLE_TYPE;
        }
    }
    else
    {
        // No Type field ...
        // first see if there is text to be searched for!
        if (pszText[0] != 0)
        {
            // There is text!
            // Should now use type but...
            // else see if the name field is not NULL and not *.*
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_NAME_TEXT;
            else
                iRes = IDS_FIND_TITLE_TEXT;
        }
        else
        {
            // No type or text, see if file pattern
            // Containing not found, first search for type then named
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_NAME;
            else
                iRes = IDS_FIND_TITLE_ALL;
        }
    }


    // We put : in for first spot for title bar.  For name creation
    // we remove it which will put the number at the end...
    if (!fFileName)
        LoadString(HINST_THISDLL, IDS_FIND_TITLE_FIND,
                szFindName, ARRAYSIZE(szFindName));
    *ppszTitle = ShellConstructMessageString(HINST_THISDLL,
            MAKEINTRESOURCE(iRes),
            fFileName? szNULL : szFindName,
            _szTypeName, pszFileSpec, pszText);

    return *ppszTitle ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindFilter::ClearSearchCriteria()
{
    // Also clear out a few other fields...
    _szUserInputFileSpec[0] = 0;
    _iType = 0;
    _szText[0] = 0;

    return S_OK;
}

STDMETHODIMP CFindFilter::PrepareToEnumObjects(HWND hwnd, DWORD *pdwFlags)
{
    *pdwFlags = 0;  // start out empty

    _hwnd = hwnd;   // used for the first enum so that can do UI (auth/insert media)

    // Update the flags and buffer strings
    if (!_fTopLevelOnly)
        *pdwFlags |= DFOO_INCLUDESUBDIRS;

    if (_fTextCaseSen)
        *pdwFlags |= DFOO_CASESEN;
        
    if (_fSearchSystemDirs)
        *pdwFlags |= DFOO_SEARCHSYSTEMDIRS;

    // Also get the shell state variables to see if we should show extensions and the like
    if (_fSearchHidden)
        *pdwFlags |= DFOO_SHOWALLOBJECTS;

    // Now lets generate the file patern we will ask the system to look for
    
    // Here is where we try to put some smarts into the file patterns stuff
    // It will go something like:
    // look between each; or , and see if there are any wild cards.  If not
    // do something like *patern*.
    // Also if there is no search pattern or if it is * or *.*, set the
    // filter to NULL as to speed it up.
    //

    _fANDSearch = SetupWildCardingOnFileSpec(_szUserInputFileSpec, &_pszFileSpec);

    _cFileSpecs = 0;
    if (_pszFileSpec && _pszFileSpec[0])
    {
        Str_SetPtr(&_pszSpecs, _pszFileSpec);

        if (_pszSpecs)
        {
            int cTokens = 0;
            LPTSTR pszToken = _pszSpecs;
            // Count number of file spces
            while (pszToken)
            {
                // let's walk pszFileSpec to see how many specs we have...
                pszToken = StrChr(pszToken, TEXT(';'));

                // If delimiter, then advance past for next iteration
                if (pszToken)
                    pszToken++;
                cTokens++;
            }

            if (cTokens)
            {
                // cleanup the previous search
                if (_apszFileSpecs)
                    LocalFree(_apszFileSpecs);
                _apszFileSpecs = (LPTSTR *)LocalAlloc(LPTR, cTokens * sizeof(LPTSTR *));
                if (_apszFileSpecs)
                {
                    _cFileSpecs = cTokens;
                    pszToken = _pszSpecs;
                    for (int i = 0; i < cTokens; i++)
                    {
                        _apszFileSpecs[i] = pszToken;
                        pszToken = StrChr(pszToken, TEXT(';'));
                        if (pszToken)
                            *pszToken++ = 0;
                    }
                }
            }
        }
    }

    _filtgrep.Reset();
    
    HRESULT hr = S_OK;
    if (_szText[0])
    {
        DWORD dwGrepFlags = FGIF_BLANKETGREP | FGIF_GREPFILENAME;
        if (*pdwFlags & DFOO_CASESEN)
            dwGrepFlags |= FGIF_CASESENSITIVE;

        hr = _filtgrep.Initialize(GetACP(), _szText, NULL, dwGrepFlags);
    }
    return hr;
}

STDMETHODIMP CFindFilter::GetColumnsFolder(IShellFolder2 **ppsf)
{
    *ppsf = NULL;
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidl, ppsf));
        ILFree(pidl);
    }
    return hr;
}

void FreePathArray(LPTSTR rgpszPaths[], UINT cPaths)
{
    for (UINT i = 0; i < cPaths; i++)
    {
        LocalFree((HLOCAL)rgpszPaths[i]);
        rgpszPaths[i] = NULL;
    }
}

HRESULT NamesFromEnumIDList(IEnumIDList *penum, LPTSTR rgpszPaths[], UINT sizePaths, UINT *pcPaths)
{
    *pcPaths = 0;
    ZeroMemory(rgpszPaths, sizeof(rgpszPaths[0]) * sizePaths);

    penum->Reset();

    LPITEMIDLIST pidl;
    while (S_OK == penum->Next(1, &pidl, NULL))
    {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            if ((*pcPaths) < sizePaths)
            {
                rgpszPaths[*pcPaths] = StrDup(szPath);
                if (rgpszPaths[*pcPaths])
                    (*pcPaths)++;
            }
        }
        ILFree(pidl);
    }
    return S_OK;
}

void ClearIDArray(LPITEMIDLIST rgItems[], UINT cItems)
{
    for (UINT i = 0; i < cItems; i++)
    {
        ILFree(rgItems[i]);
        rgItems[i] = NULL;
    }
}

#define MAX_ROOTS   32

HRESULT AddIDListToEnumerator(LPCITEMIDLIST pidlToAdd, IEnumIDList **ppenum)
{
    LPITEMIDLIST rgItems[MAX_ROOTS] = {0};
    int cItems = 0;

    // the new one
    rgItems[cItems] = ILClone(pidlToAdd);
    if (rgItems[cItems])
    {
        cItems++;
    }

    (*ppenum)->Reset();
    // capture all of the other pidls in the current enumerator
    LPITEMIDLIST pidl;
    while (S_OK == (*ppenum)->Next(1, &pidl, NULL))
    {
        // that are not the same as pidlToAdd
        if (!ILIsEqual(pidl, pidlToAdd) &&
            (cItems < ARRAYSIZE(rgItems)))
        {
            rgItems[cItems++] = pidl;
        }
        else
        {
            ILFree(pidl);   // duplicate (or did not fit in array)
        }
    }

    IEnumIDList *penum;
    if (SUCCEEDED(CreateIEnumIDListOnIDLists(rgItems, cItems, &penum)))
    {
        (*ppenum)->Release();
        *ppenum = penum;
    }

    ClearIDArray(rgItems, cItems);

    return S_OK;
}

HRESULT FilterEnumeratorByNames(const LPCTSTR rgpszNames[], UINT cNames, IEnumIDList **ppenum)
{
    LPITEMIDLIST rgItems[MAX_ROOTS] = {0};
    int cItems = 0;

    (*ppenum)->Reset();
    // capture all of the other pidls in the current enumerator
    LPITEMIDLIST pidl;
    while (S_OK == (*ppenum)->Next(1, &pidl, NULL))
    {
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            for (UINT i = 0; i < cNames; i++)
            {
                if (rgpszNames[i] &&
                    (cItems < ARRAYSIZE(rgItems)) &&
                    (0 == StrCmpIC(szPath, rgpszNames[i])))
                {
                    rgItems[cItems++] = pidl;
                    pidl = NULL;    // don't free below
                    break;
                }
            }
        }
        ILFree(pidl);   // may be NULL
    }

    IEnumIDList *penum;
    if (SUCCEEDED(CreateIEnumIDListOnIDLists(rgItems, cItems, &penum)))
    {
        (*ppenum)->Release();
        *ppenum = penum;
    }

    ClearIDArray(rgItems, cItems);

    return S_OK;
}

HRESULT CFindFilter::_ScopeEnumerator(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    HRESULT hr = E_FAIL;
    if (_penumRoots)
    {
        hr = _penumRoots->Clone(ppenum);
        if (SUCCEEDED(hr))
            (*ppenum)->Reset(); // clone above will clone the index as well
    }
    return hr;
}
 
// produce the find enumerator

STDMETHODIMP CFindFilter::EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart,
                                      DWORD grfFlags, int iColSort, LPTSTR pszProgressText,  
                                      IRowsetWatchNotify *prwn, IFindEnum **ppdfenum)
{
    *ppdfenum = NULL;

    IEnumIDList *penum;
    HRESULT hr = _ScopeEnumerator(&penum);
    if (SUCCEEDED(hr))
    {
        if (pidlStart)
        {
            AddIDListToEnumerator(pidlStart, &penum);
        }

        UINT cPaths;
        LPTSTR rgpszPaths[MAX_ROOTS];
        hr = NamesFromEnumIDList(penum, rgpszPaths, ARRAYSIZE(rgpszPaths), &cPaths);
        if (SUCCEEDED(hr)) 
        {
            hr = CreateOleDBEnum(this, psf, rgpszPaths, &cPaths, grfFlags, iColSort, pszProgressText, prwn, ppdfenum);
            if (S_OK == hr)
            {
                _penumAsync = *ppdfenum;
                _penumAsync->AddRef();
            }

            // are their more paths to process?
            if (cPaths)
            {
                // did user specified CI query that we can't grep for?
                DWORD dwFlags;
                if (FAILED(GenerateQueryRestrictions(NULL, &dwFlags)) ||
                    !(dwFlags & GQR_REQUIRES_CI))
                {
                    FilterEnumeratorByNames(rgpszPaths, ARRAYSIZE(rgpszPaths), &penum);

                    IFindEnum *pdfenum = new CNamespaceEnum(
                        SAFECAST(this, IFindFilter *), psf, *ppdfenum, 
                        penum, _hwnd, grfFlags, pszProgressText);
                    if (pdfenum)
                    {
                        // The rest of the fields should be zero/NULL
                        *ppdfenum = pdfenum;
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            FreePathArray(rgpszPaths, cPaths);
        }
        penum->Release();
    }
    return hr;
}

// IFindFilter::MatchFilter

STDMETHODIMP_(BOOL) CFindFilter::MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bMatch = TRUE;
    TCHAR szName[MAX_PATH], szDisplayName[MAX_PATH];
    DWORD dwAttrib = SHGetAttributes(psf, pidl, SFGAO_HIDDEN | SFGAO_FOLDER | SFGAO_ISSLOW);
    
    if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))) &&
        SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_NORMAL, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        IShellFolder2 *psf2;
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2)); // optional, may be NULL
        
        // First things we dont show hidden files
        // If show all is set then we should include hidden files also...
        
        if (!_fSearchHidden && (SFGAO_HIDDEN & dwAttrib))
            bMatch = FALSE;     // does not match
        
        if (bMatch && _fFoldersOnly && !(SFGAO_FOLDER & dwAttrib))
            bMatch = FALSE;     // does not match
        
        if (bMatch && _iSizeType)
        {
            ULONGLONG ullSize;
            if (psf2 && SUCCEEDED(GetLongProperty(psf2, pidl, &_scidSize, &ullSize)))
            {
                if (1 == _iSizeType)        // >
                {
                    if (!(ullSize > _dwSize))
                        bMatch = FALSE;     // does not match
                }
                else if (2 == _iSizeType)   // <
                {
                    if (!(ullSize < _dwSize))
                        bMatch = FALSE;     // does not match
                }
            }
            else
            {
                bMatch = FALSE;
            }
        }
        
        if (bMatch && (_scidDate.fmtid != CLSID_NULL))
        {
            FILETIME ft;
            if (psf2 && SUCCEEDED(GetDateProperty(psf2, pidl, &_scidDate, &ft)))
            {
                FILETIME ftLocal;
                FileTimeToLocalFileTime(&ft, &ftLocal);

                WORD wFileDate = 0, wFileTime = 0;
                FileTimeToDosDateTime(&ftLocal, &wFileDate, &wFileTime);
            
                if (_dateModifiedBefore && !(wFileDate <= _dateModifiedBefore))
                    bMatch = FALSE;     // does not match
            
                if (_dateModifiedAfter && !(wFileDate >= _dateModifiedAfter))
                    bMatch = FALSE;     // does not match
            }
            else
            {
                bMatch = FALSE;
            }
        }
        
        // Match file specificaitions.
        if (bMatch && _pszFileSpec && _pszFileSpec[0])
        {
            // if we have split up version of the specs we'll use it because PathMatchSpec
            // can take up to 5-6 hours for more than 10 wildcard specs
            if (_cFileSpecs)
            {
                // Only search the actual file system file name if the user specified 
                // an extention
                BOOL bHasExtension = (0 != *PathFindExtension(_pszFileSpec));
                if (bHasExtension)
                {
                    for (int i = 0; i < _cFileSpecs; i++)
                    {
                        bMatch = PathMatchSpec(szName, _apszFileSpecs[i]);
                        if (_fANDSearch)
                        {
                            // AND we quit on the first one that doesn't match
                            if (!bMatch)
                                break;
                        }
                        else
                        {
                            // OR we quit on the first one that does match
                            if (bMatch)
                                break;
                        }
                    }
                }
                
                // Compare the displayable name to the filter.
                // This is needed for searching the recylcle bin becuase the actual file names
                // are similar to "DC0.LNK" instead of "New Text Document.txt"
                if (!bMatch || !bHasExtension)
                {
                    for (int i = 0; i < _cFileSpecs; i++)
                    {
                        bMatch = PathMatchSpec(szDisplayName, _apszFileSpecs[i]);
                        if (_fANDSearch)
                        {
                            // AND we quit on the first one that doesn't match
                            if (!bMatch)
                                break;
                        }
                        else
                        {
                            // OR we quit on the first one that does match
                            if (bMatch)
                                break;
                        }
                    }
                }
            }
            else if (!PathMatchSpec(szName, _pszFileSpec) 
                && !PathMatchSpec(szDisplayName, _pszFileSpec))
            {
                bMatch = FALSE;     // does not match
            }
        }
        
        if (bMatch && _strTypeFilePatterns[0])
        {
            // if looking for folders only and file pattern is all folders then no need to check
            // if folder name matches the pattern -- we know it is the folder, otherwise we
            // would have bailed out earlier in the function
            if (!(_fFoldersOnly && lstrcmp(_strTypeFilePatterns, TEXT(".")) == 0))
            {
                if (!PathMatchSpec(szName, _strTypeFilePatterns))
                    bMatch = FALSE;     // does not match
            }
        }
        
        // See if we need to do a grep of the file
        if (bMatch && (SFGAO_ISSLOW & dwAttrib) && !_fSearchSlowFiles)
            bMatch = FALSE;     // does not match
        
        if (bMatch && 
            (S_OK == _filtgrep.GetMatchTokens(NULL, 0) || 
             S_OK == _filtgrep.GetExcludeTokens(NULL, 0)))
        {
            bMatch = (S_OK == _filtgrep.Grep(psf, pidl, szName));
        }
        
        if (psf2)
            psf2->Release();
    }
    else
        bMatch = FALSE;
    return bMatch;    // return TRUE -> yes, a match!
}

// date ordinal mapper helpers to deal with old way to refer to dates

BOOL MapValueToDateSCID(UINT i, SHCOLUMNID *pscid)
{
    ZeroMemory(pscid, sizeof(*pscid));

    switch (i)
    {
    case 1:
        *pscid = SCID_WRITETIME;
        break;
    case 2:
        *pscid = SCID_CREATETIME;
        break;
    case 3:
        *pscid = SCID_ACCESSTIME;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

// returns 0 as invalid ordinal

int MapDateSCIDToValue(const SHCOLUMNID *pscid)
{
    int i = 0;  // 0 invalid scid

    if (IsEqualSCID(*pscid, SCID_WRITETIME))
    {
        i = 1;
    }
    else if (IsEqualSCID(*pscid, SCID_CREATETIME))
    {
        i = 2;
    }
    else if (IsEqualSCID(*pscid, SCID_ACCESSTIME))
    {
        i = 3;
    }
    return i;
}


// IFindFilter::SaveCriteria

STDMETHODIMP CFindFilter::SaveCriteria(IStream * pstm, WORD fCharType)
{
    TCHAR szTemp[40];    // some random size

    // The caller should have already validated the stuff and updated
    // everything for the current filter information.

    // we need to walk through and check each of the items to see if we
    // have a criteria to save away. this includes:
    //      (Name, Path, Type, Contents, size, modification dates)
    int cCriteria = _SaveCriteriaItem(pstm, IDD_FILESPEC, _szUserInputFileSpec, fCharType);

    cCriteria += _SaveCriteriaItem(pstm, IDD_PATH, _szPath, fCharType);

    cCriteria += _SaveCriteriaItem(pstm, DFSC_SEARCHFOR, _pszIndexedSearch, fCharType);
    cCriteria += _SaveCriteriaItem(pstm, IDD_TYPECOMBO, _strTypeFilePatterns, fCharType);
    cCriteria += _SaveCriteriaItem(pstm, IDD_CONTAINS, _szText, fCharType);
    
    // Also save away the state of the top level only
    wsprintf(szTemp, TEXT("%d"), _fTopLevelOnly);
    cCriteria += _SaveCriteriaItem(pstm, IDD_TOPLEVELONLY, szTemp, fCharType);

    // The Size field is little more fun!
    if (_iSizeType != 0)
    {
        wsprintf(szTemp, TEXT("%d %ld"), _iSizeType, _dwSize);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SIZECOMP, szTemp, fCharType);
    }

    // Likewise for the dates, should be fun as we need to save it depending on
    // how the date was specified
    switch (_wDateType & DFF_DATE_RANGEMASK)
    {
    case DFF_DATE_ALL:
        // nothing to store
        break;
    case DFF_DATE_DAYS:
        wsprintf(szTemp, TEXT("%d"), _wDateValue);
        cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_NUMDAYS, szTemp, fCharType);
        break;
    case DFF_DATE_MONTHS:
        wsprintf(szTemp, TEXT("%d"), _wDateValue);
        cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_NUMMONTHS, szTemp, fCharType);
        break;
    case DFF_DATE_BETWEEN:
        if (_dateModifiedAfter)
        {
            wsprintf(szTemp, TEXT("%d"), _dateModifiedAfter);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_FROM, szTemp, fCharType);
        }

        if (_dateModifiedBefore)
        {
            wsprintf(szTemp, TEXT("%d"), _dateModifiedBefore);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_TO, szTemp, fCharType);
        }
        break;
    }

    if ((_wDateType & DFF_DATE_RANGEMASK) != DFF_DATE_ALL)
    {
        int i = MapDateSCIDToValue(&_scidDate);
        if (i)
        {
            // strangly we write a 0 based version of this ordinal out
            wsprintf(szTemp, TEXT("%d"), i - 1);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_TYPE, szTemp, fCharType);
        }
    }

    if (_fTextCaseSen)
    {
        wsprintf(szTemp, TEXT("%d"), _fTextCaseSen);
        cCriteria += _SaveCriteriaItem(pstm, IDD_TEXTCASESEN, szTemp, fCharType);
    }

    if (_fTextReg)
    {
        wsprintf(szTemp, TEXT("%d"), _fTextReg);
        cCriteria += _SaveCriteriaItem(pstm, IDD_TEXTREG, szTemp, fCharType);
    }

    if (_fSearchSlowFiles)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchSlowFiles);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHSLOWFILES, szTemp, fCharType);
    }

    //  Save value for searching system directories.
    if (_fSearchSystemDirs)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchSystemDirs);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHSYSTEMDIRS, szTemp, fCharType);
    }

    if (_fSearchHidden)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchHidden);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHHIDDEN, szTemp, fCharType);
    }

    return MAKE_SCODE(0, 0, cCriteria);
}


// Helper function for save criteria that will output the string and
// and id to the specified file.  it will also test for NULL and the like

int CFindFilter::_SaveCriteriaItem(IStream *pstm, WORD wNum, LPCTSTR psz, WORD fCharType)
{
    if ((psz == NULL) || (*psz == 0))
        return 0;
    else
    {
        const void *pszText = (const void *)psz; // Ptr to output text. Defaults to source.
        // These are required to support ANSI-unicode conversions.
        LPSTR pszAnsi  = NULL; // For unicode-to-ansi conversion.
        LPWSTR pszWide = NULL; // For ansi-to-unicode conversion.
        DFCRITERIA dfc;
        dfc.wNum = wNum;
        
        // Note: Problem if string is longer than 64K
        dfc.cbText = (WORD) ((lstrlen(psz) + 1) * sizeof(TCHAR));
        
        // Source string is Unicode but caller wants to save as ANSI.
        //
        if (DFC_FMT_ANSI == fCharType)
        {
            // Convert to ansi and write ansi.
            dfc.cbText = (WORD) WideCharToMultiByte(CP_ACP, 0L, psz, -1, pszAnsi, 0, NULL, NULL);
            
            pszAnsi = (LPSTR)LocalAlloc(LMEM_FIXED, dfc.cbText);
            if (pszAnsi)
            {
                WideCharToMultiByte(CP_ACP, 0L, psz, -1, pszAnsi, dfc.cbText / sizeof(pszAnsi[0]), NULL, NULL);
                pszText = (void *)pszAnsi;
            }
        }
        
        pstm->Write(&dfc, sizeof(dfc), NULL);       // Output index
        pstm->Write(pszText, dfc.cbText, NULL);     // output string + NULL
        
        // Free up conversion buffers if any were created.
        if (pszAnsi)
            LocalFree(pszAnsi);
        if (pszWide)
            LocalFree(pszWide);
    }
    
    return 1;
}

// IFindFilter::RestoreCriteria
STDMETHODIMP CFindFilter::RestoreCriteria(IStream *pstm, int cCriteria, WORD fCharType)
{
    SHSTR strTemp;
    SHSTRA strTempA;

    if (cCriteria > 0)
        _fWeRestoredSomeCriteria = TRUE;

    while (cCriteria--)
    {
        DFCRITERIA dfc;
        DWORD cb;

        if (FAILED(pstm->Read(&dfc, sizeof(dfc), &cb)) || cb != sizeof(dfc))
            break;

        if (DFC_FMT_UNICODE == fCharType)
        {
           // Destination is Unicode and we're reading Unicode data from stream.
           // No conversion required.
           if (FAILED(strTemp.SetSize(dfc.cbText / sizeof(TCHAR))) ||
               FAILED(pstm->Read(strTemp.GetInplaceStr(), dfc.cbText, &cb))
                   || (cb != dfc.cbText))
               break;
        }
        else
        {
           // Destination is Unicode but we're reading ANSI data from stream.
           // Read ansi.  Convert to unicode.
           if (FAILED(strTempA.SetSize(dfc.cbText / sizeof(CHAR))) ||
               FAILED(pstm->Read(strTempA.GetInplaceStr(), dfc.cbText, &cb))
                   || (cb != dfc.cbText))
               break;

           strTemp.SetStr(strTempA);
        }

        switch (dfc.wNum)
        {
        case IDD_FILESPEC:
            lstrcpyn(_szUserInputFileSpec, strTemp, ARRAYSIZE(_szUserInputFileSpec));
            break;

        case DFSC_SEARCHFOR:
            Str_SetPtr(&_pszIndexedSearch, strTemp);
            break;

        case IDD_PATH:
            _ResetRoots();
            lstrcpyn(_szPath, strTemp, ARRAYSIZE(_szPath));
            CreateIEnumIDListPaths(_szPath, &_penumRoots);
            break;

        case IDD_TOPLEVELONLY:
            _fTopLevelOnly = StrToInt(strTemp);
            break;

        case IDD_TYPECOMBO:
            _strTypeFilePatterns.SetStr(strTemp);
            break;

        case IDD_CONTAINS:
            lstrcpyn(_szText, strTemp, ARRAYSIZE(_szText));
            break;

        case IDD_SIZECOMP:
            // we need to extract off the two parts, the type and
            // the value

            _iSizeType = strTemp[0] - TEXT('0');
            _dwSize = StrToInt(&(strTemp.GetStr())[2]);
            break;

        case IDD_MDATE_NUMDAYS:
            _wDateType = DFF_DATE_DAYS;
            _wDateValue = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_NUMMONTHS:
            _wDateType = DFF_DATE_MONTHS;
            _wDateValue = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_FROM:
            _wDateType = DFF_DATE_BETWEEN;
            _dateModifiedAfter = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_TO:
            _wDateType = DFF_DATE_BETWEEN;
            _dateModifiedBefore = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_TYPE:
            // persisted value is zero based, adjust that by adding 1
            MapValueToDateSCID(StrToInt(strTemp) + 1, &_scidDate);
            break;

        case IDD_TEXTCASESEN:
            _fTextCaseSen = StrToInt(strTemp);
            break;

        case IDD_TEXTREG:
            _fTextReg = StrToInt(strTemp);
            break;

        case IDD_SEARCHSLOWFILES:
            _fSearchSlowFiles = StrToInt(strTemp);
            break;
            
        case IDD_SEARCHSYSTEMDIRS:
            _fSearchSystemDirs = StrToInt(strTemp);
            break;
        }
    }
    return S_OK;
}

// IFindFilter::GetColSaveStream

STDMETHODIMP CFindFilter::GetColSaveStream(WPARAM wParam, IStream **ppstm)
{
    *ppstm = OpenRegStream(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, TEXT("DocFindColsX"), (DWORD) wParam);
    return *ppstm ? S_OK : E_FAIL;
}

void CFindFilter::_GenerateQuery(LPWSTR pwszQuery, DWORD *pcchQuery)
{
    DWORD cchNeeded = 0, cchLeft = *pcchQuery;
    LPWSTR pszCurrent = pwszQuery;
    BOOL bFirst = TRUE; // first property

    if (_pszFileSpec && _pszFileSpec[0])
    {
        cchNeeded += _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, _pszFileSpec);
    }

    // fFoldersOnly = TRUE implies szTypeFilePatterns = "."
    // we cannot pass "." to CI because they won't understand it as give me the folder types
    // we could check for @attrib ^a FILE_ATTRIBUTE_DIRECTORY (0x10) but ci doesn't index the 
    // folder names by default so we normally won't get any results...

    if (!_fFoldersOnly && _strTypeFilePatterns[0])
    {
        cchNeeded += _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, _strTypeFilePatterns);
    }
    
    // Date:
    if (_dateModifiedBefore)
    {           
        cchNeeded += _QueryDosDate(&bFirst, &cchLeft, &pszCurrent, _dateModifiedBefore, TRUE);
    }
    
    if (_dateModifiedAfter)
    {
        cchNeeded += _QueryDosDate(&bFirst, &cchLeft, &pszCurrent, _dateModifiedAfter, FALSE);
    }

    if (_iSizeType)
    {
        cchNeeded += _CIQuerySize(&bFirst, &cchLeft, &pszCurrent, _dwSize, _iSizeType);
    }

    // Indexed Search: raw query
    if (_pszIndexedSearch && _pszIndexedSearch[0])
    {
        // HACK Alert if first Char is ! then we assume Raw and pass it through directly to CI...
        // Likewise if it starts with @ or # pass through, but remember the @...
        cchNeeded += _CIQueryIndex(&bFirst, &cchLeft, &pszCurrent, _pszIndexedSearch);
    }

    // Containing Text:
    if (_szText[0])
    {
        // Try not to quote the strings unless we need to.  This allows more flexability to do the
        // searching for example: "cat near dog" is different than: cat near dog
        cchNeeded += _CIQueryTextPatterns(&bFirst, &cchLeft, &pszCurrent, _szText, _fTextReg);
    }

    cchNeeded += _CIQueryShellSettings(&bFirst, &cchLeft, &pszCurrent);

    IEnumIDList *penum;
    if (SUCCEEDED(_ScopeEnumerator(&penum)))
    {
        TCHAR szPath[MAX_PATH];

        LPITEMIDLIST pidl;
        while (S_OK == penum->Next(1, &pidl, NULL))
        {
            if (SHGetPathFromIDList(pidl, szPath) && PathStripToRoot(szPath))
            {
                // don't search recycle bin folder. we add both nt4's recycled 
                // and nt5's recycler for every drive we search.
                static const LPCTSTR s_rgszRecycleBins[] = 
                { 
                    TEXT("Recycled\\*"), 
                    TEXT("Recycler\\*"), 
                };

                for (int iBin = 0; iBin < ARRAYSIZE(s_rgszRecycleBins); iBin++)
                {
                    TCHAR szExclude[MAX_PATH];
                    if (PathCombine(szExclude, szPath, s_rgszRecycleBins[iBin]))
                    {
                        DWORD cchSize = lstrlen(szExclude) + ARRAYSIZE(TEXT(" & !#PATH "));

                        // don't bail out early if we are asked for size of query
                        if (pwszQuery && cchSize > cchLeft)
                            break;

                        cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, TEXT(" & !#PATH "));
                        cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, szExclude);
                    }
                }
            }
            ILFree(pidl);
        }
        penum->Release();
    }

    // we must exclude the special folders from the results or ci will find items that 
    // we cannot get pidls for.
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, CI_SPECIAL_FOLDERS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD cValues = 0; // init to zero in case query info bellow fails
    
        RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, NULL, NULL, NULL, NULL);
        for (DWORD i = 0; i < cValues; i++)
        {
            TCHAR szExcludePath[MAX_PATH];
            DWORD cb = sizeof(szExcludePath);

            TCHAR szName[10];
            wsprintf(szName, TEXT("%d"), i);
            if (RegQueryValueEx(hkey, szName, NULL, NULL, (BYTE *)szExcludePath, &cb) == ERROR_SUCCESS)
            {
                // this is in the query (or a drive letter of the query)

                DWORD cchSize = lstrlen(szExcludePath) + ARRAYSIZE(TEXT(" & !#PATH "));

                // don't bail out early if we are asked for size of query
                if (pwszQuery && cchSize > cchLeft)
                    break;

                cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, TEXT(" & !#PATH "));
                cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, szExcludePath);
            }
        }
        RegCloseKey(hkey);
    }

    // we need at least some constraints so give a query of "all files"

    if (pwszQuery && pszCurrent == pwszQuery)
        _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, L"*.*");

    if (pszCurrent)
    {
        // Make sure we terminate the string at the end...
        *pszCurrent = 0;
    }

    if (!pwszQuery)
    {
        *pcchQuery = cchNeeded;
    }
    else
    {
        ASSERT(*pcchQuery > cchNeeded);
    }
}

// Create a query command string out of the search criteria

STDMETHODIMP CFindFilter::GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwQueryRestrictions)
{
    // we should be able to make use of ci no matter what (exceptions at the end of the function)
    DWORD dwQueryRestrictions = GQR_MAKES_USE_OF_CI; 
    HRESULT hr = S_OK;

#ifdef DEBUG
    if (GetKeyState(VK_SHIFT) < 0)
    {
        dwQueryRestrictions |= GQR_REQUIRES_CI;
    }
#endif

    if (ppwszQuery)
    {
        DWORD cchNeeded = 0;
        _GenerateQuery(NULL, &cchNeeded);
        cchNeeded++;  // for \0
        
        *ppwszQuery = (LPWSTR)LocalAlloc(LPTR, cchNeeded * sizeof(**ppwszQuery));
        if (*ppwszQuery)
        {
            _GenerateQuery(*ppwszQuery, &cchNeeded);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (_pszIndexedSearch && _pszIndexedSearch[0])
            dwQueryRestrictions |= GQR_REQUIRES_CI;

        // ci is not case sensitive, so if user wanted case sensitive search we cannot use ci
        // also ci doesn't index folder names by default so to be safe we just default to our
        // disk traversal algorithm...
        if (_fTextCaseSen || _fFoldersOnly)
        {    
            if ((dwQueryRestrictions & GQR_REQUIRES_CI) && _fTextCaseSen)
                hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_CASESENINDEX);
            else if (dwQueryRestrictions & GQR_MAKES_USE_OF_CI)
                dwQueryRestrictions &= ~GQR_MAKES_USE_OF_CI;
        }
    }
    *pdwQueryRestrictions = dwQueryRestrictions;  // return calculated Flags...
    return hr;
}

STDMETHODIMP CFindFilter::ReleaseQuery()
{
    ATOMICRELEASE(_penumAsync);
    return S_OK;
}

STDMETHODIMP CFindFilter::GetQueryLanguageDialect(ULONG* pulDialect)
{
    *pulDialect = _ulQueryDialect;
    return S_OK;
}

STDMETHODIMP CFindFilter::GetWarningFlags(DWORD* pdwWarningFlags)
{
    *pdwWarningFlags = _dwWarningFlags;
    return S_OK;
}

// Registering our interest in FS change notifications.
//
// In:
//   hwnd = window handle of the find dialog
//   uMsg = message to be sent to window when informing of notify

STDMETHODIMP CFindFilter::DeclareFSNotifyInterest(HWND hwnd, UINT uMsg)
{
    HDPA hdpa = DPA_Create(10);     // Used to manage list of pidls to add
    if (hdpa)
    {
        IEnumIDList *penum;
        if (SUCCEEDED(_ScopeEnumerator(&penum)))
        {
            LPITEMIDLIST pidl;
            while (S_OK == penum->Next(1, &pidl, NULL))
            {
                if (-1 == DPA_AppendPtr(hdpa, pidl))
                {
                    // Failed to add it, so free it.
                    ILFree(pidl);
                }
            }
            penum->Release();
        }
        // Eliminate any pidls in the hdpa that are children of other pidls.  
        // this is needed to prevent receiving the multiple updates for one change.
        // For example, if searching My Documents and C:\, then we will get 2 updates
        // for a change in My Documents if My Documents is on the C:\.            
        int cItems = DPA_GetPtrCount(hdpa);
        for (int iOuterLoop = 0; iOuterLoop < cItems - 1; iOuterLoop++)
        {
            LPITEMIDLIST pidlOuter = (LPITEMIDLIST) DPA_GetPtr(hdpa, iOuterLoop);
            for (int iInnerLoop = iOuterLoop + 1; 
                 pidlOuter && iInnerLoop < cItems; 
                 iInnerLoop++)
            {
                LPITEMIDLIST pidlInner = (LPITEMIDLIST) DPA_GetPtr(hdpa, iInnerLoop);
                if (pidlInner)
                {
                    if (ILIsParent(pidlInner, pidlOuter, FALSE))
                    {
                        // Since pidlInner is pidlOuter's parent, free pidlOuter and 
                        // don't register for events on it.
                        ILFree(pidlOuter);
                        pidlOuter = NULL;
                        DPA_SetPtr(hdpa, iOuterLoop, NULL);
                    } 
                    else if (ILIsParent(pidlOuter, pidlInner, FALSE))
                    {
                        // Since pidlOuter is pidlInner's parent, free pidlInner and 
                        // don't register for events on it.
                        ILFree(pidlInner);
                        pidlInner = NULL;
                        DPA_SetPtr(hdpa, iInnerLoop, NULL);
                    }
                }
            }
        }
        // Declare that we are interested in events on remaining pidls
        for (int iRegIndex = 0; iRegIndex < cItems; iRegIndex++)
        {
            SHChangeNotifyEntry fsne = {0};
            fsne.fRecursive = TRUE;

            fsne.pidl = (LPITEMIDLIST)DPA_GetPtr(hdpa, iRegIndex);
            if (fsne.pidl)
            {
                SHChangeNotifyRegister(hwnd, 
                                       SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                       SHCNE_DISKEVENTS, uMsg, 1, &fsne);
                ILFree((LPITEMIDLIST)fsne.pidl);
            }
        }

        DPA_Destroy(hdpa);
    }
    return S_OK;
}

void CFindFilter::_UpdateTypeField(const VARIANT *pvar)
{
    LPCWSTR pszValue = VariantToStrCast(pvar);  // input needs to be a BSTR
    if (pszValue)
    {
        if (StrStr(pszValue, TEXT(".Folder;.")))
        {
            // Special searching for folders...
            _fFoldersOnly = TRUE;
            _strTypeFilePatterns.SetStr(TEXT("."));
        }
        else
        {
            // Assume if the first one is wildcarded than all are,...
            if (*pszValue == TEXT('*'))
                _strTypeFilePatterns.SetStr(pszValue);
            else
            {
                TCHAR szNextPattern[MAX_PATH];  // overkill in size
                BOOL fFirst = TRUE;
                LPCTSTR pszNextPattern = pszValue;
                while ((pszNextPattern = NextPath(pszNextPattern, szNextPattern, ARRAYSIZE(szNextPattern))) != NULL)
                {
                    if (!fFirst)
                        _strTypeFilePatterns.Append(TEXT(";"));
                    fFirst = FALSE;

                    if (szNextPattern[0] != TEXT('*'))
                        _strTypeFilePatterns.Append(TEXT("*"));
                    _strTypeFilePatterns.Append(szNextPattern);
                }
            }
        }
    }
}

int _MapConstraint(LPCWSTR pszField)
{
    for (int i = 0; i < ARRAYSIZE(s_cdffuf); i++)
    {
        if (StrCmpIW(pszField, s_cdffuf[i].pwszField) == 0)
        {
            return i;
        }
    }
    return -1;
}

HRESULT CFindFilter::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

HRESULT CFindFilter::UpdateField(LPCWSTR pszField, VARIANT vValue)
{
    _fFilterChanged = TRUE;    // force rebuilding name of files...

    USHORT uDosTime;

    switch (_MapConstraint(pszField))
    {
    case CDFFUFE_IndexedSearch:
        Str_SetPtr(&_pszIndexedSearch, NULL);   // zero this out
        _pszIndexedSearch = VariantToStr(&vValue, NULL, 0);
        break;

    case CDFFUFE_LookIn:
        _ResetRoots();

        if (FAILED(QueryInterfaceVariant(vValue, IID_PPV_ARG(IEnumIDList, &_penumRoots))))
        {
            if (vValue.vt == VT_BSTR)
            {
                VariantToStr(&vValue, _szPath, ARRAYSIZE(_szPath));
                CreateIEnumIDListPaths(_szPath, &_penumRoots);
            }
            else
            {
                LPITEMIDLIST pidl = VariantToIDList(&vValue);
                if (pidl)
                {
                    CreateIEnumIDListOnIDLists(&pidl, 1, &_penumRoots);
                    ILFree(pidl);
                }
            }
        }
        break;

    case CDFFUFE_IncludeSubFolders:
        _fTopLevelOnly = !VariantToBOOL(vValue);   // invert sense
        break;

    case CDFFUFE_Named:
        VariantToStr(&vValue, _szUserInputFileSpec, ARRAYSIZE(_szUserInputFileSpec));
        break;

    case CDFFUFE_ContainingText:
        ZeroMemory(_szText, sizeof(_szText));   // special zero init whole buffer
        VariantToStr(&vValue, _szText, ARRAYSIZE(_szText));
        break;

    case CDFFUFE_FileType:
        _UpdateTypeField(&vValue);
        break;

    case CDFFUFE_WhichDate:
        if (vValue.vt == VT_BSTR)
        {
            IPropertyUI *ppui;
            if (SUCCEEDED(_GetPropertyUI(&ppui)))
            {
                ULONG cch = 0;  // in/out
                ppui->ParsePropertyName(vValue.bstrVal, &_scidDate.fmtid, &_scidDate.pid, &cch);
                ppui->Release();
            }
        }
        else
        {
            MapValueToDateSCID(VariantToInt(vValue), &_scidDate);
        }
        break;

    case CDFFUFE_DateLE:
        _wDateType |= DFF_DATE_BETWEEN;
        VariantToDosDateTime(vValue, &_dateModifiedBefore, &uDosTime); 
        if (_dateModifiedAfter && _dateModifiedBefore)
        {
            if (_dateModifiedAfter > _dateModifiedBefore)
            {
                WORD wTemp = _dateModifiedAfter;
                _dateModifiedAfter = _dateModifiedBefore;
                _dateModifiedBefore = wTemp;
            }
        }
        break;

    case CDFFUFE_DateGE:
        _wDateType |= DFF_DATE_BETWEEN;
        VariantToDosDateTime(vValue, &_dateModifiedAfter, &uDosTime); 
        if (_dateModifiedAfter && _dateModifiedBefore)
        {
            if (_dateModifiedAfter > _dateModifiedBefore)
            {
                WORD wTemp = _dateModifiedAfter;
                _dateModifiedAfter = _dateModifiedBefore;
                _dateModifiedBefore = wTemp;
            }
        }
        break;

    case CDFFUFE_DateNDays:
        _wDateType |= DFF_DATE_DAYS;
        _wDateValue = (WORD)VariantToInt(vValue);
        _dateModifiedAfter = _GetTodaysDosDateMinusNDays(_wDateValue);
        break;

    case CDFFUFE_DateNMonths:
        _wDateType |= DFF_DATE_MONTHS;
        _wDateValue = (WORD)VariantToInt(vValue);
        _dateModifiedAfter = _GetTodaysDosDateMinusNMonths(_wDateValue);
        break;

    case CDFFUFE_SizeLE:
        _iSizeType = 2;
        _dwSize = VariantToUINT(vValue);
        break;

    case CDFFUFE_SizeGE:
        _iSizeType = 1;
        _dwSize = VariantToUINT(vValue);
        break;

    case CDFFUFE_TextCaseSen:
        _fTextCaseSen = VariantToBOOL(vValue);
        break;

    case CDFFUFE_TextReg:
        _fTextReg = VariantToBOOL(vValue);
        break;

    case CDFFUFE_SearchSlowFiles:
        _fSearchSlowFiles = VariantToBOOL(vValue);
        break;

    case CDFFUFE_QueryDialect:
        _ulQueryDialect = VariantToUINT(vValue);
        break;

    case CDFFUFE_WarningFlags:
        _dwWarningFlags = VariantToUINT(vValue);
        break;

    case CDFFUFE_SearchSystemDirs:
        _fSearchSystemDirs = VariantToBOOL(vValue);
        break;

    case CDFFUFE_SearchHidden:
        _fSearchHidden = VariantToBOOL(vValue);
        break;
    }
    return S_OK;
}

void CFindFilter::_ResetRoots()
{
    _szPath[0] = 0;
    ATOMICRELEASE(_penumRoots);
}

HRESULT CFindFilter::ResetFieldsToDefaults()
{
    // Try to reset everything that our UpdateFields may touch to make sure next search gets all

    _ResetRoots();

    _fTopLevelOnly = FALSE;
    _szUserInputFileSpec[0] = 0;
    _szText[0] = 0;
    if (_pszIndexedSearch)
        *_pszIndexedSearch = 0;
    _strTypeFilePatterns.Reset();

    ZeroMemory(&_scidDate, sizeof(_scidDate));
    _scidSize = SCID_SIZE;

    _fFoldersOnly = FALSE;
    _wDateType = 0;
    _dateModifiedBefore = 0;
    _dateModifiedAfter = 0;
    _iSizeType = 0;
    _dwSize = 0;
    _fTextCaseSen = FALSE;
    _fTextReg = FALSE;
    _fSearchSlowFiles = FALSE;
    _ulQueryDialect = ISQLANG_V2;
    _dwWarningFlags = DFW_DEFAULT;
    _fSearchSystemDirs = FALSE;

    // the search UI will usually override this, but if that us has not been updated
    // we need to set out state the same was as before here
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    _fSearchHidden = ss.fShowAllObjects;
    return S_OK;
}

HRESULT CFindFilter::GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound)
{
    *pName = NULL;
    VariantClear(pValue);                            
    *pfFound = FALSE;

    if (fReset)
        _iNextConstraint = 0;

    HRESULT hr = S_FALSE;    // not found

    // we don't go to array size as the last entry is an empty item...
    while (_iNextConstraint < ARRAYSIZE(s_cdffuf))
    {
        switch (s_cdffuf[_iNextConstraint].cdffufe)
        {
        case CDFFUFE_IndexedSearch:
            hr = InitVariantFromStr(pValue, _pszIndexedSearch);
            break;
    
        case CDFFUFE_LookIn:
            hr = InitVariantFromStr(pValue, _szPath);
            break;
    
        case CDFFUFE_IncludeSubFolders:
            hr = InitVariantFromInt(pValue, _fTopLevelOnly ? 0 : 1);
            break;
    
        case CDFFUFE_Named:
            hr = InitVariantFromStr(pValue, _szUserInputFileSpec);
            break;
    
        case CDFFUFE_ContainingText:
            hr = InitVariantFromStr(pValue, _szText);
            break;
    
        case CDFFUFE_FileType:
            hr = InitVariantFromStr(pValue, _strTypeFilePatterns);
            break;

        case CDFFUFE_WhichDate:
            pValue->lVal = MapDateSCIDToValue(&_scidDate);
            if (pValue->lVal)
                hr = InitVariantFromInt(pValue, pValue->lVal);
            break;

        case CDFFUFE_DateLE:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_BETWEEN)
                hr = InitVariantFromDosDateTime(pValue, _dateModifiedBefore, 0);
            break;

        case CDFFUFE_DateGE:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_BETWEEN)
                hr = InitVariantFromDosDateTime(pValue, _dateModifiedAfter, 0); 
            break;

        case CDFFUFE_DateNDays:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_DAYS)
                hr = InitVariantFromInt(pValue, _wDateValue);
            break;

        case CDFFUFE_DateNMonths:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_MONTHS)
                hr = InitVariantFromInt(pValue, _wDateValue);
            break;

        case CDFFUFE_SizeLE:
            if (_iSizeType == 2)
                hr = InitVariantFromUINT(pValue, _dwSize);
            break;

        case CDFFUFE_SizeGE:
            if (_iSizeType == 1)
                hr = InitVariantFromUINT(pValue, _dwSize);
            break;

        case CDFFUFE_TextCaseSen:
            hr = InitVariantFromInt(pValue, _fTextCaseSen ? 1 : 0);
            break;

        case CDFFUFE_TextReg:
            hr = InitVariantFromInt(pValue, _fTextReg ? 1 : 0);
            break;

        case CDFFUFE_SearchSlowFiles:
            hr = InitVariantFromInt(pValue, _fSearchSlowFiles ? 1 : 0);
            break;

        case CDFFUFE_QueryDialect:
            hr = InitVariantFromUINT(pValue, _ulQueryDialect);
            break;

        case CDFFUFE_WarningFlags:
            hr = InitVariantFromUINT(pValue, _dwWarningFlags);
            break;

        case CDFFUFE_SearchSystemDirs:
            hr = InitVariantFromUINT(pValue, _fSearchSystemDirs ? 1 : 0);
            break;

        case CDFFUFE_SearchHidden:
            hr = InitVariantFromUINT(pValue, _fSearchHidden ? 1 : 0);
            break;
        }

        if (S_OK == hr)
            break;

        if (SUCCEEDED(hr))
            VariantClear(pValue);

        _iNextConstraint += 1;
    }

    if (S_OK == hr)
    {
        *pName = SysAllocString(s_cdffuf[_iNextConstraint].pwszField);
        if (NULL == *pName)
        {
            VariantClear(pValue);                            
            hr = E_OUTOFMEMORY;
        }
        else
            *pfFound = TRUE;

        _iNextConstraint += 1; // for the next call here
    }
    return hr;    // no error let script use the found field...
}


DWORD CFindFilter::_AddToQuery(LPWSTR *ppszBuf, DWORD *pcchBuf, LPWSTR pszAdd)
{
    DWORD cchAdd = lstrlenW(pszAdd);

    if (*ppszBuf && *pcchBuf > cchAdd)
    {
        StrCpyNW(*ppszBuf, pszAdd, *pcchBuf);
        *pcchBuf -= cchAdd;
        *ppszBuf += cchAdd;
    }
    return cchAdd;
}


DWORD AddQuerySep(DWORD *pcchBuf, LPWSTR *ppszCurrent, WCHAR  bSep)
{
    LPWSTR pszCurrent = *ppszCurrent;
    // make sure we have room for us plus terminator...
    if (*ppszCurrent && *pcchBuf >= 4)
    {
        *pszCurrent++ = L' ';
        *pszCurrent++ = bSep;
        *pszCurrent++ = L' ';

        *ppszCurrent = pszCurrent;
        *pcchBuf -= 3;
    }
    return 3; // size necessary
}


DWORD PrepareQueryParam(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent)
{
    if (*pbFirst)
    {
        *pbFirst = FALSE;
        return 0;  // no size necessary
    }
        
    // we're not the first property
    return AddQuerySep(pcchBuf, ppszCurrent, L'&');
}

// pick the longest date query so we can avoid checking the buffer size each time we
// add something to the string
#define LONGEST_DATE  50 //lstrlen(TEXT("{prop name=access} <= 2000/12/31 23:59:59{/prop}"))+2

DWORD CFindFilter::_QueryDosDate(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, WORD wDate, BOOL bBefore)
{
    LPWSTR pszCurrent = *ppszCurrent;
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, &pszCurrent);
    
    if (pszCurrent && *pcchBuf > LONGEST_DATE)
    {
        FILETIME ftLocal;
        DosDateTimeToFileTime(wDate, 0, &ftLocal);
        FILETIME ftGMT;
        LocalFileTimeToFileTime(&ftLocal, &ftGMT);
        SYSTEMTIME st;
        FileTimeToSystemTime(&ftGMT, &st);

        IPropertyUI *ppui;
        if (SUCCEEDED(_GetPropertyUI(&ppui)))
        {
            WCHAR szName[128];
            if (SUCCEEDED(ppui->GetCannonicalName(_scidDate.fmtid, _scidDate.pid, szName, ARRAYSIZE(szName))))
            {
                 wnsprintfW(pszCurrent, *pcchBuf, L"{prop name=%s} ", szName);
                 // the date syntax we use is V2, so force this dialect
                _ulQueryDialect = ISQLANG_V2;
            }
            ppui->Release();
        }

        pszCurrent += lstrlenW(pszCurrent);
        if (bBefore)
        {
            *pszCurrent++ = L'<';
            // if you ask for a range like: 2/20/98 - 2/20/98 then we get no time at all
            // So for before, convert H:m:ss to 23:59:59...
            st.wHour = 23;
            st.wMinute = 59; 
            st.wSecond = 59;
        }
        else
        {
            *pszCurrent++ = L'>';
        }
        
        *pszCurrent++ = L'=';

        wnsprintfW(pszCurrent, *pcchBuf, L" %d/%d/%d %d:%d:%d{/prop}", st.wYear, st.wMonth, st.wDay,
            st.wHour, st.wMinute, st.wSecond);
        pszCurrent += lstrlenW(pszCurrent);
        
        *ppszCurrent = pszCurrent;
        *pcchBuf -= LONGEST_DATE;
    }
    return cchNeeded + LONGEST_DATE;
}

DWORD CFindFilter::_CIQueryFilePatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPCWSTR pszFilePatterns)
{
    WCHAR szNextPattern[MAX_PATH];  // overkill in size
    BOOL fFirst = TRUE;
    LPCWSTR pszNextPattern = pszFilePatterns;
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    // Currently will have to long hand the query, may try to find shorter format once bugs
    // are fixed...
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"(");
    while ((pszNextPattern = NextPathW(pszNextPattern, szNextPattern, ARRAYSIZE(szNextPattern))) != NULL)
    {
        if (!fFirst)
        {
            cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L" | ");
        }
        fFirst = FALSE;
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"#filename ");
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, szNextPattern);
    }
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L")");
    return cchNeeded;
}


DWORD CFindFilter::_CIQueryTextPatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText, BOOL bTextReg)
{
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"{prop name=all}");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, bTextReg? L"{regex}" : L"{phrase}");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, pszText);
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, bTextReg? L"{/regex}{/prop}" : L"{/phrase}{/prop}");

    return cchNeeded;
}

#define MAX_DWORD_LEN  18

DWORD CFindFilter::_CIQuerySize(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, DWORD dwSize, int iSizeType)
{
    WCHAR szSize[MAX_DWORD_LEN+8]; // +8 for " {/prop}"
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"{prop name=size} ");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, iSizeType == 1? L">" : L"<");
            
    wnsprintfW(szSize, *pcchBuf, L" %d{/prop}", dwSize);
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, szSize);

    return cchNeeded;
}

DWORD CFindFilter::_CIQueryIndex(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText)
{
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, pszText);
    return cchNeeded;
}

DWORD CFindFilter::_CIQueryShellSettings(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent)
{
    DWORD cchNeeded = 0;
    
    if (!ShowSuperHidden())
    {
        cchNeeded += PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"NOT @attrib ^a 0x6 ");// don't show files w/ hidden and system bit on
    }

    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    if (!ss.fShowAllObjects)
    {
        cchNeeded += PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"NOT @attrib ^a 0x2 "); // don't show files w/ hidden bit on
    }
    return cchNeeded;
}


//  Helper function to add the PIDL from theCsidl to the exclude tree.
void _AddSystemDirCSIDLToPidlTree(int csidl, CIDLTree *ppidlTree)
{
    LPITEMIDLIST pidl = SHCloneSpecialIDList(NULL, csidl, TRUE);
    if (pidl)
    {
        ppidlTree->AddData(IDLDATAF_MATCH_RECURSIVE, pidl, EXCLUDE_SYSTEMDIR);
        ILFree(pidl);
    }
}


CNamespaceEnum::CNamespaceEnum(IFindFilter *pfilter, IShellFolder* psf, 
                               IFindEnum *penumAsync, IEnumIDList *penumScopes, 
                               HWND hwnd, DWORD grfFlags, LPTSTR pszProgressText) :   
    _cRef(1), _pfilter(pfilter), _iFolder(-1), _hwnd(hwnd), _grfFlags(grfFlags), 
    _pszProgressText(pszProgressText), _penumAsync(penumAsync)
{
    ASSERT(NULL == _psf);
    ASSERT(NULL == _pidlFolder);
    ASSERT(NULL == _pidlCurrentRootScope);
    ASSERT(NULL == _penum);

    if (penumScopes)
        penumScopes->Clone(&_penumScopes);

    _pfilter->AddRef();
    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
    ASSERT(_pff);

    if (_penumAsync) 
        _penumAsync->AddRef();

    // Setup the exclude system directories:
    if (!(_grfFlags & DFOO_SEARCHSYSTEMDIRS))
    {
        // IE History and cache are excluded based on the CLSID.
        _AddSystemDirCSIDLToPidlTree(CSIDL_WINDOWS, &_treeExcludeFolders);
        _AddSystemDirCSIDLToPidlTree(CSIDL_PROGRAM_FILES, &_treeExcludeFolders);

        //  Exclude Temp folder
        TCHAR szPath[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(szPath), szPath))
        {
            LPITEMIDLIST pidl = ILCreateFromPath(szPath);
            if (pidl)
            {   
                _treeExcludeFolders.AddData(IDLDATAF_MATCH_RECURSIVE, pidl, EXCLUDE_SYSTEMDIR);
                ILFree(pidl);
            }
        }
    }
}

CNamespaceEnum::~CNamespaceEnum()
{
    ATOMICRELEASE(_penumScopes);

    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_penumAsync);
    ATOMICRELEASE(_pff);

    ILFree(_pidlFolder);    // accepts NULL
    ILFree(_pidlCurrentRootScope);
}

STDMETHODIMP CNamespaceEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
//        QITABENT(CNamespaceEnum, IFindEnum),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNamespaceEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNamespaceEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

// Check if the relative pidl passed is to a folder that we are going 
// skip based on its CLSID:
// This will be used to skip IE History and IE Cache.
BOOL CNamespaceEnum::_IsSystemFolderByCLSID(LPCITEMIDLIST pidl)
{
    BOOL bRetVal = FALSE;
    IShellFolder2 *psf2;
    if (_psf && SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        CLSID clsid;
        if (SUCCEEDED(GetItemCLSID(psf2, pidl, &clsid)))
        {
            if (IsEqualCLSID(clsid, CLSID_CacheFolder) ||
                IsEqualCLSID(clsid, CLSID_CacheFolder2) ||
                IsEqualCLSID(clsid, CLSID_HistFolder))
            {
                bRetVal = TRUE;
            }
        }  
        psf2->Release();
    }
    return bRetVal;
}

// given the fact that a file is a directory, is this one we should search???

BOOL CNamespaceEnum::_ShouldPushItem(LPCITEMIDLIST pidl)
{
    BOOL bShouldPush = FALSE;
    TCHAR szName[MAX_PATH];

    // folders only, not folder shortcuts (note, this includes SFGAO_STREAM objects, .zip/.cab files)
    // skip all folders that start with '?'. these are folders that the names got trashed in some
    // ansi/unicode round trip. this avoids problems in the web folders name space

    if (SFGAO_FOLDER == SHGetAttributes(_psf, pidl, SFGAO_FOLDER | SFGAO_LINK) &&
        SUCCEEDED(DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))) &&
        (TEXT('?') != szName[0]))
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidlFolder, pidl);
        if (pidlFull)
        {
            INT_PTR i = 0;
            
            // Check if the folder is in the exclude list because it has been searched
            HRESULT hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, pidlFull, &i, NULL);

            if (FAILED(hr))
            {
                // see if an alias version of this pidl is exists
                LPITEMIDLIST pidlAlias = SHLogILFromFSIL(pidlFull);
                if (pidlAlias)
                {
                    hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, pidlAlias, &i, NULL);
                    ILFree(pidlAlias);
                }
            }

            if (FAILED(hr))
            {
                // If we still think it should be added, check if we can reject it based
                // on its CSILD.  We will only exclude system folders this way.
                bShouldPush = (_grfFlags & DFOO_SEARCHSYSTEMDIRS) || 
                              (!_IsSystemFolderByCLSID(pidl));
            }
            else if (i == EXCLUDE_SYSTEMDIR)
            {
                //  If it is under a system directory exclude, check to see if it is the 
                //  directory or a sub directory.  We want to exclude the exact directory
                //  so that we don't add a system directory to the list of things to search.
                //  Since we may have specified the directory in the list of places to search
                //  and therefore want to search it, we don't want to exclude sub directories 
                //  that way.
                hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_EXACT, pidlFull, &i, NULL);
                if (FAILED(hr))
                {
                    //  If we get here, it means that pidlFull is a sub directory of a 
                    //  system directory which was searched because it was explicitly
                    //  specified in the list of scopes to search.  Therefore we want
                    //  to continue to search the sub directories.
                    bShouldPush = TRUE;
                }
            } 
            else
            {
                // It matched an item in the tree and was not EXCLUDE_SYSTEMDIR:
                ASSERT(i == EXCLUDE_SEARCHED);
            }
            
            ILFree(pidlFull);
        }
    }

    return bShouldPush;
}

IShellFolder *CNamespaceEnum::_NextRootScope()
{
    IShellFolder *psf = NULL;

    if (_penumScopes)
    {
        LPITEMIDLIST pidl;
        if (S_OK == _penumScopes->Next(1, &pidl, NULL))
        {
            SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf));
            ILFree(pidl);
        }
    }
    return psf;
}

STDMETHODIMP CNamespaceEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, 
                                  int *pcFoldersSearched, BOOL *pfContinue, int *piState)
{
    *ppidl = NULL;
    *piState = GNF_NOMATCH;
    HRESULT hrRet = S_FALSE;
    
    while (S_OK != hrRet && *pfContinue)
    {
        // Retrieve an enumerator if we don't already have one.
        while (NULL == _penum)
        {
            // Indicates that we have taken scope from _penumScopes
            BOOL fUseRootScope = FALSE;

            ASSERT(NULL == _psf);

            // first try popping subdirs off folder stack

            _psf = _queSubFolders.Remove();

            // If there are no folders pushed, then try to get on from the caller.. (root scopes)
            if (NULL == _psf) 
            {
                // Since we are getting a new root scope, add old one to exclude list
                if (_pidlCurrentRootScope)
                {                
                    // Add to exclude List.
                    if (_grfFlags & DFOO_INCLUDESUBDIRS)
                    {
                        // Since all sub directories will be search, don't search again.
                        _treeExcludeFolders.AddData(IDLDATAF_MATCH_RECURSIVE, _pidlCurrentRootScope, EXCLUDE_SEARCHED);
                    }
                    else
                    {
                        // Since sub directories have not been search, allow them to be searched.
                        _treeExcludeFolders.AddData(IDLDATAF_MATCH_EXACT, _pidlCurrentRootScope, EXCLUDE_SEARCHED);
                    }

                    ILFree(_pidlCurrentRootScope);
                    _pidlCurrentRootScope = NULL;
                }
            
                // Get scope from list passed in from caller (root scopes)
                _psf = _NextRootScope();

                fUseRootScope = TRUE;
            }
            
            if (_psf)
            {
                HRESULT hrT = SHGetIDListFromUnk(_psf, &_pidlFolder);

                if (SUCCEEDED(hrT) && fUseRootScope)
                {
                    // Check if the pidl is in the tree
                    INT_PTR i = 0;
                    HRESULT hrMatch = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, _pidlFolder, &i, NULL);
  
                    // If we have a new root scope, set that up as current root scope pidl:
                    // We only want to skip pidls from the queue of "root" search scopes
                    // if they have already been searched.  We do not want to exclude a directory
                    // (from exclude system directories) if it is an explicit search scope.
                    if (FAILED(hrMatch) || i == EXCLUDE_SYSTEMDIR)
                    {
                        ASSERT(_pidlCurrentRootScope == NULL);
                        _pidlCurrentRootScope = ILClone(_pidlFolder);
                    }
                    else
                    {
                        // Since the PIDL is in the exclude tree, we do not want to search it.
                        hrT = E_FAIL;
                    }
                }

                if (SUCCEEDED(hrT))
                {
                    //  Check that we have a pidl, that it is not to be excluded, and that it can
                    //  be enumerated.

                    SHCONTF contf = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                    if (_grfFlags & DFOO_SHOWALLOBJECTS) 
                        contf |= SHCONTF_INCLUDEHIDDEN;
                    hrT = _psf->EnumObjects(_hwnd, contf, &_penum);

                    // only do UI on the first enum, all others are silent
                    // this makes doing search on A:\ produce the insert media
                    // prompt, but searching MyComputer does not prompt for all
                    // empty media
                    _hwnd = NULL;   

                    if (S_OK == hrT)
                    {
                        SHGetNameAndFlags(_pidlFolder, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, _pszProgressText, MAX_PATH, NULL);
                        (*pcFoldersSearched)++;
                    }
                }

                // Check for cleaning up...
                if (hrT != S_OK)
                {
                    ASSERT(NULL == _penum);
                    ATOMICRELEASE(_psf);    // and continue...
                    ILFree(_pidlFolder);
                    _pidlFolder = NULL;
                }
            }
            else // no scope
            {
                *piState = GNF_DONE;
                return hrRet;
            }
        }

        // Retrieve item
        LPITEMIDLIST pidl;
        HRESULT hrEnum = S_FALSE;

        while ((S_OK != hrRet) && *pfContinue && (S_OK == (hrEnum = _penum->Next(1, &pidl, NULL))))
        {
            (*pcObjectSearched)++;

            //  Determine if this is a subfolder that should be recursively searched.
            if (_grfFlags & DFOO_INCLUDESUBDIRS)
            {
                if (_ShouldPushItem(pidl))
                {
                    // queue folder to stack of subfolders to be searched in the next round.
                    _queSubFolders.Add(_psf, pidl);
                }
            }

            //  Test item against search criteria:
            if (_pfilter->MatchFilter(_psf, pidl))
            {
                // folder has not been registered with docfind folder?
                if (_iFolder < 0)
                {
                    // add folder to folder list.
                    _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
                    ASSERT(_iFolder >= 0);
                }
                
                // add docfind goo to pidl
                hrRet = _pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl);
                if (SUCCEEDED(hrRet))
                    *piState = GNF_MATCH;
            }
            else
            {
                ASSERT(GNF_NOMATCH == *piState);
                hrRet = S_OK;   // exit loop, without a match
            }
            ILFree(pidl);
        }


        if (!*pfContinue)
        {
            *piState = GNF_DONE;
            hrEnum = S_FALSE;
        }
        
        if (S_OK != hrEnum)
        {
            // Done enumerating this folder - clean up for next iteration; or..
            // Failed miserably - clean up prior to bail.
            ATOMICRELEASE(_penum);
            ATOMICRELEASE(_psf);
            ILFree(_pidlFolder);
            _pidlFolder = NULL;
            _iFolder = -1;
        }
    }
    return hrRet;
}

STDMETHODIMP CNamespaceEnum::StopSearch()
{
    if (_penumAsync)
        return _penumAsync->StopSearch();
    return E_NOTIMPL;
}

STDMETHODIMP_(BOOL) CNamespaceEnum::FQueryIsAsync()
{
    if (_penumAsync)
        return DF_QUERYISMIXED;    // non-zero special number to say both...
    return FALSE;
}

STDMETHODIMP CNamespaceEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    if (_penumAsync)
        return _penumAsync->GetAsyncCount(pdwTotalAsync, pnPercentComplete, pfQueryDone);

    *pdwTotalAsync = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    if (_penumAsync)
        return _penumAsync->GetItemIDList(iItem, ppidl);

    *ppidl = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::GetItemID(UINT iItem, DWORD *puWorkID)
{
    if (_penumAsync)
        return _penumAsync->GetItemID(iItem, puWorkID);

    *puWorkID = (UINT)-1;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::SortOnColumn(UINT iCol, BOOL fAscending)
{
    if (_penumAsync)
        return _penumAsync->SortOnColumn(iCol, fAscending);

    return E_NOTIMPL;
}


// Masks used to indicate which search operation we are doing.
#define AND_MASK            0x01
#define OR_MASK             0x02
#define SEMICOLON_MASK      0x04
#define COMMA_MASK          0x08
#define EXTENSION_MASK      0x10

// Both "*" and "?" are treated as wildcards.

BOOL SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR *ppszSpecOut)
{
    LPTSTR pszIn = pszSpecIn;
    BOOL fQuote;
    TCHAR szSpecOut[3*MAX_PATH];   // Rather large...

    // Read in localized versions of AND/OR used for searching
    TCHAR szAND[20];
    LoadString(HINST_THISDLL, IDS_FIND_AND, szAND, ARRAYSIZE(szAND));
    TCHAR szOR[20];
    LoadString(HINST_THISDLL, IDS_FIND_OR, szOR, ARRAYSIZE(szOR));

    // Masks and variable to indicate what operation we are going to perform.
    UINT iOperation  = 0;      // Bitmask to store which operation we have selected.

    // allocate a buffer that should be able to hold the resultant
    // string.  When all is said and done we'll re-allocate to the
    // correct size.

    LPTSTR pszOut = szSpecOut;
    while (*pszIn != 0)
    {
        TCHAR  c;                       // The delimiter.
        LPTSTR pszT;
        int    ich;

        // Strip in leading spaces out of there
        while (*pszIn == TEXT(' '))
            pszIn++;

        if (*pszIn == 0)
            break;

        // If we are beyond the first item, add a seperator between the tokens
        if (pszOut != szSpecOut)
            *pszOut++ = TEXT(';');
        
        fQuote = (*pszIn == TEXT('"'));
        if (fQuote)
        {
            // The user asked for something litteral.
           pszT = pszIn = CharNext(pszIn);
           while (*pszT && (*pszT != TEXT('"')))
               pszT = CharNext(pszT);
        }
        else
        {
            pszT = pszIn + (ich = StrCSpn(pszIn, TEXT(",; \""))); // Find end of token
        }

        c = *pszT;       // Save away the seperator character that was found
        *pszT = 0;       // Add null so string functions will work and only extract the token

        // Put in a couple of tests for * and *.*
        if ((lstrcmp(pszIn, c_szStar) == 0) ||
            (lstrcmp(pszIn, c_szStarDotStar) == 0))
        {
            // Complete wild card so set a null criteria
            *pszT = c;              // Restore char;
            pszOut = szSpecOut;     // Set to start of string
            break;
        }
        
        if (fQuote)
        {
            lstrcpy(pszOut, pszIn);
            pszOut += lstrlen(pszIn);
        }
        else if (lstrcmpi(pszIn, szAND) == 0)
        {
            iOperation |= AND_MASK;
            // If we don't move back one character, then "New and folder" will give:
            // "*New*;;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;
        }
        else if (lstrcmpi(pszIn, szOR) == 0)
        {
            iOperation |= OR_MASK;
            // If we don't move back one character, then "New or folder" will give:
            // "*New*;;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;
        }
        else if (*pszIn == 0)
        {
            // If we don't move back one character, then "New ; folder" will give:
            // "*New*;**;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;

            // Check what the seperator is.  This handles instances like
            // ("abba" ; "abba2") where we want an OR search.
            if (c == TEXT(','))
            {
                iOperation |= COMMA_MASK;
            }
            else if (c == TEXT(';'))
            {
                iOperation |= SEMICOLON_MASK;
            }
        }
        else
        {
            // Check what the seperator is:
            if (c == TEXT(','))
            {
                iOperation |= COMMA_MASK;
            }
            else if (c == TEXT(';'))
            {
                iOperation |= SEMICOLON_MASK;
            }
        
            // both "*" and "?" are wildcards.  When checking for wildcards check
            // for both before we conclude there are no wildcards.  If a search
            // string contains both "*" and "?" then we need for pszStar to point
            // to the last occorance of either one (this is assumed in the code
            // below which will add a ".*" when pszStar is the last character).
            // NOTE: I wish there was a StrRPBrk function to do this for me.
            LPTSTR pszStar = StrRChr(pszIn, NULL, TEXT('*'));
            LPTSTR pszAnyC = StrRChr(pszIn, NULL, TEXT('?'));
            if (pszAnyC > pszStar)
                pszStar = pszAnyC;
            if (pszStar == NULL)
            {
                // No wildcards were used:
                *pszOut++ = TEXT('*');
                lstrcpy(pszOut, pszIn);
                pszOut += ich;
                *pszOut++ = TEXT('*');
            }
            else
            {
                // Includes wild cards
                lstrcpy(pszOut, pszIn);
                pszOut += ich;

                pszAnyC = StrRChr(pszIn, NULL, TEXT('.'));
                if (pszAnyC)
                {
                    // extension present, that implies OR search
                    iOperation |= EXTENSION_MASK;
                }
                else
                {
                    // No extension is given
                    if ((*(pszStar+1) == 0) && (*pszStar == TEXT('*')))
                    {
                        // The last character is an "*" so this single string will
                        // match everything you would expect.
                    }
                    else
                    {
                        // Before, given "a*a" we searched for "a*a" as well
                        // as "a*a.*".  We can no longer do that because if we are
                        // doing an AND search, it will exclude any item that does not
                        // match both of the criterial.  For example, "abba" mattches
                        // "a*a" but not "a*a.*" and "abba.txt" matches "a*a.*" but
                        // not "a*a".  Therefore, we append an * to get "a*a*".  This 
                        // will match files like "abba2.wav" which wouldn't previously
                        // have been matched, but it is a small price to pay.
                        *pszOut++ = TEXT('*');  
                    }
                }
            }
        }

        *pszT = c;  // Restore char;
        if (c == 0)
            break;

        // Skip the seperator except if we weren't quoting and the seperator is 
        // a '"' then we found something like (blah"next tag")
        if (*pszT != 0 && !(*pszT == TEXT('"') && !fQuote))
            pszT++;
            
        pszIn = pszT;   // setup for the next item
    }
    
    // Ensure the string is terminated
    *pszOut++ = 0;

    // re-alloc the buffer down to the actual size of the string...
    Str_SetPtr(ppszSpecOut, szSpecOut);
    
    //  Precidence rules to be applied in order:
    //  1. ;        -> OR search
    //  2. AND      -> AND search 
    //  3. , or OR  -> OR search
    //  4. none & explict file extensions -> OR search (files can only have one extension)
    //  5. none     -> AND search
    //  
    //
    // AND   OR  ;   ,   | AND Search
    //  X    X   1   X   |     0
    //  1    X   0   X   |     1
    //  0    \   0   \   |     0    Where one if the '\'s is 1
    //  0    0   0   0   |     1
    return (!(iOperation & SEMICOLON_MASK) && (iOperation & AND_MASK)) || iOperation == 0;
}

WORD CFindFilter::_GetTodaysDosDateMinusNDays(int nDays)
{
    SYSTEMTIME st;
    union
    {
        FILETIME ft;
        LARGE_INTEGER li;
    }ftli;

    WORD FatTime = 0, FatDate = 0;

    // Now we need to
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftli.ft);
    FileTimeToLocalFileTime(&ftli.ft, &ftli.ft);

    // Now decrement the file time by the count of days * the number of
    // 100NS time units per day.  Assume that nDays is positive.
    if (nDays > 0)
    {
        #define NANO_SECONDS_PER_DAY 864000000000
        ftli.li.QuadPart = ftli.li.QuadPart - ((__int64)nDays * NANO_SECONDS_PER_DAY);
    }

    FileTimeToDosDateTime(&ftli.ft, &FatDate, &FatTime);
    DebugMsg(DM_TRACE, TEXT("DocFind %d days = %x"), nDays, FatDate);
    return FatDate;
}

WORD CFindFilter::_GetTodaysDosDateMinusNMonths(int nMonths)
{
    SYSTEMTIME st;
    FILETIME ft;
    WORD FatTime, FatDate;

    GetSystemTime(&st);
    st.wYear -= (WORD) nMonths / 12;
    nMonths = nMonths % 12;
    if (nMonths < st.wMonth)
        st.wMonth -= (WORD) nMonths;
    else
    {
        st.wYear--;
        st.wMonth = (WORD)(12 - (nMonths - st.wMonth));
    }

    // Now normalize back to a valid date.
    while (!SystemTimeToFileTime(&st, &ft))
    {
        st.wDay--;  // must not be valid date for month...
    }

    if (!FileTimeToLocalFileTime(&ft, &ft) || !FileTimeToDosDateTime(&ft, &FatDate,&FatTime))
        FatDate = 0; //search for all the files from beginning of time (better to find more than less)
        
    DebugMsg(DM_TRACE, TEXT("DocFind %d months = %x"), nMonths, FatDate);
    return FatDate;
}

void CFindFilter::_DosDateToSystemtime(WORD wFatDate, SYSTEMTIME *pst)
{
    ZeroMemory(pst, sizeof(*pst));
    pst->wDay = wFatDate & 0x001F;
    pst->wMonth = (wFatDate >> 5) & 0x000F;
    pst->wYear = 1980 + ((wFatDate >> 9) & 0x007F);
    DebugMsg(DM_TRACE, TEXT("DocFind %x -> %d/%d/%d"), wFatDate, pst->wDay, pst->wMonth, pst->wYear);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findcmd.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "dspsprt.h"
#include "findfilter.h"
#include "cowsite.h"
#include "cobjsafe.h"
#include "cnctnpt.h"
#include "stdenum.h"
#include "exdisp.h"
#include "exdispid.h"
#include "shldisp.h"
#include "shdispid.h"
#include "dataprv.h"
#include "ids.h"
#include "views.h"
#include "findband.h"

#define WM_DF_SEARCHPROGRESS        (WM_USER + 42)
#define WM_DF_ASYNCPROGRESS         (WM_USER + 43)
#define WM_DF_SEARCHSTART           (WM_USER + 44)
#define WM_DF_SEARCHCOMPLETE        (WM_USER + 45)
#define WM_DF_FSNOTIFY              (WM_USER + 46)

STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

typedef struct 
{
    BSTR        bstrName;
    VARIANT     vValue;
} CMD_CONSTRAINT; 

typedef struct
{
    LPTSTR  pszDotType;
    LPTSTR  pszDefaultValueMatch;
    LPTSTR  pszGuid;                // If NULL, patch either pszDefaultValueMatch, or pszDotType whichever you find
} TYPE_FIX_ENTRY;

class CFindCmd : public ISearchCommandExt,
                   public CImpIDispatch, 
                   public CObjectWithSite, 
                   public CObjectSafety, 
                   public IConnectionPointContainer,
                   public IProvideClassInfo2,
                   public CSimpleData,
                   public IRowsetWatchNotify,
                   public IFindControllerNotify
{    
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // IConnectionPointContainer
    STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

    // IProvideClassInfo
    STDMETHOD(GetClassInfo)(ITypeInfo **ppTI);

    // IProvideClassInfo2
    STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID *pGUID);

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite);

    // ISearchCommandExt
    STDMETHOD(ClearResults)(void);
    STDMETHOD(NavigateToSearchResults)(void);
    STDMETHOD(get_ProgressText)(BSTR *pbs);
    STDMETHOD(SaveSearch)(void);
    STDMETHOD(RestoreSearch)(void);
    STDMETHOD(GetErrorInfo)(BSTR *pbs,  int *phr);
    STDMETHOD(SearchFor)(int iFor);
    STDMETHOD(GetScopeInfo)(BSTR bsScope, int *pdwScopeInfo);
    STDMETHOD(RestoreSavedSearch)(VARIANT *pvarFile);
    STDMETHOD(Execute)(VARIANT *RecordsAffected, VARIANT *Parameters, long Options);
    STDMETHOD(AddConstraint)(BSTR Name, VARIANT Value);        
    STDMETHOD(GetNextConstraint)(VARIANT_BOOL fReset, DFConstraint **ppdfc);

    // IRowsetWatchNotify
    STDMETHODIMP OnChange(IRowset *prowset, DBWATCHNOTIFY eChangeReason);

    // IFindControllerNotify
    STDMETHODIMP DoSortOnColumn(UINT iCol, BOOL fSameCol);
    STDMETHODIMP StopSearch(void);
    STDMETHODIMP GetItemCount(UINT *pcItems);
    STDMETHODIMP SetItemCount(UINT cItems);
    STDMETHODIMP ViewDestroyed();

    CFindCmd();
    HRESULT Init(void);

private:
    ~CFindCmd();
    HRESULT _GetSearchIDList(LPITEMIDLIST *ppidl);
    HRESULT _SetEmptyText(UINT nID);
    HRESULT _Clear();
    void _SelectResults();
    HWND _GetWindow();

    struct THREAD_PARAMS {
        CFindCmd    *pThis;
        IFindEnum   *penum;
    };

    struct DEFER_UPDATE_DIR {
        struct DEFER_UPDATE_DIR *pdudNext;
        LPITEMIDLIST            pidl;
        BOOL                    fRecurse;
    };

    // Internal class to handle notifications from top level browser
    class CWBEvents2: public DWebBrowserEvents, DWebBrowserEvents2
    {
    public:
        STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void) { return _pcdfc->AddRef();}
        STDMETHOD_(ULONG, Release)(void) { return _pcdfc->Release();}
    
        // (DwebBrowserEvents)IDispatch
        STDMETHOD(GetTypeInfoCount)(UINT * pctinfo) { return E_NOTIMPL;}
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL;}
        STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) { return E_NOTIMPL;}
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

        // Some helper functions...
        void SetOwner(CFindCmd *pcdfc) { _pcdfc = pcdfc; }  // Don't addref as part of larger object... }
        void SetWaiting(BOOL fWait) {_fWaitingForNavigate = fWait;}

    protected:
        // Internal variables...
        CFindCmd *_pcdfc;     // pointer to top object... could cast, but...
        BOOL _fWaitingForNavigate;   // Are we waiting for the navigate to search resluts?
    };

    friend class CWBEvents2;
    CWBEvents2              _cwbe;
    IConnectionPoint        *_pcpBrowser;   // hold onto browsers connection point;
    ULONG                   _dwCookie;      // Cookie returned by Advise

    HRESULT                 _UpdateFilter(IFindFilter *pfilter);
    void                    _ClearConstraints();
    static DWORD CALLBACK   _ThreadProc(void *pv);
    void                    _DoSearch(IFindEnum *penum);
    HRESULT                 _Start(BOOL fNavigateIfFail, int iCol, LPCITEMIDLIST pidlUpdate);
    HRESULT                 _Cancel();
    HRESULT                 _Init(THREAD_PARAMS **ppParams, int iCol, LPCITEMIDLIST pidlUpdate);
    static HRESULT          _FreeThreadParams(THREAD_PARAMS *ptp);
    HRESULT                 _ExecData_Init();
    HRESULT                 _EnsureResultsViewIsCurrent(IUnknown *punk);
    HRESULT                 _ExecData_Release();
    BOOL                    _SetupBrowserCP();
    void cdecl              _NotifyProgressText(UINT ids,...);
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void                    _PTN_SearchProgress(void);
    void                    _PTN_AsyncProgress(int nPercentComplete, DWORD cAsync);
    void                    _PTN_AsyncToSync(void);
    void                    _PTN_SearchComplete(HRESULT hr, BOOL fAbort);
    void                    _OnChangeNotify(LONG code, LPITEMIDLIST *ppidl);
    void                    _DeferHandleUpdateDir(LPCITEMIDLIST pidl, BOOL bRecurse);
    void                    _ClearDeferUpdateDirList();
    void                    _ClearItemDPA(HDPA hdpa);
    HRESULT                 _SetLastError(HRESULT hr);
    void                    _SearchResultsCLSID(CLSID *pclsid) { *pclsid = _clsidResults; };
    IUnknown*               _GetObjectToPersist();
    HRESULT                 _ForcedUnadvise(void);
    void                    _PostMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT                 _GetShellView(REFIID riid, void **ppv);
    BOOL                    _FixPersistHandler(LPCTSTR pszBase, LPCTSTR pszDefaultHandler);
    void                    _ProcessTypes(const TYPE_FIX_ENTRY *ptfeTypes, UINT cTypes, TCHAR *pszClass);
    void                    _FixBrokenTypes(void);

    // These are the things that the second thread will use during it's processing...
    struct {
        CRITICAL_SECTION    csSearch;
        HWND                hwndThreadNotify;
        HDPA                hdpa;
        DWORD               dwTimeLastNotify;   
        BOOL                fFilesAdded : 1;
        BOOL                fDirChanged : 1;
        BOOL                fUpdatePosted : 1;
    } _updateParams; // Pass callback params through this object to avoid alloc/free cycle

    struct {
        IShellFolder        *psf;
        IShellFolderView    *psfv;
        IFindFolder         *pff;
        TCHAR               szProgressText[MAX_PATH];
    } _execData;

private:
    LONG                _cRef;
    HDSA                _hdsaConstraints;
    DWORD               _cExecInProgress;
    BOOL                _fAsyncNotifyReceived;
    BOOL                _fDeferRestore;
    BOOL                _fDeferRestoreTried;
    BOOL                _fContinue;
    BOOL                _fNew;
    CConnectionPoint    _cpEvents;
    OLEDBSimpleProviderListener *_pListener;
    HDPA                _hdpaItemsToAdd1;
    HDPA                _hdpaItemsToAdd2;
    TCHAR               _szProgressText[MAX_PATH+40];   // progress text leave room for chars...
    LPITEMIDLIST        _pidlUpdate;                    // Are we processing an updatedir?
    LPITEMIDLIST        _pidlRestore;                   // pidl to do restore from...
    struct DEFER_UPDATE_DIR *_pdudFirst;                  // Do we have any defered update dirs?
    HRESULT             _hrLastError;                   // the last error reported.
    UINT                _uStatusMsgIndex;               // Files or computers found...
    CRITICAL_SECTION    _csThread;
    DFBSAVEINFO         _dfbsi;
    CLSID               _clsidResults;
};


class CFindConstraint: public DFConstraint, public CImpIDispatch 
{    
public:
    // IUnknown
    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);        
    STDMETHOD_(ULONG, Release)(void);

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // DFConstraint
    STDMETHOD(get_Name)(BSTR *pbs);
    STDMETHOD(get_Value)(VARIANT *pvar);

    CFindConstraint(BSTR bstr, VARIANT var);
private:
    ~CFindConstraint();
    LONG                _cRef;
    BSTR                _bstr;
    VARIANT             _var;
};

CFindCmd::CFindCmd() : CImpIDispatch(LIBID_Shell32, 1, 0, IID_ISearchCommandExt), CSimpleData(&_pListener)
{
    _cRef = 1;
    _fAsyncNotifyReceived = 0;
    _fContinue = TRUE;
    ASSERT(NULL == _pidlRestore);

    ASSERT(_cExecInProgress == 0);

    InitializeCriticalSection(&_updateParams.csSearch);
    InitializeCriticalSection(&_csThread);

    _clsidResults = CLSID_DocFindFolder;    // default

    _cpEvents.SetOwner(SAFECAST(this, ISearchCommandExt *), &DIID_DSearchCommandEvents);
}

HRESULT CFindCmd::Init(void)
{
    _hdsaConstraints = DSA_Create(sizeof(CMD_CONSTRAINT), 4);
    if (!_hdsaConstraints)
        return E_OUTOFMEMORY;
    return S_OK;
}

CFindCmd::~CFindCmd()
{
    if (_updateParams.hwndThreadNotify)
    {
        // make sure no outstanding fsnotifies registered.
        SHChangeNotifyDeregisterWindow(_updateParams.hwndThreadNotify);
        DestroyWindow(_updateParams.hwndThreadNotify);
    }

    _ClearConstraints();
    DSA_Destroy(_hdsaConstraints);
    _ExecData_Release();

    DeleteCriticalSection(&_updateParams.csSearch);
    DeleteCriticalSection(&_csThread);

    // Make sure we have removed all outstanding update dirs...
    _ClearDeferUpdateDirList();

    if (_hdpaItemsToAdd1)
        DPA_Destroy(_hdpaItemsToAdd1);

    if (_hdpaItemsToAdd2)
        DPA_Destroy(_hdpaItemsToAdd2);

    ILFree(_pidlRestore);
}

STDMETHODIMP CFindCmd::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindCmd, ISearchCommandExt),
        QITABENTMULTI(CFindCmd, IDispatch, ISearchCommandExt),
        QITABENT(CFindCmd, IProvideClassInfo2),
        QITABENTMULTI(CFindCmd, IProvideClassInfo,IProvideClassInfo2),
        QITABENT(CFindCmd, IObjectWithSite),
        QITABENT(CFindCmd, IObjectSafety),
        QITABENT(CFindCmd, IConnectionPointContainer),
        QITABENT(CFindCmd, OLEDBSimpleProvider),
        QITABENT(CFindCmd, IRowsetWatchNotify),
        QITABENT(CFindCmd, IFindControllerNotify),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindCmd::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindCmd::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

// IDispatch implementation

STDMETHODIMP CFindCmd::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFindCmd::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFindCmd::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP CFindCmd::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

// ADOCommand implementation, dual interface method callable via script

STDMETHODIMP CFindCmd::AddConstraint(BSTR bstrName, VARIANT vValue)
{
    HRESULT hr = E_OUTOFMEMORY;

    CMD_CONSTRAINT dfcc = {0};
    dfcc.bstrName = SysAllocString(bstrName);
    if (dfcc.bstrName)
    {
        hr = VariantCopy(&dfcc.vValue, &vValue);
        if (SUCCEEDED(hr))
        {
            if (DSA_ERR == DSA_InsertItem(_hdsaConstraints, DSA_APPEND, &dfcc))
            {
                SysFreeString(dfcc.bstrName);
                VariantClear(&dfcc.vValue);
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            SysFreeString(dfcc.bstrName);
        }
    }
    return hr;
}

STDMETHODIMP CFindCmd::GetNextConstraint(VARIANT_BOOL fReset, DFConstraint **ppdfc)
{
    *ppdfc = NULL;

    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr))
    {
        BSTR bName;
        VARIANT var;
        VARIANT_BOOL fFound;
        hr = pfilter->GetNextConstraint(fReset, &bName, &var, &fFound);
        if (SUCCEEDED(hr))
        {
            if (!fFound)
            {
                // need a simple way to signal end list, how about an empty name string?
                bName = SysAllocString(L"");
            }
            CFindConstraint *pdfc = new CFindConstraint(bName, var);
            if (pdfc)
            {
                hr = pdfc->QueryInterface(IID_PPV_ARG(DFConstraint, ppdfc));
                pdfc->Release();
            }
            else
            {
                // error release stuff we allocated.
                hr = E_OUTOFMEMORY;
                SysFreeString(bName);
                VariantClear(&var);
            }
        }
        pfilter->Release();
    }
    return hr;
}

HRESULT CFindCmd::_UpdateFilter(IFindFilter *pfilter)
{
    HRESULT hr = S_OK;

    pfilter->ResetFieldsToDefaults();

    int cNumParams = DSA_GetItemCount(_hdsaConstraints); 
    for (int iItem = 0; iItem < cNumParams; iItem++)
    {
        CMD_CONSTRAINT *pdfcc = (CMD_CONSTRAINT *)DSA_GetItemPtr(_hdsaConstraints, iItem);
        if (pdfcc)
        {
            hr = pfilter->UpdateField(pdfcc->bstrName, pdfcc->vValue);
        }
    }

    // And clear out the constraint list...
    _ClearConstraints();
    return hr;
}

void CFindCmd::_ClearConstraints()
{
    int cNumParams = DSA_GetItemCount(_hdsaConstraints); 
    for (int iItem = 0; iItem < cNumParams; iItem++)
    {
        CMD_CONSTRAINT *pdfcc = (CMD_CONSTRAINT *)DSA_GetItemPtr(_hdsaConstraints, iItem);
        if (pdfcc)
        {
            SysFreeString(pdfcc->bstrName);
            VariantClear(&pdfcc->vValue);
        }
    }
    DSA_DeleteAllItems(_hdsaConstraints);
}

void cdecl CFindCmd::_NotifyProgressText(UINT ids,...)
{
    va_list ArgList;
    va_start(ArgList, ids);
    LPTSTR psz = _ConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(ids), &ArgList);
    va_end(ArgList);

    if (psz)
    {
        LPTSTR pszDst = &_szProgressText[0];

        StrCpyN(pszDst, psz, ARRAYSIZE(_szProgressText)-2);

        LocalFree(psz);
    }
    else
    {
        _szProgressText[0] = 0;
    }

    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_PROGRESSTEXT);
}

STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFindCmd *pfc = new CFindCmd();
    if (pfc)
    {
        hr = pfc->Init();
        if (SUCCEEDED(hr))
            hr = pfc->QueryInterface(riid, ppv);
        pfc->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;    
}

void CFindCmd::_PTN_SearchProgress(void)
{
    HRESULT hr = S_OK;
    HDPA hdpa = _updateParams.hdpa;
    if (hdpa) 
    {
        // Ok lets swap things out from under other thread so that we can process it and still
        // let the other thread run...
        EnterCriticalSection(&_updateParams.csSearch);

        if (_updateParams.hdpa == _hdpaItemsToAdd2)
            _updateParams.hdpa = _hdpaItemsToAdd1;
        else
            _updateParams.hdpa = _hdpaItemsToAdd2;

        // say that we don't have any thing here such that other thread will reset up...
        _updateParams.fFilesAdded = FALSE;
        BOOL fDirChanged = _updateParams.fDirChanged;
        _updateParams.fDirChanged = FALSE;

        LeaveCriticalSection(&_updateParams.csSearch);

        int cItemsToAdd = DPA_GetPtrCount(hdpa);

        if (!_execData.pff)
            return;
            
        int iItem;
        _execData.pff->GetItemCount(&iItem);
        int iItemStart = iItem + 1;     // needed for notifies 1 based.

        if (cItemsToAdd)
        {
            if (_fContinue)
            {
                // Are we in an updatedir?  If so then need to do merge, else...
                if (_pidlUpdate)
                {
                    // see if items in list, already if so we unmark the item
                    // for delete else if not there maybe add it...

                    int cItems = iItem;        
                    for (int i = 0; i < cItemsToAdd; i++) 
                    {
                        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                        FIND_ITEM *pfi;

                        for (int j = cItems - 1; j >= 0; j--) 
                        {
                            _execData.pff->GetItem(j, &pfi);
                            if (pfi && (_execData.pff->GetFolderIndex(pidl) == _execData.pff->GetFolderIndex(&pfi->idl))) 
                            {
                                if (_execData.psf->CompareIDs(0, pidl, &pfi->idl) == 0)
                                    break;
                            }
                        }

                        if (j == -1) 
                        {
                            // Not already in the list so add it...
                            hr = _execData.pff->AddPidl(iItem, pidl, -1, NULL);
                            if (SUCCEEDED(hr))
                                iItem++;
                        } 
                        else 
                        {
                            // Item still there - remove possible delete flag...
                            if (pfi)
                                pfi->dwState &= ~CDFITEM_STATE_MAYBEDELETE;
                        }

                        ILFree(pidl);   // The AddPidl does a clone of the pidl...
                    }
                    if (iItem && _execData.psfv)
                    {
                         hr = _execData.psfv->SetObjectCount(iItem, SFVSOC_NOSCROLL);
                    }
                } 
                else 
                {
                    if (_pListener)
                        _pListener->aboutToInsertRows(iItemStart, cItemsToAdd);
                    
                    for (int i = 0; i < cItemsToAdd; i++) 
                    {
                        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                        hr = _execData.pff->AddPidl(iItem, pidl, -1, NULL);
                        if (SUCCEEDED(hr))
                            iItem++;
                        ILFree(pidl);   // AddPidl makes a copy
                    }
        
                    if (iItem >= iItemStart)
                    {
                        if (_execData.psfv)
                            hr = _execData.psfv->SetObjectCount(iItem, SFVSOC_NOSCROLL);
                
                        _execData.pff->SetItemsChangedSinceSort();
                        _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_UPDATE);
                    }

                    if (_pListener) 
                    {
                        _pListener->insertedRows(iItemStart, cItemsToAdd);
                        _pListener->rowsAvailable(iItemStart, cItemsToAdd);
                    }
                }
            }
            else  // _fContinue
            {
                for (int i = 0; i < cItemsToAdd; i++)
                {
                    ILFree((LPITEMIDLIST)DPA_FastGetPtr(hdpa, i));
                }
            }
            DPA_DeleteAllPtrs(hdpa);
        }

        if (fDirChanged) 
        {
            _NotifyProgressText(IDS_SEARCHING, _execData.szProgressText);
        }
    }
    
    _updateParams.dwTimeLastNotify = GetTickCount();
    _updateParams.fUpdatePosted = FALSE;
}

void CFindCmd::_PTN_AsyncProgress(int nPercentComplete, DWORD cAsync)
{
    if (!_execData.pff)
        return;
    // Async case try just setting the count...
    _execData.pff->SetAsyncCount(cAsync);
    if (_execData.psfv) 
    {
        // -1 for the first item means verify visible items only
        _execData.pff->ValidateItems(_execData.psfv, -1, -1, FALSE);
        _execData.psfv->SetObjectCount(cAsync, SFVSOC_NOSCROLL);
    }

    _execData.pff->SetItemsChangedSinceSort();
    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_UPDATE);
    _NotifyProgressText(IDS_SEARCHINGASYNC, cAsync, nPercentComplete);
}

void CFindCmd::_PTN_AsyncToSync()
{
    if (_execData.pff)
        _execData.pff->CacheAllAsyncItems();
}

void CFindCmd::_ClearItemDPA(HDPA hdpa)
{
    if (hdpa)
    {
        EnterCriticalSection(&_updateParams.csSearch);
        int cItems = DPA_GetPtrCount(hdpa);
        for (int i = 0; i < cItems; i++) 
        {
            ILFree((LPITEMIDLIST)DPA_GetPtr(hdpa, i));
        }
        DPA_DeleteAllPtrs(hdpa);
        LeaveCriticalSection(&_updateParams.csSearch);
    }
}

void CFindCmd::_PTN_SearchComplete(HRESULT hr, BOOL fAbort)
{
    int iItem;

    // someone clicked on new button -- cannot set no files found text in listview
    // because we'll overwrite enter search criteria to begin
    if (!_fNew)
        _SetEmptyText(IDS_FINDVIEWEMPTY);
    _SetLastError(hr);

    // _execData.pff is NULL when Searh is complete by navigating away from the search page
    if (!_execData.pff)
    {
        // do clean up of hdpaToItemsToadd1 and 2
        // make sure all items in buffer 1 and 2 are empty
        _ClearItemDPA(_hdpaItemsToAdd1);
        _ClearItemDPA(_hdpaItemsToAdd2);
    }
    else
    {
        // if we have a _pidlUpdate are completing an update
        if (_pidlUpdate)
        {
            int i, cPidf;
            UINT uItem;

            _execData.pff->GetItemCount(&i);
            for (; i-- > 0;)
            {
                // Pidl at start of structure...
                FIND_ITEM *pfi;
                _execData.pff->GetItem(i, &pfi);
                if (pfi->dwState & CDFITEM_STATE_MAYBEDELETE)
                {
                    _execData.psfv->RemoveObject(&pfi->idl, &uItem);
                }
            }                  

            ILFree(_pidlUpdate);
            _pidlUpdate = NULL;

            // clear the update dir flags
            _execData.pff->GetFolderListItemCount(&cPidf);
            for (i = 0; i < cPidf; i++)
            {
                FIND_FOLDER_ITEM *pdffli;
            
                if (SUCCEEDED(_execData.pff->GetFolderListItem(i, &pdffli)))
                    pdffli->fUpdateDir = FALSE;
            }
        }

        // Release our reference count on the searching.
        if (_cExecInProgress)
            _cExecInProgress--;

        // Tell everyone the final count and that we are done...
        // But first check if there are any cached up Updatedirs to be processed...
        if (_pdudFirst) 
        {
            // first unlink the first one...
            struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
            _pdudFirst = pdud->pdudNext;

            if (_execData.pff->HandleUpdateDir(pdud->pidl, pdud->fRecurse)) 
            {
                // Need to spawn sub-search on this...
                _Start(FALSE, -1, pdud->pidl);
            }
            ILFree(pdud->pidl);
            LocalFree((HLOCAL)pdud);
        } 
        else 
        {
            if (_execData.psfv) 
            {
                // validate all the items we pulled in already
                _execData.pff->ValidateItems(_execData.psfv, 0, -1, TRUE);
            }
            _execData.pff->GetItemCount(&iItem);
            _NotifyProgressText(_uStatusMsgIndex, iItem);
            if (!fAbort)
                _SelectResults();
        }
    }

    // weird connection point corruption can happen here.  somehow the number of sinks is 0 but 
    // some of the array entries are non null thus causing fault.  this problem does not want to 
    // repro w/ manual testing or debug binaries, only sometimes after an automation run.  when
    // it happens it is too late to figure out what happened so just patch it here.
    if (_cpEvents._HasSinks())
        _cpEvents.InvokeDispid(fAbort ? DISPID_SEARCHCOMMAND_ABORT : DISPID_SEARCHCOMMAND_COMPLETE);
}

// see if we need to restart the search based on an update dir

BOOL ShouldRestartSearch(LPCITEMIDLIST pidl)
{ 
    BOOL fRestart = TRUE;   // assume we should, non file system pidls

    WCHAR szPath[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // Check if this is either a network drive or a remote drive:
        if (PathIsRemote(szPath))
        {
            // If we can find the CI catalogs for the drive on the other machine, then we do
            // not want to search.

            WCHAR wszCatalog[MAX_PATH], wszMachine[32];
            ULONG cchCatalog = ARRAYSIZE(wszCatalog), cchMachine = ARRAYSIZE(wszMachine);

            fRestart = (S_OK != LocateCatalogsW(szPath, 0, wszMachine, &cchMachine, wszCatalog, &cchCatalog));
        }
        else if (-1 != PathGetDriveNumber(szPath))
        {
            // It is a local dirve...
            // Is this machine running the content indexer (CI)?

            BOOL fCiRunning, fCiIndexed, fCiPermission;
            GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);

            fRestart = !fCiRunning || !fCiIndexed;  // restart if not running or not fully indexed
        }
    }
    
    return fRestart;
}

void CFindCmd::_OnChangeNotify(LONG code, LPITEMIDLIST *ppidl)
{
    LPITEMIDLIST pidlT;
    UINT idsMsg;
    UINT cItems;

    if (!_execData.pff)
    {
        _ExecData_Init();

        // If we are running async then for now ignore notifications...
        // Unless we have cached all of the items...
        if (!_execData.pff)
            return; // we do not have anything to listen...
    }

    // see if we want to process the notificiation or not.
    switch (code)
    {
    case SHCNE_RENAMEFOLDER:    // With trashcan this is what we see...
    case SHCNE_RENAMEITEM:      // With trashcan this is what we see...
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_UPDATEITEM:
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        // Process this one out of place
        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, *ppidl, NULL);
        break;

    case SHCNE_UPDATEDIR:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_UPDATEDIR, pidl=0x%X",*ppidl);
        if (ShouldRestartSearch(*ppidl)) 
        {
            BOOL bRecurse = (ppidl[1] != NULL);
            if (_cExecInProgress) 
            {
                _DeferHandleUpdateDir(*ppidl, bRecurse);
            } 
            else 
            {
                if (_execData.pff->HandleUpdateDir(*ppidl, bRecurse)) 
                {
                    // Need to spawn sub-search on this...
                    _Start(FALSE, -1, *ppidl);
                }
            }
        }
        return;

    default:
        return;     // we are not interested in this event
    }

    //
    // Now we need to see if the item might be in our list
    // First we need to extract off the last part of the id list
    // and see if the contained id entry is in our list.  If so we
    // need to see if can get the defview find the item and update it.
    //

    _execData.pff->MapToSearchIDList(*ppidl, FALSE, &pidlT);

    switch (code)
    {
    case SHCNE_RMDIR:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_RMDIR, pidl=0x%X",*ppidl);
        _execData.pff->HandleRMDir(_execData.psfv, *ppidl);
        if (pidlT)
        {
            _execData.psfv->RemoveObject(pidlT, &idsMsg);
        }
        break;

    case SHCNE_DELETE:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_DELETE, pidl=0x%X",*ppidl);
        if (pidlT)
        {
            _execData.psfv->RemoveObject(pidlT, &idsMsg);
        }
        break;

    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        if (pidlT)
        {
            // If the two items dont have the same parent, we will go ahead
            // and remove it...
            LPITEMIDLIST pidl1;
            if (SUCCEEDED(_execData.pff->GetParentsPIDL(pidlT, &pidl1)))
            {
                LPITEMIDLIST pidl2 = ILClone(ppidl[1]);
                if (pidl2)
                {
                    ILRemoveLastID(pidl2);
                    if (!ILIsEqual(pidl1, pidl2))
                    {
                        _execData.psfv->RemoveObject(pidlT, &idsMsg);

                        // And maybe add it back to the end... of the list
                        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], NULL);
                    }
                    else
                    {
                        // The object is in same folder so must be rename...
                        // And maybe add it back to the end... of the list
                        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], pidlT);
                    }
                    ILFree(pidl2);
                }
                ILFree(pidl1);
            }
        }
        else
        {
            _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], NULL);
        }
        break;

    case SHCNE_UPDATEITEM:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_UPDATEITEM, pidl=0x%X",*ppidl);
        if (pidlT)
            _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, *ppidl, pidlT);
        break;
    }

    // Update the count...
    _execData.psfv->GetObjectCount(&cItems);
    _NotifyProgressText(_uStatusMsgIndex, cItems);

    ILFree(pidlT);
}                          

// Ok we need to add a defer

void CFindCmd::_DeferHandleUpdateDir(LPCITEMIDLIST pidl, BOOL bRecurse)
{
    // See if we already have some items in the list which are lower down in the tree if so we
    // can replace it.  Or is there one that is higher up, in which case we can ignore it...

    struct DEFER_UPDATE_DIR *pdudPrev = NULL;
    struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
    while (pdud) 
    {
        if (ILIsParent(pdud->pidl, pidl, FALSE))
            return;     // Already one in the list that will handle this one...
        if (ILIsParent(pidl, pdud->pidl, FALSE))
            break;
        pdudPrev = pdud;
        pdud = pdud->pdudNext;
    }

    // See if we found one that we can replace...
    if (pdud) 
    {
        LPITEMIDLIST pidlT = ILClone(pidl);
        if (pidlT) 
        {
            ILFree(pdud->pidl);
            pdud->pidl = pidlT;

            // See if there are others...
            pdudPrev = pdud;
            pdud = pdud->pdudNext;
            while (pdud) 
            {
                if (ILIsParent(pidl, pdud->pidl, FALSE)) 
                {
                    // Yep lets trash this one.
                    ILFree(pdud->pidl);
                    pdudPrev->pdudNext = pdud->pdudNext;
                    pdud = pdudPrev;    // Let it fall through to setup to look at next...
                }
                pdudPrev = pdud;
                pdud = pdud->pdudNext;
            }
        }
    }
    else 
    {
        // Nope simply add us in to the start of the list.
        pdud = (struct DEFER_UPDATE_DIR*)LocalAlloc(LPTR, sizeof(struct DEFER_UPDATE_DIR));
        if (!pdud)
            return; // Ooop could not alloc...
        pdud->pidl = ILClone(pidl);
        if (!pdud->pidl) 
        {
            LocalFree((HLOCAL)pdud);
            return;
        }
        pdud->fRecurse = bRecurse;
        pdud->pdudNext = _pdudFirst;
        _pdudFirst = pdud;
    }
}

void CFindCmd::_ClearDeferUpdateDirList()
{
    // Cancel any Pending updatedirs also.    
    while (_pdudFirst) 
    {
        struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
        _pdudFirst = pdud->pdudNext;
        ILFree(pdud->pidl);
        LocalFree((HLOCAL)pdud);
    }
}

LRESULT CALLBACK CFindCmd::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CFindCmd* pThis = (CFindCmd*)GetWindowLongPtr(hwnd, 0);
    LRESULT lRes = 0;
    switch (uMsg)
    {
    case WM_DESTROY:
        SetWindowLong(hwnd, 0, 0); // make sure we don't deref pThis
        break;

    case WM_DF_FSNOTIFY:
        {
            LPITEMIDLIST *ppidl;
            LONG lEvent;
            LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
            if (pshcnl)
            {
                if (pThis)
                    pThis->_OnChangeNotify(lEvent, ppidl);
                SHChangeNotification_Unlock(pshcnl);
            }
        }
        break;
        
    case WM_DF_SEARCHPROGRESS:
        pThis->_PTN_SearchProgress();
        pThis->Release();
        break;

    case WM_DF_ASYNCPROGRESS:
        pThis->_PTN_AsyncProgress((int)wParam, (DWORD)lParam);
        pThis->Release();
        break;

    case WM_DF_SEARCHSTART:
        pThis->_cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_START);
        pThis->_SetEmptyText(IDS_FINDVIEWEMPTYBUSY);
        pThis->Release();
        break;

    case WM_DF_SEARCHCOMPLETE:
        pThis->_PTN_SearchComplete((HRESULT)wParam, (BOOL)lParam);
        pThis->Release();
        break;

    default:
        lRes = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }
    return lRes;
}

// test to see if the view is in a mode where many items are displayed
BOOL LotsOfItemsInView(IUnknown *punkSite)
{
    BOOL bLotsOfItemsInView = FALSE;

    IFolderView * pfv;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        UINT uViewMode;
        bLotsOfItemsInView = SUCCEEDED(pfv->GetCurrentViewMode(&uViewMode)) &&
            ((FVM_ICON == uViewMode) || (FVM_SMALLICON == uViewMode));
        pfv->Release();
    }
    return bLotsOfItemsInView;
}

void CFindCmd::_DoSearch(IFindEnum *penum)
{
    BOOL fAbort = FALSE;

    BOOL bLotsOfItems = LotsOfItemsInView(_execData.psfv);

    EnterCriticalSection(&_csThread);

    // previous thread might have exited but we're still processing search complete message
    if (_cExecInProgress > 1) 
        Sleep(1000); // give it a chance to finish

    _updateParams.hdpa = NULL;
    _updateParams.fFilesAdded = FALSE;
    _updateParams.fDirChanged = FALSE;
    _updateParams.fUpdatePosted = FALSE;

    _PostMessage(WM_DF_SEARCHSTART, 0, 0);

    // Now see if this is an Sync or an Async version of the search...

    HRESULT hr = S_OK;

    BOOL fQueryIsAsync = penum->FQueryIsAsync();
    if (fQueryIsAsync)
    {
        DBCOUNTITEM dwTotalAsync;
        BOOL fDone;
        int nPercentComplete;
        while (S_OK == (hr = penum->GetAsyncCount(&dwTotalAsync, &nPercentComplete, &fDone)))
        {
            if (!_fContinue) 
            {
                fAbort = TRUE;
                break;
            }

            _PostMessage(WM_DF_ASYNCPROGRESS, (WPARAM)nPercentComplete, (LPARAM)dwTotalAsync);

            // If we are done we can simply let the ending callback tell of the new count...
            if (fDone) 
                break;

            // sleep .3 or 1.5 sec
            Sleep(bLotsOfItems ? 1500 : 300); // wait between looking again...
        }
    }

    if (!fQueryIsAsync || (fQueryIsAsync == DF_QUERYISMIXED))
    {
        int state, cItemsSearched = 0, cFoldersSearched = 0, cFoldersSearchedPrev = 0;

        _updateParams.hdpa = _hdpaItemsToAdd1;    // Assume first one now...
        _updateParams.dwTimeLastNotify = GetTickCount();

        LPITEMIDLIST pidl;
        while (S_OK == (hr = penum->Next(&pidl, &cItemsSearched, &cFoldersSearched, &_fContinue, &state)))
        {
            if (state == GNF_DONE) 
                break;  // no more

            if (!_fContinue) 
            {                        
                fAbort = TRUE;
                break;
            }

            // See if we should abort
            if (state == GNF_MATCH)
            {   
                EnterCriticalSection(&_updateParams.csSearch);
                DPA_AppendPtr(_updateParams.hdpa, pidl);
                _updateParams.fFilesAdded = TRUE;
                LeaveCriticalSection(&_updateParams.csSearch);
            }

            if (cFoldersSearchedPrev != cFoldersSearched)
            {
                _updateParams.fDirChanged = TRUE;
                cFoldersSearchedPrev = cFoldersSearched;
            }

            if (!_updateParams.fUpdatePosted && 
                (_updateParams.fDirChanged || _updateParams.fFilesAdded)) 
            {
                if ((GetTickCount() - _updateParams.dwTimeLastNotify) > 200)
                {
                    _updateParams.fUpdatePosted = TRUE;
                    _PostMessage(WM_DF_SEARCHPROGRESS, 0, 0);
                }
            }
        }

        _PostMessage(WM_DF_SEARCHPROGRESS, 0, 0);
    }

    if (hr != S_OK) 
    {
        fAbort = TRUE;
    }

    _PostMessage(WM_DF_SEARCHCOMPLETE, (WPARAM)hr, (LPARAM)fAbort);

    LeaveCriticalSection(&_csThread);
}

DWORD CALLBACK CFindCmd::_ThreadProc(void *pv)
{
    THREAD_PARAMS *pParams = (THREAD_PARAMS *)pv;
    pParams->pThis->_DoSearch(pParams->penum);
    _FreeThreadParams(pParams);
    return 0;
}

HRESULT CFindCmd::_Cancel()
{
    _ClearDeferUpdateDirList();

    if (DSA_GetItemCount(_hdsaConstraints) == 0) 
    {
        _fContinue = FALSE; // Cancel current query if we have a null paramter collection
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFindCmd::_Init(THREAD_PARAMS **ppParams, int iCol, LPCITEMIDLIST pidlUpdate)
{
    *ppParams = new THREAD_PARAMS;
    if (NULL == *ppParams)
        return E_OUTOFMEMORY;

    // Clear any previous registrations...
    SHChangeNotifyDeregisterWindow(_updateParams.hwndThreadNotify);

    // Prepare to execute the query
    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr)) 
    {
        // We do not need to update the filter if this is done as part of an FSNOTIFY or a Sort...
        if ((iCol >= 0) || pidlUpdate || SUCCEEDED(hr = _UpdateFilter(pfilter))) 
        {
            _execData.szProgressText[0] = 0; 

            pfilter->DeclareFSNotifyInterest(_updateParams.hwndThreadNotify, WM_DF_FSNOTIFY);
            pfilter->GetStatusMessageIndex(0, &_uStatusMsgIndex);

            DWORD dwFlags;
            hr = pfilter->PrepareToEnumObjects(_GetWindow(), &dwFlags);
            if (SUCCEEDED(hr)) 
            {
                hr = pfilter->EnumObjects(_execData.psf, pidlUpdate, dwFlags, iCol, 
                        _execData.szProgressText, SAFECAST(this, IRowsetWatchNotify*), &(*ppParams)->penum);
            }
        }
        pfilter->Release();
    }

    // Fill in the exec params

    (*ppParams)->pThis = this;
    AddRef();   // ExecParams_Free will release this interface addref...

    if (FAILED(hr)) 
    {
        _FreeThreadParams(*ppParams);        
        *ppParams = NULL;
    } 

    return hr;
}

HRESULT CFindCmd::_FreeThreadParams(THREAD_PARAMS *pParams)
{
    if (!pParams)
        return S_OK;

    // Don't use atomic release as this a pointer to a class not an interface.
    CFindCmd *pThis = pParams->pThis;
    pParams->pThis = NULL;
    pThis->Release();

    ATOMICRELEASE(pParams->penum);

    delete pParams;
    
    return S_OK;
}

HRESULT CFindCmd::_ExecData_Release()
{
    ATOMICRELEASE(_execData.psf);
    ATOMICRELEASE(_execData.psfv);
    if (_execData.pff)
        _execData.pff->SetControllerNotifyObject(NULL);   // release back pointer to us...
    ATOMICRELEASE(_execData.pff);
    _cExecInProgress = 0; // we must be in process of shutting down at least...
    
    return S_OK;
}

HRESULT CFindCmd::_EnsureResultsViewIsCurrent(IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFolder;
    if (S_OK == SHGetIDListFromUnk(punk, &pidlFolder))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(_GetSearchIDList(&pidl)))
        {
            if (ILIsEqual(pidlFolder, pidl))
                hr = S_OK;
            ILFree(pidl);
        }
        ILFree(pidlFolder);
    }
    return hr;
}

// the search results view callback proffeerd itself and we can use that 
// to get a hold of defview and can program it

HRESULT CFindCmd::_GetShellView(REFIID riid, void **ppv)
{
    return IUnknown_QueryService(_punkSite, SID_DocFindFolder, riid, ppv);
}

HRESULT CFindCmd::_ExecData_Init()
{
    _ExecData_Release();

    IFolderView *pfv;
    HRESULT hr = _GetShellView(IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr)) 
    {
        IShellFolder *psf;
        hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr)) 
        {
            IFindFolder *pff;
            hr = psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff));
            if (SUCCEEDED(hr)) 
            {
                hr = _EnsureResultsViewIsCurrent(psf);
                if (SUCCEEDED(hr)) 
                {
                    IShellFolderView *psfv;
                    hr = pfv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv));
                    if (SUCCEEDED(hr)) 
                    {
                        IUnknown_Set((IUnknown **)&_execData.pff, pff);
                        IUnknown_Set((IUnknown **)&_execData.psf, psf);
                        IUnknown_Set((IUnknown **)&_execData.psfv, psfv);
                        _execData.pff->SetControllerNotifyObject(SAFECAST(this, IFindControllerNotify*));
                        psfv->Release();
                    }
                }
                pff->Release();
            }
            psf->Release();
        }
        pfv->Release();
    }

    if (FAILED(hr))
        _ExecData_Release();
    else
        SetShellFolder(_execData.psf);
    
    return hr;
}

BOOL CFindCmd::_SetupBrowserCP()
{
    if (!_dwCookie)
    {
        _cwbe.SetOwner(this);   // make sure our owner is set...

        // register ourself with the Defview to get any events that they may generate...
        IServiceProvider *pspTLB;
        HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTLB));
        if (SUCCEEDED(hr)) 
        {
            IConnectionPointContainer *pcpc;
            hr = pspTLB->QueryService(IID_IExpDispSupport, IID_PPV_ARG(IConnectionPointContainer, &pcpc));
            if (SUCCEEDED(hr)) 
            {
                hr = ConnectToConnectionPoint(SAFECAST(&_cwbe, DWebBrowserEvents*), DIID_DWebBrowserEvents2,
                                              TRUE, pcpc, &_dwCookie, &_pcpBrowser);
                pcpc->Release();
            }
            pspTLB->Release();
        }
    }

    if (_dwCookie)
        _cwbe.SetWaiting(TRUE);

    return _dwCookie ? TRUE : FALSE;
}

HRESULT CFindCmd::_Start(BOOL fNavigateIfFail, int iCol, LPCITEMIDLIST pidlUpdate)
{
    if (_cExecInProgress)
        return E_UNEXPECTED;

    if (!_hdpaItemsToAdd1) 
    {
        _hdpaItemsToAdd1 = DPA_CreateEx(64, GetProcessHeap());
        if (!_hdpaItemsToAdd1)
            return E_OUTOFMEMORY;
    }

    if (!_hdpaItemsToAdd2) 
    {
        _hdpaItemsToAdd2 = DPA_CreateEx(64, GetProcessHeap());
        if (!_hdpaItemsToAdd2)
            return E_OUTOFMEMORY;
    }

    if (!_updateParams.hwndThreadNotify) 
    {
        _updateParams.hwndThreadNotify = SHCreateWorkerWindow(_WndProc, NULL, 0, 0, 0, this);
        if (!_updateParams.hwndThreadNotify) 
            return E_OUTOFMEMORY;
    }

    HRESULT hr = _ExecData_Init();
    if (FAILED(hr)) 
    {
        if (fNavigateIfFail) 
        {
            if (_SetupBrowserCP())
                NavigateToSearchResults();
        }
        // Return S_False so that when we check if this succeeded in finddlg, we wee that it 
        // did, and therefore let the animation run.  If we return a failure code here, we
        // will stop the animation.  This will only hapen when we are navigating to the search
        // results as well as starting the search.
        return S_FALSE;
    }

    THREAD_PARAMS *ptp;
    hr = _Init(&ptp, iCol, pidlUpdate);
    if (SUCCEEDED(hr)) 
    {
        // See if we should be saving away the selection...
        if (iCol >= 0)
            _execData.pff->RememberSelectedItems();

        // If this is an update then we need to remember our IDList else clear list...
        if (pidlUpdate) 
        {
            _pidlUpdate = ILClone(pidlUpdate);
        } 
        else 
        {
            _Clear();   // tell defview to delete everything
        }

        _execData.pff->SetAsyncEnum(ptp->penum);

        // Start the query
        _cExecInProgress++;
        _fContinue = TRUE;
        _fNew = FALSE;

        if (SHCreateThread(_ThreadProc, ptp, CTF_COINIT, NULL))
        {     
            hr = S_OK;
        } 
        else 
        {
            _cExecInProgress--;
            _FreeThreadParams(ptp);
            _SetEmptyText(IDS_FINDVIEWEMPTY);
        }
    }
    else
        hr = _SetLastError(hr);

    return hr; 
}

HRESULT CFindCmd::_SetLastError(HRESULT hr) 
{
    if (HRESULT_FACILITY(hr) == FACILITY_SEARCHCOMMAND) 
    {
        _hrLastError = hr;
        hr = S_FALSE; // Don't error out script...
        _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_ERROR);
    }
    return hr;
}

STDMETHODIMP CFindCmd::Execute(VARIANT *RecordsAffected, VARIANT *Parameters, long Options)
{
    if (Options == 0)
        return _Cancel();

    _FixBrokenTypes();

    return _Start(TRUE, -1, NULL);
}

// IConnectionPointContainer

STDMETHODIMP CFindCmd::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1, _cpEvents.CastToIConnectionPoint());
}

STDMETHODIMP CFindCmd::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    if (IsEqualIID(iid, DIID_DSearchCommandEvents) || 
        IsEqualIID(iid, IID_IDispatch)) 
    {
        *ppCP = _cpEvents.CastToIConnectionPoint();
    } 
    else 
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}

// IProvideClassInfo2 methods

STDMETHODIMP CFindCmd::GetClassInfo(ITypeInfo **ppTI)
{
    return GetTypeInfoFromLibId(0, LIBID_Shell32, 1, 0, CLSID_DocFindCommand, ppTI);
}

STDMETHODIMP CFindCmd::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID) 
    {
        *pGUID = DIID_DSearchCommandEvents;
        return S_OK;
    }
    
    *pGUID = GUID_NULL;
    return E_FAIL;
}


STDMETHODIMP CFindCmd::SetSite(IUnknown *punkSite)
{
    if (!punkSite) 
    {
        if (!_cExecInProgress) 
        {
            _ExecData_Release();
        }
        _fContinue = FALSE; // Cancel existing queries

        // See if we have a connection point... If so unadvise now...
        if (_dwCookie) 
        {
            _pcpBrowser->Unadvise(_dwCookie);
            ATOMICRELEASE(_pcpBrowser);
            _dwCookie = 0;
        }

        // Bug #199671
        // Trident won't call UnAdvise and they except ActiveX Controls
        // to use IOleControl::Close() to do their own UnAdvise, and hope
        // nobody will need events after that.  I don't impl IOleControl so
        // we need to do the same thing during IObjectWithSite::SetSite(NULL)
        // and hope someone won't want to reparent us.  This is awkward but
        // saves Trident some perf so we will tolerate it.
        EVAL(SUCCEEDED(_cpEvents.UnadviseAll()));
    }

    return CObjectWithSite::SetSite(punkSite);
}

void CFindCmd::_SelectResults()
{
    if (_execData.psfv)
    {
        //  If there are any items...
        UINT cItems = 0;
        if (SUCCEEDED(_execData.psfv->GetObjectCount(&cItems)) && cItems > 0)
        {
            IShellView* psv;
            if (SUCCEEDED(_execData.psfv->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
            {
                //  If none are selected (don't want to rip the user's selection out of his hand)...
                UINT cSelected = 0;
                if (SUCCEEDED(_execData.psfv->GetSelectedCount(&cSelected)) && cSelected == 0)
                {
                    //  Retrieve the pidl for the first item in the list...
                    LPITEMIDLIST pidlFirst = NULL;
                    if (SUCCEEDED(_execData.psfv->GetObject(&pidlFirst,  0)))
                    {
                        //  Give it the focus
                        psv->SelectItem(pidlFirst, SVSI_FOCUSED | SVSI_ENSUREVISIBLE);
                    }
                }

                //  Activate the view.
                psv->UIActivate(SVUIA_ACTIVATE_FOCUS);
                psv->Release();
            }
        }
    }
}

STDMETHODIMP CFindCmd::ClearResults(void)
{
    HRESULT hr = _Clear();

    if (SUCCEEDED(hr))
    {
        _fNew = TRUE;
        _SetEmptyText(IDS_FINDVIEWEMPTYINIT);
    }

    return hr ;
}

HRESULT CFindCmd::_Clear()
{
    // Tell defview to delete everything.
    if (_execData.psfv)
    {
        UINT u;
        _execData.psfv->RemoveObject(NULL, &u);
    }

    // And cleanup our folderList
    if (_execData.pff)
    {
        _execData.pff->ClearItemList();
        _execData.pff->ClearFolderList();
    }
    return S_OK;
}

HRESULT CFindCmd::_SetEmptyText(UINT nIDEmptyText)
{
    IShellFolderViewCB *psfvcb;
    HRESULT hr = IUnknown_QueryService(_execData.psfv, SID_ShellFolderViewCB, IID_PPV_ARG(IShellFolderViewCB, &psfvcb));
    if (SUCCEEDED(hr))
    {
        TCHAR szEmptyText[128];
        LoadString(HINST_THISDLL, nIDEmptyText, szEmptyText, ARRAYSIZE(szEmptyText));

        hr = psfvcb->MessageSFVCB(SFVM_SETEMPTYTEXT, 0, (LPARAM)szEmptyText);
        psfvcb->Release();
    }
    return hr;
}

HRESULT CFindCmd::_GetSearchIDList(LPITEMIDLIST *ppidl)
{
    CLSID clsid;
    _SearchResultsCLSID(&clsid);
    return ILCreateFromCLSID(clsid, ppidl);
}

STDMETHODIMP CFindCmd::NavigateToSearchResults(void)
{
    IShellBrowser *psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr)) 
    {
        LPITEMIDLIST pidl;
        hr = _GetSearchIDList(&pidl);
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidl,  SBSP_SAMEBROWSER | SBSP_ABSOLUTE | SBSP_WRITENOHISTORY);
            ILFree(pidl);
        }
        psb->Release();
    }
    return hr;
}

IUnknown* CFindCmd::_GetObjectToPersist()
{
    IOleObject *pole = NULL;
    
    IShellView *psv;
    HRESULT hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
    if (SUCCEEDED(hr)) 
    {
        psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IOleObject, &pole));
        psv->Release();
    }

    return (IUnknown *)pole;
}

void CFindCmd::_PostMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{    
    AddRef();  // to be released after processing of the message bellow
    if (!PostMessage(_updateParams.hwndThreadNotify, uMsg, wParam, lParam))
    {
        Release();
    }
}

HWND CFindCmd::_GetWindow()
{
    HWND hwnd;
    return SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwnd)) ? hwnd : NULL;
}

STDMETHODIMP CFindCmd::SaveSearch(void)
{
    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr))
    {
        IShellView *psv;
        hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr)) 
        {
            IUnknown* punk = _GetObjectToPersist(); // NULL is OK

            _execData.pff->Save(pfilter, _GetWindow(), &_dfbsi, psv, punk);

            ATOMICRELEASE(punk);

            psv->Release();
        }
        pfilter->Release();
    }

    return hr;
}

STDMETHODIMP CFindCmd::RestoreSearch(void)
{
    // let script know that a restore happened...
    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_RESTORE);
    return S_OK;
}

STDMETHODIMP CFindCmd::StopSearch(void)
{
    if (_cExecInProgress)
        return _Cancel();

    return S_OK;
}

STDMETHODIMP CFindCmd::GetItemCount(UINT *pcItems)
{
    if (_execData.psfv)
    {
        return _execData.psfv->GetObjectCount(pcItems);
    }
    return E_FAIL;
}

STDMETHODIMP CFindCmd::SetItemCount(UINT cItems)
{
    if (_execData.psfv)
    {
        return _execData.psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
    }
    return E_FAIL;
}

STDMETHODIMP CFindCmd::ViewDestroyed()
{
    _ExecData_Release();
    return S_OK;
}

STDMETHODIMP CFindCmd::get_ProgressText(BSTR *pbs)
{

    *pbs = SysAllocStringT(_szProgressText);
    return *pbs ? S_OK : E_OUTOFMEMORY;
}

//------ error string mappings ------//
static const UINT error_strings[] =
{
    SCEE_CONSTRAINT,   IDS_DOCFIND_CONSTRAINT,
    SCEE_PATHNOTFOUND, IDS_DOCFIND_PATHNOTFOUND,
    SCEE_INDEXSEARCH,  IDS_DOCFIND_SCOPEERROR,
    SCEE_CASESENINDEX, IDS_DOCFIND_CI_NOT_CASE_SEN,
};

STDMETHODIMP CFindCmd::GetErrorInfo(BSTR *pbs,  int *phr)
{
    int nCode     = HRESULT_CODE(_hrLastError);
    UINT uSeverity = HRESULT_SEVERITY(_hrLastError);

    if (phr)
        *phr = nCode;
    
    if (pbs)
    {    
        UINT nIDString = 0;
        *pbs = NULL;

        for(int i = 0; i < ARRAYSIZE(error_strings); i += 2)
        {
            if (error_strings[i] == (UINT)nCode)
            {
                nIDString =  error_strings[i+1];
                break ;
            }
        }

        if (nIDString)
        {
            WCHAR wszMsg[MAX_PATH];
            EVAL(LoadStringW(HINST_THISDLL, nIDString, wszMsg, ARRAYSIZE(wszMsg)));
            *pbs = SysAllocString(wszMsg);
        }
        else
            *pbs = SysAllocString(L"");
    }
    
    return S_OK;
}

STDMETHODIMP CFindCmd::SearchFor(int iFor)
{
    if (SCE_SEARCHFORFILES == iFor)
    {
        _clsidResults = CLSID_DocFindFolder;
    }
    else if (SCE_SEARCHFORCOMPUTERS == iFor)
    {
        _clsidResults = CLSID_ComputerFindFolder;
    }
    return S_OK;
}

STDMETHODIMP CFindCmd::GetScopeInfo(BSTR bsScope, int *pdwScopeInfo)
{
    *pdwScopeInfo = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CFindCmd::RestoreSavedSearch(VARIANT *pvarFile)
{
    if (pvarFile && pvarFile->vt != VT_EMPTY)
    {
        LPITEMIDLIST pidl = VariantToIDList(pvarFile); 
        if (pidl)
        {
            ILFree(_pidlRestore);
            _pidlRestore = pidl ;
        }
    }

    if (_pidlRestore)
    {
        IShellView *psv;
        HRESULT hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr)) 
        {
            psv->Release();

            if (SUCCEEDED(_ExecData_Init()))
            {
                _execData.pff->RestoreSearchFromSaveFile(_pidlRestore, _execData.psfv);
                _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_RESTORE);
                ILFree(_pidlRestore);
                _pidlRestore = NULL;
            }
        }
        else if (!_fDeferRestoreTried)
        {
            // appears to be race condition to load
            TraceMsg(TF_WARNING, "CFindCmd::MaybeRestoreSearch - _GetShellView failed...");
            _fDeferRestore = TRUE;
            if (!_SetupBrowserCP())
                _fDeferRestore = FALSE;
        }
    }
    return S_OK;
}

STDMETHODIMP CFindCmd::OnChange(IRowset *prowset, DBWATCHNOTIFY eChangeReason)
{
    _fAsyncNotifyReceived = TRUE;
    return S_OK;
}

STDMETHODIMP CFindCmd::DoSortOnColumn(UINT iCol, BOOL fSameCol)
{
    IFindEnum *pdfEnumAsync;

    if (S_OK == _execData.pff->GetAsyncEnum(&pdfEnumAsync))
    {
        // If the search is still running we will restart with the other column else we
        // will make sure all of the items have been cached and let the default processing happen
        if (!fSameCol && _cExecInProgress)
        {
            // We should try to sort on the right column...
            _Start(FALSE, iCol, NULL);
            return S_FALSE; // tell system to not do default processing.
        }

        _execData.pff->CacheAllAsyncItems();
    }
    return S_OK;    // let it do default processing.

}

// Implemention of our IDispatch to hookup to the top level browsers connnection point...
STDMETHODIMP CFindCmd::CWBEvents2::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFindCmd::CWBEvents2, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CFindCmd::CWBEvents2, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        QITABENTMULTI2(CFindCmd::CWBEvents2, DIID_DWebBrowserEvents, DWebBrowserEvents),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CFindCmd::CWBEvents2::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    if (_fWaitingForNavigate) 
    {
        if ((dispidMember == DISPID_NAVIGATECOMPLETE) || 
            (dispidMember == DISPID_DOCUMENTCOMPLETE)) 
        {
            // Assume this is ours... Should maybe check parameters...
            _fWaitingForNavigate = FALSE;

            // Now see if it is a case where we are to restore the search...
            if (_pcdfc->_fDeferRestore)
            {
                _pcdfc->_fDeferRestore = FALSE;
                _pcdfc->_fDeferRestoreTried = TRUE;
                _pcdfc->RestoreSavedSearch(NULL);
            }
            else
                return _pcdfc->_Start(FALSE, -1, NULL);
        }
    }
    return S_OK;
}

#define MAX_DEFAULT_VALUE   40      // Longest of all of the below pszDefaultValueMatch strings (plus slop)
#define MAX_KEY_PH_NAME     70      // "CLSID\{GUID}\PersistentHandler" (plus slop)

const TYPE_FIX_ENTRY g_tfeTextTypes[] =
{
    { TEXT(".rtf"), NULL,                               NULL                                           },
};

const TYPE_FIX_ENTRY g_tfeNullTypes[] =
{
    { TEXT(".mdb"), TEXT("Access.Application.10"),      TEXT("{73A4C9C1-D68D-11D0-98BF-00A0C90DC8D9}") },
    { TEXT(".msg"), TEXT("msgfile"),                    NULL                                           },
    { TEXT(".sc2"), TEXT("SchedulePlus.Application.7"), TEXT("{0482E074-C5B7-101A-82E0-08002B36A333}") },
    { TEXT(".wll"), TEXT("Word.Addin.8"),               NULL                                           },
};

//
// rtf is listed twice, once above for TextTypes (to fix when office
// un-installed) and once here as an OfficeType (to fix when office
// is re-installed).  Uninstalled = TextFilter,  Reinstalled = OfficeFilter
//
const TYPE_FIX_ENTRY g_tfeOfficeTypes[] =
{
    { TEXT(".rtf"), TEXT("Word.RTF.8"),                 TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".doc"), TEXT("Word.Document.8"),            TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".dot"), TEXT("Word.Template.8"),            TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".pot"), TEXT("PowerPoint.Template.8"),      TEXT("{64818D11-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".pps"), TEXT("PowerPoint.SlideShow.8"),     TEXT("{64818D10-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".ppt"), TEXT("PowerPoint.Show.8"),          TEXT("{64818D10-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".rtf"), TEXT("Word.RTF.8"),                 TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".xlb"), TEXT("Excel.Sheet.8"),              TEXT("{00020820-0000-0000-C000-000000000046}") },
    { TEXT(".xlc"), TEXT("Excel.Chart.8"),              TEXT("{00020821-0000-0000-C000-000000000046}") },
    { TEXT(".xls"), TEXT("Excel.Sheet.8"),              TEXT("{00020820-0000-0000-C000-000000000046}") },
    { TEXT(".xlt"), TEXT("Excel.Template"),             TEXT("{00020820-0000-0000-C000-000000000046}") },
};

const TYPE_FIX_ENTRY g_tfeHtmlTypes[] =
{
    { TEXT(".asp"), TEXT("aspfile"),                    NULL                                           },
    { TEXT(".htx"), TEXT("htxfile"),                    NULL                                           },
};

BOOL CFindCmd::_FixPersistHandler(LPCTSTR pszBase, LPCTSTR pszDefaultHandler)
{
    TCHAR szPHName[MAX_KEY_PH_NAME];
    LONG lr;
    HKEY hkeyPH;
    HKEY hkeyBase;

    wnsprintf(szPHName,ARRAYSIZE(szPHName), TEXT("%s\\PersistentHandler"), pszBase);

    lr = RegOpenKey(HKEY_CLASSES_ROOT, szPHName, &hkeyPH);
    if (lr == ERROR_SUCCESS)
    {
        // We found an existing PersistHandler key, leave it alone
        RegCloseKey(hkeyPH);
        return TRUE;
    }

    lr = RegOpenKey(HKEY_CLASSES_ROOT, pszBase, &hkeyBase);
    if (lr != ERROR_SUCCESS)
    {
        // We didn't find the base key (normally "CLSID\\{GUID}"), get out
        return FALSE;
    }
    RegCloseKey(hkeyBase);

    lr = RegCreateKey(HKEY_CLASSES_ROOT, szPHName, &hkeyPH);
    if (lr != ERROR_SUCCESS)
    {
        // We couldn't create the ...\PersistHandler key, get out
        return FALSE;
    }

    // Able to create the ...\PersistHandler key, write out the default handler
    lr = RegSetValue(hkeyPH, NULL, REG_SZ, pszDefaultHandler, lstrlen(pszDefaultHandler));
    RegCloseKey(hkeyPH);

    // Success if write succeeded
    return (lr == ERROR_SUCCESS);
}

void CFindCmd::_ProcessTypes(
    const TYPE_FIX_ENTRY *ptfeTypes,
    UINT cTypes,
    TCHAR *pszClass)
{
    UINT iType;
    LONG lr;
    HKEY hkeyType;

    for (iType = 0; iType < cTypes; iType++)
    {
        lr = RegOpenKey(HKEY_CLASSES_ROOT, ptfeTypes[iType].pszDotType, &hkeyType);
        if (lr == ERROR_SUCCESS)
        {
            //
            // If it has a default value to match, repair that (if it exists).
            // If there is no default value to match, just repair the .foo type
            //
            if (ptfeTypes[iType].pszDefaultValueMatch)
            {
                TCHAR szDefaultValue[MAX_DEFAULT_VALUE];
                LONG cb = sizeof(szDefaultValue);
                lr = RegQueryValue(hkeyType, NULL, szDefaultValue, &cb);
                if (lr == ERROR_SUCCESS)
                {
                    if (lstrcmp(szDefaultValue,ptfeTypes[iType].pszDefaultValueMatch) == 0)
                    {
                        if (ptfeTypes[iType].pszGuid == NULL)
                        {
                            // Fix either the progid or the type, whichever we can
                            if (!_FixPersistHandler(ptfeTypes[iType].pszDefaultValueMatch,pszClass))
                            {
                                 _FixPersistHandler(ptfeTypes[iType].pszDotType,pszClass);
                            }
                        }
                        else
                        {
                            // Fix the persist handler for the guid, since its specified
                            TCHAR szPHName[MAX_KEY_PH_NAME];

                            wnsprintf(szPHName, ARRAYSIZE(szPHName), TEXT("CLSID\\%s"), ptfeTypes[iType].pszGuid);
                            _FixPersistHandler(szPHName, pszClass);
                        }
                    }
                }
            }
            else
            {
                _FixPersistHandler(ptfeTypes[iType].pszDotType, pszClass);
            }
            RegCloseKey(hkeyType);
        }
        else if (lr == ERROR_FILE_NOT_FOUND)
        {
            //
            // .foo doesn't exist - this can happen because of bad un-install program
            // Create .foo and .foo\PersistentHandler
            //
            lr = RegCreateKey(HKEY_CLASSES_ROOT, ptfeTypes[iType].pszDotType, &hkeyType);
            if (lr == ERROR_SUCCESS)
            {
                _FixPersistHandler(ptfeTypes[iType].pszDotType, pszClass);
                RegCloseKey(hkeyType);
            }
        }
    }
}

void CFindCmd::_FixBrokenTypes(void)
{
    _ProcessTypes(g_tfeNullTypes,   ARRAYSIZE(g_tfeNullTypes),   TEXT("{098f2470-bae0-11cd-b579-08002b30bfeb}"));
    _ProcessTypes(g_tfeTextTypes,   ARRAYSIZE(g_tfeTextTypes),   TEXT("{5e941d80-bf96-11cd-b579-08002b30bfeb}"));
    _ProcessTypes(g_tfeOfficeTypes, ARRAYSIZE(g_tfeOfficeTypes), TEXT("{98de59a0-d175-11cd-a7bd-00006b827d94}"));
    _ProcessTypes(g_tfeHtmlTypes,   ARRAYSIZE(g_tfeHtmlTypes),   TEXT("{eec97550-47a9-11cf-b952-00aa0051fe20}"));
}

CFindConstraint::CFindConstraint(BSTR bstr, VARIANT var) : CImpIDispatch(LIBID_Shell32, 1, 0, IID_DFConstraint)
{
    _cRef = 1;
    _bstr = bstr;
    _var = var;
}

CFindConstraint::~CFindConstraint()
{
    SysFreeString(_bstr);
    VariantClear(&_var);
}

STDMETHODIMP CFindConstraint::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindConstraint, DFConstraint),                  // IID_DFConstraint
        QITABENTMULTI(CFindConstraint, IDispatch, DFConstraint),  // IID_IDispatch
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindConstraint::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindConstraint::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CFindConstraint::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFindConstraint::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFindConstraint::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP CFindConstraint::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CFindConstraint::get_Name(BSTR *pbs)
{
    *pbs = SysAllocString(_bstr);
    return *pbs? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindConstraint::get_Value(VARIANT *pvar)
{
    VariantInit(pvar);
    return VariantCopy(pvar, &_var);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\finddlg.h ===
// finddlg.h : Declaration of the file search band dialog classes

#ifndef __FSEARCH_DLGS_H__
#define __FSEARCH_DLGS_H__

#pragma warning(disable:4127) // conditional expression is constant

#include "resource.h"       // main symbols
#include <shdispid.h>
#include "atldisp.h"
#include "ids.h"

class CFileSearchBand;     // top-level (band/OC) window

class CBandDlg;            // base class for top-level dialogs
    class CSearchCmdDlg;       // base class for band dlgs that employ an ISearchCmdExt interface
        class CFindFilesDlg;       // top level file system search dialog
        class CFindComputersDlg;   // top level net search dialog
    class CFindPrintersDlg;    // top level printer search dialog

class CSubDlg;             // base class for subordinate dialogs
    class CDateDlg;            // file date subordinate dialog
    class CTypeDlg;            // file type subordinate dialog
    class CSizeDlg;            // file size subordinate dialog
    class CAdvancedDlg;        // advanced options subordinate dialog

interface IStringMru;

//  private messages posted to subdialogs
#define WMU_COMBOPOPULATIONCOMPLETE     (WM_USER+0x200) // (wParam: HWND of combo).
#define WMU_STATECHANGE                 (WM_USER+0x201) // 
#define WMU_UPDATELAYOUT                (WM_USER+0x202) // (wParam: Band layout flags (BLF_)).
#define WMU_RESTORESEARCH               (WM_USER+0x203) // (wParam: n/a, lParam: n/a, ret: n/a).
#define WMU_BANDINFOUPDATE              (WM_USER+0x204) // (wParam: NULL).
#define WMU_NAMESPACERECONCILE          (WM_USER+0x205) // (wParam: n/a, LPARAM: n/a).
#define WMU_BANDFINISHEDDISPLAYING      (WM_USER+0x306) // (wParam: NULL).

//  async state data
typedef struct tagFSEARCHTHREADSTATE
{
    HWND      hwndCtl;
    int       cItems;
    void*     pvParam;
    ULONG     Reserved;
    BOOL      fComplete;
    BOOL      fCancel;
    IUnknown* punkBand;

    //  constructor:
    tagFSEARCHTHREADSTATE() 
        :   hwndCtl(NULL), 
            cItems(0), 
            pvParam(NULL),
            Reserved(0),
            fComplete(FALSE),
            fCancel(FALSE),
            punkBand(NULL)
            {}
    ~tagFSEARCHTHREADSTATE() { ATOMICRELEASE(punkBand); }

} FSEARCHTHREADSTATE;


class CSubDlg // base class for subordinate dialogs
{
public:
    CSubDlg(CFileSearchBand* pfsb) : _pfsb(pfsb), _hwnd(NULL), _pBandDlg(NULL) {}
    virtual ~CSubDlg() {}

    HWND      Hwnd() const                       { return _hwnd; }
    void      SetBandDlg(CBandDlg* pBandDlg)   { _pBandDlg = pBandDlg; }
    CBandDlg* BandDlg() const                    { return _pBandDlg; }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd) PURE;
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue) PURE;
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual int  GetIdealDeskbandWidth() const { return -1;}
    virtual BOOL Validate()     { return TRUE; }
    virtual void Clear() PURE;
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave) {}
    virtual void OnWinIniChange()   {}
    virtual void DoDelayedInit()    {}          //  Called after search band displayed.

protected:
    BEGIN_MSG_MAP(CSubDlg)
        MESSAGE_HANDLER(WM_NCCALCSIZE, OnNcCalcsize)
        MESSAGE_HANDLER(WM_NCPAINT, OnNcPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColor)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        COMMAND_CODE_HANDLER(BN_SETFOCUS, OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(EN_SETFOCUS, OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(CBN_SETFOCUS, OnChildSetFocusCmd)
        NOTIFY_CODE_HANDLER(NM_SETFOCUS, OnChildSetFocusNotify) 
        COMMAND_CODE_HANDLER(BN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(EN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnChildKillFocusCmd)
        NOTIFY_CODE_HANDLER(NM_KILLFOCUS,   OnChildKillFocusNotify) 
        NOTIFY_CODE_HANDLER(CBEN_ENDEDIT,   OnComboExEndEdit) 
    END_MSG_MAP()

    LRESULT OnNcCalcsize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnNcPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnCtlColor(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnChildSetFocusCmd(WORD, WORD, HWND, BOOL&); 
    LRESULT OnChildSetFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnChildKillFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildKillFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnComboExEndEdit(int, LPNMHDR, BOOL&);

    void _Attach(HWND hwnd)    { _hwnd = hwnd; }
    CFileSearchBand* _pfsb;
    CBandDlg*        _pBandDlg;

private:
    HWND _hwnd;
};


// file date subordinate dialog
class CDateDlg : public CDialogImpl<CDateDlg>,
                 public CSubDlg
{
public:
    CDateDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CDateDlg() {}

    enum { IDD = DLG_FSEARCH_DATE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual BOOL Validate();
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CDateDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,       OnSize)
        NOTIFY_CODE_HANDLER(UDN_DELTAPOS, OnMonthDaySpin) 
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick)
        COMMAND_HANDLER(IDC_RECENT_MONTHS, EN_KILLFOCUS, OnMonthsKillFocus)
        COMMAND_HANDLER(IDC_RECENT_DAYS,   EN_KILLFOCUS, OnDaysKillFocus)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD,WORD,HWND,BOOL&);
    LRESULT OnMonthsKillFocus(WORD,WORD,HWND,BOOL&);
    LRESULT OnDaysKillFocus(WORD,WORD,HWND,BOOL&);
    LRESULT OnMonthDaySpin(int, LPNMHDR, BOOL&);

    //  utility methods
    void    EnableControls();
};


// file size subordinate dialog
class CSizeDlg : public CDialogImpl<CSizeDlg>,
                 public CSubDlg
{
public:
    CSizeDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CSizeDlg() {}

    enum { IDD = DLG_FSEARCH_SIZE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CSizeDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_FILESIZE_SPIN, UDN_DELTAPOS, OnSizeSpin) 
        COMMAND_HANDLER(IDC_FILESIZE, EN_KILLFOCUS, OnSizeKillFocus)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSizeSpin(int, LPNMHDR, BOOL&);
    LRESULT OnSizeKillFocus(WORD,WORD,HWND,BOOL&);
};


// CTypeDlg - file type subordinate dialog
class CTypeDlg : public CDialogImpl<CTypeDlg>,
                 public CSubDlg
{
public:
    CTypeDlg(CFileSearchBand* pfsb);
    ~CTypeDlg();

    enum { IDD = DLG_FSEARCH_TYPE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();
    virtual void OnWinIniChange();
    virtual void DoDelayedInit();              //  Called after search band displayed.

protected:
    BEGIN_MSG_MAP(CTypeDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,       OnSize)
        MESSAGE_HANDLER(WMU_COMBOPOPULATIONCOMPLETE, OnComboPopulationComplete)
        MESSAGE_HANDLER(WM_DESTROY,    OnDestroy)
        NOTIFY_HANDLER(IDC_FILE_TYPE, CBEN_DELETEITEM, OnFileTypeDeleteItem) 
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnFileTypeDeleteItem(int, LPNMHDR, BOOL&);
    LRESULT OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&);

    //  utility methods
    static HRESULT  AddItemNotify(ULONG, PCBXITEM, LPARAM);
    static DWORD    FileAssocThreadProc(void* pv);
    static INT_PTR  _FindExtension(HWND hwndCombo, TCHAR* pszExt);

    //  data
    FSEARCHTHREADSTATE  _threadState;
    TCHAR               _szRestoredExt[MAX_PATH];
};


// CAdvancedDlg - advanced options subordinate dialog
class CAdvancedDlg : public CDialogImpl<CAdvancedDlg>,
                     public CSubDlg

{
public:
    CAdvancedDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CAdvancedDlg() {}
    enum { IDD = DLG_FSEARCH_ADVANCED };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CAdvancedDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
};


class COptionsDlg : public CDialogImpl<COptionsDlg>,
                    public CSubDlg

{
public:
    COptionsDlg(CFileSearchBand* pfsb);
    ~COptionsDlg() {}

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave);
    virtual BOOL GetMinSize(LPSIZE pSize);
    virtual BOOL Validate();
    virtual void Clear();
    virtual void OnWinIniChange();

    void UpdateSearchCmdStateUI(DISPID dispid = 0);
    LONG QueryHeight(LONG cx, LONG cy);
    virtual HWND GetBottomItem();

    BOOL IsAdvancedOptionChecked(UINT nID)    {
        return _dlgAdvanced.IsDlgButtonChecked(nID) ? TRUE : FALSE ;
    }
    void TakeFocus();
    void DoDelayedInit();

    enum { IDD = DLG_FSEARCH_OPTIONS };

protected:
    BEGIN_MSG_MAP(COptionsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,   OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,         OnSize)
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick)
        NOTIFY_HANDLER(IDC_INDEX_SERVER, NM_CLICK,  OnIndexServerClick)
        NOTIFY_HANDLER(IDC_INDEX_SERVER, NM_RETURN, OnIndexServerClick)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  messsage handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD,WORD,HWND,BOOL&);
    LRESULT OnIndexServerClick(int, LPNMHDR, BOOL&);

    //  utility methods
    void LayoutControls(int cx = -1, int cy = -1);
    void SizeToFit(BOOL bScrollBand = FALSE);

    //  data
private:
    //  private subdialog identifiers
    enum SUBDLGID
    {
        SUBDLG_DATE,
        SUBDLG_TYPE,
        SUBDLG_SIZE,
        SUBDLG_ADVANCED,

        SUBDLG_Count
    };
    
    //  subdialog instances
    CDateDlg          _dlgDate;
    CTypeDlg          _dlgType;
    CSizeDlg          _dlgSize;
    CAdvancedDlg      _dlgAdvanced;

    //  subdialog data definition block.
    typedef struct {
        UINT nIDCheck;
        CSubDlg* pDlg;
        SIZE sizeDlg;
        RECT rcCheck;
        RECT rcDlg;
    } _SUBDLG;
    _SUBDLG      _subdlgs[SUBDLG_Count];
    
    //  misc
    UINT _nCIStatusText; 
};

// top level dialog base class
class CBandDlg
{
public:
    CBandDlg(CFileSearchBand* pfsb);
    ~CBandDlg();

    HWND Hwnd() const           { return _hwnd; }

    //  manditory overrideables
    virtual HWND Create(HWND hwndParent) = 0;
    virtual UINT GetIconID() const = 0;
    virtual UINT GetCaptionID() const = 0;
    virtual UINT GetCaptionDivID() const = 0;

    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void RemoveToolbarTurds(int cyOffset);

    //  optional overrideables
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate()     { return TRUE; }
    virtual void Clear() {};
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual BOOL GetIdealSize(HWND hwndOC, LPSIZE pSize) const;
    virtual int  GetIdealDeskbandWidth() const { return -1; }
    virtual void SetDefaultFocus();
    virtual HWND GetFirstTabItem() const    { return NULL; }
    virtual HWND GetLastTabItem() const     { return NULL; }
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    virtual void NavigateToResults(IWebBrowser2* pwb2) {}
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave) {}
    virtual HWND ShowHelp(HWND hwndOwner) { return NULL; }
    virtual void OnWinIniChange()    {}
    virtual void WndPosChanging(HWND hwndOC, LPWINDOWPOS pwp);
    virtual void RememberFocus(HWND hwndFocus);
    virtual BOOL RestoreFocus();

    virtual void OnBandShow(BOOL bShow)   {}          //**band** show/hide handler
    virtual void OnBandDialogShow(BOOL bShow)   {}    //band **dialog** show/hide handler
    virtual HRESULT SetScope(IN VARIANT* pvarScope, BOOL bTrack = FALSE);
    virtual HRESULT GetScope(OUT VARIANT* pvarScope);
    virtual HRESULT SetQueryFile(IN VARIANT* pvarScope);
    virtual HRESULT GetQueryFile(OUT VARIANT* pvarScope);

    virtual BOOL    SearchInProgress() const { return FALSE; };
    virtual void    StopSearch() {};
protected:
    BEGIN_MSG_MAP(CBandDlg)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColorStatic)
        COMMAND_CODE_HANDLER(BN_SETFOCUS,   OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(EN_SETFOCUS,   OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(CBN_SETFOCUS,  OnChildSetFocusCmd)
        NOTIFY_CODE_HANDLER(NM_SETFOCUS,    OnChildSetFocusNotify) 

        COMMAND_CODE_HANDLER(BN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(EN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnChildKillFocusCmd)
        NOTIFY_CODE_HANDLER(NM_KILLFOCUS,   OnChildKillFocusNotify) 
        NOTIFY_CODE_HANDLER(CBEN_ENDEDIT,   OnComboExEndEdit) 
    END_MSG_MAP()

    // message handlers
    LRESULT OnPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnCtlColorStatic(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchLink(int, LPNMHDR, BOOL&);
    LRESULT OnEditChange(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildSetFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildSetFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnChildKillFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildKillFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnComboExEndEdit(int, LPNMHDR, BOOL&);

    //  utility methods:
    void _Attach(HWND hwnd)    { _hwnd = hwnd; }
    void _BeautifyCaption(UINT nIDCaption, UINT nIDIcon=0, UINT nIDIconResource=0);
    void _LayoutCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDDiv, LONG cxDlg);
    void _LayoutSearchLinks(UINT nIDCaption, UINT nIDDiv, BOOL bShowDiv, 
                             LONG left, LONG right, LONG yMargin, LONG& yStart, 
                             const int rgLinkIDs[], LONG cLinkIDs);

    CFileSearchBand* _pfsb;      // master band object
    VARIANT          _varScope0;
    VARIANT          _varQueryFile0;
    HWND             _hwndLastFocus;

private:
    HWND             _hwnd;
};

inline BOOL CBandDlg::GetMinSize(HWND hwndOC, LPSIZE pSize) const { 
    pSize->cx = pSize->cy = 0; return TRUE;
}

inline BOOL CBandDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2) { 
    *ppac2 = NULL; return FALSE;
}

//  Band dialog as searchCmdExt object wrap and event sink.
class CSearchCmdDlg : public DSearchCommandEvents, public CBandDlg
{
public:
    CSearchCmdDlg(CFileSearchBand* pfsb);
    ~CSearchCmdDlg();
    
    // ISearchCommandExt event sink

    //  IUnknown
    STDMETHOD (QueryInterface) (REFIID riid, void** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods 
    STDMETHOD(GetTypeInfoCount)(UINT*)              { return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo**) { return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR**, UINT, LCID, DISPID*) { return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);

    //  CBandDlg overrides
    virtual HWND Create(HWND hwndParent) = 0;
    virtual void Clear();
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);


    //  CSearchCmdDlg methods
    ISearchCommandExt* GetSearchCmd();
    virtual BOOL SearchInProgress() const { return _fSearchInProgress; }
    BOOL         SearchAborted() const    { return _fSearchAborted; }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd) { return E_NOTIMPL; }
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue) { return E_NOTIMPL; }

    HRESULT      StartSearch();
    virtual void StopSearch();
    HRESULT      SetQueryFile(IN VARIANT* pvarScope);

    HRESULT      DisconnectEvents();
    static void  EnableStartStopButton(HWND hwndBtn, BOOL bEnable);

    //  Overrideables
    virtual int  GetSearchType() const = 0; // ret: SCE_SEARCHFORxxx
    virtual HWND GetAnimation() { return NULL ; }

    virtual void UpdateSearchCmdStateUI(DISPID dispid = 0);
    virtual BOOL OnSearchCmdError(HRESULT hr, LPCTSTR pszError);
    virtual void UpdateStatusText();
    virtual void StartStopAnimation(BOOL bStart) ;
    virtual void RestoreSearch() {};
    virtual void OnBandShow(BOOL bShow) ;

protected:
    BOOL ProcessCmdError();

    BEGIN_MSG_MAP(CSearchCmdDlg)
        MESSAGE_HANDLER(WMU_RESTORESEARCH, OnRestoreSearch)
    CHAIN_MSG_MAP(CBandDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnRestoreSearch(UINT, WPARAM, LPARAM, BOOL&);

protected:
    //  utility methods
    HRESULT Execute(BOOL bStart);
    
    //  data
    IConnectionPoint*   _pcp;
    DWORD               _dwConnection;
    ISearchCommandExt*  _pSrchCmd;
    BOOL                _fSearchInProgress,
                        _fSearchAborted,
                        _fOnDestroy;
};

// top level dialog for Search for Files and Folders UI
class CFindFilesDlg : public CDialogImpl<CFindFilesDlg>, 
                      public CSearchCmdDlg
{
public:
    CFindFilesDlg(CFileSearchBand* pfsb);
    ~CFindFilesDlg();

    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_FSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_FSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual int  GetIdealDeskbandWidth() const;
    virtual void NavigateToResults(IWebBrowser2* pwb2);
    virtual HWND ShowHelp(HWND hwndOwner);

    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);

    virtual int  GetSearchType() const  { return SCE_SEARCHFORFILES; }
    virtual HWND GetAnimation() { return GetDlgItem(IDC_FSEARCH_ICON); }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void UpdateSearchCmdStateUI(DISPID eventID = 0);
    virtual void RestoreSearch();
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave);
    virtual BOOL OnSearchCmdError(HRESULT hr, LPCTSTR pszError);


    BOOL SetDefaultScope();
    virtual void OnBandShow(BOOL bShow);
    virtual void OnBandDialogShow(BOOL bShow);

    virtual HRESULT SetScope(IN VARIANT* pvarScope, BOOL bTrack = FALSE);
    BOOL AssignNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszNamespace, BOOL bPassive /*only if no current selection*/);
    BOOL GetMinMaxInfo(HWND hwndOC, LPMINMAXINFO pmmi);
    void OnWinIniChange();

    enum { IDD = DLG_FSEARCH_MAIN };

    BEGIN_MSG_MAP(CFindFilesDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WMU_COMBOPOPULATIONCOMPLETE, OnComboPopulationComplete)
        MESSAGE_HANDLER(WMU_STATECHANGE, OnStateChange)
        MESSAGE_HANDLER(WMU_UPDATELAYOUT, OnUpdateLayout) 
        MESSAGE_HANDLER(WMU_NAMESPACERECONCILE, OnNamespaceReconcileMsg)
        MESSAGE_HANDLER(WMU_BANDFINISHEDDISPLAYING, OnBandFinishedDisplaying);
        COMMAND_HANDLER(IDC_FILESPEC,   EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_GREPTEXT,   EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_EDITCHANGE, OnNamespaceEditChange)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_SELENDOK, OnNamespaceSelEndOk)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_SELENDCANCEL, OnNamespaceReconcileCmd)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_DROPDOWN, OnNamespaceReconcileCmd)
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick);
        NOTIFY_HANDLER(IDC_NAMESPACE, CBEN_DELETEITEM, OnNamespaceDeleteItem) 
        NOTIFY_HANDLER(IDC_NAMESPACE, CBEN_ENDEDIT, OnNamespaceReconcileNotify) 
        NOTIFY_HANDLER(IDC_SEARCHLINK_OPTIONS,   NM_CLICK, OnOptions)
        NOTIFY_HANDLER(IDC_SEARCHLINK_OPTIONS,   NM_RETURN, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     NM_CLICK, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     NM_RETURN, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     GBN_QUERYBUDDYHEIGHT, OnQueryOptionsHeight)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)

        CHAIN_MSG_MAP(CSearchCmdDlg) // fall through to base class handlers
    END_MSG_MAP()

protected:
    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnStateChange(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnTimer(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnUpdateLayout(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceDeleteItem(int, LPNMHDR, BOOL&);
    LRESULT OnNamespaceEditChange(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceSelEndOk(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceReconcileCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceReconcileNotify(int, LPNMHDR, BOOL&);
    LRESULT OnNamespaceReconcileMsg(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnOptions(int, LPNMHDR, BOOL&);
    LRESULT OnQueryOptionsHeight(int, LPNMHDR, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBandFinishedDisplaying(UINT, WPARAM, LPARAM, BOOL&);

private:
    //  misc utility methods
    void                _ShowOptions(BOOL bShow = TRUE);
    LPARAM              _GetComboData(UINT id, INT_PTR idx);

    //  namespace scoping
    BOOL                _SetPreassignedScope();
    BOOL                _SetFolderScope();
    BOOL                _SetLocalDefaultScope();
    void                _ShowNamespaceEditImage(BOOL bShow);

    //  ad hoc namespace handling
    BOOL                _PathFixup(LPTSTR pszDst, LPCTSTR pszSrc);
    BOOL                _ShouldReconcileNamespace();
    void                _UIReconcileNamespace(BOOL bAsync = FALSE);
    INT_PTR             _ReconcileNamespace(OPTIONAL BOOL bAsync = FALSE);
    INT_PTR             _AddNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bSelectItem);

    //  namespace browsing
    void                _BrowseAndAssignNamespace();
    HRESULT             _BrowseForNamespace(LPTSTR pszPath, UINT cchPath, LPITEMIDLIST* ppidlRet);
    static int          _BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);

    //  more namespace helpers
    BOOL                _IsSearchableFolder(LPCITEMIDLIST pidlFolder);
    HRESULT             _GetTargetNamespace(IEnumIDList **ppenum);
    IEnumIDList         *_GetItems(INT_PTR i);
    INT_PTR             _FindNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl);

private:
    //  namespace combo thread
    static HRESULT      AddNamespaceItemNotify(ULONG, PCBXITEM, LPARAM);
    static DWORD        NamespaceThreadProc(void *pv);

    //  data
    COptionsDlg         _dlgOptions;
    FSEARCHTHREADSTATE  _threadState;
    TCHAR               _szInitialNames[MAX_PATH],          // SHGDN_NORMAL
                        _szInitialPath[MAX_PATH];           // SHGDN_FORPARSING
    LPITEMIDLIST        _pidlInitial;                       // Stores the initial PDIL                   
    TCHAR               _szCurrentPath[MAX_PATH];
    TCHAR               _szLocalDrives[MAX_URL_STRING];
    ULONG               _dwWarningFlags;        // docfind warning bits.
    BOOL                _dwRunOnceWarningFlags; 

    LRESULT             _iCurNamespace;     // combobox item index for currently selected namespace.
    BOOL                _fDebuted,          // this band dialog has been displayed before.
                        _bScoped,           // ve assigned a value to the namespace combo.
                        _fNamespace,        // TRUE if the user has been typing in the namespace combo.
                        _fDisplayOptions;   // Search Options group box is displayed

    IAutoComplete2*     _pacGrepText;       // 'Containing Text' autocomplete object    
    IStringMru*         _pmruGrepText;      // 'Containing Text' mru object
    IAutoComplete2*     _pacFileSpec;       // 'Files Named' autocomplete object    
    IStringMru*         _pmruFileSpec;      // 'Files Named' mru object

    enum {
        TRACKSCOPE_NONE,
        TRACKSCOPE_GENERAL,
        TRACKSCOPE_SPECIFIC,
    } ;
    ULONG               _fTrackScope;       // defines scope-tracking behavior.  See TRACKSCOPE_xxx flags
    BOOL                _fBandFinishedDisplaying; // TRUE if we have already resceived WMU_BANDFINISHEDDISPLAYING
};

inline HWND CFindFilesDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindFilesDlg>::Create(hwndParent);
}

#ifdef __PSEARCH_BANDDLG__

// CFindPrintersDlg - top level dialog for Search for Printers UI
class CFindPrintersDlg : public CDialogImpl<CFindPrintersDlg>,
                         public CBandDlg
{
public:
    CFindPrintersDlg(CFileSearchBand* pfsb);
    ~CFindPrintersDlg();

    // overrides of CBandDlg    
    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_PSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_PSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void OnWinIniChange();

    enum { IDD = DLG_PSEARCH };

protected:
    BEGIN_MSG_MAP(CFindPrintersDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER(IDC_PSEARCH_NAME,      EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_PSEARCH_LOCATION,  EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_PSEARCH_MODEL,     EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_SEARCH_START,      BN_CLICKED,  OnSearchStartBtn)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)
    CHAIN_MSG_MAP(CBandDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchStartBtn(WORD, WORD, HWND, BOOL&);
};

inline HWND CFindPrintersDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindPrintersDlg>::Create(hwndParent);
}
#endif __PSEARCH_BANDDLG__


// CFindComputersDlg - top level dialog for Search for Computers UI
class CFindComputersDlg : public CDialogImpl<CFindComputersDlg>,
                          public CSearchCmdDlg
{
public:
    CFindComputersDlg(CFileSearchBand* pfsb);
    ~CFindComputersDlg();

    // overrides of CBandDlg    
    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_CSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_CSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual void NavigateToResults(IWebBrowser2* pwb2);

    virtual HWND ShowHelp(HWND hwndOwner);
    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void OnWinIniChange();
    
    virtual int  GetSearchType() const  { return SCE_SEARCHFORCOMPUTERS; }
    virtual HWND GetAnimation() { return GetDlgItem(IDC_CSEARCH_ICON); }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    virtual void UpdateStatusText();
    virtual void RestoreSearch();

    enum { IDD = DLG_CSEARCH };

protected:

    BEGIN_MSG_MAP(CFindComputersDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        COMMAND_HANDLER(IDC_CSEARCH_NAME,      EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_SEARCH_START,      BN_CLICKED,  OnSearchStartBtn)
        COMMAND_HANDLER(IDC_SEARCH_STOP,       BN_CLICKED,  OnSearchStopBtn)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)
    CHAIN_MSG_MAP(CSearchCmdDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchStartBtn(WORD, WORD, HWND, BOOL&);
    LRESULT OnSearchStopBtn(WORD, WORD, HWND, BOOL&);

    //  data
    IAutoComplete2*     _pacComputerName;    // 'Files Named' autocomplete object    
    IStringMru*         _pmruComputerName;   // 'Files Named' mru object
};

inline HWND CFindComputersDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindComputersDlg>::Create(hwndParent);
}


DECLARE_INTERFACE_(IStringMru, IUnknown)
{
    // *** IStringMru specific methods ***
    STDMETHOD(Add)(LPCOLESTR pwszAdd) PURE;
};
extern const IID IID_IStringMru;


class CStringMru : public IStringMru, public IEnumString
{
public:
    static  HRESULT CreateInstance(HKEY hKey, LPCTSTR szSubKey, LONG cMaxStrings, BOOL bCaseSensitive,
                                    REFIID riid, void ** ppv); 
protected:
    // IUnknown
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IStringMru
    virtual STDMETHODIMP Add(LPCOLESTR pwsz);  // adds or promotes a string

    // IEnumString
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum)    { return E_NOTIMPL; }

private:
    CStringMru();
    ~CStringMru();

    HRESULT _Open();
    HRESULT _Read(OUT OPTIONAL LONG* pcRead = NULL /*count of strings read*/);
    HRESULT _Write(OUT OPTIONAL LONG* pcWritten = NULL /*count of strings written*/);
    HRESULT _Promote(LONG iString);
    void    _Close();
    void    _Delete();
    void    _Clear(); 

    HKEY    _hKey,
            _hKeyRoot;
    TCHAR   _szSubKey[MAX_PATH];
    LONG    _cRef;
    BOOL    _bCaseSensitive;
    LONG    _cMax;
    LONG    _iString;
    HDPA    _hdpaStrings;
};

//  DivWindow registration
#define  DIVWINDOW_CLASS     TEXT("DivWindow")

#define  DWM_FIRST          (WM_USER+0x300)
#define  DWM_SETHEIGHT      (DWM_FIRST+0)   // WPARAM: height in pixels, LPARAM: n/a, ret: BOOL
#define  DWM_SETBKCOLOR     (DWM_FIRST+1)   // WPARAM: COLORREF, LPARAM: n/a, ret: BOOL

//--------------------//
//  Helper macros
#define POINTSPERRECT   (sizeof(RECT)/sizeof(POINT))

//---------------------//
//  Misc utility
LONG _PixelsForDbu(HWND hwndDlg, LONG cDbu, BOOL bHorz);

#endif //__FSEARCH_DLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findfilter.h ===
#ifndef _INC_DOCFIND
#define _INC_DOCFIND

// for the OLEDB query stuff
#define OLEDBVER 0x0250 // enable ICommandTree interface
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledbdep.h>
#include <query.h>
#include <stgprop.h>
#include <ntquery.h>

#include <idhidden.h>

// reg location where we store bad paths that ci should not have indexed
#define CI_SPECIAL_FOLDERS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\SpecialFolders")

// Define some options that are used between filter and search code
#define DFOO_INCLUDESUBDIRS     0x0001      // Include sub directories.
#define DFOO_SHOWALLOBJECTS     0x1000      // Show all files
#define DFOO_CASESEN            0x0008      // Do case sensitive search         
#define DFOO_SEARCHSYSTEMDIRS   0x0010      // Search into system directories

// Some error happended on the get next file...
#define GNF_ERROR       -1
#define GNF_DONE        0
#define GNF_MATCH       1
#define GNF_NOMATCH     2
#define GNF_ASYNC       3

// Define a FACILITY That we can check errors for...
#define FACILITY_SEARCHCOMMAND      99

#undef  INTERFACE
#define INTERFACE       IFindEnum

DECLARE_INTERFACE_(IFindEnum, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindEnum
    STDMETHOD(Next)(THIS_ LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState) PURE;
    STDMETHOD (Skip)(THIS_ int celt) PURE;
    STDMETHOD (Reset)(THIS) PURE;
    STDMETHOD (StopSearch)(THIS) PURE;
    STDMETHOD_(BOOL,FQueryIsAsync)(THIS) PURE;
    STDMETHOD (GetAsyncCount)(THIS_ DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone) PURE;
    STDMETHOD (GetItemIDList)(THIS_ UINT iItem, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (GetItemID)(THIS_ UINT iItem, DWORD *puWorkID) PURE;
    STDMETHOD (SortOnColumn)(THIS_ UINT iCol, BOOL fAscending) PURE;
};

// We overloaded Async case when we are in mixed (some async some sync mode)
#define DF_QUERYISMIXED     ((BOOL)42)

typedef interface IFindFolder IFindFolder;

#undef  INTERFACE
#define INTERFACE       IFindFilter
DECLARE_INTERFACE_(IFindFilter, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindFilter
    STDMETHOD(GetStatusMessageIndex)(THIS_ UINT uContext, UINT *puMsgIndex) PURE;
    STDMETHOD(GetFolderMergeMenuIndex)(THIS_ UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu) PURE;
    STDMETHOD(FFilterChanged)(THIS) PURE;
    STDMETHOD(GenerateTitle)(THIS_ LPTSTR *ppszTile, BOOL fFileName) PURE;
    STDMETHOD(PrepareToEnumObjects)(THIS_ HWND hwnd, DWORD *pdwFlags) PURE;
    STDMETHOD(ClearSearchCriteria)(THIS) PURE;
    STDMETHOD(EnumObjects)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidlStart,
            DWORD grfFlags, int iColSort, LPTSTR pszProgressText, IRowsetWatchNotify *prwn, 
            IFindEnum **ppdfenum) PURE;
    STDMETHOD(GetColumnsFolder)(THIS_ IShellFolder2 **ppsf) PURE;
    STDMETHOD_(BOOL,MatchFilter)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SaveCriteria)(THIS_ IStream * pstm, WORD fCharType) PURE;   
    STDMETHOD(RestoreCriteria)(THIS_ IStream * pstm, int cCriteria, WORD fCharType) PURE;
    STDMETHOD(DeclareFSNotifyInterest)(THIS_ HWND hwndDlg, UINT uMsg) PURE;
    STDMETHOD(GetColSaveStream)(THIS_ WPARAM wParam, IStream **ppstm) PURE;
    STDMETHOD(GenerateQueryRestrictions)(THIS_ LPWSTR *ppwszQuery, DWORD *pdwGQRFlags) PURE;
    STDMETHOD(ReleaseQuery)(THIS) PURE;
    STDMETHOD(UpdateField)(THIS_ LPCWSTR pszField, VARIANT vValue) PURE;
    STDMETHOD(ResetFieldsToDefaults)(THIS) PURE;
    STDMETHOD(GetItemContextMenu)(THIS_ HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu** ppcm) PURE;
    STDMETHOD(GetDefaultSearchGUID)(THIS_ IShellFolder2 *psf2, LPGUID lpGuid) PURE;
    STDMETHOD(EnumSearches)(THIS_ IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum) PURE;
    STDMETHOD(GetSearchFolderClassId)(THIS_ LPGUID lpGuid) PURE;
    STDMETHOD(GetNextConstraint)(THIS_ VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound) PURE;
    STDMETHOD(GetQueryLanguageDialect)(THIS_ ULONG * pulDialect);
    STDMETHOD(GetWarningFlags)(THIS_ DWORD *pdwWarningFlags);
};


// Define the flags that GenerateQueryRestrictions may return
typedef enum {
    GQR_MAKES_USE_OF_CI =   0x0001, // some constraint makes resonable use of Content index
    GQR_REQUIRES_CI     =   0x0002, // The query requires the CI to work
    GQR_BYBASS_CI       =   0x0004, // The query should bybass CI.
} GQR_FLAGS;

//  Docfind UI warning bits.
#define DFW_DEFAULT                0x00000000  
#define DFW_IGNORE_CISCOPEMISMATCH 0x00000001 // CI query requested search scopes beyond indexed scopes
#define DFW_IGNORE_INDEXNOTCOMPLETE 0x00000002 // ci not done indexing

#define ESFITEM_ICONOVERLAYSET    0x00000001
typedef struct
{
    DWORD       dwMask;
    DWORD       dwState;    // State of the item;
    int         iIcon;
    ITEMIDLIST  idl;        // find pidl bits (with hidden stuff embedded), variable length
} FIND_ITEM;

// Currently the state above is LVIS_SELECTED and LVIS_FOCUSED (low two bits)
// Add a bit to use in the processing of updatedir
#define CDFITEM_STATE_MAYBEDELETE    0x80000000L
#define CDFITEM_STATE_MASK           (LVIS_SELECTED)    // Which states we will hav LV have us track

// Definition of the data items that we cache per directory.
typedef struct
{
    IShellFolder *      psf;        // Cache of MRU items
    BOOL                fUpdateDir:1; // Was this node touched by an updatedir...
    BOOL                fDeleteDir:1; // Was this directory removed from the list?
    // Allocate the pidl at end as variable length
    ITEMIDLIST idl;      // the pidl
} FIND_FOLDER_ITEM;


#pragma pack(1)
typedef struct
{
    HIDDENITEMID hid;
    WORD    iFolder;        // index to the folder DPA
    WORD    wFlags;
    UINT    uRow;           // Which row in the CI;
    DWORD   dwItemID;       // Only used for Async support...
    ULONG   ulRank;         // The rank returned by CI...
    ITEMIDLIST idlParent;   // the pidl of the folder this thing came from (fully qualified!)
} HIDDENDOCFINDDATA;
#pragma pack()

#define DFDF_NONE               0x0000
#define DFDF_EXTRADATA          0x0001

typedef UNALIGNED HIDDENDOCFINDDATA * PHIDDENDOCFINDDATA;
typedef const UNALIGNED HIDDENDOCFINDDATA * PCHIDDENDOCFINDDATA;

//
// Define structure that will be saved out to disk.
//
#define DOCFIND_SIG     (TEXT('D') | (TEXT('F') << 8))
typedef struct
{
    WORD    wSig;       // Signature
    WORD    wVer;       // Version
    DWORD   dwFlags;    // Flags that controls the sort
    WORD    wSortOrder; // Current sort order
    WORD    wcbItem;    // Size of the fixed portion of each item.
    DWORD   oCriteria;  // Offset to criterias in list
    long    cCriteria;  // Count of Criteria
    DWORD   oResults;   // Starting location of results in file
    long    cResults;   // Count of items that have been saved to file
    UINT    ViewMode;   // The view mode of the file...
} DFHEADER_WIN95;

typedef struct
{
    WORD    wSig;       // Signature
    WORD    wVer;       // Version
    DWORD   dwFlags;    // Flags that controls the sort
    WORD    wSortOrder; // Current sort order
    WORD    wcbItem;    // Size of the fixed portion of each item.
    DWORD   oCriteria;  // Offset to criterias in list
    long    cCriteria;  // Count of Criteria
    DWORD   oResults;   // Starting location of results in file
    long    cResults;   // Count of items that have been saved to file
    UINT    ViewMode;   // The view mode of the file...
    DWORD   oHistory;   // IPersistHistory::Save offset
} DFHEADER;

// The check in Win95/NT4 would fail to read the DFHEADER structure if
// the wVer field was > 3, which is unfortunate since the DFHEADER struct is
// backwards compiatible (that's why it uses offsets).  So we either
// go through the pain of revving the stream format in a backwards
// compatible way (not impossible, just a pain in the brain), or simply
// rev the version and add our new fields and call the Win95/NT4 problem
// a bug and punt.  I'm leaning towards "bug" as this is a rarely used feature.
#define DF_CURFILEVER_WIN95  3
#define DF_CURFILEVER        4

// define the format of the column information.
typedef struct
{
    WORD    wNum;       // Criteria number (cooresponds to dlg item id)
    WORD    cbText;     // size of text including null char (DavePl: code using this now assumes byte count)
} DFCRITERIA;

// Formats for saving find criteria.
#define DFC_FMT_UNICODE   1
#define DFC_FMT_ANSI      2

// This is a subset of fileinfo structure
typedef struct
{
    WORD    flags;          // FIF_ bits
    WORD    timeLastWrite;
    WORD    dateLastWrite;
    WORD    dummy;              // 16/32 bit compat.
                                //the compiler adds this padding
                                // remove and use if needed
    DWORD   dwSize;     // size of the file
    WORD    cbPath;     // size of the text (0 implies use previous files)
    WORD    cbName;     // Size of name including NULL.
} DFITEM;

STDAPI CreateNameSpaceFindFilter(IFindFilter **ppff);
STDAPI_(BOOL) SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR * pszSpecOut);

STDAPI CreateDefaultComputerFindFilter(IFindFilter **ppff);

STDAPI CreateOleDBEnum(
    IFindFilter * pdfff,
    IShellFolder *psf,
    LPWSTR *apwszPaths,
    UINT    *pcPaths,
    DWORD grfFlags,
    int iColSort,
    LPTSTR pszProgressText,
    IRowsetWatchNotify *prwn,
    IFindEnum **ppdfenum);


#undef  INTERFACE
#define INTERFACE       IFindControllerNotify

// This interface is used to let the callback class talk to the class that is actually controlling
// the queries and the like.
DECLARE_INTERFACE_(IFindControllerNotify, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IFindControllerNotify methods ***
    STDMETHOD(DoSortOnColumn)(THIS_ UINT iCol, BOOL fSameCol) PURE;
    STDMETHOD(SaveSearch)(THIS) PURE;
    STDMETHOD(RestoreSearch)(THIS) PURE;
    STDMETHOD(StopSearch)(THIS) PURE;
    STDMETHOD(GetItemCount)(THIS_ UINT *pcItems) PURE;
    STDMETHOD(SetItemCount)(THIS_ UINT cItems) PURE;
    STDMETHOD(ViewDestroyed)(THIS) PURE;
};


typedef struct {
    LPITEMIDLIST pidlSaveFile;  // [in, out] most recent pidl saved to
    DWORD dwFlags;              // [in, out] current flag state
    int SortMode;               // [in]      current sort mode
} DFBSAVEINFO;


#undef  INTERFACE
#define INTERFACE       IFindFolder

DECLARE_INTERFACE_(IFindFolder, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // IFindFolder
    STDMETHOD(GetFindFilter)(THIS_ IFindFilter  **pdfff) PURE;
    STDMETHOD(AddPidl)(THIS_ int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppItem) PURE;
    STDMETHOD(GetItem)(THIS_ int iItem, FIND_ITEM **ppItem) PURE;
    STDMETHOD(DeleteItem)(THIS_ int iItem) PURE;
    STDMETHOD(GetItemCount)(THIS_ INT *pcItems) PURE;
    STDMETHOD(ValidateItems)(THIS_ IUnknown *punk, int iItemFirst, int cItems, BOOL bSearchComplete) PURE;
    STDMETHOD(GetFolderListItemCount)(THIS_ INT *pcCount) PURE;
    STDMETHOD(GetFolderListItem)(THIS_ int iItem, FIND_FOLDER_ITEM **ppItem) PURE;
    STDMETHOD(GetFolder)(THIS_ int iFolder, REFIID riid, void **ppv) PURE;
    STDMETHOD_(UINT,GetFolderIndex)(THIS_ LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SetItemsChangedSinceSort)(THIS) PURE;
    STDMETHOD(ClearItemList)(THIS) PURE;
    STDMETHOD(ClearFolderList)(THIS) PURE;
    STDMETHOD(AddFolder)(THIS_ LPITEMIDLIST pidl, BOOL fCheckForDup, int *piFolder) PURE;
    STDMETHOD(SetAsyncEnum)(THIS_ IFindEnum *pdfEnumAsync) PURE;
    STDMETHOD(GetAsyncEnum)(THIS_ IFindEnum **ppdfEnumAsync) PURE;
    STDMETHOD(SetAsyncCount)(THIS_ DBCOUNTITEM cCount) PURE;
    STDMETHOD(CacheAllAsyncItems)(THIS) PURE;
    STDMETHOD_(BOOL,AllAsyncItemsCached)(THIS) PURE;
    STDMETHOD(ClearSaveStateList)(THIS) PURE;
    STDMETHOD(GetStateFromSaveStateList)(THIS_ DWORD dwItemID, DWORD *pdwState) PURE;
    STDMETHOD(MapToSearchIDList)(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD(GetParentsPIDL)(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent) PURE;
    STDMETHOD(RememberSelectedItems)(THIS) PURE;
    STDMETHOD(SetControllerNotifyObject)(IFindControllerNotify *pdfcn) PURE;
    STDMETHOD(GetControllerNotifyObject)(IFindControllerNotify **ppdfcn) PURE;
    STDMETHOD(SaveFolderList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(RestoreFolderList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(SaveItemList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(RestoreItemList)(THIS_ IStream *pstm, int *pcItems) PURE;
    STDMETHOD(RestoreSearchFromSaveFile)(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv) PURE;

    STDMETHOD_(BOOL,HandleUpdateDir)(LPCITEMIDLIST pidl, BOOL fCheckSubDirs) PURE;
    STDMETHOD_(void,HandleRMDir)(IShellFolderView *psfv, LPCITEMIDLIST pidl) PURE;
    STDMETHOD_(void,UpdateOrMaybeAddPidl)(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld) PURE;
    STDMETHOD_(void,Save)(IFindFilter* pdfff, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown * pObject) PURE;
    STDMETHOD(OpenContainingFolder)(IUnknown *punkSite) PURE;

    STDMETHOD(AddDataToIDList)(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl) PURE;
};

STDAPI CFindItem_Create(HWND hwnd, IFindFolder *pdfFolder, IContextMenu **ppcm);

EXTERN_C const GUID IID_IFindFolder;
EXTERN_C const GUID IID_IFindFilter;
EXTERN_C const GUID IID_IFindControllerNotify;

#endif   // !_INC_DOCFIND
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\finddlg.cpp ===
#include "shellprv.h"
#include "findband.h"
#include "finddlg.h"
#include "findfilter.h"     // DFW_xxx warning flags.
#include "enumidlist.h"

void DivWindow_RegisterClass();

//  Namespace picker combo methods.
STDAPI PopulateNamespaceCombo(HWND hwndComboEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam);

#define MAX_EDIT                256
#define SUBDLG_BORDERWIDTH      0
#define MIN_NAMESPACELIST_WIDTH 140
#define MIN_FILEASSOCLIST_WIDTH 175

#define LSUIS_WARNING  1  // LoadSaveUIState warning flags

int  CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgTemplate, BOOL* pbNoWarn);
int  CCISettingsDlg_DoModal(HWND hwndParent);

BOOL IsConstraintName(LPCWSTR pwszConstraint, LPCWSTR pwszName)
{
    return pwszName && (0 == StrCmpIW(pwszName, pwszConstraint));
}

BOOL _GetWindowSize(HWND hwndDlg, SIZE *pSize)
{
    RECT rc;
    if (::GetClientRect(hwndDlg, &rc))
    {
        pSize->cx = RECTWIDTH(rc);
        pSize->cy = RECTHEIGHT(rc);
        return TRUE;
    }
    return FALSE;
}

BOOL _ModifyWindowStyle(HWND hwnd, DWORD dwAdd, DWORD dwRemove)
{
    ASSERT(dwAdd || dwRemove);

    if (IsWindow(hwnd))
    {
        DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
        if (dwAdd)
            dwStyle |= dwAdd;
        if (dwRemove)
            dwStyle &= ~dwRemove;
        SetWindowLong(hwnd, GWL_STYLE, dwStyle);
        return TRUE;
    }
    return FALSE;
}


BOOL _EnforceNumericEditRange(
    IN HWND hwndDlg, 
    IN UINT nIDEdit, 
    IN UINT nIDSpin,
    IN LONG nLow, 
    IN LONG nHigh, 
    IN BOOL bSigned = FALSE)
{
    BOOL bRet   = FALSE;
    BOOL bReset = FALSE;
    LONG lRet   = -1;

    if (nIDSpin)
    {
        lRet = (LONG)SendDlgItemMessage(hwndDlg, nIDSpin, UDM_GETPOS, 0, 0);
        bRet = 0 == HIWORD(lRet);
    }
    
    if (!bRet)
        lRet = (LONG)GetDlgItemInt(hwndDlg, nIDEdit, &bRet, bSigned);

    if (lRet < nLow)
    {
        lRet = nLow;
        bReset = TRUE;
    }
    else if (lRet > nHigh)
    {
        lRet = nHigh;
        bReset = TRUE;
    }

    if (bReset)
        SetDlgItemInt(hwndDlg, nIDEdit, lRet, bSigned);

    return bRet;
}


BOOL _IsDirectoryServiceAvailable()
{
    BOOL bRet = FALSE;

    IShellDispatch2* psd;
    if (SUCCEEDED(CoCreateInstance(CLSID_Shell, 0, CLSCTX_INPROC_SERVER, 
                                     IID_PPV_ARG(IShellDispatch2, &psd))))
    {
        BSTR bstrName = SysAllocString(L"DirectoryServiceAvailable");
        if (bstrName)
        {
            VARIANT varRet = {0};
            if (SUCCEEDED(psd->GetSystemInformation(bstrName, &varRet)))
            {
                ASSERT(VT_BOOL == varRet.vt);
                bRet = varRet.boolVal;
            }
            SysFreeString(bstrName);
        }
        psd->Release();
    }
    return bRet;
}


//  Calculates number of pixels for dialog template units
LONG _PixelsForDbu(HWND hwndDlg, LONG cDbu, BOOL bHorz)
{
    RECT rc = {0,0,0,0};
    if (bHorz)
        rc.right = cDbu;
    else
        rc.bottom = cDbu;

    if (MapDialogRect(hwndDlg, &rc))
        return bHorz ? RECTWIDTH(rc) : RECTHEIGHT(rc);
    return 0;
}


//  Retrieves a localizable horizontal or vertical metric value from
//  the resource module.
LONG _GetResourceMetric(HWND hwndDlg, UINT nIDResource, BOOL bHorz /*orientation of metric*/)
{
    TCHAR szMetric[48];
    if (!EVAL(LoadString(HINST_THISDLL, nIDResource,
                           szMetric, ARRAYSIZE(szMetric))))
        return 0;

    LONG n = StrToInt(szMetric);
    return _PixelsForDbu(hwndDlg, n, bHorz);
}


//  Calculates the date nDays + nMonths from pstSrc.   nDays and/or nMonths
//  can be negative values.
BOOL _CalcDateOffset(const SYSTEMTIME* pstSrc, int nDays, int nMonths, OUT SYSTEMTIME* pstDest)
{
    ASSERT(pstSrc);
    ASSERT(pstDest);
    
    //  Subtract 90 days from current date and stuff in date low range
    FILETIME   ft;
    SystemTimeToFileTime(pstSrc, &ft);

    LARGE_INTEGER t;
    t.LowPart = ft.dwLowDateTime;
    t.HighPart = ft.dwHighDateTime;

    nDays += MulDiv(nMonths, 1461 /*days per 4 yrs*/, 48 /*months per 4 yrs*/);   
    t.QuadPart += Int32x32To64(nDays * 24 /*hrs per day*/ * 3600 /*seconds per hr*/,
                                10000000 /*100 ns intervals per sec*/);
    ft.dwLowDateTime = t.LowPart;
    ft.dwHighDateTime = t.HighPart;
    FileTimeToSystemTime(&ft, pstDest);
    return TRUE;
}


//  Loads a string into a combo box and assigns the string resource ID value
//  to the combo item's data.
BOOL _LoadStringToCombo(HWND hwndCombo, int iPos, UINT idString, LPARAM lpData)
{
    TCHAR szText[MAX_EDIT];
    if (LoadString(HINST_THISDLL, idString, szText, ARRAYSIZE(szText)))
    {
        INT_PTR idx = ::SendMessage(hwndCombo, CB_INSERTSTRING, iPos, (LPARAM)szText);
        if (idx != CB_ERR)
        {
            ::SendMessage(hwndCombo, CB_SETITEMDATA, idx, lpData);
            return TRUE;
        }
    }
    return FALSE;
}


//  Retrieves combo item's data.  If idx == CB_ERR, the currently selected
//  item's data will be retrieved.
LPARAM _GetComboData(HWND hwndCombo, INT_PTR idx = CB_ERR)
{
    if (CB_ERR == idx)
        idx = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (CB_ERR == idx)
        return idx;

    return (LPARAM)::SendMessage(hwndCombo, CB_GETITEMDATA, idx, 0);
}


//  Selects combo item with matching data, and returns the index
//  of the selected item.
INT_PTR _SelectComboData(HWND hwndCombo, LPARAM lpData)
{
    for (INT_PTR i = 0, cnt = SendMessage(hwndCombo, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        LPARAM lParam = SendMessage(hwndCombo, CB_GETITEMDATA, i, 0);
        if (lParam != CB_ERR && lParam == lpData)
        {
            SendMessage(hwndCombo, CB_SETCURSEL, i, 0);
            return i;
        }
    }
    return CB_ERR;
}


//  Draws a focus rect bounding the specified window.
void _DrawCtlFocus(HWND hwnd)
{
    HDC  hdc;
    if ((hdc = GetDC(hwnd)) != NULL)
    {
        RECT rc;
        GetClientRect(hwnd, &rc);
        DrawFocusRect(hdc, &rc);
        ReleaseDC(hwnd, hdc);
    }
}


BOOL _IsPathList(LPCTSTR pszPath)
{
    return pszPath ? StrChr(pszPath, TEXT(';')) != NULL : FALSE;
}


HRESULT _IsPathValidUNC(HWND hWndParent, BOOL fNetValidate, LPCTSTR pszPath)
{
    HRESULT hr = S_OK;

    if (PathIsUNC(pszPath))
    {
        if (fNetValidate)
        {
            NETRESOURCE nr = {0};
            TCHAR szPathBuffer[MAX_PATH];
            StrCpyN(szPathBuffer, pszPath, ARRAYSIZE(szPathBuffer));

            nr.dwType = RESOURCETYPE_DISK;
            nr.lpRemoteName = szPathBuffer;

            if (NO_ERROR != WNetAddConnection3(hWndParent, &nr, NULL, NULL, 
                CONNECT_TEMPORARY | CONNECT_INTERACTIVE))
            {
                hr = E_FILE_NOT_FOUND;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

BOOL _IsFullPathMinusDriveLetter(LPCTSTR pszPath)
{
    if (NULL == pszPath || PathIsUNC(pszPath))
        return FALSE;
    ASSERT(!PathIsRelative(pszPath));

    // Eat whitespace
    for (; (0 != *pszPath) && (TEXT(' ') == *pszPath) ; pszPath = CharNext(pszPath));

    return TEXT('\\') == *pszPath &&
            -1 == PathGetDriveNumber(pszPath);
}

BOOL _PathLooksLikeFilePattern(LPCTSTR pszPath)
{
    return StrPBrk(pszPath, TEXT("?*")) != NULL;
}


BOOL _PathIsDblSlash(LPCTSTR pszPath)
{
    return pszPath && (pszPath[0] == TEXT('\\')) && (pszPath[1] == TEXT('\\'));
}


BOOL _PathIsUNCServerShareOrSub(LPCTSTR pszPath)
{
    int cSlash = 0;
    if (_PathIsDblSlash(pszPath))
    {
        for (LPTSTR psz = (LPTSTR)pszPath; psz && *psz; psz = CharNext(psz))
        {
            if (*psz == TEXT('\\'))
                cSlash++;
        }
    }
    return cSlash >= 3;
}


BOOL _IsPathLocalHarddrive(LPCTSTR pszPath)
{
    int iDrive = PathGetDriveNumber(pszPath);
    if (iDrive != -1)
    {
        TCHAR szRoot[16];
        return DRIVE_FIXED == GetDriveType(PathBuildRoot(szRoot, iDrive));
    }
    return FALSE;
}


BOOL _IsPathLocalRoot(LPCTSTR pszPath)
{
    int iDrive = PathGetDriveNumber(pszPath);
    if (-1 != iDrive)
    {
        TCHAR szRoot[16];
        if (PathBuildRoot(szRoot, iDrive))
        {
            if (0 == StrCmpI(szRoot, pszPath))
            {
                switch (GetDriveType(szRoot))
                {
                    case DRIVE_REMOVABLE:
                    case DRIVE_FIXED:
                    case DRIVE_REMOTE:
                    case DRIVE_CDROM:
                    case DRIVE_RAMDISK:
                        return TRUE;
                }
            }
        }
    }
    return FALSE;
}

// from an object in the browser and it's site find the current pidl of what
// we are looking at

HRESULT _GetCurrentFolderIDList(IUnknown* punkSite, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr)) 
    {
        IShellView* psv;
        hr = psb->QueryActiveShellView(&psv);
        if (SUCCEEDED(hr)) 
        {
            IFolderView *pfv;
            hr = psv->QueryInterface(IID_PPV_ARG(IFolderView, &pfv));
            if (SUCCEEDED(hr)) 
            {
                IShellFolder* psf;
                hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf));
                if (SUCCEEDED(hr)) 
                {
                    hr = SHGetIDListFromUnk(psf, ppidl);
                    psf->Release();
                }
                pfv->Release();
            }
            psv->Release();
        }
        psb->Release();
    }
    return hr;
}

HRESULT _PathValidate(LPCTSTR pszPath, HWND hWndParent, BOOL fNetValidate)
{
    HRESULT hr = _IsPathValidUNC(hWndParent, fNetValidate, pszPath);
    if (S_OK == hr)
    {
        // We are done.
    }
    else if (E_FILE_NOT_FOUND != hr)
    {
        if (_IsPathList(pszPath) || PathIsSlow(pszPath, -1))
        {
            hr = S_OK;  // Skip check for slow files.
        }
        else
        {
            DWORD dwAttr;

            if (PathIsRelative(pszPath) || _IsFullPathMinusDriveLetter(pszPath))
            {
                hr = E_FILE_NOT_FOUND; // don't accept anything but a fully qualified path at this point.
                dwAttr = -1;
            }
            else
            {
                dwAttr = GetFileAttributes(pszPath);  // Does it exist?
    
                if (-1 == dwAttr)
                {
                    HRESULT hrFromPrepareForWrite = S_OK;

                    // Maybe the disk isn't inserted, so allow the user
                    // the chance to insert it.
                    if (hWndParent)
                    {
                        hrFromPrepareForWrite = SHPathPrepareForWrite(hWndParent, NULL, pszPath, SHPPFW_IGNOREFILENAME);
                        if (SUCCEEDED(hrFromPrepareForWrite))
                            dwAttr = GetFileAttributes(pszPath);  // Does it exist now?
                    }

                    // If SHPathPrepareForWrite() displays UI, then they will return HRESULT_FROM_WIN32(ERROR_CANCELLED)
                    // so that the callers (us) will skip displaying our UI.  If this is the case, when propagate that error.
                    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hrFromPrepareForWrite)
                    {
                        hr = hrFromPrepareForWrite;
                    }
                    else
                    {
                        if (-1 == dwAttr)
                            hr = E_FILE_NOT_FOUND;    // It doesn't exist.
                        else
                            hr = S_OK;      // It exists now.
                    }
                }
            }
        }
    }
    return hr;
}

BOOL _FmtError(UINT nIDFmt, LPCTSTR pszSub, LPTSTR szBuf, int cchBuf)
{
    TCHAR szFmt[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, nIDFmt, szFmt, ARRAYSIZE(szFmt))))
    {
        wnsprintf(szBuf, cchBuf, szFmt, pszSub);
        return TRUE;
    }
    return FALSE;
}

//  Retrieves the window text as a variant value of the specified type.
HRESULT _GetWindowValue(HWND hwndDlg, UINT nID, VARIANT* pvar)
{
    TCHAR szText[MAX_EDIT];
    LPTSTR pszText;
    if (::GetDlgItemText(hwndDlg, nID, szText, ARRAYSIZE(szText)))
        pszText = szText;
    else
        pszText = NULL;

    return InitVariantFromStr(pvar, pszText);
}


//  Loads the window text from a string resource.
BOOL _LoadWindowText(HWND hwnd, UINT nIDString)
{
    TCHAR szText[MAX_PATH];
    if (LoadString(HINST_THISDLL, nIDString, szText, ARRAYSIZE(szText)))
        return SetWindowText(hwnd, szText);
    return FALSE;
}


//  Retrieves the window text as a variant value of the specified type.
HRESULT _SetWindowValue(HWND hwndDlg, UINT nID, const VARIANT* pvar)
{
    switch (pvar->vt)
    {
    case VT_BSTR:
        SetDlgItemTextW(hwndDlg, nID, pvar->bstrVal);
        break;

    case VT_UI4:
        SetDlgItemInt(hwndDlg, nID, pvar->uiVal, FALSE);
        break;
        
    case VT_I4:
        SetDlgItemInt(hwndDlg, nID, pvar->lVal, TRUE);
        break;

    default:
        return E_NOTIMPL;
    }
    return S_OK;
}

//  Adds a named constraint to the specified search command extension object
HRESULT _AddConstraint(ISearchCommandExt* pSrchCmd, LPCWSTR pwszConstraint, VARIANT* pvarValue)
{
    HRESULT hr;
    BSTR bstrConstraint = SysAllocString(pwszConstraint);
    if (bstrConstraint)
    {
        hr = pSrchCmd->AddConstraint(bstrConstraint, *pvarValue);
        SysFreeString(bstrConstraint);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

void _PaintDlg(HWND hwndDlg, const CMetrics& metrics, HDC hdcPaint = NULL, LPCRECT prc = NULL)
{
    RECT rcPaint /* rcLine */;
    HDC  hdc = hdcPaint;

    if (NULL == hdcPaint)
        hdc = GetDC(hwndDlg);

    if (prc == NULL)
    {
        GetClientRect(hwndDlg, &rcPaint);
        prc = &rcPaint;
    }

    FillRect(hdc, prc, metrics.BkgndBrush());
        
    if (NULL == hdcPaint)
        ReleaseDC(hwndDlg, hdc);
}


void _EnsureVisible(HWND hwndDlg, HWND hwndVis, CFileSearchBand* pfsb)
{
    ASSERT(pfsb);
    ASSERT(::IsWindow(hwndDlg));
    ASSERT(::IsWindow(hwndVis));
    
    RECT rcDlg, rcVis, rcX;
    GetWindowRect(hwndDlg, &rcDlg);
    GetWindowRect(hwndVis, &rcVis);

    if (IntersectRect(&rcX, &rcDlg, &rcVis))
        pfsb->EnsureVisible(&rcX);
}


inline BOOL _IsKeyPressed(int virtkey)
{
    return (GetKeyState(virtkey) & 8000) != 0;
}


HWND _CreateDivider(HWND hwndParent, UINT nIDC, const POINT& pt, int nThickness = 1, HWND hwndAfter = NULL)
{
    HWND hwndDiv = CreateWindowEx(0, DIVWINDOW_CLASS, NULL,
                                   WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
                                   pt.x, pt.y, 400, 1, hwndParent, 
                                   IntToPtr_(HMENU, nIDC), HINST_THISDLL, NULL);
    if (IsWindow(hwndDiv))
    {
        if (IsWindow(hwndAfter))
            SetWindowPos(hwndDiv, hwndAfter, 0,0,0,0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);

        SendMessage(hwndDiv, DWM_SETHEIGHT, nThickness, 0);
        return hwndDiv;
    }
    return NULL;
}


HWND _CreateLinkWindow(HWND hwndParent, UINT nIDC, const POINT& pt, UINT nIDCaption, BOOL bShow = TRUE)
{
    DWORD dwStyle = WS_CHILD|WS_TABSTOP|WS_CLIPSIBLINGS;
    if (bShow)
        dwStyle |= WS_VISIBLE;
    
    HWND hwndCtl = CreateWindowEx(0, WC_LINK, NULL, dwStyle,
                                   pt.x, pt.y, 400, 18, hwndParent, 
                                   IntToPtr_(HMENU, nIDC), HINST_THISDLL, NULL);
        
    if (IsWindow(hwndCtl))
    {
        _LoadWindowText(hwndCtl, nIDCaption);
        return hwndCtl;
    }

    return NULL;
}


BOOL _EnableLink(HWND hwndLink, BOOL bEnable)
{
    LWITEM item;
    item.mask       = LWIF_ITEMINDEX|LWIF_STATE;
    item.stateMask  = LWIS_ENABLED;
    item.state      = bEnable ? LWIS_ENABLED : 0;
    item.iLink      = 0;

    return (BOOL)SendMessage(hwndLink, LWM_SETITEM, 0, (LPARAM)&item);
}


int _CreateSearchLinks(HWND hwndDlg, const POINT& pt, UINT nCtlIDdlg /* ctl ID of link to hwndDlg */)
{
    const UINT rgCtlID[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        IDC_SEARCHLINK_INTERNET,
    };
    const UINT rgCaptionID[] = {
        IDS_FSEARCH_SEARCHLINK_FILES,
        IDS_FSEARCH_SEARCHLINK_COMPUTERS,
        IDS_FSEARCH_SEARCHLINK_PRINTERS,
        IDS_FSEARCH_SEARCHLINK_PEOPLE,
        IDS_FSEARCH_SEARCHLINK_INTERNET,
    };
    int  cLinks = 0;
    BOOL bDSEnabled = _IsDirectoryServiceAvailable();

    for (int i = 0; i < ARRAYSIZE(rgCtlID); i++)
    {
        //  block creation of csearch, psearch search links 
        //  if Directory Service is not available.
        if (((IDC_SEARCHLINK_PRINTERS == rgCtlID[i]) && rgCtlID[i] != nCtlIDdlg && !bDSEnabled)
        ||  (IDC_SEARCHLINK_FILES == rgCtlID[i] && SHRestricted(REST_NOFIND)))
        {
            continue;
        }
        
        if (_CreateLinkWindow(hwndDlg, rgCtlID[i], pt, rgCaptionID[i]))
                cLinks++;
    }

    //  Disable link to current dialog:
    _EnableLink(GetDlgItem(hwndDlg, nCtlIDdlg), FALSE);

    return cLinks;
}


void _LayoutLinkWindow(
    IN HWND hwnd,     // parent window
    IN LONG left,     // left position of link
    IN LONG right,    // right position of link
    IN LONG yMargin,  // vertical padding between links
    IN OUT LONG& y,   // IN: where to start (RECT::top).  OUT: where the last link was positioned (RECT::bottom).
    IN const int nCtlID) // ctl ID 
{
    HWND hwndLink;
    
    if (nCtlID > 0)
    {
        hwndLink = GetDlgItem(hwnd, nCtlID);
        RECT rcLink;
        if (!IsWindow(hwndLink))
            return;

        ::GetWindowRect(hwndLink, &rcLink);
        ::MapWindowRect(NULL, hwnd, &rcLink);
        rcLink.left  = left;
        rcLink.right = right;

        int cyIdeal = (int)::SendMessage(hwndLink, LWM_GETIDEALHEIGHT, RECTWIDTH(rcLink), 0);
        if (cyIdeal >= 0)
            rcLink.bottom = rcLink.top + cyIdeal;

        OffsetRect(&rcLink, 0, y - rcLink.top);
        y = rcLink.bottom;

        ::SetWindowPos(hwndLink, NULL, 
                        rcLink.left, rcLink.top, 
                        RECTWIDTH(rcLink), RECTHEIGHT(rcLink),
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }
    else if (nCtlID < 0)
    {
        //  this is a divider window
        hwndLink = GetDlgItem(hwnd, -nCtlID);
        ::SetWindowPos(hwndLink, NULL, left, y + yMargin/2, right - left, 1, 
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }
    y += yMargin;
}


void _LayoutLinkWindows(
    IN HWND hwnd,     // parent window
    IN LONG left,     // left position of links
    IN LONG right,    // right position of links
    IN LONG yMargin,  // vertical padding between links
    IN OUT LONG& y,   // IN: where to start (RECT::top).  OUT: where the last link was positioned (RECT::bottom).
    IN const int rgCtlID[],// array of link ctl IDs.  use IDC_SEPARATOR for separators
    IN LONG cCtlID)  // number of array elements to layout in rgCtlID.
{
    for (int i = 0; i < cCtlID; i++)
        _LayoutLinkWindow(hwnd, left, right, yMargin, y, rgCtlID[i]);
}

//  Retrieves AutoComplete flags
//
#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define BOOL_NOT_SET                        0x00000005

DWORD _GetAutoCompleteSettings()
{
    DWORD dwACOptions = 0;

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, TEXT("Always Use Tab"), FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


//  Initializes and enables an MRU autocomplete list on the specified
//  edit control
HRESULT _InitializeMru(HWND hwndEdit, IAutoComplete2** ppAutoComplete, LPCTSTR pszSubKey, IStringMru** ppStringMru)
{
    *ppAutoComplete = NULL;
    *ppStringMru = NULL;

    HRESULT hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, 
                                   IID_PPV_ARG(IAutoComplete2, ppAutoComplete));
    if (SUCCEEDED(hr))
    {
        TCHAR szKey[MAX_PATH];
        if (CFileSearchBand::MakeBandSubKey(pszSubKey, szKey, ARRAYSIZE(szKey)) > 0)
        {
            hr = CStringMru::CreateInstance(HKEY_CURRENT_USER, szKey, 25, FALSE, 
                                             IID_PPV_ARG(IStringMru, ppStringMru));
            if (SUCCEEDED(hr))
            {
                hr = (*ppAutoComplete)->Init(hwndEdit, *ppStringMru, NULL, NULL);
            }
        }
        else
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        (*ppAutoComplete)->SetOptions(_GetAutoCompleteSettings());
        (*ppAutoComplete)->Enable(TRUE);
    }
    else
    {
        ATOMICRELEASE((*ppAutoComplete));        
        ATOMICRELEASE((*ppStringMru));        
    }

    return hr;
}

HRESULT _AddMruStringFromWindow(IStringMru* pmru, HWND hwnd)
{
    ASSERT(::IsWindow(hwnd));
    HRESULT hr = E_FAIL;

    if (pmru)
    {
        TCHAR szText[MAX_PATH * 3];
        if (GetWindowTextW(hwnd, szText, ARRAYSIZE(szText)) > 0)
            hr = pmru->Add(szText);
        else
            hr = S_FALSE;
    }
    return hr;
}


HRESULT _TestAutoCompleteDropDownState(IAutoComplete2* pac2, DWORD dwTest)
{
    IAutoCompleteDropDown* pacdd;
    HRESULT hr = pac2->QueryInterface(IID_PPV_ARG(IAutoCompleteDropDown, &pacdd));
    if (SUCCEEDED(hr))
    {
        DWORD dwFlags;
        if (SUCCEEDED((hr = pacdd->GetDropDownStatus(&dwFlags, NULL))))
            hr = (dwFlags & dwTest) ? S_OK : S_FALSE;
        pacdd->Release();
    }
    return hr;
}

inline HWND _IndexServiceHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("isconcepts.chm"), HH_DISPLAY_TOPIC, 0);
}

LRESULT CSubDlg::OnNcCalcsize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    InflateRect((LPRECT)lParam, -SUBDLG_BORDERWIDTH, -SUBDLG_BORDERWIDTH);
    return 0;
}

LRESULT CSubDlg::OnNcPaint(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    RECT    rc;
    HDC     hdc;
    HBRUSH  hbr = _pfsb->GetMetrics().BorderBrush();
    
    GetWindowRect(Hwnd(), &rc);
    OffsetRect(&rc, -rc.left, -rc.top);
    
    if (hbr && (hdc = GetWindowDC(Hwnd())) != NULL)
    {
        for (int i=0; i < SUBDLG_BORDERWIDTH; i++)
        {
            FrameRect(hdc, &rc, hbr);
            InflateRect(&rc, -1, -1);
        }

        ReleaseDC(Hwnd(), hdc);
    }
    
    return 0;
}


LRESULT CSubDlg::OnCtlColor(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    SetTextColor((HDC)wParam, _pfsb->GetMetrics().TextColor());
    SetBkColor((HDC)wParam, _pfsb->GetMetrics().BkgndColor());
    return (LRESULT)_pfsb->GetMetrics().BkgndBrush();
}

LRESULT CSubDlg::OnPaint(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Just going to call BeginPaint and EndPaint.  All
    //  painting done in WM_ERASEBKGND handler to avoid flicker.
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(_hwnd, &ps);
    if (hdc)
    {
        EndPaint(_hwnd, &ps);
    }
    return 0;
}

LRESULT CSubDlg::OnSize(UINT, WPARAM, LPARAM, BOOL&)
{
    ASSERT(::IsWindow(Hwnd())); // was _Attach() called, e.g. from WM_INITDIALOG?
    _PaintDlg(Hwnd(), _pfsb->GetMetrics());
    ValidateRect(Hwnd(), NULL);
    return 0;
}

LRESULT CSubDlg::OnEraseBkgnd(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    _PaintDlg(Hwnd(), _pfsb->GetMetrics(), (HDC)wParam);
    ValidateRect(Hwnd(), NULL);
    return TRUE;
}

STDMETHODIMP CSubDlg::TranslateAccelerator(MSG *pmsg)
{
    if (_pfsb->IsKeyboardScroll(pmsg))
        return S_OK;

    return _pfsb->IsDlgMessage(Hwnd(), pmsg);
}

LRESULT CSubDlg::OnChildSetFocusCmd(WORD wNotifyCode, WORD wID, HWND hwndCtl, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, hwndCtl, _pfsb);
    bHandled = FALSE;
    return 0;
}

LRESULT CSubDlg::OnChildSetFocusNotify(int, NMHDR *pnmh, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, pnmh->hwndFrom, _pfsb);
    bHandled = FALSE;
    return 0;
}

LRESULT CSubDlg::OnChildKillFocusCmd(WORD, WORD, HWND hwndCtl, BOOL&)
{
    if (_pBandDlg)
        _pBandDlg->RememberFocus(hwndCtl);
    return 0;
}

LRESULT CSubDlg::OnChildKillFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    if (_pBandDlg)
        _pBandDlg->RememberFocus(pnmh->hwndFrom);
    return 0;
}

LRESULT CSubDlg::OnComboExEndEdit(int, NMHDR *pnmh, BOOL&)
{
    if (CBENF_KILLFOCUS == ((NMCBEENDEDIT*)pnmh)->iWhy)
    {
        if (_pBandDlg)
            _pBandDlg->RememberFocus(pnmh->hwndFrom);
    }
    return 0;
}


// CDateDlg impl

#define RECENTMONTHSRANGE_HIGH      999  
#define RECENTDAYSRANGE_HIGH        RECENTMONTHSRANGE_HIGH
#define RECENTMONTHSRANGE_HIGH_LEN  3 // count of digits in RECENTMONTHSRANGE_HIGH
#define RECENTDAYSRANGE_HIGH_LEN    RECENTMONTHSRANGE_HIGH_LEN
#define RECENTMONTHSRANGE_LOW       1
#define RECENTDAYSRANGE_LOW         RECENTMONTHSRANGE_LOW


LRESULT CDateDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT(_pfsb);
    _Attach(m_hWnd);

    HWND hwndCombo = GetDlgItem(IDC_WHICH_DATE);

    SendDlgItemMessage(IDC_RECENT_MONTHS_SPIN, UDM_SETRANGE32, 
                        RECENTMONTHSRANGE_HIGH, RECENTMONTHSRANGE_LOW);
    SendDlgItemMessage(IDC_RECENT_DAYS_SPIN, UDM_SETRANGE32, 
                        RECENTDAYSRANGE_HIGH, RECENTDAYSRANGE_LOW);

    SendDlgItemMessage(IDC_RECENT_MONTHS, EM_LIMITTEXT, RECENTMONTHSRANGE_HIGH_LEN, 0);
    SendDlgItemMessage(IDC_RECENT_DAYS,   EM_LIMITTEXT, RECENTDAYSRANGE_HIGH_LEN, 0);

    SYSTEMTIME st[2] = {0};

    // lower limit -- dos date does not support anything before 1/1/1980
    st[0].wYear = 1980;
    st[0].wMonth = 1;
    st[0].wDay = 1;
    // upper limit
    st[1].wYear = 2099;
    st[1].wMonth = 12;
    st[1].wDay = 31;
    SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_SETRANGE, GDTR_MIN | GDTR_MAX, (LPARAM)st);
    SendDlgItemMessage(IDC_DATERANGE_END,   DTM_SETRANGE, GDTR_MIN | GDTR_MAX, (LPARAM)st);
    
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_MODIFIED_DATE, IDS_FSEARCH_MODIFIED_DATE);
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_CREATION_DATE, IDS_FSEARCH_CREATION_DATE);
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_ACCESSED_DATE, IDS_FSEARCH_ACCESSED_DATE);

    Clear();

    return TRUE;  // Let the system set the focus
}

BOOL CDateDlg::Validate()
{
    return TRUE;
}

STDMETHODIMP CDateDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    VARIANT var;
    BOOL    bErr;
    UINT_PTR nIDString = _GetComboData(GetDlgItem(IDC_WHICH_DATE));

    HRESULT hr;
#if 1
    hr = InitVariantFromStr(&var, 
        (IDS_FSEARCH_MODIFIED_DATE == nIDString) ? L"Write" :
        (IDS_FSEARCH_CREATION_DATE == nIDString) ? L"Create" : L"Access");
#else
    var.vt = VT_UI4;
    var.ulVal = (IDS_FSEARCH_MODIFIED_DATE == nIDString) ? 1 :
                (IDS_FSEARCH_CREATION_DATE == nIDString) ? 2 :
                (IDS_FSEARCH_ACCESSED_DATE == nIDString) ? 3 : 0;
    hr = S_OK;
    ASSERT(var.ulVal);
#endif

    if (SUCCEEDED(hr))
    {
        hr = _AddConstraint(pSrchCmd, L"WhichDate", &var);
        VariantClear(&var);
    }
    
    if (IsDlgButtonChecked(IDC_USE_RECENT_MONTHS))
    {
        var.vt = VT_I4;
        var.ulVal = (ULONG)SendDlgItemMessage(IDC_RECENT_MONTHS_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
        if (!bErr)
            hr = _AddConstraint(pSrchCmd, L"DateNMonths", &var);

    }
    else if (IsDlgButtonChecked(IDC_USE_RECENT_DAYS))
    {
        var.vt = VT_I4;
        var.ulVal = (ULONG)SendDlgItemMessage(IDC_RECENT_DAYS_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
        if (!bErr)
            hr = _AddConstraint(pSrchCmd, L"DateNDays", &var);
    }
    else if (IsDlgButtonChecked(IDC_USE_DATE_RANGE))     
    {
        SYSTEMTIME stBegin, stEnd;

        var.vt = VT_DATE;

        LRESULT lRetBegin = SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_GETSYSTEMTIME, 0, (LPARAM)&stBegin);
        LRESULT lRetEnd   = SendDlgItemMessage(IDC_DATERANGE_END,   DTM_GETSYSTEMTIME, 0, (LPARAM)&stEnd);

        if (GDT_VALID == lRetBegin && GDT_VALID == lRetEnd)
        {
#ifdef DEBUG
            FILETIME ft;
            //validate that we were passed a correct date
            //SystemTimeToFileTime calls internal API IsValidSystemTime.
            //This will save us from OLE Automation bug# 322789

            // the only way we can get a date is through date/time picker
            // control which should validate the dates so just assert...
            ASSERT(SystemTimeToFileTime(&stBegin, &ft));
#endif
            SystemTimeToVariantTime(&stBegin, &var.date);
            hr = _AddConstraint(pSrchCmd, L"DateGE", &var);
#ifdef DEBUG
            ASSERT(SystemTimeToFileTime(&stEnd, &ft));
#endif

            SystemTimeToVariantTime(&stEnd, &var.date);
            hr = _AddConstraint(pSrchCmd, L"DateLE", &var);
        }
    }
    
    return hr;
}


//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CDateDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    HRESULT hr = E_FAIL;
    BOOL    bUseMonths = FALSE,
            bUseDays = FALSE,
            bUseRange = FALSE;
            
    if (IsConstraintName(L"WhichDate", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt)
        UINT nIDS = pValue->lVal == 1 ? IDS_FSEARCH_MODIFIED_DATE :
                    pValue->lVal == 2 ? IDS_FSEARCH_CREATION_DATE :
                    pValue->lVal == 3 ? IDS_FSEARCH_ACCESSED_DATE : 0;

        if (nIDS != 0)
            _SelectComboData(GetDlgItem(IDC_WHICH_DATE), nIDS);

        return nIDS == IDS_FSEARCH_MODIFIED_DATE /*default*/ ? 
                       S_FALSE /* don't open */: S_OK /* open */;
    }
    
    if (IsConstraintName(L"DateNMonths", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt);
        bUseMonths = TRUE;
        _SetWindowValue(m_hWnd, IDC_RECENT_MONTHS, pValue);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateNDays", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt);
        bUseDays = TRUE;
        _SetWindowValue(m_hWnd, IDC_RECENT_DAYS, pValue);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateGE", bstrName))
    {
        ASSERT(VT_DATE == pValue->vt);
        bUseRange = TRUE;

        SYSTEMTIME st;
        VariantTimeToSystemTime(pValue->date, &st);
        SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_SETSYSTEMTIME, 0, (LPARAM)&st);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateLE", bstrName))
    {
        ASSERT(VT_DATE == pValue->vt);
        bUseRange = TRUE;

        SYSTEMTIME st;
        VariantTimeToSystemTime(pValue->date, &st);
        SendDlgItemMessage(IDC_DATERANGE_END, DTM_SETSYSTEMTIME, 0, (LPARAM)&st);
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        CheckDlgButton(IDC_USE_RECENT_MONTHS, bUseMonths);
        CheckDlgButton(IDC_USE_RECENT_DAYS,   bUseDays);
        CheckDlgButton(IDC_USE_DATE_RANGE,    bUseRange);
        EnableControls();
    }

    return hr;
}


void CDateDlg::Clear()
{
    SendDlgItemMessage(IDC_WHICH_DATE, CB_SETCURSEL, 0, 0);

    CheckDlgButton(IDC_USE_RECENT_MONTHS, 0);
    SetDlgItemInt(IDC_RECENT_MONTHS, 1, FALSE);

    CheckDlgButton(IDC_USE_RECENT_DAYS, 0);
    SetDlgItemInt(IDC_RECENT_DAYS, 1, FALSE);

    CheckDlgButton(IDC_USE_DATE_RANGE, 1);

    SYSTEMTIME stNow, stPrev;
    GetLocalTime(&stNow);
    SendDlgItemMessage(IDC_DATERANGE_END, DTM_SETSYSTEMTIME, 0, (LPARAM)&stNow);

    //  Subtract 90 days from current date and stuff in date low range
    _CalcDateOffset(&stNow, 0, -1 /* 1 month ago */, &stPrev);
    SendDlgItemMessage(IDC_DATERANGE_BEGIN,  DTM_SETSYSTEMTIME, 0, (LPARAM)&stPrev);

    EnableControls();
}


LRESULT CDateDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    ValidateRect(NULL);

    RECT rc;
    HWND hwndCtl = GetDlgItem(IDC_WHICH_DATE);
    ASSERT(hwndCtl);
    
    ::GetWindowRect(hwndCtl, &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.right = pts.x - _pfsb->GetMetrics().CtlMarginX();
    
    ::SetWindowPos(GetDlgItem(IDC_WHICH_DATE), NULL, 0, 0, 
                    RECTWIDTH(rc), RECTHEIGHT(rc),
                    SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    return 0;
}


LRESULT CDateDlg::OnMonthDaySpin(int nIDSpin, NMHDR *pnmh, BOOL& bHandled)
{
    LPNMUPDOWN pud = (LPNMUPDOWN)pnmh;
    pud->iDelta *= -1; // increments of 1 month/day
    return 0;
}


LRESULT CDateDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    EnableControls();
    return 0;
}


LRESULT CDateDlg::OnMonthsKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_RECENT_MONTHS, IDC_RECENT_MONTHS_SPIN,
                              RECENTMONTHSRANGE_LOW, RECENTMONTHSRANGE_HIGH);
    return 0;
}


LRESULT CDateDlg::OnDaysKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_RECENT_DAYS, IDC_RECENT_DAYS_SPIN,
                             RECENTDAYSRANGE_LOW, RECENTDAYSRANGE_HIGH);
    return 0;
}


void CDateDlg::EnableControls()
{
    UINT nSel = IsDlgButtonChecked(IDC_USE_RECENT_MONTHS) ? IDC_USE_RECENT_MONTHS :
                IsDlgButtonChecked(IDC_USE_RECENT_DAYS) ? IDC_USE_RECENT_DAYS :
                IsDlgButtonChecked(IDC_USE_DATE_RANGE) ? IDC_USE_DATE_RANGE : 0;

    ::EnableWindow(GetDlgItem(IDC_RECENT_MONTHS),      IDC_USE_RECENT_MONTHS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_MONTHS_SPIN), IDC_USE_RECENT_MONTHS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_DAYS),        IDC_USE_RECENT_DAYS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_DAYS_SPIN),   IDC_USE_RECENT_DAYS == nSel);
    ::EnableWindow(GetDlgItem(IDC_DATERANGE_BEGIN),    IDC_USE_DATE_RANGE == nSel);
    ::EnableWindow(GetDlgItem(IDC_DATERANGE_END),      IDC_USE_DATE_RANGE == nSel);
}


// CSizeDlg impl


#define FILESIZERANGE_LOW       0
#define FILESIZERANGE_HIGH      99999999
#define FILESIZERANGE_HIGH_LEN  8 // count of digits in FILESIZERANGE_HIGH


LRESULT CSizeDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);

    HWND hwndCombo = GetDlgItem(IDC_WHICH_SIZE);
    SendDlgItemMessage(IDC_FILESIZE_SPIN, UDM_SETRANGE32,
                        FILESIZERANGE_HIGH, FILESIZERANGE_LOW /*Kb*/);
    SendDlgItemMessage(IDC_FILESIZE, EM_LIMITTEXT, FILESIZERANGE_HIGH_LEN, 0);

    _LoadStringToCombo(hwndCombo, -1, 
                        IDS_FSEARCH_SIZE_GREATEREQUAL, 
                        IDS_FSEARCH_SIZE_GREATEREQUAL);
    _LoadStringToCombo(hwndCombo, -1, 
                        IDS_FSEARCH_SIZE_LESSEREQUAL, 
                        IDS_FSEARCH_SIZE_LESSEREQUAL);

    Clear();

    return TRUE;  // Let the system set the focus
}


STDMETHODIMP CSizeDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    VARIANT var;
    BOOL    bErr = FALSE;
    HRESULT hr = S_FALSE;
    UINT_PTR nIDString = _GetComboData(GetDlgItem(IDC_WHICH_SIZE));

    var.vt = VT_UI4;
    var.ulVal = (ULONG)SendDlgItemMessage(IDC_FILESIZE_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
    
    if (!bErr)
    {
        var.ulVal *= 1024; // KB to bytes.
        LPCWSTR pwszConstraint = (IDS_FSEARCH_SIZE_GREATEREQUAL == nIDString) ? 
                                    L"SizeGE" :
                                 (IDS_FSEARCH_SIZE_LESSEREQUAL == nIDString) ? 
                                    L"SizeLE" : NULL;

        if (pwszConstraint)
            hr = _AddConstraint(pSrchCmd, pwszConstraint, &var);
    }

    return hr;
}


//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CSizeDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    HRESULT hr = E_FAIL;
    UINT    nID = 0;

    if (IsConstraintName(L"SizeGE", bstrName))
    {
        nID = IDS_FSEARCH_SIZE_GREATEREQUAL;
        hr = S_OK;
    }
    else if (IsConstraintName(L"SizeLE", bstrName))
    {
        nID = IDS_FSEARCH_SIZE_LESSEREQUAL;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        ASSERT(VT_UI4 == pValue->vt);
        ULONG ulSize = pValue->ulVal/1024; // convert bytes to KB
        SetDlgItemInt(IDC_FILESIZE, ulSize, FALSE);

        ASSERT(nID != 0);
        _SelectComboData(GetDlgItem(IDC_WHICH_SIZE), nID);
    }
    
    return hr;
}



void CSizeDlg::Clear()
{
    SendDlgItemMessage(IDC_WHICH_SIZE, CB_SETCURSEL, 0, 0);
    SetDlgItemInt(IDC_FILESIZE, 0, FALSE);    
}


LRESULT CSizeDlg::OnSizeSpin(int nIDSpin, NMHDR *pnmh, BOOL& bHandled)
{
    LPNMUPDOWN pud = (LPNMUPDOWN)pnmh;
    pud->iDelta *= -10;  // increments of 10KB
    return 0;
}


LRESULT CSizeDlg::OnSizeKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_FILESIZE, IDC_FILESIZE_SPIN,
                              FILESIZERANGE_LOW, FILESIZERANGE_HIGH);
    return 0;
}

CTypeDlg::CTypeDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb)
{
    *_szRestoredExt = 0;
}

CTypeDlg::~CTypeDlg()
{
}

LRESULT CTypeDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND        hwndCombo = GetDlgItem(IDC_FILE_TYPE);
    HIMAGELIST  hil = GetSystemImageListSmallIcons();

    _Attach(m_hWnd);
    ::SendMessage(hwndCombo, CBEM_SETEXTENDEDSTYLE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);
    
    ::SendMessage(hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM)hil);
    ::SendMessage(hwndCombo, CBEM_SETEXSTYLE, 0, 0);
    return TRUE;  // Let the system set the focus
}

STDMETHODIMP CTypeDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    LPTSTR  pszText;
    HRESULT hr = S_FALSE;

    if (GetFileAssocComboSelItemText(GetDlgItem(IDC_FILE_TYPE), &pszText) >= 0 && pszText)
    {
        VARIANT var = {0};
        if (*pszText && 
            SUCCEEDED(InitVariantFromStr(&var, pszText)) &&
            SUCCEEDED(_AddConstraint(pSrchCmd, L"FileType", &var)))
        {
            hr = S_OK;
        }
        VariantClear(&var);
        LocalFree((HLOCAL)pszText);
    }
    
    return hr;
}

//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CTypeDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"FileType", bstrName))
    {
        ASSERT(VT_BSTR == pValue->vt);
        
        USES_CONVERSION;
        lstrcpyn(_szRestoredExt, W2T(pValue->bstrVal), ARRAYSIZE(_szRestoredExt));

        INT_PTR i = _FindExtension(GetDlgItem(IDC_FILE_TYPE), _szRestoredExt);
        if (i != CB_ERR)
        {
            SendDlgItemMessage(IDC_FILE_TYPE, CB_SETCURSEL, i, 0);
            *_szRestoredExt = 0;
        }

        return S_OK;
    }
    return E_FAIL;
}

INT_PTR CTypeDlg::_FindExtension(HWND hwndCombo, TCHAR* pszExt)
{
    INT_PTR i, cnt = ::SendMessage(hwndCombo, CB_GETCOUNT, 0, 0);
    LPTSTR  pszData;
    BOOL    bAllFileTypes = pszExt && (lstrcmp(TEXT("*.*"), pszExt) == 0);
    TCHAR   szExt[MAX_PATH];

    if (!bAllFileTypes)
    {
        //  Remove wildcard characters.
        LPTSTR pszSrc = pszExt, pszDest = szExt;
        for (;; pszSrc = CharNext(pszSrc))
        {
            if (TEXT('*') == *pszSrc)
                pszSrc = CharNext(pszSrc);

            if ((*(pszDest++) = *pszSrc) == 0)
                break;
        }
        pszExt = szExt;
    }

    if (pszExt && (bAllFileTypes || *pszExt))
    {
        for (i = 0; i < cnt; i++)
        {
            pszData = (LPTSTR)::SendMessage(hwndCombo, CB_GETITEMDATA, i, 0);
            if (bAllFileTypes && (FILEASSOCIATIONSID_ALLFILETYPES == (UINT_PTR)pszData))
                return i;

            if (pszData != (LPTSTR)FILEASSOCIATIONSID_ALLFILETYPES &&
                pszData != (LPTSTR)CB_ERR && 
                pszData != NULL)
            {
                if (0 == StrCmpI(pszExt, pszData))
                    return i;
            }
        }
    }
    return CB_ERR;
}

void CTypeDlg::Clear()
{
    //  Assign combo selection to 'all file types':
    HWND hwndCombo = GetDlgItem(IDC_FILE_TYPE);
    for (INT_PTR i = 0, cnt = ::SendMessage(hwndCombo, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        if (FILEASSOCIATIONSID_ALLFILETYPES == _GetComboData(hwndCombo, i))
        {
            ::SendMessage(hwndCombo, CB_SETCURSEL, i, 0);
            break;
        }
    }
    _szRestoredExt[0] = 0;
}

LRESULT CTypeDlg::OnFileTypeDeleteItem(int idCtrl, NMHDR *pnmh, BOOL& bHandled)
{
    return DeleteFileAssocComboItem(pnmh);
}

LRESULT CTypeDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    ValidateRect(NULL);

    RECT rc;
    HWND hwndCtl = GetDlgItem(IDC_FILE_TYPE);
    ASSERT(hwndCtl);
    
    ::GetWindowRect(hwndCtl, &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.right = pts.x - _pfsb->GetMetrics().CtlMarginX();
    
    ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                    RECTWIDTH(rc), RECTHEIGHT(rc),
                    SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    return 0;
}

DWORD CTypeDlg::FileAssocThreadProc(void* pv)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)pv;
    CTypeDlg* pThis = (CTypeDlg*)pState->pvParam;

    if (PopulateFileAssocCombo(pState->hwndCtl, AddItemNotify, (LPARAM)pv) != E_ABORT)
    {
        ::PostMessage(::GetParent(pState->hwndCtl), WMU_COMBOPOPULATIONCOMPLETE, (WPARAM)pState->hwndCtl, 0);
    }

    pState->fComplete = TRUE;

    ATOMICRELEASE(pState->punkBand);
    return 0;
}

HRESULT CTypeDlg::AddItemNotify(ULONG fAction, PCBXITEM pItem, LPARAM lParam)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)lParam;
    ASSERT(pState);
    ASSERT(pState->hwndCtl);

    //  Do we want to abort combo population thread?
    if (fAction & CBXCB_ADDING && pState->fCancel)
        return E_ABORT;

    //  Set the current selection to 'all file types'
    if (fAction & CBXCB_ADDED)
    {
        BOOL bAllTypesItem = (FILEASSOCIATIONSID_ALLFILETYPES == pItem->lParam);
        
        CTypeDlg* pThis = (CTypeDlg*)pState->pvParam;
        ASSERT(pThis);
        
        //  If this item is the one restored from a saved query
        //  override any current selection and select it.
        if (*pThis->_szRestoredExt && !bAllTypesItem && pItem->lParam && 
            0 == lstrcmpi((LPCTSTR)pItem->lParam, pThis->_szRestoredExt))
        {
            ::SendMessage(pState->hwndCtl, CB_SETCURSEL, pItem->iItem, 0);
            *pThis->_szRestoredExt = 0;
        }
        //  If this item is the default ('all file types') and 
        //  nothing else is selected, select it.
        else if (bAllTypesItem)
        {
            if (CB_ERR == ::SendMessage(pState->hwndCtl, CB_GETCURSEL, 0, 0))
                ::SendMessage(pState->hwndCtl, CB_SETCURSEL, pItem->iItem, 0);
        }
    }
    return S_OK;
}

LRESULT CTypeDlg::OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&)
{
    // remove briefcase from type combo because briefcases no longer use this
    // extension (now they store clsid in desktop.ini
    INT_PTR iBfc = _FindExtension(GetDlgItem(IDC_FILE_TYPE), TEXT(".bfc"));
    if (iBfc != CB_ERR)
    {
        SendDlgItemMessage(IDC_FILE_TYPE, CB_DELETESTRING, (WPARAM)iBfc, 0);
    }
    
    if (*_szRestoredExt)
    {
        INT_PTR iSel = _FindExtension(GetDlgItem(IDC_FILE_TYPE), _szRestoredExt);
        if (iSel != CB_ERR)
        {
            SendDlgItemMessage(IDC_FILE_TYPE, CB_SETCURSEL, (WPARAM)iSel, 0);
            *_szRestoredExt = 0;
        }
    }
        
    return 0;
}

// Called when we are finished doing all the work to display the search band.
// We then launch the thread to populate the file type drop down.  By delaying this 
// until now, we can speed up the band loading.
// No return becuase it's called async.
void CTypeDlg::DoDelayedInit()
{
    //  Launch thread to populate the file types combo.
    _threadState.hwndCtl = GetDlgItem(IDC_FILE_TYPE);
    _threadState.pvParam = this;
    _threadState.fComplete = FALSE;
    _threadState.fCancel   = FALSE;

    if (SUCCEEDED(SAFECAST(_pfsb, IFileSearchBand*)->QueryInterface(IID_PPV_ARG(IUnknown, &_threadState.punkBand))))
    {
        if (!SHCreateThread(FileAssocThreadProc, &_threadState, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(_threadState.punkBand);
        }
    }
}


LRESULT CTypeDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)  
{ 
    _threadState.fCancel = TRUE; 
    bHandled = FALSE; 
    return 0;
}


void CTypeDlg::OnWinIniChange()
{
    SendDlgItemMessage(IDC_FILE_TYPE, CB_SETDROPPEDWIDTH,
                        _PixelsForDbu(m_hWnd, MIN_FILEASSOCLIST_WIDTH, TRUE), 0);
}


LRESULT CAdvancedDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);
    Clear();
    return TRUE;  // Let the system set the focus
}

HRESULT AddButtonConstraintPersist(ISearchCommandExt* pSrchCmd, LPCWSTR pszConstraint, HWND hwndButton)
{

    BOOL bValue = SendMessage(hwndButton, BM_GETCHECK, 0, 0) == BST_CHECKED;
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), pszConstraint,
                    REG_DWORD, &bValue, sizeof(bValue), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    VARIANT var = {0};
    var.vt = VT_BOOL;
    var.boolVal = bValue ? VARIANT_TRUE : 0;

    return _AddConstraint(pSrchCmd, pszConstraint, &var);
}

STDMETHODIMP CAdvancedDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    AddButtonConstraintPersist(pSrchCmd, L"SearchSystemDirs",  GetDlgItem(IDC_USE_SYSTEMDIRS));
    AddButtonConstraintPersist(pSrchCmd, L"SearchHidden",      GetDlgItem(IDC_SEARCH_HIDDEN));
    AddButtonConstraintPersist(pSrchCmd, L"IncludeSubFolders", GetDlgItem(IDC_USE_SUBFOLDERS));
    AddButtonConstraintPersist(pSrchCmd, L"CaseSensitive",     GetDlgItem(IDC_USE_CASE));
    AddButtonConstraintPersist(pSrchCmd, L"SearchSlowFiles",   GetDlgItem(IDC_USE_SLOW_FILES));
    return S_OK;
}

//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CAdvancedDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"IncludeSubFolders", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_SUBFOLDERS, pValue->lVal);
        return S_FALSE;    // this is a default. don't force open the subdialog.
    }

    if (IsConstraintName(L"CaseSensitive", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_CASE, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchSlowFiles", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_SLOW_FILES, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchSystemDirs", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt || VT_UI4 == pValue->vt);
        CheckDlgButton(IDC_USE_SYSTEMDIRS, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchHidden", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt || VT_UI4 == pValue->vt);
        CheckDlgButton(IDC_SEARCH_HIDDEN, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    return E_FAIL;
}

void CheckDlgButtonPersist(HWND hdlg, UINT id, LPCTSTR pszOption, BOOL bDefault)
{
    BOOL bValue = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), pszOption, FALSE, bDefault);
    CheckDlgButton(hdlg, id, bValue);
}

void CAdvancedDlg::Clear()
{
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SYSTEMDIRS,   L"SearchSystemDirs",  IsOS(OS_ANYSERVER));
    CheckDlgButtonPersist(m_hWnd, IDC_SEARCH_HIDDEN,    L"SearchHidden",      FALSE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SUBFOLDERS,   L"IncludeSubFolders", TRUE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_CASE,         L"CaseSensitive",     FALSE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SLOW_FILES,   L"SearchSlowFiles",   FALSE);
}

COptionsDlg::COptionsDlg(CFileSearchBand* pfsb)
    :   CSubDlg(pfsb),
        _dlgDate(pfsb),
        _dlgSize(pfsb),
        _dlgType(pfsb),
        _dlgAdvanced(pfsb)
{
    // Verify that it initialized to 0's
    ASSERT(0 == _nCIStatusText);

    ZeroMemory(_subdlgs, sizeof(_subdlgs));
    #define SUBDLG_ENTRY(idx, idCheck, dlg)  \
        { _subdlgs[idx].nIDCheck = idCheck; _subdlgs[idx].pDlg = &dlg; }

    SUBDLG_ENTRY(SUBDLG_DATE, IDC_USE_DATE, _dlgDate);
    SUBDLG_ENTRY(SUBDLG_TYPE, IDC_USE_TYPE, _dlgType);
    SUBDLG_ENTRY(SUBDLG_SIZE, IDC_USE_SIZE, _dlgSize);
    SUBDLG_ENTRY(SUBDLG_ADVANCED, IDC_USE_ADVANCED, _dlgAdvanced);
}

LRESULT COptionsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    _Attach(m_hWnd);
    _dlgDate.SetBandDlg(_pBandDlg);
    _dlgSize.SetBandDlg(_pBandDlg);
    _dlgType.SetBandDlg(_pBandDlg);
    _dlgAdvanced.SetBandDlg(_pBandDlg);

    //  Gather some metrics from the fresh dialog template...
    CMetrics& metrics = _pfsb->GetMetrics();
    RECT rc[3] = {0};

    ASSERT(::IsWindow(GetDlgItem(IDC_USE_DATE)));
    ASSERT(::IsWindow(GetDlgItem(IDC_USE_TYPE)));
    ASSERT(::IsWindow(GetDlgItem(IDC_USE_ADVANCED)));

    ::GetWindowRect(GetDlgItem(IDC_USE_DATE), rc + 0);
    ::GetWindowRect(GetDlgItem(IDC_USE_TYPE), rc + 1);
    ::GetWindowRect(GetDlgItem(IDC_USE_ADVANCED), rc + 2);
    for (int i = 0; i < ARRAYSIZE(rc); i++)
    {
        // MapWindowPoints is mirroring aware only if you pass two points
        ::MapWindowRect(NULL, m_hWnd, &rc[i]);
    }    

    metrics.ExpandOrigin().y = rc[0].top;
    metrics.CheckBoxRect()   = rc[2];
    OffsetRect(&metrics.CheckBoxRect(), -rc[0].left, -rc[0].top);
    
    //  Create subdialogs and collect native sizes.
    if (_dlgDate.Create(m_hWnd))
        _GetWindowSize(_dlgDate, &_subdlgs[SUBDLG_DATE].sizeDlg);

    if (_dlgSize.Create(m_hWnd))
        _GetWindowSize(_dlgSize, &_subdlgs[SUBDLG_SIZE].sizeDlg);

    if (_dlgType.Create(m_hWnd))
        _GetWindowSize(_dlgType, &_subdlgs[SUBDLG_TYPE].sizeDlg);

    if (_dlgAdvanced.Create(m_hWnd))
        _GetWindowSize(_dlgAdvanced, &_subdlgs[SUBDLG_ADVANCED].sizeDlg);

    //  Create index server link window    
    POINT pt = {0};
    HWND hwndCI = _CreateLinkWindow(m_hWnd, IDC_INDEX_SERVER, 
                                     pt, IDS_FSEARCH_CI_DISABLED_LINK);
    UpdateSearchCmdStateUI();

    //  Layout controls
    LayoutControls();

    return TRUE;
}


void COptionsDlg::OnWinIniChange()
{
    CSubDlg::OnWinIniChange();
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
        _subdlgs[i].pDlg->OnWinIniChange();
}


BOOL _SaveCheck(HWND hwnd, UINT nIDCheck, HKEY hkey, LPCTSTR pszValue)
{
    DWORD dwData = IsDlgButtonChecked(hwnd, nIDCheck);
    return ERROR_SUCCESS == RegSetValueEx(hkey, pszValue, 0, REG_DWORD, (LPBYTE)&dwData, sizeof(dwData));
}

BOOL _LoadCheck(HWND hwnd, UINT nIDCheck, HKEY hkey, LPCTSTR pszValue)
{
    DWORD dwData = IsDlgButtonChecked(hwnd, nIDCheck);
    DWORD cbData = sizeof(dwData);

    if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszValue, 0, NULL, (LPBYTE)&dwData, &cbData))
    {
        CheckDlgButton(hwnd, nIDCheck, dwData);
        return TRUE;
    }
    return FALSE;
}

void COptionsDlg::LoadSaveUIState(UINT nIDCtl, BOOL bSave) 
{
}

LRESULT COptionsDlg::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    LayoutControls(pts.x, pts.y);
    return 0;
}


void COptionsDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }

    HDWP hdwp = BeginDeferWindowPos(1 + (ARRAYSIZE(_subdlgs) * 2));
    if (hdwp)
    {
        CMetrics& metrics = _pfsb->GetMetrics();
        POINT ptOrigin = metrics.ExpandOrigin();

        //  For each checkbox and associated subdialog...
        for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
        {
            //  Calculate checkbox position
            HWND hwndCheck = GetDlgItem(_subdlgs[i].nIDCheck);
            ASSERT(hwndCheck);
    
            SetRect(&_subdlgs[i].rcCheck, 
                     ptOrigin.x, ptOrigin.y,
                     ptOrigin.x + RECTWIDTH(metrics.CheckBoxRect()),
                     ptOrigin.y + RECTHEIGHT(metrics.CheckBoxRect()));

            //  Calculate subdialog position
            ULONG dwDlgFlags = SWP_NOACTIVATE;

            if (IsDlgButtonChecked(_subdlgs[i].nIDCheck))
            {
                //  position the checkbox's dialog immediately below.
                SetRect(&_subdlgs[i].rcDlg, 
                         _subdlgs[i].rcCheck.left, _subdlgs[i].rcCheck.bottom,
                         cx - 1, _subdlgs[i].rcCheck.bottom  + _subdlgs[i].sizeDlg.cy);
                dwDlgFlags |= SWP_SHOWWINDOW;

                ptOrigin.y = _subdlgs[i].rcDlg.bottom + metrics.TightMarginY();
            }
            else
            {
                ptOrigin.y = _subdlgs[i].rcCheck.bottom + metrics.TightMarginY();        
                dwDlgFlags |= SWP_HIDEWINDOW;
            }

            //  Reposition the pair
            ::DeferWindowPos(hdwp, _subdlgs[i].pDlg->Hwnd(), hwndCheck, 
                            _subdlgs[i].rcDlg.left,
                            _subdlgs[i].rcDlg.top,
                            RECTWIDTH(_subdlgs[i].rcDlg),
                            RECTHEIGHT(_subdlgs[i].rcDlg),
                            dwDlgFlags);

            ::DeferWindowPos(hdwp, hwndCheck, NULL, 
                            _subdlgs[i].rcCheck.left,
                            _subdlgs[i].rcCheck.top,
                            RECTWIDTH(_subdlgs[i].rcCheck),
                            RECTHEIGHT(_subdlgs[i].rcCheck),
                            SWP_NOZORDER|SWP_NOACTIVATE);
        }

        _LayoutLinkWindow(m_hWnd, metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                           ptOrigin.y, IDC_INDEX_SERVER);

        EndDeferWindowPos(hdwp);
    }
}


//  Assigns focus to the options dialog.   This cannot be done by
//  simply setting focus to the options dialog, which is a child
//  of another dialog; USER will simply assign focus to the parent dialog.
//  So we need to explicitly set focus to our first child.
void COptionsDlg::TakeFocus()
{
    for (HWND hwndCtl = GetWindow(GW_CHILD);
        ::IsWindow(hwndCtl);
         hwndCtl = ::GetWindow(hwndCtl, GW_HWNDNEXT))
    {
        ULONG dwStyle = ::GetWindowLong(hwndCtl, GWL_STYLE);
        if (dwStyle & WS_TABSTOP)
        {
            ::SetFocus(hwndCtl);
            break;
        }
    }
}

//  Note that we do not care about returning results from this, as it will
//  be started asynchronously.
void COptionsDlg::DoDelayedInit()
{
    //  have subdialogs do delayed initialization
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        _subdlgs[i].pDlg->DoDelayedInit();
    }
}

LONG COptionsDlg::QueryHeight(LONG cx /* proposed width */, LONG cy /* proposed height */)
{
    HWND hwndBottommost = GetBottomItem();
    RECT rcThis, rcBottommost;

    //  Retrieve the current height of the bottommost link window.
    GetWindowRect(&rcThis);
    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, GetParent(), &rcThis);
    ::MapWindowRect(NULL, GetParent(), &rcBottommost);

    //  If, at the specified width, we compute a height for the bottommost 
    //  linkwindow that is different from its current height (e.g, due to word wrap),
    //  we'll compute a new window rect that will 
    LONG cyBottommost = (LONG)::SendMessage(hwndBottommost, LWM_GETIDEALHEIGHT, 
                                           cx - (_pfsb->GetMetrics().CtlMarginX() * 2), 0);
    
    if (cyBottommost > 0 && cyBottommost != RECTHEIGHT(rcBottommost))
        rcThis.bottom = rcBottommost.top + cyBottommost + _pfsb->GetMetrics().TightMarginY();

    return RECTHEIGHT(rcThis);
}

BOOL COptionsDlg::GetMinSize(SIZE *pSize)
{
    pSize->cx = pSize->cy = 0;

    HWND hwndBottom = GetBottomItem();

    if (!::IsWindow(hwndBottom))
        return FALSE;

    RECT rcBottom;
    ::GetWindowRect(hwndBottom, &rcBottom);
    ::MapWindowRect(NULL, m_hWnd, &rcBottom);

    pSize->cx = 0;
    pSize->cy = rcBottom.bottom;

    return TRUE;
}

HWND COptionsDlg::GetBottomItem()
{
    HWND hwndBottom = GetDlgItem(IDC_INDEX_SERVER);
    ASSERT(::IsWindow(hwndBottom))
    return hwndBottom;
}

void COptionsDlg::UpdateSearchCmdStateUI(DISPID dispid)
{
    UINT nStatusText;
    BOOL fCiRunning, fCiIndexed, fCiPermission;
    GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);

    if (fCiRunning)
    {
        if (fCiPermission)
            //  we have permission to distinguish between ready and busy
            nStatusText = fCiIndexed ? IDS_FSEARCH_CI_READY_LINK : IDS_FSEARCH_CI_BUSY_LINK;
        else
            //  no permission to distinguish between ready and busy; we'll
            //  just say it's enabled.
            nStatusText = IDS_FSEARCH_CI_ENABLED_LINK;
    }
    else
    {
        nStatusText = IDS_FSEARCH_CI_DISABLED_LINK;
    }

    TCHAR szCaption[MAX_PATH];
    if (nStatusText != _nCIStatusText &&
        EVAL(LoadString(HINST_THISDLL, nStatusText, szCaption, ARRAYSIZE(szCaption))))
    {
        SetDlgItemText(IDC_INDEX_SERVER, szCaption);
        _nCIStatusText = nStatusText;
        LayoutControls();
        SizeToFit(FALSE);
    }
}

STDMETHODIMP COptionsDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    HRESULT hrRet = S_OK;
    //  have subdialogs add their constraints
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        if (::IsWindowVisible(_subdlgs[i].pDlg->Hwnd()))
        {
            HRESULT hr = _subdlgs[i].pDlg->AddConstraints(pSrchCmd);
            if (FAILED(hr))
                hrRet = hr;
        }       
    }
    return hrRet;
}


STDMETHODIMP COptionsDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    //  Try subordinate dialogs.
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        HRESULT hr = _subdlgs[i].pDlg->RestoreConstraint(bstrName, pValue);

        if (S_OK == hr)  // open the dialog
        {
            CheckDlgButton(_subdlgs[i].nIDCheck, TRUE);
            LayoutControls();
            SizeToFit();
        }

        //  if success, we're done.
        if (SUCCEEDED(hr))
            return hr;

        //  otherwise, try next subdialog.
    }
    return E_FAIL;
}


STDMETHODIMP COptionsDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CSubDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Query subdialogs
    if (_dlgDate.IsChild(pmsg->hwnd) &&
        S_OK == _dlgDate.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgType.IsChild(pmsg->hwnd) &&
        S_OK == _dlgType.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgSize.IsChild(pmsg->hwnd) &&
        S_OK == _dlgSize.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgAdvanced.IsChild(pmsg->hwnd) &&
        S_OK == _dlgAdvanced.TranslateAccelerator(pmsg))
        return S_OK;

    return _pfsb->IsDlgMessage(Hwnd(), pmsg);
}


BOOL COptionsDlg::Validate()
{
    //  have subdialogs do validatation
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        if (::IsWindowVisible(_subdlgs[i].pDlg->Hwnd()))
            if (!_subdlgs[i].pDlg->Validate())
                return FALSE;
    }
    return TRUE;
}


void COptionsDlg::Clear()
{
    //  have subdialogs clear themselves.
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        _subdlgs[i].pDlg->Clear();
        CheckDlgButton(_subdlgs[i].nIDCheck, FALSE);
    }
    LayoutControls();
    SizeToFit();
}


LRESULT COptionsDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
#ifdef DEBUG
    //  Is this a sub-dialog expansion/contraction?
    BOOL bIsSubDlgBtn = FALSE;
    for (int i = 0; i < ARRAYSIZE(_subdlgs) && !bIsSubDlgBtn; i++)
    {
        if (nID == _subdlgs[i].nIDCheck)
            bIsSubDlgBtn = TRUE;
    }
    ASSERT(bIsSubDlgBtn);
#endif DEBUG
    
    LoadSaveUIState(nID, TRUE); // persist it.

    LayoutControls();
    SizeToFit(!IsDlgButtonChecked(nID));
        //  don't need to scroll the band if we've expanded a subdialog,
        //  but we do if we've contracted one.

    return 0;
}


void COptionsDlg::SizeToFit(BOOL bScrollBand)
{
    SIZE size;
    GetMinSize(&size);
    size.cy += _pfsb->GetMetrics().TightMarginY();
    SetWindowPos(NULL, 0, 0, size.cx, size.cy, SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);

    ULONG dwLayoutFlags = BLF_ALL;
    if (!bScrollBand)
        dwLayoutFlags &= ~BLF_SCROLLWINDOW;    
    
    ::SendMessage(GetParent(), WMU_UPDATELAYOUT, dwLayoutFlags, 0);
}


LRESULT COptionsDlg::OnIndexServerClick(int idCtl, NMHDR *pnmh, BOOL&)
{
    BOOL fCiRunning, fCiIndexed, fCiPermission = FALSE;
    
    HRESULT hr = GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);
    if (SUCCEEDED(hr) && fCiPermission)
    {
        //  CI is idle or not runnning.  Show status dialog.
        if (IDOK == CCISettingsDlg_DoModal(GetDlgItem(IDC_INDEX_SERVER)))
        {
            // reflect any state change in UI.
            ::PostMessage(GetParent(), WMU_STATECHANGE, 0, 0); 
        }
    }
    else
    {
        //  No permission? display CI help.
        _IndexServiceHelp(NULL);
    }
        
    return 0;
}






// CBandDlg impl



CBandDlg::CBandDlg(CFileSearchBand* pfsb)
    :   _pfsb(pfsb)
{
    // Verify that it initialized to FALSE/NULL
    ASSERT(NULL == _hwnd);
    ASSERT(NULL == _hwndLastFocus);
    
    VariantInit(&_varScope0);
    VariantInit(&_varQueryFile0);
}


CBandDlg::~CBandDlg()
{
    VariantClear(&_varScope0);
    VariantClear(&_varQueryFile0);
}


STDMETHODIMP CBandDlg::TranslateAccelerator(MSG *pmsg)
{
    if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
    {
        IAutoComplete2* pac2;
        if (GetAutoCompleteObjectForWindow(pmsg->hwnd, &pac2))
        {
            if (S_OK == _TestAutoCompleteDropDownState(pac2, ACDD_VISIBLE))
            {
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
                pac2->Release();
                return S_OK;
            }
            pac2->Release();
        }
    }
    
    //  Check for Ctrl+Nav Key:
    if (_pfsb->IsKeyboardScroll(pmsg))
        return S_OK;
    return S_FALSE;
}


void CBandDlg::SetDefaultFocus()
{
    HWND hwndFirst = GetFirstTabItem();
    if (IsWindow(hwndFirst))
        SetFocus(hwndFirst);
}


void CBandDlg::RememberFocus(HWND hwndFocus)
{
    if (!IsWindow(hwndFocus))
    {
        _hwndLastFocus = NULL;
        hwndFocus = GetFocus();
    }

    if (IsChild(_hwnd, hwndFocus))
        _hwndLastFocus = hwndFocus;
}


BOOL CBandDlg::RestoreFocus()
{
    if (IsWindow(_hwndLastFocus))
    {
        if (IsWindowVisible(_hwndLastFocus) && IsWindowEnabled(_hwndLastFocus))
        {
            SetFocus(_hwndLastFocus);
            return TRUE;
        }
    }
    else
        _hwndLastFocus = NULL;
    
    return FALSE;
}


LRESULT CBandDlg::OnChildSetFocusCmd(WORD, WORD, HWND hwndCtl, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, hwndCtl, _pfsb);
    return 0;
}


LRESULT CBandDlg::OnChildSetFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    _EnsureVisible(_hwnd, pnmh->hwndFrom, _pfsb);
    return 0;
}


LRESULT CBandDlg::OnChildKillFocusCmd(WORD, WORD, HWND hwndCtl, BOOL&)
{
    _hwndLastFocus = hwndCtl;
    return 0;
}


LRESULT CBandDlg::OnChildKillFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    _hwndLastFocus = pnmh->hwndFrom;
    return 0;
}


LRESULT CBandDlg::OnComboExEndEdit(int, NMHDR *pnmh, BOOL&)
{
    if (CBEN_ENDEDIT == pnmh->code)
    {
        if (CBENF_KILLFOCUS == ((NMCBEENDEDIT*)pnmh)->iWhy)
            _hwndLastFocus = pnmh->hwndFrom;
    }
    return 0;
}


void CBandDlg::WndPosChanging(HWND hwndOC, LPWINDOWPOS pwp)
{
    SIZE sizeMin;
    if (0 == (pwp->flags & SWP_NOSIZE) && GetMinSize(hwndOC, &sizeMin))
    {
        if (pwp->cx < sizeMin.cx)
            pwp->cx = sizeMin.cx;

        if (pwp->cy < sizeMin.cy)
            pwp->cy = sizeMin.cy;
    }        
}


LRESULT CBandDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    LayoutControls(pts.x, pts.y);
    return 0;
}


void CBandDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(_hwnd, &rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }
    _LayoutCaption(GetIconID(), GetCaptionID(), GetCaptionDivID(), cx);
}


BOOL CBandDlg::GetIdealSize(HWND hwndOC, SIZE *psize) const
{
    ASSERT(psize);
    psize->cx = psize->cy = 0;

    if (!IsWindow(Hwnd()))
        return FALSE;

    SIZE sizeMin;
    if (GetMinSize(hwndOC, &sizeMin))
    {
        RECT rcClient;
        ::GetClientRect(hwndOC, &rcClient);

        psize->cx = (RECTWIDTH(rcClient) < sizeMin.cx) ? sizeMin.cx : RECTWIDTH(rcClient);
        psize->cy = sizeMin.cy;            
        return TRUE;
    }
    
    return FALSE;
}

LRESULT CBandDlg::OnPaint(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Just going to call BeginPaint and EndPaint.  All
    //  painting done in WM_ERASEBKGND handler to avoid flicker.
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(_hwnd, &ps);
    if (hdc)
        EndPaint(_hwnd, &ps);
    return 0;
}

LRESULT CBandDlg::OnEraseBkgnd(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    ASSERT(::IsWindow(_hwnd)); // was _Attach() called, e.g. from WM_INITDIALOG?
    _PaintDlg(_hwnd, _pfsb->GetMetrics(), (HDC)wParam);
    ValidateRect(_hwnd, NULL);
    return TRUE;   
}

LRESULT CBandDlg::OnCtlColorStatic(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    SetTextColor((HDC)wParam, _pfsb->GetMetrics().TextColor());
    SetBkColor((HDC)wParam, _pfsb->GetMetrics().BkgndColor());
    return (LRESULT)_pfsb->GetMetrics().BkgndBrush();
}

//  Hack method to remove turds left after showing band toolbar.
//  Methinks this is a USER issue. [scotthan]
void CBandDlg::RemoveToolbarTurds(int cyOffset)
{
    RECT rcUpdate;
    GetClientRect(_hwnd, &rcUpdate);

    HWND hwndCtl = GetDlgItem(_hwnd, GetCaptionDivID());
    if (hwndCtl)
    {
        RECT rc;
        GetWindowRect(hwndCtl, &rc);
        ::MapWindowRect(NULL, _hwnd, &rc);
        rcUpdate.bottom = rc.bottom;
        OffsetRect(&rcUpdate, 0, cyOffset);

        InvalidateRect(_hwnd, &rcUpdate, TRUE);
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    hwndCtl = GetDlgItem(_hwnd, GetIconID());
    if (hwndCtl)
    {
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    hwndCtl = GetDlgItem(_hwnd, GetCaptionID());
    if (hwndCtl)
    {
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    UpdateWindow(_hwnd);
}


void CBandDlg::_BeautifyCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDIconResource)
{
    //  Do some cosmetic and initialization stuff
    HFONT hf = _pfsb->GetMetrics().BoldFont(_hwnd);
    if (hf)
        SendDlgItemMessage(_hwnd, nIDCaption, WM_SETFONT, (WPARAM)hf, 0);

    if (nIDIcon && nIDIconResource)
    {
        HICON hiconCaption = _pfsb->GetMetrics().CaptionIcon(nIDIconResource);
        if (hiconCaption)
            SendDlgItemMessage(_hwnd, nIDIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hiconCaption);
    }
}


void CBandDlg::_LayoutCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDDiv, LONG cxDlg)
{
    RECT rcIcon, rcCaption;
    LONG cxMargin = _pfsb->GetMetrics().CtlMarginX();

    GetWindowRect(GetDlgItem(_hwnd, nIDIcon), &rcIcon);
    GetWindowRect(GetDlgItem(_hwnd, nIDCaption), &rcCaption);
    ::MapWindowRect(NULL, _hwnd, &rcIcon);
    ::MapWindowRect(NULL, _hwnd, &rcCaption);

    int nTop = max(rcIcon.bottom, rcCaption.bottom) + _PixelsForDbu(_hwnd, 1, FALSE);

    SetWindowPos(GetDlgItem(_hwnd, nIDDiv), GetDlgItem(_hwnd, nIDCaption),
                  cxMargin, nTop, cxDlg - (cxMargin * 2), 2, SWP_NOACTIVATE);              
}



void CBandDlg::_LayoutSearchLinks(UINT nIDCaption, UINT nIDDiv, BOOL bShowDiv, LONG left, LONG right, LONG yMargin, 
                                   LONG& yStart, const int rgLinkIDs[], LONG cLinkIDs)
{
    //  Position divider
    if (bShowDiv != 0)
    {
        RECT rcDiv;
        SetRect(&rcDiv, left, yStart, right, yStart + 1);
        SetWindowPos(GetDlgItem(_hwnd, nIDDiv), GetDlgItem(_hwnd, nIDCaption),
                      rcDiv.left, rcDiv.top, RECTWIDTH(rcDiv), RECTHEIGHT(rcDiv),
                      SWP_NOACTIVATE|SWP_SHOWWINDOW);

        yStart += yMargin;
    }
    else
        ShowWindow(GetDlgItem(_hwnd, nIDDiv), SW_HIDE);

    //  Position caption
    RECT rcCaption;
    GetWindowRect(GetDlgItem(_hwnd, nIDCaption), &rcCaption);
    ::MapWindowRect(NULL, _hwnd, &rcCaption);
    OffsetRect(&rcCaption, left - rcCaption.left, yStart - rcCaption.top);
    SetWindowPos(GetDlgItem(_hwnd, nIDCaption), NULL, 
                  left, yStart, 0,0,
                  SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    yStart += RECTHEIGHT(rcCaption) + yMargin;

    //  Position links
    _LayoutLinkWindows(_hwnd, left, right, yMargin, yStart, rgLinkIDs, cLinkIDs);
}


LRESULT CBandDlg::OnEditChange(WORD, WORD, HWND, BOOL&)
{
    _pfsb->SetDirty();
    return 0;
}


LRESULT CBandDlg::OnSearchLink(int nID, LPNMHDR, BOOL&)
{
    ASSERT(_pfsb);

    _pfsb->StopSearch();
    switch (nID)
    {
    case IDC_SEARCHLINK_FILES:
        _pfsb->FindFilesOrFolders(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_COMPUTERS:
        _pfsb->FindComputer(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_PRINTERS:
        _pfsb->FindPrinter(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_PEOPLE:
        _pfsb->FindPeople(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_INTERNET:
        _pfsb->FindOnWeb(FALSE, TRUE);
        break;
    }
    return 0;
}


//  Invoked when a client calls IFileSearchBand::SetSearchParameters() 
HRESULT CBandDlg::SetScope(IN VARIANT* pvarScope, BOOL bTrack)
{
    HRESULT hr = S_OK;

    VariantClear(&_varScope0);
    
    //  cache the scope
    if (pvarScope)
        hr = VariantCopy(&_varScope0, pvarScope);

    return hr;
}


HRESULT CBandDlg::GetScope(OUT VARIANT* pvarScope)
{ 
    //  retrieve the scope
    if (!pvarScope)
        return E_INVALIDARG;

    HRESULT hr = VariantCopy(pvarScope, &_varScope0);

    return SUCCEEDED(hr) ? (VT_EMPTY == _varScope0.vt ? S_FALSE : S_OK) : hr;
}


HRESULT CBandDlg::SetQueryFile(IN VARIANT* pvarFile)
{
    return VariantCopy(&_varQueryFile0, pvarFile);
}


HRESULT CBandDlg::GetQueryFile(OUT VARIANT* pvarFile)
{
    //  retrieve the filename of the query to restore.
    if (!pvarFile)
        return E_INVALIDARG;

    VariantInit(pvarFile);
    HRESULT hr = VariantCopy(pvarFile, &_varQueryFile0);

    return SUCCEEDED(hr) ? (VT_EMPTY == _varQueryFile0.vt ? S_FALSE : S_OK) : hr;
}


// CFindFilesDlg impl

#define FSEARCHMAIN_TABFIRST      IDC_FILESPEC
#define FSEARCHMAIN_TABLAST       IDC_SEARCHLINK_INTERNET
#define FSEARCHMAIN_BOTTOMMOST    IDC_SEARCHLINK_INTERNET // bottom-most control
#define FSEARCHMAIN_RIGHTMOST     IDC_SEARCH_STOP         // right-most control
#define UISTATETIMER              1
#define UISTATETIMER_DELAY        4000


CFindFilesDlg::CFindFilesDlg(CFileSearchBand* pfsb)
    :   CSearchCmdDlg(pfsb),
        _dlgOptions(pfsb),
        _iCurNamespace(CB_ERR),
        _fTrackScope(TRACKSCOPE_SPECIFIC),
        _dwWarningFlags(DFW_DEFAULT),
        _dwRunOnceWarningFlags(DFW_DEFAULT)
{
    // Since we use the zero initializer for COM objects, all variables should
    // be initialized to NULL/FALSE/0
    ASSERT(FALSE == _bScoped);
    ASSERT(FALSE == _fDisplayOptions);
    ASSERT(FALSE == _fNamespace);
    ASSERT(FALSE == _fDebuted);
    ASSERT(FALSE == _fBandFinishedDisplaying);
    ASSERT(NULL  == _pacGrepText);
    ASSERT(NULL  == _pmruGrepText);
    ASSERT(NULL  == _pacFileSpec);
    ASSERT(NULL  == _pmruFileSpec);
    ASSERT(0     == *_szInitialPath);
    ASSERT(0     == *_szInitialNames);
    ASSERT(0     == *_szCurrentPath);
    ASSERT(0     == *_szLocalDrives);
    ASSERT(NULL  == _pidlInitial);
}

CFindFilesDlg::~CFindFilesDlg()
{
    ATOMICRELEASE(_pacGrepText);
    ATOMICRELEASE(_pmruGrepText);
    ATOMICRELEASE(_pacFileSpec);
    ATOMICRELEASE(_pmruFileSpec);
    ILFree(_pidlInitial);
}

//  Scope to a default namespace.
BOOL CFindFilesDlg::SetDefaultScope()
{
    //  If we've already assigned a scope, bail early
    if (_bScoped) 
        return TRUE;

    //  Try establiblishing the preassigned (_szInitialXXX) scope:
    BOOL bScoped = _SetPreassignedScope();
    if (!bScoped)
    {
        //  Try setting scope to the current shell folder of the active view...
        bScoped = _SetFolderScope();
        if (!bScoped)
        {
            //  set it to the hard-coded shell default folder
            bScoped = _SetLocalDefaultScope();
        }
    }

    return bScoped;
}


//  Assignes the namespace control to the preassigned scope saved in
//  _szInitialNames/_szInitialPath/_pidlInitial
BOOL CFindFilesDlg::_SetPreassignedScope()
{
    BOOL bScoped = FALSE;
    if (*_szInitialNames || *_szInitialPath || _pidlInitial)
        bScoped = AssignNamespace(_szInitialPath, _pidlInitial, _szInitialNames, FALSE);

    return bScoped;
}

STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf);

//  Scope to the namespace of the current shell folder view
BOOL CFindFilesDlg::_SetFolderScope()
{
    BOOL bScoped = FALSE;
    ASSERT(_pfsb->BandSite());

    LPITEMIDLIST pidl;
    if (SUCCEEDED(_GetCurrentFolderIDList(_pfsb->BandSite(), &pidl)))
    {
        // Get the display name/path.  IF it is an FTP site, then we need to get the name
        // as though it is for the address bar becasue when we call SHGetPathFromIDList,
        // it returns "" for FTP sites.  
        IShellFolder *psf = NULL;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf)))
        && IsFTPFolder(psf))
        {
            SHGetNameAndFlags(pidl, SHGDN_FORADDRESSBAR, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
            SHGetNameAndFlags(pidl, SHGDN_FORPARSING, _szInitialPath, ARRAYSIZE(_szInitialNames), NULL);
        }
        else
        {
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
            SHGetPathFromIDList(pidl, _szInitialPath);  // file system path only here!
        }

        if (psf)
        {
            psf->Release();
        }

        // Store the pidl for use later if we are starting it async
        _pidlInitial = ILClone(pidl);
        
        //  if we're tracking the scope loosely...
        if ((TRACKSCOPE_GENERAL == _fTrackScope) && _IsPathLocalHarddrive(_szInitialPath))
        {
            //  scope to local default scope
            *_szInitialNames = *_szInitialPath = 0;
            bScoped = _SetLocalDefaultScope();
        }
        else if (_threadState.fComplete /* finished populating namespace combo */ && 
                 _szInitialPath[0])
        {
            bScoped = AssignNamespace(_szInitialPath, pidl, _szInitialNames, FALSE);
        }
        ILFree(pidl);
    }

    return bScoped;
}


//  Scope to the hard-coded shell default namespace.
BOOL CFindFilesDlg::_SetLocalDefaultScope()
{
    BOOL bScoped = FALSE;

    //  Initialize fallback initial namespace

    // default to Local Hard Drives if possible
    if (_szLocalDrives[0] &&
        AssignNamespace(NULL, NULL, _szLocalDrives, FALSE))
    {
        bScoped = TRUE;
    }
    else
    {        
        TCHAR szDesktopPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szDesktopPath)) &&
            AssignNamespace(NULL, NULL, szDesktopPath, FALSE))
        {
            bScoped = TRUE;
        }
    }
    
    //  If we failed, this means that the namespace combo hasn't
    //  been populated yet.   
    //  We just sit tight, cuz the populating thread will fall back on
    //  the LocalDefaultScope.
    return bScoped;
}


//  search **band** show/hide handler
void CFindFilesDlg::OnBandShow(BOOL fShow)
{
    CSearchCmdDlg::OnBandShow(fShow);
    if (fShow)
    {
        //  Establish the first showing's band width
        if (!_fDebuted && _pfsb->IsBandDebut())
        {
            _pfsb->SetDeskbandWidth(GetIdealDeskbandWidth());
            _fDebuted = TRUE;
        }
        
        //  If we're tracking the scope to the current folder shell view,
        //  update it now, as it may have changed.
        if (_fTrackScope != TRACKSCOPE_NONE)
        {
            _bScoped = FALSE;
            _SetFolderScope();
        }
        
        //  restart our UI state timer
        SetTimer(UISTATETIMER, UISTATETIMER_DELAY);
    }
    else
    {
        //  we're being hidden so stop updating our state indicators.
        KillTimer(UISTATETIMER);
    }
}


//  search band **dialog** show/hide handler
void CFindFilesDlg::OnBandDialogShow(BOOL fShow)
{
    CSearchCmdDlg::OnBandDialogShow(fShow);

    if (fShow)
    {
        //  If we're tracking the scope to the current folder shell view,
        //  update it now, as it may have changed.
        if (_fTrackScope != TRACKSCOPE_NONE)
        {
            _bScoped = FALSE;
            _SetFolderScope();
        }
    }
}


//  Explicit scoping method.   This will be called if a client
//  called IFileSearchBand::SetSearchParameters with a non-NULL scope.
HRESULT CFindFilesDlg::SetScope(IN VARIANT* pvarScope, BOOL bTrack)
{
    HRESULT hr = CBandDlg::SetScope(pvarScope, bTrack);
    
    if (S_OK != hr)
        return hr;

    LPITEMIDLIST pidlSearch = VariantToIDList(&_varScope0);
    if (pidlSearch)
    {
        SHGetNameAndFlags(pidlSearch, SHGDN_FORPARSING,  _szInitialPath, ARRAYSIZE(_szInitialPath), NULL);
        SHGetNameAndFlags(pidlSearch, SHGDN_NORMAL, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
        ILFree(pidlSearch);

        //  Did we get one?   
        if (*_szInitialNames || *_szInitialPath)
        {
            if (_bScoped)
            {
                //  If we've already scoped, update the namespace combo.
                //  Track if succeed and requested.
                if (AssignNamespace(_szInitialPath, NULL, _szInitialNames, FALSE) && bTrack)
                    _fTrackScope = TRACKSCOPE_SPECIFIC;
            }
            else 
            {
                //  Not already scoped.   We've assigned our initial namespace,
                //  let the namespace thread completion handler update
                //  the combo
                if (bTrack)
                    _fTrackScope = TRACKSCOPE_SPECIFIC;
            }
        }
    }
    return S_OK;
}


LRESULT CFindFilesDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);
    _dlgOptions.SetBandDlg(this);

    //  Register specialty window classes.
    DivWindow_RegisterClass();
    GroupButton_RegisterClass();
    
    //  Initialize some metrics
    CMetrics&   metrics = _pfsb->GetMetrics();
    RECT        rc;

    _pfsb->GetMetrics().Init(m_hWnd);

    // SHAutoComplete(::GetWindow(GetDlgItem(IDC_NAMESPACE), GW_CHILD), SHACF_FILESYS_DIRS);

    ::GetWindowRect(GetDlgItem(IDC_FILESPEC), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    metrics.ExpandOrigin().x = rc.left;

    //  Position start, stop buttons.
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    int cxBtn = _GetResourceMetric(m_hWnd, IDS_FSEARCH_STARTSTOPWIDTH, TRUE);
    if (cxBtn > 0)
    {
        rc.right = rc.left + cxBtn;
    
        ::SetWindowPos(GetDlgItem(IDC_SEARCH_START), NULL, 
                        rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    
        OffsetRect(&rc, cxBtn + _PixelsForDbu(m_hWnd, 12, TRUE), 0);
        ::SetWindowPos(GetDlgItem(IDC_SEARCH_STOP), NULL, 
                        rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }

    //  Create subdialogs and collect native sizes.
    _dlgOptions.Create(m_hWnd);
    ASSERT(::IsWindow(_dlgOptions));

    //  Load settings
    LoadSaveUIState(0, FALSE);

    //  Show/Hide the "Search" Options subdialog
    _dlgOptions.ShowWindow(_fDisplayOptions ? SW_SHOW : SW_HIDE);

    //  Create 'link' child controls
    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;

    //  Create 'Search Options' link and group button
    _CreateLinkWindow(m_hWnd, IDC_SEARCHLINK_OPTIONS, pt, 
                       IDS_FSEARCH_SEARCHLINK_OPTIONS, !_fDisplayOptions);

    TCHAR szGroupBtn[128];
    EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_GROUPBTN_OPTIONS, 
                      szGroupBtn, ARRAYSIZE(szGroupBtn)));
    HWND hwndGrpBtn = CreateWindowEx(0, GROUPBUTTON_CLASS, szGroupBtn, 
                                      WS_CHILD|WS_BORDER|WS_TABSTOP, pt.x, pt.y, 400, 18, 
                                      m_hWnd, (HMENU)IDC_GROUPBTN_OPTIONS, HINST_THISDLL, NULL);
    if (::IsWindow(hwndGrpBtn))
    {
        ::SendMessage(hwndGrpBtn, GBM_SETBUDDY, 
                       (WPARAM)_dlgOptions.m_hWnd, (LPARAM)GBBF_HRESIZE|GBBF_VSLAVE);
        ::ShowWindow(GetDlgItem(IDC_GROUPBTN_OPTIONS), _fDisplayOptions ? SW_SHOW : SW_HIDE);
    }
                    
    //  Create cross-navigation links
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_FILES);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_FSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    //  Do some cosmetic and initialization stuff
    OnWinIniChange();

    _InitializeMru(GetDlgItem(IDC_FILESPEC), &_pacFileSpec, 
                    TEXT("FilesNamedMRU"), &_pmruFileSpec);
    _InitializeMru(GetDlgItem(IDC_GREPTEXT), &_pacGrepText, 
                    TEXT("ContainingTextMRU"), &_pmruGrepText);

    SendDlgItemMessage(IDC_FILESPEC, EM_LIMITTEXT, MAX_EDIT, 0);
    SendDlgItemMessage(IDC_GREPTEXT, EM_LIMITTEXT, MAX_EDIT, 0);

    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXTENDEDSTYLE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);
    
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETIMAGELIST, 0, (LPARAM)GetSystemImageListSmallIcons());
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXSTYLE, 0, 0);

    //  Enable the cue banners for the edit boxes:
    TCHAR szCaption[128];
    LoadString(HINST_THISDLL, IDS_FIND_CUEBANNER_FILE, szCaption, ARRAYSIZE(szCaption));
    SendDlgItemMessage(IDC_FILESPEC, EM_SETCUEBANNER, 0, (LPARAM) szCaption);

    LoadString(HINST_THISDLL, IDS_FIND_CUEBANNER_GREP, szCaption, ARRAYSIZE(szCaption));
    SendDlgItemMessage(IDC_GREPTEXT, EM_SETCUEBANNER, 0, (LPARAM) szCaption); 

    //  Bias the input reader towards file names
    SetModeBias(MODEBIASMODE_FILENAME);

    //  Launch thread to populate the namespaces combo.
    _threadState.hwndCtl   = GetDlgItem(IDC_NAMESPACE);
    _threadState.pvParam   = this;
    _threadState.fComplete = FALSE;
    _threadState.fCancel   = FALSE;

    if (SUCCEEDED(SAFECAST(_pfsb, IFileSearchBand*)->QueryInterface(IID_PPV_ARG(IUnknown, &_threadState.punkBand))))
    {
        if (!SHCreateThread(NamespaceThreadProc, &_threadState, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(_threadState.punkBand);
        }
    }

    //  Layout our subdialogs and update state representation...
    LayoutControls();
    UpdateSearchCmdStateUI();

    SetTimer(UISTATETIMER, UISTATETIMER_DELAY);

    return TRUE;  // Let the system set the focus
}


LRESULT CFindFilesDlg::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // paint the background
    _PaintDlg(m_hWnd, _pfsb->GetMetrics(), (HDC)wParam); 
    
    if (_fDisplayOptions)
        // ensure that the group button is updated.
        SendDlgItemMessage(IDC_GROUPBTN_OPTIONS, WM_NCPAINT, (WPARAM)1, 0);
    
    //  validate our work.
    ValidateRect(NULL);
    return TRUE;   
}


void CFindFilesDlg::OnWinIniChange()
{
    CBandDlg::OnWinIniChange();

    //  redisplay animated icon
    HWND hwndIcon = GetDlgItem(IDC_FSEARCH_ICON);
    Animate_Close(hwndIcon);
    Animate_OpenEx(hwndIcon, HINST_THISDLL, MAKEINTRESOURCE(IDA_FINDFILE));
    SendDlgItemMessage(IDC_NAMESPACE, CB_SETDROPPEDWIDTH, 
                        _PixelsForDbu(m_hWnd, MIN_NAMESPACELIST_WIDTH, TRUE), 0);

    _BeautifyCaption(IDC_FSEARCH_CAPTION);

    _dlgOptions.OnWinIniChange();
}


LRESULT CFindFilesDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
{
    KillTimer(UISTATETIMER);
    StopSearch();
    if (_pSrchCmd)
    {
        DisconnectEvents();
        IUnknown_SetSite(_pSrchCmd, NULL);
    }
    _threadState.fCancel = TRUE;
    _fOnDestroy = TRUE;
    bHandled = FALSE;
    return 0;
}

BOOL CFindFilesDlg::Validate()
{
    return _dlgOptions.Validate();
}

STDMETHODIMP CFindFilesDlg::AddConstraints(ISearchCommandExt *pSrchCmd)
{
    HRESULT hr;
    VARIANT var = {0};

    TCHAR szPath[MAX_URL_STRING];

    // If the user enters a path as a filename, it will recognize it as a path and replace
    // the filename with just the file portion and the namespace with the path.
    if (::GetDlgItemText(m_hWnd, IDC_FILESPEC, szPath, ARRAYSIZE(szPath)) > 0)
    {
        if (StrChr(szPath, TEXT('\\')) != NULL)
        {
            if (!_PathLooksLikeFilePattern(szPath) &&
                (PathIsUNCServer(szPath) /* string test: \\server */|| 
                 _PathIsUNCServerShareOrSub(szPath) /* string test: \\server\share */ ||
                  PathIsDirectory(szPath)) /* this actually tests existence */)
            {
                ::SetDlgItemText(m_hWnd, IDC_FILESPEC, TEXT("*.*"));
                AssignNamespace(szPath, NULL, NULL, FALSE);
            }
            else
            {
                // just use the prefix for the file spec & the root for the location
                TCHAR szRoot[MAX_URL_STRING];
                lstrcpy(szRoot, szPath);
                if (PathRemoveFileSpec(szRoot) && szRoot[0] != 0) 
                {
                    PathStripPath(szPath);
                    ::SetDlgItemText(m_hWnd, IDC_FILESPEC, szPath);
                    AssignNamespace(szRoot, NULL, NULL, FALSE);                
                }
            }
        }
    }

    // If _ReconcileNamespace could not add an item to the combo box for 
    // the path entered, then it means that the path is likely invalid. 
    // Get the path and check it here.  
    IEnumIDList *penum;
    hr = _GetTargetNamespace(&penum);
    if (SUCCEEDED(hr))
    {
        var.vt = VT_UNKNOWN;
        penum->QueryInterface(IID_PPV_ARG(IUnknown, &var.punkVal));

        hr = _AddConstraint(pSrchCmd, L"LookIn", &var);

        VariantClear(&var);
    }
    else
    {
        GetDlgItemText(IDC_NAMESPACE, szPath, ARRAYSIZE(szPath));
        hr = _PathValidate(szPath, GetParent(), TRUE);
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(InitVariantFromStr(&var, szPath)))
            {
                hr = _AddConstraint(pSrchCmd, L"LookIn", &var);
                VariantClear(&var);
            }
        }
        else
        {
            // _PathValidate's SHPathPrepareForWrite may have already displayed error
            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                TCHAR szMsg[MAX_URL_STRING];
                if (_FmtError(IDS_FSEARCH_INVALIDFOLDER_FMT, szPath, szMsg, ARRAYSIZE(szMsg)))
                    ShellMessageBox(HINST_THISDLL, GetParent(), szMsg, NULL, MB_OK | MB_ICONASTERISK);
            }
            ::SetFocus(GetDlgItem(IDC_NAMESPACE));
        }
    }

    if (SUCCEEDED(hr))
    {
        //  Add 'Files Named' constraint
        if (S_OK == _GetWindowValue(m_hWnd, IDC_FILESPEC, &var))
        {
            hr = _AddConstraint(pSrchCmd, L"Named", &var);
            if (SUCCEEDED(hr))
                _AddMruStringFromWindow(_pmruFileSpec, GetDlgItem(IDC_FILESPEC));
            VariantClear(&var);
        }

        //  Add 'Containing Text' constraint
        if (S_OK == _GetWindowValue(m_hWnd, IDC_GREPTEXT, &var))
        {
            VARIANT varQuery;
            ULONG ulDialect;
            BOOL fCiQuery = IsCiQuery(&var, &varQuery, &ulDialect);
            if (fCiQuery)
            {
                hr = _AddConstraint(pSrchCmd, L"IndexedSearch", &varQuery);
                if (SUCCEEDED(hr))
                {
                    _AddMruStringFromWindow(_pmruGrepText, GetDlgItem(IDC_GREPTEXT));
                
                    VariantClear(&var);
                    var.vt = VT_UI4;
                    var.ulVal = ulDialect;
                    hr = _AddConstraint(pSrchCmd, L"QueryDialect", &var);
                }
            }
            else
            {
                //  add to 'containing text' constraint
                hr = _AddConstraint(pSrchCmd, L"ContainingText", &var);
                if (SUCCEEDED(hr))
                    _AddMruStringFromWindow(_pmruGrepText, GetDlgItem(IDC_GREPTEXT));
            }
            VariantClear(&varQuery);
            VariantClear(&var);
        }

        //  Warning flags
    
        if (_dwRunOnceWarningFlags != DFW_DEFAULT) 
        {
            // re-run the query w/ temporary warning bits.
            var.ulVal = _dwRunOnceWarningFlags;
            var.vt    = VT_UI4;
            //_dwRunOnceWarningFlags = DFW_DEFAULT; cannot reset it here in case of error, must preserve them
       
            hr = _AddConstraint(pSrchCmd, L"WarningFlags", &var);
        }
        else if (_dwWarningFlags != DFW_DEFAULT)
        {
            var.ulVal = _dwWarningFlags;
            var.vt    = VT_UI4;
            hr = _AddConstraint(pSrchCmd, L"WarningFlags", &var);
        }
    
        VariantClear(&var);

        hr = _dlgOptions.AddConstraints(pSrchCmd);
    }

    return hr;
}


STDMETHODIMP CFindFilesDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"Named", bstrName))
    {
        _SetWindowValue(m_hWnd, IDC_FILESPEC, pValue);
        return S_FALSE;
    }

    if (IsConstraintName(L"IndexedSearch", bstrName))
    {
        ASSERT(VT_BSTR == pValue->vt);
        if (pValue->bstrVal)
        {
            int cch = lstrlenW(pValue->bstrVal) + 2;
            LPWSTR pwszVal = new WCHAR[cch];
            if (pwszVal)
            {
                *pwszVal = L'!';
                StrCatW(pwszVal, pValue->bstrVal);
            }
        
            ::SetDlgItemTextW(m_hWnd, IDC_GREPTEXT, pwszVal);
            if (pwszVal)
                delete [] pwszVal;
        }
        return S_FALSE;
    }

    if (IsConstraintName(L"ContainingText", bstrName))
    {
        _SetWindowValue(m_hWnd, IDC_GREPTEXT, pValue);
        return S_FALSE;
    }

    HRESULT hr = _dlgOptions.RestoreConstraint(bstrName, pValue);

    if (S_OK == hr) // opened a dialog
        _ShowOptions(TRUE);

    if (SUCCEEDED(hr))
        return hr;   
   
    return E_FAIL;
}


void CFindFilesDlg::RestoreSearch()
{
    DFConstraint* pdfc = NULL;
    HRESULT hr;
    BOOL    bMore = TRUE;
    ISearchCommandExt* pSrchCmd = GetSearchCmd();

    if (NULL == pSrchCmd)
        return;

    CSearchCmdDlg::Clear();

    // we'll anchor to any restored scope, or the default
    _fTrackScope = TRACKSCOPE_GENERAL;

    for (hr = pSrchCmd->GetNextConstraint(TRUE, &pdfc);
         S_OK == hr && bMore;
         hr = pSrchCmd->GetNextConstraint(FALSE, &pdfc))
    {
        BSTR bstrName = NULL;

        if (S_OK == (hr = pdfc->get_Name(&bstrName)) && bstrName)
        {
            if (*bstrName == 0)
                bMore = FALSE;   // no more constraints.
            else
            {
                VARIANT varValue = {0};
                hr = pdfc->get_Value(&varValue);
                if (S_OK == hr)
                {
                    //  If this is the 'lookin' value, cache the path.
                    if (IsConstraintName(L"LookIn", bstrName))
                    {
                        if (VT_BSTR == varValue.vt && varValue.bstrVal)
                        {
                            USES_CONVERSION;

                            //  Assign path and clear display name (which we don't know or care about).
                            if (_bScoped)
                                AssignNamespace(W2T(varValue.bstrVal), NULL, NULL, FALSE);
                            else
                            {
                                lstrcpyn(_szInitialPath, W2T(varValue.bstrVal), ARRAYSIZE(_szInitialPath));
                                *_szInitialNames = 0;
                            }
                        }
                    }
                    else
                        RestoreConstraint(bstrName, &varValue);    
                    VariantClear(&varValue);
                }
            }
            SysFreeString(bstrName);
        }

        pdfc->Release();
    }
    LayoutControls();
    _pfsb->UpdateLayout();
}

HRESULT FirstIDList(IEnumIDList *penum, LPITEMIDLIST *ppidl)
{
    penum->Reset();
    return penum->Next(1, ppidl, NULL);
}

HRESULT CFindFilesDlg::_GetTargetNamespace(IEnumIDList **ppenum)
{
    *ppenum = NULL;

    // We don't trust the comboex to handle the edit text properly so try to compensate...
    TCHAR szText[MAX_PATH];
    GetDlgItemText(IDC_NAMESPACE, szText, ARRAYSIZE(szText));
    INT_PTR iCurSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if (CB_ERR != iCurSel)
    {
        TCHAR szItemName[MAX_PATH];

        if (CB_ERR == SendDlgItemMessage(IDC_NAMESPACE, CB_GETLBTEXT, (WPARAM)iCurSel, (LPARAM)szItemName))
            szItemName[0] = 0;

        *ppenum = _GetItems(iCurSel);
        if (*ppenum)
        {
            if (lstrcmp(szText, szItemName))
                *ppenum = NULL;            // combo edit/combo dropdown mismatch!
        }
    }
    return *ppenum ? S_OK : E_FAIL;
}

void CFindFilesDlg::Clear()
{
    CSearchCmdDlg::Clear();
    
    //  Clear edit fields
    SetDlgItemText(IDC_FILESPEC, NULL);
    SetDlgItemText(IDC_GREPTEXT, NULL);

    _dlgOptions.Clear();
    _pfsb->UpdateLayout(BLF_ALL);
}

void CFindFilesDlg::LoadSaveUIState(UINT nIDCtl, BOOL bSave) 
{
    if (0 == nIDCtl)   // load/save all.
    {
        LoadSaveUIState(IDC_SEARCHLINK_OPTIONS, bSave);
        LoadSaveUIState(LSUIS_WARNING, bSave);
    }
    
    HKEY hkey = _pfsb->GetBandRegKey(bSave);
    if (hkey)
    {
        DWORD   dwData;
        DWORD   cbData;
        DWORD   dwType;
        LPCTSTR pszVal = NULL; 

        switch (nIDCtl)
        {
        case IDC_SEARCHLINK_OPTIONS:
            pszVal = TEXT("UseSearchOptions");
            dwData = _fDisplayOptions;
            cbData = sizeof(dwData);
            dwType = REG_DWORD;
            break;
        
        case LSUIS_WARNING:
            pszVal = TEXT("Warnings");
            dwData = _dwWarningFlags;
            cbData = sizeof(_dwWarningFlags);
            dwType = REG_DWORD;
            break;
        }

        if (bSave)
            RegSetValueEx(hkey, pszVal, 0, dwType, (LPBYTE)&dwData, cbData);
        else
        {
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszVal, 0, &dwType, 
                                                  (LPBYTE)&dwData, &cbData))
            {
                switch (nIDCtl)
                {
                case IDC_SEARCHLINK_OPTIONS:
                    _fDisplayOptions = BOOLIFY(dwData);
                    break;
                case LSUIS_WARNING:
                    _dwWarningFlags = dwData;
                    break;
                }
            }
        }
        
        RegCloseKey(hkey);
    }
}

HWND CFindFilesDlg::GetFirstTabItem() const
{
    return GetDlgItem(FSEARCHMAIN_TABFIRST);
}

HWND CFindFilesDlg::GetLastTabItem() const
{
    return GetDlgItem(FSEARCHMAIN_TABLAST);
}

BOOL CFindFilesDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2)
{
    *ppac2 = NULL;

    if (hwnd == GetDlgItem(IDC_FILESPEC))
        *ppac2 = _pacFileSpec;
    else if (hwnd == GetDlgItem(IDC_GREPTEXT))
        *ppac2 = _pacGrepText;

    if (*ppac2)
    {
        (*ppac2)->AddRef();
        return TRUE;
    }
    return CBandDlg::GetAutoCompleteObjectForWindow(hwnd, ppac2);
}


void CFindFilesDlg::_ShowNamespaceEditImage(BOOL bShow)
{
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, bShow ? 0 : CBES_EX_NOEDITIMAGE);
}



STDMETHODIMP CFindFilesDlg::TranslateAccelerator(MSG *pmsg)
{
    //  Check for Ctrl+Nav Key:
    if (S_OK == CSearchCmdDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Check for VK_RETURN key.
    if (WM_KEYDOWN == pmsg->message)
    {
        HWND hwndFocus = ::GetFocus();
        if (hwndFocus == GetDlgItem(IDC_NAMESPACE) || ::IsChild(GetDlgItem(IDC_NAMESPACE), hwndFocus))
        {
            if (VK_RETURN == pmsg->wParam || VK_TAB == pmsg->wParam || VK_F6 == pmsg->wParam)
            {
                _UIReconcileNamespace();
            }
            else 
            {
                //  Hide edit image if this virtkey maps to a character,
                if (MapVirtualKey((UINT)pmsg->wParam, 2) != 0 /* it's a char */)
                    _fNamespace = TRUE;
                _ShowNamespaceEditImage(!_fNamespace);
            }
        }
    }

    if (_dlgOptions.IsChild(pmsg->hwnd) &&
        S_OK == _dlgOptions.TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}


BOOL CFindFilesDlg::GetMinSize(HWND hwndOC, SIZE *psize) const
{
    CMetrics& metrics = _pfsb->GetMetrics();
    RECT rc;

    //  Calculate minimum tracking width.
    ASSERT(psize);
    psize->cx = psize->cy = 0;

    if (!::IsWindow(m_hWnd))
        return FALSE;

        // determine mininum width
    HWND hwndLimit = GetDlgItem(FSEARCHMAIN_RIGHTMOST);
    if (!::GetWindowRect(hwndLimit, &rc))
    {
        ASSERT(hwndLimit != NULL);
        return FALSE;
    }
    ::MapWindowRect(NULL, m_hWnd, &rc);
    psize->cx = rc.right + metrics.CtlMarginX();

    // determine mininum height
    hwndLimit = GetDlgItem(FSEARCHMAIN_BOTTOMMOST);

    if (!(::IsWindow(hwndLimit) && ::GetWindowRect(hwndLimit, &rc)))
        return FALSE;

    ::MapWindowRect(NULL, m_hWnd, &rc);
    psize->cy = rc.bottom + metrics.TightMarginY();

    return TRUE;
}


int CFindFilesDlg::GetIdealDeskbandWidth() const
{
    LONG cx0 = _GetResourceMetric(m_hWnd, IDS_FSEARCH_BANDWIDTH, TRUE);
    ASSERT(cx0 >= 0);

    return cx0 + (_pfsb->GetMetrics().CtlMarginX() * 2);
}


BOOL CFindFilesDlg::GetMinMaxInfo(HWND hwndOC, LPMINMAXINFO pmmi)
{
    SIZE sizeMin;
    if (GetMinSize(hwndOC, &sizeMin))
    {
        pmmi->ptMinTrackSize.x = sizeMin.cx;
        pmmi->ptMinTrackSize.y = sizeMin.cy;
        return TRUE;
    }
    return FALSE;
}


void CFindFilesDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rcClient;
        GetClientRect(&rcClient);
        cx = RECTWIDTH(rcClient);
        cy = RECTHEIGHT(rcClient);
    }
    CBandDlg::LayoutControls(cx, cy);

    CMetrics& metrics = _pfsb->GetMetrics();
    POINT ptOrigin = metrics.ExpandOrigin();
    HDWP  hdwp = BeginDeferWindowPos(6);

    if (hdwp)
    {
        //  Resize edit, combo immediate children
        int i;
        enum {  ircFILESPEC,
                ircGREPTEXT,
                ircNAMESPACE,
                ircSEARCHSTART,
                ircOPTIONGRP,
                ircOPTIONSDLG,
                ircLINKCAPTION,
                ircDIV2,
                irc_count };
        RECT rcCtls[irc_count];

        ::GetWindowRect(GetDlgItem(IDC_FILESPEC),            &rcCtls[ircFILESPEC]);
        ::GetWindowRect(GetDlgItem(IDC_GREPTEXT),            &rcCtls[ircGREPTEXT]);
        ::GetWindowRect(GetDlgItem(IDC_NAMESPACE),           &rcCtls[ircNAMESPACE]);
        ::GetWindowRect(GetDlgItem(IDC_SEARCH_START),        &rcCtls[ircSEARCHSTART]);
        ::GetWindowRect(GetDlgItem(IDC_GROUPBTN_OPTIONS),    &rcCtls[ircOPTIONGRP]);
        ::GetWindowRect(GetDlgItem(IDC_SEARCHLINK_CAPTION),  &rcCtls[ircLINKCAPTION]);
        ::GetWindowRect(GetDlgItem(IDC_FSEARCH_DIV2),        &rcCtls[ircDIV2]);

        SIZE sizeOptions;
        _dlgOptions.GetWindowRect(&rcCtls[ircOPTIONSDLG]);
        _dlgOptions.GetMinSize(&sizeOptions);
        rcCtls[ircOPTIONSDLG].bottom = rcCtls[ircOPTIONSDLG].top + sizeOptions.cy;
        for (i = 0; i < ARRAYSIZE(rcCtls); i++)
        {
            // MapWindowPoints is mirroring aware only if you pass two points        
            ::MapWindowRect(NULL, m_hWnd, &rcCtls[i]);
        }    

        //  Position caption elements
        _LayoutCaption(IDC_FSEARCH_CAPTION, IDC_FSEARCH_ICON, IDC_FSEARCH_DIV1, cx);

        //  Resize ctl widths
        for (i = 0; i < irc_count; i++)
            rcCtls[i].right = cx - metrics.CtlMarginX();

        //  Stretch the 'Named' combo:
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_FILESPEC), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircFILESPEC)), RECTHEIGHT(*(rcCtls + ircFILESPEC)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

        //  Stretch the 'Containing Text' combo:
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_GREPTEXT), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircGREPTEXT)), RECTHEIGHT(*(rcCtls + ircGREPTEXT)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

        //  Stretch the 'Look In' combo
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_NAMESPACE), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircNAMESPACE)), RECTHEIGHT(*(rcCtls + ircNAMESPACE)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        
        //  Arrange dynamically positioned controls.
        ptOrigin.y = rcCtls[ircSEARCHSTART].bottom + metrics.LooseMarginY();
        if (_fDisplayOptions)
        {
            OffsetRect(&rcCtls[ircOPTIONGRP], metrics.CtlMarginX() - rcCtls[ircOPTIONGRP].left, 
                                                ptOrigin.y - rcCtls[ircOPTIONGRP].top);
            rcCtls[ircOPTIONSDLG].right = cx - metrics.CtlMarginX();

            ::SetWindowPos(GetDlgItem(IDC_GROUPBTN_OPTIONS), NULL, 
                            rcCtls[ircOPTIONGRP].left, rcCtls[ircOPTIONGRP].top,
                            RECTWIDTH(rcCtls[ircOPTIONGRP]), RECTHEIGHT(rcCtls[ircOPTIONGRP]),
                            SWP_NOZORDER|SWP_NOACTIVATE);
            
            ::GetWindowRect(GetDlgItem(IDC_GROUPBTN_OPTIONS),    &rcCtls[ircOPTIONGRP]);
            ::MapWindowRect(NULL, m_hWnd, &rcCtls[ircOPTIONGRP]);
            
            ptOrigin.y = rcCtls[ircOPTIONGRP].bottom + metrics.TightMarginY();
        }
        else
        {
            //  Position the 'Options' link
            _LayoutLinkWindow(m_hWnd, metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                                ptOrigin.y, IDC_SEARCHLINK_OPTIONS);
        }

        ptOrigin.y += metrics.TightMarginY();

        //  Position the 'Search for Other Items' caption, divider and link windows
        const int rgLinkIDs[] = { 
            IDC_SEARCHLINK_FILES,
            IDC_SEARCHLINK_COMPUTERS,
            IDC_SEARCHLINK_PRINTERS,
            IDC_SEARCHLINK_PEOPLE,
            -IDC_FSEARCH_DIV3,
            IDC_SEARCHLINK_INTERNET, 
        };

        _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, !_fDisplayOptions,
                            metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                            ptOrigin.y, rgLinkIDs, ARRAYSIZE(rgLinkIDs));

        EndDeferWindowPos(hdwp);
    }

}


LRESULT CFindFilesDlg::OnUpdateLayout(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    LayoutControls();
    _pfsb->UpdateLayout((ULONG)wParam);
    return 0;
}


LRESULT CFindFilesDlg::OnTimer(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    if (UISTATETIMER == wParam && IsWindowVisible())
        UpdateSearchCmdStateUI();
    
    return 0;
}


LRESULT CFindFilesDlg::OnOptions(int idCtl, NMHDR *pnmh, BOOL&)
{
    _ShowOptions(!_fDisplayOptions);
    LoadSaveUIState(IDC_SEARCHLINK_OPTIONS, TRUE);

    if (_fDisplayOptions)
        _dlgOptions.TakeFocus();
    else
        ::SetFocus(GetDlgItem(IDC_SEARCHLINK_OPTIONS));

    return 0;
}


void CFindFilesDlg::_ShowOptions(BOOL bShow)
{
    _fDisplayOptions = bShow;

    //  don't need to scroll if we've expanded a subdialog,
    //  but we do if we've contracted one.
    ULONG dwLayoutFlags = BLF_ALL;
    if (_fDisplayOptions)
        dwLayoutFlags &= ~BLF_SCROLLWINDOW;    

    LayoutControls();
    _pfsb->UpdateLayout(dwLayoutFlags);

    ::ShowWindow(GetDlgItem(IDC_GROUPBTN_OPTIONS), _fDisplayOptions ? SW_SHOW : SW_HIDE);
    ::ShowWindow(GetDlgItem(IDC_SEARCHLINK_OPTIONS), !_fDisplayOptions ? SW_SHOW : SW_HIDE);

}


LRESULT CFindFilesDlg::OnQueryOptionsHeight(int idCtl, NMHDR *pnmh, BOOL&)
{
    GBNQUERYBUDDYSIZE* pqbs = (GBNQUERYBUDDYSIZE*)pnmh;
    pqbs->cy = _dlgOptions.QueryHeight(pqbs->cx, pqbs->cy);
    return TRUE;
}


void CFindFilesDlg::UpdateSearchCmdStateUI(DISPID eventID)
{
    if (_fOnDestroy)
        return;

    if (DISPID_SEARCHCOMMAND_COMPLETE == eventID 
    ||   DISPID_SEARCHCOMMAND_ABORT == eventID)
        _dwRunOnceWarningFlags = DFW_DEFAULT;

    CSearchCmdDlg::UpdateSearchCmdStateUI(eventID);
    _dlgOptions.UpdateSearchCmdStateUI(eventID);
}


BOOL CFindFilesDlg::OnSearchCmdError(HRESULT hr, LPCTSTR pszError)
{
    if (SCEE_SCOPEMISMATCH == HRESULT_CODE(hr) 
    ||  SCEE_INDEXNOTCOMPLETE == HRESULT_CODE(hr))
    {
        //  Set up checkbox
        BOOL fFlag = SCEE_SCOPEMISMATCH == HRESULT_CODE(hr)? DFW_IGNORE_CISCOPEMISMATCH :
                                                             DFW_IGNORE_INDEXNOTCOMPLETE ,
             fNoWarn = (_dwWarningFlags & fFlag) != 0,
             fNoWarnPrev = fNoWarn;
        USHORT uDlgT = SCEE_SCOPEMISMATCH == HRESULT_CODE(hr)? DLG_FSEARCH_SCOPEMISMATCH :
                                                               DLG_FSEARCH_INDEXNOTCOMPLETE ;
        int  nRet = CSearchWarningDlg_DoModal(m_hWnd, uDlgT, &fNoWarn);

        if (fNoWarn)
            _dwWarningFlags |= fFlag;
        else
            _dwWarningFlags &= ~fFlag;        
        
        if (fNoWarnPrev != fNoWarn)
            LoadSaveUIState(LSUIS_WARNING, TRUE);

        if (IDOK == nRet)
        {
            _dwRunOnceWarningFlags |= _dwWarningFlags | fFlag ; // preserve the old run once flags...
            //  hack one, hack two...  let's be USER!!! [scotthan]
            PostMessage(WM_COMMAND, MAKEWPARAM(IDC_SEARCH_START, BN_CLICKED),
                         (LPARAM)GetDlgItem(IDC_SEARCH_START));
        }
        else
            ::SetFocus(GetDlgItem(IDC_NAMESPACE));

        return TRUE;
    }
    return CSearchCmdDlg::OnSearchCmdError(hr, pszError);
}

LRESULT CFindFilesDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    switch (nID)
    {
    case IDC_SEARCH_START:
        if (_ShouldReconcileNamespace())
            _UIReconcileNamespace(TRUE);
        
        if (SUCCEEDED(StartSearch()))
        {
            EnableStartStopButton(hwndCtl, FALSE);
            StartStopAnimation(TRUE);
        }
        break;

    case IDC_SEARCH_STOP:
        StopSearch();
        break;
    }
    return 0;
}

void CFindFilesDlg::NavigateToResults(IWebBrowser2* pwb2)
{
    BSTR bstrUrl = SysAllocString(L"::{e17d4fc0-5564-11d1-83f2-00a0c90dc849}");// CLSID_DocFindFolder
    if (bstrUrl)
    {
        VARIANT varNil = {0};
        pwb2->Navigate(bstrUrl, &varNil, &varNil, &varNil, &varNil);
        SysFreeString(bstrUrl);
    }
}

LRESULT CFindFilesDlg::OnStateChange(UINT, WPARAM, LPARAM, BOOL&)
{
    UpdateSearchCmdStateUI();
    return 0;
}

LRESULT CFindFilesDlg::OnNamespaceSelEndOk(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    LRESULT iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if (iSel != CB_ERR)
    {
        IEnumIDList *penum = _GetItems(iSel);
        if (NULL == penum)
            _BrowseAndAssignNamespace();    // Was this the "Browse..." item 
        else
            _iCurNamespace = iSel;
    }

    _pfsb->SetDirty();
    return 0;
}

LRESULT CFindFilesDlg::OnNamespaceEditChange(WORD wID, WORD wCode, HWND hwndCtl, BOOL& bHandled)
{
    return OnEditChange(wID, wCode, hwndCtl, bHandled);
}

//  Handler for CBN_SELENDCANCEL, CBN_DROPDOWN, CBN_KILLFOCUS
LRESULT CFindFilesDlg::OnNamespaceReconcileCmd(WORD wID, WORD wCode, HWND hwndCtl, BOOL&)
{
    if (_ShouldReconcileNamespace())
        _UIReconcileNamespace(wCode != CBN_DROPDOWN);
    return 0;
}

//  Handler for WM_NOTIFY::CBEN_ENDEDIT
LRESULT CFindFilesDlg::OnNamespaceReconcileNotify(int idCtl, NMHDR *pnmh, BOOL& bHandled)
{
    if (_ShouldReconcileNamespace())
    {
        //  Post ourselves a message to reconcile the ad hoc namespace.
        //  Note: We need to do this because ComboBoxEx won't update his window text if he
        //  is waiting for his CBEN_ENDEDIT notification message to return.
        PostMessage(WMU_NAMESPACERECONCILE, 0, 0);
    }
    bHandled = FALSE; // let base class have a crack as well.
    return 0;
}


//  WMU_NAMESPACERECONCILE handler
LRESULT CFindFilesDlg::OnNamespaceReconcileMsg(UINT, WPARAM, LPARAM, BOOL&)
{
    if (_ShouldReconcileNamespace())
        _UIReconcileNamespace(FALSE);
    return 0;
}

//  WMU_BANDFINISHEDDISPLAYING handler
//  Note that we do not care about returning results from this, as it will
//  be started asynchronously.
LRESULT CFindFilesDlg::OnBandFinishedDisplaying(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Now that the search band has finished displaying, we will do the
    //  delayed initialization.  Make sure we don't do it twice.
    if (!_fBandFinishedDisplaying)
    {
        _fBandFinishedDisplaying = TRUE;
        _dlgOptions.DoDelayedInit();
    }
    return 0;
}


BOOL CFindFilesDlg::_ShouldReconcileNamespace()
{
    return _fNamespace || SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0) == CB_ERR;
}


//  Invokes lower Namespace reconciliation helper, updates some UI and 
//  instance state data. 
//  this was added as a late RC 'safe' delta, and should have actually
//  become part of _ReconcileNamespace() impl.
void CFindFilesDlg::_UIReconcileNamespace(BOOL bAsync)
{
    LRESULT iSel = _ReconcileNamespace(bAsync);
    if (iSel != CB_ERR)
        _iCurNamespace = iSel;

    _ShowNamespaceEditImage(TRUE);
    _fNamespace = FALSE; // clear the ad hoc flag.    
}

//  Scans namespace combo for a matching namespace; if found, selects
//  the namespace item, otherwise adds an adhoc item and selects it.
//  
//  Important: don't call this directly, call _UIReconcileNamespace()
//  instead to ensure that instance state data is updated.
INT_PTR CFindFilesDlg::_ReconcileNamespace(OPTIONAL BOOL bAsync)
{
    INT_PTR iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if ((CB_ERR != iSel) && (NULL == _GetItems(iSel)))
    {
        // The user has selected the special Browse... item. 
        // Irreconcilable.  Return CB_ERR
        return CB_ERR;
    }

    //  Don't know the namespace?  Use current window text.
    TCHAR szNamespace[MAX_URL_STRING];
    if (0 == GetDlgItemText(IDC_NAMESPACE, szNamespace, ARRAYSIZE(szNamespace)))
        return CB_ERR;

    INT_PTR iFind = _FindNamespace(szNamespace, NULL);

    // search display names
    if (CB_ERR == iFind)
    {
        // search paths
        TCHAR szTemp[MAX_URL_STRING];
        StrCpy(szTemp, szNamespace);
        _PathFixup(szNamespace, szTemp); // don't care if this fails, the path might be a path list

        iFind = _FindNamespace(szNamespace, NULL);
    }

    //  Not found in CB list? Add it if it's a valid path
    if (CB_ERR == iFind)
    {
        iSel = _AddNamespace(szNamespace, NULL, szNamespace, TRUE);
    }
    else
    {    
        // found in CB list? Select it.
        if (bAsync)
        {
            // this was needed in cases of reconcile following kill focus
            ::PostMessage(GetDlgItem(IDC_NAMESPACE), CB_SETCURSEL, iFind, 0); 
        }
        else
        {
            iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iFind, 0);
        }
    }

    return iSel;
}

BOOL CFindFilesDlg::_PathFixup(LPTSTR pszDst, LPCTSTR pszSrc)
{
    ASSERT(pszDst);
    ASSERT(pszSrc);
    TCHAR szSrc[MAX_PATH];
    TCHAR szFull[MAX_PATH];

    if (SHExpandEnvironmentStrings(pszSrc, szSrc, ARRAYSIZE(szSrc)) && *szSrc)
        pszSrc = szSrc;

    if (_IsPathList(pszSrc))
    {
        lstrcpy(pszDst, pszSrc);
        return TRUE;
    }

    szFull[0] = 0;
    BOOL bRelative     = PathIsRelative(pszSrc);
    BOOL bMissingDrive = bRelative ? FALSE : _IsFullPathMinusDriveLetter(pszSrc);
    // bMissingDrive =,e.g. "\foo", "\foo\bar", etc.  PathIsRelative() reports FALSE in this case.

    if (bRelative || bMissingDrive)
    {
        ASSERT(_pfsb && _pfsb->BandSite());

        LPITEMIDLIST pidl;
        HRESULT hr = _GetCurrentFolderIDList(_pfsb->BandSite(), &pidl);
        if (S_OK == hr) 
        {
            TCHAR szCurDir[MAX_PATH];   
            // file system path only here!
            if (SHGetPathFromIDList(pidl, szCurDir) && 
                StrCmpI(szCurDir, _szCurrentPath))
            {
                lstrcpy(_szCurrentPath, szCurDir);
            }

            if (*_szCurrentPath)
            {
                if (bRelative)
                {
                    if (PathCombine(szFull, _szCurrentPath, pszSrc))
                        pszSrc = szFull;
                }
                else if (bMissingDrive)
                {
                    int iDrive = PathGetDriveNumber(_szCurrentPath);
                    if (-1 != iDrive)
                    {
                        TCHAR szRoot[MAX_PATH];
                        if (PathCombine(szFull, PathBuildRoot(szRoot, iDrive), pszSrc))
                            pszSrc = szFull;
                    }
                }
            }
            ILFree(pidl);
        }
    }
    return PathCanonicalize(pszDst, pszSrc);
}

LRESULT CFindFilesDlg::OnNamespaceDeleteItem(int idCtrl, NMHDR *pnmh, BOOL& bHandled)
{
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnmh;
    if (pnmce->ceItem.lParam)
    {
        IEnumIDList *penum = (IEnumIDList *)pnmce->ceItem.lParam;
        penum->Release();
    }
    return 1;
}

DWORD CFindFilesDlg::NamespaceThreadProc(void* pv)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)pv;
    CFindFilesDlg* pThis = (CFindFilesDlg*)pState->pvParam;

    if (PopulateNamespaceCombo(pState->hwndCtl, AddNamespaceItemNotify, (LPARAM)pv) != E_ABORT)
    {
        ::PostMessage(::GetParent(pState->hwndCtl), WMU_COMBOPOPULATIONCOMPLETE, (WPARAM)pState->hwndCtl, 0);
    }

    pState->fComplete = TRUE;
    ATOMICRELEASE(pState->punkBand);
    return 0;
}

#define CBX_CSIDL_LOCALDRIVES          0x04FF   // arbitrarily out of range of other CSIDL_xxx values.

HRESULT CFindFilesDlg::AddNamespaceItemNotify(ULONG fAction, PCBXITEM pItem, LPARAM lParam)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)lParam;
    
    if (fAction & CBXCB_ADDING && pState->fCancel)
        return E_ABORT;

    //
    //  Sets the string in the CFindFilesDlg as the display name.
    //  This string is then used to set the default item in the 
    //  combo box.
    //
    if (fAction & CBXCB_ADDED && CBX_CSIDL_LOCALDRIVES == pItem->iID)
    {
        CFindFilesDlg* pffd = (CFindFilesDlg*)pState->pvParam;

        lstrcpyn(pffd->_szLocalDrives, pItem->szText, ARRAYSIZE(pffd->_szLocalDrives));
    }

    return S_OK;
}

LRESULT CFindFilesDlg::OnComboPopulationComplete(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    _bScoped = SetDefaultScope();
    return 0;
}

// bPassive TRUE -> assign only if no current selection

BOOL CFindFilesDlg::AssignNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bPassive)
{
    INT_PTR iSel = CB_ERR;
    
    //  If we don't yet have a current selection, establish it now.
    if (!bPassive || CB_ERR == (iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0)))
    {
        iSel = _FindNamespace(pszPath, pidl);

        // scan items by display name if we don't have pidl
        // otherwise choosing x:\my pictures (in browse) would end up selecting
        // my pictures folder and searching the wrong place
        if (CB_ERR == iSel && !pidl && !pszPath && pszName && *pszName)
            iSel = _FindNamespace(pszName, NULL);

        //  Is this a folder we already know about?
        if (CB_ERR == iSel)
        {
            if (pidl || pszPath)
                iSel = _AddNamespace(pszPath, pidl, pszName, TRUE);

            if (iSel != CB_ERR)
                _iCurNamespace = iSel;
        }
        else
        {
            // yes: select it
            SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iSel, 0);
            _iCurNamespace = iSel;
        }
    }

    return CB_ERR != SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
}

HWND CFindFilesDlg::ShowHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("find.chm"), HH_DISPLAY_TOPIC, 0);
}

// inserts something into the name space combo
INT_PTR CFindFilesDlg::_AddNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bSelectItem)
{
    IEnumIDList *penum = NULL;

    if (pszPath)
    {
        CreateIEnumIDListPaths(pszPath, &penum);
    }
    else if (pidl)
    {
        CreateIEnumIDListOnIDLists(&pidl, 1, &penum);
    }

    CBXITEM item;
    item.iItem = CB_ERR;    // failure result here
    if (penum)
    {
        LPITEMIDLIST pidlIcon;
        if (S_OK == FirstIDList(penum, &pidlIcon))
        {
            if (NULL == pszName)
                pszName = pszPath;

            MakeCbxItem(&item, pszName, penum, pidlIcon, LISTINSERT_LAST, 1);

            INT_PTR iSel = item.iItem;
            if (SUCCEEDED(AddCbxItemToComboBox(GetDlgItem(IDC_NAMESPACE), &item, &iSel)))
            {
                penum = NULL;   // don't release below

                item.iItem = iSel;
                if (bSelectItem)
                    SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iSel, 0);
            }
            else
            {
                item.iItem = CB_ERR;
            }
            ILFree(pidlIcon);
        }

        if (penum)
            penum->Release();   // not inserted, free this
    }

    return item.iItem;
}

LPARAM CFindFilesDlg::_GetComboData(UINT id, INT_PTR idx)
{
    if (CB_ERR == idx)
        idx = SendDlgItemMessage(id, CB_GETCURSEL, 0, 0);
    if (CB_ERR == idx)
        return idx;

    return (LPARAM)SendDlgItemMessage(id, CB_GETITEMDATA, idx, 0);
}

IEnumIDList *CFindFilesDlg::_GetItems(INT_PTR i)
{
    IEnumIDList *penum = (IEnumIDList *)_GetComboData(IDC_NAMESPACE, i);
    return (INVALID_HANDLE_VALUE != penum) ? penum : NULL;
}

BOOL MatchItem(IEnumIDList *penum, LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    BOOL bMatch = FALSE;

    // this is somewhat imprecise as we will match on the first IDList in the
    // enumerator. but generally that is the desired behavior for the special
    // items that include multiple implied items
    LPITEMIDLIST pidlFirst;
    if (S_OK == FirstIDList(penum, &pidlFirst))
    {
        bMatch = pidl && ILIsEqual(pidl, pidlFirst);

        if (!bMatch && pszPath)
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidlFirst, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
            {
                bMatch = (0 == StrCmpI(pszPath, szPath));
            }
        }
        ILFree(pidlFirst);
    }

    return bMatch;
}

// searches namespace comboboxex for the indicated item
// returns:
//      index of item, CB_ERR (-1) if not found

INT_PTR CFindFilesDlg::_FindNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    for (INT_PTR i = 0, cnt = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        IEnumIDList *penum = _GetItems(i);
        if (penum)
        {
            if (MatchItem(penum, pszPath, pidl))
                return i;
        }
    }
    // fall back to finding by display name in the combo
    if (pszPath)
        return SendDlgItemMessage(IDC_NAMESPACE, CB_FINDSTRINGEXACT, -1, (LPARAM)pszPath);
    return CB_ERR;
}

//  Invokes UI to select a namespace.
//
//  Returns:
//  S_OK if the user has selected a valid item and the pszNamespace contains
//  a valid shell folder display name.
//  E_ABORT if the user canceled his search
//  E_FAIL if an error occurred

HRESULT CFindFilesDlg::_BrowseForNamespace(LPTSTR pszName, UINT cchName, LPITEMIDLIST *ppidlRet)
{
    *pszName = 0;

    TCHAR szTitle[128];
    LoadString(HINST_THISDLL, IDS_SNS_BROWSERFORDIR_TITLE, szTitle, ARRAYSIZE(szTitle));

    BROWSEINFO bi = {0};

    bi.hwndOwner = m_hWnd;
    bi.lpszTitle = szTitle;
    bi.ulFlags   = BIF_USENEWUI | BIF_EDITBOX; // | BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
    bi.lpfn      = _BrowseCallback;
    bi.lParam    = (LPARAM)this;

    HRESULT hr;
    *ppidlRet = SHBrowseForFolder(&bi);
    if (*ppidlRet)
    {
        SHGetNameAndFlags(*ppidlRet, SHGDN_NORMAL, pszName, cchName, NULL);
        hr = S_OK;
    }
    else
    {
        hr = E_ABORT;
    }
    return hr;
}

//  Invokes SHBrowserForFolder UI and assigns results.
void CFindFilesDlg::_BrowseAndAssignNamespace()
{
    TCHAR szName[MAX_PATH];
    LPITEMIDLIST pidl;
    if (SUCCEEDED(_BrowseForNamespace(szName, ARRAYSIZE(szName), &pidl)))
    {
        AssignNamespace(NULL, pidl, szName, FALSE);
        ILFree(pidl);
    }
    else
    {
        SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, _iCurNamespace, 0);
    }
}

BOOL CFindFilesDlg::_IsSearchableFolder(LPCITEMIDLIST pidlFolder)
{
    return TRUE;
}

int CFindFilesDlg::_BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    CFindFilesDlg *pThis = (CFindFilesDlg *)lpData;
    switch (msg)
    {
    case BFFM_INITIALIZED:  // initializing: set default selection to drives if we can
        {
            LPITEMIDLIST pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_DRIVES, TRUE);
            if (pidlDefault)
            {
                if (!::SendMessage(hwnd, BFFM_SETSELECTION, FALSE, (LPARAM)pidlDefault)) // if we fail to default to drives, default to desktop
                {
                    ILFree(pidlDefault);
                    pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, TRUE);
                    ::SendMessage(hwnd, BFFM_SETSELECTION, FALSE, (LPARAM)pidlDefault);
                }
                ILFree(pidlDefault);
                
            }
        }
        break;

    case BFFM_SELCHANGED:   // prevent non-searchable folder pidls from being selected.
        {
            BOOL bAllow = pThis->_IsSearchableFolder((LPCITEMIDLIST)lParam);
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bAllow);
        }
        break;
    }

    return 0;
}


class CSearchWarningDlg
{
private:    
    CSearchWarningDlg() : _hwnd(NULL), _bNoWarn(FALSE) {}
    static BOOL_PTR WINAPI DlgProc(HWND, UINT, WPARAM, LPARAM);

    HWND    _hwnd;
    BOOL    _bNoWarn;

    friend int CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgT, BOOL* pbNoWarn);
};


int CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgTemplate, BOOL* pbNoWarn)
{
    ASSERT(pbNoWarn);

    CSearchWarningDlg dlg;
    dlg._bNoWarn = *pbNoWarn;
    int nRet = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(uDlgTemplate),
                                    hwndParent, CSearchWarningDlg::DlgProc, (LPARAM)&dlg);    
    *pbNoWarn = dlg._bNoWarn;
    return nRet;
}

BOOL_PTR WINAPI CSearchWarningDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSearchWarningDlg* pdlg = (CSearchWarningDlg*)GetWindowPtr(hwnd, GWLP_USERDATA);

    if (WM_INITDIALOG == uMsg)
    {
        pdlg = (CSearchWarningDlg*)lParam;
        pdlg->_hwnd = hwnd;
        SetWindowPtr(hwnd, GWLP_USERDATA, pdlg);

        CheckDlgButton(hwnd, IDC_NOSCOPEWARNING, pdlg->_bNoWarn);
        MessageBeep(MB_ICONASTERISK);
        return TRUE;
    }

    if (pdlg)
    {
        switch (uMsg)
        {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDOK:
            case IDCANCEL:
                pdlg->_bNoWarn = IsDlgButtonChecked(hwnd, IDC_NOSCOPEWARNING);
                EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                break;
            }
            return TRUE;
        }
    }
    return FALSE;
}


class CCISettingsDlg
{
public:
    CCISettingsDlg() : _hwnd(NULL), _fCiIndexed(FALSE), _fCiRunning(FALSE), _fCiPermission(FALSE), _hProcessMMC(INVALID_HANDLE_VALUE)
    {
    }

    ~CCISettingsDlg()   
    {
        if (_hProcessMMC != INVALID_HANDLE_VALUE)
            CloseHandle(_hProcessMMC);
    }

    static int  DoModal(HWND hwndParent);
    static HWND CreateModeless(HWND hwndParent);


protected:
    BOOL OnInitDialog();
    BOOL OnOK();

private:    
    static BOOL_PTR WINAPI DlgProc(HWND, UINT, WPARAM, LPARAM);

    void ShowAdvanced();

    HWND    _hwnd;
    BOOL    _fCiIndexed,
            _fCiRunning,
            _fCiPermission;
    HANDLE  _hProcessMMC;

    friend int  CCISettingsDlg_DoModal(HWND hwndParent);
};


int CCISettingsDlg_DoModal(HWND hwndParent)
{
    CCISettingsDlg dlg;
    return (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_INDEXSERVER),
                           hwndParent, CCISettingsDlg::DlgProc, (LPARAM)&dlg);    
}

BOOL_PTR WINAPI CCISettingsDlg::DlgProc(HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CCISettingsDlg* pdlg = (CCISettingsDlg*)GetWindowPtr(hDlg, GWLP_USERDATA);

    if (WM_INITDIALOG == nMsg)
    {
        pdlg = (CCISettingsDlg*)lParam;
        pdlg->_hwnd = hDlg;
        SetWindowPtr(hDlg, GWLP_USERDATA, pdlg);
        return pdlg->OnInitDialog();
    }

    if (pdlg)
    {
        switch (nMsg)
        {
        case WM_NCDESTROY:
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_CI_ADVANCED:
                pdlg->ShowAdvanced();
                break;

            case IDOK:
                if (pdlg->OnOK())
                    EndDialog(hDlg, IDOK);
                break;

            case IDCANCEL:
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                break;

            case IDC_CI_HELP:
                _IndexServiceHelp(hDlg);
                break;
            }
            return TRUE;
        }
    }
    return FALSE;
}

void CCISettingsDlg::ShowAdvanced()
{
    //  have we already spawned MMC?
    if (_hProcessMMC != INVALID_HANDLE_VALUE)
    {
        if (WaitForSingleObject(_hProcessMMC, 0) != WAIT_OBJECT_0)
        {
            //  MMC is still running, let user ATL+TAB or something but don't launch a second copy
            return;     
        }
        _hProcessMMC = INVALID_HANDLE_VALUE;
    }

    SHELLEXECUTEINFO sei = { sizeof(sei) };
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.nShow = SW_SHOWNORMAL;
    sei.lpFile = TEXT("ciadv.msc");
    sei.lpParameters = TEXT("computername=localmachine");

    if (ShellExecuteEx(&sei))
    {
        _hProcessMMC = sei.hProcess;
    }
}

BOOL CCISettingsDlg::OnInitDialog() 
{ 
    TCHAR szStatusFmt[128], szStatusText[MAX_PATH];
    UINT nStatusText = IDS_FSEARCH_CI_DISABLED;

    GetCIStatus(&_fCiRunning, &_fCiIndexed, &_fCiPermission);
    
    if (_fCiRunning)
    {
        if (_fCiPermission)
            //  permission to distinguish between ready, busy.
            nStatusText = _fCiIndexed ? IDS_FSEARCH_CI_READY : IDS_FSEARCH_CI_BUSY;
        else
            //  no permission to distinguish between ready, busy; just say it's enabled.
            nStatusText = IDS_FSEARCH_CI_ENABLED;
    }

    if (LoadString(HINST_THISDLL, IDS_FSEARCH_CI_STATUSFMT, szStatusFmt, ARRAYSIZE(szStatusFmt)))
    {
        if (LoadString(HINST_THISDLL, nStatusText, szStatusText, ARRAYSIZE(szStatusText)))
        {
            TCHAR szStatus[MAX_PATH];
            wnsprintf(szStatus, ARRAYSIZE(szStatus), szStatusFmt, szStatusText);
            SetDlgItemText(_hwnd, IDC_CI_STATUS, szStatus);
        }
    }

    CheckDlgButton(_hwnd, IDC_ENABLE_CI,   _fCiRunning);
    CheckDlgButton(_hwnd, IDC_BLOWOFF_CI, !_fCiRunning);

    EnableWindow(GetDlgItem(_hwnd, IDC_CI_PROMPT),  _fCiPermission);
    EnableWindow(GetDlgItem(_hwnd, IDC_ENABLE_CI),   _fCiPermission);
    EnableWindow(GetDlgItem(_hwnd, IDC_BLOWOFF_CI),  _fCiPermission);

    return TRUE; 
}

BOOL CCISettingsDlg::OnOK()
{
    StartStopCI(IsDlgButtonChecked(_hwnd, IDC_ENABLE_CI) ? TRUE : FALSE);
    return TRUE;
}

#ifdef __PSEARCH_BANDDLG__

//  CFindPrintersDlg impl

#define PSEARCHDLG_TABFIRST   IDC_PSEARCH_NAME
#define PSEARCHDLG_TABLAST    IDC_SEARCHLINK_INTERNET
#define PSEARCHDLG_RIGHTMOST   IDC_SEARCH_START
#define PSEARCHDLG_BOTTOMMOST  IDC_SEARCHLINK_INTERNET


CFindPrintersDlg::CFindPrintersDlg(CFileSearchBand* pfsb)
    :   CBandDlg(pfsb)
{
}

CFindPrintersDlg::~CFindPrintersDlg()
{

}

LRESULT CFindPrintersDlg::OnInitDialog(UINT, WPARAM, LPARAM, BOOL&)
{
    _Attach(m_hWnd);
    ASSERT(Hwnd());

    CMetrics&   metrics = _pfsb->GetMetrics();
    _pfsb->GetMetrics().Init(m_hWnd);

    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_PRINTERS);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_PSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    OnWinIniChange();
    LayoutControls(-1, -1);

    return TRUE;
}

void CFindPrintersDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }

    CBandDlg::LayoutControls(cx, cy);
    CMetrics& metrics = _pfsb->GetMetrics();

    const UINT nIDCtl[] = {
        IDC_PSEARCH_NAME,
        IDC_PSEARCH_LOCATION,
        IDC_PSEARCH_MODEL,
    };
    RECT rcCtl[ARRAYSIZE(nIDCtl)];
    
    //  Stretch edit boxes to fit horz
    for (int i = 0; i< ARRAYSIZE(nIDCtl); i++)
    {
        HWND hwndCtl = GetDlgItem(nIDCtl[i]);
        if (hwndCtl && ::GetWindowRect(hwndCtl, &rcCtl[i]))
        {
            ::MapWindowRect(NULL, Hwnd(), &rcCtl[i]);
            rcCtl[i].right = cx - metrics.CtlMarginX();
            ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                          RECTWIDTH(*(rcCtl+i)), RECTHEIGHT(*(rcCtl+i)),
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
        else
            SetRectEmpty(rcCtl + i);    
    }

    //  Position the 'Search for Other Items' caption, divider and link windows
    const int rgLinks[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        -IDC_FSEARCH_DIV3,
        IDC_SEARCHLINK_INTERNET,
    };

    RECT rc;
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.bottom += metrics.LooseMarginY();

    _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, TRUE,
                        metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                        rc.bottom, rgLinks, ARRAYSIZE(rgLinks));
}


BOOL CFindPrintersDlg::Validate()
{
    return TRUE;
}


void CFindPrintersDlg::Clear()
{
    SetDlgItemText(IDC_PSEARCH_NAME, NULL);
    SetDlgItemText(IDC_PSEARCH_LOCATION, NULL);
    SetDlgItemText(IDC_PSEARCH_MODEL, NULL);
}


BOOL CFindPrintersDlg::GetMinSize(HWND hwndOC, SIZE *pSize) const
{
    RECT rcRightmost, rcBottommost;
    HWND hwndRightmost = GetDlgItem(PSEARCHDLG_RIGHTMOST), 
         hwndBottommost= GetDlgItem(PSEARCHDLG_BOTTOMMOST);
    
    ASSERT(::IsWindow(hwndRightmost));
    ASSERT(::IsWindow(hwndBottommost));

    ::GetWindowRect(hwndRightmost, &rcRightmost);
    ::MapWindowRect(NULL, m_hWnd, &rcRightmost);

    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, m_hWnd, &rcBottommost);

    pSize->cx = rcRightmost.right;
    pSize->cy = rcBottommost.bottom + _pfsb->GetMetrics().TightMarginY();

    return TRUE;
}

HWND CFindPrintersDlg::GetFirstTabItem() const
{
    return GetDlgItem(PSEARCHDLG_TABFIRST);
}

HWND CFindPrintersDlg::GetLastTabItem() const
{
    return GetDlgItem(PSEARCHDLG_TABLAST);
}

STDMETHODIMP CFindPrintersDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CBandDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}

void CFindPrintersDlg::OnWinIniChange()
{
    _BeautifyCaption(IDC_PSEARCH_CAPTION, IDC_PSEARCH_ICON, IDI_PSEARCH);
}

LRESULT CFindPrintersDlg::OnSearchStartBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    WCHAR wszName[MAX_PATH],
          wszLocation[MAX_PATH],
          wszModel[MAX_PATH];

    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_NAME, wszName, ARRAYSIZE(wszName));
    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_LOCATION, wszLocation, ARRAYSIZE(wszLocation));
    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_MODEL, wszModel, ARRAYSIZE(wszModel));

    ASSERT(_pfsb);
    ASSERT(_pfsb->BandSite());

    IShellDispatch2* psd2;
    if (SUCCEEDED(CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                     IID_PPV_ARG(IShellDispatch2, &psd2))))
    {
        BSTR bstrName     = *wszName ? SysAllocString(wszName) : NULL,
             bstrLocation = *wszLocation ? SysAllocString(wszLocation) : NULL, 
             bstrModel    = *wszModel ? SysAllocString(wszModel) : NULL;

        if (FAILED(psd2->FindPrinter(bstrName, bstrLocation, bstrModel)))
        {
            SysFreeString(bstrName);
            SysFreeString(bstrLocation);
            SysFreeString(bstrModel);
        }
        
        psd2->Release();
    }
    
    return 0;
}
#endif __PSEARCH_BANDDLG__



//  CFindComputersDlg impl

#define CSEARCHDLG_TABFIRST   IDC_CSEARCH_NAME
#define CSEARCHDLG_TABLAST    IDC_SEARCHLINK_INTERNET
#define CSEARCHDLG_RIGHTMOST   IDC_SEARCH_STOP
#define CSEARCHDLG_BOTTOMMOST  IDC_SEARCHLINK_INTERNET


CFindComputersDlg::CFindComputersDlg(CFileSearchBand* pfsb)
    :   CSearchCmdDlg(pfsb),
        _pacComputerName(NULL),
        _pmruComputerName(NULL)
{

}


CFindComputersDlg::~CFindComputersDlg()
{
    ATOMICRELEASE(_pacComputerName);
    ATOMICRELEASE(_pmruComputerName);
}


LRESULT CFindComputersDlg::OnInitDialog(UINT, WPARAM, LPARAM, BOOL&)
{
    _Attach(m_hWnd);
    ASSERT(Hwnd());

    CMetrics&   metrics = _pfsb->GetMetrics();
    _pfsb->GetMetrics().Init(m_hWnd);

    //  Register specialty window classes.
    DivWindow_RegisterClass();

    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_COMPUTERS);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_CSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    _InitializeMru(GetDlgItem(IDC_CSEARCH_NAME), &_pacComputerName, 
                    TEXT("ComputerNameMRU"), &_pmruComputerName);
    SendDlgItemMessage(IDC_CSEARCH_NAME, EM_LIMITTEXT, MAX_PATH, 0);

    OnWinIniChange();
    LayoutControls(-1, -1);

    return TRUE;
}

LRESULT CFindComputersDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
{
    StopSearch();
    if (_pSrchCmd)
    {
        DisconnectEvents();
        IUnknown_SetSite(_pSrchCmd, NULL);
    }
    bHandled = FALSE;
    _fOnDestroy = TRUE;
    return 0;
}



void CFindComputersDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }
    CBandDlg::LayoutControls(cx, cy);

    const UINT nIDCtl[] = {
        IDC_CSEARCH_NAME,
    };
    RECT rcCtl[ARRAYSIZE(nIDCtl)];

    CMetrics& metrics = _pfsb->GetMetrics();
    for (int i = 0; i< ARRAYSIZE(nIDCtl); i++)
    {
        HWND hwndCtl = GetDlgItem(nIDCtl[i]);
        if (hwndCtl && ::GetWindowRect(hwndCtl, &rcCtl[i]))
        {
            ::MapWindowRect(NULL, m_hWnd, &rcCtl[i]);
            rcCtl[i].right = cx - metrics.CtlMarginX();
            ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                          RECTWIDTH(*(rcCtl+i)), RECTHEIGHT(*(rcCtl+i)),
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
        else
            SetRectEmpty(rcCtl + i);    
    }

    //  Position the 'Search for Other Items' caption, divider and link windows

    const int rgLinks[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        -IDC_FSEARCH_DIV3,
        IDC_SEARCHLINK_INTERNET,
    };

    RECT rc;
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.bottom += metrics.LooseMarginY();

    _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, TRUE,
                        metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                        rc.bottom, rgLinks, ARRAYSIZE(rgLinks));
}

BOOL CFindComputersDlg::Validate()
{
    return TRUE;
}

STDMETHODIMP CFindComputersDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    HRESULT hr = E_FAIL;
    TCHAR   szName[MAX_PATH];
    if (::GetDlgItemText(m_hWnd, IDC_CSEARCH_NAME, szName, MAX_PATH) <= 0)
    {
        lstrcpy(szName, TEXT("*"));
    }

    VARIANT var;
    hr = InitVariantFromStr(&var, szName);
    if (SUCCEEDED(hr))
    {
        hr = _AddConstraint(pSrchCmd, L"SearchFor", &var);
        if (SUCCEEDED(hr))
            _AddMruStringFromWindow(_pmruComputerName, GetDlgItem(IDC_CSEARCH_NAME));
        VariantClear(&var);
    }

    return hr;
}


void CFindComputersDlg::UpdateStatusText()
{
    CSearchCmdDlg::UpdateStatusText();
}


void CFindComputersDlg::RestoreSearch()
{
    CSearchCmdDlg::RestoreSearch();
}


void CFindComputersDlg::Clear()
{
    CSearchCmdDlg::Clear();
    SetDlgItemText(IDC_CSEARCH_NAME, NULL);
}


BOOL CFindComputersDlg::GetMinSize(HWND hwndOC, SIZE *pSize) const
{
    RECT rcRightmost, rcBottommost;
    HWND hwndRightmost = GetDlgItem(CSEARCHDLG_RIGHTMOST), 
         hwndBottommost= GetDlgItem(CSEARCHDLG_BOTTOMMOST);
    
    ASSERT(::IsWindow(hwndRightmost));
    ASSERT(::IsWindow(hwndBottommost));

    ::GetWindowRect(hwndRightmost, &rcRightmost);
    ::MapWindowRect(NULL, m_hWnd, &rcRightmost);

    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, m_hWnd, &rcBottommost);

    pSize->cx = rcRightmost.right;
    pSize->cy = rcBottommost.bottom + _pfsb->GetMetrics().TightMarginY();

    return TRUE;
}

void CFindComputersDlg::NavigateToResults(IWebBrowser2* pwb2)
{
    BSTR bstrUrl = SysAllocString(L"::{1f4de370-d627-11d1-ba4f-00a0c91eedba}");// CLSID_ComputerFindFolder
    if (bstrUrl)
    {
        VARIANT varNil = {0};
        pwb2->Navigate(bstrUrl, &varNil, &varNil, &varNil, &varNil);
        SysFreeString(bstrUrl);
    }
}

HWND CFindComputersDlg::GetFirstTabItem() const
{
    return GetDlgItem(CSEARCHDLG_TABFIRST);
}

HWND CFindComputersDlg::GetLastTabItem() const
{
    return GetDlgItem(CSEARCHDLG_TABLAST);
}

BOOL CFindComputersDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2)
{
    if (hwnd == GetDlgItem(IDC_CSEARCH_NAME))
    {
        *ppac2 = _pacComputerName;
        (*ppac2)->AddRef();
        return TRUE;
    }
    return CBandDlg::GetAutoCompleteObjectForWindow(hwnd, ppac2);
}

STDMETHODIMP CFindComputersDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CSearchCmdDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}


void CFindComputersDlg::OnWinIniChange()
{
    //  redisplay animated icon
    HWND hwndIcon = GetDlgItem(IDC_CSEARCH_ICON);
    Animate_Close(hwndIcon);
    Animate_OpenEx(hwndIcon, HINST_THISDLL, MAKEINTRESOURCE(IDA_FINDCOMP));

    _BeautifyCaption(IDC_CSEARCH_CAPTION);
}


LRESULT CFindComputersDlg::OnSearchStartBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    if (SUCCEEDED(StartSearch()))
    {
        EnableStartStopButton(hwndCtl, FALSE);
        StartStopAnimation(TRUE);
    }
    return 0;
}


LRESULT CFindComputersDlg::OnSearchStopBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    StopSearch();
    return 0;
}

HWND CFindComputersDlg::ShowHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("find.chm"), HH_DISPLAY_TOPIC, 0);
}

//  CSearchCmdDlg object wrap and event sink

CSearchCmdDlg::CSearchCmdDlg(CFileSearchBand* pfsb)
    :   CBandDlg(pfsb),
        _pSrchCmd(NULL), 
        _pcp(NULL), 
        _dwConnection(0)
{
    ASSERT(pfsb);
}

CSearchCmdDlg::~CSearchCmdDlg()
{ 
    DisconnectEvents(); 
    if (_pSrchCmd)
    {
        _pSrchCmd->Release();
        _pSrchCmd = NULL;
    }
}


ISearchCommandExt* CSearchCmdDlg::GetSearchCmd()
{
    if (_fOnDestroy)
        return NULL;
        
    ASSERT(_pfsb->BandSite() != NULL);

    //  Instantiate docfind command object
    if (NULL == _pSrchCmd)
    {
        ASSERT(0 == _dwConnection);

        if (SUCCEEDED(CoCreateInstance(CLSID_DocFindCommand, NULL, CLSCTX_INPROC_SERVER,
                                      IID_PPV_ARG(ISearchCommandExt, &_pSrchCmd))))
        {
            // Assign search type.
            _pSrchCmd->SearchFor(GetSearchType());

            // cmd object needs site to get to browser
            IUnknown_SetSite(_pSrchCmd, _pfsb->BandSite());

            // Connect events.
            ConnectToConnectionPoint(SAFECAST(this, DSearchCommandEvents*), DIID_DSearchCommandEvents,
                                      TRUE, _pSrchCmd, &_dwConnection, &_pcp);
        }
    }
    return _pSrchCmd;
}

HRESULT CSearchCmdDlg::DisconnectEvents()
{
    HRESULT hr = S_FALSE;
    if (_pcp)
    {
        _pcp->Unadvise(_dwConnection);
        _pcp->Release();
        _pcp = NULL;
        _dwConnection = 0;
        hr = S_OK;
    }
    return hr;
}

HRESULT CSearchCmdDlg::StartSearch()
{
    HRESULT hr = E_INVALIDARG;
    if (Validate())     //  Validate input
    {
        ISearchCommandExt* pSrchCmd = GetSearchCmd();
        if (pSrchCmd)
        {
            pSrchCmd->ClearResults();   //  Clear off current results
            hr = AddConstraints(pSrchCmd);
            if (SUCCEEDED(hr))
                hr = Execute(TRUE);
        }
    }
    return hr;
}

void CSearchCmdDlg::StartStopAnimation(BOOL bStart)
{
    HWND hwndAnimate = GetAnimation();
    if (IsWindow(hwndAnimate))
    {
        if (bStart)
            Animate_Play(hwndAnimate, 0, -1, -1);
        else
            Animate_Stop(hwndAnimate);
    }
}


//  WMU_RESTORESEARCH handler
LRESULT CSearchCmdDlg::OnRestoreSearch(UINT, WPARAM, LPARAM, BOOL&)
{
    //  We've posted ourselves this message in response to the event 
    //  dispatch because we want to do our restoration on the
    //  band's primary thread rather than the OLE dispatch thread.   
    //  To do the work on the dispatch thread results in a premature 
    //  abort of the search restoration processing as the dispatch
    //  thread terminates.
    RestoreSearch();
    return 0;
}


void CSearchCmdDlg::Clear()
{
    StopSearch();
    
    ISearchCommandExt *pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
        pSrchCmd->ClearResults();
}


HRESULT CSearchCmdDlg::Execute(BOOL bStart)
{
    ASSERT(_pSrchCmd);
    
    VARIANT varRecordsAffected = {0}, varParams = {0};
    return _pSrchCmd->Execute(&varRecordsAffected, &varParams, bStart ? 1 : 0);
}


void CSearchCmdDlg::StopSearch()
{
    if (SearchInProgress())
        Execute(FALSE);
}


HRESULT CSearchCmdDlg::SetQueryFile(IN VARIANT* pvarFile)
{
    HRESULT hr = CBandDlg::SetQueryFile(pvarFile);
    if (S_OK == hr)
    {
        ISearchCommandExt* pSrchCmd = GetSearchCmd();
        if (pSrchCmd)
            hr = pSrchCmd->RestoreSavedSearch(pvarFile);
        else
            hr = E_FAIL;
    }
    return hr;
}


void CSearchCmdDlg::UpdateSearchCmdStateUI(DISPID eventID)
{
    if (_fOnDestroy)
        return;
        
    BOOL bStopEvent = (DISPID_SEARCHCOMMAND_COMPLETE == eventID || 
                       DISPID_SEARCHCOMMAND_ERROR == eventID ||
                       DISPID_SEARCHCOMMAND_ABORT == eventID),
         bStartEvent = DISPID_SEARCHCOMMAND_START == eventID;
    
    HWND hwndStart = GetDlgItem(Hwnd(), IDC_SEARCH_START),
         hwndStop  = GetDlgItem(Hwnd(), IDC_SEARCH_STOP);

    if (IsWindow(hwndStart))
    {
        EnableStartStopButton(hwndStart, !SearchInProgress());
        if (bStopEvent && IsChild(Hwnd(), GetFocus()))
        {
            _pfsb->AutoActivate();
            SetFocus(hwndStart);
        }
    }

    if (IsWindow(hwndStop))
    {
        EnableStartStopButton(hwndStop, SearchInProgress());
        if (bStartEvent)
        {
            _pfsb->AutoActivate();
            SetFocus(hwndStop);
        }
    }

    if (bStopEvent || !SearchInProgress())
        StartStopAnimation(FALSE);
}


void CSearchCmdDlg::EnableStartStopButton(HWND hwndBtn, BOOL bEnable)
{
    if (IsWindow(hwndBtn))
    {
        if (bEnable)
            _ModifyWindowStyle(hwndBtn, BS_DEFPUSHBUTTON, 0);
        else
            _ModifyWindowStyle(hwndBtn, 0, BS_DEFPUSHBUTTON);

        ::EnableWindow(hwndBtn, bEnable);
    }
}


//  Extracts error information from ISearchCommandExt and 
//  propagate 
BOOL CSearchCmdDlg::ProcessCmdError()
{
    BOOL bRet = FALSE;
    
    ISearchCommandExt* pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
    {
        HRESULT hr = S_OK;
        BSTR bstrError = NULL;
        USES_CONVERSION;

        //  request error information through ISearchCommandExt
        if (SUCCEEDED(pSrchCmd->GetErrorInfo(&bstrError,  (int *)&hr)))
            //  allow derivatives classes a crack at handling the error
            bRet = OnSearchCmdError(hr, bstrError ? W2T(bstrError) : NULL);
    }
    return bRet;
}


BOOL CSearchCmdDlg::OnSearchCmdError(HRESULT hr, LPCTSTR pszError)
{
    if (pszError)
    {
        ShellMessageBox(HINST_THISDLL, _pfsb->m_hWnd, pszError, NULL,
                         MB_OK | MB_ICONASTERISK);
        return TRUE;
    }
    return FALSE;
}


void CSearchCmdDlg::UpdateStatusText()
{
    if (_fOnDestroy)
        return;
        
    ASSERT(_pfsb && _pfsb->BandSite());

    ISearchCommandExt* pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
    {
        BSTR bstrStatus;
        if (SUCCEEDED(pSrchCmd->get_ProgressText(&bstrStatus)))
        {
            IWebBrowserApp* pwba;
            if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_pfsb->BandSite(), IID_PPV_ARG(IWebBrowserApp, &pwba))))
            {
                pwba->put_StatusText(bstrStatus);
                pwba->Release();
            }
            if (bstrStatus)
                SysFreeString(bstrStatus);
        }
    }
}


void CSearchCmdDlg::OnBandShow(BOOL bShow) 
{ 
    if (!bShow) 
        StopSearch() ;
}


STDMETHODIMP CSearchCmdDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CBandDlg::TranslateAccelerator(pmsg))
        return S_OK;

    if (WM_KEYDOWN == pmsg->message &&
        VK_ESCAPE == pmsg->wParam && 
        SearchInProgress() &&
        0 == (GetKeyState(VK_CONTROL) & 0x8000))
    {
        StopSearch();
    }
    return S_FALSE;
}

STDMETHODIMP CSearchCmdDlg::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CSearchCmdDlg, IDispatch, DSearchCommandEvents),
        QITABENTMULTI2(CSearchCmdDlg, DIID_DSearchCommandEvents, DSearchCommandEvents),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearchCmdDlg::AddRef()
{
    return ((IFileSearchBand*)_pfsb)->AddRef(); 
}

STDMETHODIMP_(ULONG) CSearchCmdDlg::Release()
{
    return ((IFileSearchBand*)_pfsb)->Release(); 
}

// IDispatch
STDMETHODIMP CSearchCmdDlg::Invoke(DISPID dispid, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
{
    switch (dispid)
    {
    case DISPID_SEARCHCOMMAND_COMPLETE:
    case DISPID_SEARCHCOMMAND_ABORT:
    case DISPID_SEARCHCOMMAND_ERROR:
    case DISPID_SEARCHCOMMAND_START:
        _fSearchInProgress = (DISPID_SEARCHCOMMAND_START == dispid);
        _fSearchAborted =    (DISPID_SEARCHCOMMAND_ABORT == dispid);
        UpdateSearchCmdStateUI(dispid);
        if (DISPID_SEARCHCOMMAND_ERROR == dispid)
            ProcessCmdError();    
        break;

    case DISPID_SEARCHCOMMAND_PROGRESSTEXT:
        UpdateStatusText();
        break;

    case DISPID_SEARCHCOMMAND_RESTORE:
        PostMessage(Hwnd(), WMU_RESTORESEARCH, 0, 0); 
        //  See comments in the CSearchCmdDlg::OnRestoreSearch message handler.
        break;
    }
    return S_OK;
}

class CDivWindow
{
    //  All private members:
    CDivWindow();
    ~CDivWindow();
    
    static LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT     EraseBkgnd(HDC hdc);
    LRESULT     WindowPosChanging(WINDOWPOS* pwp);
    LRESULT     SetHeight(LONG cy);
    LRESULT     SetBkColor(COLORREF rgb);


    static ATOM _atom;     // window class atom
    HWND        _hwnd;
    LONG        _cy;       // enforced height.
    COLORREF    _rgbBkgnd; // background color
    HBRUSH      _hbrBkgnd; // background brush

    friend void WINAPI DivWindow_RegisterClass();
};

void DivWindow_RegisterClass()
{
    WNDCLASSEX wc = {0};
    
    wc.cbSize         = sizeof(wc);
    wc.style          = CS_GLOBALCLASS;
    wc.lpfnWndProc    = CDivWindow::WndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName  = DIVWINDOW_CLASS;

    RegisterClassEx(&wc);
}

inline CDivWindow::CDivWindow() : _hwnd(NULL), _cy(1), _hbrBkgnd(NULL), _rgbBkgnd(COLOR_BTNFACE)
{
}
        

inline CDivWindow::~CDivWindow()
{
    if (_hbrBkgnd)
        DeleteObject(_hbrBkgnd);
}


LRESULT CDivWindow::EraseBkgnd(HDC hdc)
{
    if (!_hbrBkgnd)
        return DefWindowProc(_hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);

    RECT rc;
    GetClientRect(_hwnd, &rc);
    FillRect(hdc, &rc, _hbrBkgnd);
    return TRUE;
}


LRESULT CDivWindow::WindowPosChanging(WINDOWPOS* pwp)
{
    //  enforce height
    if (0 == (pwp->flags & SWP_NOSIZE))
        pwp->cy = _cy;
    return 0;
}


LRESULT CDivWindow::SetHeight(LONG cy)
{
    _cy = cy;
    return TRUE;
}


LRESULT CDivWindow::SetBkColor(COLORREF rgb)
{
    if (rgb != _rgbBkgnd)
    {
        _rgbBkgnd = rgb;
        if (_hbrBkgnd)
            DeleteObject(_hbrBkgnd);
        _hbrBkgnd = CreateSolidBrush(_rgbBkgnd);
        InvalidateRect(_hwnd, NULL, TRUE);
    }
    return TRUE;
}


LRESULT WINAPI CDivWindow::WndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CDivWindow* pThis = (CDivWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (nMsg)
    {
        case WM_ERASEBKGND:
            return pThis->EraseBkgnd((HDC)wParam);

        case WM_WINDOWPOSCHANGING:
            return pThis->WindowPosChanging((WINDOWPOS*)lParam);

        case WM_GETDLGCODE:
            return DLGC_STATIC;

        case DWM_SETHEIGHT:
            return pThis->SetHeight((LONG)wParam);

        case DWM_SETBKCOLOR:
            return pThis->SetBkColor((COLORREF)wParam);

        case WM_NCCREATE:
            if (NULL == (pThis = new CDivWindow))
                return FALSE;
            pThis->_hwnd = hwnd;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            break;

        case WM_NCDESTROY:
        {
            LRESULT lRet = DefWindowProc(hwnd, nMsg, wParam, lParam);
            SetWindowPtr(hwnd, GWLP_USERDATA, 0);
            pThis->_hwnd = NULL;
            delete pThis;
            return lRet;
        }
    }
    return DefWindowProc(hwnd, nMsg, wParam, lParam);
}


// {C8F945CB-327A-4330-BB2F-C04122959488}
static const IID IID_IStringMru = 
    { 0xc8f945cb, 0x327a, 0x4330, { 0xbb, 0x2f, 0xc0, 0x41, 0x22, 0x95, 0x94, 0x88 } };


//  Creates and initializes a CStringMru instance
HRESULT CStringMru::CreateInstance(HKEY hKey, LPCTSTR szSubKey, LONG cMaxStrings, BOOL  bCaseSensitive, REFIID riid, void ** ppv)
{
    CStringMru* pmru = new CStringMru;
    if (NULL == pmru)
        return E_OUTOFMEMORY;

    pmru->_hKeyRoot = hKey;
    StrCpyN(pmru->_szSubKey, szSubKey, ARRAYSIZE(pmru->_szSubKey));
    if (cMaxStrings > 0)
        pmru->_cMax = cMaxStrings;
    pmru->_bCaseSensitive = bCaseSensitive;

    HRESULT hr = pmru->QueryInterface(riid, ppv);
    pmru->Release();

    return hr;
}

CStringMru::CStringMru() : _cRef(1), _hKeyRoot(NULL), _hKey(NULL), 
        _hdpaStrings(NULL), _cMax(25), _bCaseSensitive(TRUE), _iString(-1)
{
    *_szSubKey = 0;
}

CStringMru::~CStringMru()
{
    _Close();
    _Clear();
}

//  Opens string MRU store
HRESULT CStringMru::_Open()
{
    if (_hKey)
        return S_OK;

    DWORD dwDisposition;
    DWORD dwErr = RegCreateKeyEx(_hKeyRoot, _szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                  NULL, &_hKey, &dwDisposition);
    return HRESULT_FROM_WIN32(dwErr);
}


//  Deletes string MRU store
void CStringMru::_Delete()
{
    if (_hKey)
        _Close();

    SHDeleteKey(_hKeyRoot, _szSubKey);
}

//  Reads string MRU store into memory
HRESULT CStringMru::_Read(OUT OPTIONAL LONG* pcRead)
{
    HRESULT hr = E_FAIL;
    if (pcRead)
        *pcRead = 0;

    if (SUCCEEDED((hr = _Open())))
    {
        _Clear();     // throw away existing cached strings
        _hdpaStrings = DPA_Create(4);  // allocate dynarray
        if (NULL == _hdpaStrings)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //  step through string values in registry.
            for (int iString = 0; iString < _cMax; iString++)
            {
                TCHAR szVal[16];
                TCHAR szString[MAX_URL_STRING];
                ULONG dwType, cbString = sizeof(szString);

                wsprintf(szVal, TEXT("%03d"), iString);
                DWORD dwErr = RegQueryValueEx(_hKey, szVal, 0, &dwType, 
                                               (LPBYTE)szString, &cbString);

                if (dwErr == ERROR_SUCCESS && REG_SZ == dwType && *szString)
                {
                    LPOLESTR pwszAdd;
                    if (SUCCEEDED(SHStrDup(szString, &pwszAdd)))
                    {
                        if (DPA_AppendPtr(_hdpaStrings, pwszAdd) == -1)
                        {
                            CoTaskMemFree(pwszAdd);
                        }
                    }
                }
            }
        }

        _Close();
        
        if (pcRead && _hdpaStrings)
            *pcRead = DPA_GetPtrCount(_hdpaStrings);
    }

    return hr;
}


//  Writes string MRU store from memory
HRESULT CStringMru::_Write(OUT OPTIONAL LONG* pcWritten)
{
    HRESULT hr = E_FAIL;
    LONG   cWritten = 0;
    
    if (pcWritten)
        *pcWritten = cWritten;

    //  Delete store and re-create.
    _Delete();
    if (NULL == _hdpaStrings)
        return S_FALSE;
    if (FAILED((hr = _Open())))
        return hr;

    ASSERT(DPA_GetPtrCount(_hdpaStrings) <= _cMax);

    //  step through string values in registry.
    for (int iString = 0, cnt = DPA_GetPtrCount(_hdpaStrings); 
         iString < cnt; iString++)
    {
        TCHAR szVal[16];
        TCHAR szString[MAX_URL_STRING];

        wsprintf(szVal, TEXT("%03d"), iString);

        LPOLESTR pwszWrite = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, iString);
        SHUnicodeToTChar(pwszWrite, szString, ARRAYSIZE(szString));

        DWORD dwErr = RegSetValueEx(_hKey, szVal, 0, REG_SZ, 
                                     (LPBYTE)szString, sizeof(szString));

        if (ERROR_SUCCESS == dwErr)
            cWritten++;
    }

    _Close();

    if (pcWritten)
        *pcWritten = cWritten;

    return S_OK;
}


//  Closes string MRU store
void  CStringMru::_Close()
{
    if (_hKey)
    {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }
}

//  Adds a string to the store
STDMETHODIMP CStringMru::Add(LPCOLESTR pwszAdd)
{
    if (!(pwszAdd && *pwszAdd))
        return E_INVALIDARG;
    
    if (NULL == _hdpaStrings)
    {
        _hdpaStrings = DPA_Create(4);
        if (NULL == _hdpaStrings)
            return E_OUTOFMEMORY;
    }
        
    HRESULT hr = E_FAIL;
    LONG    iMatch = -1;

    for (LONG i = 0, cnt = DPA_GetPtrCount(_hdpaStrings); i < cnt; i++)
    {
        LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, i);
        if (pwsz)
        {
            int nCompare = _bCaseSensitive ? 
                    StrCmpW(pwszAdd, pwsz) : StrCmpIW(pwszAdd, pwsz);

            if (0 == nCompare)
            {
                iMatch = i;
                break;
            }       
        }
    }

    if (-1 == iMatch)
    {
        //  Create a copy and add it to the list.
        LPOLESTR pwszCopy;
        hr = SHStrDup(pwszAdd, &pwszCopy);
        if (SUCCEEDED(hr))
        {
            int iNew = DPA_InsertPtr(_hdpaStrings, 0, pwszCopy);
            if (iNew < 0)
            {
                CoTaskMemFree(pwszCopy);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = _Promote(iMatch);
    }

    if (S_OK == hr)
    {
        //  If we've grown too large, delete LRU string
        int cStrings = DPA_GetPtrCount(_hdpaStrings);
        while (cStrings > _cMax)
        {
            LPOLESTR pwsz = (LPOLESTR)DPA_DeletePtr(_hdpaStrings, cStrings - 1);
            CoTaskMemFree(pwsz);
            cStrings--;
        }
        hr = _Write();
    }

    return hr;
}


//  Promotes a string to MRU
HRESULT CStringMru::_Promote(LONG iString)
{
    if (0 == iString)
        return S_OK;

    LONG cnt = _hdpaStrings ? DPA_GetPtrCount(_hdpaStrings) : 0 ;
    
    if (iString >= cnt)
        return E_INVALIDARG;

    LPOLESTR pwsz = (LPOLESTR)DPA_DeletePtr(_hdpaStrings, iString);
    if (pwsz)
    {
        int iMru = DPA_InsertPtr(_hdpaStrings, 0, pwsz);

        if (iMru < 0)
        {
            CoTaskMemFree(pwsz);
            return E_OUTOFMEMORY;
        }
        else
        {
            ASSERT(0 == iMru);
            return S_OK;
        }
    }
    return E_FAIL;
}


//  Clears string MRU memory cache
void CStringMru::_Clear()
{
    if (_hdpaStrings)
    {
        for (int i = 0, cnt = DPA_GetPtrCount(_hdpaStrings); i < cnt; i++)
        {
            LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, i);
            CoTaskMemFree(pwsz);
        }
        DPA_Destroy(_hdpaStrings);
        _hdpaStrings = NULL;
    }
}

STDMETHODIMP_(ULONG) CStringMru::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CStringMru::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}

STDMETHODIMP CStringMru::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CStringMru, IEnumString),
        QITABENT(CStringMru, IStringMru),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// *** IEnumString ***
STDMETHODIMP CStringMru::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    ULONG cFetched = 0;

    if (pceltFetched)
        *pceltFetched = cFetched;

    if (NULL == _hdpaStrings)
    {
        HRESULT hr = _Read();
        if (FAILED(hr))
            return hr;
    }

    for (int cnt =  _hdpaStrings ? DPA_GetPtrCount(_hdpaStrings) : 0; 
         cFetched < celt && (_iString + 1) < cnt;)
    {
        _iString++;
        LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, _iString);
        if (pwsz)
        {
            if (SUCCEEDED(SHStrDup(pwsz, &rgelt[cFetched])))
            {
                cFetched++;
            }
        }
    }

    if (pceltFetched)
        *pceltFetched = cFetched;

    return cFetched == celt ? S_OK : S_FALSE ;
}

STDMETHODIMP CStringMru::Skip(ULONG celt)
{
    _iString += celt;
    if (_iString >= _cMax)
        _iString = _cMax - 1;
    return S_OK;
}

STDMETHODIMP CStringMru::Reset(void)
{
    _iString = -1;
    return S_OK;
}

//  Namespace selector combo methods

HRESULT _BuildDrivesList(UINT uiFilter, LPCTSTR pszEnd, LPTSTR pszString, DWORD cchSize)
{
    TCHAR szDriveList[MAX_PATH];    // Needs to be 'Z'-'A' (26) * 3 + 1 = 79.
    UINT nSlot = 0;
    UINT cchSeparator = lstrlen(TEXT(";"));
    UINT cchEnd = lstrlen(pszEnd);

    for (int i = 0; i < 26; i++)
    {
        TCHAR szDrive[4];
        UINT uiDriveType = GetDriveType(PathBuildRoot(szDrive, i));

        UINT driveNum, dwRest;
        if ((driveNum = PathGetDriveNumber(szDrive)) != -1) {
            dwRest = SHRestricted(REST_NODRIVES);
            if (dwRest & (1 << driveNum))
                continue;
        }

        if ((1 != uiDriveType) &&          // Make sure it exists.
            ((-1 == uiFilter) ||
            (uiFilter == uiDriveType)))
        {
            if (nSlot) // Do we need to add a separator before we add the next item?
            {
                StrCpy(szDriveList + nSlot, TEXT(";"));  // Size guaranteed to not be a problem.
                nSlot += cchSeparator;
            }

            szDriveList[nSlot++] = szDrive[0]; // terminate list.
            StrCpy(szDriveList + nSlot, pszEnd);  // Size guaranteed to not be a problem.
            nSlot += cchEnd;
        }
    }

    StrCpyN(pszString, szDriveList, cchSize);     // Put back into the final location.
    return S_OK;
}

HRESULT _MakeCSIDLCbxItem(UINT csidl, UINT csidl2, HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    LPCTSTR rgcsidl[2] = {MAKEINTRESOURCE(csidl), MAKEINTRESOURCE(csidl2)};

    // note, CreateIEnumIDListOnCSIDLs checks SFGAO_NONENUMERATED so it filters
    // out things we should not display

    IEnumIDList *penum;
    HRESULT hr = CreateIEnumIDListOnCSIDLs(NULL, rgcsidl, (-1 == csidl2 ? 1 : 2), &penum);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        if (S_OK == FirstIDList(penum, &pidl))
        {
            TCHAR szName[MAX_PATH];
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), NULL);
        
            CBXITEM item;
            item.iID = csidl;

            MakeCbxItem(&item, szName, penum, pidl, LISTINSERT_LAST, NO_ITEM_INDENT);

            hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
            if (SUCCEEDED(hr))
            {
                penum = NULL;
            }

            ILFree(pidl);
        }
        if (penum)
            penum->Release();
    }
    return hr;
}

BOOL AppendItemToItemsArray(LPITEMIDLIST pidl, LPITEMIDLIST rgItems[], UINT sizeItems, UINT *pcItems)
{
    BOOL bAdded = FALSE;
    if (*pcItems < sizeItems)
    {
        DWORD dwFlags = SFGAO_NONENUMERATED;
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_NORMAL, NULL, 0, &dwFlags)) &&
            !(dwFlags & SFGAO_NONENUMERATED))
        {
            rgItems[(*pcItems)++] = pidl;
            bAdded = TRUE;
            pidl = NULL;    // don't free below
        }
    }
    ILFree(pidl);   // will be NULL if added to array, ownership transfered
    return bAdded;
}

BOOL AppendToItemsArray(LPCTSTR psz, LPITEMIDLIST rgItems[], UINT sizeItems, UINT *pcItems)
{
    LPITEMIDLIST pidl;
    if (IS_INTRESOURCE(psz))
    {
        SHGetFolderLocation(NULL, LOWORD((UINT_PTR)psz), NULL, 0, &pidl);
    }
    else
    {
        SHParseDisplayName(psz, NULL, &pidl, 0, NULL);
    }

    BOOL bAdded = FALSE;
    if (pidl)
    {
        bAdded = AppendItemToItemsArray(pidl, rgItems, sizeItems, pcItems);
    }
    return bAdded;
}

//  Create an item to put into the "look in" combo box for 
//  Local Hard Drives.  Will search the following directories:
//    1. My Documents
//    2. The Desktop folder (not the root of all PIDLS)
//    3. My Pictures
//    4. My Music
//    5. Documents and Settings
//    6. The current directory
//    7. The recycle bin
//    8. All local drives.

#define MIR(x) MAKEINTRESOURCE(x)

HRESULT _MakeLocalHardDrivesCbxItem(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    LPITEMIDLIST rgItems[32] = {0};
    UINT cItems = 0;
    
    AppendToItemsArray(MIR(CSIDL_PERSONAL), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_COMMON_DOCUMENTS | CSIDL_FLAG_NO_ALIAS), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_COMMON_DESKTOPDIRECTORY), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYPICTURES), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYMUSIC), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYVIDEO), rgItems, ARRAYSIZE(rgItems), &cItems);

    TCHAR szPath[MAX_PATH];
    DWORD cchPath = ARRAYSIZE(szPath);
    if (GetProfilesDirectory(szPath, &cchPath))
    {
        AppendToItemsArray(szPath, rgItems, ARRAYSIZE(rgItems), &cItems);
    }
    
    AppendToItemsArray(MIR(CSIDL_BITBUCKET), rgItems, ARRAYSIZE(rgItems), &cItems);

    TCHAR szDrives[128];
    szDrives[0] = 0;
    LPITEMIDLIST pidlIcon = NULL;
    for (int i = 0; i < 26; i++)
    {
        TCHAR szDrive[4];
        if (DRIVE_FIXED == GetDriveType(PathBuildRoot(szDrive, i)))
        {
            if (AppendToItemsArray(szDrive, rgItems, ARRAYSIZE(rgItems), &cItems))
            {
                // grab the pidl of the first time to use for the icon
                if (pidlIcon == NULL)
                    SHParseDisplayName(szDrive, NULL, &pidlIcon, 0, NULL);

                if (szDrives[0])
                    StrCatBuff(szDrives, TEXT(";"), ARRAYSIZE(szDrives));
                szDrive[2] = 0; // remove the back slash
                StrCatBuff(szDrives, szDrive, ARRAYSIZE(szDrives));
            }
        }
    }

    IEnumIDList *penum;
    HRESULT hr = CreateIEnumIDListOnIDLists(rgItems, cItems, &penum);
    if (SUCCEEDED(hr))
    {
        TCHAR szFmt[64];
        LoadString(HINST_THISDLL, IDS_SNS_LOCALHARDDRIVES, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(szPath, ARRAYSIZE(szPath), szFmt, szDrives);

        CBXITEM item;
        MakeCbxItem(&item, szPath, penum, pidlIcon, LISTINSERT_LAST, ITEM_INDENT);

        item.iID = CBX_CSIDL_LOCALDRIVES;
        hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
        if (FAILED(hr))
            penum->Release();
    }

    ILFree(pidlIcon);
    return hr;
}

typedef struct
{
    HWND                hwndComboBox;
    ADDCBXITEMCALLBACK  pfn; 
    LPARAM              lParam;
} ENUMITEMPARAM;

HRESULT _PopulateDrivesCB(LPCITEMIDLIST pidl, void *pv) 
{ 
    ENUMITEMPARAM* peip = (ENUMITEMPARAM*)pv;

    ULONG ulAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED;
    TCHAR szName[MAX_PATH];       
    HRESULT hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), &ulAttrs);
    if (SUCCEEDED(hr))
    {
        if ((SFGAO_FOLDER | SFGAO_FILESYSTEM) == (ulAttrs & (SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED)))
        {
            IEnumIDList *penum;
            hr = CreateIEnumIDListOnIDLists(&pidl, 1, &penum);
            if (SUCCEEDED(hr))
            {
                CBXITEM item;
                MakeCbxItem(&item, szName, penum, pidl, LISTINSERT_LAST, ITEM_INDENT);

                item.iID = CSIDL_DRIVES;
                hr = AddCbxItemToComboBoxCallback(peip->hwndComboBox, &item, peip->pfn, peip->lParam);
                if (SUCCEEDED(hr))
                {
                    penum = NULL;
                }
                else
                {
                    penum->Release();
                }
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;    
}

STDAPI PopulateNamespaceCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    // CSIDL_DESKTOP - use just the file system locations, not the root of the whole
    // name space here to avoid searching everything
    HRESULT hr = _MakeCSIDLCbxItem(CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS, 
                                   CSIDL_COMMON_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_PERSONAL, -1, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_MYPICTURES, -1, hwndComboBoxEx, pfn, lParam);
    
    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_MYMUSIC, -1, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
    {
        //  My Computer and children

        //  If My Docs has been redirected to a remote share, we'll want to prepend its path
        //  to our My Computer path list; otherwise it'll be missed.
        UINT csidl2 = -1;
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, szPath)) &&
            PathIsNetworkPath(szPath))
        {
            csidl2 = CSIDL_PERSONAL;
        }

        hr = _MakeCSIDLCbxItem(CSIDL_DRIVES, csidl2, hwndComboBoxEx, pfn, lParam);
        if (SUCCEEDED(hr))
        {
            //  Local hard drives (Which has heuristics to search best places first...)
            hr = _MakeLocalHardDrivesCbxItem(hwndComboBoxEx, pfn, lParam);
            if (SUCCEEDED(hr))
            {
                ENUMITEMPARAM eip = {0};
                eip.hwndComboBox = hwndComboBoxEx;
                eip.pfn          = pfn;
                eip.lParam       = lParam;

                hr = EnumSpecialItemIDs(CSIDL_DRIVES, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, _PopulateDrivesCB, &eip);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // Browse...
        CBXITEM item;
        item.iID = -1;
        TCHAR szDisplayName[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_SNS_BROWSER_FOR_DIR, szDisplayName, ARRAYSIZE(szDisplayName));
        MakeCbxItem(&item, szDisplayName, NULL, NULL, LISTINSERT_LAST, NO_ITEM_NOICON_INDENT);

        hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\findfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include <regstr.h>
#include <varutil.h>
#include "ids.h"        
#include "findhlp.h"    
#include "pidl.h"       
#include "shitemid.h"   
#include "defview.h"    
#include "fstreex.h"
#include "views.h"
#include "cowsite.h"
#include "exdisp.h"
#include "shguidp.h"
#include "prop.h"           // COLUMN_INFO
#include <limits.h>
#include "stgutil.h"
#include "netview.h"
#include "basefvcb.h"
#include "findfilter.h"
#include "defvphst.h"
#include "perhist.h"
#include "adoint.h"
#include "dspsprt.h"
#include "defcm.h"
#include "enumidlist.h"
#include "contextmenu.h"

// findband.cpp
STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission);
STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine);

class CFindFolder;

class CFindLVRange : public ILVRange
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ILVRange
    STDMETHODIMP IncludeRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP ExcludeRange(LONG iBegin, LONG iEnd);    
    STDMETHODIMP InvertRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP InsertItem(LONG iItem);
    STDMETHODIMP RemoveItem(LONG iItem);

    STDMETHODIMP Clear();
    STDMETHODIMP IsSelected(LONG iItem);
    STDMETHODIMP IsEmpty();
    STDMETHODIMP NextSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP NextUnSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP CountIncluded(LONG *pcIncluded);

    // Helperfunctions...
    void SetOwner(CFindFolder *pff, DWORD dwMask)
    {
        // don't AddRef -- we're a member variable of the object punk points to
        _pff = pff;
        _dwMask = dwMask;
        _cIncluded = 0;
    }
    void IncrementIncludedCount() {_cIncluded++;}
    void DecrementIncludedCount() {_cIncluded--;}
protected:
    CFindFolder *_pff;
    DWORD _dwMask;  // The mask we use to know which "selection" bit we are tracking...
    LONG _cIncluded;  // count included... (selected)
};

class CFindFolder : public IFindFolder,
                    public IShellFolder2,
                    public IShellIcon,
                    public IShellIconOverlay,
                    public IPersistFolder2
{
public:
    CFindFolder(IFindFilter *pff);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
        
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(THIS_ HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        { return BindToObject(pidl, pbc, riid, ppv); }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid);

    // IFindFolder
    STDMETHODIMP GetFindFilter(IFindFilter **pfilter);
    STDMETHODIMP AddPidl(int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppItem);
    STDMETHODIMP GetItem(int iItem, FIND_ITEM **ppItem);
    STDMETHODIMP DeleteItem(int iItem);
    STDMETHODIMP GetItemCount(INT *pcItems);
    STDMETHODIMP ValidateItems(IUnknown *punkView, int iItemFirst, int cItems, BOOL bSearchComplete);
    STDMETHODIMP GetFolderListItemCount(INT *pcCount);
    STDMETHODIMP GetFolderListItem(int iItem, FIND_FOLDER_ITEM **ppItem);
    STDMETHODIMP GetFolder(int iFolder, REFIID riid, void **ppv);
    STDMETHODIMP_(UINT) GetFolderIndex(LPCITEMIDLIST pidl);
    STDMETHODIMP SetItemsChangedSinceSort();
    STDMETHODIMP ClearItemList();
    STDMETHODIMP ClearFolderList();
    STDMETHODIMP AddFolder(LPITEMIDLIST pidl, BOOL fCheckForDup, int * piFolder);
    STDMETHODIMP SetAsyncEnum(IFindEnum *pfenum);
    STDMETHODIMP GetAsyncEnum(IFindEnum **ppfenum);
    STDMETHODIMP CacheAllAsyncItems();
    STDMETHODIMP_(BOOL) AllAsyncItemsCached();
    STDMETHODIMP SetAsyncCount(DBCOUNTITEM cCount);
    STDMETHODIMP ClearSaveStateList();
    STDMETHODIMP GetStateFromSaveStateList(DWORD dwItemID, DWORD *pdwState);
    STDMETHODIMP MapToSearchIDList(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetParentsPIDL(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent);
    STDMETHODIMP SetControllerNotifyObject(IFindControllerNotify *pfcn);
    STDMETHODIMP GetControllerNotifyObject(IFindControllerNotify **ppfcn);
    STDMETHODIMP RememberSelectedItems();
    STDMETHODIMP SaveFolderList(IStream *pstm);
    STDMETHODIMP RestoreFolderList(IStream *pstm);
    STDMETHODIMP SaveItemList(IStream *pstm);
    STDMETHODIMP RestoreItemList(IStream *pstm, int *pcItems);
    STDMETHODIMP RestoreSearchFromSaveFile(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv);

    STDMETHODIMP_(BOOL) HandleUpdateDir(LPCITEMIDLIST pidl, BOOL fCheckSubDirs);
    STDMETHODIMP_(void) HandleRMDir(IShellFolderView *psfv, LPCITEMIDLIST pidl);
    STDMETHODIMP_(void) UpdateOrMaybeAddPidl(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld);
    STDMETHODIMP_(void) Save(IFindFilter* pfilter, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown * pObject);
    STDMETHODIMP OpenContainingFolder(IUnknown *punkSite);
    STDMETHODIMP AddDataToIDList(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl);

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);
  
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    friend class CFindFolderViewCB;
    friend class CFindLVRange;

    HRESULT Init();

private:
    ~CFindFolder();
    HRESULT _CompareFolderIndexes(int iFolder1, int iFolder2);
    void _AddFIND_ITEMToSaveStateList(FIND_ITEM *pesfi);
    LPITEMIDLIST _GetFullPidlForItem(LPCITEMIDLIST pidl);
    HRESULT _UpdateItemList();

    static int CALLBACK _SortForDataObj(void *p1, void *p2, LPARAM lparam);
    static ULONG _Rank(LPCITEMIDLIST pidl);
    static DWORD _ItemID(LPCITEMIDLIST pidl);
    static PCHIDDENDOCFINDDATA _HiddenData(LPCITEMIDLIST pidl);
    FIND_FOLDER_ITEM *_FolderListItem(int iFolder);
    FIND_FOLDER_ITEM *_FolderListItem(LPCITEMIDLIST pidl);
    static BOOL _MapColIndex(UINT *piColumn);
    HRESULT _PrepareHIDA(UINT cidl, LPCITEMIDLIST *apidl, HDPA *phdpa);

    HRESULT _GetDetailsFolder();
    HRESULT _QueryItemShellFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf);
    HRESULT _QueryItemInterface(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _Folder(FIND_FOLDER_ITEM *pffli, REFIID riid, void **ppv);
    HRESULT _FolderFromItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv);

    HRESULT _GetFolderName(LPCITEMIDLIST pidl, DWORD gdnFlags, LPTSTR psz, UINT cch);
    int _CompareByCachedSCID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareNames(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwFlags);
    HRESULT _GetItemDisplayName(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR wzName, UINT cch);
    HRESULT _GetFolderIDList(int iFolder, LPITEMIDLIST *ppidlParent);

    LONG _cRef;

    CFindLVRange _dflvrSel; // manage selection and cut range information...
    CFindLVRange _dflvrCut;

    HDPA                _hdpaItems;             // all of the items in the results
    HDPA                _hdpaPidf;              // folders that the items came from
    IFindFilter         *_pfilter;
    BOOL                _fItemsChangedSinceSort;// Has the list changed since the last sort?
    BOOL                _fAllAsyncItemsCached;  // Have we already cached all of the items?
    BOOL                _fSearchComplete; 
    BOOL                _fInRefresh;            // true if received prerefresh callback but postrefresh

    LPITEMIDLIST        _pidl;
    IFindEnum           *_pDFEnumAsync;         // we have an async one, will need to call back for PIDLS and the like
    DBCOUNTITEM         _cAsyncItems;           // Count of async items
    int                 _iGetIDList;            // index of the last IDlist we retrieved in callback.
    HDSA                _hdsaSaveStateForIDs;   // Async - Remember which items are selected when we sort
    int                 _cSaveStateSelected;    // Number of items in selection list which are selected
    IFindControllerNotify *_pfcn;           // Sometimes need to let the "Controller" object know about things
    CRITICAL_SECTION    _csSearch;          
    int                 _iCompareFolderCache1, _iCompareFolderCache2, _iCompareFolderCacheResult;
    IShellFolder2       *_psfDetails;

    SHCOLUMNID          _scidCached;            // Cached SCID for sorting the columns
    UINT                _uiColumnCached;         // The index to the cached column for _scidCached

#if DEBUG
    DWORD               _GUIThreadID;           // Items can only be added to _hdpaItems on the UI thread.
#endif
};

class CFindFolderViewCB : public CBaseShellFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT SetShellView(IShellView *psv);

    CFindFolderViewCB(CFindFolder* pff);

    //  IServiceProvider override
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // Web View Tasks
    static HRESULT _OnOpenContainingFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

private:
    ~CFindFolderViewCB();

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP);    
    HRESULT OnReArrange(DWORD pv, LPARAM lp);
    HRESULT OnGETWORKINGDIR(DWORD pv, UINT wP, LPTSTR lP);
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream**lP);
    HRESULT OnGETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST *ppidl);
    HRESULT OnGetItemIconIndex(DWORD pv, WPARAM iItem, int *piIcon);
    HRESULT OnSetItemIconOverlay(DWORD pv, WPARAM iItem, int dwOverlayState);
    HRESULT OnGetItemIconOverlay(DWORD pv, WPARAM iItem, int * pdwOverlayState);
    HRESULT OnSETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST pidl);
    HRESULT OnGetIndexForItemIDList(DWORD pv, int * piItem, LPITEMIDLIST pidl);
    HRESULT OnDeleteItem(DWORD pv, LPCITEMIDLIST pidl);
    HRESULT OnODFindItem(DWORD pv, int * piItem, NM_FINDITEM* pnmfi);
    HRESULT OnODCacheHint(DWORD pv, NMLVCACHEHINT* pnmlvc);
    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnGetEmptyText(DWORD pv, UINT cchTextMax, LPTSTR pszText);
    HRESULT OnSetEmptyText(DWORD pv, UINT res, LPCTSTR pszText);
    HRESULT OnHwndMain(DWORD pv, HWND hwndMain);
    HRESULT OnIsOwnerData(DWORD pv, DWORD *pdwFlags);
    HRESULT OnSetISFV(DWORD pv, IShellFolderView* pisfv);
    HRESULT OnWindowCreated(DWORD pv, HWND hwnd);
    HRESULT OnWindowDestroy(DWORD pv, HWND wP);
    HRESULT OnGetODRangeObject(DWORD pv, WPARAM wWhich, ILVRange **pplvr);
    HRESULT OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP);
    HRESULT OnGetIPersistHistory(DWORD pv, IPersistHistory **ppph);
    HRESULT OnRefresh(DWORD pv, BOOL fPreRefresh);
    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *shtd);
    HRESULT OnSortListData(DWORD pv, PFNLVCOMPARE pfnCompare, LPARAM lParamSort);
    HRESULT _ProfferService(BOOL bProffer);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme);

    CFindFolder*  _pff;
    UINT        _iColSort;         // Which column are we sorting by
    BOOL        _fIgnoreSelChange;      // Sort in process
    UINT        _iFocused;         // Which item has the focus?
    UINT        _cSelected;        // Count of items selected

    IProfferService* _pps;          // ProfferService site.
    DWORD _dwServiceCookie;         // ProfferService cookie.

    TCHAR _szEmptyText[128];        // empty results list text.

    friend class CFindLVRange;
};

// Class to save and restore find state on the travel log 
class CFindPersistHistory : public CDefViewPersistHistory
{
public:
    CFindPersistHistory();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);

protected:
    IFindFolder* _GetDocFindFolder();
};


// {a5df1ea0-5702-11d1-83fa-00a0c90dc849}
const IID IID_IFindFolder = {0xa5df1ea0, 0x5702, 0x11d1, {0x83, 0xfa, 0x00, 0xa0, 0xc9, 0x0d, 0xc8, 0x49}};

// {5B8DCBF0-B096-11d1-9217-00403393B8F0}
const IID IID_IFindControllerNotify = {0x5b8dcbf0, 0xb096, 0x11d1, {0x92, 0x17, 0x0, 0x40, 0x33, 0x93, 0xb8, 0xf0}};

// Listview doesn't support more than 100000000 items, so if our
// client returns more than that, just stop after that point.
//
// Instead of 100000000, we use the next lower 64K boundary.  This keeps
// us away from strange boundary cases (where a +1 might push us over the
// top), and it keeps the Alpha happy.
//
#define MAX_LISTVIEWITEMS  (100000000 & ~0xFFFF)
#define SANE_ITEMCOUNT(c)  ((int)min(c, MAX_LISTVIEWITEMS))

// Unicode descriptor:
//
// Structure written at the end of NT-generated find stream serves dual purpose.
// 1. Contains an NT-specific signature to identify stream as NT-generated.
//    Appears as "NTFF" (NT Find File) in ASCII dump of file.
// 2. Contains an offset to the unicode-formatted criteria section.
//
// The following diagram shows the find criteria/results stream format including
// the NT-specific unicode criteria and descriptor.
//
//          +-----------------------------------------+ --------------
//          |         DFHEADER structure              |   .        .
//          +-----------------------------------------+   .        .
//          |      DF Criteria records (ANSI)         | Win95      .
//          +-----------------------------------------+   .        .
//          |      DF Results (PIDL) [optional]       |   .        NT
//          +-----------------------------------------+ -------    .
//   +----->| DF Criteria records (Unicode) [NT only] |            .
//   |      +-----------------------------------------+            .
//   |      | Unicode Descriptor |                                 .
//   |      +--------------------+  ----------------------------------
//   |     /                      \
//   |    /                         \
//   |   +-----------------+---------+
//   +---| Offset (64-bit) |  "NTFF" |
//       +-----------------+---------+
//
//

const DWORD c_NTsignature = 0x4646544E; // "NTFF" in ASCII file dump.

typedef struct
{
   ULARGE_INTEGER oUnicodeCriteria;  // Offset of unicode find criteria.
   DWORD NTsignature;               // Signature of NT-generated find file.
} DFC_UNICODE_DESC;


enum
{
    IDFCOL_NAME = 0,    // default col from guy we are delegating to
    IDFCOL_PATH,
    IDFCOL_RANK,
};

const COLUMN_INFO c_find_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,            30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_DIRECTORY,       30, IDS_PATH_COL),
    DEFINE_COL_STR_MENU_ENTRY(SCID_RANK,       10, IDS_RANK_COL),
};

class CFindMenuBase : public IContextMenuCB , public CObjectWithSite
{
public:
    CFindMenuBase();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

protected:
    virtual ~CFindMenuBase();

private:
    LONG _cRef;
};

CFindMenuBase::CFindMenuBase() : _cRef(1)
{
}

CFindMenuBase::~CFindMenuBase()
{
}

STDMETHODIMP CFindMenuBase::QueryInterface(REFIID riid, void **ppv) 
{        
    static const QITAB qit[] = {
        QITABENT(CFindMenuBase, IContextMenuCB),           // IID_IContextMenuCB
        QITABENT(CFindMenuBase, IObjectWithSite),          // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFindMenuBase::AddRef() 
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFindMenuBase::Release() 
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


class CFindMenuCB : public CFindMenuBase
{
public:
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

STDMETHODIMP CFindMenuCB::CallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            if (!pdtobj)
            {
                UINT idStart = pqcm->idCmdFirst;
                UINT idBGMain = 0, idBGPopup = 0;
                IFindFolder *pff;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff)))) 
                {
                    IFindFilter *pfilter;
                    if (SUCCEEDED(pff->GetFindFilter(&pfilter))) 
                    {
                        pfilter->GetFolderMergeMenuIndex(&idBGMain, &idBGPopup);
                        CDefFolderMenu_MergeMenu(HINST_THISDLL, idBGMain, idBGPopup, pqcm);

                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_EDIT_PASTE, MF_BYCOMMAND);
                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_EDIT_PASTELINK, MF_BYCOMMAND);
                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_MISC_REFRESH, MF_BYCOMMAND);

                        IFindControllerNotify *pdcn;
                        if (S_OK == pff->GetControllerNotifyObject(&pdcn))
                        {
                            pdcn->Release();
                        }
                        else
                        {
                            DeleteMenu(pqcm->hmenu, idStart+FSIDM_SAVESEARCH, MF_BYCOMMAND);
                        }
                        
                        pfilter->Release();
                    }
                    pff->Release();
                }
            }
        }
        break;

    case DFM_INVOKECOMMAND:
        {    
            // Check if this is from item context menu
            if (pdtobj)
            {
                switch(wParam)
                {
                case DFM_CMD_LINK:
                    hr = SHCreateLinks(hwnd, NULL, pdtobj, SHCL_USETEMPLATE | SHCL_USEDESKTOP | SHCL_CONFIRM, NULL);
                    break;
    
                case DFM_CMD_DELETE:
                    // convert to DFM_INVOKCOMMANDEX to get flags bits
                    hr = DeleteFilesInDataObject(hwnd, 0, pdtobj, 0);
                    break;

                case DFM_CMD_PROPERTIES:
                    // We need to pass an empty IDlist to combine with.
                    hr = SHLaunchPropSheet(CFSFolder_PropertiesThread, pdtobj,
                                      (LPCTSTR)lParam, NULL,  (void *)&c_idlDesktop);
                    break;

                default:
                    // Note: Fixing the working of Translator Key is not worth fixing. Hence Punted.
                    // if GetAttributesOf did not specify the SFGAO_ bit
                    // that corresponds to this default DFM_CMD, then we should
                    // fail it here instead of returning S_FALSE. Otherwise,
                    // accelerator keys (cut/copy/paste/etc) will get here, and
                    // defcm tries to do the command with mixed results.
                    // if GetAttributesOf did not specify SFGAO_CANLINK
                    // or SFGAO_CANDELETE or SFGAO_HASPROPERTIES, then the above
                    // implementations of these DFM_CMD commands are wrong...
                    // Let the defaults happen for this object
                    hr = S_FALSE;
                    break;
                }
            }
            else
            {
                switch (wParam)
                {
                case FSIDM_SAVESEARCH:
                    {
                        IFindFolder *pff;
                        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff))))
                        {
                            IFindControllerNotify *pdcn;
                            if (S_OK == pff->GetControllerNotifyObject(&pdcn))
                            {
                                pdcn->SaveSearch();
                                pdcn->Release();
                            }
                            pff->Release();
                        }
                    }
                    break;

                default:
                    hr = S_FALSE; // one of view menu items, use the default code.
                    break;
                }
            }
        }
        break;

    case DFM_GETHELPTEXT:  // ansi version
    case DFM_GETHELPTEXTW:
        {
            UINT id = LOWORD(wParam) + IDS_MH_FSIDM_FIRST;

            if (uMsg == DFM_GETHELPTEXTW)
                LoadStringW(HINST_THISDLL, id, (LPWSTR)lParam, HIWORD(wParam));
            else
                LoadStringA(HINST_THISDLL, id, (LPSTR)lParam, HIWORD(wParam));
        }
        break;
        
    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}


class CFindFolderContextMenuItemCB : public CFindMenuBase
{
public:
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    CFindFolderContextMenuItemCB(IFindFolder* pff);
    ~CFindFolderContextMenuItemCB();
    friend HRESULT CFindItem_Create(HWND hwnd, IFindFolder *pff, IContextMenu **ppcm);

    STDMETHODIMP _GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode);

    IFindFolder *_pff;
};

CFindFolderContextMenuItemCB::CFindFolderContextMenuItemCB(IFindFolder* pff) : _pff(pff)
{
    _pff->AddRef();
}

CFindFolderContextMenuItemCB::~CFindFolderContextMenuItemCB()
{
    _pff->Release();
}

STDMETHODIMP CFindFolderContextMenuItemCB::_GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    HRESULT hr;
    if (idCmd == FSIDM_OPENCONTAININGFOLDER)
    {
        if (bUnicode)
            StrCpyNW((LPWSTR)pszName, L"OpenContainingFolder", cchMax);
        else
            StrCpyNA((LPSTR)pszName, "OpenContainingFolder", cchMax);
        hr = S_OK;
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

STDMETHODIMP CFindFolderContextMenuItemCB::CallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DOCFIND_ITEM_MERGE, 0, pqcm);
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_OPENCONTAININGFOLDER:
            _pff->OpenContainingFolder(_punkSite);
            break;
        default:
            hr = E_FAIL; // not our command
            break;
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        // probably need to implement these...
        
    case DFM_GETVERBA:
    case DFM_GETVERBW:
        hr = _GetVerb((UINT_PTR)(LOWORD(wParam)), (LPSTR)lParam, (UINT)(HIWORD(wParam)), uMsg == DFM_GETVERBW);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    
    return hr;
}

STDAPI CFindItem_Create(HWND hwnd, IFindFolder* pff, IContextMenu **ppcm)
{
    *ppcm = NULL;

    HRESULT hr;
    // We want a quick IContextMenu implementation -- an empty defcm looks easiest
    IContextMenuCB* pcmcb = new CFindFolderContextMenuItemCB(pff);
    if (pcmcb)
    {
        hr = CDefFolderMenu_CreateEx(NULL, hwnd, 0, NULL, NULL, pcmcb, NULL, NULL, ppcm);
        pcmcb->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

void cdecl DocFind_SetStatusText(HWND hwndStatus, int iField, UINT ids,...)
{
    TCHAR sz2[MAX_PATH+32];   // leave slop for message + max path name
    va_list ArgList;

    if (hwndStatus)
    {
        va_start(ArgList, ids);
        LPTSTR psz = _ConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(ids), &ArgList);
        if (psz)
        {
            StrCpyN(sz2, psz, ARRAYSIZE(sz2));
            LocalFree(psz);
        }
        else
        {
            sz2[0] = 0;
        }
        va_end(ArgList);

        if (iField < 0)
        {
            SendMessage(hwndStatus, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM)(LPTSTR)sz2);
        }
        else
        {
            SendMessage(hwndStatus, SB_SETTEXT, iField, (LPARAM)(LPTSTR)sz2);
        }
            

        UpdateWindow(hwndStatus);
    }
}

HRESULT CFindFolder::AddFolder(LPITEMIDLIST pidl, BOOL fCheckForDup, int *piFolder)
{
    *piFolder = -1;

    if (fCheckForDup)
    {
        EnterCriticalSection(&_csSearch);
        for (int i = DPA_GetPtrCount(_hdpaPidf) - 1; i >= 0; i--)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli && ILIsEqual(&pffli->idl, pidl))
            {
                LeaveCriticalSection(&_csSearch);
                *piFolder = i;
                return S_OK;
            }
        }
        LeaveCriticalSection(&_csSearch);
    }

    int cb = ILGetSize(pidl);
    FIND_FOLDER_ITEM *pffli;;
    HRESULT hr = SHLocalAlloc(sizeof(*pffli) - sizeof(pffli->idl) + cb, &pffli);
    if (SUCCEEDED(hr))
    {
        // pddfli->psf = NULL;
        // pffli->fUpdateDir = FALSE;
        memcpy(&pffli->idl, pidl, cb);

        EnterCriticalSection(&_csSearch);
        // Now add this item to our DPA...
        *piFolder = DPA_AppendPtr(_hdpaPidf, pffli);
        LeaveCriticalSection(&_csSearch);
    
        if (-1 != *piFolder)
        {
            // If this is a network ID list then register a path -> pidl mapping, therefore
            // avoiding having to create simple ID lists, which don't work correctly when
            // being compared against real ID lists.

            if (IsIDListInNameSpace(pidl, &CLSID_NetworkPlaces))
            {
                TCHAR szPath[ MAX_PATH ];
                SHGetPathFromIDList(pidl, szPath);
                NPTRegisterNameToPidlTranslation(szPath, _ILNext(pidl));  // skip the My Net Places entry
            }
        }
        else
        {
            LocalFree((HLOCAL)pffli);
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

typedef struct
{
    DWORD       dwState;    // State of the item;
    DWORD       dwItemID;   // Only used for Async support...
} FIND_ITEM_SAVE_STATE;


void CFindFolder::_AddFIND_ITEMToSaveStateList(FIND_ITEM *pesfi)
{
    FIND_ITEM_SAVE_STATE essi;
    essi.dwState = pesfi->dwState & CDFITEM_STATE_MASK;
    essi.dwItemID = _ItemID(&pesfi->idl);

    DSA_AppendItem(_hdsaSaveStateForIDs, (void *)&essi);
    if (essi.dwState & LVIS_SELECTED)
        _cSaveStateSelected++;
}


HRESULT CFindFolder::RememberSelectedItems()
{
    EnterCriticalSection(&_csSearch);
    // Currently has list of pidls...
    for (int i = DPA_GetPtrCount(_hdpaItems); i-- > 0;)
    {
        // Pidl at start of structure...
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_hdpaItems, i);
        if (pesfi)
        {
            if (pesfi->dwState & (LVIS_SELECTED|LVIS_FOCUSED))
                _AddFIND_ITEMToSaveStateList(pesfi);
        }
    }
    LeaveCriticalSection(&_csSearch);
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearItemList()
{
    // Clear out any async enumerators we may have
    SetAsyncEnum(NULL);
    _cAsyncItems = 0;       // clear out our count of items...
    _pfilter->ReleaseQuery();

    // Also tell the filter to release everything...
    EnterCriticalSection(&_csSearch);
    if (_hdpaItems)
    {
        // Currently has list of pidls...
        for (int i = DPA_GetPtrCount(_hdpaItems) - 1; i >= 0; i--)
        {
            // Pidl at start of structure...
            FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_hdpaItems, i);
            if (pesfi)
                LocalFree((HLOCAL)pesfi);
        }

        _fSearchComplete = FALSE;
        DPA_DeleteAllPtrs(_hdpaItems);
    }
    LeaveCriticalSection(&_csSearch);
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearFolderList()
{
    EnterCriticalSection(&_csSearch);
    if (_hdpaPidf)
    {
        for (int i = DPA_GetPtrCount(_hdpaPidf) - 1; i >= 0; i--)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli)
            {
                // Release the IShellFolder if we have one
                if (pffli->psf)
                    pffli->psf->Release();

                // And delete the item
                LocalFree((HLOCAL)pffli);
            }
        }
        DPA_DeleteAllPtrs(_hdpaPidf);
    }
    LeaveCriticalSection(&_csSearch);
    
    return S_OK;
}

CFindFolder::CFindFolder(IFindFilter *pff) : _cRef(1), _iGetIDList(-1), _pfilter(pff), _iCompareFolderCache1(-1), _uiColumnCached(-1)
{
    ASSERT(_pidl == NULL);

    _pfilter->AddRef();

    // initialize our LV selection objects...
    _dflvrSel.SetOwner(this, LVIS_SELECTED);
    _dflvrCut.SetOwner(this, LVIS_CUT);

    InitializeCriticalSection(&_csSearch);

#if DEBUG
    _GUIThreadID = GetCurrentThreadId();
#endif
}

CFindFolder::~CFindFolder()
{
    ASSERT(_cRef==0);
    
    // We will need to call our function to Free our items in our
    // Folder list.  We will use the same function that we use to
    // clear it when we do a new search

    ClearItemList();
    ClearFolderList();
    ClearSaveStateList();

    EnterCriticalSection(&_csSearch);
    DPA_Destroy(_hdpaPidf);
    DPA_Destroy(_hdpaItems);
    _hdpaPidf = NULL;
    _hdpaItems = NULL;
    LeaveCriticalSection(&_csSearch);
    DSA_Destroy(_hdsaSaveStateForIDs);

    _pfilter->Release();

    if (_psfDetails)
        _psfDetails->Release();

    DeleteCriticalSection(&_csSearch);
}

HRESULT CFindFolder::Init()
{
    // Create the heap for the folder lists.
    _hdpaPidf = DPA_CreateEx(64, GetProcessHeap());

    // Create the DPA and DSA for the item list.
    _hdpaItems = DPA_CreateEx(64, GetProcessHeap());
    _hdsaSaveStateForIDs = DSA_Create(sizeof(FIND_ITEM_SAVE_STATE), 16);

    return _hdsaSaveStateForIDs && _hdpaItems && _hdpaPidf ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindFolder::AddDataToIDList(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    LPITEMIDLIST pidlToFree;
    if (pidlFolder)
    {
        pidlToFree = NULL;
        hr = S_OK;
    }
    else
    {
         hr = _GetFolderIDList(iFolder, &pidlToFree);
         pidlFolder = pidlToFree;
    }

    if (SUCCEEDED(hr))
    {
        HIDDENDOCFINDDATA *phfd;
        int cb = ILGetSize(pidlFolder);
        int cbTotal = sizeof(*phfd) - sizeof(phfd->idlParent) + cb;
        hr = SHLocalAlloc(cbTotal, &phfd);
        if (SUCCEEDED(hr))
        {
            phfd->hid.cb = (WORD)cbTotal;
            phfd->hid.wVersion = 0;
            phfd->hid.id = IDLHID_DOCFINDDATA;
            phfd->iFolder = (WORD)iFolder;      // index to the folder DPA
            phfd->wFlags  = (WORD)uFlags;
            phfd->uRow = uRow;                  // Which row in the CI;
            phfd->dwItemID = dwItemID;          // Only used for Async support...
            phfd->ulRank = ulRank;              // The rank returned by CI...
            memcpy(&phfd->idlParent, pidlFolder, cb);
    
            hr = ILCloneWithHiddenID(pidl, &phfd->hid, ppidl);
            LocalFree(phfd);
        }
        ILFree(pidlToFree);
    }
    return hr;
}

HRESULT CreateFindWithFilter(IFindFilter *pff, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_OUTOFMEMORY;

    CFindFolder *pfindfldr = new CFindFolder(pff);
    if (pfindfldr)
    {
        hr = pfindfldr->Init();
        if (SUCCEEDED(hr))
            hr = pfindfldr->QueryInterface(riid, ppv);
        pfindfldr->Release();
    }

    return hr;
}

STDAPI CDocFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IFindFilter *pff;
    HRESULT hr = CreateNameSpaceFindFilter(&pff);
    if (SUCCEEDED(hr))
    {
        hr = CreateFindWithFilter(pff, riid, ppv);
        pff->Release();
    }

    return hr;    
}

STDAPI CComputerFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IFindFilter *pff;
    HRESULT hr = CreateDefaultComputerFindFilter(&pff);
    if (pff)
    {
        hr = CreateFindWithFilter(pff, riid, ppv);
        pff->Release();
    }
    return hr;    
}

HRESULT CFindFolder::MapToSearchIDList(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    
    LPITEMIDLIST pidlParent;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SplitIDList(pidl, &pidlParent, &pidlChild)))
    {
        EnterCriticalSection(&_csSearch);

        // loop through our DPA list and see if we can find a matach
        for (int i = 0; i < DPA_GetPtrCount(_hdpaPidf); i++)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli && ILIsEqual(pidlParent, &pffli->idl))
            {
                // We found the right one
                // so no lets transform the ID into one of our own
                // to return.  Note: we must catch the case where the
                // original one passed in was a simple pidl and do
                // the appropriate thing.
                //
                LPITEMIDLIST pidlToFree = NULL; // might need to cleanup in one case

                // If this is not a FS folder, just clone it.
                IShellFolder *psf;
                if (fMapToReal && SUCCEEDED(_Folder(pffli, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    if (SUCCEEDED(SHGetRealIDL(psf, pidlChild, &pidlToFree)))
                    {
                        pidlChild = pidlToFree; // use this below... 
                    }
                    psf->Release();
                }

                // create the doc find version of the pidl witht the
                // extra hidden items embedded
                AddDataToIDList(pidlChild, i, pidlParent, DFDF_NONE, 0, 0, 0, ppidl);
                ILFree(pidlToFree); // may be NULL

                break;  // done with this loop
            }
        }
        LeaveCriticalSection(&_csSearch);

        ILFree(pidlParent);
    }
    
    return *ppidl ? S_OK : S_FALSE;
}


// Called before saving folder list.  Needed especially in Asynch search, 
// (CI).  We lazily pull item data from RowSet only when list view asks 
// for it.  When we are leaving the search folder, we pull all items
// creating all necessary folder lists.  This ensure when saving  folder
// list, all are included.   
// remark : Fix bug#338714.

HRESULT CFindFolder::_UpdateItemList()
{
    USHORT cb = 0;
    int cItems;
    if (SUCCEEDED(GetItemCount(&cItems))) 
    {
        for (int i = 0; i < cItems; i++) 
        {
            FIND_ITEM *pesfi;
            if (DB_S_ENDOFROWSET == GetItem(i, &pesfi))
                break;
        }
    }
    return S_OK;
}

// IFindFolder
HRESULT CFindFolder::SaveFolderList(IStream *pstm)
{
    // We First pull all the items from RowSet (in Asynch case)
    _UpdateItemList();

    EnterCriticalSection(&_csSearch);

    // Now loop through our DPA list and see if we can find a matach
    for (int i = 0; i < DPA_GetPtrCount(_hdpaPidf); i++)
    {
        FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
        if (EVAL(pffli))
            ILSaveToStream(pstm, &pffli->idl);
        else
            break;
    }
    LeaveCriticalSection(&_csSearch);

    // Now out a zero size item..
    USHORT cb = 0;
    pstm->Write(&cb, sizeof(cb), NULL);

    return TRUE;
}

// IFindFolder, Restore results out to file.
HRESULT CFindFolder::RestoreFolderList(IStream *pstm)
{
    // loop through and all all of the folders to our list...
    LPITEMIDLIST pidl = NULL;
    HRESULT hr;

    for (;;)
    {
        hr = ILLoadFromStream(pstm, &pidl); // frees [in,out] pidl for us
        
        if (pidl == NULL)
            break;   // end of the list
        else
        {
            int i;
            AddFolder(pidl, FALSE, &i);
        }
    }
    
    ILFree(pidl); // don't forget to free last pidl

    return hr;
}

HRESULT CFindFolder::SaveItemList(IStream *pstm)
{
    // We First serialize all of our PIDLS for each item in our list
    int cItems;
    if (SUCCEEDED(GetItemCount(&cItems))) 
    {
        // And Save the items that are in the list
        for (int i = 0; i < cItems; i++) 
        {
            FIND_ITEM *pesfi;
            HRESULT hr = GetItem(i, &pesfi);
            
            if (hr == DB_S_ENDOFROWSET)
                break;
            if (SUCCEEDED(hr) && pesfi)
                ILSaveToStream(pstm, &pesfi->idl);
        }
    }
    
    USHORT cb = 0;
    pstm->Write(&cb, sizeof(cb), NULL); // a Trailing NULL size to say end of pidl list...
    
    return S_OK;
}

HRESULT CFindFolder::RestoreItemList(IStream *pstm, int *pcItems)
{
    // And the pidls that are associated with the object
    int cItems = 0;
    LPITEMIDLIST pidl = NULL;    // don't free previous one
    FIND_ITEM *pesfi;
    for (;;)
    {
        if (FAILED(ILLoadFromStream(pstm, &pidl)) || (pidl == NULL))
            break;
        
        if (FAILED(AddPidl(cItems, pidl, (UINT)-1, &pesfi)) || !pesfi)
            break;
        cItems++;
    }

    ILFree(pidl);       // Free the last one read in

    *pcItems = cItems;
    return S_OK;
}

HRESULT CFindFolder::_GetFolderIDList(int iFolder, LPITEMIDLIST *ppidlParent)
{
    *ppidlParent = NULL;

    HRESULT hr = E_FAIL;
    EnterCriticalSection(&_csSearch);
    FIND_FOLDER_ITEM *pffli = _FolderListItem(iFolder);
    if (pffli)
        hr = SHILClone(&pffli->idl, ppidlParent);
    LeaveCriticalSection(&_csSearch);

    return hr;
}

HRESULT CFindFolder::GetParentsPIDL(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent)
{
    return _GetFolderIDList(GetFolderIndex(pidl), ppidlParent);
}

HRESULT CFindFolder::SetControllerNotifyObject(IFindControllerNotify *pfcn)
{
    IUnknown_Set((IUnknown **)&_pfcn, pfcn);
    return S_OK;
}

HRESULT CFindFolder::GetControllerNotifyObject(IFindControllerNotify **ppfcn)
{
    *ppfcn = _pfcn;
    if (_pfcn)
        _pfcn->AddRef();
    return _pfcn ? S_OK : S_FALSE;
}

STDMETHODIMP_(ULONG) CFindFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
       return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP CFindFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName,
    ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFindFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    // We do not want the def view to enumerate us, instead we
    // will tell defview to call us...
    *ppenum = NULL;     // No enumerator
    return S_FALSE;     // no enumerator (not error)
}

STDMETHODIMP CFindFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        hr = psf->BindToObject(pidl, pbc, riid, ppv);
        psf->Release();
    }
    return hr;
}


// Little helper function for bellow
HRESULT CFindFolder::_CompareFolderIndexes(int iFolder1, int iFolder2)
{
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&_csSearch);
    
    FIND_FOLDER_ITEM *pffli1 = _FolderListItem(iFolder1);
    FIND_FOLDER_ITEM *pffli2 = _FolderListItem(iFolder2);

    if (pffli1 && pffli2)
    {
        // Check our 1-level deep cache.  Since its is common for there to be multiple
        //  items in the same folder, during a sort operation, we often compare the
        //  same two folders repeatedly.
        if ((_iCompareFolderCache1 != iFolder1) || (_iCompareFolderCache2 != iFolder2))
        {
            TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];

            SHGetPathFromIDList(&pffli1->idl, szPath1);
            SHGetPathFromIDList(&pffli2->idl, szPath2);
            _iCompareFolderCacheResult = lstrcmpi(szPath1, szPath2);
            _iCompareFolderCache1 = iFolder1;
            _iCompareFolderCache2 = iFolder2;
        }
        hr = ResultFromShort(_iCompareFolderCacheResult);
    }

    LeaveCriticalSection(&_csSearch);
    return hr;
}

PCHIDDENDOCFINDDATA CFindFolder::_HiddenData(LPCITEMIDLIST pidl)
{
    return (PCHIDDENDOCFINDDATA)ILFindHiddenID(pidl, IDLHID_DOCFINDDATA);
}


UINT CFindFolder::GetFolderIndex(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = (PCHIDDENDOCFINDDATA)ILFindHiddenID(pidl, IDLHID_DOCFINDDATA);
    return phdfd ? phdfd->iFolder : -1;
}

FIND_FOLDER_ITEM *CFindFolder::_FolderListItem(int iFolder)
{
    return (FIND_FOLDER_ITEM *)DPA_GetPtr(_hdpaPidf, iFolder);
}

FIND_FOLDER_ITEM *CFindFolder::_FolderListItem(LPCITEMIDLIST pidl)
{
    return _FolderListItem(GetFolderIndex(pidl));
}

ULONG CFindFolder::_Rank(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    // Could be mixed if so put ones without rank at the end...
    return phdfd && (phdfd->wFlags & DFDF_EXTRADATA) ? phdfd->ulRank : 0;
}

DWORD CFindFolder::_ItemID(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    return phdfd && (phdfd->wFlags & DFDF_EXTRADATA) ? phdfd->dwItemID : -1;
}

HRESULT CFindFolder::_GetItemDisplayName(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR wzName, UINT cch)
{
    // Get the IShellFolder:
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        // Get the display name:
        hr = DisplayNameOf(psf, pidl, dwFlags, wzName, cch);
        psf->Release();
    }
    return hr;
}


// Given the 2 pidls, we extract the display name using DisplayNameOf and then
// if all goes well, we compare the two.
int CFindFolder::_CompareNames(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwFlags)
{
    int iRetVal = 0;
    WCHAR szName1[MAX_PATH], szName2[MAX_PATH];

    // Get the name for 1
    HRESULT hr = _GetItemDisplayName(pidl1, dwFlags, szName1, ARRAYSIZE(szName1));
    if (SUCCEEDED(hr))
    {
        // Get the name for 2
        hr = _GetItemDisplayName(pidl2, dwFlags, szName2, ARRAYSIZE(szName2));
        if (SUCCEEDED(hr))
        {
            // Compare and set value
            iRetVal = StrCmpLogicalW(szName1, szName2);
        }
    }

    return iRetVal;
}

int CFindFolder::_CompareByCachedSCID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRetVal = 0;
    
    // If sort on name, we will skip this and use the code below.
    if (!IsEqualSCID(_scidCached, SCID_NAME))
    {
        iRetVal = CompareBySCID(this, &_scidCached, pidl1, pidl2);
    }
    
    // If they are still the same, sort them alphabetically by the name:
    // When we want to sort by name (either becuase we are sorting the
    // name column, or because 2 items are identical in other regards) we 
    // want to display name vs the GetDetailsOf name for 2 reasons:
    //   1. Some folders like IE's History don't support GetDetailsEx.
    //   2. Recycle bin returns the file name, not the displayable name;
    //      so we would end up with "DC###..." instead of "New Folder".
    if (iRetVal == 0)
    {
        iRetVal = _CompareNames(pidl1, pidl2, SHGDN_INFOLDER | SHGDN_NORMAL);
        if (iRetVal == 0)  // the display names are the same, could they be in different folders?
        {
            iRetVal = _CompareNames(pidl1, pidl2, SHGDN_FORPARSING);
        }
    }

    return iRetVal;
}

STDMETHODIMP CFindFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pidl1 == ILFindLastID(pidl1));

    UINT iInputColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);
    UINT iMappedColumn = iInputColumn;

    if (_MapColIndex(&iMappedColumn))
    {
        if (IDFCOL_PATH == iMappedColumn)
        {
            UINT iFolder1 = GetFolderIndex(pidl1);
            UINT iFolder2 = GetFolderIndex(pidl2);

            if (iFolder1 != iFolder2)
                return _CompareFolderIndexes(iFolder1, iFolder2);
        }
        else
        {
            ASSERT(iMappedColumn == IDFCOL_RANK);

            ULONG ulRank1 = _Rank(pidl1);
            ULONG ulRank2 = _Rank(pidl2);
            if (ulRank1 < ulRank2)
                return ResultFromShort(-1);
            if (ulRank1 > ulRank2)
                return ResultFromShort(1);
        }
    }

    // Check the SCID cache and update it if necessary.
    if (_uiColumnCached != iInputColumn)
    {
        hr = MapColumnToSCID(iInputColumn, &_scidCached);
        if (SUCCEEDED(hr))
        {
            _uiColumnCached = iInputColumn;
        }
    }

    // Check if one is a folder and not the other. put folders before files.
    int iRes = CompareFolderness(this, pidl1, pidl2);
    if (iRes == 0)
    {
        iRes = _CompareByCachedSCID(pidl1, pidl2);
    }

    return ResultFromShort(iRes);
}

STDMETHODIMP CFindFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb = new CFindFolderViewCB(this);
        if (psfvcb)
        {
            SFV_CREATE sSFV = {0};
            sSFV.cbSize   = sizeof(sSFV);
            sSFV.pshf     = this;
            sSFV.psfvcb   = psfvcb;

            hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

            psfvcb->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenuCB *pcmcb = new CFindMenuCB();
        if (pcmcb)
        {
            hr = CDefFolderMenu_CreateEx(NULL, hwnd,
                    0, NULL, this, pcmcb, NULL, NULL, (IContextMenu * *)ppv);
            pcmcb->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    HRESULT hr;
    if (cidl == 0)
    {
        // defview asks to see if any items can be renamed this way, lame
        *prgfInOut = SFGAO_CANRENAME;
        hr = S_OK;
    }
    else
    {
        ASSERT(*apidl == ILFindLastID(*apidl))
        IShellFolder *psf;
        hr = _QueryItemShellFolder(apidl[0], &psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(cidl, apidl, prgfInOut);
            psf->Release();
        }
    }
    return hr;
}

//
// To be called back from within CDefFolderMenuE - Currently only used
//

// Some helper functions                
STDMETHODIMP CFindFolder::SetItemsChangedSinceSort()
{ 
    _fItemsChangedSinceSort = TRUE;
    _iCompareFolderCache1 = -1;     // an invalid folder index value
    return S_OK;
}

STDMETHODIMP CFindFolder::GetItemCount(INT *pcItems)
{ 
    ASSERT(pcItems);
    DBCOUNTITEM cItems = 0;

    EnterCriticalSection(&_csSearch);
    if (_hdpaItems)
        cItems = DPA_GetPtrCount(_hdpaItems);
    LeaveCriticalSection(&_csSearch);

    // If async, then we may not have grown our dpa yet... but in mixed case we have so take
    // max of the two...
    if (_pDFEnumAsync)
    {
        if (_cAsyncItems > cItems)
            cItems = _cAsyncItems;
    }

    *pcItems = SANE_ITEMCOUNT(cItems);
    return S_OK;
};


STDMETHODIMP CFindFolder::GetItem(int iItem, FIND_ITEM **ppItem)
{
    HRESULT  hr = E_FAIL; // just to init, use anything
    FIND_ITEM *pesfi;
    IFindEnum *pidfenum;

    GetAsyncEnum(&pidfenum);

    DWORD dwItemID = (UINT)-1;

    EnterCriticalSection(&_csSearch);
    int i = DPA_GetPtrCount(_hdpaItems);
    pesfi = (FIND_ITEM *) DPA_GetPtr(_hdpaItems, iItem);
    LeaveCriticalSection(&_csSearch);

    // Mondo hack to better handle Async searching (ROWSET), we are not sure if we
    // can trust the PIDL of the row as new rows may have been inserted...
    // Only do this if we are not looking at the previous item..

    if (pesfi && pidfenum && !_fSearchComplete && (iItem != _iGetIDList))
    {
        PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

        // As we can now have mixed results only blow away if this is an async guy...
        if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
        {
            pidfenum->GetItemID(iItem, &dwItemID);
            if (dwItemID != phdfd->dwItemID)
            {
                // Overload, pass NULL to ADDPIDL to tell system to free that item
                if (pesfi->dwState & (LVIS_SELECTED|LVIS_FOCUSED))
                    _AddFIND_ITEMToSaveStateList(pesfi);

                AddPidl(iItem, 0, NULL, NULL);
                pesfi = NULL;
            }
        }
    }
                                                                                   
    _iGetIDList = iItem;   // remember the last one we retrieved...

    if (!pesfi && (iItem >= 0))
    {
        // See if this is the async case
        if (pidfenum)
        {
            LPITEMIDLIST pidlT;

            hr = pidfenum->GetItemIDList(SANE_ITEMCOUNT(iItem), &pidlT);            
            if (SUCCEEDED(hr) && hr != DB_S_ENDOFROWSET)
            {
                AddPidl(iItem, pidlT, dwItemID, &pesfi);
                // See if this item should show up as selected...
                if (dwItemID == (UINT)-1)
                    pidfenum->GetItemID(iItem, &dwItemID);
                GetStateFromSaveStateList(dwItemID, &pesfi->dwState);
            }
        }
    }

    *ppItem = pesfi;

    if (hr != DB_S_ENDOFROWSET)
        hr = pesfi ? S_OK : E_FAIL;

    return hr;
}

STDMETHODIMP CFindFolder::DeleteItem(int iItem)
{
    HRESULT hr = E_FAIL;
    
    if (!_fInRefresh)
    {
        FIND_ITEM *pesfi;

        hr = E_INVALIDARG;
        // make sure the item is in dpa (if using cI)
        if (SUCCEEDED(GetItem(iItem, &pesfi)) && pesfi)
        {
            EnterCriticalSection(&_csSearch);
            DPA_DeletePtr(_hdpaItems, iItem);
            LeaveCriticalSection(&_csSearch);
            
            PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

            if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
            {
                //we are deleting async item...
                _cAsyncItems--;
            }
            
            if (pesfi->dwState &= LVIS_SELECTED)
            {
                // Need to update the count of items selected...
                _dflvrSel.DecrementIncludedCount();
            }
            LocalFree((HLOCAL)pesfi);

            hr = S_OK;
        }
    }
    return hr;
}

// evil window crawling code to get the listview from defview

HWND ListviewFromView(HWND hwnd)
{
    HWND hwndLV;

    do
    {
        hwndLV = FindWindowEx(hwnd, NULL, WC_LISTVIEW, NULL);
    }
    while ((hwndLV == NULL) && (hwnd = GetWindow(hwnd, GW_CHILD)));

    return hwndLV;
}

HWND ListviewFromViewUnk(IUnknown *punkView)
{
    HWND hwnd;
    if (SUCCEEDED(IUnknown_GetWindow(punkView, &hwnd)))
    {
        hwnd = ListviewFromView(hwnd);
    }
    return hwnd;
}

STDMETHODIMP CFindFolder::ValidateItems(IUnknown *punkView, int iItem, int cItems, BOOL bSearchComplete)
{
    IFindEnum *pidfenum;
    if (S_OK != GetAsyncEnum(&pidfenum) || _fAllAsyncItemsCached)
        return S_OK;    // nothing to validate.

    DWORD dwItemID = (UINT)-1;

    int cItemsInList;
    GetItemCount(&cItemsInList);

    // force reload of rows
    pidfenum->Reset();

    HWND hwndLV = ListviewFromViewUnk(punkView);

    int iLVFirst = ListView_GetTopIndex(hwndLV);
    int cLVItems = ListView_GetCountPerPage(hwndLV);

    if (iItem == -1)
    {
        iItem = iLVFirst;
        cItems = cLVItems;
    }

    // to avoid failing to update an item...
    if (bSearchComplete)
        _iGetIDList = -1;
        
    while ((iItem < cItemsInList) && cItems)
    {
        EnterCriticalSection(&_csSearch);
        FIND_ITEM *pesfi = (FIND_ITEM *) DPA_GetPtr(_hdpaItems, iItem);
        LeaveCriticalSection(&_csSearch);
        if (!pesfi)     // Assume that if we have not gotten this one we are in the clear...
            break;

        PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

        if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
        {
            pidfenum->GetItemID(iItem, &dwItemID);
            
            if (dwItemID != _ItemID(&pesfi->idl))
            {
                FIND_ITEM *pItem; // dummy to make GetItem happy
                // Oops don't match,
                if (InRange(iItem, iLVFirst, iLVFirst+cLVItems))
                {
                    if (SUCCEEDED(GetItem(iItem, &pItem)))
                    {
                        ListView_RedrawItems(hwndLV, iItem, iItem);
                    }
                }
                else
                {
                    AddPidl(iItem, NULL, 0, NULL);
                }
            }
        }
        else
        {
            break;  // stop after we reach first non ci item
        }
        iItem++;
        cItems--;
    }

    _fSearchComplete = bSearchComplete;

    return S_OK;
}

STDMETHODIMP CFindFolder::AddPidl(int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppcdfi)
{
    HRESULT hr = S_OK;

    ASSERT(GetCurrentThreadId() == _GUIThreadID);

    if (NULL == pidl)
    {
        EnterCriticalSection(&_csSearch);
        FIND_ITEM* pesfi = (FIND_ITEM*)DPA_GetPtr(_hdpaItems, i);
        if (pesfi)
        {
            LocalFree((HLOCAL)pesfi);
            DPA_SetPtr(_hdpaItems, i, NULL);
        }
        LeaveCriticalSection(&_csSearch);
        if (ppcdfi)
            *ppcdfi = NULL;
    }
    else
    {
        int cb = ILGetSize(pidl);
        FIND_ITEM *pesfi;
        hr = SHLocalAlloc(sizeof(*pesfi) - sizeof(pesfi->idl) + cb, &pesfi);
        if (SUCCEEDED(hr))
        {
            // pesfi->dwMask = 0;
            // pesfi->dwState = 0;
            pesfi->iIcon = -1;
            memcpy(&pesfi->idl, pidl, cb);

            EnterCriticalSection(&_csSearch);
            BOOL bRet = DPA_SetPtr(_hdpaItems, i, (void *)pesfi);
            LeaveCriticalSection(&_csSearch);

            if (bRet)
            {
                if (ppcdfi)
                    *ppcdfi = pesfi;
            }
            else
            {
                LocalFree((HLOCAL)pesfi);
                pesfi = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CFindFolder::SetAsyncEnum(IFindEnum *pdfEnumAsync)
{
    if (_pDFEnumAsync)
        _pDFEnumAsync->Release();

    _pDFEnumAsync = pdfEnumAsync;
    if (pdfEnumAsync)
        pdfEnumAsync->AddRef();
    return S_OK;
}

STDMETHODIMP CFindFolder::CacheAllAsyncItems()
{
    if (_fAllAsyncItemsCached)
        return S_OK;      // Allready done it...  

    IFindEnum *pidfenum;
    if (S_OK != GetAsyncEnum(&pidfenum))
        return S_FALSE; // nothing to do...

    // Probably the easiest thing to do is to simply walk through all of the items...
    int maxItems = SANE_ITEMCOUNT(_cAsyncItems);
    for (int i = 0; i < maxItems; i++)
    {
        FIND_ITEM *pesfi;
        GetItem(i, &pesfi);
    }

    _fAllAsyncItemsCached = TRUE;
    return S_OK;
}

BOOL CFindFolder::AllAsyncItemsCached()
{
    return _fAllAsyncItemsCached;
}

STDMETHODIMP CFindFolder::GetAsyncEnum(IFindEnum **ppdfEnumAsync)
{
    *ppdfEnumAsync = _pDFEnumAsync; // unreferecned!
    return *ppdfEnumAsync ? S_OK : S_FALSE;
}

STDMETHODIMP CFindFolder::SetAsyncCount(DBCOUNTITEM cCount)
{
    _cAsyncItems = cCount;
    _fAllAsyncItemsCached = FALSE;
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearSaveStateList()
{
    DSA_DeleteAllItems(_hdsaSaveStateForIDs);
    _cSaveStateSelected = 0;
    return S_OK;
}

STDMETHODIMP CFindFolder::GetStateFromSaveStateList(DWORD dwItemID, DWORD *pdwState)
{
    for (int i = DSA_GetItemCount(_hdsaSaveStateForIDs); i-- > 0;)
    {
        // Pidl at start of structure...
        FIND_ITEM_SAVE_STATE *pessi = (FIND_ITEM_SAVE_STATE*)DSA_GetItemPtr(_hdsaSaveStateForIDs, i);
        if  (pessi->dwItemID == dwItemID)
        {    
            *pdwState = pessi->dwState;
            if (pessi->dwState & LVIS_SELECTED)
            {
                // Remember the counts of items that we have touched...
                _dflvrSel.IncrementIncludedCount();
                _cSaveStateSelected--;
            }

            // Any items we retrieve we can get rid of...
            DSA_DeleteItem(_hdsaSaveStateForIDs, i);
            return S_OK;
        }
    }
    return S_FALSE;
}

STDMETHODIMP CFindFolder::GetFolderListItemCount(INT *pcItemCount)
{ 
    *pcItemCount = 0;

    EnterCriticalSection(&_csSearch);
    if (_hdpaPidf)
        *pcItemCount = DPA_GetPtrCount(_hdpaPidf);
    LeaveCriticalSection(&_csSearch);
     
    return S_OK;
}

STDMETHODIMP CFindFolder::GetFolderListItem(int iItem, FIND_FOLDER_ITEM **ppdffi)
{ 
    EnterCriticalSection(&_csSearch);
    *ppdffi = (FIND_FOLDER_ITEM *)DPA_GetPtr(_hdpaPidf, iItem);
    LeaveCriticalSection(&_csSearch);
    return *ppdffi ? S_OK : E_FAIL;
}

class CFindMenuWrap : public CContextMenuForwarder
{
public:
    // IContextMenu overrides
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

protected:
    CFindMenuWrap(IDataObject* pdo, IContextMenu* pcmArray);
    ~CFindMenuWrap();
    friend HRESULT DFWrapIContextMenus(IDataObject* pdo, IContextMenu* pcm1, IContextMenu* pcm2, REFIID riid, void** ppv);

private:
    IDataObject *       _pdtobj;
};

CFindMenuWrap::CFindMenuWrap(IDataObject* pdo, IContextMenu* pcmArray) : CContextMenuForwarder(pcmArray)
{
    _pdtobj = pdo;
    _pdtobj->AddRef();
}

CFindMenuWrap::~CFindMenuWrap()
{
    _pdtobj->Release();
}

STDMETHODIMP CFindMenuWrap::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fIsLink = FALSE;

    // "link" has to create a link on the desktop, not in the folder (since we're not a real folder...)
    if (IS_INTRESOURCE(lpici->lpVerb))
    {
        WCHAR szCommandString[64];
        if (SUCCEEDED(ContextMenu_GetCommandStringVerb(_pcm, LOWORD((UINT_PTR)lpici->lpVerb), szCommandString, ARRAYSIZE(szCommandString))))
        {
            fIsLink = !StrCmpIW(szCommandString, L"link");
        }
    }
    else
    {
        fIsLink = !StrCmpIA(lpici->lpVerb, "link");
    }

    if (fIsLink)
    {
        // Note: old code used to check pdtobj, but we don't create this
        //       object unless we get one of them, so why check?
        ASSERT(_pdtobj);
        return SHCreateLinks(lpici->hwnd, NULL, _pdtobj,
                SHCL_USETEMPLATE | SHCL_USEDESKTOP | SHCL_CONFIRM, NULL);
    }

    return CContextMenuForwarder::InvokeCommand(lpici);
}

HRESULT DFWrapIContextMenu(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl,
                           IContextMenu* pcmExtra, void **ppvInOut)
{
    IContextMenu *pcmWrap = NULL;
    IContextMenu *pcmFree = (IContextMenu*)*ppvInOut;

    IDataObject* pdo;
    HRESULT hr = psf->GetUIObjectOf(hwnd, 1, &pidl, IID_X_PPV_ARG(IDataObject, NULL, &pdo));
    if (SUCCEEDED(hr))
    {
        hr = DFWrapIContextMenus(pdo, pcmFree, pcmExtra, IID_PPV_ARG(IContextMenu, &pcmWrap));
        pdo->Release();
    }

    pcmFree->Release();
    *ppvInOut = pcmWrap;
    
    return hr;
}

HRESULT DFWrapIContextMenus(IDataObject* pdo, IContextMenu* pcm1, IContextMenu* pcm2, REFIID riid, void** ppv)
{
    *ppv = NULL;

    IContextMenu * pcmArray;
    IContextMenu* rgpcm[2] = {pcm2, pcm1};
    HRESULT hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), IID_PPV_ARG(IContextMenu, &pcmArray));
    if (SUCCEEDED(hr))
    {
        CFindMenuWrap * p = new CFindMenuWrap(pdo, pcmArray);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        pcmArray->Release();
    }

    return hr;
}


STDMETHODIMP CFindFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindFolder, IShellFolder2),          //IID_ISHELLFolder2
        QITABENTMULTI(CFindFolder, IShellFolder, IShellFolder2),   // IID_IShellFolder
        QITABENT(CFindFolder, IFindFolder),        //IID_IFindFolder
        QITABENT(CFindFolder, IShellIcon),            //IID_IShellIcon
        QITABENT(CFindFolder, IPersistFolder2),       //IID_IPersistFolder2
        QITABENTMULTI(CFindFolder, IPersistFolder, IPersistFolder2), //IID_IPersistFolder
        QITABENTMULTI(CFindFolder, IPersist, IPersistFolder2),      //IID_IPersist
        QITABENT(CFindFolder, IShellIconOverlay),     //IID_IShellIconOverlay
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
    
// IPersistFolder2 implementation
STDMETHODIMP CFindFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DocFindFolder;
    return S_OK;
}

STDMETHODIMP CFindFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (_pidl)
        ILFree(_pidl);

    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CFindFolder::GetCurFolder(LPITEMIDLIST *ppidl) 
{    
    return GetCurFolderImpl(_pidl, ppidl);
}

// helper function to sort the selected ID list by something that
// makes file operations work reasonably OK, when both an object and it's
// parent is in the list...
//
int CALLBACK CFindFolder::_SortForDataObj(void *p1, void *p2, LPARAM lparam)
{
    // Since I do recursion, If I get the Folder index number from the
    // last element of each and sort by them such that the higher numbers
    // come first, should solve the problem fine...
    LPITEMIDLIST pidl1 = (LPITEMIDLIST)ILFindLastID((LPITEMIDLIST)p1);
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)ILFindLastID((LPITEMIDLIST)p2);
    CFindFolder *pff = (CFindFolder *)lparam;

    return pff->GetFolderIndex(pidl2) - pff->GetFolderIndex(pidl1);
}

LPITEMIDLIST CFindFolder::_GetFullPidlForItem(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlParent;
    if (S_OK == GetParentsPIDL(pidl, &pidlParent))
    {
        pidlRet = ILCombine(pidlParent, pidl);
        ILFree(pidlParent);
    }
    return pidlRet;
}

// we generate a non flat HIDA. this is so clients that
// use this HIDA will bind to the folder that the results came
// from instead of this folder that has runtime state that won't
// be present if we rebind

HRESULT CFindFolder::_PrepareHIDA(UINT cidl, LPCITEMIDLIST * apidl, HDPA *phdpa)
{
    HRESULT hr = E_OUTOFMEMORY;
    *phdpa = DPA_Create(0);
    if (*phdpa)
    {
        if (DPA_Grow(*phdpa, cidl))
        {
            for (UINT i = 0; i < cidl; i++)
            {
                LPITEMIDLIST pidl = _GetFullPidlForItem(apidl[i]);
                if (pidl)
                    DPA_InsertPtr(*phdpa, i, pidl);
            }

            // In order to make file manipulation functions work properly we
            // need to sort the elements to make sure if an element and one
            // of it's parents are in the list, that the element comes
            // before it's parents...
            DPA_Sort(*phdpa, _SortForDataObj, (LPARAM)this);
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    *ppv = NULL;

    // if just one item we can deletate to real folder
    if (cidl == 1)
    {
        // Note we may have been passed in a complex item so find the last
        ASSERT(ILIsEmpty(_ILNext(*apidl)));  // should be a single level PIDL!

        IShellFolder *psf;
        hr = _QueryItemShellFolder(apidl[0], &psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);

            // if we are doing context menu, then we will wrap this
            // interface in a wrapper object, that we can then pick
            // off commands like link to process specially
            if (SUCCEEDED(hr))
            {
                if (IsEqualIID(riid, IID_IContextMenu))
                {
                    // we also let the net/file guy add in a context menu if they want to
                    IContextMenu* pcmExtra = NULL;
                    _pfilter->GetItemContextMenu(hwnd, SAFECAST(this, IFindFolder*), &pcmExtra);
                
                    hr = DFWrapIContextMenu(hwnd, psf, apidl[0], pcmExtra, ppv);

                    ATOMICRELEASE(pcmExtra);
                }
                else if (IsEqualIID(riid, IID_IQueryInfo)) // && SHGetAttributes(psf, apidl[0], SFGAO_FILESYSTEM))
                {
                    WrapInfotip(SAFECAST(this, IShellFolder2 *), apidl[0], &SCID_DIRECTORY, (IUnknown *)*ppv);
                }
            }
            psf->Release();
        }
    }
    else if (cidl > 1)
    {
        if (IsEqualIID(riid, IID_IContextMenu))
        {
            // Try to create a menu object that we process ourself
            // Yes, do context menu.
            HKEY ahkeys[MAX_ASSOC_KEYS] = {0};
            DWORD ckeys = 0;

            LPITEMIDLIST pidlFull = _GetFullPidlForItem(apidl[0]);
            if (pidlFull)
            {
                // Get the hkeyProgID and hkeyBaseProgID from the first item.
                ckeys = SHGetAssocKeysForIDList(pidlFull, ahkeys, ARRAYSIZE(ahkeys));
                ILFree(pidlFull);
            }

            IContextMenuCB *pcmcb = new CFindMenuCB();
            if (pcmcb)
            {
                hr = CDefFolderMenu_Create2Ex(NULL, hwnd,
                                cidl, apidl, this, pcmcb,
                                ckeys, ahkeys,
                                (IContextMenu **)ppv);
                pcmcb->Release();
            }

            SHRegCloseKeys(ahkeys, ckeys);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            HDPA hdpa;
            hr = _PrepareHIDA(cidl, apidl, &hdpa);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateFileDataObject(&c_idlDesktop, cidl, (LPCITEMIDLIST*)DPA_GetPtrPtr(hdpa),
                                            NULL, (IDataObject **)ppv);
                DPA_FreeIDArray(hdpa);
            }
        }
    }

    return hr;
}

STDMETHODIMP CFindFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwRes, LPSTRRET pStrRet)
{
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        if ((dwRes & SHGDN_INFOLDER) && (dwRes & SHGDN_FORPARSING) && !(dwRes & SHGDN_FORADDRESSBAR))
        {
            // The thumbnail cache uses this as a hit test... in search view we can have files with the same name.
            dwRes &= ~SHGDN_INFOLDER;
        }
        hr = psf->GetDisplayNameOf(pidl, dwRes, pStrRet);
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                                    DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlRenamed;
        hr = psf->SetNameOf(hwnd, pidl, PathFindFileName(pszName), dwRes, ppidlOut ? &pidlRenamed : NULL);
        if (SUCCEEDED(hr) && ppidlOut)
        {
            hr = AddDataToIDList(pidlRenamed, GetFolderIndex(pidl), NULL, DFDF_NONE, 0, 0, 0, ppidlOut);
            ILFree(pidlRenamed);
        }
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return _pfilter->GetDefaultSearchGUID(SAFECAST(this, IShellFolder2*), pGuid);
}

STDMETHODIMP CFindFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    return _pfilter->EnumSearches(SAFECAST(this, IShellFolder2*), ppenum);
}

HRESULT CFindFolder::_Folder(FIND_FOLDER_ITEM *pffli, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (pffli->psf)
        hr = S_OK;
    else
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, &pffli->idl, &pffli->psf));

    if (SUCCEEDED(hr))
        hr = pffli->psf->QueryInterface(riid, ppv);
    return hr;
}

HRESULT CFindFolder::GetFolder(int iFolder, REFIID riid, void **ppv)
{
    *ppv = NULL; 
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(iFolder);
    if (pffli)
        hr = _Folder(pffli, riid, ppv);

    LeaveCriticalSection(&_csSearch);

    return hr;
}

HRESULT CFindFolder::_FolderFromItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL; 
    HRESULT hr = E_FAIL;
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    if (phdfd)
    {
        hr = SHBindToObject(NULL, riid, &phdfd->idlParent, ppv);
    }
    return hr;
}

HRESULT CFindFolder::_QueryItemShellFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf)
{
    *ppsf = NULL;
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(pidl);
    if (pffli)
    {
        if (pffli->psf)
            hr = S_OK;
        else
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, &pffli->idl, &pffli->psf));

        if (SUCCEEDED(hr))
        {
            *ppsf = pffli->psf;
            (*ppsf)->AddRef();
        }
    }

    LeaveCriticalSection(&_csSearch);

    if (FAILED(hr))
    {
        hr = _FolderFromItem(pidl, IID_PPV_ARG(IShellFolder, ppsf));
    }

    return hr;
}


HRESULT CFindFolder::_QueryItemInterface(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(pidl);
    if (pffli)
        hr = _Folder(pffli, riid, ppv);

    LeaveCriticalSection(&_csSearch);

    if (FAILED(hr))
    {
        hr = _FolderFromItem(pidl, riid, ppv);
    }

    return hr;
}

HRESULT CFindFolder::_GetDetailsFolder()
{
    HRESULT hr;
    if (_psfDetails)
        hr = S_OK;  // in cache
    else 
    {
        IFindFilter *pfilter;
        hr = GetFindFilter(&pfilter);
        if (SUCCEEDED(hr)) 
        {
            hr = pfilter->GetColumnsFolder(&_psfDetails);
            pfilter->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetDetailsFolder();
    if (SUCCEEDED(hr))
        hr = _psfDetails->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

BOOL CFindFolder::_MapColIndex(UINT *piColumn)
{
    switch (*piColumn)
    {
    case IDFCOL_NAME:   // 0
        return FALSE;

    case IDFCOL_PATH:   // 1
    case IDFCOL_RANK:   // 2
        return TRUE;

    default:            // >= 3
        *piColumn -= IDFCOL_RANK;
        return FALSE;
    }
}

STDMETHODIMP CFindFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr;
    
    if (_MapColIndex(&iColumn))
    {
        *pdwState = c_find_cols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        hr = _GetDetailsFolder();
        if (SUCCEEDED(hr))
        {
            hr = _psfDetails->GetDefaultColumnState(iColumn, pdwState);
            *pdwState &= ~SHCOLSTATE_SLOW;  // virtual lv and defview
        }
    }
    return hr;
}

HRESULT CFindFolder::_GetFolderName(LPCITEMIDLIST pidl, DWORD gdnFlags, LPTSTR psz, UINT cch)
{
    LPITEMIDLIST pidlFolder;
    HRESULT hr = GetParentsPIDL(pidl, &pidlFolder);
    if (SUCCEEDED(hr))
    { 
        hr = SHGetNameAndFlags(pidlFolder, gdnFlags, psz, cch, NULL);
        ILFree(pidlFolder);
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr;
    if (IsEqualSCID(*pscid, SCID_RANK))
    {
        hr = InitVariantFromUINT(pv, _Rank(pidl));
    }
    else
    {
        IShellFolder2 *psf;
        hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
            psf->Release();
        }

        if (FAILED(hr))
        {
            if (IsEqualSCID(*pscid, SCID_DIRECTORY))
            {
                TCHAR szTemp[MAX_PATH];
                hr = _GetFolderName(pidl, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStr(pv, szTemp);
                }
            }
        }
    }
    return hr;
}

//  Figure out what the correct column index is to match the scid we are given
//  where the returned index is relative to the folder passed in.
int MapSCIDToColumnForFolder(IShellFolder2 *psf, SHCOLUMNID scidIn)
{
    SHCOLUMNID scidNew;
    for (UINT i = 0; SUCCEEDED(psf->MapColumnToSCID(i, &scidNew)); i++)
    {
        if (IsEqualSCID(scidNew, scidIn))
        {
            return i;   // found
        }
    }
    return -1;  // not found
}

STDMETHODIMP CFindFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        if (pidl)
        {
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = 0;
            if (IDFCOL_PATH == iColumn)   
            {
                _GetFolderName(pidl, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szTemp, ARRAYSIZE(szTemp));
            }
            else
            {
                ASSERT(IDFCOL_RANK == iColumn);
                ULONG uRank = _Rank(pidl);
                if (uRank)
                    AddCommas(uRank, szTemp, ARRAYSIZE(szTemp));
            }
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            hr = GetDetailsOfInfo(c_find_cols, ARRAYSIZE(c_find_cols), iColumn, pdi);
        }
    }
    else
    {
        if (pidl)
        {
            IShellFolder2 *psf;
            hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellFolder2, &psf));
            if (SUCCEEDED(hr))
            {
                //  We cannot simply ask for GetDetailsOf because some folders map different
                //  column numbers to differnt values.
                //  Translate the column index to the SHCOLUMNID relative to this folder.
                SHCOLUMNID colId;
                hr = _GetDetailsFolder();
                if (SUCCEEDED(hr))
                    hr = _psfDetails->MapColumnToSCID(iColumn, &colId);

                //  Use the SCID to get the correct column index...
                if (SUCCEEDED(hr))
                {
                    //  Get the column index for the SCID with respect to the other folder
                    int newIndex = MapSCIDToColumnForFolder(psf, colId);
                    if (newIndex != -1)
                    {
                        //  Found the correct column index, so use it to get the data
                        hr = psf->GetDetailsOf(pidl, newIndex, pdi);
                    }
                    else
                    {
                        //  Failed to find the correct column index.
                        hr = E_FAIL;
                    }
                }
                
                psf->Release();
            }
        }
        else
        {
            hr = _GetDetailsFolder();
            if (SUCCEEDED(hr))
                hr = _psfDetails->GetDetailsOf(NULL, iColumn, pdi);
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        hr = MapColumnToSCIDImpl(c_find_cols, ARRAYSIZE(c_find_cols), iColumn, pscid);
    }
    else
    {
        hr = _GetDetailsFolder();
        if (SUCCEEDED(hr))
            hr = _psfDetails->MapColumnToSCID(iColumn, pscid);
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetFindFilter(IFindFilter **ppfilter)
{
    return _pfilter->QueryInterface(IID_PPV_ARG(IFindFilter, ppfilter));
}

// IShellIcon::GetIconOf
STDMETHODIMP CFindFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    IShellIcon * psiItem;
    HRESULT hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellIcon, &psiItem));
    if (SUCCEEDED(hr))
    {
        hr = psiItem->GetIconOf(pidl, flags, piIndex);
        psiItem->Release();
    }
    return hr;
}

// IShellIconOverlay
STDMETHODIMP CFindFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    IShellIconOverlay * psioItem;
    HRESULT hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellIconOverlay, &psioItem));
    if (SUCCEEDED(hr))
    {
        hr = psioItem->GetOverlayIndex(pidl, pIndex);
        psioItem->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFindFolder::RestoreSearchFromSaveFile(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv)
{
    // See if we can restore most of the search from here...
    IStream *pstm;
    HRESULT hr = StgBindToObject(pidlSaveFile, STGM_READ | STGM_SHARE_DENY_WRITE, IID_PPV_ARG(IStream, &pstm));
    if (SUCCEEDED(hr))
    {
        ULONG cbRead;
        DFHEADER dfh;

        // Note: in theory I should test the size read by the size of the
        // smaller headers, but if the number of bytes read is smaller than
        // the few new things added then there is nothing to restore anyway...

        // Note: Win95/NT4 incorrectly failed newer versions of this structure.
        // Which is bogus since the struct was backward compatible (that's what
        // the offsets are for).  We fix for NT5 and beyond, but downlevel
        // systems are forever broken.  Hopefully this feature is rarely enough
        // used (and never mailed) that nobody will notice we're broken.

        if (SUCCEEDED(pstm->Read(&dfh, sizeof(dfh), &cbRead)) &&
            (sizeof(dfh) == cbRead) && (DOCFIND_SIG == dfh.wSig))
        {
            DFC_UNICODE_DESC desc;
            LARGE_INTEGER dlibMove = {0, 0};
            WORD fCharType = 0;

            // Check the stream's signature to see if it was generated by Win95 or NT.
            dlibMove.QuadPart = -(LONGLONG)sizeof(desc);
            pstm->Seek(dlibMove, STREAM_SEEK_END, NULL);
            pstm->Read(&desc, sizeof(desc), &cbRead);
            if (cbRead > 0 && desc.NTsignature == c_NTsignature)
            {
               // NT-generated stream.  Read in Unicode criteria.
               fCharType = DFC_FMT_UNICODE;
               dlibMove.QuadPart = desc.oUnicodeCriteria.QuadPart;
            }
            else
            {
               // Win95-generated stream.  Read in ANSI criteria.
               fCharType = DFC_FMT_ANSI;
               dlibMove.LowPart = dfh.oCriteria;
            }
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            _pfilter->RestoreCriteria(pstm, dfh.cCriteria, fCharType);

            // Now read in the results
            dlibMove.LowPart = dfh.oResults;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

            if (dfh.wVer > 1)
            {
                // only restore this way if version 2 data....
                // Now Restore away the folder list
                RestoreFolderList(pstm);
                int cItems = 0;
                RestoreItemList(pstm, &cItems);
                if (cItems > 0)
                    psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
            }
        }
        else
            hr = E_FAIL;
        pstm->Release();
    }
    return hr;
}

// a form of this code is duplicated in browseui searchext.cpp
//
BOOL RealFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile)
{
    // First create the top level browser...
    IWebBrowser2 *pwb2;
    HRESULT hr = CoCreateInstance(CLSID_ShellBrowserWindow, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        VARIANT varClsid;
        hr = InitBSTRVariantFromGUID(&varClsid, CLSID_FileSearchBand);
        if (SUCCEEDED(hr))
        {
            VARIANT varEmpty = {0};

            // show a search bar
            hr = pwb2->ShowBrowserBar(&varClsid, &varEmpty, &varEmpty);
            if (SUCCEEDED(hr))
            {
                // Grab the band's IUnknown from browser property.
                VARIANT varFsb;
                hr = pwb2->GetProperty(varClsid.bstrVal, &varFsb);
                if (SUCCEEDED(hr))
                {
                    //  QI for IFileSearchBand, which we'll use to program the search band's
                    //  search type (files or folders), inititial scope, and/or saved query file.
                    IFileSearchBand* pfsb;
                    if (SUCCEEDED(QueryInterfaceVariant(varFsb, IID_PPV_ARG(IFileSearchBand, &pfsb))))
                    {
                        BSTR bstrSearch;
                        hr = BSTRFromCLSID(SRCID_SFileSearch, &bstrSearch);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varQueryFile = {0}, varScope = {0};

                            //  assign initial scope
                            if (pidlFolder)
                                InitVariantFromIDList(&varScope, pidlFolder);
                            //  assign query file from which to restore search
                            else if (pidlSaveFile)
                                InitVariantFromIDList(&varQueryFile, pidlSaveFile);

                            pfsb->SetSearchParameters(&bstrSearch, VARIANT_TRUE, &varScope, &varQueryFile);

                            VariantClear(&varScope);
                            VariantClear(&varQueryFile);

                            SysFreeString(bstrSearch);
                        }
                        pfsb->Release();
                    }
                    VariantClear(&varFsb);
                }

                if (SUCCEEDED(hr))
                    hr = pwb2->put_Visible(TRUE);
            }
            VariantClear(&varClsid); // frees bstrFileSearchBand too
        }
        pwb2->Release();
    }
    return hr;
}

HRESULT CFindFolder::OpenContainingFolder(IUnknown *punkSite)
{
    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;
        hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IEnumIDList, &penum));
        if (S_OK == hr)
        {
            LPITEMIDLIST pidl;
            ULONG c;
            while (S_OK == penum->Next(1, &pidl, &c))
            {
                // Now get the parent of it.
                LPITEMIDLIST pidlParent;
                if (SUCCEEDED(GetParentsPIDL(pidl, &pidlParent)))
                {
                    SHOpenFolderAndSelectItems(pidlParent, 1, (LPCITEMIDLIST *)&pidl, 0);
                    ILFree(pidlParent);
                }
                ILFree(pidl);
            }
            penum->Release();
        }
        pfv->Release();
    }
    return hr;
}

// Save away the current search to a file on the desktop.
// For now the name will be automatically generated.
//
void CFindFolder::Save(IFindFilter* pfilter, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown *pObject)
{
    TCHAR szFilePath[MAX_PATH];
    IStream * pstm;
    DFHEADER dfh;
    TCHAR szTemp[MAX_PATH];
    SHORT cb;
    LARGE_INTEGER dlibMove = {0, 0};
    ULARGE_INTEGER libCurPos;
    FOLDERSETTINGS fs;
    
    //
    // See if the search already has a file name associated with it.  If so
    // we will save it in it, else we will create a new file on the desktop
    if (pfilter->FFilterChanged() == S_FALSE)
    {
        // Lets blow away the save file
        ILFree(pSaveInfo->pidlSaveFile);
        pSaveInfo->pidlSaveFile = NULL;
    }
    
    // If it still looks like we want to continue to use a save file then
    // continue.
    if (pSaveInfo->pidlSaveFile)
    {
        SHGetPathFromIDList(pSaveInfo->pidlSaveFile, szFilePath);
    }
    else
    {
        // First get the path name to the Desktop.
        SHGetSpecialFolderPath(NULL, szFilePath, CSIDL_PERSONAL, TRUE);
        
        // and update the title
        // we now do this before getting a filename because we generate
        // the file name from the title
        
        LPTSTR pszTitle;
        pfilter->GenerateTitle(&pszTitle, TRUE);
        if (pszTitle)
        {
            // Now add on the extension.
            lstrcpyn(szTemp, pszTitle, MAX_PATH - (lstrlen(szFilePath) + 1 + 4 + 1+3));
            lstrcat(szTemp, TEXT(".fnd"));
            
            LocalFree(pszTitle);     // And free the title string.
        }
        else
        {
            szTemp[0] = 0;
        }
        
        
        // Now loop through and replace all of the invalid characters with _'s
        // we special case a few of the characters...
        for (LPTSTR lpsz = szTemp; *lpsz; lpsz = CharNext(lpsz))
        {
            if (PathGetCharType(*lpsz) & (GCT_INVALID|GCT_WILD|GCT_SEPARATOR))
            {
                switch (*lpsz) 
                {
                case TEXT(':'):
                    *lpsz = TEXT('-');
                    break;
                case TEXT('*'):
                    *lpsz = TEXT('@');
                    break;
                case TEXT('?'):
                    *lpsz = TEXT('!');
                    break;
                default:
                    *lpsz = TEXT('_');
                }
            }
        }
        
        TCHAR szShortName[12];
        LoadString(HINST_THISDLL, IDS_FIND_SHORT_NAME, szShortName, ARRAYSIZE(szShortName));
        if (!PathYetAnotherMakeUniqueName(szFilePath, szFilePath, szShortName, szTemp))
            return;
    }
    
    // Now lets bring up the save as dialog...
    TCHAR szFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szFilename[MAX_PATH];
    OPENFILENAME ofn = { 0 };
    
    LoadString(g_hinst, IDS_FINDFILESFILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString(g_hinst, IDS_FINDSAVERESULTSTITLE, szTitle, ARRAYSIZE(szTitle));
    
    //Strip out the # and make them Nulls for SaveAs Dialog
    LPTSTR psz = szFilter;
    while (*psz)
    {
        if (*psz == TEXT('#'))
            *psz = 0;
        psz++;
    }
    
    lstrcpy(szFilename, PathFindFileName(szFilePath));
    PathRemoveFileSpec(szFilePath);
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hinst;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szFilePath;
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = TEXT("fnd");
    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | 
        OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;
    ofn.lpTemplateName = NULL;
    ofn.lpfnHook= NULL;
    ofn.lCustData = NULL;
    
    if (!GetSaveFileName(&ofn))
        return;
    
    if (FAILED(SHCreateStreamOnFile(szFilename, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm)))
        return;
    
    // remember the file that we saved away to...
    ILFree(pSaveInfo->pidlSaveFile);
    SHParseDisplayName(szFilename, NULL, &pSaveInfo->pidlSaveFile, 0, NULL);
    
    // Now setup and write out header information
    ZeroMemory(&dfh, sizeof(dfh));
    dfh.wSig = DOCFIND_SIG;
    dfh.wVer = DF_CURFILEVER;
    dfh.dwFlags =  pSaveInfo->dwFlags;
    dfh.wSortOrder = (WORD)pSaveInfo->SortMode;
    dfh.wcbItem = sizeof(DFITEM);
    dfh.oCriteria = sizeof(dfh);
    // dfh.cCriteria = sizeof(s_aIndexes) / sizeof(SHORT);
    // dfh.oResults =;
    
    // Not used anymore...
    dfh.cResults = -1;
    
    // Note: Later we may convert this to DOCFILE where the
    // criteria is stored as properties.
    
    // Get the current Folder Settings
    if (SUCCEEDED(psv->GetCurrentInfo(&fs)))
        dfh.ViewMode = fs.ViewMode;
    else
        dfh.ViewMode = FVM_DETAILS;
    
    // Now call the filter object to save out his own set of criterias
    
    dlibMove.LowPart = dfh.oCriteria;
    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    HRESULT hr = pfilter->SaveCriteria(pstm, DFC_FMT_ANSI);
    if (SUCCEEDED(hr))
        dfh.cCriteria = GetScode(hr);
    
    // Now setup to output the results
    dlibMove.LowPart = 0;
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos); // Get current pos
    dfh.oResults = libCurPos.LowPart;
    //
    // Now Let our file folder serialize his results out here also...
    // But only if the option is set to do so...
    //
    cb = 0;
    
    // Write out a Trailing NULL for Folder list
    pstm->Write(&cb, sizeof(cb), NULL);
    // And item list.
    pstm->Write(&cb, sizeof(cb), NULL);
    
    // END of DFHEADER_WIN95 information
    // BEGIN of NT5 information:
    
    // Now setup to output the history stream
    if (pObject)
    {
        dlibMove.LowPart = 0;
        pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos); // Get current pos
        dfh.oHistory = libCurPos.LowPart;
        
        if (FAILED(SavePersistHistory(pObject, pstm)))
        {
            // On failure we might as well just pretend we didn't save this bit of data.
            // Do we need an error message -- the ui won't be right when relaunched...
            //
            dfh.oHistory = 0;
            dlibMove.LowPart = libCurPos.LowPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
        }
    }
    
    // In NT the below was done AT THE END OF THE STREAM instead of
    // revving the DFHEADER struct.  (Okay, DFHEADEREX, since Win95
    // already broke DFHEADER back compat by in improper version check)
    // This could have been done by putting a propery signatured
    // DFHEADEREX that had proper versioning so we could add information
    // to.  Unfortunately another hardcoded struct was tacked on to
    // the end of the stream...   Next time, please fix the problem
    // instead of work around it.
    //
    // What this boils down to is we cannot put any information
    // after the DFC_UNICODE_DESC section, so might as well
    // always do this SaveCriteria section last...
    //
    // See comment at top of file for DFC_UNICODE_DESC.
    //
    DFC_UNICODE_DESC desc;
    
    //
    // Get the current location in stream.  This is the offset where
    // we'll write the unicode find criteria.  Save this
    // value (along with NT-specific signature) in the descriptor
    //
    dlibMove.LowPart = 0;
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos);
    
    desc.oUnicodeCriteria.QuadPart = libCurPos.QuadPart;
    desc.NTsignature               = c_NTsignature;
    
    // Append the Unicode version of the find criteria.
    hr = pfilter->SaveCriteria(pstm, DFC_FMT_UNICODE);
    
    // Append the unicode criteria descriptor to the end of the file.
    pstm->Write(&desc, sizeof(desc), NULL);
    //
    // don't put any code between the above DFC_UNICDE_DESC section
    // and this back-patch of the dfh header...
    //
    // Finally output the header information at the start of the file
    // and close the file
    //
    pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
    pstm->Write(&dfh, sizeof(dfh), NULL);
    pstm->Release();
    
    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pSaveInfo->pidlSaveFile, NULL);
    SHChangeNotify(SHCNE_FREESPACE, SHCNF_IDLIST, pSaveInfo->pidlSaveFile, NULL);
}

// Broke out from class to share with old and new code
BOOL CFindFolder::HandleUpdateDir(LPCITEMIDLIST pidl, BOOL fCheckSubDirs)
{
    // 1. Start walk through list of dirs.  Find list of directories effected
    //    and mark them
    // 2. Walk the list of items that we have and mark each of the items that
    //    that are in our list of directories and then do a search...
    BOOL fCurrentItemsMayBeImpacted = FALSE;
    FIND_FOLDER_ITEM *pffli;
    INT cPidf;

    // First see which directories are effected...
    GetFolderListItemCount(&cPidf);
    for (int iPidf = 0; iPidf < cPidf; iPidf++)
    {        
        if (SUCCEEDED(GetFolderListItem(iPidf, &pffli)) 
            && !pffli->fUpdateDir) // We may have already impacted these...
        {
            pffli->fUpdateDir = ILIsParent(pidl, &pffli->idl, FALSE);
            fCurrentItemsMayBeImpacted |= pffli->fUpdateDir;
        }
    }

    if (fCurrentItemsMayBeImpacted)
    {
        // Now we need to walk through the whole list and remove any entries
        // that are no longer there...
        //
        int iItem;
        if (SUCCEEDED(GetItemCount(&iItem))) 
        {
            for (--iItem; iItem >= 0; iItem--)
            {
                FIND_ITEM *pesfi;
                if (SUCCEEDED(GetItem(iItem, &pesfi)) && pesfi)
                {
                    UINT iFolder = GetFolderIndex(&pesfi->idl);
                
                    // See if item may be impacted...
                    if (SUCCEEDED(GetFolderListItem(iFolder, &pffli)) && pffli->fUpdateDir)
                        pesfi->dwState |= CDFITEM_STATE_MAYBEDELETE;
                }
            }
        }
    }

    return fCurrentItemsMayBeImpacted;
}

void CFindFolder::UpdateOrMaybeAddPidl(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld)
{
    HRESULT hr;

    // First see if we should try to do an update...
    if (pidlOld)
    {
        LPITEMIDLIST pidlT;
        if (S_OK == MapToSearchIDList(pidl, TRUE, &pidlT))
        {
            SetItemsChangedSinceSort();
            UINT iItem;
            // cast needed for bad interface def
            hr = psfv->UpdateObject((LPITEMIDLIST)pidlOld, (LPITEMIDLIST)pidlT, &iItem);

            ILFree(pidlT);  // In either case simply blow away our generated pidl...
            if (SUCCEEDED(hr))
                return;
        }
    }

    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        BOOL fMatch = FALSE;
        // See if this item matches the filter...
        IFindFilter *pfilter;
        if (SUCCEEDED(GetFindFilter(&pfilter))) 
        {
            fMatch = pfilter->MatchFilter(psf, pidlChild) != 0;
            pfilter->Release();
        }

        psf->Release();

        if (fMatch)
        {
            LPITEMIDLIST pidlT;
            if (S_OK != MapToSearchIDList(pidl, TRUE, &pidlT))
            {
                fMatch = FALSE;

                // The folder has not been added before now...
                TCHAR szPath[MAX_PATH];
                SHGetPathFromIDList(pidl, szPath);
                if (!IsFileInBitBucket(szPath))
                {
                    PathRemoveFileSpec(szPath);

                    LPITEMIDLIST pidlFolder;
                    if (SUCCEEDED(SHParseDisplayName(szPath, NULL, &pidlFolder, 0, NULL)))
                    {
                        int iFolder;
                        hr = AddFolder(pidlFolder, TRUE, &iFolder);
                        if (SUCCEEDED(hr))
                        {
                            fMatch = (S_OK == MapToSearchIDList(pidl, TRUE, &pidlT));
                        }
                        ILFree(pidlFolder);
                    }
                }
            }

            if (fMatch)
            {
                // There are times we get notified twice.  To handle this
                // see if the item is already in our list.  If so punt...

                SetItemsChangedSinceSort();

                UINT iItem;
                if (FAILED(psfv->UpdateObject(pidlT, pidlT, &iItem)))
                {
                    // item not in the view yet... so we need to add it

                    if (SUCCEEDED(GetItemCount((INT *)&iItem))) 
                    {
                        // Normal case would be here to add the object
                        // We need to add this to our dpa and dsa...
                        FIND_ITEM *pesfi;
                        AddPidl(iItem, pidlT, (UINT)-1, &pesfi);
                        if (pesfi)
                            psfv->SetObjectCount(++iItem, SFVSOC_NOSCROLL);
                    }
                }
                ILFree(pidlT);
            }
            else
            {
                ASSERT(NULL == pidlT);
            }
        }
    }
}

void CFindFolder::HandleRMDir(IShellFolderView *psfv, LPCITEMIDLIST pidl)
{
    BOOL fCurrentItemsMayBeImpacted = FALSE;
    FIND_FOLDER_ITEM *pffli;
    INT cItems;
    FIND_ITEM *pesfi;

    // First see which directories are effected...
    GetFolderListItemCount(&cItems);
    for (int iItem = 0; iItem < cItems; iItem++)
    {         
        if (SUCCEEDED(GetFolderListItem(iItem, &pffli)))
        {
            pffli->fDeleteDir = ILIsParent(pidl, &pffli->idl, FALSE);
            fCurrentItemsMayBeImpacted |= pffli->fDeleteDir;
        }
        else 
        {
#ifdef DEBUG
            INT cItem;
            GetFolderListItemCount(&cItem);
            TraceMsg(TF_WARNING, "NULL pffli in _handleRMDir (iItem == %d, ItemCount()==%d)!!!", iItem, cItems);
#endif
        }
    }

    if (fCurrentItemsMayBeImpacted)
    {
        // Now we need to walk through the whole list and remove any entries
        // that are no longer there...
        if (SUCCEEDED(GetItemCount(&iItem))) 
        {
            for (--iItem; iItem >= 0; iItem--)
            {
                if (FAILED(GetItem(iItem, &pesfi)) || pesfi == NULL)
                    continue;

                // See if item may be impacted...
                UINT iFolder = GetFolderIndex(&pesfi->idl);
                if (SUCCEEDED(GetFolderListItem(iFolder, &pffli)) 
                    && pffli->fDeleteDir) 
                {
                    psfv->RemoveObject(&pesfi->idl, (UINT*)&cItems);
                }
            }
        }
    }
}

// export used for Start.Search-> cascade menu

STDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwnd, UINT idCmdFirst, UINT idCmdLast)
{
    IContextMenu * pcm = NULL;
    HKEY hkFind = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("FindExtensions"), FALSE);
    if (hkFind) 
    {
        if (SUCCEEDED(CDefFolderMenu_CreateHKeyMenu(hwnd, hkFind, &pcm))) 
        {
            int iItems = GetMenuItemCount(hmenu);
            // nuke all old entries
            while (iItems--) 
            {
                DeleteMenu(hmenu, iItems, MF_BYPOSITION);
            }

            pcm->QueryContextMenu(hmenu, 0, idCmdFirst, idCmdLast, CMF_NODEFAULT|CMF_INCLUDESTATIC|CMF_FINDHACK);
            iItems = GetMenuItemCount(hmenu);
            if (!iItems) 
            {
                TraceMsg(TF_DOCFIND, "no menus in find extension, blowing away context menu");
                pcm->Release();
                pcm = NULL;
            }
        }
        RegCloseKey(hkFind);
    }
    return pcm;
}


void _SetObjectCount(IShellView *psv, int cItems, DWORD dwFlags)
{
    IShellFolderView *psfv;
    if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv)))) 
    {
        psfv->SetObjectCount(cItems, dwFlags);
        psfv->Release();
    }
}

typedef struct
{
    PFNLVCOMPARE pfnCompare;
    LPARAM       lParamSort;
} FIND_SORT_INFO;

int CALLBACK _FindCompareItems(void *p1, void *p2, LPARAM lParam)
{
    FIND_SORT_INFO *pfsi = (FIND_SORT_INFO*)lParam;
    return pfsi->pfnCompare(PtrToInt(p1), PtrToInt(p2), pfsi->lParamSort);
}

HRESULT CFindFolderViewCB::OnSortListData(DWORD pv, PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
{
    EnterCriticalSection(&_pff->_csSearch);

    // First mark the focused item in the list so we can find it later...
    FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, _iFocused);    // indirect
    if (pesfi)
        pesfi->dwState |= LVIS_FOCUSED;

    int cItems = DPA_GetPtrCount(_pff->_hdpaItems);
    HDPA hdpaForSorting = NULL;
    if (cItems)
    {
        hdpaForSorting = DPA_Create(cItems);
    }

    if (hdpaForSorting)
    {
        for (int i = 0; i< cItems; i++)
        {
            DPA_SetPtr(hdpaForSorting, i, IntToPtr(i));
        }
        // sort out items
        FIND_SORT_INFO fsi;
        fsi.pfnCompare = pfnCompare;
        fsi.lParamSort = lParamSort;

        DPA_Sort(hdpaForSorting, _FindCompareItems, (LPARAM)&fsi);
        for (i = 0; i < cItems; i++)
        {
            int iIndex = PtrToInt(DPA_FastGetPtr(hdpaForSorting, i));

            // Move the items from _hdpaItems to hdpaForSorting in sorted order
            DPA_SetPtr(hdpaForSorting, i, DPA_FastGetPtr(_pff->_hdpaItems, iIndex));
        }
        // Now switch the two HDPA to get the sorted list in the member variable
        DPA_Destroy(_pff->_hdpaItems);
        _pff->_hdpaItems = hdpaForSorting;
    }

    // Now find the focused item and scroll it into place...
    IShellView *psv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
    {
        int iFocused = -1;

        // Tell the view we need to reshuffle....
        // Gross, this one defaults to invalidate all which for this one is fine...
        _SetObjectCount(psv, cItems, SFVSOC_INVALIDATE_ALL); // Invalidate all

        for (int iEnd = cItems - 1; iEnd >= 0; iEnd--)
        {
            pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iEnd);    // indirect
            if (pesfi && pesfi->dwState & LVIS_FOCUSED)
                iFocused = iEnd;
        }
        // Now handle the focused item...
        if (iFocused != -1)
        {
            _pff->_iGetIDList = iFocused;   // remember the last one we retrieved...
            pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iFocused);    // indirect
            if (pesfi)
            {
                // flags depend on first one and also if selected?
                psv->SelectItem(&pesfi->idl, SVSI_FOCUSED | SVSI_ENSUREVISIBLE | SVSI_SELECT);
                pesfi->dwState &= ~LVIS_FOCUSED;    // don't keep it around to get lost later...
            }
        }

        _iFocused = iFocused;
        _fIgnoreSelChange = FALSE;
        psv->Release();
    }
    LeaveCriticalSection(&_pff->_csSearch);

    return S_OK;
}

HRESULT CFindFolderViewCB::OnMergeMenu(DWORD pv, QCMINFO*lP)
{
    DebugMsg(DM_TRACE, TEXT("sh TR - DF_FSNCallBack DVN_MERGEMENU"));

    UINT idCmdFirst = lP->idCmdFirst;

    UINT idBGMain = 0, idBGPopup = 0;
    _pff->_pfilter->GetFolderMergeMenuIndex(&idBGMain, &idBGPopup);
    CDefFolderMenu_MergeMenu(HINST_THISDLL, 0, idBGPopup, lP);

    // Lets remove some menu items that are not useful to us.
    HMENU hmenu = lP->hmenu;
    DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTE, MF_BYCOMMAND);
    DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTELINK, MF_BYCOMMAND);
    // DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTESPECIAL, MF_BYCOMMAND);

    // This is sortof bogus but if after the merge one of the
    // menus has no items in it, remove the menu.

    for (int i = GetMenuItemCount(hmenu) - 1; i >= 0; i--)
    {
        HMENU hmenuSub = GetSubMenu(hmenu, i);

        if (hmenuSub && (GetMenuItemCount(hmenuSub) == 0))
        {
            DeleteMenu(hmenu, i, MF_BYPOSITION);
        }
    }
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGETWORKINGDIR(DWORD pv, UINT wP, LPTSTR lP)
{
    HRESULT hr = E_FAIL;
    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        LPCITEMIDLIST *ppidls;      // pointer to a list of pidls.
        UINT cpidls = 0;            // Count of pidls that were returned.

        psfv->GetSelectedObjects(&ppidls, &cpidls);
        
        if (cpidls > 0)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_pff->GetParentsPIDL(ppidls[0], &pidl)))
            {
                SHGetPathFromIDList(pidl, lP);
                ILFree(pidl);
            }
            LocalFree((void *)ppidls);  // const -> non const
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
        psfv->Release();
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **ppstm)
{
    return _pff->_pfilter->GetColSaveStream(wP, ppstm);
}

HRESULT CFindFolderViewCB::OnGETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST *ppidl)
{
    FIND_ITEM *pesfi;

    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        *ppidl = &pesfi->idl;   // return alias!
        return S_OK;
    }

    *ppidl = NULL;
    return E_FAIL;
}

// in defviewx.c
STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage);

HRESULT CFindFolderViewCB::OnGetItemIconIndex(DWORD pv, WPARAM iItem, int *piIcon)
{
    FIND_ITEM *pesfi;

    *piIcon = -1;
    
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        if (pesfi->iIcon == -1)
        {
            IShellFolder* psf = (IShellFolder*)_pff;
            SHGetIconFromPIDL(psf, NULL, &pesfi->idl, 0, &pesfi->iIcon);
        }

        *piIcon = pesfi->iIcon;
        return S_OK;
    }

    return E_FAIL;
}


HRESULT CFindFolderViewCB::OnSetItemIconOverlay(DWORD pv, WPARAM iItem, int iOverlayIndex)
{
    HRESULT hr = E_FAIL;
    FIND_ITEM *pesfi;
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        pesfi->dwMask |= ESFITEM_ICONOVERLAYSET;
        pesfi->dwState |= INDEXTOOVERLAYMASK(iOverlayIndex) & LVIS_OVERLAYMASK;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFindFolderViewCB::OnGetItemIconOverlay(DWORD pv, WPARAM iItem, int * piOverlayIndex)
{
    HRESULT hr = E_FAIL;
    *piOverlayIndex = SFV_ICONOVERLAY_DEFAULT;
    FIND_ITEM *pesfi;
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        if (pesfi->dwMask & ESFITEM_ICONOVERLAYSET)
        {
            *piOverlayIndex = OVERLAYMASKTO1BASEDINDEX(pesfi->dwState & LVIS_OVERLAYMASK);
        }
        else
            *piOverlayIndex = SFV_ICONOVERLAY_UNSET;
        hr = S_OK;
    }

    return hr;
}


HRESULT CFindFolderViewCB::OnSETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST pidl)
{
    FIND_ITEM *pesfi;

    _pff->_iGetIDList = (int) iItem;   // remember the last one we retrieved...    

    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        FIND_ITEM *pesfiNew;
        
        if (SUCCEEDED(_pff->AddPidl((int) iItem, pidl, 0, &pesfiNew) && pesfiNew)) 
        {
            pesfiNew->dwState = pesfi->dwState;
            LocalFree((HLOCAL)pesfi);   // Free the old one...
        }
        return S_OK;
    }

    return E_FAIL;
}

BOOL DF_ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL bRet = (pidl1 == pidl2);

    if (!bRet)
    {
        PCHIDDENDOCFINDDATA phdfd1 = (PCHIDDENDOCFINDDATA) ILFindHiddenID(pidl1, IDLHID_DOCFINDDATA);
        PCHIDDENDOCFINDDATA phdfd2 = (PCHIDDENDOCFINDDATA) ILFindHiddenID(pidl2, IDLHID_DOCFINDDATA);

        if (phdfd1 && phdfd2)
            bRet = (phdfd1->iFolder == phdfd2->iFolder) && ILIsEqual(pidl1, pidl2);
    }
    return bRet;
}

HRESULT CFindFolderViewCB::OnGetIndexForItemIDList(DWORD pv, int * piItem, LPITEMIDLIST pidl)
{
    int cItems;

    // Try to short circuit searching for pidls...
    if (SUCCEEDED(_pff->GetItemCount(&cItems)) && _pff->_iGetIDList < cItems)
    {
        FIND_ITEM *pesfi;
                
        if (SUCCEEDED(_pff->GetItem(_pff->_iGetIDList, &pesfi)) && pesfi)
        {
            if (DF_ILIsEqual(&pesfi->idl, pidl))
            {
                // Yep it was ours so return the index quickly..
                *piItem = _pff->_iGetIDList;
                return S_OK;
            }
        }
    }

    // Otherwise let it search the old fashion way...
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnDeleteItem(DWORD pv, LPCITEMIDLIST pidl)
{
    // We simply need to remove this item from our list.  The
    // underlying listview will decrement the count on their end...
    FIND_ITEM *pesfi;
    int iItem;
    int cItems;
    BOOL bFound;

    if (!pidl)
    {
        _pff->SetAsyncEnum(NULL);
        return S_OK;     // special case telling us all items deleted...
    }

    bFound = FALSE;
    
    if (SUCCEEDED(_pff->GetItem(_pff->_iGetIDList, &pesfi)) 
        && pesfi
        && (DF_ILIsEqual(&pesfi->idl, pidl)))
    {
        iItem = _pff->_iGetIDList;
        bFound = TRUE;
    }
    else
    {
        if (SUCCEEDED(_pff->GetItemCount(&cItems))) 
        {
            for (iItem = 0; iItem < cItems; iItem++)
            {                
                if (SUCCEEDED(_pff->GetItem(iItem, &pesfi)) && pesfi && (DF_ILIsEqual(&pesfi->idl, pidl)))
                {
                    bFound = TRUE;
                    break;
                }
            }
        }
    }

    if (bFound)
    {
        _pff->DeleteItem(iItem);
    }

    return S_OK;
}

HRESULT CFindFolderViewCB::OnODFindItem(DWORD pv, int * piItem, NM_FINDITEM* pnmfi)
{
    // We have to do the subsearch ourself to find the correct item...
    // As the listview has no information saved in it...

    int iItem = pnmfi->iStart;
    int cItem;
    UINT flags = pnmfi->lvfi.flags;

    if (FAILED(_pff->GetItemCount(&cItem))) 
        return E_FAIL;

    if ((flags & LVFI_STRING) == 0)
        return E_FAIL;      // Not sure what type of search this is...

    int cbString = lstrlen(pnmfi->lvfi.psz);

    for (int j = cItem; j-- != 0;)
    {
        if (iItem >= cItem)
        {
            if (flags & LVFI_WRAP)
                iItem = 0;
            else
                break;
        }

        // Now we need to get the Display name for this item...
        FIND_ITEM *pesfi;
        TCHAR szPath[MAX_PATH];
        IShellFolder* psf = (IShellFolder*)_pff;

        if (SUCCEEDED(_pff->GetItem(iItem, &pesfi)) && pesfi && 
            SUCCEEDED(DisplayNameOf(psf, &pesfi->idl, NULL, szPath, ARRAYSIZE(szPath))))
        {
            if (flags & (LVFI_PARTIAL|LVFI_SUBSTRING))
            {
                if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pnmfi->lvfi.psz, cbString, szPath, cbString) == 2)
                {
                    *piItem = iItem;
                    return S_OK;
                }
            }
            else if (lstrcmpi(pnmfi->lvfi.psz, szPath) == 0)
            {
                *piItem = iItem;
                return S_OK;
            }
        }

        ++iItem;
    }
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA *lP)
{
    // Try to remember which item is focused...
    if (lP->uNewState & LVIS_FOCUSED)
        _iFocused = wPh;

    return S_OK;
}

HRESULT CFindFolderViewCB::OnSetEmptyText(DWORD pv, UINT res, LPCTSTR pszText)
{
    if (pszText && 0 == lstrcmp(_szEmptyText, pszText))
        return S_OK;

    lstrcpyn(_szEmptyText, pszText ? pszText : TEXT(""), ARRAYSIZE(_szEmptyText));

    HWND hwndLV = ListviewFromViewUnk(_punkSite);
    if (hwndLV)
        SendMessage(hwndLV, LVM_RESETEMPTYTEXT, 0, 0);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetEmptyText(DWORD pv, UINT cchTextMax, LPTSTR pszText)
{
    if (_szEmptyText[0])
    {
        lstrcpyn(pszText, _szEmptyText, cchTextMax);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_FINDVIEWEMPTYINIT, pszText, cchTextMax);
    }
    return S_OK;
}

HRESULT CFindFolderViewCB::OnReArrange(DWORD pv, LPARAM lparam)
{   
    UINT nCol = (UINT)lparam;

    // See if there is any controller object registered that may want to take over this...
    // if we are in a mixed query and we have already fetched the async items, simply sort
    // the dpa's...
    IFindEnum *pidfenum;
    if (S_OK == _pff->GetAsyncEnum(&pidfenum))
    {
        if (!((pidfenum->FQueryIsAsync() == DF_QUERYISMIXED) && _pff->_fAllAsyncItemsCached))
        {
            if (_pff->_pfcn)
            {
                // if they return S_FALSE it implies that they handled it and they do not
                // want the default processing to happen...
                if (_pff->_pfcn->DoSortOnColumn(nCol, _iColSort == nCol) == S_FALSE)
                {
                    _iColSort = nCol;
                    return S_OK;
                }
            }
            else 
            {
                // If we are running in the ROWSET way, we may want to have the ROWSET do the work...
                // pass one we spawn off a new search with the right column sorted
                if (_iColSort != nCol)
                {
                    _iColSort = nCol;      
                }
    
                // Warning the call above may release our AsyncEnum and generate a new one so
                // Don't rely on it's existence here...
                return S_OK;
            }
        }

        // we must pull in all the results from ci
        if (pidfenum->FQueryIsAsync() && !_pff->_fAllAsyncItemsCached)
            _pff->CacheAllAsyncItems();

#ifdef DEBUG
#define MAX_LISTVIEWITEMS  (100000000 & ~0xFFFF)
#define SANE_ITEMCOUNT(c)  ((int)min(c, MAX_LISTVIEWITEMS))
        if (pidfenum->FQueryIsAsync())
        {
            ASSERT(DPA_GetPtrCount(_pff->_hdpaItems) >= SANE_ITEMCOUNT(_pff->_cAsyncItems));
            for (int i = 0; i < SANE_ITEMCOUNT(_pff->_cAsyncItems); i++)
            {
                FIND_ITEM *pesfi = (FIND_ITEM *)DPA_GetPtr(_pff->_hdpaItems, i);

                ASSERT(pesfi);
                if (!pesfi)
                {
                    ASSERT(SUCCEEDED(_pff->GetItem(i, &pesfi)));
                }
            }
        }
#endif
    }

    // Use the common sort.
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnWindowCreated(DWORD pv, HWND hwnd)
{
    _ProfferService(TRUE);  // register our service w/ top level container
    return S_OK;
}

HRESULT CFindFolderViewCB::_ProfferService(BOOL bProffer)
{
    HRESULT hr = E_FAIL;

    if (bProffer)
    {
        //  shouldn't be redundantly registering our service
        ASSERT(NULL == _pps);
        ASSERT(-1 == _dwServiceCookie);
            
        IProfferService* pps;
        hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IProfferService, &pps));
        if (SUCCEEDED(hr))
        {
            hr = pps->ProfferService(SID_DocFindFolder, this, &_dwServiceCookie);
            if (SUCCEEDED(hr))
            {
                pps->AddRef();
                _pps = pps;
            }
            pps->Release();
        }
    }
    else
    {
        if (NULL == _pps)
        {
            hr = S_OK;
        }
        else
        {
            hr = _pps->RevokeService(_dwServiceCookie);
            if (SUCCEEDED(hr))
            {
                ATOMICRELEASE(_pps);
                _dwServiceCookie = -1;
            }
        }
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnWindowDestroy(DWORD pv, HWND wP)
{
    _ProfferService(FALSE); // unregister our service w/ top level container

    if (_pff->_pfcn)
        _pff->_pfcn->StopSearch();

    // The search may have a circular set of pointers.  So call the 
    // delete items and folders here to remove these back references...
    _pff->ClearItemList();
    _pff->ClearFolderList();

    IFindControllerNotify *pfcn;
    if (_pff->GetControllerNotifyObject(&pfcn) == S_OK)
    {
        pfcn->ViewDestroyed();
        pfcn->Release();
    }
    return S_OK;
}

HRESULT CFindFolderViewCB::OnIsOwnerData(DWORD pv, DWORD *pdwFlags)
{
    *pdwFlags |= FWF_OWNERDATA; // we want virtual defview support
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetODRangeObject(DWORD pv, WPARAM wWhich, ILVRange **plvr)
{
    HRESULT hr = E_FAIL;
    switch (wWhich)
    {
    case LVSR_SELECTION:
        hr = _pff->_dflvrSel.QueryInterface(IID_PPV_ARG(ILVRange, plvr));
        break;
    case LVSR_CUT:
        hr = _pff->_dflvrCut.QueryInterface(IID_PPV_ARG(ILVRange, plvr));
        break;
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnODCacheHint(DWORD pv, NMLVCACHEHINT* pnmlvc)
{
    // The listview is giving us a hint of the items it is about to do something in a range
    // so make sure we have pidls for each of the items in the range...
    int iTo;
    
    _pff->GetItemCount(&iTo);
    if (iTo >= pnmlvc->iTo)
        iTo = pnmlvc->iTo;
    else
        iTo--;

    for (int i = pnmlvc->iFrom; i <= iTo; i++)
    {
        FIND_ITEM *pesfi;
        if (FAILED(_pff->GetItem(i, &pesfi)))
            break;
    }

    return S_OK;
}

HRESULT CFindFolderViewCB::OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP)
{
    *lP = FVM_DETAILS;  // match the advanced mode of SC (+ Win2K parity)
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_DETAILS | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CFindFolderViewCB::_OnOpenContainingFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFindFolderViewCB* pThis = (CFindFolderViewCB*)(void*)pv;
    return pThis->_pff->OpenContainingFolder(pThis->_punkSite);
}

const WVTASKITEM c_FindTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_SEARCH, IDS_HEADER_FIND_TT);
const WVTASKITEM c_FindTaskList[] =
{
    WVTI_ENTRY_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_OPENCONTAININGFOLDER, IDS_TASK_OPENCONTAININGFOLDER, 0, IDS_TASK_OPENCONTAININGFOLDER_TT, IDI_TASK_OPENCONTAININGFOLDER, NULL, CFindFolderViewCB::_OnOpenContainingFolder),
};

HRESULT CFindFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_FindTaskHeader, &(pData->pSpecialTaskHeader));

    LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_NETWORK) };
    CreateIEnumIDListOnCSIDLs(_pidl, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &pData->penumOtherPlaces);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_FindTaskList, ARRAYSIZE(c_FindTaskList), &pTasks->penumSpecialTasks);

    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme)
{
    ZeroMemory(pTheme, sizeof(*pTheme));

    pTheme->pszThemeID = L"search";
    
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetIPersistHistory(DWORD pv, IPersistHistory **ppph)
{
    // If they call us with ppph == NULL they simply want to know if we support
    // the history so return S_OK;
    if (ppph == NULL)
        return S_OK;

    // get the persist history from us and we hold folder and view objects
    *ppph = NULL;

    CFindPersistHistory *pdfph = new CFindPersistHistory();
    if (!pdfph)
        return E_OUTOFMEMORY;

    HRESULT hr = pdfph->QueryInterface(IID_PPV_ARG(IPersistHistory, ppph));
    pdfph->Release();
    return hr;
}

HRESULT CFindFolderViewCB::OnRefresh(DWORD pv, BOOL fPreRefresh)
{
    EnterCriticalSection(&_pff->_csSearch);

    _pff->_fInRefresh = BOOLIFY(fPreRefresh);
    // If we have old results tell defview the new count now...
    if (!fPreRefresh && _pff->_hdpaItems)
    {
        IShellFolderView *psfv;
        UINT cItems = DPA_GetPtrCount(_pff->_hdpaItems);
        if (cItems && _punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
        {   
            psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
            psfv->Release();
        }
    }
    LeaveCriticalSection(&_pff->_csSearch);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *phtd)
{
    if (IsOS(OS_ANYSERVER))
    {
        StrCpyW(phtd->wszHelpFile, L"find.chm");
    }
    else
    {
        StrCpyW(phtd->wszHelpTopic, L"hcp://services/subsite?node=Unmapped/Search");
    }
    return S_OK;
}

STDMETHODIMP CFindFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGETWORKINGDIR);
    HANDLE_MSG(0, SFVM_GETCOLSAVESTREAM, OnGETCOLSAVESTREAM);
    HANDLE_MSG(0, SFVM_GETITEMIDLIST, OnGETITEMIDLIST);
    HANDLE_MSG(0, SFVM_SETITEMIDLIST, OnSETITEMIDLIST);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_INDEXOFITEMIDLIST, OnGetIndexForItemIDList);
    HANDLE_MSG(0, SFVM_DELETEITEM, OnDeleteItem);
    HANDLE_MSG(0, SFVM_ODFINDITEM, OnODFindItem);
    HANDLE_MSG(0, SFVM_ARRANGE, OnReArrange);
    HANDLE_MSG(0, SFVM_GETEMPTYTEXT, OnGetEmptyText);
    HANDLE_MSG(0, SFVM_SETEMPTYTEXT, OnSetEmptyText);
    HANDLE_MSG(0, SFVM_GETITEMICONINDEX, OnGetItemIconIndex);
    HANDLE_MSG(0, SFVM_SETICONOVERLAY, OnSetItemIconOverlay);
    HANDLE_MSG(0, SFVM_GETICONOVERLAY, OnGetItemIconOverlay);
    HANDLE_MSG(0, SFVM_FOLDERSETTINGSFLAGS, OnIsOwnerData);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWindowDestroy);
    HANDLE_MSG(0, SFVM_GETODRANGEOBJECT, OnGetODRangeObject);
    HANDLE_MSG(0, SFVM_ODCACHEHINT, OnODCacheHint);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDEFVIEWMODE);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTHEME, OnGetWebViewTheme);
    HANDLE_MSG(0, SFVM_GETIPERSISTHISTORY, OnGetIPersistHistory);
    HANDLE_MSG(0, SFVM_REFRESH, OnRefresh);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_SORTLISTDATA, OnSortListData);

    default:
        return E_FAIL;
    }

    return S_OK;
}

CFindFolderViewCB::CFindFolderViewCB(CFindFolder* pff) : 
    CBaseShellFolderViewCB(pff->_pidl, 0), _pff(pff), _fIgnoreSelChange(FALSE),
    _iColSort((UINT)-1), _iFocused((UINT)-1), _cSelected(0), _pps(NULL), _dwServiceCookie(-1)
{
    _pff->AddRef();
}

CFindFolderViewCB::~CFindFolderViewCB()
{
    _pff->Release();
    ASSERT(NULL == _pps);
    ASSERT(_dwServiceCookie == -1);
}

// give the find command code access to defview via this QS that we proffered

HRESULT CFindFolderViewCB::QueryService(REFGUID guidService, REFIID riid, void **ppv) 
{ 
    HRESULT hr = E_NOTIMPL;
    *ppv = NULL;
    if (guidService == SID_DocFindFolder)
    {
        hr = IUnknown_QueryService(_punkSite, SID_DefView, riid, ppv);
    }
    return hr;
}

CFindPersistHistory::CFindPersistHistory()
{
}

STDAPI CFindPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CFindPersistHistory *pdfph = new CFindPersistHistory();
    if (pdfph)
    {
        hr = pdfph->QueryInterface(riid, ppv);
        pdfph->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;    
}


// Functions to support persisting the document into the history stream...
STDMETHODIMP CFindPersistHistory::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DocFindPersistHistory;
    return S_OK;
}

IFindFolder *CFindPersistHistory::_GetDocFindFolder()
{
    IFindFolder *pdff = NULL;

    // the _punksite is to the defview so we can simply QI for frame...
    IFolderView *pfv;
    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv)))) 
    {
        pfv->GetFolder(IID_PPV_ARG(IFindFolder, &pdff));
        pfv->Release();
    }

    return pdff;
}

STDMETHODIMP CFindPersistHistory::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    int cItems = 0;
    IFindFolder *pdff = _GetDocFindFolder();
    if (pdff)
    {
        pdff->RestoreFolderList(pstm);
        pdff->RestoreItemList(pstm, &cItems);
        pdff->Release();
    }

    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
        psfv->Release();
    }

    // call our base class to allow it to restore it's stuff as well.
    return CDefViewPersistHistory::LoadHistory(pstm, pbc);
}


STDMETHODIMP CFindPersistHistory::SaveHistory(IStream *pstm)
{
    IFindFolder *pdff = _GetDocFindFolder();
    if (pdff)
    {
        pdff->SaveFolderList(pstm);       
        pdff->SaveItemList(pstm);       
        pdff->Release();
    }
    // Let base class save out as well
    return CDefViewPersistHistory::SaveHistory(pstm);
}

// use to manage the selection states for an owner data listview...

STDMETHODIMP_(ULONG) CFindLVRange::AddRef()
{
    return _pff->AddRef();
}
STDMETHODIMP_(ULONG) CFindLVRange::Release()
{ 
    return _pff->Release();
}

STDMETHODIMP CFindLVRange::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindLVRange, ILVRange),          // IID_ILVRange
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// ILVRange methods
STDMETHODIMP CFindLVRange::IncludeRange(LONG iBegin, LONG iEnd)
{
    // Including the range must load the elements as we need the object ptr...
    FIND_ITEM *pesfi;
    int  iTotal;

    _pff->GetItemCount(&iTotal);
    if (iEnd > iTotal)
        iEnd = iTotal-1;
        
    for (long i = iBegin; i <= iEnd;i++)
    {
        if (SUCCEEDED(_pff->GetItem(i, &pesfi)) && pesfi)
        {
            if ((pesfi->dwState & _dwMask) == 0)
            {
                _cIncluded++;
                pesfi->dwState |= _dwMask;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CFindLVRange::ExcludeRange(LONG iBegin, LONG iEnd)    
{
    // Excluding the range is OK to not load the elements as this would be to deslect all...

    EnterCriticalSection(&_pff->_csSearch);
    if (iEnd >= DPA_GetPtrCount(_pff->_hdpaItems))
        iEnd = DPA_GetPtrCount(_pff->_hdpaItems) - 1;

    for (long i = iBegin; i <= iEnd; i++)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_pff->_hdpaItems, i);
        if (pesfi)
        {
            if (pesfi->dwState & _dwMask)
            {
                _cIncluded--;
                pesfi->dwState &= ~_dwMask;
            }
        }
    }
    LeaveCriticalSection(&_pff->_csSearch);

    return S_OK;
}

STDMETHODIMP CFindLVRange::InvertRange(LONG iBegin, LONG iEnd)
{
    // Including the range must load the elements as we need the object ptr...
    int iTotal;

    _pff->GetItemCount(&iTotal);
    if (iEnd > iTotal)
        iEnd = iTotal-1;

    for (long i = iBegin; i <= iEnd;i++)
    {
        FIND_ITEM *pesfi;
        if (SUCCEEDED(_pff->GetItem(i, &pesfi)) && pesfi)
        {
            if ((pesfi->dwState & _dwMask) == 0)
            {
                _cIncluded++;
                pesfi->dwState |= _dwMask;
            }
            else
            {
                _cIncluded--;
                pesfi->dwState &= ~_dwMask;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CFindLVRange::InsertItem(LONG iItem)
{
    // We already maintain the list anyway...
    return S_OK;
}

STDMETHODIMP CFindLVRange::RemoveItem(LONG iItem)
{
    // We maintain the list so don't do anything...
    return S_OK;
}

STDMETHODIMP CFindLVRange::Clear()
{
    // If there are things selected, need to unselect them now...
    if (_cIncluded)
        ExcludeRange(0, LONG_MAX);

    _cIncluded = 0;
    _pff->ClearSaveStateList();
    return S_OK;
}

STDMETHODIMP CFindLVRange::IsSelected(LONG iItem)
{
    // Don't force the items to be generated if they were not before...
    HRESULT hr = S_FALSE;

    EnterCriticalSection(&_pff->_csSearch);
    FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
    if (pesfi)
        hr = pesfi->dwState & _dwMask ? S_OK : S_FALSE;
    LeaveCriticalSection(&_pff->_csSearch);

    // Assume not selected if we don't have the item yet...
    return hr;
}

STDMETHODIMP CFindLVRange::IsEmpty()
{
    return _cIncluded ? S_FALSE : S_OK;
}

STDMETHODIMP CFindLVRange::NextSelected(LONG iItem, LONG *piItem)
{
    EnterCriticalSection(&_pff->_csSearch);
    LONG cItems = DPA_GetPtrCount(_pff->_hdpaItems);

    while (iItem < cItems)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
        if (pesfi && (pesfi->dwState & _dwMask))
        {
            *piItem = iItem;
            LeaveCriticalSection(&_pff->_csSearch);
            return S_OK;
        }
        iItem++;
    }
    LeaveCriticalSection(&_pff->_csSearch);
    *piItem = -1;
    return S_FALSE;
}

STDMETHODIMP CFindLVRange::NextUnSelected(LONG iItem, LONG *piItem)
{
    EnterCriticalSection(&_pff->_csSearch);
    LONG cItems = DPA_GetPtrCount(_pff->_hdpaItems);

    while (iItem < cItems)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
        if (!pesfi || ((pesfi->dwState & _dwMask) == 0))
        {
            *piItem = iItem;
            LeaveCriticalSection(&_pff->_csSearch);
            return S_OK;
        }
        iItem++;
    }
    LeaveCriticalSection(&_pff->_csSearch);
    *piItem = -1;
    return S_FALSE;
}

STDMETHODIMP CFindLVRange::CountIncluded(LONG *pcIncluded)
{
    *pcIncluded = _cIncluded;

    // Sortof Gross, but if looking at selection then also include the list of items
    // that are selected in our save list...
    if (_dwMask & LVIS_SELECTED)
        *pcIncluded += _pff->_cSaveStateSelected;
    return S_OK;
}


// Define OleDBEnum translation structure...
typedef struct _dfodbet         // DFET for short
{
    struct _dfodbet *pdfetNext;
    LPWSTR  pwszFrom;
    int     cbFrom;
    LPWSTR  pwszTo;
} DFODBET;


class CContentIndexEnum : public IFindEnum, public IShellService
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt);
    STDMETHODIMP Reset();
    STDMETHODIMP StopSearch();
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCOl, BOOL fAscending);

    // IShellService
    STDMETHODIMP SetOwner(IUnknown* punkOwner);
    
    CContentIndexEnum(IFindFilter *pfilter, IFindFolder *pff, DWORD grfFlags, 
                      int iColSort,  LPTSTR pszProgressText, IRowsetWatchNotify *prwn);

    HRESULT DoQuery(LPWSTR *apwszPaths, UINT *pcPaths);

private:
    ~CContentIndexEnum();

    void HandleWatchNotify(DBWATCHNOTIFY eChangeReason);
    HRESULT _BuildAndSetCommandTree(int iCol, BOOL fReverse);
    HRESULT _SetCmdProp(ICommand *pCommand);
    HRESULT _MapColumns(IUnknown *punk, DBORDINAL cCols, DBBINDING *pBindings, const DBID * pDbCols, HACCESSOR &hAccessor);
    void _ReleaseAccessor();
    HRESULT _CacheRowSet(UINT iItem);
    BOOL _TranslateFolder(LPCWSTR pszParent, LPWSTR pszResult);
    void _ClearFolderState();

    LONG _cRef;
    IFindFilter *_pfilter;
    IRowsetWatchNotify *_prwn;
    IFindFolder *_pff;
    int _iColSort; 
    DWORD _grfFlags;
    DWORD _grfWarnings;
    LPTSTR _pszProgressText;

    TCHAR _szCurrentDir[MAX_PATH];
    IShellFolder *_psfCurrentDir;
    LPITEMIDLIST _pidlFolder;
    int _iFolder;

    HRESULT _hrCurrent;
    ICommand *_pCommand;
    IRowsetLocate *_pRowset;
    IRowsetAsynch *_pRowsetAsync;
    HACCESSOR   _hAccessor;
    HACCESSOR   _hAccessorWorkID;
    HROW        _ahrow[100];            // Cache 100 hrows out for now
    UINT        _ihrowFirst;            // The index of which row is cached out first
    DBCOUNTITEM _cRows;                 // number of hrows in _ahrow
    DFODBET     *_pdfetFirst;           // Name translation list.
};

STDAPI CreateOleDBEnum(IFindFilter *pfilter, IShellFolder *psf,
    LPWSTR *apwszPaths, UINT *pcPaths, DWORD grfFlags, int iColSort,
    LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppdfenum)
{
    *ppdfenum = NULL;
    HRESULT hr = E_OUTOFMEMORY;

    IFindFolder *pff;
    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff));

    CContentIndexEnum* pdfenum = new CContentIndexEnum(pfilter, pff, grfFlags, iColSort, pszProgressText, prwn);

    if (pdfenum)
    {
        hr = pdfenum->DoQuery(apwszPaths, pcPaths);
        if (hr == S_OK)       // We only continue to use this if query returne S_OK...
            *ppdfenum = (IFindEnum*)pdfenum;
        else
        {
            pdfenum->Release();     // release the memory we allocated
        }
    }

    if (pff)
        pff->Release();
    
    return hr;
}

const DBID c_aDbCols[] =
{
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_NAME}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_PATH}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_ATTRIBUTES}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_SIZE}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_WRITETIME}},
    {{PSGUID_QUERY_D}, DBKIND_GUID_PROPID, {(LPOLESTR)                  PROPID_QUERY_RANK}},
};

const DBID c_aDbWorkIDCols[] =
{
    {{PSGUID_QUERY_D}, DBKIND_GUID_PROPID, {(LPOLESTR)PROPID_QUERY_WORKID}}
};

const LPCWSTR c_awszColSortNames[] = {
    L"FileName[a],Path[a]", 
    L"Path[a],FileName[a]", 
    L"Size[a]", 
    NULL, 
    L"Write[a]", 
    L"Rank[d]"
};

const ULONG c_cDbCols = ARRAYSIZE(c_aDbCols);
const DBID c_dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
const GUID c_guidQueryExt = DBPROPSET_QUERYEXT;
const GUID c_guidRowsetProps = {0xc8b522be,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}; 

CContentIndexEnum::CContentIndexEnum(IFindFilter *pfilter, IFindFolder *pff,
    DWORD grfFlags, int iColSort,  LPTSTR pszProgressText, IRowsetWatchNotify *prwn) :
    _cRef(1), _ihrowFirst((UINT)-1), _pfilter(pfilter),
    _pff(pff), _prwn(prwn), _grfFlags(grfFlags),
    _grfWarnings(DFW_DEFAULT), _iColSort(iColSort), _pszProgressText(pszProgressText)
{
    _szCurrentDir[0] = 0;

    ASSERT(_pRowset == 0);
    ASSERT(_pRowsetAsync == 0);
    ASSERT(_pCommand == 0);
    ASSERT(_hAccessor == 0);
    ASSERT(_hAccessorWorkID ==0);
    ASSERT(_cRows == 0);

    if (_pfilter)
    {
        _pfilter->AddRef();
        _pfilter->GetWarningFlags(&_grfWarnings);
    }
        
    if (_pff)              
        _pff->AddRef();

    if (_prwn)
        _prwn->AddRef();
}

void CContentIndexEnum::_ClearFolderState()
{
    ATOMICRELEASE(_psfCurrentDir);
    ILFree(_pidlFolder);
    _pidlFolder = NULL;
    _iFolder = -1;
    _szCurrentDir[0] = 0;
}

CContentIndexEnum::~CContentIndexEnum()
{
    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_pff);
    ATOMICRELEASE(_prwn);

    _ClearFolderState();
        
    if (_pRowset)
    {
        ATOMICRELEASE(_pRowsetAsync);

        // Release any cached rows.
       _CacheRowSet((UINT)-1);
          
        if (_hAccessor || _hAccessorWorkID)
            _ReleaseAccessor();

        _pRowset->Release();
    }

    ATOMICRELEASE(_pCommand);

    // Release any name translations we may have allocated.
    DFODBET *pdfet = _pdfetFirst;
    while (pdfet)
    {
        DFODBET *pdfetT = pdfet;
        pdfet = pdfet->pdfetNext;      // First setup to look at the next item before we free stuff...
        LocalFree((HLOCAL)pdfetT->pwszFrom);
        LocalFree((HLOCAL)pdfetT->pwszTo);
        LocalFree((HLOCAL)pdfetT);
    }
}

HRESULT CContentIndexEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CContentIndexEnum, IUnknown, IFindEnum), // IID_IUNKNOWN
        QITABENT(CContentIndexEnum, IShellService),          // IID_IShellService
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CContentIndexEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CContentIndexEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CContentIndexEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState)
{
    return E_PENDING;       // as good a return as any to say that we are async...
}

HRESULT CContentIndexEnum::Skip(int celt)
{
    return E_NOTIMPL;
}

HRESULT CContentIndexEnum::Reset()
{
    // overload Reset to mean dump the rowset cache!!!
    _CacheRowSet(-1);    
    // still return failiure
    return E_NOTIMPL;
}

HRESULT CContentIndexEnum::StopSearch()
{
    // Lets see if we can find one that works...
    HRESULT hr = _pCommand->Cancel();
    if (FAILED(hr))
        hr = _pRowsetAsync->Stop();
    if (FAILED(hr))
    {
        IDBAsynchStatus *pdbas;
        if (SUCCEEDED(_pRowset->QueryInterface(IID_PPV_ARG(IDBAsynchStatus, &pdbas))))
        {
            hr = pdbas->Abort(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN);
            pdbas->Release();
        }
    }
    return hr; 
}

BOOL CContentIndexEnum::FQueryIsAsync()
{
    return TRUE;
}

HRESULT CContentIndexEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    if (!_pRowsetAsync)
        return E_FAIL;

    BOOL fMore;
    DBCOUNTITEM dwDen, dwNum;
    HRESULT hr = _pRowsetAsync->RatioFinished(&dwDen, &dwNum, pdwTotalAsync, &fMore);
    if (SUCCEEDED(hr))
    {
        *pfQueryDone = dwDen == dwNum;
        *pnPercentComplete = dwDen ? (int)((dwNum * 100) / dwDen) : 100;
    }
    else
        *pfQueryDone = TRUE;    // in case that is all they are looking at...
    return hr;
}

// modify pszPath until you can parse it, return result in *ppidl

HRESULT _StripToParseableName(LPTSTR pszPath, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    HRESULT hr = E_FAIL;

    PathRemoveBackslash(pszPath);
    while (PathRemoveFileSpec(pszPath) && FAILED(hr))
    {
        hr = SHParseDisplayName(pszPath, NULL, ppidl, 0, NULL);
    }
    return hr;
}

// we could not get pidl for this item for some reason.  we have to put 
// it in the list of bad items so that we can tell ci not to give it to
// us the next time we do search
void _ExcludeFromFutureSearch(LPCTSTR pszParent)
{
    HKEY hkey;

    TCHAR szParent[MAX_PATH];
    StrCpyN(szParent, pszParent, ARRAYSIZE(szParent));

    if (RegCreateKeyExW(HKEY_CURRENT_USER, CI_SPECIAL_FOLDERS, 0, L"", 0, KEY_WRITE | KEY_QUERY_VALUE, NULL, &hkey, NULL) == ERROR_SUCCESS)
    {
        LPITEMIDLIST pidlT;
        if (SUCCEEDED(_StripToParseableName(szParent, &pidlT)))
        {
            ILFree(pidlT);
        
            DWORD dwInsert = 0; // init to zero in case query info bellow fails
            int iEnd;
            TCHAR sz[MAX_PATH], szName[10];
            RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &dwInsert, NULL, NULL, NULL, NULL);
            // start from the end as there is a high chance we added this at the end
            for (int i = dwInsert - 1; i >= 0; i--)
            {                        
                DWORD cb = sizeof(sz);
            
                wsprintf(szName, L"%d", i);
                if (RegQueryValueEx(hkey, szName, NULL, NULL, (BYTE *)sz, &cb) == ERROR_SUCCESS)
                {
                    LPTSTR pszTemp = StrStrI(sz + 1, szParent); // +1 to pass " that's at the beginning of the string
                    if (pszTemp && pszTemp == sz + 1)
                    {
                        dwInsert = i; // overwrite this value
                        break;
                    }
                    else
                    {
                        iEnd = lstrlen(sz);
                        if (EVAL(iEnd > 1))
                        {
                            int iBackslash = iEnd - 3;
                            ASSERT(sz[iBackslash] == L'\\');
                            sz[iBackslash] = L'\0';
                            pszTemp = StrStrI(szParent, sz + 1);
                            sz[iBackslash] = L'\\';
                            if (pszTemp && pszTemp == szParent)
                            {
                                dwInsert = -1;
                                break;
                            }
                        }
                    }
                }
            }

            if (dwInsert != -1)
            {
                wsprintf(szName, L"%d", dwInsert);

                PathAppend(szParent, TEXT("*"));
                PathQuoteSpaces(szParent);
                RegSetValueEx(hkey, szName, 0, REG_SZ, (BYTE *)szParent, (lstrlen(szParent) + 1) * sizeof(szParent[0]));
            }
        }
        RegCloseKey(hkey);
    }
}

// If it is a UNC it might be one we need to translate, to handle the case that 
// content index does not support redirected drives.

BOOL CContentIndexEnum::_TranslateFolder(LPCTSTR pszParent, LPTSTR pszResult)
{
    BOOL fTranslated = FALSE;
    StrCpyW(pszResult, pszParent);  // default to the same
    if (PathIsUNC(pszParent))
    {
        for (DFODBET *pdfet = _pdfetFirst; pdfet; pdfet = pdfet->pdfetNext)
        {
            if ((StrCmpNIW(pszParent, pdfet->pwszFrom, pdfet->cbFrom) == 0)
                    && (pszParent[pdfet->cbFrom] == L'\\'))
            {
                // Ok we have a translation to use.
                fTranslated = TRUE;
                StrCpyW(pszResult, pdfet->pwszTo);
                // need + 1 here or we'll get something like w:\\winnt! bogus path, that is.
                StrCatW(pszResult, &pszParent[pdfet->cbFrom + 1]);
            }
        }
    }
    return fTranslated;
}

HRESULT CContentIndexEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr = _CacheRowSet(iItem);
    if (S_OK != hr)
    {
        return E_FAIL;    // we could not get the item someone asked for, so error...
    }

    PROPVARIANT* data[c_cDbCols];
    
    hr = _pRowset->GetData(_ahrow[iItem - _ihrowFirst], _hAccessor, &data);
    if (S_OK == hr)
    {
        // data[0].pwszVal is the file name
        // data[1].pwszVal is the full path (including file name)
        // data[2].ulVal is the attribute
        // data[3].ulVal is the size in byte
        // data[4].filetime is the last write time in UTC
        // data[5].ulVal is the rank of the item...

        WIN32_FIND_DATA fd = {0};

        fd.dwFileAttributes = data[2]->ulVal;
        fd.nFileSizeLow = data[3]->ulVal;
        fd.ftLastWriteTime = data[4]->filetime;

        ASSERT(ShowSuperHidden() || !IsSuperHidden(fd.dwFileAttributes));   // query should exclude these
        
        StrCpyW(fd.cFileName, data[0]->pwszVal);

        WCHAR szParent[MAX_PATH];
        StrCpyW(szParent, data[1]->pwszVal);    // full path
        PathRemoveFileSpec(szParent);           // strip to parent folder path
       
        WCHAR szTranslatedParent[MAX_PATH];
        BOOL fTranslated = _TranslateFolder(szParent, szTranslatedParent);
        
        if (lstrcmp(szParent, _szCurrentDir) != 0)
        {
            _ClearFolderState();    // our previous "current folder" state is now invalid

            hr = SHParseDisplayName(szTranslatedParent, NULL, &_pidlFolder, 0, NULL);
            if (SUCCEEDED(hr))
            { 
                hr = _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
                if (SUCCEEDED(hr))
                {
                    hr = _pff->GetFolder(_iFolder, IID_PPV_ARG(IShellFolder, &_psfCurrentDir));
                    if (SUCCEEDED(hr))
                    {
                        // on succesful init of this folder save the cache key
                        lstrcpy(_szCurrentDir, szParent);
                    }
                }
            }
            else if (hr != E_OUTOFMEMORY && !fTranslated)
            {
                _ExcludeFromFutureSearch(szParent);
            }
            _hrCurrent = hr;    // save error state for next time around

            if (FAILED(hr))
                _ClearFolderState();
        }
        else
        {
            hr = _hrCurrent;
        }

        if (SUCCEEDED(hr))
        {
            // success implies the state of these variables
            ASSERT((NULL != _psfCurrentDir) && (NULL != _pidlFolder) && (_iFolder > 0));

            DWORD dwItemID;
            GetItemID(iItem, &dwItemID);

            LPITEMIDLIST pidl;
            hr = SHSimpleIDListFromFindData2(_psfCurrentDir, &fd, &pidl);
            if (SUCCEEDED(hr))
            {
                hr = _pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_EXTRADATA, iItem, dwItemID, data[5]->ulVal, ppidl);
                ILFree(pidl);
            }
        }
        else 
        {
            // failure implies these should be clear
            ASSERT((NULL == _psfCurrentDir) && (NULL == _pidlFolder));

            LPITEMIDLIST pidlFull;
            if (SUCCEEDED(_StripToParseableName(szTranslatedParent, &pidlFull)))
            {
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(SplitIDList(pidlFull, &_pidlFolder, &pidlChild)))
                {
                    hr = _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pff->GetFolder(_iFolder, IID_PPV_ARG(IShellFolder, &_psfCurrentDir));
                        if (SUCCEEDED(hr))
                        {
                            hr = _pff->AddDataToIDList(pidlChild, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl);
                            if (SUCCEEDED(hr))
                            {
                                // on succesful init of this folder save the cache key
                                lstrcpy(_szCurrentDir, szTranslatedParent);
                                PathRemoveFileSpec(_szCurrentDir);
                            }
                        }
                    }
                }
                ILFree(pidlFull);

                if (FAILED(hr))
                    _ClearFolderState();
            }
        }
    }

    return hr;
}

HRESULT CContentIndexEnum::GetItemID(UINT iItem, DWORD *puItemID)
{
    *puItemID = (UINT)-1;
    HRESULT hr = _CacheRowSet(iItem);
    if (S_OK == hr)
    {
        PROPVARIANT* data[1];
        hr = _pRowset->GetData(_ahrow[iItem - _ihrowFirst], _hAccessorWorkID, &data);
        if (S_OK == hr)
        {
            // Only one data column so this is easy...
            // The ULVal is the thing we are after...
            *puItemID = data[0]->ulVal;
        }
    }
    return hr;
}

HRESULT CContentIndexEnum::SortOnColumn(UINT iCol, BOOL fAscending)
{
    // Ok We need to generate the Sort String... 
    return _BuildAndSetCommandTree(iCol, fAscending);             
}

HRESULT CContentIndexEnum::SetOwner(IUnknown* punkOwner)
{
    // Used to set the docfind folder and from that the filter.
    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_pff);

    if (punkOwner)
    {
        punkOwner->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
        if (_pff)
            _pff->GetFindFilter(&_pfilter);
    }
    return S_OK;
}

HRESULT CContentIndexEnum::_MapColumns(IUnknown *punk, DBORDINAL cCols,
                                  DBBINDING *pBindings, const DBID *pDbCols,
                                  HACCESSOR &hAccessor)
{
    DBORDINAL aMappedColumnIDs[c_cDbCols];

    IColumnsInfo *pColumnsInfo;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IColumnsInfo, &pColumnsInfo));
    if (SUCCEEDED(hr))
    {
        hr = pColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);
        if (SUCCEEDED(hr))
        {
            for (ULONG i = 0; i < cCols; i++)
                pBindings[i].iOrdinal = aMappedColumnIDs[i];

            IAccessor *pIAccessor;
            hr = punk->QueryInterface(IID_PPV_ARG(IAccessor, &pIAccessor));
            if (SUCCEEDED(hr))
            {
                hAccessor = 0;
                hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA, cCols, pBindings, 0, &hAccessor, 0);
                pIAccessor->Release();
            }
        }
        pColumnsInfo->Release();
    }

    return hr;
}

void CContentIndexEnum::_ReleaseAccessor()
{
    IAccessor *pIAccessor;
    HRESULT hr = _pRowset->QueryInterface(IID_PPV_ARG(IAccessor, &pIAccessor));
    if (SUCCEEDED(hr))
    {
        if (_hAccessor)
            pIAccessor->ReleaseAccessor(_hAccessor, 0);
        if (_hAccessorWorkID)
            pIAccessor->ReleaseAccessor(_hAccessorWorkID, 0);

        pIAccessor->Release();
    }
}

HRESULT CContentIndexEnum::_CacheRowSet(UINT iItem)
{
    HRESULT hr = S_OK;

    if (!_pRowset)
        return E_FAIL;
    
    if (!_cRows || !InRange(iItem, _ihrowFirst, _ihrowFirst+(UINT)_cRows-1) || (iItem == (UINT)-1))
    {
        // Release the last cached element we had.
        if (_cRows != 0)
            _pRowset->ReleaseRows(ARRAYSIZE(_ahrow), _ahrow, 0, 0, 0);

        // See if we are simply releasing our cached data...
        _cRows = 0;
        _ihrowFirst = (UINT)-1;
        if (iItem == (UINT)-1)
            return S_OK;

        // Ok try to read in the next on...
        BYTE bBookMark = (BYTE) DBBMK_FIRST;
        HROW *rghRows = (HROW *)_ahrow;

        // change this to fetch 100 or so rows at the time -- huge perf improvment
        hr = _pRowset->GetRowsAt(0, 0, sizeof(bBookMark), &bBookMark, iItem, ARRAYSIZE(_ahrow), &_cRows, &rghRows);
        if (FAILED(hr))
            return hr;
            
        _ihrowFirst = iItem;

        if ((DB_S_ENDOFROWSET == hr) || (_cRows == 0))
        {
            if (_cRows == 0)
                _ihrowFirst = -1;
            else
                hr = S_OK;  // we got some items and caller expects S_OK so change DB_S_ENDOFROWSET to noerror
        }
    }

    return hr;
}

void CContentIndexEnum::HandleWatchNotify(DBWATCHNOTIFY eChangeReason)
{
    // For now we will simply Acknoledge the change...
    if (_prwn)
        _prwn->OnChange(NULL, eChangeReason);
}

HRESULT CContentIndexEnum::_SetCmdProp(ICommand *pCommand)
{
#define MAX_PROPS 8

    DBPROPSET aPropSet[MAX_PROPS];
    DBPROP aProp[MAX_PROPS];
    ULONG cProps = 0;
    HRESULT hr;

    // asynchronous query

    aProp[cProps].dwPropertyID = DBPROP_IRowsetAsynch;
    aProp[cProps].dwOptions = 0;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_BOOL;
    aProp[cProps].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidRowsetProps;

    cProps++;

    // don't timeout queries

    aProp[cProps].dwPropertyID = DBPROP_COMMANDTIMEOUT;
    aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_I4;
    aProp[cProps].vValue.lVal = 0;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidRowsetProps;

    cProps++;

    // We can handle PROPVARIANTs

    aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_BOOL;
    aProp[cProps].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidQueryExt;

    cProps++;

    ICommandProperties * pCmdProp = 0;
    hr = pCommand->QueryInterface(IID_PPV_ARG(ICommandProperties, &pCmdProp));
    if (SUCCEEDED(hr))
    {
        hr = pCmdProp->SetProperties(cProps, aPropSet);
        pCmdProp->Release();
    }

    return hr;
}

// create the query command string

HRESULT CContentIndexEnum::_BuildAndSetCommandTree(int iCol, BOOL fReverse)
{
    LPWSTR pwszRestrictions = NULL;
    DWORD  dwGQRFlags;
    HRESULT hr = _pfilter->GenerateQueryRestrictions(&pwszRestrictions, &dwGQRFlags);
    if (SUCCEEDED(hr))
    {
        ULONG ulDialect;
        hr = _pfilter->GetQueryLanguageDialect(&ulDialect);
        if (SUCCEEDED(hr))
        {
            // NOTE: hard coded to our current list of columns
            WCHAR wszSort[80];      // use this to sort by different columns...
            wszSort[0] = 0;

            if ((iCol >= 0) && (iCol < ARRAYSIZE(c_awszColSortNames)) && c_awszColSortNames[iCol])
            {
                // Sort order is hardcoded for ascending.
                StrCpyW(wszSort, c_awszColSortNames[iCol]); 
                StrCatW(wszSort, L",Path[a],FileName[a]");
            }
        
            DBCOMMANDTREE *pTree = NULL;
            hr = CITextToFullTreeEx(pwszRestrictions, ulDialect, 
                L"FileName,Path,Attrib,Size,Write,Rank,WorkID",
                wszSort[0] ? wszSort : NULL, 0, &pTree, 0, 0, LOCALE_USER_DEFAULT);
            if (FAILED(hr)) 
            {
                // Map this to one that I know about
                // Note: We will only do this if we require CI else we will try to fallback to old search...
                // Note we are running into problems where CI says we are contained in a Catalog even if
                // CI process is not running... So try to avoid this if possible
                if (dwGQRFlags & GQR_REQUIRES_CI)
                    hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_CONSTRAINT);
            }

            if (SUCCEEDED(hr))
            {
                ICommandTree *pCmdTree;
                hr = _pCommand->QueryInterface(IID_PPV_ARG(ICommandTree, &pCmdTree));
                if (SUCCEEDED(hr))
                {    
                    hr = pCmdTree->SetCommandTree(&pTree, DBCOMMANDREUSE_NONE, FALSE);
                    pCmdTree->Release();
                }
            }
        }
    }
    LocalFree((HLOCAL)pwszRestrictions);
    return hr;
}

#define cbP (sizeof (PROPVARIANT *))

// [in, out] apwszPaths this is modified
// [in, out] pcPaths

HRESULT CContentIndexEnum::DoQuery(LPWSTR *apwszPaths, UINT *pcPaths)
{
    UINT nPaths = *pcPaths;
    WCHAR** aScopes = NULL;
    WCHAR** aScopesOrig = NULL;
    ULONG* aDepths = NULL;
    WCHAR** aCatalogs = NULL;
    WCHAR** aMachines = NULL;
    WCHAR wszPath[MAX_PATH];
    LPWSTR pwszPath = wszPath;
    LPWSTR pszMachineAlloc = NULL, pszCatalogAlloc = NULL;
    LPWSTR pwszMachine, pwszCatalog;
    UINT i, iPath = 0;
    DWORD dwQueryRestrictions;

    // Initiailize all of our query values back to unused 
    _hAccessor = NULL;
    _hAccessorWorkID = NULL;
    _pRowset = NULL;
    _pRowsetAsync = NULL;
    _pCommand = NULL;

    // Get array of search paths...
#define MAX_MACHINE_NAME_LEN    32

    BOOL fIsCIRunning, fCiIndexed, fCiPermission;
    GetCIStatus(&fIsCIRunning, &fCiIndexed, &fCiPermission);

    // First pass see if we have anything that make use at all of CI if not lets simply bail and let
    // old code walk the list...
    HRESULT hr = _pfilter->GenerateQueryRestrictions(NULL, &dwQueryRestrictions);
    if (FAILED(hr))
        goto Abort;

    if ((dwQueryRestrictions & GQR_MAKES_USE_OF_CI) == 0)
    {
        hr = S_FALSE;
        goto Abort;
    }

    // allocate the arrays that we need to pass to CIMakeICommand and
    // the buffers needed for the machine name and catalog name
    aDepths = (ULONG*)LocalAlloc(LPTR, nPaths * sizeof(ULONG));
    aScopes = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aScopesOrig = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aCatalogs = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aMachines = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    pszMachineAlloc = pwszMachine = (LPWSTR)LocalAlloc(LPTR, nPaths * MAX_MACHINE_NAME_LEN * sizeof(WCHAR));
    pszCatalogAlloc = pwszCatalog = (LPWSTR)LocalAlloc(LPTR, nPaths * MAX_PATH * sizeof(WCHAR));

    if (!aDepths || !aScopes || !aScopesOrig || !aCatalogs ||
        !aMachines || !pszMachineAlloc || !pszCatalogAlloc)
    {
        hr = E_OUTOFMEMORY;
        goto Abort;
    }

    // This following loop does two things,
    //  1. Check if all the scopes are indexed, if any one scope is not,
    //      fail the call and we'll do the win32 find.
    //  2. Prepare the arrays of parameters that we need to pass to
    //      CIMakeICommand().
    //
    // NOTE: Reinerf says this code looks busted for nPaths > 1.  See bug 199254 for comments.
    for (i = 0; i < nPaths; i++)
    {
        ULONG cchMachine = MAX_MACHINE_NAME_LEN;
        ULONG cchCatalog = MAX_PATH;
        WCHAR wszUNCPath[MAX_PATH];
        BOOL fRemapped = FALSE;

        // if CI is not running we can still do ci queries on a remote drive (if it is  indexed)
        // so we cannot just bail if ci is not running on user's machine
        if (!fIsCIRunning && !PathIsRemote(apwszPaths[i]))
            continue;  // do grep on this one

        hr = LocateCatalogsW(apwszPaths[i], 0, pwszMachine, &cchMachine, pwszCatalog, &cchCatalog);
        if (hr != S_OK)
        {
            // see if by chance this is a network redirected drive.  If so we CI does not handle
            // these.  See if we can remap to UNC path to ask again...
            if (!PathIsUNC(apwszPaths[i]))
            {
                DWORD nLength = ARRAYSIZE(wszUNCPath);
                // this api takes TCHAR, but we only compile this part for WINNT...
                DWORD dwType = SHWNetGetConnection(apwszPaths[i], wszUNCPath, &nLength);
                if ((dwType == NO_ERROR) || (dwType == ERROR_CONNECTION_UNAVAIL))
                {
                    fRemapped = TRUE;
                    LPWSTR pwsz = PathSkipRootW(apwszPaths[i]);
                    if (pwsz)
                        PathAppendW(wszUNCPath, pwsz);

                    cchMachine = MAX_MACHINE_NAME_LEN;  // reset in params
                    cchCatalog = MAX_PATH;

                    hr = LocateCatalogsW(wszUNCPath, 0, pwszMachine, &cchMachine, pwszCatalog, &cchCatalog);
                }
            }
        }
        if (hr != S_OK)
        {
            continue;   // this one is not indexed.
        }

        if (S_FALSE == CatalogUptodate(pwszCatalog, pwszMachine))
        {
            // not up todate
            if (dwQueryRestrictions & GQR_REQUIRES_CI)
            {
                // ci not up to date and we must use it..
                // inform the user that results may not be complete
                if (!(_grfWarnings & DFW_IGNORE_INDEXNOTCOMPLETE))
                {
                    hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_INDEXNOTCOMPLETE);
                    goto Abort;
                }
                //else use ci although index is not complete
            }
            else
            {
                // ci is not upto date so just use grep for this drive so user can get
                // complete results
                pwszCatalog[0] = 0; 
                pwszMachine[0] = 0;
                continue;
            }
        }

        aDepths[iPath] = (_grfFlags & DFOO_INCLUDESUBDIRS) ? QUERY_DEEP : QUERY_SHALLOW;
        aScopesOrig[iPath] = apwszPaths[i];
        if (fRemapped)
        {
            aScopes[iPath] = StrDupW(wszUNCPath);
            if (aScopes[iPath] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Abort;
            }
        }
        else
        {
            aScopes[iPath] = apwszPaths[i];
        }

        aCatalogs[iPath] = pwszCatalog;
        aMachines[iPath] = pwszMachine;
        
        pwszCatalog += MAX_PATH;    // advance the catalog and machine name buffer
        pwszMachine += MAX_MACHINE_NAME_LEN;
        iPath++;    // next item in this list
    }

    if (iPath == 0) 
    {
        // no catalogs found;  - We should check to see if by chance the user specified a query that
        // is CI based if so error apapropriately...
        hr = (dwQueryRestrictions & GQR_REQUIRES_CI) ? MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_INDEXSEARCH) : S_FALSE;
        goto Abort;
    }

    // Get ICommand.
    hr = CIMakeICommand(&_pCommand, iPath, aDepths, aScopes, aCatalogs, aMachines);
    if (SUCCEEDED(hr))
    {
        // create the query command string - Assume default sort...
        hr = _BuildAndSetCommandTree(_iColSort, FALSE);
        if (SUCCEEDED(hr))
        {
            if ((dwQueryRestrictions & GQR_REQUIRES_CI) && (nPaths != iPath))
            {
                // check warning flags to see if we should ignore and continue
                if (0 == (_grfWarnings & DFW_IGNORE_CISCOPEMISMATCH))
                {
                    hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_SCOPEMISMATCH);
                }
            }

            if (SUCCEEDED(hr))
            {
                // Get IRowset.
                _SetCmdProp(_pCommand);
                hr = _pCommand->Execute(0, IID_IRowsetLocate, 0, 0, (IUnknown **)&_pRowset);
                if (SUCCEEDED(hr))
                {
                    // we have the IRowset.
                    // Real work to get the Accessor
                    DBBINDING aPropMainCols[c_cDbCols] =
                    {
                        { 0,cbP*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*1,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*2,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*3,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*4,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*5,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 }
                    };

                    hr = _MapColumns(_pRowset, c_cDbCols, aPropMainCols, c_aDbCols, _hAccessor);
                    if (SUCCEEDED(hr))
                    {
                        // OK lets also get the accessor for the WorkID...
                        hr = _MapColumns(_pRowset, ARRAYSIZE(c_aDbWorkIDCols), aPropMainCols, c_aDbWorkIDCols, _hAccessorWorkID);
                        if (SUCCEEDED(hr))
                        {
                            hr = _pRowset->QueryInterface(IID_PPV_ARG(IRowsetAsynch, &_pRowsetAsync));
                        }
                    }
                }
            }
        }
    }

    if (FAILED(hr))
        goto Abort;

    // If we got here than at least some of our paths are indexed
    // we may need to compress the list down of the ones we did not handle...
    *pcPaths = (nPaths - iPath);  // Let caller know how many we did not process

    // need to move all the ones we did not process to the start of the list...
    // we always process this list here as we may need to allocate translation lists to be used to
    // translate the some UNCS back to the mapped drive the user passed in.

    UINT j = 0, iInsert = 0;
    iPath--;    // make it easy to detect 
    for (i = 0; i < nPaths; i++) 
    {
        if (aScopesOrig[j] == apwszPaths[i])
        {
            if (aScopesOrig[j] != aScopes[j])
            {
                // There is a translation in place.
                DFODBET *pdfet = (DFODBET*)LocalAlloc(LPTR, sizeof(*pdfet));
                if (pdfet)
                {
                    pdfet->pdfetNext = _pdfetFirst;
                    _pdfetFirst = pdfet;
                    pdfet->pwszFrom = aScopes[j];
                    pdfet->cbFrom = lstrlenW(pdfet->pwszFrom);
                    pdfet->pwszTo = aScopesOrig[j];
                    aScopes[j] = aScopesOrig[j];    // Make sure loop below does not delete pwszFrom
                    apwszPaths[i] = NULL;           // Likewise for pswsTo...
                }

            }
            if (apwszPaths[i])
            {
                LocalFree((HLOCAL)apwszPaths[i]);
                apwszPaths[i] = NULL;
            }

            if (j < iPath)
                j++;
        }
        else
        {
            apwszPaths[iInsert++] = apwszPaths[i]; // move to right place
        }
    }
    iPath++;    // setup to go through cleanupcode...

     // Fall through to cleanup code...

Abort:                
    // Warning... Since a failure return from this function will
    // release this class, most all of the allocated items up till the failure should
    // be released...   Also cleanup any paths we may have allocated...
    for (i = 0; i < iPath; i++) 
    {
        if (aScopesOrig[i] != aScopes[i])
            LocalFree(aScopes[i]);
    }

    if (aDepths)
        LocalFree(aDepths);

    if (aScopes)
        LocalFree(aScopes);

    if (aScopesOrig)
        LocalFree(aScopesOrig);
    
    if (aCatalogs)
        LocalFree(aCatalogs);

    if (aMachines)
        LocalFree(aMachines);

    if (pszMachineAlloc)
        LocalFree(pszMachineAlloc);

    if (pszCatalogAlloc)
        LocalFree(pszCatalogAlloc);

    return hr;
}

// This is the main external entry point to start a search.  This will
// create a new thread to process the 
STDAPI_(BOOL) SHFindComputer(LPCITEMIDLIST, LPCITEMIDLIST)
{
    IContextMenu *pcm;
    HRESULT hr = CoCreateInstance(CLSID_ShellSearchExt, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        CMINVOKECOMMANDINFO ici = {0};

        ici.cbSize = sizeof(ici);
        ici.lpParameters = "{996E1EB1-B524-11d1-9120-00A0C98BA67D}"; // Search Guid of Find Computers
        ici.nShow  = SW_NORMAL;

        hr = pcm->InvokeCommand(&ici);

        pcm->Release();
    }
    return SUCCEEDED(hr);
}

BOOL _IsComputerPidl(LPCITEMIDLIST pidl)
{
    CLSID clsid;
    if (SUCCEEDED(GetCLSIDFromIDList(pidl, &clsid)))
    {
        return (IsEqualCLSID(clsid, CLSID_NetworkPlaces) 
             || IsEqualCLSID(clsid, CLSID_NetworkRoot)
             || IsEqualCLSID(clsid, CLSID_NetworkDomain));
    }
    return FALSE;
}

// This is the main external entry point to start a search.  This will
// create a new thread to process the
//
STDAPI_(BOOL) SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile)
{
    // are we allowed?
    if (SHRestricted(REST_NOFIND))
        return FALSE;
        
    // We Need a hack to allow Find to work for cases like
    // Rest of network and workgroups to map to find computer instead
    // This is rather gross, but what the heck.  It is also assumed that
    // the pidl is of the type that we know about (either File or network)
    if (pidlFolder && _IsComputerPidl(pidlFolder))    
    {
        return SHFindComputer(pidlFolder, pidlSaveFile);
    }

    return RealFindFiles(pidlFolder, pidlSaveFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\folder.h ===
STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName);
STDAPI_(int) GetSpecialFolderParentIDAndOffset(LPCITEMIDLIST pidl, ULONG *pcbOffset);

#define TEST_SUBFOLDER   0x00010000  // CSIDL_ values are < 0xFFFF
STDAPI_(int) GetSpecialFolderID(LPCTSTR pszFolder, const int *rgcsidl, UINT count);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fldrscut.cpp ===
//   Implements Folder Shortcut.

#include "shellprv.h"
#include "clsobj.h"

// implemented in filefldr.cpp
extern LPTSTR PathFindCLSIDExtension(LPCTSTR pszFile, CLSID *pclsid);

BOOL CreateFolderDesktopIni(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID | FCSM_FLAGS;
    fcs.pclsid = (GUID*)&CLSID_FolderShortcut;
    fcs.dwFlags = FCS_FLAG_DRAGDROP;
    return SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_FORCEWRITE));
}


EXTERN_C BOOL IsFolderShortcut(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    CLSID clsid = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID;
    fcs.pclsid = &clsid;

    if (SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_READ)))
    {
        return IsEqualGUID(clsid, CLSID_FolderShortcut);
    }
    return FALSE;
}


// exported from fsnotify.c
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);


class CFolderShortcut : public IShellFolder2, 
                        public IPersistFolder3,
                        public IShellLinkA,
                        public IShellLinkW,
                        public IPersistFile,
                        public IExtractIcon,
                        public IQueryInfo,
                        public IFolderShortcutConvert,
                        public IPersistStreamInit,
                        public IPersistPropertyBag,
                        public IBrowserFrameOptions
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
                                  ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IPersistFolder3
    STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti);
    STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti);

    // IPersistStream
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm,int fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);

    // IPersistPropertyBag
    STDMETHODIMP Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    STDMETHODIMP Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);

    // IPersistPropertyBag/IPersistStreamInit
    STDMETHODIMP InitNew(void);

    // IPersistFile
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP IsDirty() { return E_NOTIMPL; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName) { return E_NOTIMPL; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IShellLinkW
    STDMETHODIMP GetPath(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD flags);
    STDMETHODIMP SetPath(LPCWSTR pszFile);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl);
    STDMETHODIMP GetDescription(LPWSTR pszName, int cchMaxName);
    STDMETHODIMP SetDescription(LPCWSTR pszName);
    STDMETHODIMP GetWorkingDirectory(LPWSTR pszDir, int cchMaxPath);
    STDMETHODIMP SetWorkingDirectory(LPCWSTR pszDir);
    STDMETHODIMP GetArguments(LPWSTR pszArgs, int cchMaxPath);
    STDMETHODIMP SetArguments(LPCWSTR pszArgs);
    STDMETHODIMP GetHotkey(WORD *pwHotkey);
    STDMETHODIMP SetHotkey(WORD wHotkey);
    STDMETHODIMP GetShowCmd(int *piShowCmd);
    STDMETHODIMP SetShowCmd(int iShowCmd);
    STDMETHODIMP GetIconLocation(LPWSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHODIMP SetIconLocation(LPCWSTR pszIconPath, int iIcon);
    STDMETHODIMP Resolve(HWND hwnd, DWORD fFlags);
    STDMETHODIMP SetRelativePath(LPCWSTR pszPathRel, DWORD dwReserved);

    // IShellLinkA
    STDMETHODIMP GetPath(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags);
    STDMETHODIMP SetPath(LPCSTR pszFile);
    STDMETHODIMP GetDescription(LPSTR pszName, int cchMaxName);
    STDMETHODIMP SetDescription(LPCSTR pszName);
    STDMETHODIMP GetWorkingDirectory(LPSTR pszDir, int cchMaxPath);
    STDMETHODIMP SetWorkingDirectory(LPCSTR pszDir);
    STDMETHODIMP GetArguments(LPSTR pszArgs, int cchMaxPath);
    STDMETHODIMP SetArguments(LPCSTR pszArgs);
    STDMETHODIMP GetIconLocation(LPSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHODIMP SetIconLocation(LPCSTR pszIconPath, int iIcon);
    STDMETHODIMP SetRelativePath(LPCSTR pszPathRel, DWORD dwReserved);

    // IFolderShortcutConvert
    STDMETHODIMP ConvertToLink(LPCOLESTR pszPathLNK, DWORD fFlags);
    STDMETHODIMP ConvertToFolderShortcut(LPCOLESTR pszPathLNK, DWORD fFlags);

    // IExtractIcon
    STDMETHODIMP GetIconLocation(UINT uFlags, LPTSTR pszIconFile, UINT ucchMax, INT *pniIcon, UINT *puFlags);
    STDMETHODIMP Extract(LPCTSTR pcszFile, UINT uIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT ucIconSize);

    // IQueryInfo
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, IN BROWSERFRAMEOPTIONS * pdwOptions);

    CFolderShortcut();

protected:
    ~CFolderShortcut();

    void _ClearState();
    void _ClearTargetFolder();

private:
    HRESULT _LoadShortcut();
    HRESULT _GetTargetIDList(BOOL fResolve);
    HRESULT _BindFolder(BOOL fResolve);
    HRESULT _GetFolder(BOOL fForceResolve);
    HRESULT _GetFolder2();

    HRESULT _GetLink();
    HRESULT _GetLinkA();
    HRESULT _GetLinkQI(REFIID riid, void **ppv);
    HRESULT _PreBindCtxHelper(IBindCtx **ppbc);

    LONG                   _cRef;      

    LPITEMIDLIST           _pidlRoot;
    LPITEMIDLIST           _pidlTarget;
    LPITEMIDLIST           _pidlTargetFldrFromInit;
    IShellFolder*          _psfTarget;
    IShellFolder2*         _psf2Target;
    IShellLinkW*           _pslTarget;
    IShellLinkA*           _pslTargetA;
    LPTSTR                 _pszLastSave;
    BOOL                   _fHaveResolved;
    DWORD                  _dwAttributesTarget;
    TCHAR                  _szFolderPath[MAX_PATH];
};

//constructor/destructor and related functions
CFolderShortcut::CFolderShortcut() : _cRef(1), _dwAttributesTarget(FILE_ATTRIBUTE_DIRECTORY)
{
    ASSERT(_pidlRoot == NULL);
    ASSERT(_pidlTarget == NULL);
    ASSERT(_psfTarget == NULL);
    ASSERT(_psf2Target == NULL);
    ASSERT(_szFolderPath[0] == 0);
    ASSERT(_pidlTargetFldrFromInit == NULL);

    DllAddRef();
}

CFolderShortcut::~CFolderShortcut()
{
    _ClearState();
    DllRelease();
}

void CFolderShortcut::_ClearTargetFolder()
{
    ATOMICRELEASE(_psfTarget);
    ATOMICRELEASE(_psf2Target);
}

void CFolderShortcut::_ClearState()
{
    _fHaveResolved = FALSE;

    Pidl_Set(&_pidlRoot, NULL);
    Pidl_Set(&_pidlTarget, NULL);
    Pidl_Set(&_pidlTargetFldrFromInit, NULL);

    Str_SetPtr(&_pszLastSave, NULL);

    _ClearTargetFolder();

    ATOMICRELEASE(_pslTarget);
    ATOMICRELEASE(_pslTargetA);

}

STDAPI CFolderShortcut_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    // aggregation checking is handled in class factory
    CFolderShortcut* pfolder = new CFolderShortcut();
    if (pfolder)
    {
        hr = pfolder->QueryInterface(riid, ppv);
        pfolder->Release();
    }

    return hr;
}

// ensure that _pslTarget has been created and loaded

HRESULT CFolderShortcut::_LoadShortcut()
{
    HRESULT hr;

    if (_pslTarget)
    {
        hr = S_OK;
    }
    else if (_szFolderPath[0])
    {
        TCHAR szPath[MAX_PATH];

        // leave this shortcut visible so down level clients see it and can
        // navigate through it.
        PathCombine(szPath, _szFolderPath, TEXT("target.lnk"));
        hr = LoadFromFile(CLSID_ShellLink, szPath, IID_PPV_ARG(IShellLinkW, &_pslTarget));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlTarget;

            // Prevalidate to prevent recusion
            // If GetIDList fails, that's okay; I guess it doesn't point to us after all
            if (_pslTarget->GetIDList(&pidlTarget) == S_OK)
            {
                SHGetPathFromIDList(pidlTarget, szPath);

                // Does this point to itself?
                if (StrCmpI(szPath, _szFolderPath) == 0)
                {
                    _pslTarget->Release();
                    _pslTarget = NULL;
                    hr = E_FAIL;
                }

                ILFree(pidlTarget);
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// ensure that _pidlTarget is inited (requres _pslTarget)

HRESULT CFolderShortcut::_GetTargetIDList(BOOL bResolve)
{
    HRESULT hr = _LoadShortcut();
    if (SUCCEEDED(hr))
    {
        if (_pidlTarget)
        {
            hr = S_OK;
        }
        else
        {
            if (bResolve)
                _pslTarget->Resolve(NULL, SLR_UPDATE | SLR_NO_UI);

            hr = _pslTarget->GetIDList(&_pidlTarget);
            if (hr == S_FALSE)
                hr = E_FAIL;      // convert empty to failure

            if (SUCCEEDED(hr))
            {
                //  make sure we dont have another shortcut here
                IShellLink *psl;
                if (SUCCEEDED(SHBindToObject(NULL, IID_IShellLink, _pidlTarget, (void**)&psl)))
                {
                    ILFree(_pidlTarget);
                    hr = psl->GetIDList(&_pidlTarget);

                    if (SUCCEEDED(hr))
                    {
                        hr = _pslTarget->SetIDList(_pidlTarget);
                    }
                    
                    psl->Release();
                }
            }

            if (FAILED(hr) && _pidlTarget)
            {
                ILFree(_pidlTarget);
                _pidlTarget = NULL;
            }
        }
    }
    return hr;
}

// create _psfTarget (requires _pidlTarget)

HRESULT CFolderShortcut::_BindFolder(BOOL bResolve)
{
    ASSERT(_psfTarget == NULL);

    HRESULT hr = _GetTargetIDList(bResolve);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc = NULL;   // in/out param below
        hr = _PreBindCtxHelper(&pbc);    // avoid loops in the name space
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr))
            {
                IShellFolder *psfDesktop;
                hr = SHGetDesktopFolder(&psfDesktop);
                if (SUCCEEDED(hr))
                {
                    // Are we trying to bind to the desktop folder?
                    if (ILIsEmpty(_pidlTarget))
                    {
                        // Yes; Clone the desktop shell folder.
                        _psfTarget = psfDesktop;
                        _psfTarget->AddRef();
                        hr = S_OK;
                    }
                    else
                    {
                        // No. Bind to it.
                        hr = psfDesktop->BindToObject(_pidlTarget, pbc, IID_PPV_ARG(IShellFolder, &_psfTarget));
                    }

                    if (SUCCEEDED(hr))
                    {
                        // optionally re-target the folder (if he is a file system folder) 
                        // to separate the location in the name space (_pidlRoot) 
                        // and the folder being viewed (pfsfi.szFolderPath).

                        IPersistFolder3 *ppf;
                        if (SUCCEEDED(_psfTarget->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf))))
                        {
                            PERSIST_FOLDER_TARGET_INFO pfti = { 0 };

                            pfti.pidlTargetFolder = _pidlTarget;
                            pfti.dwAttributes = _dwAttributesTarget;
                            pfti.csidl = -1;

                            hr = ppf->InitializeEx(pbc, _pidlRoot, &pfti);
                            ppf->Release();
                        }
                    }
                    psfDesktop->Release();
                }
            }
            pbc->Release();
        }
    }
    return hr;
}

// ensure that _psfTarget is inited

HRESULT CFolderShortcut::_GetFolder(BOOL fForceResolve)
{
    HRESULT hr;

    if (fForceResolve)
    {
        if (_fHaveResolved)
        {
            hr = _psfTarget ? S_OK : E_FAIL;
        }
        else
        {
            _fHaveResolved = TRUE;  // don't do this again

            _ClearTargetFolder();
            Pidl_Set(&_pidlTarget, NULL);

            hr = _BindFolder(fForceResolve);
        }
    }
    else if (_psfTarget)
    {
        hr = S_OK;
    }
    else
    {
        hr = _BindFolder(fForceResolve);
    }
    return hr;
}

// ensure that _psf2Target is inited

HRESULT CFolderShortcut::_GetFolder2()
{
    if (_psf2Target)
        return S_OK;

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf2Target));
    return hr;
}

STDMETHODIMP CFolderShortcut::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFolderShortcut, IShellFolder, IShellFolder2),
        QITABENT(CFolderShortcut, IShellFolder2),
        QITABENTMULTI(CFolderShortcut, IPersist, IPersistFolder3),
        QITABENTMULTI(CFolderShortcut, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CFolderShortcut, IPersistFolder2, IPersistFolder3),
        QITABENT(CFolderShortcut, IPersistFolder3),
        QITABENT(CFolderShortcut, IPersistStreamInit),
        QITABENTMULTI(CFolderShortcut, IPersistStream, IPersistStreamInit),
        QITABENT(CFolderShortcut, IShellLinkA),
        QITABENT(CFolderShortcut, IShellLinkW),
        QITABENT(CFolderShortcut, IPersistFile),
        QITABENT(CFolderShortcut, IFolderShortcutConvert),
        QITABENT(CFolderShortcut, IExtractIcon),
        QITABENT(CFolderShortcut, IQueryInfo),
        QITABENT(CFolderShortcut, IPersistPropertyBag),
        QITABENT(CFolderShortcut, IBrowserFrameOptions),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFolderShortcut::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderShortcut::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

// either create or init the passed bind ctx with the params to avoid loops in the name space

HRESULT CFolderShortcut::_PreBindCtxHelper(IBindCtx **ppbc)
{
    HRESULT hr;
    if (*ppbc)
    {
        (*ppbc)->AddRef();
        hr = S_OK;
    }
    else
    {
         hr = BindCtx_CreateWithMode(STGM_READ | STGM_SHARE_DENY_WRITE, ppbc);
    }

    if (SUCCEEDED(hr)) 
        (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellFolder2 *));

    return hr;
}

// IShellFolder methods

HRESULT CFolderShortcut::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;
    if (!pwszDisplayName)
        return E_INVALIDARG;

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
    {
        hr = _PreBindCtxHelper(&pbc);
        if (SUCCEEDED(hr))
        {
            hr = _psfTarget->ParseDisplayName(hwnd, pbc, pwszDisplayName, 
                                                pchEaten, ppidl, pdwAttributes);
            pbc->Release();
        }
    }
    return hr;
}

HRESULT CFolderShortcut::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    HRESULT hr = _GetFolder(TRUE);

    if (SUCCEEDED(hr))
        hr = _psfTarget->EnumObjects(hwnd, grfFlags, ppenumIDList);
    if (SUCCEEDED(hr))
        SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);
    
    return hr;
}

HRESULT CFolderShortcut::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder(TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _PreBindCtxHelper(&pbc);
        if (SUCCEEDED(hr))
        {
            hr = _psfTarget->BindToObject(pidl, pbc, riid, ppv);
            pbc->Release();

            if (SUCCEEDED(hr))
                SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);
        }
    }
    return hr;
}

HRESULT CFolderShortcut::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CFolderShortcut::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->CompareIDs(lParam, pidl1, pidl2);
    return hr;
}

HRESULT CFolderShortcut::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder(TRUE);

    if ( SUCCEEDED(hr) )
        hr = _psfTarget->CreateViewObject(hwnd, riid, ppv);

    if ( SUCCEEDED(hr) && (IsEqualIID(riid, IID_IShellView) || IsEqualIID(riid, IID_IShellView2)) )
        SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);

    return hr;
}

HRESULT CFolderShortcut::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    if (IsSelf (cidl, apidl))
    {
        // since our folder is marked "CallForAttributes" we get to report
        // our attributes at runtime instead of the normal way via the registry
        if (SHGetAppCompatFlags (ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT)
        {
            *rgfInOut = SFGAO_LINK | SFGAO_CAPABILITYMASK | SFGAO_FILESYSTEM;
        }
        else
        {
            *rgfInOut = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_STORAGE |
                          SFGAO_LINK | SFGAO_DROPTARGET | SFGAO_CANRENAME | SFGAO_CANDELETE |
                          SFGAO_CANLINK | SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
        }
        return S_OK;
    }

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetAttributesOf(cidl, apidl, rgfInOut);
    return hr;
}

HRESULT CFolderShortcut::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    return hr;
}

HRESULT CFolderShortcut::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetDisplayNameOf(pidl, uFlags, pName);
    return hr;
}

HRESULT CFolderShortcut::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                                   LPCOLESTR pszName, DWORD uFlags,
                                   LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->SetNameOf(hwnd, pidl, pszName, uFlags, ppidlOut);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultSearchGUID(LPGUID lpGuid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultSearchGUID(lpGuid);
    return hr;
}

STDMETHODIMP CFolderShortcut::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->EnumSearches(ppenum);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{    
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultColumnState(iColumn, pbState);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDetailsEx(pidl, pscid, pv);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetail)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDetailsOf(pidl, iColumn, pDetail);
    return hr;
}

STDMETHODIMP CFolderShortcut::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->MapColumnToSCID(iColumn, pscid);
    return hr;
}

// IPersist
HRESULT CFolderShortcut::GetClassID(CLSID *pCLSID)
{
    *pCLSID = CLSID_FolderShortcut;
    return S_OK;
}

// IPersistFolder
HRESULT CFolderShortcut::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // is the link loaded (could have been loaded through IPersistStream::Load)?
    if (_pslTarget)
    {
        // Yes, it's loaded so re-initialize
        // note, _szFolderPath will be empty since we are not loaded from the file system

        hr = Pidl_Set(&_pidlRoot, pidl) ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        // we explictly require initialization through 
        // IPersistFolder3::InitializeEx, if we don't do these we can
        // not defent against loops in the name space
        hr = E_FAIL;
    }

    return hr;
}

// IPersistFolder2
STDMETHODIMP CFolderShortcut::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(this->_pidlRoot, ppidl);
}

// IPersistFolder3
STDMETHODIMP CFolderShortcut::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = E_INVALIDARG;  // assume failure

    if ( NULL == pbc || (pbc && !SHSkipJunction(pbc, &CLSID_FolderShortcut)) )
    {
        _ClearState();

        if (pidlRoot)
            hr = SHILClone(pidlRoot, &_pidlRoot);

        if (pfti && pfti->pidlTargetFolder)
        {
            if ( SUCCEEDED(hr) )
                hr = SHILClone(pfti->pidlTargetFolder, &_pidlTargetFldrFromInit);

            if ( SUCCEEDED(hr) && !_szFolderPath[0] )
                hr = SHGetPathFromIDList(pfti->pidlTargetFolder, _szFolderPath) ? S_OK : E_FAIL;
        }
        else
        {
            if ( SUCCEEDED(hr) && !_szFolderPath[0] )
                hr = SHGetPathFromIDList(_pidlRoot, _szFolderPath) ? S_OK : E_FAIL;
        }

        if ( SUCCEEDED(hr) )
            hr = _LoadShortcut();
    }
    return hr;
}

HRESULT CFolderShortcut::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;

    ZeroMemory(pfti, sizeof(*pfti)); 

    if ( _pidlTargetFldrFromInit )
        hr = SHILClone(_pidlTargetFldrFromInit, &pfti->pidlTargetFolder);

    pfti->dwAttributes = -1;
    pfti->csidl = -1;
    return hr;
}

HRESULT CFolderShortcut::_GetLink()
{
    HRESULT hr = _LoadShortcut();
    if (FAILED(hr))
    {
        // get an empty one in case we are going to be asked to save
        hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLinkW, &_pslTarget));
    }
    return hr;
}

HRESULT CFolderShortcut::_GetLinkQI(REFIID riid, void **ppv)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->QueryInterface(riid, ppv);
    return hr;
}

HRESULT CFolderShortcut::_GetLinkA()
{
    return _pslTargetA ? S_OK : _GetLinkQI(IID_PPV_ARG(IShellLinkA, &_pslTargetA));
}

// IPersistFile
STDMETHODIMP CFolderShortcut::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    _ClearState();

    SHUnicodeToTChar(pszFileName, _szFolderPath, ARRAYSIZE(_szFolderPath));
    return _LoadShortcut();
}

BOOL _IsFolder(LPCITEMIDLIST pidl)
{
    ULONG rgInfo = SFGAO_FOLDER;
    HRESULT hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, NULL, 0, &rgInfo);
    return SUCCEEDED(hr) && (rgInfo & SFGAO_FOLDER);
}

void PathStripTrailingDots(LPTSTR szPath)
{
    if (szPath[0] == TEXT('\0'))
        return;

    LPTSTR psz = &szPath[lstrlen(szPath) - 1];

    while ((*psz == TEXT('.')) && 
           (psz >= szPath))
    {
        *psz-- = TEXT('\0');
    }

}


STDMETHODIMP CFolderShortcut::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr = _GetTargetIDList(FALSE);

    // We need to make sure the folder shortcut can be saved keeping in mind the MAX_PATH limitation
    // cchFSReserved is the number of characters to reserve for the largest file that will be created
    // in the foldershortcut directory, in this case, it is the ARRAYSIZE of "\\desktop.ini"
    static const int cchFSReserved = ARRAYSIZE(TEXT("\\desktop.ini")); 

    LPITEMIDLIST pidlInternet;

    // Don't create a folder shortcut to the internet folder.
    if (SUCCEEDED(hr) && SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_INTERNET, &pidlInternet)))
    {
        if (ILIsEqual(_pidlTarget, pidlInternet))
        {
            hr = E_INVALIDARG;
        }
        ILFree(pidlInternet);
    }

    if (SUCCEEDED(hr) && _IsFolder(_pidlTarget))
    {
        // we know the target is a folder, create a folder shortcut.
        BOOL fCreatedDir;
        TCHAR szName[MAX_PATH];

        SHUnicodeToTChar(pszFileName, szName, ARRAYSIZE(szName));

        // Remove any exisiting extension. 
        // We dont want "Shortcut To My Documents.lnk.{GUID}
        if (PathFindCLSIDExtension(szName,NULL))
        {
            PathRemoveExtension(szName);
        }

        PathStripTrailingDots(szName);

        // Can't create a fldrshcut with too long a path
        if ((MAX_PATH - cchFSReserved) < lstrlen(szName))
        {
            hr = CO_E_PATHTOOLONG;
        }
        
        if (SUCCEEDED(hr))
        {
            if (PathIsDirectory(szName))
                fCreatedDir = FALSE;
            else
                fCreatedDir = SHCreateDirectory(NULL, szName) == 0;

            CreateFolderDesktopIni(szName);

            // Now initialize the child link
            IPersistFile *ppf;
            hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                WCHAR wszName[MAX_PATH];
                SHTCharToUnicode(szName, wszName, ARRAYSIZE(wszName));

                PathAppendW(wszName, L"target.lnk");

                hr = ppf->Save(wszName, fRemember);
                if (SUCCEEDED(hr))
                {
                    if (fRemember)
                        Str_SetPtr(&_pszLastSave, szName);
                }

                ppf->Release();
            }

            if (FAILED(hr) && fCreatedDir) 
            {
                RemoveDirectory(szName);    // cleanup after ourselves.
            }
        }
    }
    else
    {
        // ensure that if we save as a file we do so with the right extension
        WCHAR szFile[MAX_PATH];
        StrCpy(szFile, pszFileName);
        PathRenameExtension(szFile, L".lnk");

        // the target is not a folder, create a normal shortcut in this case
        IPersistFile *ppf;
        hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Save(szFile, fRemember);
            ppf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT hr = E_FAIL;
    if (_pszLastSave)
        hr = SHStrDup(_pszLastSave, ppszFileName);
    else if (_pslTarget)
    {
        IPersistFile *ppf;
        hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->GetCurFile(ppszFileName);
            ppf->Release();
        }
    }
    return hr;
}

// IShellLinkW

STDMETHODIMP CFolderShortcut::GetPath(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD flags)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetPath(pszFile, cchMaxPath, pfd, flags);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetPath(LPCWSTR pwszFile)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr) && PathIsDirectoryW(pwszFile))
    {
        hr = _pslTarget->SetPath(pwszFile);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetIDList(ppidl);
    else
        *ppidl = NULL;
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIDList(LPCITEMIDLIST pidl)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
    {
        hr = _pslTarget->SetIDList(pidl);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDescription(LPWSTR wszName, int cchMaxName)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetDescription(wszName, cchMaxName);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetDescription(LPCWSTR wszName)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetDescription(wszName);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetWorkingDirectory(LPWSTR wszDir, int cchMaxPath)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetWorkingDirectory(wszDir, cchMaxPath);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetWorkingDirectory(LPCWSTR wszDir)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetWorkingDirectory(wszDir);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetArguments(LPWSTR wszArgs, int cchMaxPath)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetArguments(wszArgs, cchMaxPath);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::SetArguments(LPCWSTR wszArgs)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetArguments(wszArgs);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::GetHotkey(WORD *pwHotkey)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetHotkey(pwHotkey);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetHotkey(WORD wHotkey)
{
    HRESULT hr = _GetLink();
   if (SUCCEEDED(hr))
        hr = _pslTarget->SetHotkey(wHotkey);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetShowCmd(int *piShowCmd)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetShowCmd(piShowCmd);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetShowCmd(int iShowCmd)
{
    HRESULT hr = _GetLink();
   if (SUCCEEDED(hr))
        hr = _pslTarget->SetShowCmd(iShowCmd);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(LPWSTR wszIconPath, int cchIconPath, int *piIcon)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetIconLocation(wszIconPath, cchIconPath, piIcon);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIconLocation(LPCWSTR wszIconPath, int iIcon)
{
    HRESULT hr = _GetLink();
    if  (SUCCEEDED(hr))
        hr = _pslTarget->SetIconLocation(wszIconPath, iIcon);

    return hr;
}

STDMETHODIMP CFolderShortcut::Resolve(HWND hwnd, DWORD fFlags)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->Resolve(hwnd, fFlags);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetRelativePath(LPCWSTR wszPathRel, DWORD dwReserved)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetRelativePath(wszPathRel, dwReserved);

    return hr;
}

// IShellLinkA
STDMETHODIMP CFolderShortcut::GetPath(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetPath(pszFile, cchMaxPath, pfd, flags);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDescription(LPSTR pszName, int cchMaxName)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetDescription(pszName, cchMaxName);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetWorkingDirectory(LPSTR pszDir, int cchMaxPath)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetWorkingDirectory(pszDir, cchMaxPath);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetArguments(LPSTR pszArgs, int cchMaxPath)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetArguments(pszArgs, cchMaxPath);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(LPSTR pszIconPath, int cchIconPath, int *piIcon)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr)) 
       hr = _pslTargetA->GetIconLocation(pszIconPath, cchIconPath, piIcon);    
    return hr;
}

STDMETHODIMP CFolderShortcut::SetPath(LPCSTR pszFile)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr) && PathIsDirectoryA(pszFile))
    {
        hr = _pslTargetA->SetPath(pszFile);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::SetDescription(LPCSTR pszName)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetDescription(pszName);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetWorkingDirectory(LPCSTR pszDir)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetWorkingDirectory(pszDir);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetArguments(LPCSTR pszArgs)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetArguments(pszArgs);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIconLocation(LPCSTR pszIconPath, int iIcon)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))    
        hr = _pslTargetA->SetIconLocation(pszIconPath, iIcon);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetRelativePath(LPCSTR pszPathRel, DWORD dwReserved)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetRelativePath(pszPathRel, dwReserved);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(UINT uFlags, LPTSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    IExtractIcon *pxi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        hr = pxi->GetIconLocation(uFlags, pszIconFile, ucchMax, pniIcon, puFlags);
        pxi->Release();
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::Extract(LPCTSTR pcszFile, UINT uIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT ucIconSize)
{
    IExtractIcon *pxi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        hr = pxi->Extract(pcszFile, uIconIndex, phiconLarge, phiconSmall, ucIconSize);
        pxi->Release();
    }
    return hr;
}

HRESULT CFolderShortcut::GetInfoTip(DWORD dwFlags, WCHAR** ppwszText)
{
    IQueryInfo *pqi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        hr = pqi->GetInfoTip(dwFlags | QITIPF_LINKUSETARGET, ppwszText);
        pqi->Release();
    }
    return hr;
}

HRESULT CFolderShortcut::GetInfoFlags(DWORD *pdwFlags)
{
    IQueryInfo *pqi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        hr = pqi->GetInfoFlags(pdwFlags);
        pqi->Release();
    }
    return hr;
}


// IBrowserFrameOptions
HRESULT CFolderShortcut::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, IN BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = _GetFolder(FALSE);

    *pdwOptions = BFO_NONE;
    if (SUCCEEDED(hr))
    {
        IBrowserFrameOptions *pbfo;

        hr = _psfTarget->QueryInterface(IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);        
            pbfo->Release();
        }
    }
    
    return hr;
}


// IPersistStream
STDMETHODIMP CFolderShortcut::Load(IStream *pStm)
{
    _ClearState();

    IPersistStream *pps;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->Load(pStm);
        if (SUCCEEDED(hr))
            pps->QueryInterface(IID_PPV_ARG(IShellLinkW, &_pslTarget));  // keep this guy
        pps->Release();
    }
    return hr;
}

// IPersistStream
STDMETHODIMP CFolderShortcut::Save(IStream *pStm, int fClearDirty)
{
    return E_NOTIMPL;
}

// IPersistStream
STDMETHODIMP CFolderShortcut::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    return E_NOTIMPL;
}

//
// IFolderShortcut::ConvertToLink.
//
// destructively convert a Folder Shortcut into a Shell Link.
//
//  pszFolderShortcut is the path to an existing folder shortcut
//  c:\Folder Shortcut.{guid}   - deleted
//  c:\Folder Shortcut.lnk      - created
//
STDMETHODIMP CFolderShortcut::ConvertToLink(LPCOLESTR pszFolderShortcut, DWORD fFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_PATH];

    SHUnicodeToTChar(pszFolderShortcut, szName, ARRAYSIZE(szName));

    if (PathIsDirectory(szName) && IsFolderShortcut(szName))
    {
        TCHAR szLinkName[MAX_PATH];

        // c:\Folder Shortcut\target.lnk 
        StrCpyN(szLinkName, szName, ARRAYSIZE(szLinkName));
        PathAppend(szLinkName, TEXT("target.lnk"));

        PathRenameExtension(szName, TEXT(".lnk"));

        // FS.lnk -> FS.{guid}
        CopyFile(szLinkName, szName, FALSE);

        PathRemoveExtension(szName);

        if (DeleteFile(szLinkName) && 
            PathAppend(szName, TEXT("desktop.ini")) && DeleteFile(szName) &&
            PathRemoveFileSpec(szName) && RemoveDirectory(szName))
        {
            hr = S_OK;
        }
    }
    return hr;
}

//
// IFolderShortcut::ConvertToFolderShortcut.
//
// destructively convert a Shell Link (.lnk) -> Folder Shortcut (Folder.{guid}).
//  pszPathLNK is the path to an existing .lnk file
//  c:\Folder Shortcut.lnk      - deleted
//  c:\Folder Shortcut.{guid}   - created
//
STDMETHODIMP CFolderShortcut::ConvertToFolderShortcut(LPCOLESTR pszPathLNK, DWORD fFlags)
{
    //must bind to the link, resolve it, and make sure it points to a folder.
    IShellLink *psl;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))  
    {
        IPersistFile *ppf;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(pszPathLNK, STGM_READ);
            if (SUCCEEDED(hr))
            {
                hr = psl->Resolve(NULL, SLR_NO_UI); // make sure the link is real
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;

                    hr = psl->GetIDList(&pidl);
                    if (hr == S_OK)
                    {
                        // this should maybe work on the pidl so that 
                        // it doesn't have to worry about files.
                        if (_IsFolder(pidl))
                        {             
                            hr = E_FAIL;

                            TCHAR szPath[MAX_PATH], szName[MAX_PATH]; 
                            SHUnicodeToTChar(pszPathLNK, szName, ARRAYSIZE(szName));
                            StrCpyN(szPath, szName, ARRAYSIZE(szPath));
                            PathRemoveExtension(szName);
                            BOOL fCreatedDir = SHCreateDirectory(NULL, szName) == 0;

                            if (CreateFolderDesktopIni(szName) &&
                                PathAppend(szName, TEXT("target.lnk")))
                            {   
                                //copy the link file into the new directory.
                                if (CopyFile(szPath, szName, FALSE))
                                {
                                    if (DeleteFile(szPath)) //if all goes well, delete the old.
                                        hr = S_OK;
                                }
                                else
                                {
                                    PathRemoveFileSpec(szName);
                                    if (fCreatedDir)
                                        RemoveDirectory(szName);
                                }
                            }
                        }
                        else
                            hr = E_FAIL;
                        ILFree(pidl);
                    }
                    else
                        hr = E_FAIL;
                }
            }
            ppf->Release();
        }
        psl->Release();
    }
    
    return hr;
}

// IPersistPropertyBag
STDMETHODIMP CFolderShortcut::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

// IPersistPropertyBag
STDMETHODIMP CFolderShortcut::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    _ClearState();

    IPersistPropertyBag* pppb;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistPropertyBag, &pppb));
    if (SUCCEEDED(hr))
    {
        hr = pppb->Load(pPropBag, pErrorLog);
        if (SUCCEEDED(hr))
        {
            hr = pppb->QueryInterface(IID_PPV_ARG(IShellLinkW, &_pslTarget));

            DWORD dwFlags;
            if (SUCCEEDED(SHPropertyBag_ReadDWORD(pPropBag, L"Attributes", &dwFlags)))
                _dwAttributesTarget = dwFlags;
        }
        pppb->Release();
    }

    return hr;
}

STDMETHODIMP CFolderShortcut::InitNew(void)
{
    _ClearState();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\fldsets.c ===
#include "shellprv.h"
#pragma  hdrstop

#define GUIDSIZE  (GUIDSTR_MAX+1)

//
// This function uses SHGetIniStringUTF7 to access the string, so it is valid
// to use SZ_CANBEUNICODE on the key name.
//
HRESULT SHGetSetFolderSetting(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
                              LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize)
{
    HRESULT hr = S_OK;
    //They just want to read.
    if (dwReadWrite == FCS_READ)
    {
        if (pszValue)
        {
            if (!SHGetIniStringUTF7(pszSection,pszKey, pszValue, cchValueSize, pszIniFile))
                hr = E_FAIL;
        }

    }        
    //They want to write the value regardless whether the value is already there or not.
    if (dwReadWrite == FCS_FORCEWRITE)
    {
        SHSetIniStringUTF7(pszSection, pszKey, pszValue, pszIniFile);
    }

    //Write only if the value is not already present.
    if (dwReadWrite == FCS_WRITE)
    {
        TCHAR szBuf[MAX_PATH];
        BOOL fWrite = TRUE;

        szBuf[0] = 0;
        //See if the value already exists ?
        SHGetIniStringUTF7(pszSection,pszKey, szBuf, ARRAYSIZE(szBuf), pszIniFile);

        if (!szBuf[0])
        {            
            //Write only if the value is not already in the file
            SHSetIniStringUTF7(pszSection, pszKey, pszValue, pszIniFile);
        }
    }

    return hr;
}

// SHGetSetFolderSetting for path values
HRESULT SHGetSetFolderSettingPath(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
                                  LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize)
{
    HRESULT hr;
    TCHAR szTemp[MAX_PATH], szTemp2[MAX_PATH];
    if ((dwReadWrite == FCS_FORCEWRITE) || (dwReadWrite == FCS_WRITE))  // We write
    {
        int cch = cchValueSize;
        if (pszValue)
        {
            lstrcpyn(szTemp, pszValue, ARRAYSIZE(szTemp));
            SubstituteWebDir(szTemp, ARRAYSIZE(szTemp));

            if (PathUnExpandEnvStrings(szTemp, szTemp2, ARRAYSIZE(szTemp2)))
            {
                pszValue = szTemp2;
                cch = ARRAYSIZE(szTemp2);
            }
            else
            {
                pszValue = szTemp;
                cch = ARRAYSIZE(szTemp);
            }
        }
        hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, pszSection, pszKey, pszValue, 0);
    }
    else
    {
        hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, pszSection, pszKey, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))    // We've read a path
        {
            SHExpandEnvironmentStrings(szTemp, pszValue, cchValueSize);   // This is a path, so expand the env vars in it
            ExpandOtherVariables(pszValue, cchValueSize);
        }
    }
    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetLogo(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_LOGO)
    {
        hr =  SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("Logo"),
                                     pfcs->pszLogo, pfcs->cchLogo);
    }
    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetInfoTip(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_INFOTIP)
    {
        hr =  SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("InfoTip"),
                                pfcs->pszInfoTip, pfcs->cchInfoTip);
    }

    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetIconFile(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_ICONFILE)
    {
        hr =  SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("IconFile"),
                                      pfcs->pszIconFile, pfcs->cchIconFile);
    }
    return hr;
}

  
// Read/write desktop.ini settings
HRESULT SHGetSetVID(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szVID[GUIDSIZE];

    if (pfcs->dwMask & FCSM_VIEWID)
    {
        if (dwReadWrite == FCS_READ)
        {
            if (pfcs->pvid)
            {
                hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), TEXT("Default"),
                                             szVID, ARRAYSIZE(szVID));
                if (hr == S_OK)
                    SHCLSIDFromString(szVID, pfcs->pvid);
            }
        }
        else if (pfcs->pvid)
        {
            SHStringFromGUID(pfcs->pvid, szVID, ARRAYSIZE(szVID));
            SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), TEXT("Default"),
                                              szVID, ARRAYSIZE(szVID));        
            hr =  SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), szVID,
                                              szVID, ARRAYSIZE(szVID));        
        }
        else
        {
            // if we get here we assume that they want to nuke the whole section
            if(0 != WritePrivateProfileString(TEXT("ExtShellFolderViews"), NULL, NULL, pszIniFile))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetCLSID(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szCLSID[GUIDSIZE];

    if (pfcs->dwMask & FCSM_CLSID)
    {
        if (dwReadWrite == FCS_READ)
        {
            if (pfcs->pclsid)
            {
                SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  szCLSID, ARRAYSIZE(szCLSID));        
                hr = SHCLSIDFromString(szCLSID, pfcs->pclsid);
            }
        }
        else if (pfcs->pclsid)
        {
            SHStringFromGUID(pfcs->pclsid, szCLSID, ARRAYSIZE(szCLSID));
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  szCLSID, ARRAYSIZE(szCLSID));        
        }
        else
        {
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  NULL, 0);        
        }

    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetFlags(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szFlags[20];

    if (pfcs->dwMask & FCSM_FLAGS)
    {
        if (dwReadWrite == FCS_READ)
        {
           hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("Flags"),
                                           szFlags, ARRAYSIZE(szFlags));        
           pfcs->dwFlags = StrToInt(szFlags);
        }
        else
        {
            wsprintf(szFlags, TEXT("%d"), (int)pfcs->dwFlags);
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("Flags"),
                                                szFlags, ARRAYSIZE(szFlags));        
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetIconIndex(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    TCHAR szIconIndex[20];
    HRESULT hr = S_FALSE;

    if (pfcs->dwMask & FCSM_ICONFILE)
    {
        if (dwReadWrite == FCS_READ)
        {
           hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                           szIconIndex, ARRAYSIZE(szIconIndex));        
           pfcs->iIconIndex = StrToInt(szIconIndex);
        }
        else if (pfcs->pszIconFile)
        {
            wsprintf(szIconIndex, TEXT("%d"), (int)pfcs->iIconIndex);
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                                szIconIndex, ARRAYSIZE(szIconIndex));        
        }
        else
        {
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                                NULL, 0);        
        }
    }
    return hr;
}


const LPCTSTR c_szWebViewTemplateVersions[] =
{
    SZ_CANBEUNICODE TEXT("WebViewTemplate.NT5"),
    SZ_CANBEUNICODE TEXT("PersistMoniker")
};

// Read/write desktop.ini settings
HRESULT SHGetSetWebViewTemplate(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    int i;
    TCHAR szVID[GUIDSIZE], szTemp[MAX_PATH];
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_WEBVIEWTEMPLATE)
    {
        if (!SHStringFromGUID(&VID_WebView, szVID, ARRAYSIZE(szVID)))
        {
            hr = E_FAIL;
        }

        if ((!pfcs->pszWebViewTemplate || !pfcs->pszWebViewTemplate[0]) && (dwReadWrite == FCS_FORCEWRITE)) // We have to remove webview
        {
            WritePrivateProfileString(szVID, NULL, NULL, pszIniFile);
            WritePrivateProfileString(TEXT("ExtShellFolderViews"), szVID, NULL, pszIniFile);
            if (SHGetSetFolderSetting(pszIniFile, FCS_READ, TEXT("ExtShellFolderViews"), TEXT("Default"), szTemp, ARRAYSIZE(szTemp)) == S_OK
                    && StrCmpI(szTemp, szVID) == 0)
            {
                WritePrivateProfileString(TEXT("ExtShellFolderViews"), TEXT("Default"), NULL, pszIniFile);
            }
        }
        else
        {
            TCHAR szKey[MAX_PATH];
            if (!pfcs->pszWebViewTemplateVersion || !pfcs->pszWebViewTemplateVersion[0]
                    || (lstrcmpi(pfcs->pszWebViewTemplateVersion, TEXT("IE4")) == 0))
            {   // They don't know which version template they want. Let's try from the latest version down.
                if (dwReadWrite & FCS_READ)
                {
                    for (i = 0; i < ARRAYSIZE(c_szWebViewTemplateVersions); i++)
                    {
                        lstrcpyn(szKey, c_szWebViewTemplateVersions[i], ARRAYSIZE(szKey));
                        if (SHGetSetFolderSetting(pszIniFile, FCS_READ, szVID, szKey, szTemp, ARRAYSIZE(szTemp)) == S_OK)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    lstrcpyn(szKey, c_szWebViewTemplateVersions[ARRAYSIZE(c_szWebViewTemplateVersions) - 1], ARRAYSIZE(szKey));
                }
            }
            else
            {
                lstrcpyn(szKey, SZ_CANBEUNICODE TEXT("WebViewTemplate."), ARRAYSIZE(szKey));
                StrCatBuff(szKey, pfcs->pszWebViewTemplateVersion, ARRAYSIZE(szKey));
            }
            
            if (dwReadWrite == FCS_FORCEWRITE)
            {
                // Remove all old templates
                for (i = 0; i < ARRAYSIZE(c_szWebViewTemplateVersions); i++)
                {
                    SHGetSetFolderSetting(pszIniFile, FCS_FORCEWRITE, szVID, c_szWebViewTemplateVersions[i], NULL, 0);
                }
            }
            
            hr = SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, szVID, szKey,
                                    pfcs->pszWebViewTemplate, pfcs->cchWebViewTemplate);
            if (SUCCEEDED(hr))
            {
                if ((dwReadWrite == FCS_FORCEWRITE) || (dwReadWrite == FCS_WRITE))
                {
                    // If we have set the template, make sure that the VID_Webview = VID_WebView line under "ExtShellFolderViews" is present
                    if (pfcs->pszWebViewTemplate)
                    {
                        SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), szVID, 
                                        szVID, ARRAYSIZE(szVID));
                    }
                }
            }
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetFCS(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszPath, DWORD dwReadWrite)
{
    HRESULT hret = S_OK, hr;
    TCHAR szIniFile[MAX_PATH];
    DWORD dwValueReturned = 0;

    // Get the pathname for desktop.ini
    PathCombine(szIniFile, pszPath, TEXT("Desktop.ini"));

    hr = SHGetSetVID(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_VIEWID;
    }

    hr = SHGetSetWebViewTemplate(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_WEBVIEWTEMPLATE;
    }

    hr = SHGetSetInfoTip(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_INFOTIP;
    }

    hr = SHGetSetCLSID(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_CLSID;
    }
    
    hr = SHGetSetFlags(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_FLAGS;
    }

    hr = SHGetSetIconFile(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_ICONFILE;
    }

    hr = SHGetSetIconIndex(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_ICONFILE;
    }
    
    hr = SHGetSetLogo(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_LOGO;
    }
    
    if (SUCCEEDED(hret) && (dwReadWrite & FCS_FORCEWRITE))
    {
        // Make desktop.ini hidden
        SetFileAttributes(szIniFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        // Make this a system folder, so that we look for desktop.ini when we navigate to this folder.
        PathMakeSystemFolder(pszPath);
    }

    if (dwReadWrite & FCS_READ)
    {
        // If we were asked to get something and we are not returning anything, return error.
        if (pfcs->dwMask && !dwValueReturned)
        {
            hret = E_FAIL;
        }
        pfcs->dwMask = dwValueReturned;
    }
    return hret;
}

HRESULT SHAllocAndThunkUnicodeToTChar(LPWSTR pwsz, LPTSTR* ppsz, int cchReturnBuffer)
{
    HRESULT hr = S_OK;

    if (!ppsz || !pwsz)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int cch;

        if (cchReturnBuffer > 0)
        {      
            // if the user specified the size of the return buffer, alloc that ammount
            cch = cchReturnBuffer;
        }
        else
        {
            // since the user did not specify the size, alloc just enough to hold the string
            cch = lstrlenW(pwsz) + 1;
        }

        *ppsz = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (!*ppsz)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            SHUnicodeToTChar(pwsz, *ppsz, cch);
        }
    }
    return hr;
}

HRESULT SHAllocAndThunkAnsiToTChar(LPSTR psz, LPTSTR* ppsz, int cchReturnBuffer)
{
    HRESULT hr = S_OK;

    if (!ppsz || !psz)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int cch;
        
        if (cchReturnBuffer > 0)
        {      
            // if the user specified the size of the return buffer, alloc that ammount
            cch = cchReturnBuffer;
        }
        else
        {
            // since the user did not specify the size, alloc just enough to hold the string
            cch = lstrlenA(psz) + 1;
        }

        *ppsz = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (!*ppsz)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            SHAnsiToTChar(psz, *ppsz, cch);
        }
    }
    return hr;
}

// Read/write desktop.ini settings - Unicode (thunking function)
HRESULT SHGetSetFolderCustomSettingsW(LPSHFOLDERCUSTOMSETTINGSW pfcsW, LPCWSTR pwszPath, DWORD dwReadWrite)
{
    HRESULT hr = S_OK;

    if (pfcsW->dwSize >= sizeof(SHFOLDERCUSTOMSETTINGSW)  && pwszPath)
    {
        TCHAR szPath[MAX_PATH], *pszWebViewTemplate = NULL, *pszWebViewTemplateVersion = NULL;
        TCHAR *pszInfoTip = NULL, *pszIconFile = NULL, *pszLogo = NULL;

        SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));
        if (dwReadWrite == FCS_WRITE || dwReadWrite == FCS_FORCEWRITE)
        {
            if (pfcsW->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsW->pszWebViewTemplate)
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplate, &pszWebViewTemplate, pfcsW->cchWebViewTemplate);
                if (SUCCEEDED(hr) && pfcsW->pszWebViewTemplateVersion)
                {
                    hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                }
            }
            if (pfcsW->dwMask & FCSM_INFOTIP && pfcsW->pszInfoTip && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszInfoTip, &pszInfoTip, pfcsW->cchInfoTip);
            }
            if (pfcsW->dwMask & FCSM_ICONFILE && pfcsW->pszIconFile && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszIconFile, &pszIconFile, pfcsW->cchIconFile);
            }
            if (pfcsW->dwMask & FCSM_LOGO && pfcsW->pszLogo && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszLogo, &pszLogo, pfcsW->cchLogo);
            }
        }
        else if (dwReadWrite == FCS_READ)
        {
            if (pfcsW->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsW->pszWebViewTemplate && pfcsW->cchWebViewTemplate > 0)
            {
                pszWebViewTemplate = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchWebViewTemplate * sizeof(TCHAR));
                if (!pszWebViewTemplate)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszWebViewTemplate[0] = 0;
                    if (pfcsW->pszWebViewTemplateVersion)
                    {
                        hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                    }
                }
            }

            if (pfcsW->dwMask & FCSM_INFOTIP && pfcsW->pszInfoTip && pfcsW->cchInfoTip > 0 && SUCCEEDED(hr))
            {
                pszInfoTip = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchInfoTip * sizeof(TCHAR));
                if (!pszInfoTip)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszInfoTip[0] = 0;
                }
            }

            if (pfcsW->dwMask & FCSM_ICONFILE && pfcsW->pszIconFile && pfcsW->cchIconFile > 0 && SUCCEEDED(hr))
            {
                pszIconFile = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchIconFile * sizeof(TCHAR));
                if (!pszIconFile)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszIconFile[0] = 0;
                }
            }

            if (pfcsW->dwMask & FCSM_LOGO && pfcsW->pszLogo && pfcsW->cchLogo > 0 && SUCCEEDED(hr))
            {
                pszLogo = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchLogo * sizeof(TCHAR));
                if (!pszLogo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszLogo[0] = 0;
                }
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }
        
        if (SUCCEEDED(hr))
        {
            SHFOLDERCUSTOMSETTINGS fcs;
            fcs.dwSize = sizeof(LPSHFOLDERCUSTOMSETTINGS);
            fcs.dwMask = pfcsW->dwMask;
            fcs.pvid = pfcsW->pvid;
            fcs.pszWebViewTemplate = pszWebViewTemplate;
            fcs.cchWebViewTemplate = pfcsW->cchWebViewTemplate;
            fcs.pszWebViewTemplateVersion = pszWebViewTemplateVersion;
            fcs.pszInfoTip = pszInfoTip;
            fcs.cchInfoTip = pfcsW->cchInfoTip;
            fcs.pclsid = pfcsW->pclsid;
            fcs.dwFlags = pfcsW->dwFlags;
            fcs.pszIconFile = pszIconFile;
            fcs.cchIconFile = pfcsW->cchIconFile;
            fcs.iIconIndex  = pfcsW->iIconIndex;
            fcs.pszLogo = pszLogo;
            fcs.cchLogo = pfcsW->cchLogo;

            hr = SHGetSetFCS(&fcs, szPath, dwReadWrite);
            if (SUCCEEDED(hr))
            {
                if (dwReadWrite == FCS_READ)
                {
                    if (fcs.dwMask & FCSM_WEBVIEWTEMPLATE && fcs.pszWebViewTemplate)
                    {
                        SHTCharToUnicode(fcs.pszWebViewTemplate, pfcsW->pszWebViewTemplate, pfcsW->cchWebViewTemplate);
                    }
                    if (fcs.dwMask & FCSM_INFOTIP && fcs.pszInfoTip)
                    {
                        SHTCharToUnicode(fcs.pszInfoTip, pfcsW->pszInfoTip, pfcsW->cchInfoTip);
                    }
                    if (fcs.dwMask & FCSM_ICONFILE && fcs.pszIconFile)
                    {
                        SHTCharToUnicode(fcs.pszIconFile, pfcsW->pszIconFile, pfcsW->cchIconFile);
                    }
                    if (fcs.dwMask & FCSM_LOGO && fcs.pszLogo)
                    {
                        SHTCharToUnicode(fcs.pszLogo, pfcsW->pszLogo, pfcsW->cchLogo);
                    }
                    pfcsW->dwFlags = fcs.dwFlags;
                    pfcsW->iIconIndex = fcs.iIconIndex;
                    pfcsW->dwMask = fcs.dwMask;
                }
            }
        }

        // Free allocated memory
        if (pszWebViewTemplate)
        {
            LocalFree(pszWebViewTemplate);
        }
        if (pszWebViewTemplateVersion)
        {
            LocalFree(pszWebViewTemplateVersion);
        }
        if (pszInfoTip)
        {
            LocalFree(pszInfoTip);
        }
        if (pszIconFile)
        {
            LocalFree(pszIconFile);
        }
        if (pszLogo)
        {
            LocalFree(pszLogo);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


// Read/write desktop.ini settings - ANSI (thunking function)
HRESULT SHGetSetFolderCustomSettingsA(LPSHFOLDERCUSTOMSETTINGSA pfcsA, LPCSTR pszPath, DWORD dwReadWrite)
{
    HRESULT hr = S_OK;
    if (pfcsA->dwSize >= sizeof(SHFOLDERCUSTOMSETTINGSA) && pszPath)
    {
        TCHAR szPath[MAX_PATH], *pszWebViewTemplate = NULL, *pszWebViewTemplateVersion = NULL;
        TCHAR *pszInfoTip = NULL, *pszIconFile =NULL, *pszLogo = NULL;

        SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
        if (dwReadWrite == FCS_WRITE || dwReadWrite == FCS_FORCEWRITE)
        {
            if (pfcsA->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsA->pszWebViewTemplate)
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplate, &pszWebViewTemplate, pfcsA->cchWebViewTemplate);
                if (SUCCEEDED(hr) && pfcsA->pszWebViewTemplateVersion)
                {
                    hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                }
            }

            if (pfcsA->dwMask & FCSM_INFOTIP