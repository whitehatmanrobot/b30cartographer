               0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINER_COLOR_ICW(i)                           (0x00000268+(i)*4)
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINE_FACTOR(i)                               (0x00000270+(i)*4)
#define NV1196_SET_COMBINE_FACTOR_BLUE                                            7:0
#define NV1196_SET_COMBINE_FACTOR_GREEN                                          15:8
#define NV1196_SET_COMBINE_FACTOR_RED                                           23:16
#define NV1196_SET_COMBINE_FACTOR_ALPHA                                         31:24

#define NV1196_SET_COMBINER_ALPHA_OCW(i)                           (0x00000278+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION                                 31:15
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                14:14
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST                                    11:8
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST                                      7:4
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                         0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST                                      3:0
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                         0x0000000D

#define NV1196_SET_COMBINER0_COLOR_OCW                                     0x00000280
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION                                31:15
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER1_COLOR_OCW                                     0x00000284
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                          31:28
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                 0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                 0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT                               27:27
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                      0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                      0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION                                26:15
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0                               0x00000288
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                            7:5
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                              4:4
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                             3:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD          0x0000000F

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1                               0x0000028c
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                       7:7
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE          0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE           0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5               6:6
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE  0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE   0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12              5:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE  0x00000020

#define NV1196_SET_CONTROL0                                                0x00000290
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA                                  31:24
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE                                  23:20
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                19:16
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_CONTROL0_Z_FORMAT                                            15:12
#define NV1196_SET_CONTROL0_Z_FORMAT_FIXED                                 0x00000000
#define NV1196_SET_CONTROL0_Z_FORMAT_FLOAT                                 0x00000001
#define NV1196_SET_CONTROL0_WBUFFER_SELECT                                       11:8
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_0                               0x00000000
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_1                               0x00000001
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE                                  7:0
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                      0x00000001

#define NV1196_SET_LIGHT_CONTROL                                           0x00000294
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE                                       31:16
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_FALSE                            0x00000000
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_TRUE                             0x00000001
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE                                15:2
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                   0x00000000
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT               0x00000001
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                             1:1
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                0x00000000
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                 0x00000001
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                               0:0
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                  0x00000000
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                   0x00000001

#define NV1196_SET_COLOR_MATERIAL                                          0x00000298
#define NV1196_SET_COLOR_MATERIAL_V                                              31:0
#define NV1196_SET_COLOR_MATERIAL_V_DISABLED                               0x00000000
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION                               0x00000001
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT                                0x00000002
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                       0x00000003
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE                                0x00000004
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                       0x00000005
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                        0x00000006
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE               0x00000007
#define NV1196_SET_COLOR_MATERIAL_V_SPECULAR                               0x00000008
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                      0x00000009
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                       0x0000000A
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR              0x0000000B
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                       0x0000000C
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR              0x0000000D
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR               0x0000000E
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR      0x0000000F

#define NV1196_SET_FOG_MODE                                                0x0000029c
#define NV1196_SET_FOG_MODE_FOG_MODE                                             31:0
#define NV1196_SET_FOG_MODE_FOG_MODE_LINEAR                                0x00002601
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP                                   0x00000800
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2                                  0x00000801
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP_ABS                               0x00000802
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2_ABS                              0x00000803

#define NV1196_SET_FOG_GEN_MODE                                            0x000002a0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE                                     31:0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                     0x00000000
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                        0x00000001
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                        0x00000002
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                    0x00000003

#define NV1196_SET_FOG_ENABLE                                              0x000002a4
#define NV1196_SET_FOG_ENABLE_V                                                  31:0
#define NV1196_SET_FOG_ENABLE_V_FALSE                                      0x00000000
#define NV1196_SET_FOG_ENABLE_V_TRUE                                       0x00000001

#define NV1196_SET_FOG_COLOR                                               0x000002a8
#define NV1196_SET_FOG_COLOR_RED                                                  7:0
#define NV1196_SET_FOG_COLOR_GREEN                                               15:8
#define NV1196_SET_FOG_COLOR_BLUE                                               23:16
#define NV1196_SET_FOG_COLOR_ALPHA                                              31:24

#define NV1196_SET_COLOR_KEY_COLOR(i)                              (0x000002ac+(i)*4)
#define NV1196_SET_COLOR_KEY_COLOR_V                                             31:0

#define NV1196_SET_WINDOW_CLIP_TYPE                                        0x000002b4
#define NV1196_SET_WINDOW_CLIP_TYPE_V                                            31:0
#define NV1196_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                            0x00000000
#define NV1196_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                            0x00000001

#define NV1196_SET_WINDOW_CLIP_HORIZONTAL(i)                       (0x000002c0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                   11:0
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                  27:16

#define NV1196_SET_WINDOW_CLIP_VERTICAL(i)                         (0x000002e0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMIN                                     11:0
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMAX                                    27:16

#define NV1196_SET_ALPHA_TEST_ENABLE                                       0x00000300
#define NV1196_SET_ALPHA_TEST_ENABLE_V                                           31:0
#define NV1196_SET_ALPHA_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_ALPHA_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_BLEND_ENABLE                                            0x00000304
#define NV1196_SET_BLEND_ENABLE_V                                                31:0
#define NV1196_SET_BLEND_ENABLE_V_FALSE                                    0x00000000
#define NV1196_SET_BLEND_ENABLE_V_TRUE                                     0x00000001

#define NV1196_SET_CULL_FACE_ENABLE                                        0x00000308
#define NV1196_SET_CULL_FACE_ENABLE_V                                            31:0
#define NV1196_SET_CULL_FACE_ENABLE_V_FALSE                                0x00000000
#define NV1196_SET_CULL_FACE_ENABLE_V_TRUE                                 0x00000001

#define NV1196_SET_DEPTH_TEST_ENABLE                                       0x0000030c
#define NV1196_SET_DEPTH_TEST_ENABLE_V                                           31:0
#define NV1196_SET_DEPTH_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_DEPTH_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_DITHER_ENABLE                                           0x00000310
#define NV1196_SET_DITHER_ENABLE_V                                               31:0
#define NV1196_SET_DITHER_ENABLE_V_FALSE                                   0x00000000
#define NV1196_SET_DITHER_ENABLE_V_TRUE                                    0x00000001

#define NV1196_SET_LIGHTING_ENABLE                                         0x00000314
#define NV1196_SET_LIGHTING_ENABLE_V                                             31:0
#define NV1196_SET_LIGHTING_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LIGHTING_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_POINT_PARAMS_ENABLE                                     0x00000318
#define NV1196_SET_POINT_PARAMS_ENABLE_V                                         31:0
#define NV1196_SET_POINT_PARAMS_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_PARAMS_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POINT_SMOOTH_ENABLE                                     0x0000031c
#define NV1196_SET_POINT_SMOOTH_ENABLE_V                                         31:0
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_LINE_SMOOTH_ENABLE                                      0x00000320
#define NV1196_SET_LINE_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_POLY_SMOOTH_ENABLE                                      0x00000324
#define NV1196_SET_POLY_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_SKIN_ENABLE                                             0x00000328
#define NV1196_SET_SKIN_ENABLE_V                                                 31:0
#define NV1196_SET_SKIN_ENABLE_V_FALSE                                     0x00000000
#define NV1196_SET_SKIN_ENABLE_V_TRUE                                      0x00000001

#define NV1196_SET_STENCIL_TEST_ENABLE                                     0x0000032c
#define NV1196_SET_STENCIL_TEST_ENABLE_V                                         31:0
#define NV1196_SET_STENCIL_TEST_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_STENCIL_TEST_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POLY_OFFSET_POINT_ENABLE                                0x00000330
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V                                    31:0
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                        0x00000000
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                         0x00000001

#define NV1196_SET_POLY_OFFSET_LINE_ENABLE                                 0x00000334
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_POLY_OFFSET_FILL_ENABLE                                 0x00000338
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_ALPHA_FUNC                                              0x0000033c
#define NV1196_SET_ALPHA_FUNC_V                                                  31:0
#define NV1196_SET_ALPHA_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_ALPHA_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_ALPHA_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_ALPHA_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_ALPHA_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_ALPHA_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_ALPHA_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_ALPHA_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_ALPHA_REF                                               0x00000340
#define NV1196_SET_ALPHA_REF_V                                                   31:0

#define NV1196_SET_BLEND_FUNC_SFACTOR                                      0x00000344
#define NV1196_SET_BLEND_FUNC_SFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_FUNC_DFACTOR                                      0x00000348
#define NV1196_SET_BLEND_FUNC_DFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_COLOR                                             0x0000034c
#define NV1196_SET_BLEND_COLOR_V                                                 31:0

#define NV1196_SET_BLEND_EQUATION                                          0x00000350
#define NV1196_SET_BLEND_EQUATION_V                                              31:0
#define NV1196_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                          0x0000800A
#define NV1196_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                  0x0000800B
#define NV1196_SET_BLEND_EQUATION_V_FUNC_ADD                               0x00008006
#define NV1196_SET_BLEND_EQUATION_V_MIN                                    0x00008007
#define NV1196_SET_BLEND_EQUATION_V_MAX                                    0x00008008

#define NV1196_SET_DEPTH_FUNC                                              0x00000354
#define NV1196_SET_DEPTH_FUNC_V                                                  31:0
#define NV1196_SET_DEPTH_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_DEPTH_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_DEPTH_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_DEPTH_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_DEPTH_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_DEPTH_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_DEPTH_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_DEPTH_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_COLOR_MASK                                              0x00000358
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                31:24
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE                                  23:16
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                       0x00000000
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                        0x00000001
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                 15:8
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                   7:0
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                      0x00000000
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                       0x00000001

#define NV1196_SET_DEPTH_MASK                                              0x0000035c
#define NV1196_SET_DEPTH_MASK_V                                                  31:0
#define NV1196_SET_DEPTH_MASK_V_FALSE                                      0x00000000
#define NV1196_SET_DEPTH_MASK_V_TRUE                                       0x00000001

#define NV1196_SET_STENCIL_MASK                                            0x00000360
#define NV1196_SET_STENCIL_MASK_V                                                31:0

#define NV1196_SET_STENCIL_FUNC                                            0x00000364
#define NV1196_SET_STENCIL_FUNC_V                                                31:0
#define NV1196_SET_STENCIL_FUNC_V_NEVER                                    0x00000200
#define NV1196_SET_STENCIL_FUNC_V_LESS                                     0x00000201
#define NV1196_SET_STENCIL_FUNC_V_EQUAL                                    0x00000202
#define NV1196_SET_STENCIL_FUNC_V_LEQUAL                                   0x00000203
#define NV1196_SET_STENCIL_FUNC_V_GREATER                                  0x00000204
#define NV1196_SET_STENCIL_FUNC_V_NOTEQUAL                                 0x00000205
#define NV1196_SET_STENCIL_FUNC_V_GEQUAL                                   0x00000206
#define NV1196_SET_STENCIL_FUNC_V_ALWAYS                                   0x00000207

#define NV1196_SET_STENCIL_FUNC_REF                                        0x00000368
#define NV1196_SET_STENCIL_FUNC_REF_V                                            31:0

#define NV1196_SET_STENCIL_FUNC_MASK                                       0x0000036c
#define NV1196_SET_STENCIL_FUNC_MASK_V                                           31:0

#define NV1196_SET_STENCIL_OP_FAIL                                         0x00000370
#define NV1196_SET_STENCIL_OP_FAIL_V                                             31:0
#define NV1196_SET_STENCIL_OP_FAIL_V_KEEP                                  0x00001E00
#define NV1196_SET_STENCIL_OP_FAIL_V_ZERO                                  0x00000000
#define NV1196_SET_STENCIL_OP_FAIL_V_REPLACE                               0x00001E01
#define NV1196_SET_STENCIL_OP_FAIL_V_INCRSAT                               0x00001E02
#define NV1196_SET_STENCIL_OP_FAIL_V_DECRSAT                               0x00001E03
#define NV1196_SET_STENCIL_OP_FAIL_V_INVERT                                0x0000150A
#define NV1196_SET_STENCIL_OP_FAIL_V_INCR                                  0x00008507
#define NV1196_SET_STENCIL_OP_FAIL_V_DECR                                  0x00008508

#define NV1196_SET_STENCIL_OP_ZFAIL                                        0x00000374
#define NV1196_SET_STENCIL_OP_ZFAIL_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZFAIL_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZFAIL_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZFAIL_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECR                                 0x00008508

#define NV1196_SET_STENCIL_OP_ZPASS                                        0x00000378
#define NV1196_SET_STENCIL_OP_ZPASS_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZPASS_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZPASS_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZPASS_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZPASS_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECR                                 0x00008508

#define NV1196_SET_SHADE_MODE                                              0x0000037c
#define NV1196_SET_SHADE_MODE_V                                                  31:0
#define NV1196_SET_SHADE_MODE_V_FLAT                                       0x00001D00
#define NV1196_SET_SHADE_MODE_V_SMOOTH                                     0x00001D01

#define NV1196_SET_LINE_WIDTH                                              0x00000380
#define NV1196_SET_LINE_WIDTH_V                                                  31:0

#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR                             0x00000384
#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                 31:0

#define NV1196_SET_POLYGON_OFFSET_BIAS                                     0x00000388
#define NV1196_SET_POLYGON_OFFSET_BIAS_V                                         31:0

#define NV1196_SET_FRONT_POLYGON_MODE                                      0x0000038c
#define NV1196_SET_FRONT_POLYGON_MODE_V                                          31:0
#define NV1196_SET_FRONT_POLYGON_MODE_V_POINT                              0x00001B00
#define NV1196_SET_FRONT_POLYGON_MODE_V_LINE                               0x00001B01
#define NV1196_SET_FRONT_POLYGON_MODE_V_FILL                               0x00001B02

#define NV1196_SET_BACK_POLYGON_MODE                                       0x00000390
#define NV1196_SET_BACK_POLYGON_MODE_V                                           31:0
#define NV1196_SET_BACK_POLYGON_MODE_V_POINT                               0x00001B00
#define NV1196_SET_BACK_POLYGON_MODE_V_LINE                                0x00001B01
#define NV1196_SET_BACK_POLYGON_MODE_V_FILL                                0x00001B02

#define NV1196_SET_CLIP_MIN                                                0x00000394
#define NV1196_SET_CLIP_MIN_V                                                    31:0

#define NV1196_SET_CLIP_MAX                                                0x00000398
#define NV1196_SET_CLIP_MAX_V                                                    31:0

#define NV1196_SET_CULL_FACE                                               0x0000039c
#define NV1196_SET_CULL_FACE_V                                                   31:0
#define NV1196_SET_CULL_FACE_V_FRONT                                       0x00000404
#define NV1196_SET_CULL_FACE_V_BACK                                        0x00000405
#define NV1196_SET_CULL_FACE_V_FRONT_AND_BACK                              0x00000408

#define NV1196_SET_FRONT_FACE                                              0x000003a0
#define NV1196_SET_FRONT_FACE_V                                                  31:0
#define NV1196_SET_FRONT_FACE_V_CW                                         0x00000900
#define NV1196_SET_FRONT_FACE_V_CCW                                        0x00000901

#define NV1196_SET_NORMALIZATION_ENABLE                                    0x000003a4
#define NV1196_SET_NORMALIZATION_ENABLE_V                                        31:0
#define NV1196_SET_NORMALIZATION_ENABLE_V_FALSE                            0x00000000
#define NV1196_SET_NORMALIZATION_ENABLE_V_TRUE                             0x00000001

#define NV1196_SET_MATERIAL_EMISSION(i)                            (0x000003a8+(i)*4)
#define NV1196_SET_MATERIAL_EMISSION_V                                           31:0

#define NV1196_SET_MATERIAL_ALPHA                                          0x000003b4
#define NV1196_SET_MATERIAL_ALPHA_V                                              31:0

#define NV1196_SET_SPECULAR_ENABLE                                         0x000003b8
#define NV1196_SET_SPECULAR_ENABLE_V                                             31:0
#define NV1196_SET_SPECULAR_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_SPECULAR_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LIGHT_ENABLE_MASK                                       0x000003bc
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0                                       1:0
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1                                       3:2
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2                                       5:4
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3                                       7:6
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4                                       9:8
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5                                     11:10
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6                                     13:12
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7                                     15:14
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                           0x00000003

#define NV1196_SET_TEXGEN_S(i)                                    (0x000003c0+(i)*16)
#define NV1196_SET_TEXGEN_S_V                                                    31:0
#define NV1196_SET_TEXGEN_S_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_S_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_S_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_S_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_S_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_S_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_S_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_T(i)                                    (0x000003c4+(i)*16)
#define NV1196_SET_TEXGEN_T_V                                                    31:0
#define NV1196_SET_TEXGEN_T_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_T_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_T_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_T_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_T_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_T_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_T_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_R(i)                                    (0x000003c8+(i)*16)
#define NV1196_SET_TEXGEN_R_V                                                    31:0
#define NV1196_SET_TEXGEN_R_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_R_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_R_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_R_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_R_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_R_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_Q(i)                                    (0x000003cc+(i)*16)
#define NV1196_SET_TEXGEN_Q_V                                                    31:0
#define NV1196_SET_TEXGEN_Q_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_Q_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_Q_V_OBJECT_LINEAR                                0x00002401

#define NV1196_SET_TEXTURE_MATRIX0_ENABLE                                  0x000003e0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TEXTURE_MATRIX1_ENABLE                                  0x000003e4
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TLMODE                                                  0x000003e8
#define NV1196_SET_TLMODE_PASSTHROUGH                                             0:0
#define NV1196_SET_TLMODE_PASSTHROUGH_TRUE                                 0x00000001
#define NV1196_SET_TLMODE_PASSTHROUGH_FALSE                                0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0                                              1:1
#define NV1196_SET_TLMODE_W_DIVIDE_0_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0_ENABLE                                0x00000001
#define NV1196_SET_TLMODE_W_DIVIDE_1                                              2:2
#define NV1196_SET_TLMODE_W_DIVIDE_1_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_1_ENABLE                                0x00000001

#define NV1196_SET_POINT_SIZE                                              0x000003ec
#define NV1196_SET_POINT_SIZE_V                                                  31:0

#define NV1196_SET_SWATH_WIDTH                                             0x000003f0
#define NV1196_SET_SWATH_WIDTH_V                                                 31:0
#define NV1196_SET_SWATH_WIDTH_V_8                                         0x00000000
#define NV1196_SET_SWATH_WIDTH_V_16                                        0x00000001
#define NV1196_SET_SWATH_WIDTH_V_32                                        0x00000002
#define NV1196_SET_SWATH_WIDTH_V_64                                        0x00000003

#define NV1196_SET_FLAT_SHADE_OP                                           0x000003f4
#define NV1196_SET_FLAT_SHADE_OP_V                                               31:0
#define NV1196_SET_FLAT_SHADE_OP_V_LAST_VTX                                0x00000000
#define NV1196_SET_FLAT_SHADE_OP_V_FIRST_VTX                               0x00000001

#define NV1196_SET_MODEL_VIEW_MATRIX0(i)                           (0x00000400+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX0_V                                          31:0

#define NV1196_SET_MODEL_VIEW_MATRIX1(i)                           (0x00000440+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX1_V                                          31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                   (0x00000480+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                  31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                   (0x000004c0+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                  31:0

#define NV1196_SET_COMPOSITE_MATRIX(i)                             (0x00000500+(i)*4)
#define NV1196_SET_COMPOSITE_MATRIX_V                                            31:0

#define NV1196_SET_TEXTURE_MATRIX0(i)                              (0x00000540+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX0_V                                             31:0

#define NV1196_SET_TEXTURE_MATRIX1(i)                              (0x00000580+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX1_V                                             31:0

#define NV1196_SET_TEXGEN_SPLANE0(i)                               (0x00000600+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE0(i)                               (0x00000610+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE0(i)                               (0x00000620+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE0(i)                               (0x00000630+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_SPLANE1(i)                               (0x00000640+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE1(i)                               (0x00000650+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE1(i)                               (0x00000660+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE1(i)                               (0x00000670+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE1_V                                              31:0

#define NV1196_SET_FOG_PARAMS(i)                                   (0x00000680+(i)*4)
#define NV1196_SET_FOG_PARAMS_V                                                  31:0

#define NV1196_SET_FOG_PLANE(i)                                    (0x0000068c+(i)*4)
#define NV1196_SET_FOG_PLANE_V                                                   31:0

#define NV1196_SET_SPECULAR_PARAMS(i)                              (0x000006a0+(i)*4)
#define NV1196_SET_SPECULAR_PARAMS_V                                             31:0

#define NV1196_SET_SCENE_AMBIENT_COLOR(i)                          (0x000006c4+(i)*4)
#define NV1196_SET_SCENE_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_VIEWPORT_OFFSET(i)                              (0x000006e8+(i)*4)
#define NV1196_SET_VIEWPORT_OFFSET_V                                             31:0

#define NV1196_SET_POINT_PARAMS(i)                                 (0x000006f8+(i)*4)
#define NV1196_SET_POINT_PARAMS_V                                                31:0

#define NV1196_SET_EYE_POSITION(i)                                 (0x00000718+(i)*4)
#define NV1196_SET_EYE_POSITION_V                                                31:0

#define NV1196_SET_EYE_DIRECTION_SW(i)                             (0x0000072c+(i)*4)

#define NV1196_SET_LIGHT_AMBIENT_COLOR(i,j)                (0x00000800+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_DIFFUSE_COLOR(i,j)                (0x0000080c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_DIFFUSE_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_SPECULAR_COLOR(i,j)               (0x00000818+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPECULAR_COLOR_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_RANGE(i)                          (0x00000824+(i)*128)
#define NV1196_SET_LIGHT_LOCAL_RANGE_V                                           31:0

#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)         (0x00000828+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR_V                                  31:0

#define NV1196_SET_LIGHT_INFINITE_DIRECTION(i,j)           (0x00000834+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_DIRECTION_V                                    31:0

#define NV1196_SET_LIGHT_SPOT_FALLOFF(i,j)                 (0x00000840+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_FALLOFF_V                                          31:0

#define NV1196_SET_LIGHT_SPOT_DIRECTION(i,j)               (0x0000084c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_DIRECTION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_POSITION(i,j)               (0x0000085c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_POSITION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_ATTENUATION(i,j)            (0x00000868+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_ATTENUATION_V                                     31:0

#define NV1196_SET_VERTEX3F(i)                                     (0x00000c00+(i)*4)
#define NV1196_SET_VERTEX3F_V                                                    31:0

#define NV1196_SET_VERTEX4F(i)                                     (0x00000c18+(i)*4)
#define NV1196_SET_VERTEX4F_V                                                    31:0

#define NV1196_SET_VERTEX4S(i)                                     (0x00000c28+(i)*4)
#define NV1196_SET_VERTEX4S_V                                                    31:0

#define NV1196_SET_NORMAL3F(i)                                     (0x00000c30+(i)*4)
#define NV1196_SET_NORMAL3F_V                                                    31:0

#define NV1196_SET_NORMAL3S(i)                                     (0x00000c40+(i)*4)
#define NV1196_SET_NORMAL3S_V                                                    31:0

#define NV1196_SET_DIFFUSE_COLOR4F(i)                              (0x00000c50+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR4F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR3F(i)                              (0x00000c60+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR3F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR4UB                                        0x00000c6c
#define NV1196_SET_DIFFUSE_COLOR4UB_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4F(i)                             (0x00000c70+(i)*4)
#define NV1196_SET_SPECULAR_COLOR4F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR3F(i)                             (0x00000c80+(i)*4)
#define NV1196_SET_SPECULAR_COLOR3F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4UB                                       0x00000c8c
#define NV1196_SET_SPECULAR_COLOR4UB_V                                           31:0

#define NV1196_SET_TEXCOORD0_2F(i)                                 (0x00000c90+(i)*4)
#define NV1196_SET_TEXCOORD0_2F_V                                                31:0

#define NV1196_SET_TEXCOORD0_2S                                            0x00000c98
#define NV1196_SET_TEXCOORD0_2S_V                                                31:0

#define NV1196_SET_TEXCOORD0_4F(i)                                 (0x00000ca0+(i)*4)
#define NV1196_SET_TEXCOORD0_4F_V                                                31:0

#define NV1196_SET_TEXCOORD0_4S(i)                                 (0x00000cb0+(i)*4)
#define NV1196_SET_TEXCOORD0_4S_V                                                31:0

#define NV1196_SET_TEXCOORD1_2F(i)                                 (0x00000cb8+(i)*4)
#define NV1196_SET_TEXCOORD1_2F_V                                                31:0

#define NV1196_SET_TEXCOORD1_2S                                            0x00000cc0
#define NV1196_SET_TEXCOORD1_2S_V                                                31:0

#define NV1196_SET_TEXCOORD1_4F(i)                                 (0x00000cc8+(i)*4)
#define NV1196_SET_TEXCOORD1_4F_V                                                31:0

#define NV1196_SET_TEXCOORD1_4S(i)                                 (0x00000cd8+(i)*4)
#define NV1196_SET_TEXCOORD1_4S_V                                                31:0

#define NV1196_SET_FOG1F                                                   0x00000ce0
#define NV1196_SET_FOG1F_V                                                       31:0

#define NV1196_SET_WEIGHT1F                                                0x00000ce4
#define NV1196_SET_WEIGHT1F_V                                                    31:0

#define NV1196_SET_EDGE_FLAG                                               0x00000cec
#define NV1196_SET_EDGE_FLAG_V                                                   31:0

#define NV1196_INVALIDATE_VERTEX_CACHE_FILE                                0x00000cf0
#define NV1196_INVALIDATE_VERTEX_CACHE_FILE_V                                    31:0

#define NV1196_INVALIDATE_VERTEX_FILE                                      0x00000cf4
#define NV1196_INVALIDATE_VERTEX_FILE_V                                          31:0

#define NV1196_TL_NOP                                                      0x00000cf8
#define NV1196_TL_NOP_V                                                          31:0

#define NV1196_TL_SYNC                                                     0x00000cfc
#define NV1196_TL_SYNC_V                                                         31:0

#define NV1196_SET_VERTEX_ARRAY_OFFSET                                     0x00000d00
#define NV1196_SET_VERTEX_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_DIFFUSE_ARRAY_OFFSET                                    0x00000d08
#define NV1196_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                   31:0

#define NV1196_SET_SPECULAR_ARRAY_OFFSET                                   0x00000d10
#define NV1196_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                  31:0

#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET                                 0x00000d18
#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET                                 0x00000d20
#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_NORMAL_ARRAY_OFFSET                                     0x00000d28
#define NV1196_SET_NORMAL_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_WEIGHT_ARRAY_OFFSET                                     0x00000d30
#define NV1196_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_FOG_ARRAY_OFFSET                                        0x00000d38
#define NV1196_SET_FOG_ARRAY_OFFSET_OFFSET                                       31:0

#define NV1196_SET_VERTEX_ARRAY_FORMAT                                     0x00000d04
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W                                        31:24
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_NONE                              0x00000000
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                           0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_STRIDE                                    23:8
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_2                              0x00000002
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_DIFFUSE_ARRAY_FORMAT                                    0x00000d0c
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                   31:8
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                      7:4
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                      3:0
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004

#define NV1196_SET_SPECULAR_ARRAY_FORMAT                                   0x00000d14
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                  31:8
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE                                     7:4
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                            0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                            0x00000003
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                            0x00000004
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE                                     3:0
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA           0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                        0x00000002
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA           0x00000004

#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT                                 0x00000d1c
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT                                 0x00000d24
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_NORMAL_ARRAY_FORMAT                                     0x00000d2c
#define NV1196_SET_NORMAL_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_WEIGHT_ARRAY_FORMAT                                     0x00000d34
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                              0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_FOG_ARRAY_FORMAT                                        0x00000d3c
#define NV1196_SET_FOG_ARRAY_FORMAT_STRIDE                                       31:8
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE                                          7:4
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_0                                 0x00000000
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_1                                 0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE                                          3:0
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                             0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                             0x00000002

#define NV1196_SET_LOGIC_OP_ENABLE                                         0x00000d40
#define NV1196_SET_LOGIC_OP_ENABLE_V                                             31:0
#define NV1196_SET_LOGIC_OP_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LOGIC_OP_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LOGIC_OP                                                0x00000d44
#define NV1196_SET_LOGIC_OP_V                                                    31:0
#define NV1196_SET_LOGIC_OP_V_CLEAR                                        0x00001500
#define NV1196_SET_LOGIC_OP_V_AND                                          0x00001501
#define NV1196_SET_LOGIC_OP_V_AND_REVERSE                                  0x00001502
#define NV1196_SET_LOGIC_OP_V_COPY                                         0x00001503
#define NV1196_SET_LOGIC_OP_V_AND_INVERTED                                 0x00001504
#define NV1196_SET_LOGIC_OP_V_NOOP                                         0x00001505
#define NV1196_SET_LOGIC_OP_V_XOR                                          0x00001506
#define NV1196_SET_LOGIC_OP_V_OR                                           0x00001507
#define NV1196_SET_LOGIC_OP_V_NOR                                          0x00001508
#define NV1196_SET_LOGIC_OP_V_EQUIV                                        0x00001509
#define NV1196_SET_LOGIC_OP_V_INVERT                                       0x0000150A
#define NV1196_SET_LOGIC_OP_V_OR_REVERSE                                   0x0000150B
#define NV1196_SET_LOGIC_OP_V_COPY_INVERTED                                0x0000150C
#define NV1196_SET_LOGIC_OP_V_OR_INVERTED                                  0x0000150D
#define NV1196_SET_LOGIC_OP_V_NAND                                         0x0000150E
#define NV1196_SET_LOGIC_OP_V_SET                                          0x0000150F

#define NV1196_SET_BEGIN_END                                               0x00000dfc
#define NV1196_SET_BEGIN_END_OP                                                  31:0
#define NV1196_SET_BEGIN_END_OP_END                                        0x00000000
#define NV1196_SET_BEGIN_END_OP_POINTS                                     0x00000001
#define NV1196_SET_BEGIN_END_OP_LINES                                      0x00000002
#define NV1196_SET_BEGIN_END_OP_LINE_LOOP                                  0x00000003
#define NV1196_SET_BEGIN_END_OP_LINE_STRIP                                 0x00000004
#define NV1196_SET_BEGIN_END_OP_TRIANGLES                                  0x00000005
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_STRIP                             0x00000006
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_FAN                               0x00000007
#define NV1196_SET_BEGIN_END_OP_QUADS                                      0x00000008
#define NV1196_SET_BEGIN_END_OP_QUAD_STRIP                                 0x00000009
#define NV1196_SET_BEGIN_END_OP_POLYGON                                    0x0000000A

#define NV1196_ARRAY_ELEMENT16(i)                                  (0x00000e00+(i)*4)
#define NV1196_ARRAY_ELEMENT16_VERTEX0                                           15:0
#define NV1196_ARRAY_ELEMENT16_VERTEX1                                          31:16

#define NV1196_SET_BEGIN_END2                                              0x000010fc
#define NV1196_SET_BEGIN_END2_OP                                                 31:0
#define NV1196_SET_BEGIN_END2_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END2_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END2_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END2_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END2_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END2_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END2_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END2_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END2_OP_POLYGON                                   0x0000000A

#define NV1196_ARRAY_ELEMENT32(i)                                  (0x00001100+(i)*4)
#define NV1196_ARRAY_ELEMENT32_V                                                 31:0

#define NV1196_SET_BEGIN_END3                                              0x000013fc
#define NV1196_SET_BEGIN_END3_OP                                                 31:0
#define NV1196_SET_BEGIN_END3_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END3_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END3_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END3_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END3_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END3_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END3_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END3_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END3_OP_POLYGON                                   0x0000000A

#define NV1196_DRAW_ARRAYS(i)                                      (0x00001400+(i)*4)
#define NV1196_DRAW_ARRAYS_COUNT                                                31:24
#define NV1196_DRAW_ARRAYS_START_INDEX                                           23:0

#define NV1196_SET_BEGIN_END4                                              0x000017fc
#define NV1196_SET_BEGIN_END4_OP                                                 31:0
#define NV1196_SET_BEGIN_END4_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END4_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END4_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END4_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END4_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END4_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END4_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END4_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END4_OP_POLYGON                                   0x0000000A

#define NV1196_INLINE_ARRAY(i)                                     (0x00001800+(i)*4)
#define NV1196_INLINE_ARRAY_V                                                    31:0

#define NV1196_DEBUG_INIT(i)                                       (0x00001600+(i)*4)
#define NV1196_DEBUG_INIT_V                                                      31:0


// This typedef really should be the same as Nv20KelvinPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.

typedef NvV32 Nv097Typedef;

/* class NV20_KELVIN_PRIMITIVE */
#define  NV20_KELVIN_PRIMITIVE                                    (0x00000097)
/* NvNotification[] elements */
#define NV097_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV097_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV097_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV097_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV097_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV097_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV097_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvU32 SetFlipRead;
    NvU32 SetFlipWrite;
    NvU32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvV32 Reserved018c[0x4/4];
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvU32 SetContextDmaVertexA;
    NvU32 SetContextDmaVertexB;
    NvU32 SetContextDmaSemaphore;
    NvU32 SetContextDmaReport;
    NvV32 Reserved01ac[0x54/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvV32 Reserved0218[0x48/4];
    NvV32 SetCombinerAlphaICW[8];
    NvV32 Reserved0280[0x8/4];
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 Reserved02ac[0x8/4];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinMode;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[4];
    NvV32 Reserved0400[0x20/4];
    NvV32 SetTextureMatrixEnable[4];
    NvV32 Reserved0430[0xc/4];
    NvU32 SetPointSize;
    NvF32 SetProjectionMatrix[16];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetModelViewMatrix2[16];
    NvF32 SetModelViewMatrix3[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix2[16];
    NvF32 SetInverseModelViewMatrix3[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvF32 SetTextureMatrix2[16];
    NvF32 SetTextureMatrix3[16];
    NvV32 Reserved07c0[0x80/4];
    struct {
    NvF32 S[4];
    NvF32 T[4];
    NvF32 R[4];
    NvF32 Q[4];
    } SetTexgenPlane[4];
    NvV32 Reserved0940[0x80/4];
    NvF32 SetFogParams[3];
    NvV32 SetTexgenViewModel;
    NvF32 SetFogPlane[4];
    NvF32 SetSpecularParams[6];
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved0a00[0x10/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a1c[0x4/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 SetCombinerFactor0[8];
    NvV32 SetCombinerFactor1[8];
    NvV32 SetCombinerAlphaOCW[8];
    NvV32 SetCombinerColorICW[8];
    NvU32 SetColorKeyColor[4];
    NvF32 SetViewportScale[4];
    NvU32 SetTransformProgram[32];
    NvF32 SetTransformConstant[32];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvV32 Reserved0c24[0x1c/4];
    } SetBackLight[8];
    NvV32 Reserved0e00[0x200/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved1074[0xc/4];
    } SetLight[8];
    NvV32 Reserved1400[0x7c/4];
    NvV32 SetStippleControl;
    NvU32 SetStipplePattern[32];
    NvF32 SetVertex3f[3];
    NvV32 Reserved150c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved153c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved1548[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved159c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved15c4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetTexcoord2_2f[2];
    NvS32 SetTexcoord2_2s;
    NvV32 Reserved15ec[0x4/4];
    NvF32 SetTexcoord2_4f[4];
    NvS32 SetTexcoord2_4s[2];
    NvF32 SetTexcoord3_2f[2];
    NvS32 SetTexcoord3_2s;
    NvV32 Reserved1614[0xc/4];
    NvF32 SetTexcoord3_4f[4];
    NvS32 SetTexcoord3_4s[2];
    NvV32 Reserved1638[0x60/4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvF32 SetWeight2f[2];
    NvV32 Reserved16a8[0x8/4];
    NvF32 SetWeight3f[3];
    NvV32 SetEdgeFlag;
    NvF32 SetWeight4f[4];
    NvF32 SetTransformFixedConst3[4];
    NvF32 SetTransformFixedConst0[4];
    NvF32 SetTransformFixedConst1[4];
    NvF32 SetTransformFixedConst2[4];
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvV32 SetVertexDataArrayOffset[16];
    NvV32 SetVertexDataArrayFormat[16];
    NvF32 SetBackSceneAmbientColor[3];
    NvF32 SetBackMaterialAlpha;
    NvF32 SetBackMaterialEmission[3];
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 SetTwoSideLightEn;
    NvV32 ClearReportValue;
    NvV32 SetZpassPixelCountEnable;
    NvV32 GetReport;
    NvF32 SetTLConstZero[3];
    NvF32 SetEyeDirection[3];
    NvF32 SetLinearFogConst[3];
    NvV32 SetShaderClipPlaneMode;
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16;
    NvV32 Reserved1804[0x4/4];
    NvU32 ArrayElement32;
    NvV32 Reserved180c[0x4/4];
    NvV32 DrawArrays;
    NvV32 Reserved1814[0x4/4];
    NvU32 InlineArray;
    NvF32 SetEyeVector[3];
    NvU32 InlineVertexReuse;
    NvV32 Reserved182c[0x54/4];
    struct {
    NvF32 M[2];
    } SetVertexData2f[16];
    NvS32 SetVertexData2s[16];
    NvS32 SetVertexData4ub[16];
    struct {
    NvS32 M[2];
    } SetVertexData4s[16];
    struct {
    NvF32 M[4];
    } SetVertexData4f[16];
    struct {
    NvU32 Offset;
    NvV32 Format;
    NvV32 Address;
    NvV32 Control0;
    NvV32 Control1;
    NvV32 Filter;
    NvV32 Reserved1b18[0x4/4];
    NvV32 ImageRect;
    NvV32 Palette;
    NvU32 BorderColor;
    NvF32 SetBumpEnvMat00;
    NvF32 SetBumpEnvMat01;
    NvF32 SetBumpEnvMat11;
    NvF32 SetBumpEnvMat10;
    NvF32 SetBumpEnvScale;
    NvF32 SetBumpEnvOffset;
    } SetTexture[4];
    NvV32 Reserved1c00[0x164/4];
    NvV32 ParkAttribute;
    NvV32 UnparkAttribute;
    NvU32 SetSemaphoreOffset;
    NvU32 BackEndWriteSemaphoreRelease;
    NvU32 TextureReadSemaphoreRelease;
    NvV32 SetZMinMaxControl;
    NvV32 SetAntiAliasingControl;
    NvV32 SetCompressZBufferEn;
    NvV32 SetOccludeZStencilEn;
    NvV32 Reserved1d88[0x4/4];
    NvU32 SetZStencilClearValue;
    NvU32 SetColorClearValue;
    NvV32 ClearSurface;
    NvV32 SetClearRectHorizontal;
    NvV32 SetClearRectVertical;
    NvV32 Reserved1da0[0x40/4];
    NvV32 SetBeginPatch0;
    NvV32 SetBeginPatch1;
    NvV32 SetBeginPatch2;
    NvV32 SetBeginPatch3;
    NvV32 SetEndPatch;
    NvV32 SetBeginEndSwatch;
    NvV32 SetBeginEndCurve;
    NvV32 Reserved1dfc[0x4/4];
    NvF32 SetCurveCoefficients[4];
    NvV32 SetBeginTransition0;
    NvV32 SetBeginTransition1;
    NvV32 SetBeginTransition2;
    NvV32 SetEndTransition;
    NvV32 SetSpecularFogFactor[2];
    NvF32 SetBackSpecularParams[6];
    NvV32 SetCombinerColorOCW[8];
    NvV32 SetCombinerControl;
    NvV32 Reserved1e64[0x4/4];
    NvF32 SetShadowZSlopeThreshold;
    NvV32 SetShadowDepthFunc;
    NvV32 SetShaderStageProgram;
    NvV32 SetDotRGBMapping;
    NvV32 SetShaderOtherStageInput;
    NvV32 Reserved1e7c[0x4/4];
    NvF32 SetTransformData[4];
    NvU32 LaunchTransformProgram;
    NvV32 SetTransformExecutionMode;
    NvV32 SetTransformProgramCxtWriteEn;
    NvU32 SetTransformProgramLoad;
    NvU32 SetTransformProgramStart;
    NvU32 SetTransformConstantLoad;
    NvV32 Reserved1ea8[0x118/4];
    NvV32 DebugInit[10];
    NvV32 Reserved1fe8[0x18/4];
} Nv20KelvinPrimitive;

#define NV097_NO_OPERATION                                                  0x00000100

#define NV097_NOTIFY                                                        0x00000104
#define NV097_NOTIFY_TYPE                                                         31:0
#define NV097_NOTIFY_TYPE_WRITE_ONLY                                        0x00000000
#define NV097_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                 0x00000001

#define NV097_SET_WARNING_ENABLE                                            0x00000108
#define NV097_SET_WARNING_ENABLE_V                                                31:0
#define NV097_SET_WARNING_ENABLE_V_STOP                                     0x00000000
#define NV097_SET_WARNING_ENABLE_V_WRITE_ONLY                               0x00000001
#define NV097_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                        0x00000002

#define NV097_GET_STATE                                                     0x0000010c
#define NV097_GET_STATE_GETSTATE                                                  31:0
#define NV097_GET_STATE_GETSTATE_ALL_STATE                                  0x00000001
#define NV097_GET_STATE_GETSTATE_PUT_ALL_STATE                              0x00000002

#define NV097_WAIT_FOR_IDLE                                                 0x00000110

#define NV097_PM_TRIGGER                                                    0x00000140
#define NV097_PM_TRIGGER_V                                                        31:0
#define NV097_PM_TRIGGER_V_NOP                                              0x00000000
#define NV097_PM_TRIGGER_V_TRIGGER                                          0x00000001

#define NV097_SET_FLIP_READ                                                 0x00000120
#define NV097_SET_FLIP_READ_V                                                     31:0

#define NV097_SET_FLIP_WRITE                                                0x00000124
#define NV097_SET_FLIP_WRITE_V                                                    31:0

#define NV097_SET_FLIP_MODULO                                               0x00000128
#define NV097_SET_FLIP_MODULO_V                                                   31:0

#define NV097_FLIP_INCREMENT_WRITE                                          0x0000012c

#define NV097_FLIP_STALL                                                    0x00000130

#define NV097_SET_CONTEXT_DMA_NOTIFIES                                      0x00000180
#define NV097_SET_CONTEXT_DMA_NOTIFIES_V                                          31:0

#define NV097_SET_CONTEXT_DMA_A                                             0x00000184
#define NV097_SET_CONTEXT_DMA_A_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_B                                             0x00000188
#define NV097_SET_CONTEXT_DMA_B_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_STATE                                         0x00000190
#define NV097_SET_CONTEXT_DMA_STATE_V                                             31:0

#define NV097_SET_CONTEXT_DMA_COLOR                                         0x00000194
#define NV097_SET_CONTEXT_DMA_COLOR_V                                             31:0

#define NV097_SET_CONTEXT_DMA_ZETA                                          0x00000198
#define NV097_SET_CONTEXT_DMA_ZETA_V                                              31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_A                                      0x0000019c
#define NV097_SET_CONTEXT_DMA_VERTEX_A_V                                          31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_B                                      0x000001a0
#define NV097_SET_CONTEXT_DMA_VERTEX_B_V                                          31:0

#define NV097_SET_CONTEXT_DMA_SEMAPHORE                                     0x000001a4
#define NV097_SET_CONTEXT_DMA_SEMAPHORE_V                                         31:0

#define NV097_SET_CONTEXT_DMA_REPORT                                        0x000001a8
#define NV097_SET_CONTEXT_DMA_REPORT_V                                            31:0

#define NV097_SET_SURFACE_CLIP_HORIZONTAL                                   0x00000200
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_X                                       15:0
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                  31:16

#define NV097_SET_SURFACE_CLIP_VERTICAL                                     0x00000204
#define NV097_SET_SURFACE_CLIP_VERTICAL_Y                                         15:0
#define NV097_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                   31:16

#define NV097_SET_SURFACE_PITCH                                             0x0000020c
#define NV097_SET_SURFACE_PITCH_COLOR                                             15:0
#define NV097_SET_SURFACE_PITCH_ZETA                                             31:16

#define NV097_SET_SURFACE_COLOR_OFFSET                                      0x00000210
#define NV097_SET_SURFACE_COLOR_OFFSET_V                                          31:0

#define NV097_SET_SURFACE_ZETA_OFFSET                                       0x00000214
#define NV097_SET_SURFACE_ZETA_OFFSET_V                                           31:0

#define NV097_SET_COMBINER_ALPHA_ICW(i)                             (0x00000260+(i)*4)
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_COLOR_ICW(i)                             (0x00000ac0+(i)*4)
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_FACTOR0(i)                               (0x00000a60+(i)*4)
#define NV097_SET_COMBINER_FACTOR0_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR0_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR0_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR0_ALPHA                                         31:24

#define NV097_SET_COMBINER_FACTOR1(i)                               (0x00000a80+(i)*4)
#define NV097_SET_COMBINER_FACTOR1_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR1_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR1_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR1_ALPHA                                         31:24

#define NV097_SET_COMBINER_ALPHA_OCW(i)                             (0x00000aa0+(i)*4)
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION                                   31:15
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                      0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                 0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                 0x00000002
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS            0x00000003
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                 0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1                0x00000006
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0                                 0x00000288
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                              7:5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                                4:4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                               3:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD            0x0000000F

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1                                 0x0000028c
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                         7:7
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE            0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE             0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                 6:6
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE    0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE     0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12                5:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE    0x00000020

#define NV097_SET_CONTROL0                                                  0x00000290
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT                                   31:28
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS                         0x00000000
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_CRYCB_TO_RGB                 0x00000001
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_SCRYSCB_TO_RGB               0x00000002
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA                                    27:24
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                         0x00000000
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                          0x00000001
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE                                    23:20
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                         0x00000000
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                          0x00000001
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                  19:16
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                        0x00000001
#define NV097_SET_CONTROL0_Z_FORMAT                                              15:12
#define NV097_SET_CONTROL0_Z_FORMAT_FIXED                                   0x00000000
#define NV097_SET_CONTROL0_Z_FORMAT_FLOAT                                   0x00000001
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE                                    7:0
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                        0x00000001

#define NV097_SET_LIGHT_CONTROL                                             0x00000294
#define NV097_SET_LIGHT_CONTROL_LOCALEYE                                         16:16
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE                              0x00000000
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_TRUE                               0x00000001
#define NV097_SET_LIGHT_CONTROL_SOUT                                             31:17
#define NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT                               0x00000000
#define NV097_SET_LIGHT_CONTROL_SOUT_PASSTHROUGH                            0x00000001
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                               1:0
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                  0x00000000
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                   0x00000001

#define NV097_SET_COLOR_MATERIAL                                            0x00000298
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL                                 1:0
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL                                  3:2
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE                   0x00000000
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DIFFUSE_VTX_COLOR         0x00000001
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_SPECULAR_VTX_COLOR        0x00000002
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL                                     5:4
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE                      0x00000000
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DIFFUSE_VTX_COLOR            0x00000001
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_SPECULAR_VTX_COLOR           0x00000002
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL                                 7:6
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL                            9:8
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_SPEC_VTX_COLOR      0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL                           11:10
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE              0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DIFF_VTX_COLOR       0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_SPEC_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL                              13:12
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE                 0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DIFF_VTX_COLOR          0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_SPEC_VTX_COLOR          0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL                          15:14
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_SPEC_VTX_COLOR      0x00000002

#define NV097_SET_FOG_MODE                                                  0x0000029c
#define NV097_SET_FOG_MODE_V                                                      31:0
#define NV097_SET_FOG_MODE_V_LINEAR                                         0x00002601
#define NV097_SET_FOG_MODE_V_EXP                                            0x00000800
#define NV097_SET_FOG_MODE_V_EXP2                                           0x00000801
#define NV097_SET_FOG_MODE_V_EXP_ABS                                        0x00000802
#define NV097_SET_FOG_MODE_V_EXP2_ABS                                       0x00000803
#define NV097_SET_FOG_MODE_V_LINEAR_ABS                                     0x00000804

#define NV097_SET_FOG_GEN_MODE                                              0x000002a0
#define NV097_SET_FOG_GEN_MODE_V                                                  31:0
#define NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA                                 0x00000000
#define NV097_SET_FOG_GEN_MODE_V_RADIAL                                     0x00000001
#define NV097_SET_FOG_GEN_MODE_V_PLANAR                                     0x00000002
#define NV097_SET_FOG_GEN_MODE_V_ABS_PLANAR                                 0x00000003
#define NV097_SET_FOG_GEN_MODE_V_FOG_X                                      0x00000006

#define NV097_SET_FOG_ENABLE                                                0x000002a4
#define NV097_SET_FOG_ENABLE_V                                                    31:0
#define NV097_SET_FOG_ENABLE_V_FALSE                                        0x00000000
#define NV097_SET_FOG_ENABLE_V_TRUE                                         0x00000001

#define NV097_SET_FOG_COLOR                                                 0x000002a8
#define NV097_SET_FOG_COLOR_RED                                                    7:0
#define NV097_SET_FOG_COLOR_GREEN                                                 15:8
#define NV097_SET_FOG_COLOR_BLUE                                                 23:16
#define NV097_SET_FOG_COLOR_ALPHA                                                31:24

#define NV097_SET_COLOR_KEY_COLOR(i)                                (0x00000ae0+(i)*4)
#define NV097_SET_COLOR_KEY_COLOR_V                                               31:0

#define NV097_SET_WINDOW_CLIP_TYPE                                          0x000002b4
#define NV097_SET_WINDOW_CLIP_TYPE_V                                              31:0
#define NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                              0x00000000
#define NV097_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                              0x00000001

#define NV097_SET_WINDOW_CLIP_HORIZONTAL(i)                         (0x000002c0+(i)*4)
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                     11:0
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                    27:16

#define NV097_SET_WINDOW_CLIP_VERTICAL(i)                           (0x000002e0+(i)*4)
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMIN                                       11:0
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMAX                                      27:16

#define NV097_SET_ALPHA_TEST_ENABLE                                         0x00000300
#define NV097_SET_ALPHA_TEST_ENABLE_V                                             31:0
#define NV097_SET_ALPHA_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_ALPHA_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_BLEND_ENABLE                                              0x00000304
#define NV097_SET_BLEND_ENABLE_V                                                  31:0
#define NV097_SET_BLEND_ENABLE_V_FALSE                                      0x00000000
#define NV097_SET_BLEND_ENABLE_V_TRUE                                       0x00000001

#define NV097_SET_CULL_FACE_ENABLE                                          0x00000308
#define NV097_SET_CULL_FACE_ENABLE_V                                              31:0
#define NV097_SET_CULL_FACE_ENABLE_V_FALSE                                  0x00000000
#define NV097_SET_CULL_FACE_ENABLE_V_TRUE                                   0x00000001

#define NV097_SET_DEPTH_TEST_ENABLE                                         0x0000030c
#define NV097_SET_DEPTH_TEST_ENABLE_V                                             31:0
#define NV097_SET_DEPTH_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_DEPTH_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_DITHER_ENABLE                                             0x00000310
#define NV097_SET_DITHER_ENABLE_V                                                 31:0
#define NV097_SET_DITHER_ENABLE_V_FALSE                                     0x00000000
#define NV097_SET_DITHER_ENABLE_V_TRUE                                      0x00000001

#define NV097_SET_LIGHTING_ENABLE                                           0x00000314
#define NV097_SET_LIGHTING_ENABLE_V                                               31:0
#define NV097_SET_LIGHTING_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LIGHTING_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_POINT_PARAMS_ENABLE                                       0x00000318
#define NV097_SET_POINT_PARAMS_ENABLE_V                                           31:0
#define NV097_SET_POINT_PARAMS_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_PARAMS_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POINT_SMOOTH_ENABLE                                       0x0000031c
#define NV097_SET_POINT_SMOOTH_ENABLE_V                                           31:0
#define NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_SMOOTH_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_LINE_SMOOTH_ENABLE                                        0x00000320
#define NV097_SET_LINE_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_LINE_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_POLY_SMOOTH_ENABLE                                        0x00000324
#define NV097_SET_POLY_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_POLY_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_STIPPLE_CONTROL                                           0x0000147c
#define NV097_SET_STIPPLE_CONTROL_V                                               31:0
#define NV097_SET_STIPPLE_CONTROL_V_OFF                                     0x00000000
#define NV097_SET_STIPPLE_CONTROL_V_POLYGON                                 0x00000001

#define NV097_SET_STIPPLE_PATTERN(i)                                (0x00001480+(i)*4)
#define NV097_SET_STIPPLE_PATTERN_V                                               31:0

#define NV097_SET_SKIN_MODE                                                 0x00000328
#define NV097_SET_SKIN_MODE_V                                                     31:0
#define NV097_SET_SKIN_MODE_V_OFF                                           0x00000000
#define NV097_SET_SKIN_MODE_V_2G                                            0x00000001
#define NV097_SET_SKIN_MODE_V_2                                             0x00000002
#define NV097_SET_SKIN_MODE_V_3G                                            0x00000003
#define NV097_SET_SKIN_MODE_V_3                                             0x00000004
#define NV097_SET_SKIN_MODE_V_4G                                            0x00000005
#define NV097_SET_SKIN_MODE_V_4                                             0x00000006

#define NV097_SET_STENCIL_TEST_ENABLE                                       0x0000032c
#define NV097_SET_STENCIL_TEST_ENABLE_V                                           31:0
#define NV097_SET_STENCIL_TEST_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_STENCIL_TEST_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POLY_OFFSET_POINT_ENABLE                                  0x00000330
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V                                      31:0
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                           0x00000001

#define NV097_SET_POLY_OFFSET_LINE_ENABLE                                   0x00000334
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_POLY_OFFSET_FILL_ENABLE                                   0x00000338
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_ALPHA_FUNC                                                0x0000033c
#define NV097_SET_ALPHA_FUNC_V                                                    31:0
#define NV097_SET_ALPHA_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_ALPHA_FUNC_V_LESS                                         0x00000201
#define NV097_SET_ALPHA_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_ALPHA_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_ALPHA_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_ALPHA_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_ALPHA_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_ALPHA_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_ALPHA_REF                                                 0x00000340
#define NV097_SET_ALPHA_REF_V                                                     31:0

#define NV097_SET_BLEND_FUNC_SFACTOR                                        0x00000344
#define NV097_SET_BLEND_FUNC_SFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_FUNC_DFACTOR                                        0x00000348
#define NV097_SET_BLEND_FUNC_DFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_COLOR                                               0x0000034c
#define NV097_SET_BLEND_COLOR_V                                                   31:0

#define NV097_SET_BLEND_EQUATION                                            0x00000350
#define NV097_SET_BLEND_EQUATION_V                                                31:0
#define NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                            0x0000800A
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                    0x0000800B
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD                                 0x00008006
#define NV097_SET_BLEND_EQUATION_V_MIN                                      0x00008007
#define NV097_SET_BLEND_EQUATION_V_MAX                                      0x00008008
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_SIGNED             0x0000F005
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED                          0x0000F006

#define NV097_SET_DEPTH_FUNC                                                0x00000354
#define NV097_SET_DEPTH_FUNC_V                                                    31:0
#define NV097_SET_DEPTH_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_DEPTH_FUNC_V_LESS                                         0x00000201
#define NV097_SET_DEPTH_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_DEPTH_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_DEPTH_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_DEPTH_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_DEPTH_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_DEPTH_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_COLOR_MASK                                                0x00000358
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                  31:24
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE                                    23:16
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                         0x00000000
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                          0x00000001
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                   15:8
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                     7:0
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                        0x00000000
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                         0x00000001

#define NV097_SET_DEPTH_MASK                                                0x0000035c
#define NV097_SET_DEPTH_MASK_V                                                    31:0
#define NV097_SET_DEPTH_MASK_V_FALSE                                        0x00000000
#define NV097_SET_DEPTH_MASK_V_TRUE                                         0x00000001

#define NV097_SET_STENCIL_MASK                                              0x00000360
#define NV097_SET_STENCIL_MASK_V                                                  31:0

#define NV097_SET_STENCIL_FUNC                                              0x00000364
#define NV097_SET_STENCIL_FUNC_V                                                  31:0
#define NV097_SET_STENCIL_FUNC_V_NEVER                                      0x00000200
#define NV097_SET_STENCIL_FUNC_V_LESS                                       0x00000201
#define NV097_SET_STENCIL_FUNC_V_EQUAL                                      0x00000202
#define NV097_SET_STENCIL_FUNC_V_LEQUAL                                     0x00000203
#define NV097_SET_STENCIL_FUNC_V_GREATER                                    0x00000204
#define NV097_SET_STENCIL_FUNC_V_NOTEQUAL                                   0x00000205
#define NV097_SET_STENCIL_FUNC_V_GEQUAL                                     0x00000206
#define NV097_SET_STENCIL_FUNC_V_ALWAYS                                     0x00000207

#define NV097_SET_STENCIL_FUNC_REF                                          0x00000368
#define NV097_SET_STENCIL_FUNC_REF_V                                              31:0

#define NV097_SET_STENCIL_FUNC_MASK                                         0x0000036c
#define NV097_SET_STENCIL_FUNC_MASK_V                                             31:0

#define NV097_SET_STENCIL_OP_FAIL                                           0x00000370
#define NV097_SET_STENCIL_OP_FAIL_V                                               31:0
#define NV097_SET_STENCIL_OP_FAIL_V_KEEP                                    0x00001E00
#define NV097_SET_STENCIL_OP_FAIL_V_ZERO                                    0x00000000
#define NV097_SET_STENCIL_OP_FAIL_V_REPLACE                                 0x00001E01
#define NV097_SET_STENCIL_OP_FAIL_V_INCRSAT                                 0x00001E02
#define NV097_SET_STENCIL_OP_FAIL_V_DECRSAT                                 0x00001E03
#define NV097_SET_STENCIL_OP_FAIL_V_INVERT                                  0x0000150A
#define NV097_SET_STENCIL_OP_FAIL_V_INCR                                    0x00008507
#define NV097_SET_STENCIL_OP_FAIL_V_DECR                                    0x00008508

#define NV097_SET_STENCIL_OP_ZFAIL                                          0x00000374
#define NV097_SET_STENCIL_OP_ZFAIL_V                                              31:0
#define NV097_SET_STENCIL_OP_ZFAIL_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZFAIL_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZFAIL_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZFAIL_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECR                                   0x00008508

#define NV097_SET_STENCIL_OP_ZPASS                                          0x00000378
#define NV097_SET_STENCIL_OP_ZPASS_V                                              31:0
#define NV097_SET_STENCIL_OP_ZPASS_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZPASS_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZPASS_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZPASS_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZPASS_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZPASS_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZPASS_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZPASS_V_DECR                                   0x00008508

#define NV097_SET_SHADE_MODE                                                0x0000037c
#define NV097_SET_SHADE_MODE_V                                                    31:0
#define NV097_SET_SHADE_MODE_V_FLAT                                         0x00001D00
#define NV097_SET_SHADE_MODE_V_SMOOTH                                       0x00001D01

#define NV097_SET_LINE_WIDTH                                                0x00000380
#define NV097_SET_LINE_WIDTH_V                                                    31:0

#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR                               0x00000384
#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                   31:0

#define NV097_SET_POLYGON_OFFSET_BIAS                                       0x00000388
#define NV097_SET_POLYGON_OFFSET_BIAS_V                                           31:0

#define NV097_SET_FRONT_POLYGON_MODE                                        0x0000038c
#define NV097_SET_FRONT_POLYGON_MODE_V                                            31:0
#define NV097_SET_FRONT_POLYGON_MODE_V_POINT                                0x00001B00
#define NV097_SET_FRONT_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV097_SET_FRONT_POLYGON_MODE_V_FILL                                 0x00001B02

#define NV097_SET_BACK_POLYGON_MODE                                         0x00000390
#define NV097_SET_BACK_POLYGON_MODE_V                                             31:0
#define NV097_SET_BACK_POLYGON_MODE_V_POINT                                 0x00001B00
#define NV097_SET_BACK_POLYGON_MODE_V_LINE                                  0x00001B01
#define NV097_SET_BACK_POLYGON_MODE_V_FILL                                  0x00001B02

#define NV097_SET_CLIP_MIN                                                  0x00000394
#define NV097_SET_CLIP_MIN_V                                                      31:0

#define NV097_SET_CLIP_MAX                                                  0x00000398
#define NV097_SET_CLIP_MAX_V                                                      31:0

#define NV097_SET_CULL_FACE                                                 0x0000039c
#define NV097_SET_CULL_FACE_V                                                     31:0
#define NV097_SET_CULL_FACE_V_FRONT                                         0x00000404
#define NV097_SET_CULL_FACE_V_BACK                                          0x00000405
#define NV097_SET_CULL_FACE_V_FRONT_AND_BACK                                0x00000408

#define NV097_SET_FRONT_FACE                                                0x000003a0
#define NV097_SET_FRONT_FACE_V                                                    31:0
#define NV097_SET_FRONT_FACE_V_CW                                           0x00000900
#define NV097_SET_FRONT_FACE_V_CCW                                          0x00000901

#define NV097_SET_NORMALIZATION_ENABLE                                      0x000003a4
#define NV097_SET_NORMALIZATION_ENABLE_V                                          31:0
#define NV097_SET_NORMALIZATION_ENABLE_V_FALSE                              0x00000000
#define NV097_SET_NORMALIZATION_ENABLE_V_TRUE                               0x00000001

#define NV097_SET_MATERIAL_EMISSION(i)                              (0x000003a8+(i)*4)
#define NV097_SET_MATERIAL_EMISSION_V                                             31:0

#define NV097_SET_MATERIAL_ALPHA                                            0x000003b4
#define NV097_SET_MATERIAL_ALPHA_V                                                31:0

#define NV097_SET_BACK_MATERIAL_ALPHA                                       0x000017ac
#define NV097_SET_BACK_MATERIAL_ALPHA_V                                           31:0

#define NV097_SET_SPECULAR_ENABLE                                           0x000003b8
#define NV097_SET_SPECULAR_ENABLE_V                                               31:0
#define NV097_SET_SPECULAR_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_SPECULAR_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LIGHT_ENABLE_MASK                                         0x000003bc
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0                                         1:0
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1                                         3:2
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2                                         5:4
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3                                         7:6
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4                                         9:8
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5                                       11:10
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6                                       13:12
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7                                       15:14
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                             0x00000003

#define NV097_SET_VERTEX_DATA2F_M(i,j)                        (0x00001880+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA2F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA4F_M(i,j)                       (0x00001a00+(i)*16+(j)*4)
#define NV097_SET_VERTEX_DATA4F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA2S(i)                                  (0x00001900+(i)*4)
#define NV097_SET_VERTEX_DATA2S_V                                                 31:0

#define NV097_SET_VERTEX_DATA4UB(i)                                 (0x00001940+(i)*4)
#define NV097_SET_VERTEX_DATA4UB_V                                                31:0

#define NV097_SET_VERTEX_DATA4S_M(i,j)                        (0x00001980+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA4S_M_V                                               31:0

#define NV097_SET_TEXGEN_S(i)                                      (0x000003c0+(i)*16)
#define NV097_SET_TEXGEN_S_V                                                      31:0
#define NV097_SET_TEXGEN_S_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_S_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_S_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_S_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_S_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_S_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_T(i)                                      (0x000003c4+(i)*16)
#define NV097_SET_TEXGEN_T_V                                                      31:0
#define NV097_SET_TEXGEN_T_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_T_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_T_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_T_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_T_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_T_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_R(i)                                      (0x000003c8+(i)*16)
#define NV097_SET_TEXGEN_R_V                                                      31:0
#define NV097_SET_TEXGEN_R_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_R_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_R_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_R_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_R_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_Q(i)                                      (0x000003cc+(i)*16)
#define NV097_SET_TEXGEN_Q_V                                                      31:0
#define NV097_SET_TEXGEN_Q_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_Q_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_Q_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_VIEW_MODEL                                         0x000009cc
#define NV097_SET_TEXGEN_VIEW_MODEL_V                                             31:0
#define NV097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER                          0x00000000
#define NV097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER                       0x00000001

#define NV097_SET_TEXTURE_MATRIX_ENABLE(i)                          (0x00000420+(i)*4)
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V                                         31:0
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE                             0x00000000
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE                              0x00000001

#define NV097_SET_POINT_SIZE                                                0x0000043c
#define NV097_SET_POINT_SIZE_V                                                    31:0

#define NV097_SET_SWATH_WIDTH                                               0x000009f8
#define NV097_SET_SWATH_WIDTH_V                                                   31:0
#define NV097_SET_SWATH_WIDTH_V_8                                           0x00000000
#define NV097_SET_SWATH_WIDTH_V_16                                          0x00000001
#define NV097_SET_SWATH_WIDTH_V_32                                          0x00000002
#define NV097_SET_SWATH_WIDTH_V_64                                          0x00000003
#define NV097_SET_SWATH_WIDTH_V_128                                         0x00000004
#define NV097_SET_SWATH_WIDTH_V_OFF                                         0x0000000F

#define NV097_SET_FLAT_SHADE_OP                                             0x000009fc
#define NV097_SET_FLAT_SHADE_OP_V                                                 31:0
#define NV097_SET_FLAT_SHADE_OP_V_LAST_VTX                                  0x00000000
#define NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX                                 0x00000001

#define NV097_SET_PROJECTION_MATRIX(i)                              (0x00000440+(i)*4)
#define NV097_SET_PROJECTION_MATRIX_V                                             31:0

#define NV097_SET_MODEL_VIEW_MATRIX0(i)                             (0x00000480+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX0_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX1(i)                             (0x000004c0+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX1_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX2(i)                             (0x00000500+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX2_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX3(i)                             (0x00000540+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX3_V                                            31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                     (0x00000580+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                     (0x000005c0+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2(i)                     (0x00000600+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3(i)                     (0x00000640+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3_V                                    31:0

#define NV097_SET_COMPOSITE_MATRIX(i)                               (0x00000680+(i)*4)
#define NV097_SET_COMPOSITE_MATRIX_V                                              31:0

#define NV097_SET_TEXTURE_MATRIX0(i)                                (0x000006c0+(i)*4)
#define NV097_SET_TEXTURE_MATRIX0_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX1(i)                                (0x00000700+(i)*4)
#define NV097_SET_TEXTURE_MATRIX1_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX2(i)                                (0x00000740+(i)*4)
#define NV097_SET_TEXTURE_MATRIX2_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX3(i)                                (0x00000780+(i)*4)
#define NV097_SET_TEXTURE_MATRIX3_V                                               31:0

#define NV097_SET_TEXGEN_PLANE_S(i,j)                        (0x00000840+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_S_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_T(i,j)                        (0x00000850+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_T_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_R(i,j)                        (0x00000860+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_R_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_Q(i,j)                        (0x00000870+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_Q_V                                                31:0

#define NV097_SET_FOG_PARAMS(i)                                     (0x000009c0+(i)*4)
#define NV097_SET_FOG_PARAMS_V                                                    31:0

#define NV097_SET_FOG_PLANE(i)                                      (0x000009d0+(i)*4)
#define NV097_SET_FOG_PLANE_V                                                     31:0

#define NV097_SET_SPECULAR_PARAMS(i)                                (0x000009e0+(i)*4)
#define NV097_SET_SPECULAR_PARAMS_V                                               31:0

#define NV097_SET_BACK_SPECULAR_PARAMS(i)                           (0x00001e28+(i)*4)
#define NV097_SET_BACK_SPECULAR_PARAMS_V                                          31:0

#define NV097_SET_SCENE_AMBIENT_COLOR(i)                            (0x00000a10+(i)*4)
#define NV097_SET_SCENE_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_VIEWPORT_SCALE(i)                                 (0x00000af0+(i)*4)
#define NV097_SET_VIEWPORT_SCALE_V                                                31:0

#define NV097_SET_VIEWPORT_OFFSET(i)                                (0x00000a20+(i)*4)
#define NV097_SET_VIEWPORT_OFFSET_V                                               31:0

#define NV097_SET_POINT_PARAMS(i)                                   (0x00000a30+(i)*4)
#define NV097_SET_POINT_PARAMS_V                                                  31:0

#define NV097_SET_EYE_POSITION(i)                                   (0x00000a50+(i)*4)
#define NV097_SET_EYE_POSITION_V                                                  31:0

#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR(i,j)              (0x00000c00+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR(i,j)              (0x00000c0c+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR(i,j)             (0x00000c18+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR_V                                     31:0

#define NV097_SET_LIGHT_AMBIENT_COLOR(i,j)                  (0x00001000+(i)*128+(j)*4)
#define NV097_SET_LIGHT_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_LIGHT_DIFFUSE_COLOR(i,j)                  (0x0000100c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_DIFFUSE_COLOR_V                                           31:0

#define NV097_SET_LIGHT_SPECULAR_COLOR(i,j)                 (0x00001018+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPECULAR_COLOR_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_RANGE(i)                            (0x00001024+(i)*128)
#define NV097_SET_LIGHT_LOCAL_RANGE_V                                             31:0

#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)           (0x00001028+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR_V                                    31:0

#define NV097_SET_LIGHT_INFINITE_DIRECTION(i,j)             (0x00001034+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_DIRECTION_V                                      31:0

#define NV097_SET_LIGHT_SPOT_FALLOFF(i,j)                   (0x00001040+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_FALLOFF_V                                            31:0

#define NV097_SET_LIGHT_SPOT_DIRECTION(i,j)                 (0x0000104c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_DIRECTION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_POSITION(i,j)                 (0x0000105c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_POSITION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_ATTENUATION(i,j)              (0x00001068+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_ATTENUATION_V                                       31:0

#define NV097_SET_VERTEX3F(i)                                       (0x00001500+(i)*4)
#define NV097_SET_VERTEX3F_V                                                      31:0

#define NV097_SET_VERTEX4F(i)                                       (0x00001518+(i)*4)
#define NV097_SET_VERTEX4F_V                                                      31:0

#define NV097_SET_VERTEX4S(i)                                       (0x00001528+(i)*4)
#define NV097_SET_VERTEX4S_V                                                      31:0

#define NV097_SET_NORMAL3F(i)                                       (0x00001530+(i)*4)
#define NV097_SET_NORMAL3F_V                                                      31:0

#define NV097_SET_NORMAL3S(i)                                       (0x00001540+(i)*4)
#define NV097_SET_NORMAL3S_V                                                      31:0

#define NV097_SET_DIFFUSE_COLOR4F(i)                                (0x00001550+(i)*4)
#define NV097_SET_DIFFUSE_COLOR4F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR3F(i)                                (0x00001560+(i)*4)
#define NV097_SET_DIFFUSE_COLOR3F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR4UB                                          0x0000156c
#define NV097_SET_DIFFUSE_COLOR4UB_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4F(i)                               (0x00001570+(i)*4)
#define NV097_SET_SPECULAR_COLOR4F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR3F(i)                               (0x00001580+(i)*4)
#define NV097_SET_SPECULAR_COLOR3F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4UB                                         0x0000158c
#define NV097_SET_SPECULAR_COLOR4UB_V                                             31:0

#define NV097_SET_TEXCOORD0_2F(i)                                   (0x00001590+(i)*4)
#define NV097_SET_TEXCOORD0_2F_V                                                  31:0

#define NV097_SET_TEXCOORD0_2S                                              0x00001598
#define NV097_SET_TEXCOORD0_2S_V                                                  31:0

#define NV097_SET_TEXCOORD0_4F(i)                                   (0x000015a0+(i)*4)
#define NV097_SET_TEXCOORD0_4F_V                                                  31:0

#define NV097_SET_TEXCOORD0_4S(i)                                   (0x000015b0+(i)*4)
#define NV097_SET_TEXCOORD0_4S_V                                                  31:0

#define NV097_SET_TEXCOORD1_2F(i)                                   (0x000015b8+(i)*4)
#define NV097_SET_TEXCOORD1_2F_V                                                  31:0

#define NV097_SET_TEXCOORD1_2S                                              0x000015c0
#define NV097_SET_TEXCOORD1_2S_V                                                  31:0

#define NV097_SET_TEXCOORD1_4F(i)                                   (0x000015c8+(i)*4)
#define NV097_SET_TEXCOORD1_4F_V                                                  31:0

#define NV097_SET_TEXCOORD1_4S(i)                                   (0x000015d8+(i)*4)
#define NV097_SET_TEXCOORD1_4S_V                                                  31:0

#define NV097_SET_TEXCOORD2_2F(i)                                   (0x000015e0+(i)*4)
#define NV097_SET_TEXCOORD2_2F_V                                                  31:0

#define NV097_SET_TEXCOORD2_2S                                              0x000015e8
#define NV097_SET_TEXCOORD2_2S_V                                                  31:0

#define NV097_SET_TEXCOORD2_4F(i)                                   (0x000015f0+(i)*4)
#define NV097_SET_TEXCOORD2_4F_V                                                  31:0

#define NV097_SET_TEXCOORD2_4S(i)                                   (0x00001600+(i)*4)
#define NV097_SET_TEXCOORD2_4S_V                                                  31:0

#define NV097_SET_TEXCOORD3_2F(i)                                   (0x00001608+(i)*4)
#define NV097_SET_TEXCOORD3_2F_V                                                  31:0

#define NV097_SET_TEXCOORD3_2S                                              0x00001610
#define NV097_SET_TEXCOORD3_2S_V                                                  31:0

#define NV097_SET_TEXCOORD3_4F(i)                                   (0x00001620+(i)*4)
#define NV097_SET_TEXCOORD3_4F_V                                                  31:0

#define NV097_SET_TEXCOORD3_4S(i)                                   (0x00001630+(i)*4)
#define NV097_SET_TEXCOORD3_4S_V                                                  31:0

#define NV097_SET_FOG1F                                                     0x00001698
#define NV097_SET_FOG1F_V                                                         31:0

#define NV097_SET_WEIGHT1F                                                  0x0000169c
#define NV097_SET_WEIGHT1F_V                                                      31:0

#define NV097_SET_WEIGHT2F(i)                                       (0x000016a0+(i)*4)
#define NV097_SET_WEIGHT2F_V                                                      31:0

#define NV097_SET_WEIGHT3F(i)                                       (0x000016b0+(i)*4)
#define NV097_SET_WEIGHT3F_V                                                      31:0

#define NV097_SET_WEIGHT4F(i)                                       (0x000016c0+(i)*4)
#define NV097_SET_WEIGHT4F_V                                                      31:0

#define NV097_SET_EDGE_FLAG                                                 0x000016bc
#define NV097_SET_EDGE_FLAG_V                                                     31:0
#define NV097_SET_EDGE_FLAG_V_FALSE                                         0x00000000
#define NV097_SET_EDGE_FLAG_V_TRUE                                          0x00000001

#define NV097_SET_TRANSFORM_FIXED_CONST0(i)                         (0x000016e0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST0_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST1(i)                         (0x000016f0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST1_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST2(i)                         (0x00001700+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST2_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST3(i)                         (0x000016d0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST3_V                                        31:0

#define NV097_SET_TLCONST_ZERO(i)                                   (0x000017d4+(i)*4)
#define NV097_SET_TLCONST_ZERO_V                                                  31:0

#define NV097_SET_EYE_DIRECTION(i)                                  (0x000017e0+(i)*4)
#define NV097_SET_EYE_DIRECTION_V                                                 31:0

#define NV097_SET_LINEAR_FOG_CONST(i)                               (0x000017ec+(i)*4)
#define NV097_SET_LINEAR_FOG_CONST_V                                              31:0

#define NV097_INVALIDATE_VERTEX_CACHE_FILE                                  0x00001710

#define NV097_INVALIDATE_VERTEX_FILE                                        0x00001714

#define NV097_TL_NOP                                                        0x00001718

#define NV097_TL_SYNC                                                       0x0000171c

#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET(i)                       (0x00001720+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA                           31:31
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A             0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B             0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_OFFSET                                 30:0

#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT(i)                       (0x00001760+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_STRIDE                                 31:8
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE                                    7:4
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED                    0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3W                          0x00000007
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE                                    3:0
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D                      0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S1                          0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_OGL                      0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K                        0x00000005
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_CMP                         0x00000006

#define NV097_SET_LOGIC_OP_ENABLE                                           0x000017bc
#define NV097_SET_LOGIC_OP_ENABLE_V                                               31:0
#define NV097_SET_LOGIC_OP_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LOGIC_OP_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LOGIC_OP                                                  0x000017c0
#define NV097_SET_LOGIC_OP_V                                                      31:0
#define NV097_SET_LOGIC_OP_V_CLEAR                                          0x00001500
#define NV097_SET_LOGIC_OP_V_AND                                            0x00001501
#define NV097_SET_LOGIC_OP_V_AND_REVERSE                                    0x00001502
#define NV097_SET_LOGIC_OP_V_COPY                                           0x00001503
#define NV097_SET_LOGIC_OP_V_AND_INVERTED                                   0x00001504
#define NV097_SET_LOGIC_OP_V_NOOP                                           0x00001505
#define NV097_SET_LOGIC_OP_V_XOR                                            0x00001506
#define NV097_SET_LOGIC_OP_V_OR                                             0x00001507
#define NV097_SET_LOGIC_OP_V_NOR                                            0x00001508
#define NV097_SET_LOGIC_OP_V_EQUIV                                          0x00001509
#define NV097_SET_LOGIC_OP_V_INVERT                                         0x0000150A
#define NV097_SET_LOGIC_OP_V_OR_REVERSE                                     0x0000150B
#define NV097_SET_LOGIC_OP_V_COPY_INVERTED                                  0x0000150C
#define NV097_SET_LOGIC_OP_V_OR_INVERTED                                    0x0000150D
#define NV097_SET_LOGIC_OP_V_NAND                                           0x0000150E
#define NV097_SET_LOGIC_OP_V_SET                                            0x0000150F

#define NV097_SET_BEGIN_END                                                 0x000017fc
#define NV097_SET_BEGIN_END_OP                                                    31:0
#define NV097_SET_BEGIN_END_OP_END                                          0x00000000
#define NV097_SET_BEGIN_END_OP_POINTS                                       0x00000001
#define NV097_SET_BEGIN_END_OP_LINES                                        0x00000002
#define NV097_SET_BEGIN_END_OP_LINE_LOOP                                    0x00000003
#define NV097_SET_BEGIN_END_OP_LINE_STRIP                                   0x00000004
#define NV097_SET_BEGIN_END_OP_TRIANGLES                                    0x00000005
#define NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP                               0x00000006
#define NV097_SET_BEGIN_END_OP_TRIANGLE_FAN                                 0x00000007
#define NV097_SET_BEGIN_END_OP_QUADS                                        0x00000008
#define NV097_SET_BEGIN_END_OP_QUAD_STRIP                                   0x00000009
#define NV097_SET_BEGIN_END_OP_POLYGON                                      0x0000000A

#define NV097_ARRAY_ELEMENT16                                               0x00001800
#define NV097_ARRAY_ELEMENT16_VERTEX0                                             15:0
#define NV097_ARRAY_ELEMENT16_VERTEX1                                            31:16

#define NV097_ARRAY_ELEMENT32                                               0x00001808
#define NV097_ARRAY_ELEMENT32_V                                                   31:0

#define NV097_DRAW_ARRAYS                                                   0x00001810
#define NV097_DRAW_ARRAYS_COUNT                                                  31:24
#define NV097_DRAW_ARRAYS_START_INDEX                                             23:0

#define NV097_INLINE_VERTEX_REUSE                                           0x00001828
#define NV097_INLINE_VERTEX_REUSE_V                                               31:0

#define NV097_INLINE_ARRAY                                                  0x00001818
#define NV097_INLINE_ARRAY_V                                                      31:0

#define NV097_SET_TEXTURE_OFFSET(i)                                (0x00001b00+(i)*64)
#define NV097_SET_TEXTURE_OFFSET_V                                                31:0

#define NV097_SET_TEXTURE_FORMAT(i)                                (0x00001b04+(i)*64)
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA                                       1:0
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                    2:2
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                       0x00000000
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE                                     3:3
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_TEXTURE                      0x00000000
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY                                    7:4
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_ONE                         0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO                         0x00000002
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE                       0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR                                            15:8
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8                                0x00000000
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8                               0x00000001
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5                          0x00000002
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5                          0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4                          0x00000004
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5                            0x00000005
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8                          0x00000006
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8                          0x00000007
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8                       0x0000000B
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5                      0x0000000C
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8                     0x0000000E
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8                     0x0000000F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5                    0x00000010
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5                      0x00000011
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8                    0x00000012
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8                          0x00000013
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8                         0x00000014
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9                       0x00000015
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8                        0x00000016
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8                        0x00000017
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8                      0x00000018
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8                                0x00000019
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8Y8                              0x0000001A
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8                         0x0000001B
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5                    0x0000001C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4                    0x0000001D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8                    0x0000001E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8                          0x0000001F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8                        0x00000020
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8                0x00000024
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8                0x00000025
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8                  0x00000026
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5                            0x00000027
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8                              0x00000028
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8B8                              0x00000029
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FIXED                0x0000002A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FLOAT                0x0000002B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FIXED                   0x0000002C
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FLOAT                   0x0000002D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED          0x0000002E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT          0x0000002F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED             0x00000030
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT             0x00000031
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y16                               0x00000032
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16                       0x00000033
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6              0x00000034
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16                         0x00000035
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16                    0x00000036
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5                      0x00000037
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G5B5A1                          0x00000038
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R4G4B4A4                          0x00000039
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8                          0x0000003A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_B8G8R8A8                          0x0000003B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8G8B8A8                          0x0000003C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1                    0x0000003D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4                    0x0000003E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8                    0x0000003F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8                    0x00000040
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8                    0x00000041
#define NV097_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                   19:16
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U                                     23:20
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V                                     27:24
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P                                     31:28
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_512                            0x00000009

#define NV097_SET_TEXTURE_ADDRESS(i)                               (0x00001b08+(i)*64)
#define NV097_SET_TEXTURE_ADDRESS_U                                                3:0
#define NV097_SET_TEXTURE_ADDRESS_U_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_U_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_U_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U                                        7:4
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V                                               11:8
#define NV097_SET_TEXTURE_ADDRESS_V_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_V_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V                                      15:12
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P                                              19:16
#define NV097_SET_TEXTURE_ADDRESS_P_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_P_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P                                      23:20
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q                                      31:24
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_TRUE                            0x00000001

#define NV097_SET_TEXTURE_CONTROL0(i)                              (0x00001b0c+(i)*64)
#define NV097_SET_TEXTURE_CONTROL0_ENABLE                                        31:30
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE                             0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE                              0x00000001
#define NV097_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                 29:18
#define NV097_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                  17:6
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                   5:4
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                          0x00000000
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                          0x00000001
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_2                          0x00000002
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_3                          0x00000003
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                              3:3
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                 0x00000000
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                  0x00000001
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                               2:2
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                  0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                   0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                             1:0
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE                0x00000000
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA                0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                 0x00000002
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                 0x00000003

#define NV097_SET_TEXTURE_CONTROL1(i)                              (0x00001b10+(i)*64)
#define NV097_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                   31:16

#define NV097_SET_TEXTURE_FILTER(i)                                (0x00001b14+(i)*64)
#define NV097_SET_TEXTURE_FILTER_MIPMAP_LOD_BIAS                                  12:0
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL                              15:13
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX                0x00000001
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN                                             23:16
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD                         0x00000003
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD                        0x00000004
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD                           0x00000005
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD                          0x00000006
#define NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0                    0x00000007
#define NV097_SET_TEXTURE_FILTER_MAG                                             27:24
#define NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0                    0x00000004
#define NV097_SET_TEXTURE_FILTER_ASIGNED                                         28:28
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_RSIGNED                                         29:29
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_GSIGNED                                         30:30
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_BSIGNED                                         31:31
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_ENABLED                        0x00000001

#define NV097_SET_TEXTURE_IMAGE_RECT(i)                            (0x00001b1c+(i)*64)
#define NV097_SET_TEXTURE_IMAGE_RECT_WIDTH                                       31:16
#define NV097_SET_TEXTURE_IMAGE_RECT_HEIGHT                                       15:0

#define NV097_SET_TEXTURE_PALETTE(i)                               (0x00001b20+(i)*64)
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA                                      1:0
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                             0x00000000
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                             0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH                                           5:2
#define NV097_SET_TEXTURE_PALETTE_LENGTH_256                                0x00000000
#define NV097_SET_TEXTURE_PALETTE_LENGTH_128                                0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH_64                                 0x00000002
#define NV097_SET_TEXTURE_PALETTE_LENGTH_32                                 0x00000003
#define NV097_SET_TEXTURE_PALETTE_OFFSET                                          31:6

#define NV097_SET_TEXTURE_BORDER_COLOR(i)                          (0x00001b24+(i)*64)
#define NV097_SET_TEXTURE_BORDER_COLOR_V                                          31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(i)                    (0x00001b28+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(i)                    (0x00001b2c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(i)                    (0x00001b30+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(i)                    (0x00001b34+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE(i)                    (0x00001b38+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET(i)                   (0x00001b3c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET_V                                   31:0

#define NV097_PARK_ATTRIBUTE                                                0x00001d64

#define NV097_UNPARK_ATTRIBUTE                                              0x00001d68

#define NV097_SET_SEMAPHORE_OFFSET                                          0x00001d6c
#define NV097_SET_SEMAPHORE_OFFSET_V                                              31:0

#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE                              0x00001d70
#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE_V                                  31:0

#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE                                0x00001d74
#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE_V                                    31:0

#define NV097_SET_ZMIN_MAX_CONTROL                                          0x00001d78
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN                                3:0
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE                   0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_TRUE                    0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN                                       7:4
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CULL                           0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP                          0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W                                  11:8
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_FALSE                      0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE                       0x00000001

#define NV097_SET_ANTI_ALIASING_CONTROL                                     0x00001d7c
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE                                     3:0
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE                        0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_TRUE                         0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE                          7:4
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_DISABLE           0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_ENABLE            0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE                              11:8
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_DISABLE                0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_ENABLE                 0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_SAMPLE_MASK                              31:16

#define NV097_SET_COMPRESS_ZBUFFER_EN                                       0x00001d80
#define NV097_SET_COMPRESS_ZBUFFER_EN_V                                           31:0
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE                             0x00000000
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE                              0x00000001

#define NV097_SET_OCCLUDE_ZSTENCIL_EN                                       0x00001d84
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN                                  0:0
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE                   0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_ENABLE                    0x00000001
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN                           1:1
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_DISABLE            0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_ENABLE             0x00000001

#define NV097_SET_SURFACE_FORMAT                                            0x00000208
#define NV097_SET_SURFACE_FORMAT_COLOR                                             3:0
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                 0x00000001
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                 0x00000002
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                            0x00000003
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                 0x00000004
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                 0x00000005
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8             0x00000006
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8             0x00000007
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                          0x00000008
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_B8                                0x00000009
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8                              0x0000000A
#define NV097_SET_SURFACE_FORMAT_ZETA                                              7:4
#define NV097_SET_SURFACE_FORMAT_ZETA_Z16                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_ZETA_Z24S8                                 0x00000002
#define NV097_SET_SURFACE_FORMAT_TYPE                                             11:8
#define NV097_SET_SURFACE_FORMAT_TYPE_PITCH                                 0x00000001
#define NV097_SET_SURFACE_FORMAT_TYPE_SWIZZLE                               0x00000002
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING                                   15:12
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1                     0x00000000
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_CORNER_2              0x00000001
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_SQUARE_OFFSET_4              0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH                                           23:16
#define NV097_SET_SURFACE_FORMAT_WIDTH_1                                    0x00000000
#define NV097_SET_SURFACE_FORMAT_WIDTH_2                                    0x00000001
#define NV097_SET_SURFACE_FORMAT_WIDTH_4                                    0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH_8                                    0x00000003
#define NV097_SET_SURFACE_FORMAT_WIDTH_16                                   0x00000004
#define NV097_SET_SURFACE_FORMAT_WIDTH_32                                   0x00000005
#define NV097_SET_SURFACE_FORMAT_WIDTH_64                                   0x00000006
#define NV097_SET_SURFACE_FORMAT_WIDTH_128                                  0x00000007
#define NV097_SET_SURFACE_FORMAT_WIDTH_256                                  0x00000008
#define NV097_SET_SURFACE_FORMAT_WIDTH_512                                  0x00000009
#define NV097_SET_SURFACE_FORMAT_WIDTH_1024                                 0x0000000A
#define NV097_SET_SURFACE_FORMAT_WIDTH_2048                                 0x0000000B
#define NV097_SET_SURFACE_FORMAT_WIDTH_4096                                 0x0000000C
#define NV097_SET_SURFACE_FORMAT_HEIGHT                                          31:24
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1                                   0x00000000
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4                                   0x00000002
#define NV097_SET_SURFACE_FORMAT_HEIGHT_8                                   0x00000003
#define NV097_SET_SURFACE_FORMAT_HEIGHT_16                                  0x00000004
#define NV097_SET_SURFACE_FORMAT_HEIGHT_32                                  0x00000005
#define NV097_SET_SURFACE_FORMAT_HEIGHT_64                                  0x00000006
#define NV097_SET_SURFACE_FORMAT_HEIGHT_128                                 0x00000007
#define NV097_SET_SURFACE_FORMAT_HEIGHT_256                                 0x00000008
#define NV097_SET_SURFACE_FORMAT_HEIGHT_512                                 0x00000009
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1024                                0x0000000A
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2048                                0x0000000B
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4096                                0x0000000C

#define NV097_SET_ZSTENCIL_CLEAR_VALUE                                      0x00001d8c
#define NV097_SET_ZSTENCIL_CLEAR_VALUE_V                                          31:0

#define NV097_SET_COLOR_CLEAR_VALUE                                         0x00001d90
#define NV097_SET_COLOR_CLEAR_VALUE_V                                             31:0

#define NV097_CLEAR_SURFACE                                                 0x00001d94
#define NV097_CLEAR_SURFACE_Z                                                      0:0
#define NV097_CLEAR_SURFACE_Z_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_Z_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_STENCIL                                                1:1
#define NV097_CLEAR_SURFACE_STENCIL_DISABLE                                 0x00000000
#define NV097_CLEAR_SURFACE_STENCIL_ENABLE                                  0x00000001
#define NV097_CLEAR_SURFACE_R                                                      4:4
#define NV097_CLEAR_SURFACE_R_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_R_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_G                                                      5:5
#define NV097_CLEAR_SURFACE_G_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_G_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_B                                                      6:6
#define NV097_CLEAR_SURFACE_B_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_B_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_A                                                      7:7
#define NV097_CLEAR_SURFACE_A_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_A_ENABLE                                        0x00000001

#define NV097_SET_CLEAR_RECT_HORIZONTAL                                     0x00001d98
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMIN                                      15:0
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMAX                                     31:16

#define NV097_SET_CLEAR_RECT_VERTICAL                                       0x00001d9c
#define NV097_SET_CLEAR_RECT_VERTICAL_YMIN                                        15:0
#define NV097_SET_CLEAR_RECT_VERTICAL_YMAX                                       31:16

#define NV097_SET_BEGIN_PATCH0                                              0x00001de0
#define NV097_SET_BEGIN_PATCH0_POSITION_DEGREE                                     3:0
#define NV097_SET_BEGIN_PATCH0_PARAM1_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH0_PARAM2_DEGREE                                      11:8
#define NV097_SET_BEGIN_PATCH0_PARAM3_DEGREE                                     15:12
#define NV097_SET_BEGIN_PATCH0_PARAM4_DEGREE                                     19:16
#define NV097_SET_BEGIN_PATCH0_PARAM5_DEGREE                                     23:20
#define NV097_SET_BEGIN_PATCH0_PARAM6_DEGREE                                     27:24
#define NV097_SET_BEGIN_PATCH0_PARAM7_DEGREE                                     31:28

#define NV097_SET_BEGIN_PATCH1                                              0x00001de4
#define NV097_SET_BEGIN_PATCH1_PARAM8_DEGREE                                       3:0
#define NV097_SET_BEGIN_PATCH1_PARAM9_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH1_PARAM10_DEGREE                                     11:8
#define NV097_SET_BEGIN_PATCH1_PARAM11_DEGREE                                    15:12
#define NV097_SET_BEGIN_PATCH1_PARAM12_DEGREE                                    19:16
#define NV097_SET_BEGIN_PATCH1_PARAM13_DEGREE                                    23:20
#define NV097_SET_BEGIN_PATCH1_PARAM14_DEGREE                                    27:24
#define NV097_SET_BEGIN_PATCH1_PARAM15_DEGREE                                    31:28

#define NV097_SET_BEGIN_PATCH2                                              0x00001de8
#define NV097_SET_BEGIN_PATCH2_SWATCH_ROWS                                         7:0
#define NV097_SET_BEGIN_PATCH2_SWATCH_COLS                                        15:8
#define NV097_SET_BEGIN_PATCH2_SWATCH_SIZE                                       20:16
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_WIDTH                              25:21
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_HEIGHT                             30:26
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE                                        31:31
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE_SQUARE                            0x00000000

#define NV097_SET_BEGIN_PATCH3                                              0x00001dec
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS                                            2:0
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_COL_TRNS                                            5:3
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_POSITION_GUARD_CURVE_DEGREE                         9:6
#define NV097_SET_BEGIN_PATCH3_NORMAL_GUARD_CURVE_DEGREE                         13:10
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE                                         15:14
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_TRI_STRIP                          0x00000000
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_REVERSED_TRI_STRIP                 0x00000001
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_TRI_STRIP                       0x00000002
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_REVERSED_TRI_STRIP              0x00000003
#define NV097_SET_BEGIN_PATCH3_TESSELATION                                       16:16
#define NV097_SET_BEGIN_PATCH3_TESSELATION_ADAPTIVE_STITCH                  0x00000000
#define NV097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH                     0x00000001
#define NV097_SET_BEGIN_PATCH3_NUM_COEFFS                                        31:24

#define NV097_SET_END_PATCH                                                 0x00001df0

#define NV097_SET_BEGIN_END_SWATCH                                          0x00001df4
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD                                      3:0
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END                           0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN                         0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH                                       7:4
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE                       0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW                            0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW                                 11:8
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL                                15:12
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH                                  19:16
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT              0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH                                 31:20
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH              0x00000001

#define NV097_SET_BEGIN_END_CURVE                                           0x00001df8
#define NV097_SET_BEGIN_END_CURVE_CMD                                              3:0
#define NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA                        0x00000000
#define NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE                           0x00000001
#define NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE                      0x00000002
#define NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE                     0x00000003
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE                0x00000004
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE                0x00000005
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT                          0x00000006
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT                          0x00000007

#define NV097_SET_CURVE_COEFFICIENTS(i)                             (0x00001e00+(i)*4)
#define NV097_SET_CURVE_COEFFICIENTS_V                                            31:0

#define NV097_SET_BEGIN_TRANSITION0                                         0x00001e10
#define NV097_SET_BEGIN_TRANSITION0_POSITION_DEGREE                                3:0
#define NV097_SET_BEGIN_TRANSITION0_PARAM1_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION0_PARAM2_DEGREE                                 11:8
#define NV097_SET_BEGIN_TRANSITION0_PARAM3_DEGREE                                15:12
#define NV097_SET_BEGIN_TRANSITION0_PARAM4_DEGREE                                19:16
#define NV097_SET_BEGIN_TRANSITION0_PARAM5_DEGREE                                23:20
#define NV097_SET_BEGIN_TRANSITION0_PARAM6_DEGREE                                27:24
#define NV097_SET_BEGIN_TRANSITION0_PARAM7_DEGREE                                31:28

#define NV097_SET_BEGIN_TRANSITION1                                         0x00001e14
#define NV097_SET_BEGIN_TRANSITION1_PARAM8_DEGREE                                  3:0
#define NV097_SET_BEGIN_TRANSITION1_PARAM9_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION1_PARAM10_DEGREE                                11:8
#define NV097_SET_BEGIN_TRANSITION1_PARAM11_DEGREE                               15:12
#define NV097_SET_BEGIN_TRANSITION1_PARAM12_DEGREE                               19:16
#define NV097_SET_BEGIN_TRANSITION1_PARAM13_DEGREE                               23:20
#define NV097_SET_BEGIN_TRANSITION1_PARAM14_DEGREE                               27:24
#define NV097_SET_BEGIN_TRANSITION1_PARAM15_DEGREE                               31:28

#define NV097_SET_BEGIN_TRANSITION2                                         0x00001e18
#define NV097_SET_BEGIN_TRANSITION2_INSIDE_SEGMENTS                                9:0
#define NV097_SET_BEGIN_TRANSITION2_OUTSIDE_SEGMENTS                             19:10
#define NV097_SET_BEGIN_TRANSITION2_NUM_COEFFS                                   31:24

#define NV097_SET_END_TRANSITION                                            0x00001e1c

#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD                                   0x00001e68
#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD_V                                       31:0

#define NV097_SET_SHADOW_DEPTH_FUNC                                         0x00001e6c
#define NV097_SET_SHADOW_DEPTH_FUNC_V                                             31:0
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NEVER                                 0x00000000
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LESS                                  0x00000001
#define NV097_SET_SHADOW_DEPTH_FUNC_V_EQUAL                                 0x00000002
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LEQUAL                                0x00000003
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GREATER                               0x00000004
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NOTEQUAL                              0x00000005
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GEQUAL                                0x00000006
#define NV097_SET_SHADOW_DEPTH_FUNC_V_ALWAYS                                0x00000007

#define NV097_SET_SHADER_STAGE_PROGRAM                                      0x00001e70
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0                                      4:0
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1                                      9:5
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2                                    14:10
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE           0x0000000B
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3                                    19:15
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR          0x0000000C
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D                    0x0000000D
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE                  0x0000000E
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST    0x00000012

#define NV097_SET_EYE_VECTOR(i)                                     (0x0000181c+(i)*4)
#define NV097_SET_EYE_VECTOR_V                                                    31:0

#define NV097_SET_DOT_RGBMAPPING                                            0x00001e74
#define NV097_SET_DOT_RGBMAPPING_STAGE1                                            3:0
#define NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE2                                            7:4
#define NV097_SET_DOT_RGBMAPPING_STAGE2_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE3                                           11:8
#define NV097_SET_DOT_RGBMAPPING_STAGE3_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_NV                  0x00000007

#define NV097_SET_SHADER_CLIP_PLANE_MODE                                    0x000017f8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S                                  0:0
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T                                  1:1
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R                                  2:2
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q                                  3:3
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S                                  4:4
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T                                  5:5
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R                                  6:6
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q                                  7:7
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S                                  8:8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T                                  9:9
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R                                10:10
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q                                11:11
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S                                12:12
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T                                13:13
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R                                14:14
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q                                15:15
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPGEZ                   0x00000001

#define NV097_SET_SHADER_OTHER_STAGE_INPUT                                  0x00001e78
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1                                 15:0
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2                                19:16
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3                                23:20
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2                 0x00000002

#define NV097_SET_SPECULAR_FOG_FACTOR(i)                            (0x00001e20+(i)*4)
#define NV097_SET_SPECULAR_FOG_FACTOR_BLUE                                         7:0
#define NV097_SET_SPECULAR_FOG_FACTOR_GREEN                                       15:8
#define NV097_SET_SPECULAR_FOG_FACTOR_RED                                        23:16
#define NV097_SET_SPECULAR_FOG_FACTOR_ALPHA                                      31:24

#define NV097_SET_COMBINER_CONTROL                                          0x00001e60
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT                                 7:0
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE                      0x00000001
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_TWO                      0x00000002
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_THREE                    0x00000003
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FOUR                     0x00000004
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FIVE                     0x00000005
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SIX                      0x00000006
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SEVEN                    0x00000007
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_EIGHT                    0x00000008
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT                                     11:8
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_LSB                           0x00000000
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB                           0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR0                                       15:12
#define NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR0_EACH_STAGE                       0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR1                                       31:16
#define NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR1_EACH_STAGE                       0x00000001

#define NV097_SET_COMBINER_COLOR_OCW(i)                             (0x00001e40+(i)*4)
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB                              31:19
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD                              18:18
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP                                          17:15
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT                             0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT_BIAS                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1                        0x00000002
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1_BIAS                   0x00000003
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY2                        0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTRIGHTBY1                       0x00000006
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE                               13:13
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE                               12:12
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_TRANSFORM_EXECUTION_MODE                                  0x00001e94
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE                                    1:0
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED                       0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_PROGRAM                     0x00000002
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE                             31:2
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_USER                  0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV                  0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN                            0x00001e98
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V                                31:0
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_ONLY                0x00000000
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_WRITE               0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_LOAD                                    0x00001e9c
#define NV097_SET_TRANSFORM_PROGRAM_LOAD_PROG_LD_PTR                              31:0

#define NV097_SET_TRANSFORM_PROGRAM_START                                   0x00001ea0
#define NV097_SET_TRANSFORM_PROGRAM_START_V                                       31:0

#define NV097_SET_TRANSFORM_PROGRAM(i)                              (0x00000b00+(i)*4)
#define NV097_SET_TRANSFORM_PROGRAM_V                                             31:0

#define NV097_SET_TRANSFORM_CONSTANT_LOAD                                   0x00001ea4
#define NV097_SET_TRANSFORM_CONSTANT_LOAD_CONST_LD_PTR                            31:0

#define NV097_SET_TRANSFORM_CONSTANT(i)                             (0x00000b80+(i)*4)
#define NV097_SET_TRANSFORM_CONSTANT_V                                            31:0

#define NV097_SET_TRANSFORM_DATA(i)                                 (0x00001e80+(i)*4)
#define NV097_SET_TRANSFORM_DATA_V                                                31:0

#define NV097_LAUNCH_TRANSFORM_PROGRAM                                      0x00001e90
#define NV097_LAUNCH_TRANSFORM_PROGRAM_V                                          31:0

#define NV097_SET_TWO_SIDE_LIGHT_EN                                         0x000017c4
#define NV097_SET_TWO_SIDE_LIGHT_EN_V                                             31:0
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE                                 0x00000000
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_TRUE                                  0x00000001

#define NV097_SET_BACK_SCENE_AMBIENT_COLOR(i)                       (0x000017a0+(i)*4)
#define NV097_SET_BACK_SCENE_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_MATERIAL_EMISSION(i)                         (0x000017b0+(i)*4)
#define NV097_SET_BACK_MATERIAL_EMISSION_V                                        31:0

#define NV097_CLEAR_REPORT_VALUE                                            0x000017c8
#define NV097_CLEAR_REPORT_VALUE_TYPE                                             31:0
#define NV097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT                       0x00000001

#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE                                  0x000017cc
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V                                      31:0
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_TRUE                           0x00000001

#define NV097_GET_REPORT                                                    0x000017d0
#define NV097_GET_REPORT_OFFSET                                                   23:0
#define NV097_GET_REPORT_TYPE                                                    31:24
#define NV097_GET_REPORT_TYPE_ZPASS_PIXEL_CNT                               0x00000001

#define NV097_DEBUG_INIT(i)                                         (0x00001fc0+(i)*4)
#define NV097_DEBUG_INIT_V                                                        31:0
#define NV097_TYPEDEF                                              Nv20KelvinPrimitive
#define NV097_SET_OBJECT                                                  (0x00000000)


// XXXmjc Shaun Ho and John Montrym will roll these into the master file at some point.
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D


/* class NV15_CONTEXT_SURFACE_SWIZZLED */
#define  NV15_CONTEXT_SURFACE_SWIZZLED                             (0x0000009E)
/* NvNotification[] elements */
#define NV09E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetFormat;               /* height_width_color V8_V8_V16     0300-0303*/
 NvU32 SetOffset;               /* byte offset of top-left pixel    0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv09eTypedef, Nv15ContextSurfaceSwizzled;
#define NV09E_TYPEDEF                                Nv15ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV09E_SET_OBJECT                                           (0x00000000)
#define NV09E_NO_OPERATION                                         (0x00000100)
#define NV09E_NOTIFY                                               (0x00000104)
#define NV09E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09E_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV09E_SET_FORMAT                                           (0x00000300)
#define NV09E_SET_FORMAT_COLOR                                     15:0
#define NV09E_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV09E_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV09E_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV09E_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV09E_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV09E_SET_FORMAT_WIDTH                                     23:16
#define NV09E_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV09E_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV09E_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV09E_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV09E_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV09E_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV09E_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV09E_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV09E_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV09E_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV09E_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV09E_SET_FORMAT_HEIGHT                                    31:24
#define NV09E_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV09E_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV09E_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV09E_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV09E_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV09E_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV09E_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV09E_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV09E_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV09E_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV09E_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV09E_SET_OFFSET                                           (0x00000304)


/* class NV15_IMAGE_BLIT */
#define  NV15_IMAGE_BLIT                                           (0x0000009F)
/* NvNotification[] elements */
#define NV09F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* scanline range to check 0 or 1   0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV09F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv09fTypedef, Nv12ImageBlit;
#define NV09F_TYPEDEF                                             Nv12ImageBlit
/* dma method offsets, fields, and values */
#define NV09F_SET_OBJECT                                           (0x00000000)
#define NV09F_NO_OPERATION                                         (0x00000100)
#define NV09F_NOTIFY                                               (0x00000104)
#define NV09F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09F_SYNC_SET_READ                                        (0x00000120)
#define NV09F_SYNC_SET_WRITE                                       (0x00000124)
#define NV09F_SYNC_SET_MODULO                                      (0x00000128)
#define NV09F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV09F_SYNC_STALL                                           (0x00000130)
#define NV09F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV09F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV09F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV09F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV09F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV09F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV09F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV09F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV09F_SET_OPERATION                                        (0x000002FC)
#define NV09F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV09F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV09F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV09F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV09F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV09F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV09F_CONTROL_POINT_IN                                     (0x00000300)
#define NV09F_CONTROL_POINT_IN_X                                   15:0
#define NV09F_CONTROL_POINT_IN_Y                                   31:16
#define NV09F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV09F_CONTROL_POINT_OUT_X                                  15:0
#define NV09F_CONTROL_POINT_OUT_Y                                  31:16
#define NV09F_SIZE                                                 (0x00000308)
#define NV09F_SIZE_WIDTH                                           15:0
#define NV09F_SIZE_HEIGHT                                          31:16


/* class NV20_IMAGE_BLIT */
#define  NV20_IMAGE_BLIT                                            (0x0000205F)
/* NvNotification[] elements */
#define NV205F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV205F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV205F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV205F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV205F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV205F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV205F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV205F_NOTIFY_*                  0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* ignored                          0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV205F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv205fTypedef, Nv20ImageBlit;
#define NV205F_TYPEDEF                                             Nv20ImageBlit
/* dma method offsets, fields, and values */
#define NV205F_SET_OBJECT                                           (0x00000000)
#define NV205F_NO_OPERATION                                         (0x00000100)
#define NV205F_NOTIFY                                               (0x00000104)
#define NV205F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV205F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV205F_SYNC_SET_READ                                        (0x00000120)
#define NV205F_SYNC_SET_WRITE                                       (0x00000124)
#define NV205F_SYNC_SET_MODULO                                      (0x00000128)
#define NV205F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV205F_SYNC_STALL                                           (0x00000130)
#define NV205F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV205F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV205F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV205F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV205F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV205F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV205F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV205F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV205F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV205F_SET_OPERATION                                        (0x000002FC)
#define NV205F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV205F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV205F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV205F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV205F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV205F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV205F_CONTROL_POINT_IN                                     (0x00000300)
#define NV205F_CONTROL_POINT_IN_X                                   15:0
#define NV205F_CONTROL_POINT_IN_Y                                   31:16
#define NV205F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV205F_CONTROL_POINT_OUT_X                                  15:0
#define NV205F_CONTROL_POINT_OUT_Y                                  31:16
#define NV205F_SIZE                                                 (0x00000308)
#define NV205F_SIZE_WIDTH                                           15:0
#define NV205F_SIZE_HEIGHT                                          31:16


/* class NV03_DEVICE_XX */
#define  NV03_DEVICE_XX                                            (0x000000FF)
/* NvNotification[] fields and values */
#define NV0FF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0FFTypedef, Nv03DeviceXX;
#define  NV0FF_TYPEDEF                                             Nv03DeviceXX

typedef V032 Nvff0Typedef;

typedef V032 Nvff1Typedef;

typedef V032 Nvff2Typedef;

typedef V032 Nvff3Typedef;

typedef V032 Nvff4Typedef;


/* class NV_CONTEXT_ERROR_TO_MEMORY */
#define  NV_CONTEXT_ERROR_TO_MEMORY                                (0x00000FF5)
/* NvNotification[] elements */
#define NVFF5_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF5_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF5_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF5_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} Nvff5Typedef, NvContextErrorToMemory;
#define NVFF5_TYPEDEF                                    NvContextErrorToMemory
/* dma method offsets, fields, and values */
#define NVFF5_SET_OBJECT(s)                              (0x00040000+8192*(s))
#define NVFF5_NO_OPERATION(s)                            (0x00040100+8192*(s))
#define NVFF5_NOTIFY(s)                                  (0x00040104+8192*(s))
#define NVFF5_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF5_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF5_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00040180+8192*(s))
#define NVFF5_SET_DMA_SPECIFIER(s)                       (0x000C0300+8192*(s))
/* obsolete stuff */
#define nvContextErrorToMemory                           NvContextErrorToMemory


/* class NV_VIDEO_COLOR_KEY */
#define  NV_VIDEO_COLOR_KEY                                        (0x00000FF6)
/* NvNotification[] elements */
#define NVFF6_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF6_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF6_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput[3];        /* NV1_PATCHCORD_VIDEO               0204-020b*/
 V032 Reserved02[0x03c];
 V032 SetColorFormat;          /* NVFF6_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top-left  0308-030b*/
 V032 SetSize;                 /* height_width U16_U16 in pixels    030c-030f*/
 V032 Reserved03[0x73c];
} Nvff6Typedef, NvVideoColorKey;
#define NVFF6_TYPEDEF                                    NvVideoColorKey
/* dma method offsets, fields, and values */
#define NVFF6_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF6_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF6_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF6_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF6_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF6_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF6_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF6_SET_VIDEO_INPUT(s,i)                       (0x00000204+8192*(s)+\
                                                                       4*(i))
#define NVFF6_SET_COLOR_FORMAT(s)                        (0x00000300+8192*(s))
#define NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8                (0x00000001)
#define NVFF6_SET_COLOR_FORMAT_LE_X24Y8                  (0x00000002)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5            (0x00000003)
#define NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5              (0x00000004)
#define NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5              (0x00000005)
#define NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8               (0x00000006)
#define NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8               (0x00000007)
#define NVFF6_SET_COLOR_FORMAT_LE_A16Y16                 (0x00000008)
#define NVFF6_SET_COLOR_FORMAT_LE_X16Y16                 (0x00000009)
#define NVFF6_SET_COLOR_KEY(s)                           (0x00000304+8192*(s))
#define NVFF6_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF6_SET_POINT_X                                15:0
#define NVFF6_SET_POINT_Y                                31:16
#define NVFF6_SET_SIZE(s)                                (0x0000030C+8192*(s))
#define NVFF6_SET_SIZE_WIDTH                             15:0
#define NVFF6_SET_SIZE_HEIGHT                            31:16
/* obsolete stuff */
#define nvVideoColorKey                                  NvVideoColorKey


/* class NV_VIDEO_SCALER */
#define  NV_VIDEO_SCALER                                           (0x00000FF7)
/* NvNotification[] elements */
#define NVFF7_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF7_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF7_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x03e];
 V032 SetDeltaDuDx;            /* S12d20 ratio du/dx                0300-0303*/
 V032 SetDeltaDvDy;            /* S12d20 ratio dv/dy                0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels, top-left   0308-030b*/
 V032 Reserved03[0x73d];
} Nvff7Typedef, NvVideoScaler;
#define NVFF7_TYPEDEF                                    NvVideoScaler
/* dma method offsets, fields, and values */
#define NVFF7_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF7_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF7_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF7_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF7_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF7_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF7_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF7_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF7_SET_DELTA_DU_DX(s)                         (0x00000300+8192*(s))
#define NVFF7_SET_DELTA_DV_DY(s)                         (0x00000304+8192*(s))
#define NVFF7_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF7_SET_POINT_X                                15:0
#define NVFF7_SET_POINT_Y                                31:16
/* obsolete stuff */
#define nvVideoScaler                                    NvVideoScaler


/* class NV_VIDEO_FROM_MEMORY */
#define  NV_VIDEO_FROM_MEMORY                                      (0x00000FF8)
/* NvNotification[] elements */
#define NVFF8_NOTIFIERS_NOTIFY                                     (0)
#define NVFF8_NOTIFIERS_IMAGE_SCAN(b)                              (1+(b))
#define NVFF8_NOTIFIERS_GET_OFFSET_NOTIFY(b)                       (3+(b))
/* NvNotification[] fields and values */
#define NVFF8_NOTIFICATION_INFO16_BUFFER_NOT_STARTED               (0x0001)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_OFFSET_VALID              (0x0002)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_DONE                      (0x0003)
#define NVFF8_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_PATCH                  (0x0400)
#define NVFF8_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF8_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NVFF8_STOP_TRANSFER_VALUE         0108-010b*/
 V032 SetPatch;                /* NVFF8_SET_PATCH_*                 010c-010f*/
 V032 Reserved00[0x01c];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage[2];   /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-018b*/
 V032 Reserved01[0x01d];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 Reserved02[0x03f];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes, vertical pixel delta         04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* field_color V16_V16                 0c-  0f*/
  V032 notify;                 /* NVFF8_IMAGE_SCAN_NOTIFY_*           10-  13*/
 } ImageScan[2];               /* end of methods in array               -0327*/
 V032 GetOffsetNotify[2];      /* NVFF8_GET_OFFSET_NOTIFY_*         0328-032f*/
 V032 Reserved03[0x734];
} Nvff8Typedef, NvVideoFromMemory;
#define NVFF8_TYPEDEF                                    NvVideoFromMemory
/* dma method offsets, fields, and values */
#define NVFF8_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF8_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF8_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF8_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF8_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF8_STOP_TRANSFER(s)                           (0x00000108+8192*(s))
#define NVFF8_STOP_TRANSFER_VALUE                        (0x00000000)
#define NVFF8_SET_PATCH(s)                               (0x0000010C+8192*(s))
#define NVFF8_SET_PATCH_INVALIDATE                       (0x00000000)
#define NVFF8_SET_PATCH_VALIDATE                         (0x00000001)
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF8_SET_CONTEXT_DMA_IMAGE(s,b)                 (0x00000184+8192*(s)+\
                                                                        4*(b))
#define NVFF8_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF8_IMAGE_SCAN(s,b)                            (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_OFFSET(s,b)                     (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_PITCH(s,b)                      (0x00000304+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE(s,b)                       (0x00000308+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE_WIDTH                      15:0
#define NVFF8_IMAGE_SCAN_SIZE_HEIGHT                     31:16
#define NVFF8_IMAGE_SCAN_FORMAT(s,b)                     (0x0000030C+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR                    15:0
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8              (0x00000001)
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4                      0x00000001
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8      (0x00000002)
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8                   0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8      (0x00000003)
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8                   0x00000003
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5       (0x00000004)
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2                0x00000004
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5          (0x00000005)
#define NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2                  0x00000005
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8     (0x00000006)
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8                   0x00000006
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD                    31:16
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_PROGRESSIVE        (0x00000001)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_EVEN_FIELD         (0x00000002)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_ODD_FIELD          (0x00000003)
#define NVFF8_IMAGE_SCAN_NOTIFY(s,b)                     (0x00000310+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_GET_OFFSET_NOTIFY(s,b)                     (0x00000328+8192*(s)+\
                                                                        4*(b))
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
/* obsolete stuff */
#define nvVideoFromMemory                                NvVideoFromMemory
#define SetImageCtxDma                                   SetContextDmaImage
#define SetImageNotifyCtxDma                             SetContextDmaNotifies


/* class NV_VIDEO_COLORMAP */
#define  NV_VIDEO_COLORMAP                                         (0x00000FF9)
/* NvNotification[] elements */
#define NVFF9_NOTIFIERS_NOTIFY                                     (0)
#define NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY                      (1)
/* NvNotification[] fields and values */
#define NVFF9_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF9_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 SetContextDmaColormap;   /* NV_CONTEXT_DMA_FROM_MEMORY        0184-0187*/
 V032 Reserved01[0x01e];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x040];
 U032 SetColormapStart;        /* offset in bytes                   0308-030b*/
 U032 SetColormapLength;       /* in bytes                          030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update         0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, starts transfer         0314-0317*/
 V032 Reserved03[0x73a];
} Nvff9Typedef, NvVideoColormap;
#define NVFF9_TYPEDEF                                    NvVideoColormap
/* dma method offsets, fields, and values */
#define NVFF9_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF9_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF9_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF9_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF9_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF9_SET_CONTEXT_DMA_COLORMAP(s)                (0x00000184+8192*(s))
#define NVFF9_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF9_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF9_SET_COLORMAP_START(s)                      (0x00000308+8192*(s))
#define NVFF9_SET_COLORMAP_LENGTH(s)                     (0x0000030C+8192*(s))
#define NVFF9_COLORMAP_DIRTY_START(s)                    (0x00000310+8192*(s))
#define NVFF9_COLORMAP_DIRTY_LENGTH(s)                   (0x00000314+8192*(s))
/* obsolete stuff */
#define nvVideoColormap                                  NvVideoColormap


/* class NV_VIDEO_SINK */
#define  NV_VIDEO_SINK                                             (0x00000FFA)
/* NvNotification[] elements */
#define NVFFA_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFA_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFA_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFA_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoInput[64];       /* NV1_PATCHCORD_VIDEO               0200-02ff*/
 V032 Reserved02[0x740];
} NvffaTypedef, NvVideoSink;
#define NVFFA_TYPEDEF                                    NvVideoSink
/* dma method offsets, fields, and values */
#define NVFFA_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFA_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFA_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFA_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFA_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFA_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFA_SET_VIDEO_INPUT(s,i)                       (0x00000200+8192*(s)+\
                                                                        4*(i))
/* obsolete stuff */
#define nvVideoSink                                      NvVideoSink


/* class NV_PATCHCORD_VIDEO */
#define  NV_PATCHCORD_VIDEO                                        (0x00000FFB)
/* NvNotification[] entries, values, errors, warnings */
#define NVFFB_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} NvffbTypedef, NvPatchcordVideo;
#define NVFFB_TYPEDEF                                    NvPatchcordVideo
/* obsolete stuff */
#define nvPatchcordVideo                                 NvPatchcordVideo


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define  NV_CONTEXT_DMA_IN_MEMORY                                  (0x00000FFC)
/* NvNotification[] elements */
#define NVFFC_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFC_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFC_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFC_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* On X86 address[1] is the selector    0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffcTypedef, NvContextDmaInMemory;
#define NVFFC_TYPEDEF                                    NvContextDmaInMemory
/* dma method offsets, fields, and values */
#define NVFFC_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFC_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFC_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFC_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFC_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFC_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFC_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaInMemory                             NvContextDmaInMemory


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define  NV_CONTEXT_DMA_TO_MEMORY                                  (0x00000FFD)
/* NvNotification[] elements */
#define NVFFD_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFD_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFD_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFD_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffdTypedef, NvContextDmaToMemory;
#define NVFFD_TYPEDEF                                    NvContextDmaToMemory
/* dma method offsets, fields, and values */
#define NVFFD_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFD_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFD_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFD_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFD_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFD_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFD_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaToMemory                             NvContextDmaToMemory


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define  NV_CONTEXT_DMA_FROM_MEMORY                                (0x00000FFE)
/* NvNotification[] elements */
#define NVFFE_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFE_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFE_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFE_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffeTypedef, NvContextDmaFromMemory;
#define NVFFE_TYPEDEF                                    NvContextDmaFromMemory
/* dma method offsets, fields, and values */
#define NVFFE_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFE_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFE_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFE_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFE_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaFromMemory                           NvContextDmaFromMemory


/* class NV_CLASS */
#define  NV_CLASS                                                  (0x00000FFF)
/* NvNotification[] elements */
#define NVFFF_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFF_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFF_NOTIFICATION_STATUS_WARNING_UNAVAILABLE              (0x0002)
#define NVFFF_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFF_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 V032 Create;                  /* 32-bit handle of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit handle of object           0304-0307*/
 V032 Reserved02[0x73e];
} NvfffTypedef, NvClass;
#define NVFFF_TYPEDEF                                    NvClass
/* dma method offsets, fields, and values */
#define NVFFF_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFF_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFF_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFF_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFF_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFF_CREATE(s)                                  (0x00000300+8192*(s))
#define NVFFF_DESTROY(s)                                 (0x00000304+8192*(s))
/* obsolete stuff */
#define nvClass                                          NvClass



 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

typedef NvV32 Nv068Typedef;

typedef NvV32 Nv069Typedef;


/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                          (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv03ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv03ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */

} Nv03SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                                 (0x007C)
#define NV06A_FIFO_EMPTY                                           (0x007C)
#define NV06A_FIFO_FULL                                            (0x0000)
/* obsolete stuff */
#define NV3_CHANNEL_PIO                                            (0x0000006A)
#define Nv3ControlPio                                            Nv03ControlPio
#define Nv3SubchannelPio                                      Nv03SubchannelPio
#define Nv3ChannelPio                                            Nv03ChannelPio
#define NvChannel                                                Nv03ChannelPio
#define nv03ChannelPio                                           Nv03ChannelPio


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                          (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define NV06B_TYPEDEF                                            Nv03ChannelDma
#define nv03ChannelDma                                           Nv03ChannelDma


/* class NV04_CHANNEL_PIO */
#define  NV04_CHANNEL_PIO                                          (0x0000006D)
/* NvNotification[] fields and values */
#define NV06D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06D_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv04ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv04ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nv097Typedef NV097_TYPEDEF;
  Nv1189Typedef NV1189_TYPEDEF;
  Nv205fTypedef NV205F_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */
} Nv04SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv04SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv04ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06D_FIFO_GUARANTEED_SIZE                                 (0x0200)
#define NV06D_FIFO_EMPTY                                           (0x0200)
#define NV06D_FIFO_FULL                                            (0x0000)


/* class NV04_CHANNEL_DMA */
#define  NV04_CHANNEL_DMA                                          (0x0000006C)
/* NvNotification[] fields and values */
#define NV06C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06cTypedef, Nv04ChannelDma;
#define NV06C_TYPEDEF                                            Nv04ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only            0040-0043*/
 NvU32 Get;                     /* get offset, read only             0044-0047*/
 NvV32 Ignored01[0x002];
 NvU32 StallNotifier;           /* Set stall notifier                0050-0053*/
 NvU32 StallChannel;            /* Stall the channel                 0054-0057*/
 NvV32 Ignored02[0x7EA];
} Nv04ControlDma;
/* obsolete stuff */
#define NV4_CHANNEL_DMA                                            (0x0000006C)
#define Nv4ChannelDma                                            Nv04ChannelDma
#define nv4ChannelDma                                            Nv04ChannelDma
#define Nv4ControlDma                                            Nv04ControlDma


/* class NV10_CHANNEL_DMA */
#define  NV10_CHANNEL_DMA                                          (0x0000006E)
/* NvNotification[] fields and values */
#define NV06E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06eTypedef, Nv10ChannelDma;
#define NV06E_TYPEDEF                                            Nv10ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv06eControl, Nv10ControlDma;
/* fields and values */
#define NV06E_NUMBER_OF_SUBCHANNELS                                (8)
#define NV06E_SET_OBJECT                                           (0x00000000)
#define NV06E_SET_REFERENCE                                        (0x00000050)

/* class NV20_CHANNEL_DMA */
#define  NV20_CHANNEL_DMA                                          (0x0000206E)
/* NvNotification[] fields and values */
#define NV206E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT              (0x2000)
#define NV206E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT          (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv206eTypedef, Nv20ChannelDma;
#define NV206E_TYPEDEF                                           Nv20ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv206eControl, Nv20ControlDma;
/* fields and values */
#define NV206E_NUMBER_OF_SUBCHANNELS                               (8)
#define NV206E_SET_OBJECT                                          (0x00000000)
#define NV206E_SET_REFERENCE                                       (0x00000050)
#define NV206E_SET_CONTEXT_DMA_SEMAPHORE                           (0x00000060)
#define NV206E_SEMAPHORE_OFFSET                                    (0x00000064)
#define NV206E_SEMAPHORE_ACQUIRE                                   (0x00000068)
#define NV206E_SEMAPHORE_RELEASE                                   (0x0000006c)


 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                                         (0x00000000)
/* obsolete stuff */
#define NV1_NULL_OBJECT                                            (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS.
 * NV fills in the NvNotification[] data structure in the following order:
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  NvU32 nanoseconds[2];        /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 NvV32 info32;                 /* info returned depends on method   0008-000b*/
 NvV16 info16;                 /* info returned depends on method   000c-000d*/
 NvV16 status;                 /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */

 /***************************************************************************\
|*                          NvGraphicsState                                  *|
 \***************************************************************************/
/***** NvGraphicsState Structure *****/
/*
 * This represents the state structure that's passed between the Celsius
 * GetState method and the RM (in nv10 and eventually the HW). The context
 * DMA passed to NV056_SET_CONTEXT_DMA_STATE should be at least this size.
 */

typedef volatile struct {
    struct _PerFragmentState {
        // *** dword 0
        NvU32          pad0 : 8;
        NvU32     alphaFunc : 4;
        NvU32          pad1 : 4;
        NvU32     depthFunc : 4;
        NvU32          pad2 : 4;
        NvU32     depthMask : 1;
        NvU32          pad3 : 1;
        NvU32     alphaMask : 1;
        NvU32       redMask : 1;
        NvU32     greenMask : 1;
        NvU32      blueMask : 1;
        NvU32          pad4 : 2;
        // *** dword 1
        NvU32          pad5 : 4;
        NvU32   stencilFunc : 4;
        NvU32    stencilRef : 8;
        NvU32          pad6 : 8;
        NvU32   stencilMask : 8;
        // *** dword 2
        NvU32       sfailOp : 4;
        NvU32       zfailOp : 4;
        NvU32       zpassOp : 4;
        NvU32         pad7 : 20;
        // *** dword 3
        NvU32 blendEquation : 3;
        NvU32          pad8 : 1;
        NvU32      srcBlend : 4;
        NvU32     destBlend : 4;
        NvU32         pad9 : 20;
    } PerFragmentState;
    struct _PerVertexState {
        NvF32           pad0[4];
        NvF32   primaryColor[4];
        NvF32 secondaryColor[3];
        NvF32          fogCoord;
        NvF32    texCoord[2][4];
        NvF32         normal[3];
        NvF32              pad1;
        NvF32      vertexWeight;
        NvU32           pad2[7];
        NvU32              pad3;
        NvU32      edgeFlag : 8;
        NvU32         pad4 : 24;
        NvU32           pad5[2];
    } PerVertexState;
    struct _VertexArrayState {
        NvU32      vertexOffset;
        NvU32      vertexFormat;
        NvU32     diffuseOffset;
        NvU32     diffuseFormat;
        NvU32    specularOffset;
        NvU32    specularFormat;
        NvU32   texCoord0Offset;
        NvU32   texCoord0Format;
        NvU32   texCoord1Offset;
        NvU32   texCoord1Format;
        NvU32      normalOffset;
        NvU32      normalFormat;
        NvU32      weightOffset;
        NvU32      weightFormat;
        NvU32         fogOffset;
        NvU32         fogFormat;
    } VertexArrayState;
    struct _PrimitiveAssmState {
        NvU32    primAssm[3*16];
    } PrimitiveAssmState;
} NvGraphicsState;

 /***************************************************************************\
|*                          Object Allocation Parameters                     *|
 \***************************************************************************/

// class 0x07c creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07C_ALLOCATION_PARAMETERS;

// class 0x07a creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07A_ALLOCATION_PARAMETERS;

 /***************************************************************************\
|*                          NVIDIA Debug Extensions                         *|
 \***************************************************************************/

/*
 * These class numbers are a temporary hack to allow the debugger
 * client to use the NvAlloc interface to access debugger services.
 */
#define  NVDE_REGISTER_DEBUGGER                                    (0xDE000001)
#define  NVDE_UNREGISTER_DEBUGGER                                  (0xDE000002)
#define  NVDE_READ_MEMORY                                          (0xDE000003)
#define  NVDE_WRITE_MEMORY                                         (0xDE000004)
#define  NVDE_GET_EVENT_INFORMATION                                (0xDE000005)
#define  NVDE_TEST                                                 (0xDE00ffff)

#define NVDE_DEBUGGER                                              (0xDE000000)

/*
 * Status codes.
 */
#define NVDE_STATUS_SUCCESS                                         (0x0000)
#define NVDE_STATUS_ERROR_STATE_IN_USE                              (0x0001)
#define NVDE_STATUS_ERROR_BAD_ARGUMENT                              (0x0002)

/*
 * Class-specific parameter blocks.
 */
typedef struct
{
    NvU64 EventHandle;
    NvU32 EventClass;
} NVDE_ALLOCATION_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 TrapEvent;
} NVDE_REGISTER_DEBUGGER_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 foo;
} NVDE_UNREGISTER_DEBUGGER_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_READ_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_WRITE_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 CallBackAddress;
} NVDE_TEST_PARAMETERS;

typedef NvU32 (*NVDE_TEST_FUNC)();

// must be moved to NVDE class
typedef struct
{
    U032 Count;
    U032 Event[32][8];
} NVDE_GET_EVENT_INFORMATION_PARAMETERS;

/* class NV01_DEVICE_AUDIO */
#define  NV01_DEVICE_AUDIO                                         (0x000000A0)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A0Typedef, Nv01DeviceAudio;
#define  NV0A0_TYPEDEF                                             Nv01DeviceAudio

#define NV01_CONTEXT_DMA_AUDIO                                      (0x000000A1)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV1B_AUDIO_OBJECT                                           (0x000000A2)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

/* class NV01_DEVICE_EXTERNAL_CODEC */
#define  NV01_DEVICE_EXTERNAL_CODEC                                 (0x000000A3)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A3Typedef, Nv03DeviceExternalCodec;
#define  NV0A3_TYPEDEF                                             Nv01DeviceCodec

#define NV01_CONTEXT_DMA_EXTERNAL_CODEC                             (0x000000A4)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV01_EXTERNAL_CODEC_OBJECT                                  (0x000000A5)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

#define NV01_EXTERNAL_CODEC_WRITE                                   (0x000000A6)
// define the errors here later
#define NV01_EXTERNAL_CODEC_READ                                    (0x000000A7)
// define the errors here later

// this IOCTL manages system memory for the client - see AUDIO_ALLOC_MEMORY / AUDIO_FREE_MEMORY
#define NV01_MEMORY_AUDIO		                                    (0x000000A8)

// class 0x0A1 creation params (NV01_CONTEXT_DMA_AUDIO)

typedef union
{
	struct
	{
		NvU32 : 32;
	}codec;

	struct
	{
		NvU32  : 27;
		// interrupts originating from FE/SE
		NvU32 FEMethodOverFlow : 1;	// user method fifo has been overwritten
		NvU32 FEVoice : 1;			// end-of-buffer / end-of-stream
		NvU32 FENotify : 1;			// notifier originating from the FE has been written
		NvU32 DeltaPanic : 1;		// delta panic
		NvU32 DeltaWarning : 1;		// delta warning
	}apu;
	
	NvU32 uValue;					// set to ~0x0 (for codec) if the ISR fn is to be called regardless
} INTR_MASK;

typedef void (*PISRCALLBACK)(NvV32,	/* service context*/ 
							NvU32,	/* interrupt mask (INTR_MASK.uValue) with bits of triggered intr set */
							NvV32);	/* info based on reason */

typedef struct
{
	NvV32			pResList;		/*	address of resource structure	*/
	NvU8			uRevisionID;	/*	HW Revision ID of the chip - byte 0x8 in the PCI config */
	NvV32			pDevObj;		/*	address of device object		*/		
	PISRCALLBACK	pISRFn;			/*	address to an optional ISR		*/
	NvV32			pServiceContext;/*	service context for the ISR		*/
	INTR_MASK		IntrMask;		/*	set the bits for which pISRFn needs to be called	*/
	NvU32			uDeviceRef;		/*	device reference				*/
} AUDIO_INIT_DEVICE;

/*
Arguments:
		IN pResourceList - 	of type PCM_RESOURCE_LIST (WDM) - translated resource list got in IRP_MN_START_DEVICE
				of type CM_CONFIG (Win9X VxD)
				of type PCI_COMMON_CONFIG (NT4)
				TBD for linux.
	 	IN pDeviceObject - only valid in NT and WDM, ignored in Win9X VxD
		IN pISRFn (optional) - not recommended unless it is absolutely necessary.  
								The driver can install it to handle interrupts from the codec if it needs to.  
								Type - void pISRFn(U032 ServiceContext);
		IN uServiceContext (optional) - value passed back to the pISRFn if installed.
		OUT pDeviceRef	- device ref returned by the RM
*/


// defines the "type" for context DMA
#define AUDIO_CONTEXT_DMA_SESGE         0x1
#define AUDIO_CONTEXT_DMA_SESSL         0x2
#define AUDIO_CONTEXT_DMA_GPSGE         0x3
#define AUDIO_CONTEXT_DMA_FENOTIFIER    0x4
#define AUDIO_CONTEXT_DMA_EPSGE         0x5

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uType;              // one of the values defined above
	NvU32	uBaseAddress;       // base address for the type. (must be 4K aligned)
	NvU32	uMaxOffset;         // max offset for the type. (must be 4K aligned)
	NvU32	uHandle;            // OUT: handle of the context DMA
} APU_AP_ALLOC_CONTEXT_DMA;

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU32	uHandle;            // handle of the context DMA
} APU_AP_FREE_CONTEXT_DMA;


#define GSCNT_FREE_RUNNING          0 
#define GSCNT_ACSYNC                1   /* updated for every AC_SYNC pulse (48KHz) */
#define GSCNT_SW                    2   /* client will update it */

// class 0x0A2 creation parameters (NV1B_AUDIO_PROCESSOR)
typedef union
{
    struct
    {	
        NvU32       : 29;
        NvU32 GSCNT : 2;        // see values defined above
        NvU32 ISO   : 1;        // set if ISO (takes care of all ISO flags in the HW)
    }fields;
    
    NvU32 uValue;
} APU_AP_FLAGS;

typedef struct 
{
    NvV32           pObjectDmaBuffer;           // in buffer for global effects dma commands.
    NvV32           pObjectNotifiesBuffer;      // in buffer for voice notifies
    NvV32           pObjectGlobalNotifiesBuffer; // in buffer for global notifies
    APU_AP_FLAGS    flags; 
    VOID_PTR        pioBase; 
    NvU32           limitFifo; 
    NvU32           limitBandwidth; 
    NvU32           limitBlockClock; 
    NvU32           overhead; 
    
    NvU32           uVoiceCount;        // in/out req # of voices , return #
    NvU32           uVoice3dCount;      // in/out req # of 3d voices , return #
    NvU32           uHRTFCount;         // in/out req # of HRTFs, return #
    NvU32           uSubmixCount;       // in/out req # of Submixes, return #
    NvU32           uSegInCount;        // in/out req # of segments for input, return #
    NvU32           uSGEInCount;        // in/out req # of 4K SGE for input, return #
    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #
    NvU32           uGPScratch;         // in/out reg # of PRDs for GP scratch memory
    
    // global sample count values - ignored if GSCNT = GSCNT_FREE_RUNNING
    NvU32           uExternalGSCNT;     // in updated according to the GSCNT flag above
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - uExternalGSCNT) < uDeltaGSCNT, HW renders
    
    VOID_PTR        pVoiceList;         // out (DEBUG ONLY) - linear address of the voice structure
}APU_AP_CREATE;


typedef struct
{
    VOID_PTR        pioBase;

    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #
    NvU32           uScratch;           // in/out reg # of PRDs for EP scratch memory

    // global sample counts applied only to teh EP
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - APU_AP_CREATE::uExternalGSCNT) < uDeltaGSCNT, HW renders
    NvU32           uStepSize;          // in step size added to uInternalGSCNT each frame

} APU_EP_CREATE;

typedef APU_AP_CREATE NV0A2_ALLOCATION_PARAMETERS;

// NV01_EXTERNAL_CODEC_OBJECT

// class 0x0A5 creation parameters (NV01_EXTERNAL_CODEC_OBJECT)
typedef struct
{
	VOID_PTR	pioBaseMixer;
	VOID_PTR	pioBaseAci;
} CODEC_AUDIO_CREATE;

// the object alloc structure is used, both for codec and APU object allocation
// uObjectCode codes
#define	AUDIO_OBJECT_AP					0x1
#define AUDIO_OBJECT_EP					0x2
#define CODEC_OBJECT_AUDIO				0x3
#define CODEC_OBJECT_MODEM				0x4		/* not supported */

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uObjectCode;
	NvV32	pParam;	
} APU_OBJECT;

#define CODEC_ACCESS_08				1
#define CODEC_ACCESS_16				2
#define CODEC_ACCESS_32				4

// alloc params for NV01_EXTERNAL_CODEC_READ & NV01_EXTERNAL_CODEC_WRITE
typedef struct
{
	NvU32	    uDeviceRef;	            // device reference
	VOID_PTR	BaseAddr;               // base address for which read/write is made
	NvU32	    Offset;                 // offset from the base address for which access is to be made
	NvV32	    AccessType;             // hardware access type
	/*
	for BYTE reads/writes	ValidBytes = CODEC_ACCESS_08 valid Val field = u8
	for WORD reads/writes	ValidBytes = CODEC_ACCESS_16 valid Val field = u16
	for DWORD reads/writes	ValidBytes = CODEC_ACCESS_32 valid Val Field = u32
	any other value for ValidBytes is illegal
	*/
	union
	{
		NvU8	u8;
		NvU16	u16;
		NvU32	u32;
	}Val;
}CODEC_ACCESS_PARAMS;


// 0xA8 memory management paramters

#define MEM_ALIGN_4K					0x00000000
#define MEM_ALIGN_8K					0x00000001		
#define MEM_ALIGN_16K					0x00000003
#define MEM_ALIGN_32K					0x00000007
#define MEM_ALIGN_64K					0x0000000F
#define MEM_ALIGN_128K					0x0000001F
#define MEM_ALIGN_DONT_CARE				0xFFFFFFFF

// for allocation use:
typedef struct
{
	NvU32       uSize;          // IN:	size of memory to be allocated in bytes
	NvU32       uAlignMask;     // IN:	alignment mask to get physically contiguous memory
                                // use ALIGN_DONT_CARE if it need not be aligned and physically contiguous
	VOID_PTR    pLinearAddress; // OUT: linear address of allocated memory (NULL on failure)
} AUDIO_ALLOC_MEMORY;

// for freeing memory use:
typedef struct
{
	VOID_PTR    pLinearAddress; // IN: linear address of allocated memory
} AUDIO_FREE_MEMORY;

#ifdef __cplusplus
};          // extern "C" {
#endif

#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvRmApi.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApi.h
 *
 * NVidia resource manager API header file exported to drivers.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#include <nvos.h>

#ifdef NV_ICD_NT
#define NvRmAlloc NvRmAllocNt
#define NvRmAllocRoot NvRmAllocRootNt
#define NvRmAllocDevice NvRmAllocDeviceNt
#define NvRmAllocContextDma NvRmAllocContextDmaNt
#define NvRmAllocChannelPio NvRmAllocChannelPioNt
#define NvRmAllocChannelDma NvRmAllocChannelDmaNt
#define NvRmAllocMemory NvRmAllocMemoryNt
#define NvRmAllocObject NvRmAllocObjectNt
#define NvRmFree NvRmFreeNt
#define NvRmArchHeap NvRmArchHeapNt
#define NvRmConfigGet NvRmConfigGetNt
#define NvRmConfigGetEx NvRmConfigGetExNt
ULONG  NvRmAllocNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NvRmAllocRootNt(ULONG *phClient);
ULONG  NvRmAllocDeviceNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NvRmAllocContextDmaNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NvRmAllocChannelDmaNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NvRmAllocMemoryNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NvRmAllocObjectNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NvRmFreeNt(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NvRmArchHeapNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NvRmConfigGetNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NvRmConfigGetExNt(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#else /* NV_ICD_NT */
#ifndef WINNT
HANDLE NV_APIENTRY NvRmOpen(VOID);
VOID   NV_APIENTRY NvRmClose(VOID);
ULONG  NV_APIENTRY NvRmAlloc(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NV_APIENTRY NvRmAllocRoot(ULONG *phClient);
ULONG  NV_APIENTRY NvRmAllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NV_APIENTRY NvRmAllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NV_APIENTRY NvRmAllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  NV_APIENTRY NvRmAllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NV_APIENTRY NvRmAllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NV_APIENTRY NvRmAllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NV_APIENTRY NvRmFree(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NV_APIENTRY Nv3RmGetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  NV_APIENTRY NvRmAllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
ULONG  NV_APIENTRY NvRmArchHeap(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
                              ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NV_APIENTRY NvRmConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
ULONG  NV_APIENTRY NvRmConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  NV_APIENTRY NvRmInterrupt(ULONG hClient, ULONG hDevice);
ULONG  NV_APIENTRY NvRmRing0Callback(ULONG hClient, ULONG hDevice, ULONG procAddr, ULONG param1, ULONG param2);
ULONG  NV_APIENTRY NvRmConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmI2CAccess(ULONG hClient, ULONG hDevice, VOID * ctrlStructPtr );
ULONG  NV_APIENTRY NvRmPowerManagement(ULONG hRoot, ULONG hDevice, ULONG head, ULONG command, VOID *paramStructPtr);
ULONG  NV_APIENTRY NvRmDebugControl(ULONG hRoot, ULONG command, VOID *pArgs);
ULONG  NV_APIENTRY NvRmIoFlush(VOID);
#ifdef LINUX
ULONG  NV_APIENTRY NvRmAGPInit(ULONG hClient, ULONG hDevice, ULONG agp_config);
ULONG  NV_APIENTRY NvRmAGPTeardown(ULONG hClient, ULONG hDevice);
#endif
#ifdef MACOS
ULONG  NV_APIENTRY NvRmOsConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmOsConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmOsConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmOsConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#endif
#endif // #ifndef WINNT
#endif /* NV_ICD_NT */

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvARMApi.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* nvARmApi.h
*
* NVidia resource manager API header file exported to drivers. (as of now, only
* the audio drivers use it.
*
*/

#if !defined _NVARMAPIH_
#define _NVARMAPIH_

#if defined __cplusplus
extern "C" {
#endif //__cplusplus
    
#include <nvos.h>


// exported functions - OS independent to get to the core

// to be called before anything can be done with the RM
NvU32	NVARM_LoadCore(NvU32 *pDeviceHandle);
void	NVARM_UnloadCore(NvU32 uDeviceHandle);

NvU32	NVARM_Alloc(NvU32 uDeviceHandle, NVOS21_PARAMETERS *pIn);
NvU32	NVARM_Free(NvU32 uDeviceHandle, NV_UNIFIED_FREE *pIn);
    
    
#if defined WIN9XVXD		// change this to whatever the macro is
    
// some imports from resman files... wonder why it's not in common

// this structure is exactly the same as NV_IOCTL_ARCH_STRUCT,
// name's changed to prevent redfinition.
typedef struct
{
    NvU32 nvarchFunction;
    NvU32 nvarchParameters;
} NVA_IOCTL_ARCH_STRUCT;
    
#if !defined NVRM_IOCTL_NV_ARCH
#define NVRM_IOCTL_NV_ARCH				21
#endif
    
#define AVxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (service >> 16) & 0xff \
    _asm _emit (service >> 24) & 0xff \
    
NvU32 static __inline
IOCTLCall(NvU32 pDevInfoParam, DIOCPARAMETERS *pParams)
{
    NvU32 dw;
    struct DeviceInfo  *pDevInfo;
    struct VxD_Desc_Block *pDDB;
    
    pDevInfo = (struct DeviceInfo *)pDevInfoParam;
    pDDB = (struct VxD_Desc_Block *)pDevInfo->DI_DDB;
    
    // W32_DEVICEIOCONTROL = 0x23
    _asm mov eax, 0x23
    _asm mov ecx, pDDB
    _asm mov esi, pParams
    AVxDCall(0x00010147);		// Directed_Sys_Control
    _asm mov dw, eax
    return(dw);
}
    
inline NvU32
NVARM_LoadCore(NvU32 *ppDevInfo)
{
    NvU32	dlResult;
    NvU8	*pName = (NvU8*)VXDLDR_NVA_RESMAN_VXD_NAME;
    struct DeviceInfo  *pDevInfo;
    
    _asm	mov	edx, pName
    _asm	mov	eax, 1
    AVxDCall(0x00270001);		// VXDLDR_LoadDevice
    _asm	mov	dlResult, eax
    _asm	jc	LoadDeviceError
    // DDB returned in eax
    _asm	mov	pDevInfo, edx
    
    *ppDevInfo = (NvU32)pDevInfo;
    dlResult = 0;
    
LoadDeviceError:
    return	(dlResult);
}
    
inline VOID
NVARM_UnloadCore(NvU32 pDevInfoParam)
{	
    struct DeviceInfo *pDevInfo;
    
    pDevInfo = (struct DeviceInfo *)pDevInfoParam;
    
    NvU8	*pName = (NvU8 *)pDevInfo->DI_ModuleName;
    NvU32	deviceID = pDevInfo->DI_DeviceID;
    
    _asm	mov	ebx, deviceID
    _asm	mov	edx, pName
    AVxDCall(0x00270002);	// VXDLDR_UnloadDevice
}

inline NvU32
NVARM_Alloc(NvU32 pDevInfo, NVOS21_PARAMETERS *pIn)
{
    DIOCPARAMETERS ioctlParams;
    NVA_IOCTL_ARCH_STRUCT	params;
    
    params.nvarchFunction = NV04_ALLOC;
    params.nvarchParameters = (NvU32)pIn;
    
    ioctlParams.dwIoControlCode = NVRM_IOCTL_NV_ARCH;
    ioctlParams.lpvInBuffer = (NvU32)&params;
    ioctlParams.cbInBuffer = sizeof(NVA_IOCTL_ARCH_STRUCT);
    ioctlParams.lpvOutBuffer = NULL;
    ioctlParams.cbOutBuffer = 0;
    
    return IOCTLCall(pDevInfo, &ioctlParams);
}

inline NvU32
NVARM_Free(NvU32 pDevInfo, NV_UNIFIED_FREE *pIn)
{
    DIOCPARAMETERS ioctlParams;
    NVA_IOCTL_ARCH_STRUCT	params;
    
    params.nvarchFunction = NV04_UNIFIED_FREE;
    params.nvarchParameters = (NvU32)pIn;
    
    ioctlParams.dwIoControlCode = NVRM_IOCTL_NV_ARCH;
    ioctlParams.lpvInBuffer = (NvU32)&params;
    ioctlParams.cbInBuffer = sizeof(NVA_IOCTL_ARCH_STRUCT);
    ioctlParams.lpvOutBuffer = NULL;
    ioctlParams.cbOutBuffer = 0;
    
    return IOCTLCall(pDevInfo, &ioctlParams);
    
}
    
#endif
    
#if defined WDM

// list of imported functions from the resource manager
// the user still needs to link to the .lib

__declspec(dllimport) NvU32 rmAuDispatch(U032 uFunction, PVOID pIn);

inline NvU32
NVARM_LoadCore(NvU32 *ppDevInfo)
{
    // nothing to do really - except maybe load the driver??

    // I was returning '0', but the client thinks '0' is an invalid value
    *ppDevInfo = 0xF;
    return 0;
}

inline VOID
NVARM_UnloadCore(NvU32 pDevInfoParam)
{
    return;
}

inline NvU32
NVARM_Alloc(NvU32 pDevInfo, NVOS21_PARAMETERS *pIn)
{
    return rmAuDispatch(NV04_ALLOC, (VOID *)pIn);
}

inline NvU32
NVARM_Free(NvU32 pDevInfo, NV_UNIFIED_FREE *pIn)
{
    return rmAuDispatch(NV04_UNIFIED_FREE, (VOID *)pIn);
}

#endif		// WDM

#if defined __cplusplus
}
#endif //__cplusplus

#endif // _NVARMAPIH_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\Nvcm.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVCM.H                                                            *
*   Windows Configuration Manager defines and prototypes.                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
*                                                                           *
\***************************************************************************/
#ifndef _NVCM_H_
#define _NVCM_H_

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------
//
//  Configuration Defines.
//
//---------------------------------------------------------------------------
#pragma pack(1) // assure byte alignment on structures shared among modules

//
// Index parameters to ConfigGet/Set.  All other values are reserved.
//

//
// NV_CFG_MANUFACTURER - Return the manufacturer of this device
//
//  0 - NVIDIA Corporation
//  (all other values are reserved)
//
#define NV_CFG_MANUFACTURER                     1

//
// NV_CFG_ARCHITECTURE - Return the architecture of this device
//
//  0 - NV0
//  1 - NV1, etc
//
#define NV_CFG_ARCHITECTURE                     2

//
// NV_CFG_REVISION - Return the major revision of this device
//
//  0 - RevA
//  1 - RevB, etc
//
#define NV_CFG_REVISION                         3

/*
** NV_CFG_BIOS_REVISION - Return the current revision of this device's BIOS
**
**  MMNNRRRR - MM   Major Revision
**             NN   Minor Revision
**             RRRR Release Revision
*/
#define NV_CFG_BIOS_REVISION                    4

//
// NV_CFG_BUS_TYPE - Return the bus implementation of this device
//
//  1 - PCI
//  2 - VL
//  4 - AGP
//  All other values are reserved
//
#define NV_CFG_BUS_TYPE                         5

//
// NV_CFG_CRYSTAL_FREQ - Return the PLL crystal frequency of this device
//
//  Value returned in Hz
//
#define NV_CFG_CRYSTAL_FREQ                     6

//
// NV_CFG_BIOS_OEM_REVISION - Return the current OEM revision of this
//                            device's BIOS
//
#define NV_CFG_BIOS_OEM_REVISION                7

//
// NV_CFG_IMPLEMENTATION - Return the implementation of a chip architecture.
//
#define NV_CFG_IMPLEMENTATION                   8

// When ARCHITECTURE is 0x4, IMPLEMENTATIION is:
#define NV_CFG_IMPLEMENTATION_NV04      0x0
#define NV_CFG_IMPLEMENTATION_NV05      0x1
#define NV_CFG_IMPLEMENTATION_NV0A      0x2
// When ARCHITECTURE is 0x10, IMPLEMENTATIION is:
#define NV_CFG_IMPLEMENTATION_NV10      0x0
#define NV_CFG_IMPLEMENTATION_NV15      0x5
#define NV_CFG_IMPLEMENTATION_NV11      0x1

//
// NV_CFG_ADDRESS_NVADDR - Return the linear address of (BAR0) of this device
//
#define NV_CFG_ADDRESS_NVADDR                   9

//
// NV_CFG_ADDRESS - Return the physical PCI address (BAR0) of this device
//
#define NV_CFG_ADDRESS                          10

//
// NV_CFG_IRQ - Return the PCI IRQ assigned to this device
//
#define NV_CFG_IRQ                              11

//
// NV_CFG_IO_NEEDED - Return the detection flag for chipsets that have broken
//                    PCI snoop mastering.
//
#define NV_CFG_IO_NEEDED                        12

//
// NV_CFG_PCI_ID - Return the PCI Vendor and Device ID assigned to this device
//
//      DDDDVVVV -  VVVV    PCI Vendor ID
//                  DDDD    PCI Device ID
//
#define NV_CFG_PCI_ID                           13

//
// NV_CFG_PCI_SUB_ID - Return the PCI Subsystem Vendor and Device ID assigned to this device
//
//      DDDDVVVV -  VVVV    PCI Subsystem Vendor ID
//                  DDDD    PCI Subsystem ID
//
#define NV_CFG_PCI_SUB_ID                       14

//
// NV_CFG_PROCESSOR_TYPE - Return the functionality of the system processor
//
// There are 2 pieces of data passed back, the processor indicator is in
// the low 8 bits and its bitmask of functionality is in the upper 24
//
#define NV_CPU_UNKNOWN         0x00000000    // Unknown / generic
// Intel
#define NV_CPU_P5              0x00000001
#define NV_CPU_P55             0x00000002    // P55C - MMX
#define NV_CPU_P6              0x00000003    // PPro
#define NV_CPU_P2              0x00000004    // PentiumII
#define NV_CPU_P2XC            0x00000005    // Xeon & Celeron
#define NV_CPU_CELA            0x00000006    // Celeron-A
#define NV_CPU_P3              0x00000007    // Pentium-III
#define NV_CPU_P3_INTL2        0x00000008    // Pentium-III w/ integrated L2 (fullspeed, on die, 256K)
// AMD
#define NV_CPU_K5              0x00000030
#define NV_CPU_K6              0x00000031
#define NV_CPU_K62             0x00000032    // K6-2 w/ 3DNow
#define NV_CPU_K63             0x00000033
#define NV_CPU_K7              0x00000034
// IDT/Centaur
#define NV_CPU_C6              0x00000060    // WinChip C6
#define NV_CPU_C62             0x00000061    // WinChip 2 w/ 3DNow
// Cyrix
#define NV_CPU_GX              0x00000070    // MediaGX
#define NV_CPU_M1              0x00000071    // 6x86
#define NV_CPU_M2              0x00000072    // M2
#define NV_CPU_MGX             0x00000073    // MediaGX w/ MMX
// PowerPC
#define NV_CPU_PPC603          0x00000090    // PowerPC 603
#define NV_CPU_PPC604          0x00000091    // PowerPC 604
#define NV_CPU_PPC750          0x00000092    // PowerPC 750

// Function bits
#define NV_CPU_FUNC_MMX        0x00000100    // supports MMX
#define NV_CPU_FUNC_SSE        0x00000200    // supports SSE
#define NV_CPU_FUNC_3DNOW      0x00000400    // supports 3DNow
#define NV_CPU_FUNC_SSE2       0x00000800    // supports SSE2
#define NV_CPU_FUNC_SFENCE     0x00001000    // supports SFENCE

#define NV_CFG_PROCESSOR_TYPE                   15

//
// NV_CFG_PROCESSOR_SPEED - Return the speed of the processor in MHz
//
#define NV_CFG_PROCESSOR_SPEED                  16

//
// NV_CFG_GRAPHICS_CAPS - Return the capabilities of the graphics HW
//
#define NV_CFG_GRAPHICS_CAPS                    18

#define NV_CFG_GRAPHICS_CAPS_UNKNOWN            0x00000000
#define NV_CFG_GRAPHICS_CAPS_MAXCLIPS_MASK      0x000000FF  // bits 7:0
#define NV_CFG_GRAPHICS_CAPS_MAXCLIPS_SHIFT     0
#define NV_CFG_GRAPHICS_CAPS_AA_LINES           0x00000100  // bit  8
#define NV_CFG_GRAPHICS_CAPS_AA_POLYS           0x00000200  // bit  9
#define NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP     0x00000400  // bit 10
#define NV_CFG_GRAPHICS_CAPS_LOGIC_OPS          0x00000800  // bit 11
#define NV_CFG_GRAPHICS_CAPS_NV15_ALINES        0x00001000  // bit 12
#define NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING    0x00002000  // bit 13
#define NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC     0x00004000  // bit 14

//
// NV_CFG_INSTANCE_SIZE - Return the size of the instance pool of this device
//
#define NV_CFG_INSTANCE_SIZE                    20

//
// NV_CFG_INSTANCE_SIZE - Return the size of the instance pool of this device
//
#define NV_CFG_INSTANCE_TOTAL                   21

//
// NV_CFG_FIFO_COUNT - Return the number of user fifos allowed in this device
//
#define NV_CFG_FIFO_COUNT                       32

//
// NV_CFG_FIFO_USE_COUNT - Return the number of fifos used in this device
//
#define NV_CFG_FIFO_USE_COUNT                   33

//
// NV_CFG_RAM_SIZE_MB - Return the video memory size (in MB) of this device
//
#define NV_CFG_RAM_SIZE_MB                      40

//
// NV_CFG_RAM_SIZE - Return the video memory size (in bytes) of this device
//
#define NV_CFG_RAM_SIZE                         41

//
// NV_CFG_RAM_TYPE - Return the video memory type of this device
//
//  0 - DRAM (EDO/FPM)
//  1 - SGRAM
//  2 - SDRAM
//  3 - DDR-RAM
//  All other values are reserved
//
#define NV_CFG_RAM_TYPE                         42

#define NV_CFG_RAM_TYPE_DRAM          0
#define NV_CFG_RAM_TYPE_SGRAM         1
#define NV_CFG_RAM_TYPE_SDRAM         2
#define NV_CFG_RAM_TYPE_DDRRAM        3


//
// NV_CFG_AGP_FULLSPEED_FW - Return if AGP Fast Writes are fullspeed
//
#define NV_CFG_AGP_FULLSPEED_FW                 43

//
// NV_CFG_AGP_PHYS_BASE - Return/Set the current physical GART address
//
#define NV_CFG_AGP_PHYS_BASE                    44

//
// NV_CFG_AGP_LINEAR_BASE - Return/Set the current linear GART address
//
#define NV_CFG_AGP_LINEAR_BASE                  45

//
// NV_CFG_AGP_LIMIT - Return/Set the current GART size
//
#define NV_CFG_AGP_LIMIT                        46

//
// NV_CFG_AGP_FW_ENABLE - Return if AGP Fast Writes are enabled
//
#define NV_CFG_AGP_FW_ENABLE                    47

//
// NV_CFG_AGP_HEAP_FREE - Return the amount of free AGP memory
//
#define NV_CFG_AGP_HEAP_FREE                    48

// XXX this isn't be used
#define NV_CFG_AGP_LOAD_DUMMY_PAGES             49

//
// NV_CFG_SCREEN_WIDTH - Return/Set the current display horizontal resolution
//
//  Value defined in pixels
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_SCREEN_WIDTH                     50

//
// NV_CFG_SCREEN_HEIGHT - Return/Set the current display vertical resolution
//
//  Value defined in pixels
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_SCREEN_HEIGHT                    51

//
// NV_CFG_PIXEL_DEPTH - Return/Set the current display pixel depth
//
//  Value defined in bits per pixel
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_PIXEL_DEPTH                      52

//
// NV_CFG_SCREEN_MAX_WIDTH - Returns the maximum horizontal resolution supported by the display type.
//
//  Value defined in pixels
//
#define NV_CFG_SCREEN_MAX_WIDTH                 53

//
// NV_CFG_SCREEN_MAX_HEIGHT - Returns the maximum vertical resolution supported by the display type.
//
//  Value defined in pixels
//
#define NV_CFG_SCREEN_MAX_HEIGHT                54

//
// NV_CFG_VIDEO_ENCODER_TYPE - Return the external video decoder being used by this device
//
#define NV_CFG_VIDEO_ENCODER_TYPE               55

#define TV_ENCODER_NONE                 0x000
#define TV_ENCODER_BROOKTREE            0x100
#define TV_ENCODER_CHRONTEL             0x200
#define TV_ENCODER_PHILIPS              0x400

#define TV_ENCODER_FAMILY( X )          (X & ~0xFF)

#define NV_ENCODER_NONE                 TV_ENCODER_NONE

#define NV_ENCODER_BROOKTREE_868        (TV_ENCODER_BROOKTREE + 1)
#define NV_ENCODER_BROOKTREE_869        (TV_ENCODER_BROOKTREE + 2)
#define NV_ENCODER_BROOKTREE_871        (TV_ENCODER_BROOKTREE + 3)

#define NV_ENCODER_CHRONTEL_7003        (TV_ENCODER_CHRONTEL + 3)
#define NV_ENCODER_CHRONTEL_7004        (TV_ENCODER_CHRONTEL + 4)
#define NV_ENCODER_CHRONTEL_7005        (TV_ENCODER_CHRONTEL + 5)
#define NV_ENCODER_CHRONTEL_7006        (TV_ENCODER_CHRONTEL + 6)
#define NV_ENCODER_CHRONTEL_7007        (TV_ENCODER_CHRONTEL + 7)
#define NV_ENCODER_CHRONTEL_7008        (TV_ENCODER_CHRONTEL + 8)

#define NV_ENCODER_PHILIPS_7102	        (TV_ENCODER_PHILIPS + 2)
#define NV_ENCODER_PHILIPS_7103	        (TV_ENCODER_PHILIPS + 3)
#define NV_ENCODER_PHILIPS_7108	        (TV_ENCODER_PHILIPS + 8)    // = 7102 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7109	        (TV_ENCODER_PHILIPS + 9)    // = 7103 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7108B        (TV_ENCODER_PHILIPS + 8 + 0x10)    // early version of 7108 with clock active edge reversed
//
// NV_CFG_PRIMARY_SURFACE_PITCH - Return the display pitch of the primary surface
//
//  Value defined in bytes
//
#define NV_CFG_PRIMARY_SURFACE_PITCH            56

//
// NV_CFG_VIDEO_ENCODER_ID - Return the encoder ID (I2C address)
//
#define NV_CFG_VIDEO_ENCODER_ID                 57

//
// NV_CFG_NUMBER_OF_HEADS - Return the number of CRTC heads on this device
//
#define NV_CFG_NUMBER_OF_HEADS                  58

//
// NV_CFG_DEVICE_INSTANCE - Return the device instance
//
#define NV_CFG_DEVICE_INSTANCE                  59

//
// NV_CFG_NUMBER_OF_ACTIVE_HEADS - Return number of active CRTC heads on this device
//
#define NV_CFG_NUMBER_OF_ACTIVE_HEADS           60

//
// NV_CFG_INITIAL_BOOT_HEAD - Return the dac head that was used to boot the system
//
//  0 - HeadA
//  1 - HeadB
//  All other values are reserved
//
#define NV_CFG_INITIAL_BOOT_HEAD                61

//
// NV_CFG_VIDEO_DISPLAY_TYPE - Return the physical display being used by this device
//
//  0 - Monitor
//  1 - TV
//  2 - Dual Surface
//  3 - Flat Panel
//  All other values are reserved
//
#define NV_CFG_VIDEO_DISPLAY_TYPE               78

//
// NV_CFG_VIDEO_MONITOR_TYPE - Return the monitor format type being used by this device
//
//  0 - VGA
//  2 - NTSC TV
//  3 - PAL TV
//  4 - Flat Panel
//  All other values are reserved
//
#define NV_CFG_VIDEO_MONITOR_TYPE               79

#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

//
// NV_CFG_VIDEO_OVERLAY_ALLOWED - Return the video overlay validity in the current
//      desktop resolution
//
//  0 - Video Overlay not allowed
//  1 - Video Overlay is allowed
//  All other values are reserved
//
#define NV_CFG_VIDEO_OVERLAY_ALLOWED            80

//
// NV_CFG_VIDEO_DOWNSCALE_RATIO_X - Return the maximum video overlay downscale ratio
// supported for the given source width in the current desktop resolution
// (assuming the overlay is supported at all -- see above)
//
//  1  - Video Downscaling not supported with this source width
//  2  - Maximum 2X downscaling supported
//  4  - Maximum 4X downscaling supported
//  8  - Maximum 8X downscaling supported
//  16 - Maximum 16X downscaling supported
//  (and so on)
//
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_768        82
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_1280       83
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_1920       84

//
// NV_CFG_FRAMEBUFFER_UNDERSCAN - Return/Set the NV3 (RIVA128) TV Underscan resolution
//
#define NV_CFG_FRAMEBUFFER_UNDERSCAN_X          85
#define NV_CFG_FRAMEBUFFER_UNDERSCAN_Y          86

//
// NV_CFG_VIDEO_OUTPUT_FORMAT - Return/Set the NV4/5/10 TV output format (S-Video, Composite, or Auto)
//
//  0 = Auto
//  1 = Composite
//  2 = S-Video 
//
#define NV_CFG_VIDEO_OUTPUT_FORMAT              90

#define NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT          0x0
#define NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE     0x1
#define NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO        0x2

//
// NV_CFG_VIDEO_TV_FORMAT - Return the current TV format
//
#define NV_CFG_VIDEO_TV_FORMAT                  109
// must be one of the following formats
#define NTSC_M  0
#define NTSC_J  1
#define PAL_M   2
#define PAL_A   3   // PAL B, D, G, H, I
#define PAL_N   4
#define PAL_NC  5
#define KNOWN_TV_FORMATS 5 // number of formats we know about + 1

//
// NV_CFG_DAC_INPUT_WIDTH - Return the width (in bits) of the current framebuffer bus
//
#define NV_CFG_DAC_INPUT_WIDTH                  110

//
// NV_CFG_DAC_VPLL_*
// NV_CFG_DAC_MPLL_* - Return the individual components of the memory and video PLL's
//
//  The definition of these values is reserved
//
#define NV_CFG_DAC_VPLL_M                       120
#define NV_CFG_DAC_VPLL_N                       121
#define NV_CFG_DAC_VPLL_O                       122
#define NV_CFG_DAC_VPLL_P                       123
#define NV_CFG_DAC_MPLL_M                       130
#define NV_CFG_DAC_MPLL_N                       131
#define NV_CFG_DAC_MPLL_O                       132
#define NV_CFG_DAC_MPLL_P                       133

//
// NV_CFG_BIOS_DEFAULT_TV_TYPE - The TV standard the BIOS uses by default.
//
//  The allowed values are defined as the values for NV_CFG_VIDEO_TV_FORMAT
//
#define NV_CFG_BIOS_DEFAULT_TV_TYPE             134

//
// NV_CFG_INTERRUPTS_ENABLED_STATE - Return / set NV interrupts enable
//
//  Return value of "get" form is 0 or 1.
//  When enabling interrupts, restores them to RM's idea of the current value
//
#define NV_CFG_INTERRUPTS_ENABLED_STATE         140

//
// NV_CFG_VIDEO_REFRESH_RATE - Return/Set the current display refresh rate (in Hz)
//
#define NV_CFG_VIDEO_REFRESH_RATE               170

//
// NV_CFG_VBLANK_TOGGLE - Return/Set the current value of the vertical sync toggle
//
//  This value is toggled to zero (0) during every vertical sync.  By setting it to
//  any other value and then monitoring, a client can detect the presence of a
//  vertical sync signal occuring within a defined time period.
//
#define NV_CFG_VBLANK_TOGGLE                    212

//
// NV_CFG_VBLANK_COUNTER - Return/Set the number of vertical blanks 
//
//  This value is initialized to zero and keeps a running count of the number of
//  vertical blanks since the last reset. Use ConfigSet to reset it to zero.
//
#define NV_CFG_VBLANK_COUNTER                   213

//
// NV_CFG_PRAM_CURRENT_SIZE - Return the currently allocated size of chip
//
#define NV_CFG_PRAM_CURRENT_SIZE                220

//
// NV_CFG_GET_ALL_DEVICES - Return all available display devices (connectors)
//  in bitmask form.
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
#define NV_CFG_GET_ALL_DEVICES                  221

//Same format as NV_CFG_GET_ALL_DEVICES
#define NV_CFG_GET_BOOT_DEVICES                 222

//
// NV_CFG_DAC_PIXEL_CLOCK - Return the current video pixel clock (in Hz) for this device
//
#define NV_CFG_DAC_PIXEL_CLOCK                  250

//                                                              
// NV_CFG_DAC_MEMORY_CLOCK - Return the current memory clock (in Hz) for this device
//
#define NV_CFG_DAC_MEMORY_CLOCK                 251

//
// NV_CFG_DAC_GRAPHICS_CLOCK - Return the current graphics clock (in Hz) for this device
//
#define NV_CFG_DAC_GRAPHICS_CLOCK               253

//
// NV_CFG_DAC_PCLK_LIMIT_8BPP - Return the current 8bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_8BPP              260

//
// NV_CFG_DAC_PCLK_LIMIT_16BPP - Return the current 16bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_16BPP             261

//
// NV_CFG_DAC_PCLK_LIMIT_32BPP - Return the current 16bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_32BPP             262

//
// NV_CFG_MAPPING_BUSDEVICEFUNC - Return the device type for use by the display driver configmgr code
//
//  This value is the device type or'd with the busdevicefunc info (9X specific)
//
#define NV_CFG_MAPPING_BUSDEVICEFUNC            263
              
//
// NV_CFG_VBLANK_STATUS - Return the current vertical blank status of this device
//
//  0 - device is not currently in vertical blank
//  1 - device is currently in vertical blank
//
#define NV_CFG_VBLANK_STATUS                    500

//
// NV_CFG_GE_STATUS - Return the current graphics activity state of this device
//
//  any value other than zero (0) denotes graphics activity is in progress
//
#define NV_CFG_GE_STATUS                        501

//
// NV_CFG_CURRENT_SCANLINE - Return the current active display scanline of this device
//
//  The value returned may be greater than the current resolution if the display
//  has moved into the vertical blanking period.
//
#define NV_CFG_CURRENT_SCANLINE                 502

//
// NV_CFG_FRAMECAPTURE_CALLBACK - Set the current 16bit callback (VFW) for framecapture
//
//  The value is specifically OS-dependent.  This setting may only be used with ConfigSet
//  and only on those operating systems requiring the callback mechanism.
//
#define NV_CFG_FRAMECAPTURE_CALLBACK            600

// Get the device handle for the device.
// Currently only defined for unix where it returns file descriptor
// for the opened device.  Needed for poll(2) on events

#define NV_CFG_DEVICE_HANDLE                    650

//
// NV_CFG_CRTC_* - Return/Set a CRTC (VGA) register in this device
//
//  All CRTC registers are accessed by adding the index the base value 
//  given here.
//  For example, CR1B is accessed using index (NV_CFG_CRTC+0x1B)
//
#define NV_CFG_CRTC                             768
//
// NOTE: CRTC RESERVED TO INDEX 832
//

//
// The following values are reserved for use by the resource manager 
// performance and debug tools
//
#define NV_CFG_SET_JUMP_WRITE_PUT_READ_GET      833
#define NV_STAT_INTERVAL_NSEC_LO                1000
#define NV_STAT_INTERVAL_NSEC_HI                1001
#define NV_STAT_FIFO_EXCEPTIONS                 1003
#define NV_STAT_FRAMEBUFFER_EXCEPTIONS          1004
#define NV_STAT_GRAPHICS_EXCEPTIONS             1005
#define NV_STAT_TIMER_EXCEPTIONS                1006
#define NV_STAT_CHIP_EXCEPTIONS                 1050
#define NV_STAT_MEM_ALLOCATED                   1100
#define NV_STAT_MEM_LOCKED                      1101
#define NV_STAT_EXEC_NSEC_LO                    1200
#define NV_STAT_EXEC_NSEC_HI                    1201
#define NV_STAT_INT_NSEC_LO                     1202
#define NV_STAT_INT_NSEC_HI                     1203

#define NV_CFG_REGISTRY_STRING                  1300

#define NV_CFG_DEBUG_LEVEL                      1350


//////////////////////////////////////////////////////////////////////////////
//
// The following Config equates are a 16bit subset of the corresponding 
// ConfigEX values
//
// Where possible, make sure to use the 32bit versions of these DDK interfaces
// rather than these legacy equates
//

//
// NV_CFG_GET_FLAT_PANEL_CONNECT_16 - Return the connection status of a 
// digital flat panel
// 
#define NV_CFG_FLAT_PANEL_CONNECT_16            30100

//
// NV_CFG_GET_FLAT_PANEL_CONFIG_16 - Return or update the current format 
// configuration of the active digital flat panel
//
//  0 - scaled
//  1 - centered
//  2 - native
// 
#define NV_CFG_FLAT_PANEL_CONFIG_16             30102

//
// NV_CFG_STEREO_CONFIG - Stereo support Config Parameters
//
//  The subcodes within this entry are NV reserved
//
#ifdef  STEREO_SUPPORT
#define NV_CFG_STEREO_CONFIG                    40000
#endif  //STEREO_SUPPORT

//
// Parameter to ConfigUpdate.
//
#define NV_CFG_PERMANENT                        1
#define NV_CFG_TEMPORARY                        2


////////////////////////////////////////////////////////////////////
//
// The following Config equates are to be used with the ConfigGetEx()
// and ConfigSetEx() functions.  Rather than just taking a DWORD
// data value, they allow the use of a per-function data structure
// to be used as a parameter block.  
//
// Be careful to only use these equates with the appropriate
// functions.
//

//
// NV_CFGEX_GET_DESKTOP_POSITION_MONITOR - Return the monitor alignment
//
#define NV_CFGEX_GET_DESKTOP_POSITION_MONITOR              100
// Param Structure
typedef struct {
    unsigned long  GetDefault;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS;

//
// NV_CFGEX_SET_DESKTOP_POSITION_MONITOR - Set the new monitor alignment
//
#define NV_CFGEX_SET_DESKTOP_POSITION_MONITOR               101
// Param Structure
typedef struct {
    unsigned long  CommitChanges;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS;

/************** Desktop position for TV ***********/
#define NV_CFGEX_GET_DESKTOP_POSITION_TV                    102
#define NV_CFGEX_COMMIT_DESKTOP_POSITION_TV                 103

typedef struct {
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
    unsigned char  reg0x80;
    unsigned char  reg0x82;
    unsigned char  reg0x92;
    unsigned char  reg0x98;
    unsigned char  reg0x9A;
    unsigned char  reg0xC8;
    unsigned char  reg0xCA;
    unsigned char  reg0xCC;
} PARAMS_BROOKTREE;

// Register values for flicker filter. Chroma FF is 5:3, Lum FF is 2:0. Control Panel has 4 settings, other values result in OFF.
#define BT_FLICKER_HI   0    // Max FF
#define BT_FLICKER_MED  0x12
#define BT_FLICKER_LO   0x09
#define BT_FLICKER_OFF  0x1b // Place holder in CP.
#define BT_FLICKER_DEF  BT_FLICKER_MED // RM default
// Register values for Luma (Brightness)
#define BT_LUMA_MAX     0xC0  // No attenuation
#define BT_LUMA_DEF     0xC3  // RM default  
#define BT871_LUMA_DEF  0xC4  // RM default  
#define BT_LUMA_MIN     0xC7
// Register values for Chroma (Saturation)
#define BT_CHROMA_MAX   0xC0
#define BT_CHROMA_DEF   0xC2  // RM default
#define BT871_CHROMA_DEF 0xC1  // RM default
#define BT_CHROMA_MIN   0xC7

typedef struct {
    unsigned char  reg0x01; // Flicker Filter
    unsigned char  reg0x08; // overflow bits for V & H position
    unsigned char  reg0x0A; // Horizontal Position
    unsigned char  reg0x0B; // Vertical Position
    unsigned char  reg0x09; // Black Level (Brightness)
    unsigned char  reg0x11; // Contrast
} PARAMS_CHRONTEL;

// The way H2INC groks this exposes an internal error in ML 6.13
#ifndef H2INC
// Param Structure
typedef struct {
    unsigned long  Encoder_ID;  // NV_ENCODER_ type
    unsigned char  Default;     // get default setting if set, else get current
    union {
        PARAMS_BROOKTREE regsBt;
        PARAMS_CHRONTEL  regsCh;
    } u;     // NOTE: some compilers (eg: gcc) does not allow for anonymous sructs
} NV_CFGEX_DESKTOP_POSITION_TV_PARAMS;
#endif  // H2INC

/************** TV Encoder ***********************************/
#define NV_CFGEX_GET_TV_ENCODER_INFO                        104
// Param Structure
// EncoderType:
//      0 - None
//      1 - Chrontel 7003
//      2 - Brooktree 868
//      3 - Brooktree 869
//      All other values are reserved
// TVConnected:
//      0 - Not connected
//      1 - Connected
// EncoderID: I2C address of encoder
typedef struct {
    unsigned long  EncoderType;
    unsigned long  EncoderID;
    unsigned long  TVConnected;
} NV_CFGEX_TV_ENCODER_PARAMS;
#define TV_NOT_CONNECTED    0
#define TV_CONNECTED        1

#define NV_CFGEX_SET_TV_ENCODER_INFO                        105

/************** Flat Panel ***********************************/
#define NV_CFGEX_GET_FLAT_PANEL_INFO                        106
// Param structure
// FlatPanelMode:
//     0 - Not Connected
//     1 - Centered
//     2 - Native
//     3 - Scaled mode
// FlatPanelSizeX:
//     Max horizontal resolution.
// FlatPanelSizeY:
//     Max vertical resolution.
// FlatPanelNativeSupported
typedef struct {
    unsigned long FlatPanelMode;
    unsigned long FlatPanelSizeX;
    unsigned long FlatPanelSizeY;
    long          FlatPanelConnected;
    long          FlatPanelNativeSupported;
} NV_CFGEX_GET_FLATPANEL_INFO_PARAMS;
#define NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED   0
#define NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED       1
#define NV_CFGEX_GET_FLATPANEL_INFO_SCALED          0
#define NV_CFGEX_GET_FLATPANEL_INFO_CENTERED        1
#define NV_CFGEX_GET_FLATPANEL_INFO_NATIVE          2


#define NV_CFGEX_SET_FLAT_PANEL_INFO                        107
// Param structure
typedef struct {
    unsigned long CommitChanges;
    unsigned long FlatPanelMode;
} NV_CFGEX_SET_FLATPANEL_INFO_PARAMS;

/************** Monitor **************************************/
#define NV_CFGEX_GET_MONITOR_INFO                           108
// Param structure
// MonitorConnected:
//      0 - Not Connected
//      1 - Connected
typedef struct {
    unsigned long MonitorConnected;
} NV_CFGEX_GET_MONITOR_INFO_PARAMS;

#define NV_CFGEX_GET_MONITOR_INFO_NOT_CONNECTED                0
#define NV_CFGEX_GET_MONITOR_INFO_CONNECTED                    1

/************** Get the current Windows refresh rate and state (real, default or optimal) **************/
#define NV_CFGEX_GET_REFRESH_INFO             111
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long ulRefreshRate;
    unsigned long ulState;
} NV_CFGEX_GET_REFRESH_INFO_PARAMS;

// definitions of state flags
#define NV_CFG_REFRESH_FLAG_SPECIFIC          0x00000000 /* use specific value contained in ulRefreshRate */
#define NV_CFG_REFRESH_FLAG_ADAPTER_DEFAULT   0x00000001 /* Windows is using "Adapter Default" setting    */
#define NV_CFG_REFRESH_FLAG_OPTIMAL           0x00000002 /* Windows is using "Optimal" setting            */

/************** Multihead CFGEX_SET **************/

#define NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI        112
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  CommitChanges;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS;

#define NV_CFGEX_SET_FLAT_PANEL_INFO_MULTI                  113
// Param structure
typedef struct {
    unsigned long Head;
    unsigned long CommitChanges;
    unsigned long FlatPanelMode;
} NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS;

// The way H2INC groks this exposes an internal error in ML 6.13
#ifndef H2INC
#define NV_CFGEX_COMMIT_DESKTOP_POSITION_TV_MULTI           114
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  Encoder_ID;  // NV_ENCODER_ type
    unsigned char  Default;     // get default setting if set, else get current
    union {
        PARAMS_BROOKTREE regsBt;
        PARAMS_CHRONTEL  regsCh;
    } u;     // NOTE: some compilers (eg: gcc) does not allow for anonymous sructs
} NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS;

#define NV_CFGEX_GET_DESKTOP_POSITION_TV_MULTI              115

#define NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI         116
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  GetDefault;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS;
#endif

/************** Get the offset within the AGP aperture (can't just subtract from linearbase anymore) ***/
#define NV_CFGEX_GET_AGP_OFFSET                 138
// Param Structure
typedef struct {
    void* linaddr;                      // passed in linear address, returned from a AGP space alloc
    void* physaddr;                     // returned physical address
    unsigned long offset;               // returned offset within the AGP aperture
} NV_CFGEX_GET_AGP_OFFSET_PARAMS;

/************** Return/Set the current linear GART address (64 bit clean version of NV_CFG_AGP_LINEAR_BASE above) ***/
#define NV_CFGEX_AGP_LINEAR_BASE                139
// Param Structure
typedef struct {
    void* linaddr;                      // passed in/returned linear address
} NV_CFGEX_AGP_LINEAR_BASE_PARAMS;

/************** Get the Display Type **************/
#define NV_CFGEX_GET_DISPLAY_TYPE               140
// Param Structure
typedef struct {
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_GET_DISPLAY_TYPE_PARAMS;

// definitions of Display Types
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3
// definitions of TV types: see NV_CFG_VIDEO_TV_FORMAT

/************** Set the Display Type **************/
#define NV_CFGEX_SET_DISPLAY_TYPE               141
// Param Structure
typedef struct {
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_SET_DISPLAY_TYPE_PARAMS;


/************** Get the Display Type for Specified Head **************/
#define NV_CFGEX_GET_DISPLAY_TYPE_MULTI         142
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS;

/************** Get the Display Type of the Specified Head **************/
#define NV_CFGEX_SET_DISPLAY_TYPE_MULTI         143
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS;

/************** Get the Raster Postion for the Specified Head ***********/
#define NV_CFGEX_CURRENT_SCANLINE_MULTI         144
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long RasterPosition;
} NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS;

/************** CRTC Timing ***********/
#define NV_CFGEX_CRTC_TIMING_MULTI              145
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  Reg;                     // data location, see below
    unsigned long  HTotal;
    unsigned long  HDisplayEnd;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VTotal;
    unsigned long  VDisplayEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_CRTC_TIMING_PARAMS;
#define NV_CFGEX_CRTC_PARAMS    14          // number of 32 bit values (HTotal - VRetraceEnd) 
#define NV_CFGEX_CRTC_TIMING_REGISTER 1     // get/set CRTC registers
#define NV_CFGEX_CRTC_TIMING_REGISTRY 2     // get/set Windows registry
#define NV_CFGEX_CRTC_TIMING_DEFAULT  4     // get default registers (set not valid)

/** Return the linear address of (BAR0) of this device (64 bit clean version) */
#define NV_CFGEX_ADDRESS_NVADDR                 146
// Param Structure
typedef struct {
    void* nvaddr;
} NV_CFGEX_ADDRESS_NVADDR_PARAMS;

/************** RESERVED **************/
#define NV_CFGEX_RESERVED                       150

/************** Enable tiling ********************************/
#define NV_CFGEX_ENABLE_TETRIS_TILING                       200

/************** Disable tiling *******************************/
#define NV_CFGEX_DISABLE_TETRIS_TILING                      201

/************** Get the monitor EDID *************************/
#define NV_CFGEX_GET_EDID                                   210
// param structure
typedef struct {
    unsigned long displayType;  // see NV_CFGEX_GET_DISPLAY_TYPE for legal values
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_EDID_PARAMS;

/************** Get the current device BIOS ******************/
#define NV_CFGEX_GET_BIOS                                   215
// param structure
typedef struct {
    unsigned char *biosBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_BIOS_PARAMS;

//
//  New versions of ConfigGetEx for multi-head devices
//

//
// NV_CFG_DAC_PCLK_LIMIT_8BPP - Return the current 8bpp graphics clock limit (in Hz) for specified head on this device 
//
#define NV_CFGEX_DAC_PCLK_LIMIT_8BPP            264
typedef struct {
    unsigned long Head;
    unsigned long pclkLimit;
} NV_CFGEX_DAC_PCLK_LIMIT_PARAMS;

//
// NV_CFG_DAC_PCLK_LIMIT_16BPP - Return the current 16bpp graphics clock limit (in Hz) for specified head on this device
//
#define NV_CFGEX_DAC_PCLK_LIMIT_16BPP           265

//
// NV_CFG_DAC_PCLK_LIMIT_32BPP - Return the current 16bpp graphics clock limit (in Hz) for specified head onthis device
//
#define NV_CFGEX_DAC_PCLK_LIMIT_32BPP           266

//
// NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST - Return the pre-dac NV11 color saturation boost value
//
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST  268
typedef struct {
    unsigned long Head;
    unsigned char boostValue;
} NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS;

#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_0          0x00000000
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_188        0x00000001
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_375        0x00000002
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750        0x00000003

// Another get info for a specified head
#define NV_CFGEX_GET_TV_ENCODER_INFO_MULTI      270
typedef struct {
    unsigned long  Head;
    unsigned long  EncoderType;
    unsigned long  EncoderID;
    unsigned long  TVConnected;
} NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS;

// Another get info for a specified head
#define NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI       271
// Param structure
// FlatPanelMode:
//     0 - Not Connected
//     1 - Centered
//     2 - Native
//     3 - Scaled mode
// FlatPanelSizeX:
//     Max horizontal resolution.
// FlatPanelSizeY:
//     Max vertical resolution.
// FlatPanelNativeSupported
typedef struct {
    unsigned long Head;
    unsigned long FlatPanelMode;
    unsigned long FlatPanelSizeX;
    unsigned long FlatPanelSizeY;
    long          FlatPanelConnected;
    long          FlatPanelNativeSupported;
} NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS;

// Return TV encoder type on specified head
#define NV_CFGEX_VIDEO_ENCODER_TYPE             272
typedef struct {
    unsigned long Head;
    unsigned long EncoderType;
} NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS;

// Return TV encoder ID on specified head
#define NV_CFGEX_VIDEO_ENCODER_ID               273
typedef struct {
    unsigned long Head;
    unsigned long EncoderID;
} NV_CFGEX_VIDEO_ENCODER_ID_PARAMS;

#define NV_CFGEX_GET_EDID_MULTI                 274
// param structure
typedef struct {
    unsigned long Head;
    unsigned long displayType;  // see NV_CFGEX_GET_DISPLAY_TYPE for legal values
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_EDID_MULTI_PARAMS;

#define NV_CFGEX_GET_MONITOR_INFO_MULTI         275
// Param structure
// MonitorConnected:
//      0 - Not Connected
//      1 - Connected
typedef struct {
    unsigned long Head;
    unsigned long MonitorConnected;
} NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS;

#define NV_CFGEX_SYNC_STATE                     276
// Param structure
//     set/get the state of HSYNC and VSYNC
typedef struct {
    unsigned long Head;
    unsigned long Hsync;              // non-zero to enable
    unsigned long Vsync;              // non-zero to enable
    unsigned long oldHsync;           // on SETEX, what was previous value
    unsigned long oldVsync;           // ""
} NV_CFGEX_SYNC_STATE_PARAMS;

#define NV_CFGEX_PRIMARY_INFO                    277
// Param structure
//     get the state of the primary surface for the given head
typedef struct {
    unsigned long Head;               // input param; 0 or 1
    unsigned long Pitch;              // output
    unsigned long Offset;             // output; byte offset from beginning of FB
} NV_CFGEX_PRIMARY_INFO_PARAMS;

#define NV_CFGEX_FLAT_PANEL_BRIGHTNESS		278
//param structure
//   -this structure is used for setting and getting the settings of the PWM brightness output.
//   -when the getex command is called for this structure, the only two valid values on return will
//    be PWMControllerEnable and PercentRelativeBrightness. 
typedef struct
{
	unsigned long Head;
    unsigned long FlatPanelBrightnessControlFrequency;
    unsigned long PercentMaximumPWMDutyCycle;
    unsigned long PercentMinimumPWMDutyCycle;
    unsigned long PercentRelativeBrightness;
    signed long PWMControllerEnable;
} NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS;

/************** Return Pitch given Width/Depth ***************/
#define NV_CFGEX_GET_SURFACE_PITCH                          300
// Param structure
typedef struct {
    unsigned long Width;          // in (pixels)
    unsigned long Depth;          // in (bits per pixel)
    unsigned long Pitch;          // out
} NV_CFGEX_GET_SURFACE_PITCH_PARAMS;

/************** Return Pitch/Size given Width/Height/Depth ***/
#define NV_CFGEX_GET_SURFACE_DIMENSIONS                     301
// Param structure
typedef struct {
    unsigned long Width;          // in (pixels)
    unsigned long Height;         // in (pixels)
    unsigned long Depth;          // in (bits per pixel)
    unsigned long Pitch;          // out
    unsigned long Size;           // out
} NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS;

/************** Return Supported Classes for a given NV chip */
#define NV_CFGEX_GET_SUPPORTED_CLASSES                      310
//
// Pass in a NULL classBuffer pointer to have the RM fill in the numClasses field.
// This is the number of dword entries that should be allocated by the caller for
// the classBuffer.
//
// Then, make this call again with the filled in classBuffer and the RM will verify
// the numClasses is large enough and fill in classBuffer with the supported class
// numbers.
//
// Param structure
typedef struct {
    unsigned long  numClasses;    // number of supported classes
    unsigned long *classBuffer;   // dword buffer holding supported class values
} NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS;

/************** Return RM mappings to device's regs/fb *******/
#define NV_CFGEX_GET_DEVICE_MAPPINGS                        311
//
// This call is used by NVDE debugger to retrieve the RM's
// (linear) mappings to a given device's registers and framebuffer.
//
// Param structure
typedef struct {
    void *nvVirtAddr;               // register virtual address
    void *nvPhysAddr;               // register physical address
    void *fbVirtAddr;               // fb virtual address
    void *fbPhysAddr;               // fb physical address
} NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS;

/************** Set Macrovision Mode *************************/
#define NV_CFGEX_SET_MACROVISION_MODE                       320 
typedef struct {
    unsigned long   head;
    unsigned long   mode;
    unsigned long   resx;
    unsigned long   resy;
    unsigned long   status;
} NV_CFGEX_SET_MACROVISION_MODE_PARAMS;

//
// NV_CFGEX_CHECK_CONNECTED_DEVICES - Return connect status of the specified
//  devices.
// Input: a bitmask that is a subset of the bitmask returned by the
//          NV_CFG_GET_ALL_DEVICES call.  set bits indicate the calling routine
//          want to check the connect status of the corresponding devices.
// Output: set bits in the bitmask indicating the corresponding devices are
//          connected.
//
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
#define NV_CFGEX_CHECK_CONNECTED_DEVICES        321

//
// NV_CFGEX_GET_DEVICES_CONFIGURATION - Return possible configuration for the
//  specified devices.  Pass in OldDevicesConfig and OldDevicesAllocationMap
//  if you want the routine to try to keep existing attached devices on the
//  same heads whenever possible.  Pass in zero for OldDevicesConfig otherwise.
//  
// Input: DevicesConfig - a bitmask that is a subset of the bitmask returned
//              by the NV_CFGEX_CHECK_CONNECTED_DEVICES call. set bits indicate
//              devices to be in the configuration. up to eight bits can be set.
//        OldDevicesConfig - DevicesConfig used from the last call to
//              NV_CFGEX_GET_DEVICES_CONFIGURATION.
//        OldDevicesAllocationMap - DevicesAllocationMap returned by the last
//              call to NV_CFGEX_GET_DEVICES_CONFIGURATION.
// Output: DevicesAllocationMap - a 32-bit value in the following format:
//          nibble0 - head that can be used to connect to device0 (device
//                      corresponds to the rightmost set bit.
//          nibble1 - head that can be used to connect to device1 (device
//                      corresponds to the second rightmost set bit.
//          .
//          .
//
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
typedef struct {
    unsigned long  DevicesConfig;
    unsigned long  DevicesAllocationMap;
    unsigned long  OldDevicesConfig;
    unsigned long  OldDevicesAllocationMap;
} NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS;
#define NV_CFGEX_GET_DEVICES_CONFIGURATION      322

// NV_CFGEX_GET_HOTKEY_EVENT - Report Fn+x hotkey events on a mobile system.
//  Some events are informational -- the BIOS has already acted on the event.
//  Other events indicate an action that must be taken care of by the driver.
//  Currently, only the display enable/disable events fall into this category.
//
// The RM checks the BIOS for new events every vblank.  Note that more than one
//  event may be added to the queue at a time (e.g., display enable/disable events
//  will often occur in sets).  The caller should continue to poll until the
//  call returns NV_HOTKEY_EVENT_NONE_PENDING.
//
// If the BIOS does not support this feature, the RM will return NV_HOTKEY_EVENT_NOT_SUPPORTED.
// 
// Input: a pointer to a NV_CFGEX_GET_HOTKEY_EVENT_PARAMS paramStruct
// Output: the event field will report a number from the event list below
//         the status field, where appropriate, indicates the new state the event is reporting
//
#define NV_CFGEX_GET_HOTKEY_EVENT                            330

//Queue Commands
#define NV_HOTKEY_EVENT_NOT_SUPPORTED        0  //No BIOS hotkey support.  Further polling not required.
#define NV_HOTKEY_EVENT_NONE_PENDING         1  //No hotkey events currently pending
#define NV_HOTKEY_EVENT_DISPLAY_ENABLE       2  //status bits decode to disable/enable state for
                                                // each display (definitions below) (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_LCD          2  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_CRT          3  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_TV           4  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_DFP          5  //status 0/1 = disable/enable (implemented by driver)
#define NV_HOTKEY_EVENT_DISPLAY_CENTERING    6  //scaled/centered display - status values define below (implemented by BIOS)
                                                // mirrors settings for NV_PRAMDAC_FP_TG_CONTROL_MODE in nv_ref.h

// Status bit definitions for NV_HOTKEY_EVENT_DISPLAY_ENABLE event
// Currently identical to the BIOS register bit definitions, but
// we decode it explicitly to avoid implicit dependencies.
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD 0x01
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT 0x02
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV  0x04
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP 0x08

//Enumeration of centering/scaling settings used with
// NV_HOTKEY_EVENT_DISPLAY_CENTERING event
#define NV_HOTKEY_STATUS_DISPLAY_SCALED     0x00
#define NV_HOTKEY_STATUS_DISPLAY_CENTERED   0x01
#define NV_HOTKEY_STATUS_DISPLAY_NATIVE     0x02

typedef struct {
    unsigned long event;
    unsigned long status;
} NV_CFGEX_GET_HOTKEY_EVENT_PARAMS;


#define NV_CFGEX_GET_LOGICAL_DEV_EDID                331 
// param structure
typedef struct {
    unsigned long displayMap;
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS;

#pragma pack() //


// NvRmOsConfigSet/Get parameters
//
// definitions for OS-specific versions of the config get/set calls.
//   When possible, new config calls should be added to the standard
//   config calls instead of here.
//

// NV_OSCFG_VSL_MODE - Return/Set the passing of VSL to the display manager
//
//  Initial value is 1
// 

#define NV_OSCFG_VSL_MODE                        0x0001


////////////////////////////////////////////////////////////////////
//
// NvRmOsConfigSetEx/GetEx parameters
//
//

//
// Get info about the cards in the system
//
typedef struct
{
    int    flags;               // see below
    int    instance;            // resman's ordinal for the card
    int    bus;                 // bus number (PCI, AGP, etc)
    int    slot;                // card slot
    int    vendor_id;           // PCI vendor id
    int    device_id;
    int    interrupt_line;
} NVCARDINFO, *PNVCARDINFO;

#define NV_CARD_INFO_FLAG_PRESENT       0x0001

#define NV_OSCFGEX_GET_CARD_INFO           100

typedef struct {
    unsigned long NumCards;                // input size of buffer; output # cards
    PNVCARDINFO   pCardInfo;
} NV_OSCFGEX_GET_CARD_INFO_PARAMS;


//---------------------------------------------------------------------------
//
//  Configuration Manager API.
//
//---------------------------------------------------------------------------
//
//
// DWORD NvConfigVersion(VOID)
//
//  Returns the revision of the ddk (config) interface built into the resource manager.
//  This is used for version continuity between all the resource manager files,
//  as well as provides the interface version for people using the config interface.
//
//  The format of this is 0xAAAABBCC, where
//   - 0xAAAA is [nvidia internal]
//   -   0xBB is the software release revision
//   -   0xCC is the minor revision
//
//
// DWORD NvConfigGet(DWORD Index, DWORD DeviceHandle)
//
//  Given an Index from NVCM.H and a pointer to a specific device (see SDK), return
//  the current configuration value.  The format of the value is dependent on the
//  index requested.
//
//
// DWORD NvConfigSet(DWORD Index, DWORD NewValue, DWORD DeviceHandle)
//
//  Given an Index from NVCM.H, a pointer to a specific device (see SDK), and a new
//  value, update the current configuration value.  This call returns the original
//  value in that configuration index.  In general, most new values do not take affect
//  until NvConfigUpdate() is called.  This allows multiple values to be batched
//  together before enabling the change.
//
//
// DWORD NvConfigUpdate(DWORD UpdateFlag, DWORD DeviceHandle)
//
//  Given an update flag and pointer to a specific device (see SDK), perform any previously
//  batched NvConfigSet() calls.  This call returns an error code (0 denotes success).
//  The only UpdateFlag currently in use is NV_CFG_PERMANENT.
//

#ifndef _WIN32
#if defined(__GNUC__) || defined(MACOS)
int NvConfigVersion(int);
int NvConfigGet(int, int);
int NvConfigSet(int, int, int);
int NvConfigUpdate(int, int);
int NvConfigVga(int, int);
#elif !defined(__WATCOMC__)
DWORD FAR PASCAL NvConfigVersion(DWORD);
DWORD FAR PASCAL NvConfigGet(DWORD, DWORD);
DWORD FAR PASCAL NvConfigSet(DWORD, DWORD, DWORD);
DWORD FAR PASCAL NvConfigUpdate(DWORD, DWORD);
DWORD FAR PASCAL NvConfigVga(DWORD, DWORD);
#endif // ! __WATCOMC__

#elif !defined(WINNT)
int __stdcall NvConfigVersion(void);
int __stdcall NvConfigGet(int, int);
int __stdcall NvConfigSet(int, int, int);
int __stdcall NvConfigUpdate(int);
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvConfigVersion "*";
#pragma aux (__stdcall) NvConfigGet "*";
#pragma aux (__stdcall) NvConfigSet "*";
#pragma aux (__stdcall) NvConfigUpdate "*";
#endif // __WATCOMC__
#endif // _WIN32


/////////////////////////////////////////////////////////////////////////////
//
// THE FOLLOWING DEFINES AND ENTRY POINTS ARE NVIDIA RESERVED
//
//---------------------------------------------------------------------------
//
//  Device Defines.
//
//---------------------------------------------------------------------------

//
// Parameter to DeviceGet.
//
#define NV_DEV_BASE                             1
#define NV_DEV_ALTERNATE                        2
#define NV_DEV_BUFFER_0                         3
#define NV_DEV_BUFFER_1                         4
#define NV_DEV_TIMER                            5
#define NV_DEV_PFB                              6
#define NV_DEV_PGRAPH                           7
#define NV_DEV_PRMCIO                           8
#define NV_DEV_PRMVIO                           9
#define NV_DEV_AGP                              10
#define NV_DEV_GAMMA                            11
#define NV_DEV_PRAMDAC                          12
#define NV_DEV_PCRTC                            13
#define NV_DEV_MAX                              13

//---------------------------------------------------------------------------
//
//  Device Pointer API.
//
//---------------------------------------------------------------------------
#ifndef WINNT
#ifndef _WIN32
#if defined(__GNUC__) || defined(MACOS)
int NvIoControl(int, int);
int NvDeviceBaseGet(int, int);
int NvDeviceLimitGet(int, int);
int NvDeviceSelectorGet(int, int);
int NvGetHardwarePointers(int *, int *, int *, int *);
#elif !defined(__WATCOMC__)
//DWORD FAR PASCAL NvIoControl(DWORD, DWORD);
DWORD FAR PASCAL NvDeviceBaseGet(DWORD, DWORD);
DWORD FAR PASCAL NvDeviceLimitGet(DWORD, DWORD);
WORD  FAR PASCAL NvDeviceSelectorGet(DWORD, DWORD);
DWORD FAR PASCAL NvGetHardwarePointers(DWORD *, DWORD *, DWORD *, DWORD *);
#endif // __WATCOMC__
#else  /* WIN32 */
void __stdcall NvIoControl(int, void *);
int  __stdcall NvDeviceBaseGet(int, int);
int  __stdcall NvDeviceLimitGet(int, int);
int  __stdcall NvDeviceSelectorGet(int, int);
int  __stdcall NvGetHardwarePointers(int *, int *, int *, int *, int);
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvIoControl "*";
#pragma aux (__stdcall) NvDeviceBaseGet "*";
#pragma aux (__stdcall) NvDeviceLimitGet "*";
#pragma aux (__stdcall) NvDeviceSelectorGet "*";
#pragma aux (__stdcall) NvGetHardwarePointers "*";
#endif // __WATCOMC__
#endif // _WIN32
#endif // !WINNT
#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvRmR0Api.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * NvRmR0Api.h
 *
 * NVidia resource manager API header file exported to drivers which are operating in Ring0
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// NOTE NOTE NOTE
// Those functions which are commented out are not yet implemented for the Ring0 interface

//HANDLE __stdcall NvRmR0Open(VOID);
//VOID   __stdcall NvRmR0Close(VOID);
ULONG  __stdcall NvRmR0AllocRoot(ULONG *phClient);
ULONG  __stdcall NvRmR0AllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  __stdcall NvRmR0AllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  __stdcall NvRmR0AllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  __stdcall NvRmR0AllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  __stdcall NvRmR0AllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  __stdcall NvRmR0AllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  __stdcall NvRmR0Alloc(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  __stdcall NvRmR0Free(ULONG hClient, ULONG hParent, ULONG hObject);
//ULONG  __stdcall Nv3RmR0GetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  __stdcall NvRmR0AllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
//ULONG  __stdcall NvRmR0ConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
//ULONG  __stdcall NvRmR0ConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
//ULONG  __stdcall NvRmR0ConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
//ULONG  __stdcall NvRmR0ConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  __stdcall NvRmR0Interrupt(ULONG hClient, ULONG hDevice);
ULONG  __stdcall NvRmR0I2CAccess(ULONG hClient, ULONG hDevice, VOID* pCtrlStruct );

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\ioaccess.h ===
/*++

Copyright (c) 1989-1995   Microsoft Corporation

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/

//
// Note: IA64 is for 64 bits Merced. Under Merced compiler option, we don't have
// _X86_, instead, we use _IA64_. Same thing, _AXP64_ is for 64 bits compiler
// option for ALPHA
//
#if defined(_MIPS_) || defined(_X86_) || defined(_IA64_)

//
// Memory barriers on X86 and MIPS are not required since the Io
// Operations are always garanteed to be executed in order
//

#define MEMORY_BARRIER()    0


#elif defined(_PPC_)

//
// A memory barrier function is provided by the PowerPC Enforce
// In-order Execution of I/O instruction (eieio).
//

#if defined(_M_PPC) && defined(_MSC_VER) && (_MSC_VER>=1000)
void __emit( unsigned const __int32 );
#define __builtin_eieio() __emit( 0x7C0006AC )
#else
void __builtin_eieio(void);
#endif

#define MEMORY_BARRIER()        __builtin_eieio()


#elif defined(_ALPHA_) || (_AXP64_)

//
// ALPHA requires memory barriers
//

#define MEMORY_BARRIER()  __MB()



#endif

#ifndef NO_PORT_MACROS



//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate MEMORY registers.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O ports.
//  (Use x86 in/out instructions.)
//


//
// inp(),inpw(), inpd(), outp(), outpw(), outpd() are X86 specific intrinsic
// inline functions. So for IA64, we have to put READ_PORT_USHORT() etc. back
// to it's supposed to be, defined in sdk\inc\wdm.h
//
#if defined(_IA64_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_X86_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  inp (Port)
#define READ_PORT_USHORT(Port)                 inpw (Port)
#define READ_PORT_ULONG(Port)                  inpd (Port)
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#elif defined(_PPC_) || defined(_MIPS_)

#define READ_REGISTER_UCHAR(x)      (*(volatile UCHAR * const)(x))
#define READ_REGISTER_USHORT(x)     (*(volatile USHORT * const)(x))
#define READ_REGISTER_ULONG(x)      (*(volatile ULONG * const)(x))
#define WRITE_REGISTER_UCHAR(x, y)  (*(volatile UCHAR * const)(x) = (y))
#define WRITE_REGISTER_USHORT(x, y) (*(volatile USHORT * const)(x) = (y))
#define WRITE_REGISTER_ULONG(x, y)  (*(volatile ULONG * const)(x) = (y))
#define READ_PORT_UCHAR(x)          READ_REGISTER_UCHAR(x)
#define READ_PORT_USHORT(x)         READ_REGISTER_USHORT(x)
#define READ_PORT_ULONG(x)          READ_REGISTER_ULONG(x)

//
// All these macros take a ULONG as a parameter so that we don't
// force an extra typecast in the code (which will cause the X86 to
// generate bad code).
//

#define WRITE_PORT_UCHAR(x, y)      WRITE_REGISTER_UCHAR(x, (UCHAR) (y))
#define WRITE_PORT_USHORT(x, y)     WRITE_REGISTER_USHORT(x, (USHORT) (y))
#define WRITE_PORT_ULONG(x, y)      WRITE_REGISTER_ULONG(x, (ULONG) (y))


#elif defined(_ALPHA_) || (_AXP64_)

//
// READ/WRITE_PORT/REGISTER_UCHAR_USHORT_ULONG are all functions that
// go to the HAL on ALPHA
//
// So we only put the prototypes here
//

__declspec(dllimport)
UCHAR
READ_REGISTER_UCHAR(
    PVOID Register
    );

__declspec(dllimport)
USHORT
READ_REGISTER_USHORT(
    PVOID Register
    );

__declspec(dllimport)
ULONG
READ_REGISTER_ULONG(
    PVOID Register
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_UCHAR(
    PVOID Register,
    UCHAR Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_USHORT(
    PVOID  Register,
    USHORT Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_ULONG(
    PVOID Register,
    ULONG Value
    );

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#endif      // NO_PORT_MACROS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvos.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvos.h>  defines the Operating System function and ioctl interfaces to  *|
|*  NVIDIA's Unified Media Architecture (TM).                                *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVOS_INCLUDED
#define NVOS_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>

// local defines here
#define FILE_DEVICE_NV 		0x00008000
#define NV_IOCTL_FCT_BASE 	0x00000800

// Use these defines if you are opening the RM vxd or the minivdd using the
// CreateFile inetrface.
// NV3 Resource Manager VXDs
#define NV3_PRIMARY_MINIVDD     "\\\\.\\NV3.VXD"
#define NV3_SECONDARY_MINIVDD   "\\\\.\\NV3MINI2.VXD"
#define NV3_RESMAN_VXD          "\\\\.\\NV3RM.VXD"
// NV4/NV10 Resource Manager VXDs
#define NVX_PRIMARY_MINIVDD     "\\\\.\\NVMINI.VXD"
#define NVX_SECONDARY_MINIVDD   "\\\\.\\NVMINI2.VXD"
#define NVX_RESMAN_VXD          "\\\\.\\NVCORE.VXD"

// Use this define for the resman vxd name if you use the VXDLDR_LoadDevice
// interface.
#define VXDLDR_NV3_RESMAN_VXD_NAME "NV3RM.VXD"
#define VXDLDR_NVX_RESMAN_VXD_NAME "NVCORE.VXD"
#define VXDLDR_NVA_RESMAN_VXD_NAME "NVACORE.VXD"

#if defined(WIN32)
#if !defined(NV_APIENTRY)
#define NV_APIENTRY __stdcall
#ifndef APIENTRY
#define APIENTRY    NV_APIENTRY          // APIENTRY deprecated; use NV_APIENTRY
#endif
#define CAPI        NV_APIENTRY          // CAPI deprecated; use NV_APIENTRY
#endif
#if !defined(NV_FASTCALL)
#define NV_FASTCALL __fastcall
//#define FASTCALL    NV_FASTCALL          // FASTCALL deprecated; use NV_FASTCALL
#endif
#if !defined(NV_INLINE)
#define NV_INLINE __inline
#define INLINE      NV_INLINE            // INLINE deprecated; use NV_INLINE
#endif
#if !defined(NV_CDECLCALL)
#define NV_CDECLCALL __cdecl
#define CDECLCALL   NV_CDECLCALL         // CDECLCALL deprecated; use NV_CDECLCALL
#endif
#if !defined(NV_STDCALL)
#define NV_STDCALL __stdcall
#define STDCALL     NV_STDCALL           // STDCALL deprecated; use NV_STDCALL
#endif

#else /* ! defined(WIN32) */

#define NV_APIENTRY
#define NV_FASTCALL
#define NV_CDECLCALL
#define NV_STDCALL 
#ifdef __GNUC__
#define NV_INLINE     __inline__
#elif defined (macintosh)
#define NV_INLINE inline
#else
#define NV_INLINE
#endif

#endif  /* ! WIN32 */

#define NV_CAPI	NV_APIENTRY


 /***************************************************************************\
|*                              NV OS Functions                              *|
 \***************************************************************************/

/*
	Note:
		This version of the architecture has been changed to allow the 
		RM to return a client handle that will subsequently used to
		identify the client.  NvAllocRoot() returns the handle.  All
		other functions must specify this client handle. 

*/
/* macro NV01_FREE */
#define  NV01_FREE                                                 (0x00000000)

/* parameter values */
#define NVOS00_STATUS_SUCCESS                                      (0x00000000)
#define NVOS00_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS00_STATUS_ERROR_OBJECT_IN_USE                          (0x00000004)
#define NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN                    (0x00000005)


/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 status;
} NVOS00_PARAMETERS;

/* macro NV01_ALLOC_ROOT */
#define  NV01_ALLOC_ROOT                                           (0x00000001)

/* status values */
#define NVOS01_STATUS_SUCCESS                                      (0x00000000)
#define NVOS01_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS01_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 status;
} NVOS01_PARAMETERS;

/* valid hClass values. */
#define  NV01_ROOT                                                 (0x00000000)
#define  NV01_ROOT_USER                                            (0x00000041)

/* macro NV01_ALLOC_MEMORY */
#define  NV01_ALLOC_MEMORY                                         (0x00000002)

/* parameter values */
#define NVOS02_FLAGS_PHYSICALITY                                   7:4
#define NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS02_FLAGS_LOCATION                                      11:8
#define NVOS02_FLAGS_LOCATION_PCI                                  (0x00000000)
#define NVOS02_FLAGS_LOCATION_AGP                                  (0x00000001)
#define NVOS02_FLAGS_COHERENCY                                     15:12
#define NVOS02_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS02_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS02_FLAGS_COHERENCY_WRITE_COMBINE                       (0x00000002)
#define NVOS02_FLAGS_COHERENCY_WRITE_THROUGH                       (0x00000003)
#define NVOS02_FLAGS_COHERENCY_WRITE_PROTECT                       (0x00000004)
#define NVOS02_FLAGS_COHERENCY_WRITE_BACK                          (0x00000005)
#define NVOS02_STATUS_SUCCESS                                      (0x00000000)
#define NVOS02_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS02_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS02_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 flags;
  NvP64 pMemory;
  NvU64 pLimit;
  NvV32 status;
} NVOS02_PARAMETERS;

/* macro NV01_ALLOC_CONTEXT_DMA */
#define  NV01_ALLOC_CONTEXT_DMA                                    (0x00000003)

/* parameter values */
#define NVOS03_FLAGS_ACCESS                                        3:0
#define NVOS03_FLAGS_ACCESS_READ_WRITE                             (0x00000000)
#define NVOS03_FLAGS_ACCESS_READ_ONLY                              (0x00000001)
#define NVOS03_FLAGS_ACCESS_WRITE_ONLY                             (0x00000002)
#define NVOS03_FLAGS_PHYSICALITY                                   7:4
#define NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS03_FLAGS_LOCKED                                        11:8
#define NVOS03_FLAGS_LOCKED_ALWAYS                                 (0x00000000)
#define NVOS03_FLAGS_LOCKED_IN_TRANSIT                             (0x00000001)
#define NVOS03_FLAGS_COHERENCY                                     31:12
#define NVOS03_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS03_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS03_STATUS_SUCCESS                                      (0x00000000)
#define NVOS03_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS03_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS03_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS03_STATUS_ERROR_BAD_BASE                               (0x00000006)
#define NVOS03_STATUS_ERROR_BAD_LIMIT                              (0x00000007)
#define NVOS03_STATUS_ERROR_PROTECTION_FAULT                       (0x00000008)
#define NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES                  (0x00000009)
#define NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x0000000A)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 flags;
    NvP64 pBase;
    NvU64 limit;
    NvV32 status;
} NVOS03_PARAMETERS;

/* macro NV01_ALLOC_CHANNEL_PIO */
#define  NV01_ALLOC_CHANNEL_PIO                                    (0x00000004)

/* parameter values */
#define NVOS04_FLAGS_FIFO_RUNOUT_IGNORE                            (0x00000000)
#define NVOS04_FLAGS_FIFO_RUNOUT_ERROR                             (0x00000001)
#define NVOS04_STATUS_SUCCESS                                      (0x00000000)
#define NVOS04_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS04_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS04_STATUS_ERROR_BAD_FLAGS                              (0x00000006)
#define NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000007)

/* parameters */
typedef struct
{
    NvV32 hRoot;
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 hObjectError;
    NvP64 pChannel;
    NvV32 flags;
    NvV32 status;
} NVOS04_PARAMETERS;

/* macro NV01_ALLOC_OBJECT */
#define  NV01_ALLOC_OBJECT                                         (0x00000005)

/* parameter values */
#define NVOS05_STATUS_SUCCESS                                      (0x00000000)
#define NVOS05_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS05_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 status;
} NVOS05_PARAMETERS;

// ***** this has been changed to allow a device name string to be returned
/* macro NV01_ALLOC_DEVICE */
#define  NV01_ALLOC_DEVICE                                         (0x00000006)

/* parameter values */
#define NVOS06_STATUS_SUCCESS                                      (0x00000000)
#define NVOS06_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS06_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
#if _WIN32_WINNT >= 0x0400
    NvP64 szName;
#else
    NvV32 szName;
#endif
    NvV32 status;
} NVOS06_PARAMETERS;

/* macro NV03_ALLOC_CHANNEL_DMA */
#define  NV03_ALLOC_CHANNEL_DMA                                    (0x00000007)

/* parameter values */
#define NVOS07_STATUS_SUCCESS                                      (0x00000000)
#define NVOS07_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS07_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER                      (0x00000006)
#define NVOS07_STATUS_ERROR_BAD_OFFSET                             (0x00000007)
#define NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000008)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 hObjectError;
  NvV32 hObjectBuffer;
  NvU32 offset;
  NvP64 pControl;
  NvV32 status;
} NVOS07_PARAMETERS;

/* macro NV03_DMA_FLOW_CONTROL */
#define  NV03_DMA_FLOW_CONTROL                                     (0x00000008)

/* parameter values */
#define NVOS08_FLAGS_PUT                                           3:0
#define NVOS08_FLAGS_PUT_IGNORE                                    (0x00000000)
#define NVOS08_FLAGS_PUT_UPDATE                                    (0x00000001)
#define NVOS08_FLAGS_JUMP                                          31:4
#define NVOS08_FLAGS_JUMP_IGNORE                                   (0x00000000)
#define NVOS08_FLAGS_JUMP_UPDATE                                   (0x00000001)
#define NVOS08_STATUS_SUCCESS                                      (0x00000000)
#define NVOS08_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS08_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS08_STATUS_ERROR_BAD_PUT                                (0x00000004)

/* parameters */
typedef struct
{
  NvV32 hChannel;
  NvV32 flags;
  NvU32 put;
  NvU32 get;
  NvV32 status;
} NVOS08_PARAMETERS;

/* macro NV01_INTERRUPT */
#define  NV01_INTERRUPT                                            (0x00000009)

/* parameter values */
#define NVOS09_STATUS_SUCCESS                                      (0x00000000)
#define NVOS09_STATUS_ERROR_BAD_CLIENT                             (0x00000001)
#define NVOS09_STATUS_ERROR_BAD_DEVICE                             (0x00000002)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 status;
} NVOS09_PARAMETERS;

/* macro NV01_ALLOC_EVENT */
#define  NV01_ALLOC_EVENT                                          (0x0000000A)

/* parameter values */
#define NVOS10_STATUS_SUCCESS                                      (0x00000000)
#define NVOS10_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS10_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS10_STATUS_ERROR_BAD_INDEX                              (0x00000005)
#define NVOS10_STATUS_ERROR_BAD_EVENT                              (0x00000006)
#define NVOS10_STATUS_ERROR_OBJECT_IN_USE                          (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 index;
  NvU64 hEvent;
  NvV32 status;
} NVOS10_PARAMETERS;

/* Valid values for hClass in Nv01AllocEvent */
/* Note that NV01_EVENT_OS_EVENT is same as NV01_EVENT_WIN32_EVENT */
/* TODO: delete the WIN32 name */
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#define  NV01_EVENT_OS_EVENT                                       (0x00000079)
#define  NV01_EVENT_WIN32_EVENT                                    NV01_EVENT_OS_EVENT

//
// There's some definite ugly reuse of args in NV01_ARCH_HEAP for the various
// functions. We'd like to rename field names when adding funcs, so the args
// go in the appropriate places.
//
// For example, adding HEAP_INFO_FREE_BLOCKS, should take offset/offset2 args,
// but because it's not a union and some of the drivers refer to their own typedef
// for the struct, we reuse field names that don't apply to the func.
//

/* funct NV03_HEAP */
#define  NV01_ARCH_HEAP                                            (0x0000000B)
/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvU32 function;
  NvU32 owner;
  NvU32 type;       /* holds 16bits of flags and 16bits of type */
  NvU32 depth;
  NvU32 width;
  NvU32 height;
  NvS32 pitch;
  NvU32 offset;     // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 size;       // for NVOS11_HEAP_INFO, size of largest free block
#if _WIN32_WINNT >= 0x0400
  NvP64 address;    // for NVOS11_HEAP_INFO, base address of heap
#else
  NvU32 address;    // for NVOS11_HEAP_INFO, base address of heap
#endif
  NvU32 limit;      // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 total;
  NvU32 free;
  NvV32 status;
} NVOS11_PARAMETERS;
/* parameter values */
#define NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define NVOS11_HEAP_ALLOC_SIZE                      2
#define NVOS11_HEAP_FREE                            3
#define NVOS11_HEAP_PURGE                           4
#define NVOS11_HEAP_INFO                            5
#define NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define NVOS11_HEAP_DESTROY                         7
#define NVOS11_HEAP_INFO_FREE_BLOCKS                8
#define NVOS11_TYPE_IMAGE                           0
#define NVOS11_TYPE_DEPTH                           1
#define NVOS11_TYPE_TEXTURE                         2
#define NVOS11_TYPE_VIDEO_OVERLAY                   3
#define NVOS11_TYPE_FONT                            4
#define NVOS11_TYPE_CURSOR                          5
#define NVOS11_TYPE_DMA                             6
#define NVOS11_TYPE_INSTANCE                        7
#define NVOS11_TYPE_PRIMARY                         8
#define NVOS11_TYPE_IMAGE_TILED                     9
#define NVOS11_TYPE_DEPTH_COMPR16                   10
#define NVOS11_TYPE_DEPTH_COMPR32                   11
#define NVOS11_TYPE_FLAGS                                31:16
#define NVOS11_TYPE_FLAGS_IGNORE_BANK_PLACEMENT     0x00000001
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_UP        0x00000002
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_DOWN      0x00000004
#define NVOS11_INVALID_BLOCK_FREE_OFFSET            0xFFFFFFFF
#define NVOS11_STATUS_SUCCESS                       (0x00000000)
#define NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define NVOS11_STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define NVOS11_STATUS_ERROR_INVALID_OWNER           (0x00000003)
#define NVOS11_STATUS_ERROR_INVALID_HEAP            (0x00000004)

/* function OS0C */
#define  NV01_CONFIG_VERSION                                       (0x0000000C)

/* parameter values */
#define NVOS12_STATUS_SUCCESS                                      (0x00000000)
#define NVOS12_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS12_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS12_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS12_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 version;
  NvV32 status;
} NVOS12_PARAMETERS;

/* function OS0D */
#define  NV01_CONFIG_GET                                           (0x0000000D)

/* parameter values */
#define NVOS13_STATUS_SUCCESS                                      (0x00000000)
#define NVOS13_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS13_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS13_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS13_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS13_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS13_PARAMETERS;

/* function OS0E */
#define  NV01_CONFIG_SET                                           (0x0000000E)

/* parameter values */
#define NVOS14_STATUS_SUCCESS                                      (0x00000000)
#define NVOS14_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS14_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS14_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS14_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS14_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS14_PARAMETERS;

/* function OS0F */
#define  NV01_CONFIG_UPDATE                                        (0x0000000F)

/* parameter values */
#define NVOS15_STATUS_SUCCESS                                      (0x00000000)
#define NVOS15_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS15_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS15_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS15_STATUS_ERROR_BAD_FLAGS                              (0x00000004)
#define NVOS15_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 flags;
  NvV32 status;
} NVOS15_PARAMETERS;

/* function OS16 */
#define  NV04_RING0_CALLBACK                                        (0x00000010)

/* parameter values */
#define NVOS16_STATUS_SUCCESS                                       (0x00000000)

/* callback function prototype */
typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);

/* parameters */
typedef struct
{
    NvV32             hClient;
    NvV32             hDevice;
#if _WIN32_WINNT >= 0x0400
    NvP64             functionPtr;
#else
    RING0CALLBACKPROC functionPtr;
#endif
    NvU32             param1;
    NvU32             param2;
    NvV32             status;
} NVRM_RING0CALLBACK_PARAMS;

/* function OS17 */
#define  NV04_CONFIG_GET_EX                                        (0x00000011)

/* parameter values */
#define NVOS_CGE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CGE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CGE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CGE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_GET_EX_PARAMS;

/* function OS18 */
#define  NV04_CONFIG_SET_EX                                        (0x00000012)

/* parameter values */
#define NVOS_CSE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CSE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CSE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CSE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_SET_EX_PARAMS;

/* function OS19 */
#define  NV04_I2C_ACCESS                                           (0x00000013)

/* parameter values */
#define NVOS_I2C_ACCESS_STATUS_SUCCESS                             (0x00000000)
#define NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM              (0x00000001)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT                    (0x00000002)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE                    (0x00000003)
#define NVOS_I2C_ACCESS_STATUS_ERROR_INSUFFICIENT_RESOURCES        (0x00000004)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_PARAM_STRUCT              (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_I2C_ACCESS_PARAMS;

/* function OS20 */
#define  NV01_DEBUG_CONTROL                                        (0x000000014)

/* parameter values */
#define NVOS20_STATUS_SUCCESS                                      (0x00000000)
#define NVOS20_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS20_STATUS_ERROR_BAD_DEVICE                             (0x00000002)
#define NVOS20_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS20_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000004)

/* parameters */
typedef struct 
{
    NvV32 hRoot;
    NvV32 command;
    NvP64 pArgs;
    NvV32 status;
} NVOS20_PARAMETERS;

/* current values for command */
#define NVOS20_COMMAND_RM_FAILURE_ENABLE           0x0001
#define NVOS20_COMMAND_RM_FAILURE_DISABLE          0x0002

/* function OS21 */
#define  NV04_ALLOC                                                (0x00000015)

/* parameter values */
#define NVOS21_STATUS_SUCCESS                                      (0x00000000)
#define NVOS21_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS21_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000004)
#define NVOS21_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvP64 pAllocParms;
  NvV32 status;
} NVOS21_PARAMETERS;

/* function OS22 */
#define  NV04_POWER_MANAGEMENT                                     (0x00000016)

/* parameter values */
#define NVOS22_STATUS_SUCCESS                                      (0x00000000)
#define NVOS22_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS22_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS22_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS22_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS22_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)
#define NVOS22_STATUS_ERROR_NO_DEVICE                              (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hDevice;
  NvV32 command;
  NvV32 head;
  void *params;
  NvV32 status;
} NVOS22_PARAMETERS;

/* Command values */

#define NVOS22_POWER_SLEEP               0x0001
#define NVOS22_POWER_WAKE                0x0002
#define NVOS22_POWER_WAKE_BIOS_HAS_RUN   0x0003
#define NVOS22_POWER_DOZE                0x0004
#define NVOS22_POWER_WAKE_TO_DOZE        0x0005
#define NVOS22_POWER_GET_LEVEL           0x0008

/* function OS21 */
#define  NV10_AGP_INIT                                             (0x000000015)
#define  NV10_AGP_TEARDOWN                                         (0x000000016)

/* parameters */
typedef struct 
{
  NvV32 hDevice;
  NvV32 config;
  NvV32 status;
} NVOS_AGP_PARAMS;

/* parameter values */
#define NVOS_AGP_CONFIG_DISABLE_AGP                            	        (0x00000000)
#define NVOS_AGP_CONFIG_NVAGP                                           (0x00000001)
#define NVOS_AGP_CONFIG_AGPGART                                         (0x00000002)
#define NVOS_AGP_CONFIG_ANYAGP                                          (0x00000003)

#define NVOS_AGP_STATUS_SUCCESS                             		(0x00000000)
#define NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM              		(0x00000001)
#define NVOS_AGP_STATUS_ERROR_BAD_CLIENT                           	(0x00000002)
#define NVOS_AGP_STATUS_ERROR_BAD_DEVICE                           	(0x00000003)

/* function OS25 */
#define NV04_OSCONFIG_SET                                           (0x00000019)

/* parameter values */
#define NVOS25_STATUS_SUCCESS                                      (0x00000000)
#define NVOS25_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS25_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS25_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS25_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS25_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS25_PARAMETERS;

/* function OS26 */
#define NV04_OSCONFIG_GET                                           (0x0000001A)

/* parameter values */
#define NVOS26_STATUS_SUCCESS                                      (0x00000000)
#define NVOS26_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS26_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS26_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS26_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS26_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS26_PARAMETERS;

/* function OS27 */
#define NV04_OSCONFIG_GET_EX                                        (0x0000001B)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_GET_EX_PARAMS;

/* function OS28 */
#define NV04_OSCONFIG_SET_EX                                        (0x0000001C)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_SET_EX_PARAMS;

/* macro NV04_DIRECT_METHOD_CALL */
#define NV04_DIRECT_METHOD_CALL                                    (0x0000001D)

/* parameter values */
#define NVOS1D_STATUS_SUCCESS                                      (0x00000000)
#define NVOS1D_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS1D_STATUS_ERROR_BAD_METHOD                             (0x00000004)
#define NVOS1D_STATUS_ERROR_BAD_DATA                               (0x00000005)

/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 method;
  NvV32 data;
  NvV32 status;
} NVOS1D_PARAMETERS;

#define NV04_UNIFIED_FREE											(0x0000001E)

#define NVOS1E_STATUS_SUCCESS										(0x00000000)
#define NVOS1E_STATUS_ERROR_OPERATING_SYSTEM						(0x00000001)
#define NVOS1E_STATUS_ERROR_OBJECT_IN_USE							(0x00000004)

/* NT ioctl data structure */
typedef struct
{
	NvV32	hClient;
	NvV32	hClass;
	NvU32	uDeviceRef;
	NvP64	pParam;
	NvV32	status;
} NV_UNIFIED_FREE;


#ifdef __cplusplus
};
#endif
#endif /* NVOS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvrmarch.inc ===
;/*
;-----------------------------Module-Header-----------------------------;
; Module Name:  NVRMARCH.INC
;
;  Constants for interface to the Resource Manager
;
; Created: 6/12/98
; Author:  ARG
;
; Copyright (C) 1993,1998 NVidia Corporation. All Rights Reserved.
;
; History:
;-----------------------------------------------------------------------;

ifndef  NVRMARCH_INCLUDED
; This seems to break the stupid assembler in strange and mysterious
; ways.  It appears that this file is re-read on the second pass, or
; at least is reevaluated, which produces "phase errors" galore because
; the condition is now different.  This is not rocket science.
;NVRMARCH_INCLUDED       equ     1

comment ~  */

#ifndef NVRMARCH_INCLUDED
#define NVRMARCH_INCLUDED       1

/* ~


ORD_WEP                                 equ      1
ORD_NvSysDispatch                       equ      3
ORD_NvSysNotifyCallback                 equ      4
ORD_NvSysIpcCallback                    equ      5
ORD_NvSysClientExit                     equ      6
ORD_NVSysSetCursor                      equ      7
ORD_NvSysMoveCursor                     equ      8
ORD_NvSysGetScreenInfo                  equ      9
ORD_NvSysOpen                           equ      10
ORD_NvSysClose                          equ      11
ORD_NvSysGetRamInfo                     equ      12
ORD_NvSysSetCanvasRect                  equ      13
ORD_NvSysSetCanvasClip                  equ      14
ORD_NvSysInstallCallback                equ      15
ORD_NvSysAllocPages                     equ      16
ORD_NvSysFreePages                      equ      17
ORD_NvInstallCallback                   equ      22
ORD_NvSysGetBufferInfo                  equ      23
ORD_NvSysSetCanvas                      equ      24
ORD_NvConfigGet                         equ      25
ORD_NvConfigSet                         equ      26
ORD_NvConfigUpdate                      equ      27
ORD_NvConfigVersion                     equ      28
ORD_NvConfigVga                         equ      29
ORD_NvSysSetCanvasRegion                equ      30
ORD_NvSysSetCursorImage                 equ      35
ORD_NvSysMoveCursorMulti                equ      36
ORD_NvSysSetCursorImageMulti            equ      37
ORD_NvSysUpdateImageOffsetFormat        equ      38
ORD_DllEntryPoint                       equ      40
ORD_THK_ThunkData16                     equ      41
ORD_NvSysGetHardwarePointers            equ      50
ORD_NvDeviceBaseGet                     equ      51
ORD_NvDeviceLimitGet                    equ      52
ORD_NvDeviceSelectorGet                 equ      53
ORD_NvSysGetCurrentBufferFlatPointer    equ      54
ORD_NvSysSetColorCursor                 equ      70
ORD_NvSysShowHideCursor                 equ      71
ORD_NvSysGetCursorEmulatePosPointers    equ      72
ORD_NvSysFlushFifo                      equ      80
ORD_NvSysDisplayModeHook                equ      90
ORD_NvSysLockPages                      equ      100
ORD_NvSysUnlockPages                    equ      101
ORD_NvSysDriverConnect                  equ      102
ORD_NvSysDriverDisConnect               equ      103
ORD_NvSysClearScreen                    equ      200
ORD_NvSysRegisterDisplayDriver          equ      201
ORD_NvIoControl                         equ      299
ORD_Nv01Free                            equ      300
ORD_Nv01AllocRoot                       equ      301
ORD_Nv01AllocMemory                     equ      302
ORD_Nv01AllocContextDma                 equ      303
ORD_Nv01AllocChannelPio                 equ      304
ORD_Nv01AllocObject                     equ      305
ORD_Nv01AllocDevice                     equ      306
ORD_Nv03AllocChannelDma                 equ      307
ORD_Nv03DmaFlowControl                  equ      308
ORD_Nv01Interrupt                       equ      309
ORD_Nv01AllocEvent                      equ      310
ORD_NvI2CAccess                         equ      311
ORD_Nv04ConfigGetEx                     equ      312
ORD_Nv04ConfigSetEx                     equ      313
ORD_Nv04Alloc                           equ      314

; GDI and Video channel HANDLE definitions

NV_WIN_ROOT                                     equ             00002001h
NV_WIN_DEVICE                                   equ             00002002h
NV_WIN_CHANNEL                                  equ             00002003h

;
; GDI Context Dma Handles
;

NV_WIN_CONTEXT_DMA_TO_SYS_MEMORY                EQU             00001000h
NV_WIN_WB_CONTEXT_DMA_TO_VIDEO_MEMORY           EQU             00001002h
NV_WIN_WB_CONTEXT_DMA_TO_SYS_MEMORY             EQU             00001003h
NV_WIN_NOTIFIER_CONTEXT_DMA_TO_MEMORY           EQU             00001005h
NV_WIN_PUSHER_NOTIFIER_CONTEXT_DMA_TO_MEMORY    EQU             00001007h
NV_WIN_CONTEXT_DMA_IN_MEMORY                    EQU             00001010h
NV_WIN_CONTEXT_DMA_FROM_VIDEO_MEMORY            EQU             00001012h
NV_WIN_CONTEXT_DMA_FROM_MEMORY                  EQU             00001015h
NV_WIN_WB_CONTEXT_DMA_FROM_SYS_MEMORY           EQU             00001017h
NV_WIN_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT           EQU             00001020h
NV_WIN_WB_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT        EQU             00001022h

NV01_NULL_OBJECT                                equ             0

comment ~
*/

#define ORD_WEP                                  1
#define ORD_NvSysDispatch                        3
#define ORD_NvSysNotifyCallback                  4
#define ORD_NvSysIpcCallback                     5
#define ORD_NvSysClientExit                      6
#define ORD_NVSysSetCursor                       7
#define ORD_NvSysMoveCursor                      8
#define ORD_NvSysGetScreenInfo                   9
#define ORD_NvSysOpen                            10
#define ORD_NvSysClose                           11
#define ORD_NvSysGetRamInfo                      12
#define ORD_NvSysSetCanvasRect                   13
#define ORD_NvSysSetCanvasClip                   14
#define ORD_NvSysInstallCallback                 15
#define ORD_NvSysAllocPages                      16
#define ORD_NvSysFreePages                       17
#define ORD_NvInstallCallback                    22
#define ORD_NvSysGetBufferInfo                   23
#define ORD_NvSysSetCanvas                       24
#define ORD_NvConfigGet                          25
#define ORD_NvConfigSet                          26
#define ORD_NvConfigUpdate                       27
#define ORD_NvConfigVersion                      28
#define ORD_NvConfigVga                          29
#define ORD_NvSysSetCanvasRegion                 30
#define ORD_NvSysSetCursorImage                  35
#define ORD_DllEntryPoint                        40
#define ORD_THK_ThunkData16                      41
#define ORD_NvSysGetHardwarePointers             50
#define ORD_NvDeviceBaseGet                      51
#define ORD_NvDeviceLimitGet                     52
#define ORD_NvDeviceSelectorGet                  53
#define ORD_NvSysGetCurrentBufferFlatPointe      54
#define ORD_NvSysSetColorCursor                  70
#define ORD_NvSysShowHideCursor                  71
#define ORD_NvSysGetCursorEmulatePosPointer      72
#define ORD_NvSysFlushFifo                       80
#define ORD_NvSysDisplayModeHook                 90
#define ORD_NvSysLockPages                       100
#define ORD_NvSysUnlockPages                     101
#define ORD_NvSysDriverConnect                   102
#define ORD_NvSysDriverDisConnect                103
#define ORD_NvSysClearScreen                     200
#define ORD_NvIoControl                          299
#define ORD_Nv01Free                             300
#define ORD_Nv01AllocRoot                        301
#define ORD_Nv01AllocMemory                      302
#define ORD_Nv01AllocContextDma                  303
#define ORD_Nv01AllocChannelPio                  304
#define ORD_Nv01AllocObject                      305
#define ORD_Nv01AllocDevice                      306
#define ORD_Nv03AllocChannelDma                  307
#define ORD_Nv03DmaFlowControl                   308
#define ORD_Nv01Interrupt                        309
#define ORD_Nv01AllocEvent                       310
#define ORD_NvI2CAccess                          311


// GDI and Video channel HANDLE definitions

#define NV_WIN_ROOT                              0x00002001
#define NV_WIN_DEVICE                            0x00002002
#define NV_WIN_CHANNEL                           0x00002003

/* ~


;  funct NV01_ALLOC_ROOT parameters
ALLOC_ROOT_PARAM    STRUC           ;                   */ typedef struct {                 /*
    ALLOC_ROOT_hObjectNew   dd  ?   ; client handle ret */ unsigned long    hObjectNew;     /*
    ALLOC_ROOT_hClass       dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_ROOT_status       dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_ROOT_PARAM    ENDS            ;                   */ } Alloc_Root_Param;              /*

; Neat-o! MASM 5.20 is only good for 31 characters on identifiers!
; Equates definitions must be unique before this point:
;                              |

ALLOC_ROOT_STATUS_SUCCESS                       equ     00000000h
ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        equ     00000001h
ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       equ     00000002h
ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          equ     00000003h
ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               equ     00000004h
ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  equ     00000005h

ALLOC_ROOT_CLASS_ROOT                           equ     00000000h

Nv01AllocRoot_MAC macro buffer,hClass
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClass
        mov     [bx].ALLOC_ROOT_hClass,edx
        mov     [bx].ALLOC_ROOT_status,ALLOC_ROOT_STATUS_SUCCESS
        cCall   Nv01AllocRoot
        pop     edx
endm

comment ~  */

#define ALLOC_ROOT_STATUS_SUCCESS                       0x00000000
#define ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        0x00000001
#define ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       0x00000002
#define ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          0x00000003
#define ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               0x00000004
#define ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  0x00000005

#define ALLOC_ROOT_CLASS_ROOT                           0x00000000

/* ~


NVOS21_STATUS_SUCCESS                           equ     00000000
NVOS21_STATUS_ERROR_OPERATING_SYSTEM            equ     00000001
NVOS21_STATUS_ERROR_BAD_ROOT                    equ     00000002
NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT           equ     00000003
NVOS21_STATUS_ERROR_BAD_OBJECT_NEW              equ     00000004
NVOS21_STATUS_ERROR_BAD_CLASS                   equ     00000005
NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES      equ     00000006

ALLOC_PARAM      STRUC
  ALLOC_hRoot                   dd      ?
  ALLOC_hObjectParent           dd      ?
  ALLOC_hObjectNew              dd      ?
  ALLOC_hClass                  dd      ?
  ALLOC_pAllocParms             dd      ?
  ALLOC_Null                    dd      0       
  ALLOC_status                  dd      ?
ALLOC_PARAM      ENDS

ALLOC_DEV_PARAM    STRUC            ;                   */ typedef struct {                 /*
    ALLOC_DEV_hObjectParent dd  ?   ; client handle     */ unsigned long    hObjectParent;  /*
    ALLOC_DEV_hObjectNew    dd  ?   ;                   */ unsigned long    hObjectNew;     /*
    ALLOC_DEV_hClass        dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_DEV_szName        dd  ?   ;                   */ unsigned long    szName;         /*
    ALLOC_DEV_status        dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_DEV_PARAM    ENDS             ;                   */ } Alloc_Dev_Param;               /*

ALLOC_DEV_STATUS_SUCCESS                        equ     00000000h
ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           equ     00000001h
ALLOC_DEV_STATUS_ERR_BAD_PARENT_OBJECT          equ     00000002h
ALLOC_DEV_STATUS_ERR_BAD_NEW_OBJECT             equ     00000003h
ALLOC_DEV_STATUS_ERR_BAD_CLASS                  equ     00000004h
ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     equ     00000005h

Nv01AllocDevice_MAC macro buffer,hObjectParent,hObjectNew,hClass,szName
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_DEV_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_DEV_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_DEV_hClass, edx

        lea     ax, szName              ; Flatten the device name
        mov     dx, ds

        DPMI_Flatten

        shl     edx, 16
        mov     dx, ax

        lea     bx, buffer
        mov     [bx].ALLOC_DEV_szName, edx
        mov     [bx].ALLOC_DEV_status,ALLOC_DEV_STATUS_SUCCESS
        cCall   Nv01AllocDevice
        pop     edx
endm

; THE C-EQUIVALENTS OF THESE DEFINITIONS ARE FOUND IN NV32.H
; KEEP THEM IN SYNC!
NV01_DEVICE_0                                   equ     00000080h
NV01_DEVICE_1                                   equ     00000081h
NV01_DEVICE_2                                   equ     00000082h
NV01_DEVICE_3                                   equ     00000083h
NV01_DEVICE_4                                   equ     00000084h
NV01_DEVICE_5                                   equ     00000085h
NV01_DEVICE_6                                   equ     00000086h
NV01_DEVICE_7                                   equ     00000087h
NV01_CONTEXT_DMA                                equ     00000002h
NV01_CONTEXT_DMA_FROM_MEMORY                    equ     00000002h
NV01_CONTEXT_DMA_TO_MEMORY                      equ     00000003h
NV01_CONTEXT_DMA_IN_MEMORY                      equ     0000003Dh
NV01_CONTEXT_ERROR_TO_MEMORY                    equ     0000003Eh
NV03_CHANNEL_PIO                                equ     0000006Ah
NV03_CHANNEL_DMA                                equ     0000006Bh
NV04_CHANNEL_DMA                                equ     0000006Ch
NV01_MEMORY_SYSTEM                              equ     0000003Eh
NV01_MEMORY_LOCAL_PRIVILEGED                    equ     0000003Fh
NV01_MEMORY_LOCAL_USER                          equ     00000040h

comment ~  */

#define ALLOC_DEV_STATUS_SUCCESS                        0x00000000
#define ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_DEV_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000005

/* ~

ALLOC_MEMORY_PARAM     STRUC           ;               */ typedef struct {                 /*
    ALLOC_MEMORY_hObjectClient dd  ?   ; client handle */ unsigned long    hObjectClient;  /*
    ALLOC_MEMORY_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_MEMORY_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_MEMORY_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_MEMORY_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_MEMORY_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                               dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_MEMORY_pLimit        dd  ?   ;               */ unsigned long    pLimit;         /*
                               dd  ?   ;               */ unsigned long    pLimit_high;    /*
    ALLOC_MEMORY_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_MEMORY_PARAM     ENDS            ;               */ } Alloc_Memory_Param;            /*

ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               equ 00000000h
ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            equ 00000010h

ALLOC_MEMORY_FLAGS_LOCATION_PCI                         equ 00000000h
ALLOC_MEMORY_FLAGS_LOCATION_AGP                         equ 00000100h

ALLOC_MEMORY_FLAGS_UNCACHED                             equ 00000000h
ALLOC_MEMORY_FLAGS_CACHED                               equ 00001000h
ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        equ 00002000h
ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        equ 00003000h
ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        equ 00004000h
ALLOC_MEMORY_FLAGS_WRITE_BACK                           equ 00005000h

ALLOC_MEMORY_STATUS_SUCCESS                             equ 00000000h
ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                equ 00000001h
ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               equ 00000002h
ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  equ 00000003h
ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       equ 00000004h
ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       equ 00000005h
ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          equ 00000006h

Nv01AllocMemory_MAC macro buffer,hObjectClient,hObjectParent,hObjectNew,hClass,flags,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectClient
        mov     [bx].ALLOC_MEMORY_hObjectClient,edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_MEMORY_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_MEMORY_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_MEMORY_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_MEMORY_flags,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pBase, 0
        mov     dword ptr [bx].ALLOC_MEMORY_pBase+4, 0
        mov     edx, limit
        mov     [bx].ALLOC_MEMORY_pLimit,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pLimit+4, 0
        mov     [bx].ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        cCall   Nv01AllocMemory
        pop     edx
endm

comment ~  */

#define ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               0x00000000
#define ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            0x00000010

#define ALLOC_MEMORY_FLAGS_LOCATION_PCI                         0x00000000
#define ALLOC_MEMORY_FLAGS_LOCATION_AGP                         0x00000100

#define ALLOC_MEMORY_FLAGS_UNCACHED                             0x00000000
#define ALLOC_MEMORY_FLAGS_CACHED                               0x00001000
#define ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        0x00002000
#define ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        0x00003000
#define ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        0x00004000
#define ALLOC_MEMORY_FLAGS_WRITE_BACK                           0x00005000

#define ALLOC_MEMORY_STATUS_SUCCESS                             0x00000000
#define ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               0x00000002
#define ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  0x00000003
#define ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       0x00000005
#define ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000006

/* ~

ALLOC_CTX_DMA_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CTX_DMA_hObjectParent dd  ?   ; client handle */ unsigned long    hObjectParent;  /*
    ALLOC_CTX_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CTX_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CTX_DMA_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CTX_DMA_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                                dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_CTX_DMA_limit         dd  ?   ;               */ unsigned long    limit;          /*
                                dd  ?   ;               */ unsigned long    limit_high;     /*
    ALLOC_CTX_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CTX_DMA_PARAM    ENDS             ;               */ } Alloc_Ctx_DMA_Param;           /*

ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                        equ 00000000h
ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                    equ 00000001h
ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY                   equ 00000002h

ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY              equ 00000000h
ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY           equ 00000010h

ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                       equ 00000000h
ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT                   equ 00000100h

ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED                  equ 00000000h
ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                    equ 00001000h

ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                       equ ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

ALLOC_CTX_DMA_STATUS_SUCCESS                            equ 00000000h
ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                      equ 00000005h
ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                       equ 00000006h
ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                      equ 00000007h
ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT               equ 00000008h
ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES          equ 00000009h
ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 0000000ah

Nv01AllocContextDma_MAC macro buffer,hObjectParent,hObjectNew,hClass,flags,sel,pBase,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CTX_DMA_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CTX_DMA_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_CTX_DMA_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_CTX_DMA_flags,edx
        mov     edx, pBase
        mov     [bx].ALLOC_CTX_DMA_pBase,edx
        mov     dx, sel
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+4, dx
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+6, 0
        mov     edx, limit
        mov     [bx].ALLOC_CTX_DMA_limit,edx
        mov     dword ptr [bx].ALLOC_CTX_DMA_limit+4, 0
        mov     [bx].ALLOC_CTX_DMA_status,ALLOC_CTX_DMA_STATUS_SUCCESS
        cCall   Nv01AllocContextDma
        pop     edx
endm

comment ~  */

#define ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                    0x00000000
#define ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                0x00000001
#define ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY               0x00000002

#define ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY          0x00000000
#define ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY       0x00000010

#define ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                   0x00000000
#define ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT               0x00000100

#define ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED              0x00000000
#define ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                0x00001000

#define ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                   ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

#define ALLOC_CTX_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                  0x00000005
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                   0x00000006
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                  0x00000007
#define ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT           0x00000008
#define ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES      0x00000009
#define ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x0000000a

/* ~

ALLOC_CHL_PIO_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CHL_PIO_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_PIO_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_PIO_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_PIO_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_PIO_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_PIO_pChannel      dd  ?   ;               */ unsigned long    pChannel;       /*
                                dd  ?   ;               */ unsigned long    pChannel_high;  /*
    ALLOC_CHL_PIO_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CHL_PIO_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_PIO_PARAM    ENDS             ;               */ } Alloc_Chl_PIO_Param;           /*

ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT                  equ 00000000h
ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT                   equ 00000001h

ALLOC_CHL_PIO_STATUS_SUCCESS                            equ 00000000h
ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR               equ 00000005h
ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                      equ 00000006h
ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 00000007h

Nv01AllocChannelPio_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,flags
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_PIO_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_PIO_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_PIO_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_PIO_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_PIO_hObjectError, edx
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel, 0
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel+4, 0
        mov     edx, flags
        mov     [bx].ALLOC_CHL_PIO_flags,edx
        mov     [bx].ALLOC_CHL_PIO_status,ALLOC_CHL_PIO_STATUS_SUCCESS
        cCall   Nv01AllocChannelPio
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT              0x00000000
#define ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT               0x00000001

#define ALLOC_CHL_PIO_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                  0x00000006
#define ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000007

/* ~
;  funct NV03_ALLOC_CHANNEL_DMA parameters
ALLOC_CHL_DMA_PARAM STRUC                           ;               */ typedef struct {                 /*
    ALLOC_CHL_DMA_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_DMA_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_DMA_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_DMA_hObjectBuffer dd  ?   ;               */ unsigned long    hObjectBuffer;  /*
    ALLOC_CHL_DMA_offset        dd  ?   ;               */ unsigned long    offset;         /*
    ALLOC_CHL_DMA_pControl      dd  ?   ;               */ unsigned long    pControl;       /*
                                dd  ?   ;               */ unsigned long    pControl_high;  /*
    ALLOC_CHL_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_DMA_PARAM ENDS                                ;               */ } Alloc_Chl_DMA_Param;           /*

ALLOC_CHL_DMA_STATUS_SUCCESS                         equ        00000000h
ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM            equ        00000001h
ALLOC_CHL_DMA_STATUS_ERR_BAD_PARENT_OBJECT           equ        00000002h
ALLOC_CHL_DMA_STATUS_ERR_BAD_NEW_OBJECT              equ        00000003h
ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                   equ        00000004h
ALLOC_CHL_DMA_STATUS_ERR_BAD_ERROR_OBJECT            equ        00000005h
ALLOC_CHL_DMA_STATUS_ERR_BAD_BUFFRE_OBJECT           equ        00000006h
ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                  equ        00000007h
ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES      equ        00000008h

Nv03AllocChannelDma_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,hObjectBuffer,offset
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_DMA_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_DMA_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_DMA_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_DMA_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_DMA_hObjectError, edx
        mov     edx, hObjectBuffer
        mov     [bx].ALLOC_CHL_DMA_hObjectBuffer, edx
        mov     edx, offset
        mov     [bx].ALLOC_CHL_DMA_offset, edx
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl, 0
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl+4, 0
        mov     [bx].ALLOC_CHL_DMA_status,0
        cCall   Nv03AllocChannelDma
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_BUFFER          0x00000006
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                 0x00000007
#define ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000008

/* ~

NV01FREE_PARAM    STRUC                 ;               */ typedef struct {                 /*
    NV01FREE_hClient            dd  ?   ;               */ unsigned long    hClient;        /*
    NV01FREE_hObjectParent      dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NV01FREE_hObjectOld         dd  ?   ;               */ unsigned long    hObjectOld;     /*
    NV01FREE_status             dd  ?   ;               */ unsigned long    status;         /*
NV01FREE_PARAM    ENDS                  ;               */ } NV01Free_Param;                /*

NV01FREE_STATUS_SUCCESS                                 equ 00000000h
NV01FREE_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
NV01FREE_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
NV01FREE_STATUS_ERR_BAD_OLD_OBJECT                      equ 00000003h
NV01FREE_STATUS_ERR_OBJECT_IN_USE                       equ 00000004h
NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN                 equ 00000005h

Nv01Free_MAC macro buffer,hClient,hObjectParent,hObjectOld
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].NV01FREE_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].NV01FREE_hObjectParent, edx
          mov   edx, hObjectOld
          mov   [bx].NV01FREE_hObjectOld, edx
          mov   [bx].NV01FREE_status, NV01FREE_STATUS_SUCCESS
          cCall Nv01Free
          pop   edx
endm

comment ~  */


#define NV01FREE_STATUS_SUCCESS                             0x00000000
#define NV01FREE_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define NV01FREE_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define NV01FREE_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define NV01FREE_STATUS_ERR_OBJECT_IN_USE                   0x00000004
#define NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN             0x00000005

/* ~

ALLOC_OBJECT_PARAM        STRUC            ;               */ typedef struct {                 /*
    ALLOC_OBJECT_hClient           dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_OBJECT_hObjectParent     dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_OBJECT_hObjectNew        dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_OBJECT_hClass            dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_OBJECT_status            dd  ?   ;               */ unsigned long    status;         /*
ALLOC_OBJECT_PARAM        ENDS             ;               */ } AllocObject_Param;        /*

ALLOC_OBJ_STATUS_SUCCESS                                 equ 00000000h
ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
ALLOC_OBJ_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
ALLOC_OBJ_STATUS_ERR_BAD_NEW_OBJECT                      equ 00000003h
ALLOC_OBJ_STATUS_ERR_BAD_CLASS                           equ 00000004h
ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES              equ 00000005h

Nv01AllocObject_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].ALLOC_OBJECT_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].ALLOC_OBJECT_hObjectParent, edx
          mov   edx, hObjectNew
          mov   [bx].ALLOC_OBJECT_hObjectNew, edx
          mov   edx, hClass
          mov   [bx].ALLOC_OBJECT_hClass, edx
          mov   [bx].ALLOC_OBJECT_status, ALLOC_OBJ_STATUS_SUCCESS
          cCall Nv01AllocObject
          pop   edx
endm

comment ~  */


#define ALLOC_OBJ_STATUS_SUCCESS                             0x00000000
#define ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define ALLOC_OBJ_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000005

/* ~

NVIOCONTROL_PARAM   STRUC               ;               */ typedef struct {                 /*
    NVIOCONTROL_hRoot           dd  ?   ;               */ unsigned long    hRoot;          /*
    NVIOCONTROL_hObjectParent   dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NVIOCONTROL_function        dd  ?   ;               */ unsigned long    function;       /*
    NVIOCONTROL_owner           dd  ?   ;               */ unsigned long    owner;          /*
    NVIOCONTROL_type            dd  ?   ;               */ unsigned long    type;           /*
    NVIOCONTROL_depth           dd  ?   ;               */ unsigned long    depth;          /*
    NVIOCONTROL_width           dd  ?   ;               */ unsigned long    width;          /*
    NVIOCONTROL_height          dd  ?   ;               */ unsigned long    height;         /*
    NVIOCONTROL_pitch           dd  ?   ;               */ unsigned long    pitch;          /*
    NVIOCONTROL_offset          dd  ?   ;               */ unsigned long    offset;         /*
    NVIOCONTROL_size            dd  ?   ;               */ unsigned long    size;           /*
    NVIOCONTROL_address         dd  ?   ;               */ unsigned long    address;        /*
    NVIOCONTROL_limit           dd  ?   ;               */ unsigned long    limit;          /*
    NVIOCONTROL_total           dd  ?   ;               */ unsigned long    total;          /*
    NVIOCONTROL_free            dd  ?   ;               */ unsigned long    free;           /*
    NVIOCONTROL_status          dd  ?   ;               */ unsigned long    status;         /*
NVIOCONTROL_PARAM   ENDS                ;               */ } NVIOControl_Param;             /*

NVIOCONTROL_ARCH_HEAP                                   equ 0000000Bh

NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT               equ 1
NVIOCONTROL_HEAP_ALLOC_SIZE                             equ 2
NVIOCONTROL_HEAP_FREE                                   equ 3
NVIOCONTROL_HEAP_PURGE                                  equ 4
NVIOCONTROL_HEAP_INFO                                   equ 5
NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT               equ 6
NVIOCONTROL_HEAP_DESTROY                                equ 7
NVIOCONTROL_HEAP_INFO_FREE_BLOCKS                       equ 8
NVIOCONTROL_TYPE_IMAGE                                  equ 0
NVIOCONTROL_TYPE_DEPTH                                  equ 1
NVIOCONTROL_TYPE_TEXTURE                                equ 2
NVIOCONTROL_TYPE_VIDEO_OVERLAY                          equ 3
NVIOCONTROL_TYPE_FONT                                   equ 4
NVIOCONTROL_TYPE_CURSOR                                 equ 5
NVIOCONTROL_TYPE_DMA                                    equ 6
NVIOCONTROL_TYPE_INSTANCE                               equ 7
NVIOCONTROL_TYPE_PRIMARY                                equ 8
NVIOCONTROL_STATUS_SUCCESS                              equ 00000000h
NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES           equ 00000001h
NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID                 equ 00000002h
NVIOCONTROL_STATUS_ERR_OWNER_INVALID                    equ 00000003h

comment ~  */

#define NVIOCONTROL_ARCH_HEAP                               (0x0000000B)

#define NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT           1
#define NVIOCONTROL_HEAP_ALLOC_SIZE                         2
#define NVIOCONTROL_HEAP_FREE                               3
#define NVIOCONTROL_HEAP_PURGE                              4
#define NVIOCONTROL_HEAP_INFO                               5
#define NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT           6
#define NVIOCONTROL_TYPE_IMAGE                              0
#define NVIOCONTROL_TYPE_DEPTH                              1
#define NVIOCONTROL_TYPE_TEXTURE                            2
#define NVIOCONTROL_TYPE_VIDEO_OVERLAY                      3
#define NVIOCONTROL_TYPE_FONT                               4
#define NVIOCONTROL_TYPE_CURSOR                             5
#define NVIOCONTROL_TYPE_DMA                                6
#define NVIOCONTROL_TYPE_INSTANCE                           7
#define NVIOCONTROL_TYPE_PRIMARY                            8
#define NVIOCONTROL_STATUS_SUCCESS                          (0x00000000)
#define NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES       (0x00000001)
#define NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID             (0x00000002)
#define NVIOCONTROL_STATUS_ERR_OWNER_INVALID                (0x00000003)


/* ~

; This must be identical to what is NVRMWIN.H - 
; it would be nice if we could use this definition only.

_def_rmParams   STRUC                   ;       */      typedef struct _def_rmParams {      /*
    RegEAX              dd      ?       ;       */          unsigned long    RegEAX;        /*
    RegEBX              dd      ?       ;       */          unsigned long    RegEBX;        /*
    RegECX              dd      ?       ;       */          unsigned long    RegECX;        /*
    RegEDX              dd      ?       ;       */          unsigned long    RegEDX;        /*
    RegEDI              dd      ?       ;       */          unsigned long    RegEDI;        /*
    RegESI              dd      ?       ;       */          unsigned long    RegESI;        /*
    RegES               dd      ?       ;       */          unsigned long    RegES;         /*
    RegDS               dd      ?       ;       */          unsigned long    RegDS;         /*
    RegCS               dd      ?       ;       */          unsigned long    RegCS;         /*
_def_rmParams   ENDS                    ;       */      } RMPARAMS, *PRMPARAMS;             /*

RMPARAMS        TYPEDEF         _def_rmParams
PRMPARAMS       TYPEDEF         PTR _def_rmParams

comment ~  */

/* ~
comment ~  */

/* ~
comment ~  */

#endif  // NVRMARCH_INCLUDED
/* ~

endif   ; NVRMARCH_INCLUDED

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\videoagp.h ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    videoagp.h

Abstract:
    Video miniport AGP support.

Notes:

Revision History:

--*/

#ifndef __VIDEOAGP_H__
#define __VIDEOAGP_H__

typedef
PHYSICAL_ADDRESS
(*PAGP_RESERVE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext
    );

typedef
BOOLEAN
(*PAGP_COMMIT_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
PVOID
(*PAGP_RESERVE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext
    );

typedef
PVOID
(*PAGP_COMMIT_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef struct _VIDEO_PORT_AGP_SERVICES
{
    PAGP_RESERVE_PHYSICAL AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL  AgpCommitPhysical;
    PAGP_FREE_PHYSICAL    AgpFreePhysical;

    PAGP_RESERVE_VIRTUAL  AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL  AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL   AgpCommitVirtual;
    PAGP_FREE_VIRTUAL     AgpFreeVirtual;
    ULONGLONG AllocationLimit;

} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_PORT_AGP_SERVICES AgpServices
    );

#endif // ifndef __VIDEOAGP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\XXXrm_unix.h ===
/*
 * this is a hack repository to deal with issues on resman linux port as
 * it matures.
 * Once this file is emptied it can be deleted.
 */

/* XXXTEB these should be somewhere else; probably nvos.h */
typedef unsigned long ULONG;
typedef unsigned char *PUCHAR;
typedef void VOID;
typedef void *PVOID;
typedef void *HANDLE;
/* XXXTEB end */

int XXX_RM_INIT(void);
void XXX_ISR_POLL(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\NvViewer.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvViewer.h                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/04/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVVIEWER_H_
#define _NVVIEWER_H_

#define NVSTEREO_IMAGE_SIGNATURE 0x4433564e //NV3D
typedef struct  _Nv_Stereo_Image_Header
{
    DWORD   dwSignature;
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwSwapEyes;
} NVSTEREOIMAGEHEADER, *LPNVSTEREOIMAGEHEADER;
    
//Stereo image viewing mode
#define FULL_SCREEN         0
#define WINDOWED            1
#define WINDOWED_FIT        2

//Mesage handling mode
#define INTERNAL_MESSAGING  0
#define EXTERNAL_MESSAGING  1

typedef class CStereoImageViewer
{
    /*
     * methods
     */
public:
    virtual DWORD Display (LPVOID pImage, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD Display (char * filename, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD WINAPI DestroyStereoImageViewer(void);
    CStereoImageViewer();
    ~CStereoImageViewer();
protected:
} CSTEREOIMAGEVIEWER, *LPCSTEREOIMAGEVIEWER;


extern DWORD WINAPI CreateStereoImageViewer(LPCSTEREOIMAGEVIEWER &pStereoImageViewer);

#endif _NVVIEWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\video.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    video.h

Abstract:

    Contains all structure and routine definitions common to the video port
    driver and the video miniport drivers.

Notes:

Revision History:

--*/

#ifndef __VIDEO_H__
#define __VIDEO_H__

#include <videoagp.h>

//
// Define port driver status code.
// The values for these are the Win32 error codes
//

typedef LONG VP_STATUS;
typedef VP_STATUS *PVP_STATUS;

//
// Defines for registry information and synchronization.
//

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

//
//  Opaque pointer type for miniport to be used to type PEVENTs received from
//  display driver.
//

typedef struct _VIDEO_PORT_EVENT * PEVENT;

//
// Type of information requested with GetDeviceData
//

typedef enum _VIDEO_DEVICE_DATA_TYPE {
    VpMachineData,
    VpCmosData,
    VpBusData,
    VpControllerData,
    VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

//
// Data returned with VpControllerData
//

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    USHORT Version;
    USHORT Revision;
    USHORT Irql;
    USHORT Vector;
    ULONG ControlBase;
    ULONG ControlSize;
    ULONG CursorBase;
    ULONG CursorSize;
    ULONG FrameBase;
    ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

//
// Define structure used to call the BIOS int 10 function
//

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO           0x42
#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA     0x28
 
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

//
// Allows us to remove lots of unused code.
//

#ifndef _NTOSDEF_

#define ALLOC_PRAGMA 1
#define VIDEOPORT_API __declspec(dllimport)

#if DBG
#define PAGED_CODE() \
    if (VideoPortGetCurrentIrql() > 1 /*APC_LEVEL*/) { \
        VideoPortDebugPrint(0, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
        ASSERT(FALSE); \
        }

#else
#define PAGED_CODE()
#endif

ULONG
DriverEntry(
    PVOID Context1
    );

#else
#define VIDEOPORT_API
#endif


#ifndef _NTOS_

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data,
    ULONG DataLength
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data,
    ULONG DataLength // number of words
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data,
    ULONG DataLength  // number of dwords
    );

#endif // _NTOS_


//
// Definition of the request packet sent from the port driver to the
// miniport driver. It reflects the parameters passed from the
// DeviceIOControl call made by the windows display driver.
// 
// N.B. The definition of the STATUS_BLOCK must be the same as the
//      the definition of IO_STATUS_BLOCK defined in ntioapi.h.
//

typedef struct _STATUS_BLOCK {

    //
    // Contains the status code of the operation.
    // This value in one of the Win32 error codes that are defined for use
    // in the video miniport drivers.
    //

    union {
       VP_STATUS Status;
       PVOID Pointer;
    };

    //
    // Information returned to the callee.
    // The meaning of the information varies from function to function. It
    // is generally used to return the minimum size for the input buffer if
    // the function takes an input buffer, or the amount of data transfered
    // back to the caller if the operation returns output.
    //

    ULONG_PTR Information;

} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {

    //
    // The IO control code passed to the DeviceIoControl function by the
    // caller.
    //

    ULONG IoControlCode;

    //
    // Pointer to a status block provided by the caller. This should be
    // filled out by the callee with the appropriate information.
    //

    PSTATUS_BLOCK StatusBlock;

    //
    // Pointer to an input buffer which contains the information passed in
    // by the caller.
    //

    PVOID InputBuffer;

    //
    // Size of the input buffer
    //

    ULONG InputBufferLength;

    //
    // Pointer to an output buffer into which the data returned to the caller
    // should be stored.
    //

    PVOID OutputBuffer;

    //
    // Length of the output buffer. This buffer can not be grown by the
    // callee.
    //

    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

//
//  typedef for scattergather array available via GET_VIDEO_SCATTERGATHER().
//

typedef struct __VRB_SG {
    __int64   PhysicalAddress;
    ULONG     Length;
    } VRB_SG, *PVRB_SG;

//
// Opaque type for dma handle
//

typedef struct __DMA_PARAMETERS * PDMA;

//
//  The following macro returns in Address the 32 bit physical address of
//  the VirtualAddress lying within the InputBuffer passed into EngDevIo
//

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList, VirtualAddress, InputBuffer, pLength, Address)    \
                                                                                           \
        do {                                                                               \
            ULONG_PTR          byteOffset;                                                  \
                                                                                           \
            byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;                \
                                                                                           \
            while (byteOffset >= scatterList->Length) {                                    \
                                                                                           \
                byteOffset -= scatterList->Length;                                         \
                scatterList++;                                                             \
            }                                                                              \
                                                                                           \
            *pLength = scatterList->Length - byteOffset;                                   \
                                                                                           \
            Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset);                  \
                                                                                           \
        } while (0)


#define GET_VIDEO_SCATTERGATHER(ppDma)   (**(PVRB_SG **)ppDma)

#define VIDEO_RANGE_PASSIVE_DECODE   0x1
#define VIDEO_RANGE_10_BIT_DECODE    0x2


//
// The following structure is used to define access ranges. The ranges are
// used to indicate which ports and memory adresses are being used by the
// card.
//

typedef struct _VIDEO_ACCESS_RANGE {

    //
    // Indicates the starting memory address or port number of the range.
    // This values should be stored before being transformed by
    // VideoPortGetDeviceBase() which returns the logical address that must
    // be used by the miniport driver when referencing physical addresses.
    //

    PHYSICAL_ADDRESS RangeStart;

    //
    // Indicates the length in bytes, or number of ports in the range. This
    // value should indicate the range actually decoded by the adapter. For
    // example, if the adapter uses 7 registers but responds to eight, the
    // RangeLength should be set to 8.

    ULONG RangeLength;

    //
    // Indicates if the range is in IO space (TRUE) or in memory space (FALSE).
    //

    UCHAR RangeInIoSpace;

    //
    // Indicates if the range should be visible by the Windows display driver.
    // This is done so that a Windows display driver can access certain
    // video ports directly. This will only be allowed if the caller has the
    // required privileges (is a trusted subsystem) to access the range.
    //
    // Synchronization of access to ports or memory in the range must be
    // done explicitly by the miniport driver and the user mode process so
    // that they both don't try to program the device simultaneously.
    //
    // Non visible ranges should include video memory, ROM addresses, etc.
    // which are not required to program the device for output purposes.
    //
    //

    UCHAR RangeVisible;

    //
    // This field determines if the range can be shared with another device.
    // The rule should be applied as follow.
    //
    // - If the range of memory or IO ports should be "owned" by this driver,
    //   and that any other driver trying to access this range may cause
    //   a problem, FALSE should be returned.
    //
    // - If the range can be shared with another co-operating device driver,
    //   then the share field should be set to TRUE.
    //
    // As a guideline, the VGA miniport driver will claim all of its resources
    // as shareable so that it can be used as a VGA compatible device with
    // any other driver (such as an S3 or XGA.
    //
    // Super VGA miniport drivers that implement all the VGA functionality
    // (declared in the Registry as VGACOMPATIBLE=1) should claim the range
    // as non-shareable since they don't want the VGA to run at the same time.
    //
    // Miniports for cards such as an S3 or XGA that have an XGA on the board
    // but do not implement the VGA functionality will run with the VGA
    // miniport loaded and should therefore claim all the resources shared
    // with the VGA as shareable.
    //
    // Miniports for cards that work with a pass-through and that can be
    // connected to any VGA/SVGA card should not be using any VGA ports or
    // memory ranges ! ... but if they do they should not claim those
    // resources since they will cause a conflict in the system because the
    // SVGA cards will have claimed them as non-shareable ...
    //

    UCHAR RangeShareable;

    //
    // Indicates that the range is decoded by the hardware, but that the
    // driver will never access this port.
    //

    UCHAR RangePassive;

} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;



typedef
PVOID
(*PVIDEO_PORT_GET_PROC_ADDRESS)(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

//
// This structure contains the specific configuration information about the
// device. The information is initialized by the port driver and it should
// be completed by the miniport driver.
// The information is used to setup the device, as weel as providing
// information to the port driver so it can perform some of the requests on
// behalf of the miniport driver.
//

typedef struct _VIDEO_PORT_CONFIG_INFO {

    //
    // Specifies the length of the PVIDEO_PORT_CONFIG_INFO structure as
    // returned by sizeof(). Since this structure may grow in later
    // releases, the miniport driver should check that the length of the
    // structure is greater than or equal to the length it expects (since
    // it is guaranteed that defined fields will not change).
    //
    // This field is always initialized by the port driver.
    //

    ULONG Length;

    //
    // Specifies which IO bus is tp be scanned. This field is used as a
    // parameter to some VideoPortXXX calls.
    //
    // This field is always initialized by the port driver.
    //

    ULONG SystemIoBusNumber;

    //
    // Specifies the type of bus being scanned. This field is equal to the
    // value being passed into VideoPortInitialize in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // This field is always initialized by the port driver.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Specifies the bus interrupt request level. This level corresponds to
    // the IRQL on ISA and MCA buses.
    // This value is only used if the device supports interrupts, which is
    // determined by the presence of an interrupt service routine in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // The preset default value for this field is zero. Otherwise, it is the
    // value found in the device configuration information.
    //

    ULONG BusInterruptLevel;

    //
    // Specifies the bus vector returned by the adapter. This is used for
    // systems which have IO buses that use interrupt vectors. For ISA, MCA
    // and EISA buses, this field is unused.
    //
    // The preset default value for this field is zero.
    //

    ULONG BusInterruptVector;

    //
    // Specifies whether this adapter uses latched or edge-triggered type
    // interrupts.
    //
    // This field is always initialized by the port driver.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Specifies the number of emulator access entries that the adapter
    // uses.  It indicates the number of array elements in the following field.
    //
    // This field can be reinitialized with the number of entries in the
    // EmulatorAccessEntries structure if the structure is statically
    // defined in the miniport driver. The EmulatorAccessEntries fields
    // should also be updated.
    //

    ULONG NumEmulatorAccessEntries;

    //
    // Supplies a pointer to an array of EMULATOR_ACCESS_ENTRY structures.
    // The number of elements in the array is indicated by the
    // NumEmulatorAccessEntries field. The driver should fill out each entry
    // for the adapter.
    //
    // The uninitialized value for the structure is NULL.
    // EmulatorAccessEntries will be NULL if NumEmulatorAccessEntries is
    // zero.
    //
    // A poiner to an array of emulator access entries can be passed back
    // if such a structure is defined statically in the miniport driver. The
    // NumEmulatorAccessEntries field should also be updated.
    //

    PVOID EmulatorAccessEntries;

    //
    // This is a context values that is passed with each call to the
    // emulator/validator functions defined in the EmulatorAccessEntries
    // defined above.
    // This parameter should in general be a pointer to the miniports
    // device extension or other such storage location.
    //
    // This pointer will allow the miniport to save some state temporarily
    // to allow for the batching of IO requests.
    //

    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Physical address of the video memory that must be mapped into a VDM's
    // address space for proper BIOS support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;

    //
    // Length of the video memory that must be mapped into a VDM's addres
    // space for proper BIOS support.
    //

    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Determines the minimum size required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
    // The uninitialized value for this field is zero.
    //
    // If the field is left to zero, SAVE_HARDWARE_STATE will return an
    // ERROR_INVALID_FUNCTION status code.
    //

    ULONG HardwareStateSize;

    //
    // New for version 3.5
    //

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaChannel;

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaPort;

    //
    // Set to 1 if the DMA channel can be shared with another device.
    // Set to 0 if the DMA channel must be owned exclusively by the driver.
    //

    UCHAR DmaShareable;

    //
    // Set to 1 if the interrupt can be shared with another device.
    // Set to 0 if the interrupt must be owned exclusively by the driver.
    //

    UCHAR InterruptShareable;

    //
    //  Start new dma stuff
    //

    //
    // Set to TRUE if the DMA device is a busmaster, FALSE otherwise.
    //

    BOOLEAN Master;

    //
    // Set to number of bits wide. Consistent with DEVICE_DESCRIPTION.
    // See ntioapi.h
    //

    DMA_WIDTH   DmaWidth;

    //
    // Set to speed so miniport can set DEVICE_DESCRIPTION field.
    // See ntioapi.h
    //

    DMA_SPEED   DmaSpeed;

    //
    // Set to TRUE if the DMA device requires mapped buffers. Also
    // a DEVICE_DESCRIPTION  field.
    //

    BOOLEAN bMapBuffers;

    //
    // Set to TRUE if the DMA device requires physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Set to TRUE if the DMA device supports demand mode, FALSE otherwise.
    // Also DEVICE_DESCRIPTION support.
    //

    BOOLEAN DemandMode;

    //
    // Set to max transfer length the DMA device supports.
    //

    ULONG   MaximumTransferLength;

    //
    // Set to max number of Physical breaks the DMA device supports.
    //

    ULONG   NumberOfPhysicalBreaks;

    //
    // Set to TRUE if the DMA device supports scatter gather, FALSE otherwise.
    //

    BOOLEAN ScatterGather;

    //
    // Maximal Length in PVRB_SG returned measured in bytes. If the device
    // has no maximum size, zero should be entered.
    //

    ULONG   MaximumScatterGatherChunkSize;

    //
    // Allow for 4.0/5.0 compatibilty
    //

    PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;

    //
    // Provide a pointer to the device's registry path
    //

    PWSTR DriverRegistryPath;

    //
    // Indicates to a driver the amount of physical memory in the system
    //

    ULONGLONG SystemMemorySize;

} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;


//
// Video Adapter Dependent Routines.
//

typedef
VP_STATUS
(*PVIDEO_HW_FIND_ADAPTER) (
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

typedef
BOOLEAN
(*PVIDEO_HW_INITIALIZE) (
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_HW_INTERRUPT) (
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_HW_LEGACYRESOURCES) (
    IN ULONG VendorId,
    IN ULONG DeviceId,
    IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
    IN OUT PULONG LegacyResourceCount
    );

//
// type to be returned by HwStartDma().
//

typedef enum _HW_DMA_RETURN {
    DmaAsyncReturn,
    DmaSyncReturn
    } HW_DMA_RETURN, *PHW_DMA_RETURN;


typedef
HW_DMA_RETURN
(*PVIDEO_HW_START_DMA) (
    PVOID                   HwDeviceExtension,
    PDMA                    pDma
    );

//
//  Flags to be passed into VideoPortLockPages() or VideoPortDoDma().
//

//
//  The flag VideoPortUnlockAfterDma tells the video port to unlock the pages
//  after the miniport signals that the dma is complete via the
//  pDmaCompletionEvent in HwStartDma. Failure to set this event at
//  dma completion may cause the memory to be unlocked at randon times.
//  This flag is best used when one wants to do one dma transfer which
//  occurs infrequently. It allows locking, dmaing and unlocking to be performed
//  in the context of 1 IOCTL.
//

//
//  The flag VideoPortKeepPagesLocked tells the video port to leave the pages
//  locked if possible.
//

//
//  The flag VideoPortDmaInitOnly tells the Video Port to lock the pages, but don't
//  call HwStartDma. Not applicable to VideoPortDoDma().
//


typedef enum {
    VideoPortUnlockAfterDma = 1,
    VideoPortKeepPagesLocked,
    VideoPortDmaInitOnly
    }   DMA_FLAGS;

//
// DMA Event flags
//

typedef ULONG DMA_EVENT_FLAGS;

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

//
// Child Enumeration structure passed in to the PVIDEO_HW_GET_CHILD_DESCRIPTOR
// function.
//
// All these parameters are input parameters and must not be modified by the
// callee
//
// Size - Size of the structure.  It can be used by the calle for versioning.
//
// ChildDescriptorSize - Size of the pChildDescriptor buffer passed in as the
//     third parameter to PVIDEO_HW_GET_CHILD_DESCRIPTOR.
//
// ChildIndex - Index of the device to be enumerated.  This field should be
//     used to enumerate devices not enumerated by ACPI or other operating
//     system components.  If this field is set to 0 it indicates the ACPIHwId
//     field.
//
// ACPIHwId - ID returned by the ACPI BIOS that represent the device being
//     queried.  The ACPIHwId returned by the firmware must match the HwIds
//     returned by the driver.  The System BIOS manufacturer and the graphics
//     IHV must synchronize these IDs.
//
// ChildHwDeviceExtension - Pointer to a device extension specific to this
//     child device.  This field will only be filled in if the miniport driver
//     filled the ChildHwDeviceExtensionSize to be non-NULL.
//

typedef struct _VIDEO_CHILD_ENUM_INFO {
    ULONG Size;
    ULONG ChildDescriptorSize;
    ULONG ChildIndex;
    ULONG ACPIHwId;
    PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

//
//  VIDEO_CHILD_TYPE enum:
//
//  'Monitor' identifies a device which may have a DDC2 compliant EDID data
//  structure. If the video miniport detects such a device, it is to extract
//  the edid from the monitor and put that in the paged buffer provided by
//  videoprt.sys in the callback to PVIDEO_HW_GET_CHILD_DESCRIPTOR and return
//  this type in the the OUT PVIDEO_CHILD_TYPE parameter of that call. This
//  EDID, if available, will be written to the registry. If the EDID is not
//  available, nothing should be put in the buffer.
//
//  'NonPrimaryChip' identifies another VGA chip on the video board which
//  is not the primary VGA chip. This type is to be used if and only if the
//  miniport detects more than one VGA chip on the board. Such an identifier
//  will cause the videoprt to create another DEVICE_EXTENSION and associated
//  HW_DEVICE_EXTENSION to be associated with the chip so identified.
//
//  'Other' identifies some other video device attached to the video card. If
//  the miniport detects such a device, it is to put a wide char string
//  (WSTR) into the paged buffer provided by the videoprt.sys which is the
//  PNP hardware identifier of the device. This string will be used to create
//  a value of that name in the registry.
//

typedef enum {
    Monitor = 1,
    NonPrimaryChip,
    VideoChip,
    Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

//
//  define a constant that represents the display adapter self query.
//

#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

typedef struct _VIDEO_CHILD_STATE {
    ULONG   Id;
    ULONG   State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;
    
typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
    ULONG             Count;
    VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

//
//  The following routine should return TRUE if successful. It should:
//      1)  put the type of the child device in VideoChildType.
//      2)  put the information from the device in Buffer. This
//          buffer is of size 256 bytes. If the type returned in
//          PVideoChildType is Monitor, this buffer must contain the
//          EDID of the monitor if readable. If the type returned in
//          PVideoChildType is Other, a wide character string representing
//          the PNP Device Id must be put in the buffer. This string will
//          be used to create a key for the device if the buffer contains
//          an EDID. Otherwise, it is used to obtain a PNP ID for the
//          device.
//      3)  Put a miniport determined HANDLE in HwId. This value will be
//          passed back to the miniport for Power management operations,
//          as well as other operations. This allows the miniport to define
//          the contract between the system and the miniport which defines a
//          particular device.
//
//  It should  only return FALSE if there are no devices attached to that
//  display adapter connector.
//

typedef
ULONG
(*PVIDEO_HW_GET_CHILD_DESCRIPTOR) (
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PUCHAR                  pChildDescriptor,
    OUT PULONG                  UId,
    OUT PULONG                  pUnused
    );


//
// This routine is used to set the power on the graphics devices.
// These include all the Children enumerated by GET_CHILD_DESCRIPTOR callback
// as well as the graphics adapter itself.
//
// The HwDevice extension represent the adapter instance of the device.
//
// The HwId parameter is the unique ID as returned by the enumeration routine.
// The miniport will only be called to set the power on the devices it
// enumerated, as well as the graphics adapter itself.  A HwId of 0xFFFFFFFF
// will be passed in to identify the graphics adapter itself.
// The miniport driver should never turn off the power to the graphics adapter
// unless specifically request to.
//
// The VideoPowerControl is the level to which the device shold be set.
// The videoport driver will manage these states.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_SET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This routine simply returns whether or not the device can support the
// requested state.
//
// See HW_POWER_SET for a description of the parameters.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_GET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This structure should match the QueryInterface struct defined
// in io.h.
//

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

typedef struct _QUERY_INTERFACE {
    CONST GUID *InterfaceType;
    USHORT Size;
    USHORT Version;
    PINTERFACE Interface;
    PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef
VP_STATUS
(*PVIDEO_HW_QUERY_INTERFACE) (
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

typedef
VP_STATUS
(*PVIDEO_HW_CHILD_CALLBACK) (
    PVOID HwDeviceExtension,
    PVOID ChildDeviceExtension
    );

//
// Entry point for all IOCTL calls made to the miniport driver.
//

typedef
BOOLEAN
(*PVIDEO_HW_START_IO) (
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// The return value determines if the mode was completely programmed (TRUE)
// or if an int10 should be done by the HAL to complete the modeset (FALSE).
//

typedef
BOOLEAN
(*PVIDEO_HW_RESET_HW) (
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// Timer routine called every second.
//

typedef
VOID
(*PVIDEO_HW_TIMER) (
    PVOID HwDeviceExtension
    );


//
// Structure passed by the miniport entry point to the video port
// initialization routine.
//

typedef struct _VIDEO_HW_INITIALIZATION_DATA {

    //
    // Supplies the size of the structure in bytes as determined by sizeof().
    //

    ULONG HwInitDataSize;

    //
    // Indicates the bus type the adapter works with, such as Eisa, Isa, MCA.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Supplies a pointer to the miniport driver's find adapter routine.
    //

    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;

    //
    // Supplies a pointer to the miniport driver's initialization routine.
    //

    PVIDEO_HW_INITIALIZE HwInitialize;

    //
    // Supplies a pointer to the miniport driver's interrupt service routine.
    //

    PVIDEO_HW_INTERRUPT HwInterrupt;

    //
    // Supplies a pointer to the miniport driver's start io routine.
    //

    PVIDEO_HW_START_IO HwStartIO;

    //
    // Supplies the size in bytes required for the miniport driver's private
    // device extension. This storage is used by the miniport driver to hold
    // per-adapter information. A pointer to this storage is provided with
    // every call made to the miniport driver. This data storage is
    // initialized to zero by the port driver.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Supplies the number with which device numbering should be started.
    // The device numbering is used to determine which \DeviceX entry under
    // the \Parameters section in the registry should be used for parameters
    // to the miniport driver.
    // The number is *automatically* incremented when the miniport is called
    // back in it's FindAdapter routine due to an appropriate _Again_
    // parameter.
    //

    ULONG StartingDeviceNumber;


    //
    // New for version 3.5
    //

    //
    // Supplies a pointer to the miniport driver's HwResetHw routine.
    //
    // This function is called when the machine needs to bugchecks (go back
    // to the blue screen).
    //
    // This function should reset the video adapter to a character mode,
    // or at least to a state from which an int 10 can reset the card to
    // a character mode.
    //
    // This routine CAN NOT call int10.
    // It can only call Read\Write Port\Register functions from the port driver.
    //
    // The function must also be completely in non-paged pool since the IO\MM
    // subsystems may have crashed.
    //

    PVIDEO_HW_RESET_HW HwResetHw;

    //
    // Pointer to a timer routine to be called every second.
    //

    PVIDEO_HW_TIMER HwTimer;

    //
    //  Start of 5.0 stuff.
    //

    //
    //  Supplies a pointer to the miniport driver's start dma routine. This routine must
    //  return a HW_DMA_RETURN consistent with it's return behavior.
    //

    PVIDEO_HW_START_DMA HwStartDma;

    //
    //  HW dependent Power management routines.
    //

    PVIDEO_HW_POWER_SET HwSetPowerState;
    PVIDEO_HW_POWER_GET HwGetPowerState;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // enumerate devices physically attached to the graphics adapter.
    //

    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // query external programming interfaces supported in the miniport
    // driver.
    //

    PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;

    //
    // Size of the device extension associated with the display output device.
    // This should only be set (to the approrpiate size) if the miniport driver
    // needs to manage the monitor configuration data separately from the
    // adapter board configuration (example - multiple output graphics devices).
    //

    ULONG HwChildDeviceExtensionSize;

    //
    // Allows the device to report legacy resources that should be
    // associated with the Plug and Play device.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;

    //
    // Number of elements in the legacy resource list.
    //

    ULONG HwLegacyResourceCount;

    //
    // Call this routine to allow a driver to specify it's
    // legacy resources based on its device/vendor id.
    //

    PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;

    //
    // Can HwGetVideoChildDescriptor be called before HwInitialize?
    //

    BOOLEAN AllowEarlyEnumeration;

} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

//
// DDC help routines.
//

typedef
VOID
(*PVIDEO_WRITE_CLOCK_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
VOID
(*PVIDEO_WRITE_DATA_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
BOOLEAN
(*PVIDEO_READ_CLOCK_LINE)(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_READ_DATA_LINE)(
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_WAIT_VSYNC_ACTIVE)(
    PVOID HwDeviceExtension
    );

//
// Data structures used I2C and DDC helper functions.
//

typedef struct _I2C_FNC_TABLE
{
    ULONG                    Size;
    PVIDEO_WRITE_CLOCK_LINE  WriteClockLine;
    PVIDEO_WRITE_DATA_LINE   WriteDataLine;
    PVIDEO_READ_CLOCK_LINE   ReadClockLine;
    PVIDEO_READ_DATA_LINE    ReadDataLine;
    PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
    PVOID                    Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _I2C_CALLBACKS
{
    PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    PVIDEO_READ_DATA_LINE   ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef struct _DDC_CONTROL
{
    ULONG         Size;
    I2C_CALLBACKS I2CCallbacks;
    UCHAR         EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

//
// Types of services exported by the VideoPortQueryServices().
//

typedef enum
{
    VideoPortServicesAGP = 1,
    VideoPortServicesI2C
} VIDEO_PORT_SERVICES;

//
// AGP services interface.
//

typedef struct _VIDEO_PORT_AGP_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    PAGP_FREE_PHYSICAL     AgpFreePhysical;
    PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    ULONGLONG              AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

//
// I2C helper routines exported via VideoPortQueryServices().
//

typedef
BOOLEAN
(*PI2C_START)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_STOP)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_WRITE)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    OUT PUCHAR Buffer,
    IN ULONG Length
    );

//
// I2C services interface.
//

typedef struct _VIDEO_PORT_I2C_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PI2C_START             I2CStart;
    PI2C_STOP              I2CStop;
    PI2C_WRITE             I2CWrite;
    PI2C_READ              I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

//
// Flags that can be passed to VideoPortGetDeviceBase or VideoPortMapMemory.
//

#define VIDEO_MEMORY_SPACE_MEMORY    0x00  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_IO        0x01  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_USER_MODE 0x02  // Memory pointer for application use
#define VIDEO_MEMORY_SPACE_DENSE     0x04  // Mapped dense, linearly (ALPHA)
#define VIDEO_MEMORY_SPACE_P6CACHE   0x08  // P6 MTRR caching (kernel and user)

//
// Define status codes returned by HwGetVideoChildDescriptor()
// miniport enumaration routine.
//
// Note: For backword compatibility reasons these values match
// existing WINERROR codes.
//

//
// Call again (ACPI and non-ACPI devices will be enumerated).
//

#define VIDEO_ENUM_MORE_DEVICES     ERROR_CONTINUE

//
// Stop enumeration.
//

#define VIDEO_ENUM_NO_MORE_DEVICES  ERROR_NO_MORE_DEVICES

//
// Call again, device could not be enumerated.
//

#define VIDEO_ENUM_INVALID_DEVICE   ERROR_INVALID_NAME

//
// Define the bits in VgaStatus.
//

#define DEVICE_VGA_ENABLED          1

//
// Port driver routines called by miniport driver and callbacks.
//

VIDEOPORT_API
VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    );

VIDEOPORT_API
VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
ULONG
VideoPortCompareMemory(
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID HwDeviceExtension,
    IN PVOID DDCControl,
    IN OUT PUCHAR EdidBuffer,
    IN ULONG EdidBufferSize
    );

VIDEOPORT_API
VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

VIDEOPORT_API
VP_STATUS
VideoPortDisableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN PVOID Reserved
    );

VIDEOPORT_API
VOID
VideoPortFreeDeviceBase(
    PVOID HwDeviceExtension,
    PVOID MappedAddress
    );

typedef
VP_STATUS
(*PMINIPORT_QUERY_DEVICE_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

VIDEOPORT_API
PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
UCHAR
VideoPortGetCurrentIrql();

VIDEOPORT_API
PVOID
VideoPortGetDeviceBase(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfUchars,
    UCHAR InIoSpace
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    );

typedef
VP_STATUS
(*PMINIPORT_GET_REGISTRY_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,
    PVOID Context
    );

VIDEOPORT_API
PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

VIDEOPORT_API
ULONG
VideoPortInitialize(
    PVOID Argument1,
    PVOID Argument2,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PVOID HwContext
    );

VIDEOPORT_API
VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    );

VIDEOPORT_API
VOID
VideoPortLogError(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    VP_STATUS ErrorCode,
    ULONG UniqueId
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    );

VIDEOPORT_API
VOID
VideoPortMoveMemory(
    PVOID Destination,
    PVOID Source,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID HwDeviceExtension,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
VOID
(*PMINIPORT_DPC_ROUTINE)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );

VIDEOPORT_API
BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

VIDEOPORT_API
UCHAR
VideoPortReadPortUchar(
    PUCHAR Port
    );

VIDEOPORT_API
USHORT
VideoPortReadPortUshort(
    PUSHORT Port
    );

VIDEOPORT_API
ULONG
VideoPortReadPortUlong(
    PULONG Port
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
UCHAR
VideoPortReadRegisterUchar(
    PUCHAR Register
    );

VIDEOPORT_API
USHORT
VideoPortReadRegisterUshort(
    PUSHORT Register
    );

VIDEOPORT_API
ULONG
VideoPortReadRegisterUlong(
    PULONG Register
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer
  );

VIDEOPORT_API
VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    );

VIDEOPORT_API
ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VIDEOPORT_API
VOID
VideoPortStallExecution(
    ULONG Microseconds
    );

VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

BOOLEAN
VIDEOPORT_API
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VIDEOPORT_API
VOID
VideoPortWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUshort(
    PUSHORT Port,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUlong(
    PULONG Port,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUshort(
    PUSHORT Register,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUlong(
    PULONG Register,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortZeroDeviceMemory(
    PVOID Destination,
    ULONG Length
    );

VIDEOPORT_API
VOID
VideoPortZeroMemory(
    PVOID Destination,
    ULONG Length
    );

//
// DMA support.
// TODO: Move to the separate module -- will be obsolete.
//

VIDEOPORT_API
PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    );

VIDEOPORT_API
PVOID
VideoPortGetCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       DesiredLength,
    IN  ULONG                       Alignment,
    OUT PPHYSICAL_ADDRESS           LogicalAddress,
    OUT PULONG                      pActualLength,
    IN  BOOLEAN                     CacheEnabled
    );

VIDEOPORT_API
VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
    );

VIDEOPORT_API
PDMA
VideoPortDoDma(
    IN      PVOID                   HwDeviceExtension,
    IN      PDMA                    pDma,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pUEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnlockPages(
    PVOID   hwDeviceExtension,
    PDMA    pDma
    );

VIDEOPORT_API
BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID               HwDeviceExtension,
    IN  PDMA                pDmaHandle
    );

VIDEOPORT_API
BOOLEAN
VideoPortCompleteDma(
    IN  PVOID           HwDeviceExtension,
    IN  PDMA            pDmaHandle,
    IN  DMA_EVENT_FLAGS CompletionFlags
    );

VIDEOPORT_API
PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
PVOID
VideoPortGetDmaContext(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetDmaContext(
    IN  PVOID   HwDeviceExtension,
    OUT PDMA    pDma,
    IN  PVOID   InstanceContext
    );

VIDEOPORT_API
ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    );

VIDEOPORT_API
PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent
    );

VIDEOPORT_API
PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    );

//
// TODO: End of move block.
//

#endif // ifndef __VIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvRmStereo.h ===
#ifndef _NVRM_STEREO_H_
#define _NVRM_STEREO_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NvRmStereo.h                                                      *
*		Resource Manager stereo interface structure.						*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:																	*
*		Andrei Osnovich 03/17/2000 Created. 								*
*                                                                           *
\***************************************************************************/

#ifdef	STEREO_SUPPORT

//Flag values that can be ORed in the NV_CFG_STEREO_PARAMS.Flags below
#define STEREOCFG_STEREOACTIVATED   0x00000001
#define STEREOCFG_ELSADDC           0x00000002

// Param Structure
typedef struct {
	unsigned long	Flags;
	unsigned long	EyeDisplayed;
	unsigned long	FlipOffsets[4][2];
} NV_CFG_STEREO_PARAMS, *LPNV_CFG_STEREO_PARAMS;

#endif	//STEREO_SUPPORT

#endif	//_NVRM_STEREO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\rddapi.inc ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         rddapi.inc
;
; Purpose:      This file holds the interface description for both
;               the minivdd and the resman's Register Display Driver
;               API. Register Display Driver is a private API between
;               16bit land and the driver components.
;==============================================================================

; To call the API, set:
; eax = VDD_REGISTER_DISPLAY_DRIVER_INFO  (defined in minivdd.inc)
; ebx = system VM handle
; ecx = one of the equates below
;
; Other register settings depend upon the value in ecx.

; These services are in the RegisterDisplayDriver function in the
; resman. They are services needed by the hardware specific portion
; of the display driver.

MVDD_GET_LOGDEV_SHARED_MEMORY                   EQU     8764FFFFH
MVDD_ALLOC_LINEAR_ADDRESS_SPACE                 EQU     87650000H
MVDD_FREE_LINEAR_ADDRESS_SPACE                  EQU     87650001H
MVDD_COPY_PTES_FOR_LINEAR_RANGE                 EQU     87650002H

; These services are in the RegisterDisplayDriver function in the
; minivdd. They are services needed by the generic portion of the
; display driver.
MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS        EQU     87650003H
MVDD_ALLOC_MEMORY_BLOCK                         EQU     87650004H
MVDD_FREE_MEMORY_BLOCK                          EQU     87650005H
MVDD_REENUMERATE_DEVNODE                        EQU     87650006H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\nvtypes.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvtypes.h> defines common widths used to access hardware in of NVIDIA's *|
|*  Unified Media Architecture (TM).                                         *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVTYPES_INCLUDED
#define NVTYPES_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif



 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */

#if defined(_WIN64)

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef void*              NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#elif _WIN32_WINNT >= 0x0400

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef unsigned __int64   NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#else

typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvV64; /* "void": enumerated or multiple fields   */
typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvU64; /* 0 to 18446744073709551615               */
typedef struct {
 NvU32 low;
 NvS32 high;
}                          NvS64; /* 2^-63 to 2^63-1                         */
typedef struct {
 NvU32 offset;
 NvU16 selector;
 NvU16 reserved;
}                          NvP64; /* 64 bit void pointer                     */

typedef NvU32 NvP64_VALUE_T;
typedef NvU32 NvU64_VALUE_T;

#define NvU64_VALUE(n)    ((n).low)
#define NvP64_VALUE(n)    ((n).offset)
#define NvP64_SELECTOR(n) ((n).selector)

#endif

/* obsolete stuff */
typedef NvV8  V008;
typedef NvV16 V016;
typedef NvV32 V032;
typedef NvV64 V064;
typedef NvU8  U008;
typedef NvU16 U016;
typedef NvU32 U032;
typedef NvU64 U064;
typedef NvS8  S008;
typedef NvS16 S016;
typedef NvS32 S032;
typedef NvS64 S064;
typedef NvP64 P064;
typedef NvF32 F032;
typedef NvF64 F064;
#if defined(MACOS) || defined(macintosh)
// more obsolete stuff
// need to provide these on macos9 and macosX
typedef unsigned long  ULONG;
typedef unsigned long  DWORD;
typedef unsigned char *PUCHAR;
typedef void           VOID;
typedef void          *PVOID;
typedef void          *HANDLE;
#endif

/* polymorphic 64-bit macros */
#if defined(_WIN64)
typedef NvP64 VOID_PTR;
typedef NvU64 NV_UINTPTR_T;
#else
typedef NvU32 VOID_PTR;
typedef NvU32 NV_UINTPTR_T;
#endif

#ifdef __cplusplus
};
#endif
#endif /* NVTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\agp.h ===
//
// Copyright (c) 1998-1999 Microsoft Corporation
//


#ifndef __AGP_INCLUDED__
#define __AGP_INCLUDED__

DEFINE_GUID(GUID_AGP_INTERFACE, 0xd6c9df40, 0xa1a2, 0x11d1, 0x81, 0x15, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

#ifndef GUID_DEFS_ONLY

//
// Temporary Hack...
//

#ifndef IsEqualGUID
#ifdef __cplusplus
    inline int IsEqualGUID(REFGUID guid1, REFGUID guid2)
        {
            return !memcmp(&guid1, &guid2, sizeof(GUID));
        }
#else // !__cplusplus
    #define IsEqualGUID(guid1, guid2) \
        (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif // !__cplusplus
#endif

#define AGP_INTERFACE_VERSION 1

typedef struct _AGP_INTERFACE
{
    USHORT           Size;
    USHORT           Version;
    PVOID            Context;
    PVOID            InterfaceReference;
    PVOID            InterfaceDereference;

    VIDEO_PORT_AGP_SERVICES AgpServices;

} AGP_INTERFACE, *PAGP_INTERFACE;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\sdk\nvidia\inc\stdcall.inc ===
;****************************Public Macro************************************
;
;   ComposeInst Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
;
;       This macro simply concatenates all arguments into one string.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
; Module Name: stdcall.inc
;
; Copyright (c) 1991-1999 Microsoft Corporation
;****************************************************************************
  
;
;****************************************************************************

ComposeInst macro   Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
        &Inst   &p1&p2&p3&p4&p5&p6&p7&p8&p9
endm

;****************************Public Macro************************************
;
;   CountArg    cCount,ArgList
;
;       This macro count the number of arguments in the ArgList and returns
;       the value in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

CountArg    macro   cCount,ArgList

        cCount = 0

        irp arg,<ArgList>
            cCount = cCount+1
        endm
endm

;****************************Public Macro************************************
;
;   RevPush     ArgList,cCount
;
;       This macro pushes the arguments in ArgList in the reverse order
;       and returns the number of arguments in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

RevPush macro   ArgList,cCount
        Local   index,x

        CountArg cCount,<ArgList>

        index  = cCount
        rept    cCount
            x = 0
            irp arg,<ArgList>
                x = x+1
                ife index-x
                    push    arg
                    exitm
                endif
            endm
            index = index-1
        endm
endm

;****************************Public Macro************************************
;
;   The following sections contain calling-convention related macros for:
;
;   PUBLICP     Func,N
;       to define a public label
;
;   EXTRNP      Func,N
;       to define a external near label
;
;   LABELP      Func,N
;       to label an address as a routine entry point
;
;   cProc       Func,N,ArgList
;       to declare a routine header
;
;   ProcName    Name,Func,N
;       to rename a function Func to Name. Using it in conjunction with
;       normal function declaration (with the new name) will solve an error
;       caused by a long parameter list routine that exhausts page width.
;
;   cRet        Func
;       to return from Func routines (declared with cProc or ProcName.)
;
;   endProc     Func
;       to declare the end of routine (declared with cProc or ProcName.)
;
;   endMod      Func
;       to declare the end of module with an entry point at Func (declared
;       with cProc or ProcName.)
;
;   cCall       Func,ArgList
;       to call to a routine--Func--with the arguments pushed on the stack
;
;   ptrCall     Func,ArgList
;       to call through a pointer with the arguments pushed on the stack
;
;   MovAddr     dest,Func,n
;       to move the address of the routine--Func--into dest.
;
;   Note that for the standard calling convention all the function names,
;   Func, are automatically converted to Func@N where N is the number of
;   bytes in the argument list.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

IFNDEF  DOS_PLATFORM
IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for C calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif

endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   ; STD_CALL

ELSE

IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for Pascal calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

cCall   macro   Func,ArgList
        irp arg,<ArgList>
            push    arg
        endm

        call    &Func
endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   : ~STD_CALL
ENDIF   ; DOS_PLATFORM

IFDEF STD_CALL
;****************************************************************************
;
;   This section is used exclusively for the standard calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        ifb    <N>
            public      &Func&@0
        else
            public      &Func&@&N
        endif
endm

EXTRNP  macro   Func,N

        ifb    <N>
            extrn       &Func&@0:NEAR
        else
            extrn       &Func&@&N:NEAR
        endif
endm

LABELP  macro   Func,N

        ifb    <N>
            &Func&@0    LABEL   NEAR
        else
            &Func&@&N   LABEL   NEAR
        endif
endm

ProcName macro  Name,Func,N

        ifb <N>
            cByte&Func   EQU     0
            &Name        EQU     <&Func&@0>
        else
            cByte&Func   EQU     N
            &Name        EQU     <&Func&@&N>
        endif
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret     cByte&Func

endm


endProc macro   Func

        xxx&Func   endp

endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        call    &Func
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        ComposeInst <call>,&Func,<@>,%(Bytes)
endm

MovAddr macro   dest,addr,n

        ComposeInst <mov >,dest,<,offset FLAT:>,addr,<@>,n
endm

ENDIF   ;STD_CALL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\agp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    agp.c

Abstract:

    This is the agp portion of the video port driver.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/


#include "videoprt.h"

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

#pragma alloc_text(PAGE,VpQueryAgpInterface)
#pragma alloc_text(PAGE,AgpReservePhysical)
#pragma alloc_text(PAGE,AgpReleasePhysical)
#pragma alloc_text(PAGE,AgpCommitPhysical)
#pragma alloc_text(PAGE,AgpFreePhysical)
#pragma alloc_text(PAGE,AgpReserveVirtual)
#pragma alloc_text(PAGE,AgpReleaseVirtual)
#pragma alloc_text(PAGE,AgpCommitVirtual)
#pragma alloc_text(PAGE,AgpFreeVirtual)
#pragma alloc_text(PAGE,VideoPortGetAgpServices)
#pragma alloc_text(PAGE,AddRangeToReservedRegion)
#pragma alloc_text(PAGE,RemoveRangeFromReservedRegion)
#pragma alloc_text(PAGE,CreateBitField)
#pragma alloc_text(PAGE,ModifyRegion)
#pragma alloc_text(PAGE,FindFirstRun)

VOID
DumpBitField(
    PREGION Region
    )
{
    ULONG i;
    ULONG Index = 0;
    ULONG Mask = 1;

    for (i=0; i<Region->Length; i++) {
        if (Mask & Region->BitField[Index]) {
            pVideoDebugPrint((1, "1"));
        } else {
            pVideoDebugPrint((1, "0"));
        }
        Mask <<= 1;
        if (Mask == 0) {
            Index++;
            Mask = 1;
        }
    }
    pVideoDebugPrint((1, "\n"));
}

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    )

/*++

Routine Description:

    This routine creates and initializes a bitfield.

Arguments:

    Length - Number of items to track.

    Region - Location in which to store the pointer to the REGION handle.

Returns:

    TRUE - the the bitfield was created successfully, 
    FALSE - otherwise.

--*/

{
    ULONG NumDwords = (Length + 31) / 32;
    BOOLEAN bRet = FALSE;
    PREGION Buffer;

    Buffer = (PREGION) ExAllocatePoolWithTag(PagedPool, sizeof(REGION) + (NumDwords - 1) * sizeof(ULONG), POOL_TAG);

    if (Buffer) {

        Buffer->Length = Length;
        Buffer->NumDwords = NumDwords;
        memset(&Buffer->BitField[0], 0, NumDwords * 4);

        bRet = TRUE;
    }

    *Region = Buffer;
    return bRet;
}

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    )

/*++

Routine Description:

    Sets 'Length' bits starting at position 'Offset' in the bitfield.

Arguments:

    Region - Pointer to the region to modify.

    Offset - Offset into the bitfield at which to start.

    Length - Number of bits to set.

    Set - TRUE if you want to set the region, FALSE to clear it.


--*/

{
    ULONG Index = Offset / 32;
    ULONG Count = ((Offset + Length - 1) / 32) - Index;
    ULONG lMask = ~((1 << (Offset & 31)) - 1);
    ULONG rMask = ((1 << ((Offset + Length - 1) & 31)) * 2) - 1;
    PULONG ptr = &Region->BitField[Index];

    ASSERT(Length != 0);

    if (Count == 0) {

        //
        // Only one DWORD is modified, so combine left and right masks.
        //

        lMask &= rMask;
    }

    if (Set) {

        *ptr++ |= lMask;

        while (Count > 1) {
            *ptr++ |= 0xFFFFFFFF;
            Count--;
        }

        if (Count) {
            *ptr |= rMask;
        }

    } else {

        *ptr++ &= ~lMask;

        while (Count > 1) {
            *ptr++ &= 0;
            Count--;
        }

        if (Count) {
            *ptr++ &= ~rMask;
        }
    }

#if DBG
    pVideoDebugPrint((1, "Current BitField for Region: 0x%x\n", Region));
    DumpBitField(Region);
#endif
}

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    )

/*++

Routine Description:

    This routine finds the first run of bits in a bitfield.

Arguments:

    Region - Pointer to the region to operate on.

    Offset - Pointer to a ULONG to hold the offset of the run.

    Length - Pointer to a ULONG to hold the length of a run.

Returns:

    TRUE if a run was detected,
    FALSE otherwise.

--*/

{
    PULONG ptr = Region->BitField;
    ULONG Index = 0;
    ULONG BitMask;
    ULONG lsb;
    ULONG Count;
    ULONG ptrVal;

    while ((Index < Region->NumDwords) && (*ptr == 0)) {
        ptr++;
        Index++;
    }

    if (Index == Region->NumDwords) {
        return FALSE;
    }

    //
    // Find least significant bit
    //

    lsb = 0;
    ptrVal = *ptr;
    BitMask = 1;

    while ((ptrVal & BitMask) == 0) {
        BitMask <<= 1;
        lsb++;
    }

    *Offset = (Index * 32) + lsb;

    //
    // Determine the run length
    //

    Count = 0;

    while (Index < Region->NumDwords) {
        if (ptrVal & BitMask) {
            BitMask <<= 1;
            Count++;

            if (BitMask == 0) {
                BitMask = 0x1;
                Index++;
                ptrVal = *++ptr;
                while ((ptrVal == 0xFFFFFFFF) && (Index < Region->NumDwords)) {
                    Index++;
                    Count += 32;
                    ptrVal = *ptr++;
                }
            }

        } else {
            break;
        }
    }

    *Length = Count;
    return TRUE;
}

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent (the PCI bus driver) to
    retrieve the AGP_BUS_INTERFACE.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return FALSE;
    }

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set the default error code.
    //

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_AGP_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->AgpInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->AgpInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    FdoExtension->AgpInterface.Version = 1;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return NT_SUCCESS(Status);
}

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    Pages - Number of pages to reserve

    Caching - Specifies the type of caching to use

    PhysicalReserveContext - Location to store our reservation context.

Returns:

    The base of the physical address range reserved.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS PhysicalAddress = {0,0};
    NTSTATUS status;
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PVOID MapHandle;

    pVideoDebugPrint((1, "AGP: Reserving 0x%x Pages of Address Space\n", Pages));

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(PHYSICAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(Pages, &ReserveContext->Region)) {

            status = fdoExtension->AgpInterface.ReserveMemory(
                         fdoExtension->AgpInterface.AgpContext,
                         Pages,
                         Caching ? MmWriteCombined : MmNonCached,
                         &MapHandle,
                         &PhysicalAddress);

            if (NT_SUCCESS(status)) {

                ReserveContext->Pages = Pages;
                ReserveContext->Caching = Caching;
                ReserveContext->MapHandle = MapHandle;
                ReserveContext->PhysicalAddress = PhysicalAddress;

            } else {

                ExFreePool(ReserveContext->Region);
                goto FailureCase;
            }

        } else {

            goto FailureCase;
        }
    }

    *PhysicalReserveContext = ReserveContext;
    return PhysicalAddress;

FailureCase:

    PhysicalAddress.QuadPart = 0;
    ExFreePool(ReserveContext);
    *PhysicalReserveContext = NULL;

    return PhysicalAddress;
}

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of reserved physical address.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    ULONG Pages;
    ULONG Offset;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    pVideoDebugPrint((1, "AGP: Releasing 0x%x Pages of Address Space\n", ReserveContext->Pages));

    //
    // Make sure all pages have been freed
    //

    while (FindFirstRun(ReserveContext->Region, &Offset, &Pages)) {
        AgpFreePhysical(Context, PhysicalReserveContext, Pages, Offset);
    }

    fdoExtension->AgpInterface.ReleaseMemory(fdoExtension->AgpInterface.AgpContext,
                                             ReserveContext->MapHandle);

    ExFreePool(ReserveContext->Region);
    ExFreePool(ReserveContext);
}

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS MemoryBase = {0,0};
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    NTSTATUS status;
    PMDL Mdl;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    status =
        fdoExtension->AgpInterface.CommitMemory(fdoExtension->AgpInterface.AgpContext,
                                                ReserveContext->MapHandle,
                                                Pages,
                                                Offset,
                                                NULL,
                                                &MemoryBase);

    if (NT_SUCCESS(status)) {

        ModifyRegion(ReserveContext->Region, Offset, Pages, TRUE);
        return TRUE;

    } else {

        return FALSE;
    }
}

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PMDL Mdl;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    fdoExtension->AgpInterface.FreeMemory(fdoExtension->AgpInterface.AgpContext,
                                          ReserveContext->MapHandle,
                                          Pages,
                                          Offset);

    ModifyRegion(ReserveContext->Region, Offset, Pages, FALSE);
}


PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    )

/*++

Routine Description:

    Reserves a range of virtual addresses for AGP.

Arguments:

    Context - The Agp Context

    ProcessHandle - The handle of the process in which to reserve the
        virtual address range.

    PhysicalReserveContext - The physical reservation context to assoctiate
        with the given virtual reservation.

    VirtualReserveContext - The location in which to store the virtual
        reserve context.

Returns:

    The base of the virtual address range reserved.

Notes:

    You can't reserve a range of kernel address space, but if you want to
    commit into kernel space you still need a reservation handle.  Pass in
    NULL for the process handle in this case.

    For the moment, we'll commit the entire region when the do a reservation
    in kernel space.  Then Commit and Free will be no-ops.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Protect = PAGE_READWRITE;
    PVIRTUAL_RESERVE_CONTEXT ReserveContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    SIZE_T Length;
    PVOID VirtualAddress = NULL;
    PEPROCESS Process = NULL;

    PhysicalContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    Length = PhysicalContext->Pages * PAGE_SIZE;

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(VIRTUAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(PhysicalContext->Pages, &ReserveContext->Region)) {

            //
            // BUGBUG: Fix this routine for kernel mode reservation!
            //

            if (!PhysicalContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            //
            // Make sure we have the real process handle.
            //

            if (ProcessHandle == NtCurrentProcess()) {
                Process = PsGetCurrentProcess();
            }

            ReserveContext->ProcessHandle = ProcessHandle;
            ReserveContext->Process = Process;
            ReserveContext->PhysicalReserveContext =
                (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
            ReserveContext->ReservationList = NULL;

            if (ProcessHandle) {

                VirtualAddress =
                    AddRangeToReservedRegion(ReserveContext,
                                             PhysicalContext->Pages,
                                             0);

                ASSERT(VirtualAddress != NULL);

            } else {

                //
                // BUGBUG: Find a better way to reserve in kernel space.
                //
                // For a kernel reservation, go ahead and commit the
                // entire range.
                //

                if (fdoExtension->AgpInterface.Capabilities &
                    AGP_CAPABILITIES_MAP_PHYSICAL)
                {
                    //
                    // CPU can access AGP memory through AGP aperature.
                    //

                    VirtualAddress =
                        MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                     PhysicalContext->Pages * PAGE_SIZE,
                                     PhysicalContext->Caching ? MmFrameBufferCached : 0);
                    //
                    // Not all systems support USWC, so if we attempted to map USWC
                    // and failed, try again with just non-cached.
                    //
                    if ((VirtualAddress == NULL) &&
                        (PhysicalContext->Caching)) {
                        VirtualAddress = MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                                      PhysicalContext->Pages * PAGE_SIZE,
                                                      MmNonCached);
                    }

                } else {

                    PMDL Mdl;

                    //
                    // Get the MDL for the range we are trying to map.
                    //

                    Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

                    if (Mdl) {

                        fdoExtension->AgpInterface.GetMappedPages(
                                         fdoExtension->AgpInterface.AgpContext,
                                         PhysicalContext->MapHandle,
                                         PhysicalContext->Pages,
                                         0,
                                         Mdl);

                        //
                        // We must use the CPU's virtual memory mechanism to
                        // make the non-contiguous MDL look contiguous.
                        //

                        VirtualAddress =
                            MmMapLockedPagesSpecifyCache(
                                Mdl,
                                (KPROCESSOR_MODE)KernelMode,
                                PhysicalContext->Caching ? MmCached : MmNonCached,
                                NULL,
                                TRUE,
                                HighPagePriority);

                        ExFreePool(Mdl);
                    }
                }
            }

            ReserveContext->VirtualAddress = VirtualAddress;

        } else {

            pVideoDebugPrint((1, "Couldn't create bit field.\n"));
            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }

    } else {

        pVideoDebugPrint((1, "AgpReserveVirtual: Out of memory.\n"));
    }

    *VirtualReserveContext = ReserveContext;
    return VirtualAddress;
}

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    SIZE_T Length;
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    ULONG Offset;
    ULONG Pages;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure all pages have been freed
        //

        while (FindFirstRun(VirtualContext->Region, &Offset, &Pages)) {
            AgpFreeVirtual(Context, VirtualReserveContext, Pages, Offset);
        }

        if (VirtualContext->VirtualAddress) {

            ASSERT(VirtualContext->ReservationList->Next == NULL);

            RemoveRangeFromReservedRegion(VirtualContext,
                                          VirtualContext->ReservationList->Pages,
                                          VirtualContext->ReservationList->Offset);

            if (VirtualContext->ReservationList) {

                ExFreePool(VirtualContext->ReservationList);
                VirtualContext->ReservationList = NULL;
            }
        }

        ExFreePool(VirtualContext->Region);
        ExFreePool(VirtualContext);

    } else {

        //
        // This was kernel virtual memory, so release the memory we
        // committed at reserve time.
        //

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            MmUnmapIoSpace(VirtualContext->VirtualAddress,
                           PhysicalContext->Pages * PAGE_SIZE);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                PhysicalContext->Pages,
                                0,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualContext->VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }
    }
}

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Adds a range to a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    NTSTATUS Status;
    PRESERVATION_LIST Curr, Prev = NULL;

    pVideoDebugPrint((1, "AddPagesToReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    if (VirtualContext->ReservationList) {

        //
        // We are making the assumption that if range is added, and we
        // already have a reservation list, that we had removed a region
        // because we mapped it, and now we are adding it back.  So we
        // should be able to scan for a region, and just set the
        // reserved bit to TRUE.  We can then concatinate with existing
        // right or left regions.
        //

        Curr = VirtualContext->ReservationList;

        while (Curr) {

            if (Curr->Offset == Offset)
                break;

            Prev = Curr;
            Curr = Curr->Next;
        }

        pVideoDebugPrint((1, "Region to Reserve:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        //
        // If the region is already reserved, simply return.
        //

        if (Curr->Reserved == TRUE) {
            pVideoDebugPrint((1, "Region is already reserved!\n"));
            return NULL;
        }

        //
        // If there is still an allocation in this region, then return.
        //

        if (--Curr->RefCount) {
            pVideoDebugPrint((1, "Region is still in use.\n"));
            return NULL;
        }

        pVideoDebugPrint((1, "Marking region as reserved.\n"));

        Curr->Reserved = TRUE;

        //
        // See if we can concatinate with the left or right region.
        //

        if (Prev && (Prev->Reserved)) {

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Prev->Offset * PAGE_SIZE);
            Length = Prev->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with previous range.\n"));

            Prev->Pages += Curr->Pages;
            Prev->Next = Curr->Next;

            ExFreePool(Curr);

            Curr = Prev;
        }

        if (Curr->Next && (Curr->Next->Reserved)) {

            PRESERVATION_LIST Next = Curr->Next;

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Next->Offset * PAGE_SIZE);
            Length = Next->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with next range.\n"));

            Curr->Pages += Next->Pages;
            Curr->Next = Next->Next;

            ExFreePool(Next);
        }

        pVideoDebugPrint((1, "Expanded Region:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);

    } else {

        //
        // Indicate we don't care where we reserve from.
        //

        VirtualAddress = NULL;

        Curr = ExAllocatePoolWithTag(PagedPool,
                                     sizeof(RESERVATION_LIST),
                                     POOL_TAG);

        if (Curr) {

            Curr->Offset   = Offset;
            Curr->Pages    = Pages;
            Curr->RefCount = 0;
            Curr->Reserved = TRUE;
            Curr->Next     = NULL;

            VirtualContext->ReservationList = Curr;

        } else {

            return NULL;
        }
    }

    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Reserving 0x%x bytes at virtual address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    Status = ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                            &VirtualAddress,
                                            0,
                                            &Length,
                                            MEM_RESERVE,
                                            Protect);

    if (!NT_SUCCESS(Status)) {

        pVideoDebugPrint((1, "Status = 0x%x\n", Status));
        ASSERT(FALSE);
        return NULL;
    }

    return VirtualAddress;
}

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Release a sub range of a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PRESERVATION_LIST ReservationList, Curr, Prev = NULL;
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    ULONG_PTR Address, ExcessPages;

    pVideoDebugPrint((1, "RemovePagesFromReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    ASSERT(VirtualContext->ReservationList != NULL);

    Curr = VirtualContext->ReservationList;

    while (Curr) {

        if ((Curr->Offset <= Offset) &&
            ((Curr->Offset + Curr->Pages) > Offset)) {

            break;
        }

        Prev = Curr;
        Curr = Curr->Next;
    }

    pVideoDebugPrint((1, "Range to fill into:\n"
                         "  Offset: 0x%x\n"
                         "  Pages: 0x%x\n",
                         Curr->Offset,
                         Curr->Pages));


    ASSERT(Curr != NULL);

    //
    // If the region is already free, simply return.
    //

    if (Curr->Reserved == FALSE) {
        Curr->RefCount++;
        return;
    }

    //
    // Release the region which we are mapping into.
    //

    VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);
    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                        &VirtualAddress,
                                        &Length,
                                        MEM_RELEASE)))
    {
        ASSERT(FALSE);
    }

    //
    // Mark the region as not reserved.
    //

    Curr->Reserved = FALSE;
    Curr->RefCount++;

    //
    // Now see if we have sub regions to re-reserve.
    //

    if (Curr->Offset < Offset) {

        //
        // There will be a left over region prior to Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset;
            ReservationList->Pages = Offset - Curr->Offset;
            ReservationList->RefCount = 0;
            ReservationList->Next = Curr;
            ReservationList->Reserved = TRUE;

            Curr->Pages -= Offset - Curr->Offset;
            Curr->Offset = Offset;

        } else {

            return;
        }

        if (Prev) {
            Prev->Next = ReservationList;
        } else {
            VirtualContext->ReservationList = ReservationList;
        }

        pVideoDebugPrint((1, "Creating 'left' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));

        //
        // Calculate the virtual address and length of the memory to reserve.
        // Note that ZwAllocateVirtualMemory always rounds to a 64K boundary,
        // so we'll have to round up to prevent it from rounding down.
        //

        Address = ((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        VirtualAddress = (PULONG)Address;

        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    if (Curr->Pages > Pages) {

        //
        // There will be a left over region after Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset + Pages;
            ReservationList->Pages = Curr->Pages - Pages;
            ReservationList->RefCount = 0;
            ReservationList->Reserved = TRUE;

            Curr->Pages = Pages;

        } else {

            //
            // BUGBUG:
            //
            // If we return here then we have to adjacent blocks
            // which are both reserved.  This will not cause a
            // problem, but it will never be cleaned up.
            //

            return;
        }

        pVideoDebugPrint((1, "Creating 'right' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));


        ReservationList->Next = Curr->Next;
        Curr->Next = ReservationList;

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    return;
}

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    The virtual address for the base of the commited pages.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress = NULL;
    HANDLE PhysicalMemoryHandle;
    NTSTATUS ntStatus;
    BOOLEAN bUserMode;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    PhysicalAddress = PhysicalContext->PhysicalAddress;
    PhysicalAddress.LowPart += Offset * PAGE_SIZE;

    bUserMode = VirtualContext->ProcessHandle != NULL;

    if (bUserMode) {

        //
        // First release the VA range we are going to map into.
        //

        RemoveRangeFromReservedRegion(VirtualContext,
                                      Pages,
                                      Offset);

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            //
            // CPU can access AGP memory through AGP aperature.
            //

            //
            // Get a handle to the physical memory section using our pointer.
            // If this fails, return.
            //

            ntStatus =
                ObOpenObjectByPointer(
                    PhysicalMemorySection,
                    0L,
                    (PACCESS_STATE) NULL,
                    SECTION_ALL_ACCESS,
                    (POBJECT_TYPE) NULL,
                    KernelMode,
                    &PhysicalMemoryHandle);

            //
            // If successful, map the memory.
            //

            if (NT_SUCCESS(ntStatus)) {

                SIZE_T Length = Pages * PAGE_SIZE;
                ULONG Protect = PAGE_READWRITE;

                VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

                if (!PhysicalContext->Caching) {
                    Protect |= PAGE_NOCACHE;
                }

                ntStatus =
                    ZwMapViewOfSection(
                        PhysicalMemoryHandle,
                        VirtualContext->ProcessHandle,
                        &VirtualAddress,
                        0,
                        Pages * PAGE_SIZE,
                        &PhysicalAddress,
                        &Length,
                        ViewUnmap,
                        0,
                        Protect);

                pVideoDebugPrint((1, "ntStatus = 0x%x\n", ntStatus));

                ZwClose(PhysicalMemoryHandle);

            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                 fdoExtension->AgpInterface.AgpContext,
                                 PhysicalContext->MapHandle,
                                 Pages,
                                 Offset,
                                 Mdl);

                //
                // We must use the CPU's virtual memory mechanism to
                // make the non-contiguous MDL look contiguous.
                //

                VirtualAddress =
                    MmMapLockedPagesSpecifyCache(
                        Mdl,
                        (KPROCESSOR_MODE)UserMode,
                        PhysicalContext->Caching ? MmCached : MmNonCached,
                        (PVOID)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE),
                        TRUE,
                        HighPagePriority);

                ExFreePool(Mdl);
            }
        }

        if (VirtualAddress) {
            ModifyRegion(VirtualContext->Region, Offset, Pages, TRUE);
        }

    } else {

        //
        // Kernel mode commit.  Do nothing.
        //

        VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);
    }

    return VirtualAddress;
}

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Frees a range of virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    VirtualAddress = (PUCHAR)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

    //
    // Make sure we are in the correct process context.
    //

    if (VirtualContext->ProcessHandle != NULL) {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

                ZwUnmapViewOfSection(
                    VirtualContext->ProcessHandle,
                    VirtualAddress);

            } else {

                MmUnmapIoSpace(VirtualAddress,
                               Pages * PAGE_SIZE);
            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                Pages,
                                Offset,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }

        if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

            AddRangeToReservedRegion(VirtualContext,
                                     Pages,
                                     Offset);
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, FALSE);

    } else {

        //
        // Kernel Space Free - do nothing.
        //
    }
}

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    OUT PVIDEO_PORT_AGP_SERVICES AgpServices
    )

/*++

Routine Description:

    This routine returns a set of AGP services to the caller.

Arguments:

    HwDeviceExtension - Pointer to the miniports device extension

    AgpServices - A buffer in which to place the AGP services.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    SYSTEM_BASIC_INFORMATION basicInfo ;
    NTSTATUS status;

    //
    // This entry point is only valid for PnP Drivers.
    //

    if ((fdoExtension->Flags & LEGACY_DRIVER) == 0) {

        if (VpQueryAgpInterface(fdoExtension)) {

            //
            // Fill in the list of function pointers.
            //

            AgpServices->AgpReservePhysical = AgpReservePhysical;
            AgpServices->AgpCommitPhysical  = AgpCommitPhysical;
            AgpServices->AgpFreePhysical    = AgpFreePhysical;
            AgpServices->AgpReleasePhysical = AgpReleasePhysical;

            AgpServices->AgpReserveVirtual  = AgpReserveVirtual;
            AgpServices->AgpCommitVirtual   = AgpCommitVirtual;
            AgpServices->AgpFreeVirtual     = AgpFreeVirtual;
            AgpServices->AgpReleaseVirtual  = AgpReleaseVirtual;

	    status = ZwQuerySystemInformation (SystemBasicInformation,
					       &basicInfo,
					       sizeof(basicInfo),
					       NULL) ;
	    if (!NT_SUCCESS(status)) {
		pVideoDebugPrint((0, "VIDEOPRT: Failed AGP system information.\n"));
		return FALSE ;
	    }

	    AgpServices->AllocationLimit = (basicInfo.NumberOfPhysicalPages *
					    basicInfo.PageSize) / 8 ;

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        pVideoDebugPrint((1, "VideoPortGetAgpServices - only valid on PnP drivers\n"));
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\ddc.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This is the NT Video port Display Data Channel (DDC) code. It contains the
    implementations for the EDID industry standard Extended Display
    Identification Data manipulations.

Author:

    Bruce McQuistan (brucemc) 23-Sept-1996

Environment:

    kernel mode only

Notes:

    Based on VESA EDID Specification Version 2, April 9th, 1996
    Updated to support VESA E-DDC Proposed Standard Version 1P, July 13, 1999.

--*/

#include "videoprt.h"

//
// Make it easy to change debug verbosity.
//

#define DEBUG_DDC                   1

//
// Define constants used by DDC.
//

#define EDID_1_SIZE                 128
#define EDID_2_SIZE                 256
#define EDID_QUERY_RETRIES          5
#define DDC_ADDRESS_SET_OFFSET      (UCHAR)0xA0    // To set word offset into EDID
#define DDC_ADDRESS_READ            (UCHAR)0xA1    // To read EDID
#define DDC_ADDRESS_PD_SET_OFFSET   (UCHAR)0xA2    // As above for display with P&D connector
#define DDC_ADDRESS_PD_READ         (UCHAR)0xA3    // As above for display with P&D connector
#define DDC_ADDRESS_SET_SEGMENT     (UCHAR)0x60    // To set index to 256 bytes EDID segment

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VideoPortDDCMonitorHelper)
#pragma alloc_text (PAGE, DDCReadEdidSegment)
#endif  // ALLOC_PRAGMA

//
// Exported routines.
//

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID pHwDeviceExtension,
    IN PVOID pDDCControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize
    )

/*++

Routine Description:

    This routine reads the EDID structure from the monitor using DDC.

    If caller asks for 256 bytes he may receive:
        1. One 128 bytes EDID
        2. Two 128 bytes EDIDs
        3. One 256 bytes EDID (from P&D display)
        4. No EDID

    Caller should always ask for 256 bytes, since it is impossble to
    read second 128 bytes block of the segment only.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pDDCControl        - DDC access control block.
    pucEdidBuffer      - Buffer where information will be stored.
                         For ACPI devices first four bytes are preset by
                         the videoprt to indicated attempt to read the EDID.
                         We should clear those bytes in case of the EDID
                         read failure to prevent videoprt from unnecessary
                         call of the ACPI method.
    ulEdidBufferSize   - Size of the buffer to fill.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulChecksum;                   // EDID checksum
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter
    ULONG ulSize;                       // EDID size to read
    UCHAR ucEdidSegment;                // E-DDC segment to read
    BOOLEAN bEnhancedDDC;               // Use enhanced DDC flag
    PI2C_CALLBACKS pI2CCallbacks;       // I2C lines handling functions

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pDDCControl);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // Check the size of the input structure.
    //

    if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (I2C_FNC_TABLE))
    {
        ucEdidSegment = 0;
        bEnhancedDDC  = FALSE;      // Make sure we are backword compatible
    }
    else if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (DDC_CONTROL))
    {
        ucEdidSegment = ((PDDC_CONTROL)pDDCControl)->EdidSegment;
        bEnhancedDDC  = TRUE;
    }
    else
    {
        pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Invalid DDC_CONTROL\n"));
        ASSERT(FALSE);
        return FALSE;
    }

    pI2CCallbacks = (PI2C_CALLBACKS)&(((PDDC_CONTROL)pDDCControl)->I2CCallbacks);

    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);

    //
    // Initialize I2C lines and switch monitor to DDC2 mode only for the first EDID.
    // This is the most time consuming operation, we don't want to repeat it.
    // We can safely assume we'll be always asked for the segment 0 first.
    // Once switched to DDC2 the monitor will stay in that mode.
    //

    if (0 == ucEdidSegment)
    {
        //
        // Initialize SDA and SCL lines to default state of released high (input).
        //

        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(5);
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(5);

        //
        // Send 9 clock pulses on SCL to switch DDC2-capable monitor to DDC2 mode.
        //

        for (ulScratch = 0; ulScratch < 9; ulScratch++)
        {
            pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);
            DELAY_MICROSECONDS(5);
            pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);
            DELAY_MICROSECONDS(5);
        }

        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Can't switch to DDC2\n"));
            RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
            return FALSE;
        }
    }

    //
    // Using A0/A1 we can read two 128 byte EDIDs. If we are asked for a bigger size
    // we will do two reads.
    //

    ulSize = ulEdidBufferSize > EDID_1_SIZE ? EDID_1_SIZE : ulEdidBufferSize;

    if (DDCReadEdidSegment(pHwDeviceExtension,
                           pI2CCallbacks,
                           pucEdidBuffer,
                           ulSize,
                           ucEdidSegment,
                           0x00,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC) == TRUE)
    {
        if (ulEdidBufferSize <= EDID_1_SIZE)
        {
            return TRUE;
        }

        ulSize = ulEdidBufferSize - EDID_1_SIZE;

        //
        // We can read maximum two EDIDs per segment - make sure our size is correct.
        //

        if (ulSize > EDID_1_SIZE)
        {
            ulSize = EDID_1_SIZE;
        }

        //
        // We don't care about return code here - we've already got first EDID,
        // and it is possible the second one doesn't exist.
        //

        DDCReadEdidSegment(pHwDeviceExtension,
                           pI2CCallbacks,
                           pucEdidBuffer + EDID_1_SIZE,
                           ulSize,
                           ucEdidSegment,
                           0x80,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC);

        return TRUE;
    }

    //
    // Check for P&D 256 EDID at A2/A3 only for segment 0.
    //

    if (0 != ucEdidSegment)
        return FALSE;

    //
    // P&D display is a special case - its 256 bytes EDID can be accessed using
    // A2/A3 or using segment 1 and A0/A1. We shoudn't read its EDID twice though
    // since we're going to use A2/A3 only if we can't read segment 0 using A0/A1,
    // which most likely means that there are no multiple EDIDs.
    //
    // Note: In this case we don't want to program E-DDC segment, so we just
    // always force bEnhancedDDC to FALSE.
    //

    return DDCReadEdidSegment(pHwDeviceExtension,
                              pI2CCallbacks,
                              pucEdidBuffer,
                              ulEdidBufferSize,
                              ucEdidSegment,
                              0x00,
                              DDC_ADDRESS_PD_SET_OFFSET,
                              DDC_ADDRESS_PD_READ,
                              FALSE);
}   // VideoPortDDCMonitorHelper()

//
// Local routines.
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    )

/*++

Routine Description:

    This routine reads the EDID structure at given segment.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C lines control functions.
    pucEdidBuffer      - Buffer where information will be stored.
    ulEdidBufferSize   - Size of the buffer to fill.
    ucEdidSegment      - 256 bytes EDID segment to read.
    ucEdidOffset       - Offset within the segment.
    ucSetOffsetAddress - DDC command.
    ucReadAddress      - DDC command.
    bEnhancedDDC       - TRUE if we want to use 0x60 for segment addressing.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulTry = 0; ulTry < EDID_QUERY_RETRIES; ulTry++)
    {
        RtlZeroMemory(pucEdidBuffer, ulEdidBufferSize);

        //
        // Set EDID segment for E-DDC.
        //

        if (TRUE == bEnhancedDDC)
        {
            if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
            {
                I2CStop(pHwDeviceExtension, pI2CCallbacks);
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
                continue;
            }

            pucEdidBuffer[0] = DDC_ADDRESS_SET_SEGMENT;
            pucEdidBuffer[1] = ucEdidOffset;

            if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 2) == FALSE)
            {
                //
                // For segment 0 we don't care about return code here since monitor
                // may not support E-DDC.
                //

                if (0 != ucEdidSegment)
                {
                    I2CStop(pHwDeviceExtension, pI2CCallbacks);
                    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
                    continue;
                }
            }
        }

        if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Set offset to read from.
        //

        pucEdidBuffer[0] = ucSetOffsetAddress;
        pucEdidBuffer[1] = ucEdidOffset;

        if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 2) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Tell the monitor that we want to read EDID.
        //

        pucEdidBuffer[0] = ucReadAddress;

        if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 1) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        //
        // Read EDID from the monitor.
        //

        if (I2CRead(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, ulEdidBufferSize) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C read\n"));
            continue;
        }

        I2CStop(pHwDeviceExtension, pI2CCallbacks);

        //
        // Calculate the EDID checksum in case when we read full EDID.
        // We should have 0x00 in LSB for proper EDID.
        //

        if (((EDID_1_SIZE == ulEdidBufferSize) && ((0x00 == ucEdidOffset) || (0x80 == ucEdidOffset))) ||
            ((EDID_2_SIZE == ulEdidBufferSize) && (0x00 == ucEdidOffset)))
        {
            ULONG ulChecksum = 0;

            for (ulScratch = 0; ulScratch < ulEdidBufferSize; ulScratch++)
                ulChecksum += pucEdidBuffer[ulScratch];
  
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: EDID checksum = 0x%08X\n", ulChecksum));

            if (((ulChecksum & 0xFF) == 0) && (0 != ulChecksum))
            {
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Full EDID read OK\n"));
                return TRUE;
            }

            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Invalid checksum\n"));
        }
        else
        {
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Partial EDID read OK\n"));
            return TRUE;
        }
    }

    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed\n"));
    RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
    return FALSE;
}   // DDCReadEdidSegment()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\i2c.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    i2c.c

Abstract:

    This is the NT Video port I2C helper code.

Author:

    Michael Maciesowicz (mmacie) 03-Sept-1999

Environment:

    kernel mode only

Notes:

--*/

#include "videoprt.h"

//
// Make it easy to change debug verbosity.
//

#define DEBUG_I2C               1

//
// Define constants used by I2C.
//

#define I2C_START_RETRIES       10
#define I2C_SCL_READ_RETRIES    10
#define I2C_DELAY()             DELAY_MICROSECONDS(5)

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, I2CStart)
#pragma alloc_text (PAGE, I2CStop)
#pragma alloc_text (PAGE, I2CWrite)
#pragma alloc_text (PAGE, I2CRead)
#pragma alloc_text (PAGE, I2CWriteByte)
#pragma alloc_text (PAGE, I2CReadByte)
#pragma alloc_text (PAGE, I2CWaitForClockLineHigh)
#endif  // ALLOC_PRAGMA

//
// Routines exported via VideoPortQueryServices().
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine starts I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Start OK.
    FALSE - Start failed.

--*/

{
    ULONG ulRetry;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications start signal is a SDA high->low while the SCL is high.
    //

    for (ulRetry = 0; ulRetry <= I2C_START_RETRIES; ulRetry++)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);           // Set SDA high
        I2C_DELAY();
        if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) == FALSE)  // SDA didn't take - ulRetry
            continue;
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);          // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStart: SCL didn't take\n"));
            break;
        }
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);           // Set SDA low
        I2C_DELAY();
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);          // Set SCL low
        I2C_DELAY();
        return TRUE;
    }

    pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStart: Failed\n"));
    return FALSE;
}   // I2CStart()

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine stops I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Stop OK.
    FALSE - Stop failed.

--*/

{
    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications stop signal is a SDA low->high while the SCL is high.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);               // Set SDA low
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);              // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStop: SCL didn't take\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);               // Set SDA high
    I2C_DELAY();
    if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) != 1)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStop: SDA didn't take\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CStop()

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine writes data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to data to be written.
    ulLength           - Number of bytes to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (I2CWriteByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer[ulCount]) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}   // I2CWrite()

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine reads data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    ulLength           - Number of bytes to read.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // On all but the last byte, we must send an ACK in order to ensure that the sending device will
    // send subsequent data bytes. On the last byte, we must send a NAK so that it will shut up.
    //

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (ulLength - 1 == ulCount)
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, FALSE) == FALSE)  // Last byte
            {
                return FALSE;
            }
        }
        else
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, TRUE) == FALSE)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}   // I2CRead()

//
// Local routines.
//

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    )

/*++

Routine Description:

    This routine writes byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    ucByte             - Byte to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    LONG lShift;
    UCHAR ucAck;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    //
    // Bits are transmitted serially starting with the MSB.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        //
        // Transmitt data bit.
        //

        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, (UCHAR)((ucByte >> lShift) & 0x01));  // Set SDA
        I2C_DELAY();

        //
        // After each data bit we must send high->low SCL pulse.
        //

        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: SCL didn't take\n"));
            return FALSE;
        }
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // The monitor sends ACK by preventing the SDA from going high after the clock pulse we use
    // to send our last data bit. If the SDA goes high after this bit, it is a NAK from the monitor.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    ucAck = pI2CCallbacks->ReadDataLine(pHwDeviceExtension);        // Read ACK bit
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();

    if (1 == ucAck)                                                 // NAK from the monitor
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: NAK received\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CWriteByte()

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    )

/*++

Routine Description:

    This routine reads byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    bMore              - TRUE if we want to continue reading, FALSE otherwise.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    LONG lShift;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucByte);

    *pucByte = 0;

    //
    // The data bits are read from MSB to LSB. A data bit is read while the SCL is high.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "ATIRAGE.SYS!I2CReadByte: SCL didn't take\n"));
            return FALSE;
        }
        *pucByte |= pI2CCallbacks->ReadDataLine(pHwDeviceExtension) << lShift;  // Read SDA
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // Send the acknowledge bit. SDA low = ACK, SDA high = NAK.
    //

    if (TRUE == bMore)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);        // Set SDA low - ACK
    }
    else
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);        // Set SDA high - NAK
    }
    I2C_DELAY();

    //
    // Send a SCL high->low pulse, then release the SDA by setting it high.
    //

    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "ATIRAGE.SYS!I2CReadByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();

    return TRUE;
}   // I2CReadByte()

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine waits till SCL goes high
    (SCL low period can be stretched by slow devices).

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - OK - SCL high.
    FALSE - SCL didn't take.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    for (ulCount = 0; ulCount < I2C_SCL_READ_RETRIES; ulCount++)
    {
        if (pI2CCallbacks->ReadClockLine(pHwDeviceExtension) == TRUE)
            return TRUE;

        I2C_DELAY();
    }

    return FALSE;
}   // I2CWaitForClockLineHigh()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\registry.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Registry support for the video port driver.

Author:

    Andre Vachon (andreva) 01-Mar-1992

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "videoprt.h"


//
// Local routines.
//

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,VpGetFlags)
#pragma alloc_text(PAGE,VideoPortGetAccessRanges)
#pragma alloc_text(PAGE,VideoPortVerifyAccessRanges)
#pragma alloc_text(PAGE,CheckIoEnabled)
#pragma alloc_text(PAGE,VpAppendToRequirementsList)
#pragma alloc_text(PAGE,VpIsLegacyAccessRange)
#pragma alloc_text(PAGE,GetCmResourceListSize)
#pragma alloc_text(PAGE,VpRemoveFromResourceList)
#pragma alloc_text(PAGE,VpIsVgaResource)
#endif

NTSTATUS
VpGetFlags(
    PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    )

/*++

Routine Description:

    Checks for the existance of the PnP key/value in the device's
    registry path.

Return Value:

    TRUE if the flag exists, FALSE otherwise.

--*/

{
    PWSTR    Path;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG    pnpEnabled = 0;
    ULONG    legacyDetect = 0;
    ULONG    defaultValue = 0;
    ULONG    bootDriver = 0;
    ULONG    reportDevice = 0;
    PWSTR    Table[] = {L"\\Vga", L"\\VgaSave", NULL};
    PWSTR    SubStr, *Item = Table;
    ULONG    Len;

    *Flags = 0;

    Path = ExAllocatePoolWithTag(PagedPool,
                                 RegistryPath->Length + sizeof(UNICODE_NULL),
                                 POOL_TAG);

    if (Path)
    {
        RtlCopyMemory(Path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        *(Path + (RegistryPath->Length / sizeof(UNICODE_NULL))) = UNICODE_NULL;

        pVideoDebugPrint((1, "PnP path: %ws\n", Path));

        legacyDetect = FALSE;
        reportDevice = FALSE;

        //
        // If the PnP Entry points are present, then we will treat this
        // driver as a PnP driver.
        //

        if ( (HwInitializationData->HwInitDataSize >=
              FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) &&
             (HwInitializationData->HwSetPowerState != NULL)                &&
             (HwInitializationData->HwGetPowerState != NULL)                &&
             (HwInitializationData->HwGetVideoChildDescriptor != NULL) )
        {
            pVideoDebugPrint((1, "videoprt: The miniport is a PnP miniport."));

            pnpEnabled = TRUE;
        }

        //
        // REPORT_DEVICE is only valid if PNP_ENABLED is true.
        //
        // We don't want to report a device to the PnP system if
        // we don't have a PnP driver.
        //

        if (!pnpEnabled)
        {
            reportDevice = 0;
        }

        *Flags = (pnpEnabled   ? PNP_ENABLED   : 0) |
                 (legacyDetect ? LEGACY_DETECT : 0) |
                 (reportDevice ? REPORT_DEVICE : 0);

        //
        // Free the memory we allocated above.
        //

        ExFreePool(Path);


        //
        // Determine if the current miniport is the VGA miniport.
        //

        while (*Item) {

            Len = wcslen(*Item);

            SubStr = RegistryPath->Buffer + (RegistryPath->Length / 2) - Len;

            if (!_wcsnicmp(SubStr, *Item, Len)) {

                pVideoDebugPrint((1, "This IS the vga miniport\n"));
                *Flags |= VGA_DRIVER;
                break;
            }

            Item++;
        }

        pVideoDebugPrint((1, "Flags = %d\n", *Flags));

        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}


VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    )

/*++

Routine Description:

    Walk the appropriate bus to get device information.
    Search for the appropriate device ID.
    Appropriate resources will be returned and automatically stored in the
    resourcemap.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumRequestedResources - Number of entries in the RequestedResources array.

    RequestedResources - Optional pointer to an array ofRequestedResources
        the miniport driver wants to access.

    NumAccessRanges - Maximum number of access ranges that can be returned
        by the function.

    AccessRanges - Array of access ranges that will be returned to the driver.

    VendorId - Pointer to the vendor ID. On PCI, this is a pointer to a 16 bit
        word.

    DeviceId - Pointer to the Device ID. On PCI, this is a pointer to a 16 bit
        word.

    Slot - Pointer to the starting slot number for this search.

Return Value:

    ERROR_MORE_DATA if the AccessRange structure is not large enough for the
       PCI config info.
    ERROR_DEV_NOT_EXIST is the card is not found.

    NO_ERROR if the function succeded.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    UNICODE_STRING unicodeString;
    ULONG i;
    ULONG j;

    PCM_RESOURCE_LIST cmResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDescriptor;


    VP_STATUS status;
    UCHAR bShare;

    PPCI_SLOT_NUMBER slotData = (PPCI_SLOT_NUMBER)Slot;

    //
    // This is the miniport drivers slot. Allocate the
    // resources.
    //

    // Hack Add extra R so the Device0 key does not get created as volatile
    // a screw up the subsequent driver install.

    *(LPWSTR) (((PUCHAR)fdoExtension->DriverRegistryPath) +
               fdoExtension->DriverRegistryPathLength) = L'R';

    RtlInitUnicodeString(&unicodeString, fdoExtension->DriverRegistryPath);

    //
    // Assert drivers do set those parameters properly
    //

#if DBG

    if ((NumRequestedResources == 0) != (RequestedResources == NULL)) {

        pVideoDebugPrint((0, "VideoPortGetDeviceResources: Parameters for requested resource are inconsistent\n"));

    }

#endif

    //
    // An empty requested resource list means we want to automatic behavoir.
    // Just call the HAL to get all the information
    //

    if (NumRequestedResources == 0) {

        //
        // If a PnP driver is requesting resources, then return what the
        // system passed in to us.
        //

        cmResourceList = fdoExtension->AllocatedResources;

        //
        // Return the slot number to the device.
        //

        if (Slot) {
            *Slot = fdoExtension->SlotNumber;
        }

        if (cmResourceList) {
#if DBG
            DumpResourceList(cmResourceList);
#endif
            status = NO_ERROR;

        } else {

            //
            // The system should always pass us resources.
            //

            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
        }

    } else {

        PIO_RESOURCE_REQUIREMENTS_LIST requestedResources;
        ULONG requestedResourceSize;
        NTSTATUS ntStatus;

        status = NO_ERROR;

        //
        // The caller has specified some resources.
        // Lets call IoAssignResources with that and see what comes back.
        //

        requestedResourceSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                                   ((NumRequestedResources - 1) *
                                   sizeof(IO_RESOURCE_DESCRIPTOR));

        requestedResources = ExAllocatePoolWithTag(PagedPool,
                                                   requestedResourceSize,
                                                   POOL_TAG);

        if (requestedResources) {

            RtlZeroMemory(requestedResources, requestedResourceSize);

            requestedResources->ListSize = requestedResourceSize;
            requestedResources->InterfaceType = fdoExtension->AdapterInterfaceType;
            requestedResources->BusNumber = fdoExtension->SystemIoBusNumber;
            requestedResources->SlotNumber = slotData->u.bits.DeviceNumber;
            requestedResources->AlternativeLists = 1;

            requestedResources->List[0].Version  = 1;
            requestedResources->List[0].Revision = 1;
            requestedResources->List[0].Count    = NumRequestedResources;

            RtlMoveMemory(&(requestedResources->List[0].Descriptors[0]),
                          RequestedResources,
                          NumRequestedResources * sizeof(IO_RESOURCE_DESCRIPTOR));

            ntStatus = IoAssignResources(&unicodeString,
                                         &VideoClassName,
                                         fdoExtension->FunctionalDeviceObject->DriverObject,
                                         fdoExtension->FunctionalDeviceObject,
                                         requestedResources,
                                         &cmResourceList);

            ExFreePool(requestedResources);

            if (!NT_SUCCESS(ntStatus)) {

                status = ERROR_INVALID_PARAMETER;

            }

        } else {

            status = ERROR_NOT_ENOUGH_MEMORY;

        }

    }

    if (status == NO_ERROR) {

        VIDEO_ACCESS_RANGE TempRange;

        //
        // We now have a valid cmResourceList.
        // Lets translate it back to access ranges so the driver
        // only has to deal with one type of list.
        //

        //
        // NOTE: The resources have already been reported at this point in
        // time.
        //

        //
        // Walk resource list to update configuration information.
        //

        for (i = 0, j = 0;
             (i < cmResourceList->List->PartialResourceList.Count) &&
                 (status == NO_ERROR);
             i++) {

            //
            // Get resource descriptor.
            //

            cmResourceDescriptor =
                &cmResourceList->List->PartialResourceList.PartialDescriptors[i];

            //
            // Get the share disposition
            //

            if (cmResourceDescriptor->ShareDisposition == CmResourceShareShared) {

                bShare = 1;

            } else {

                bShare = 0;

            }

            switch (cmResourceDescriptor->Type) {

            case CmResourceTypePort:
            case CmResourceTypeMemory:

                //
                // common part
                //

                TempRange.RangeLength =
                    cmResourceDescriptor->u.Memory.Length;
                TempRange.RangeStart =
                    cmResourceDescriptor->u.Memory.Start;
                TempRange.RangeVisible = 0;
                TempRange.RangeShareable = bShare;
                TempRange.RangePassive = 0;

                //
                // separate part
                //

                if (cmResourceDescriptor->Type == CmResourceTypePort) {
                    TempRange.RangeInIoSpace = 1;
                } else {
                    TempRange.RangeInIoSpace = 0;
                }

                //
                // See if we need to return the resource to the driver.
                //

                if (!VpIsLegacyAccessRange(fdoExtension, &TempRange)) {

                    if (j == NumAccessRanges) {

                        status = ERROR_MORE_DATA;
                        break;

                    } else {

                        //
                        // Only modify the AccessRange array if we are writing
                        // valid data.
                        //

                        AccessRanges[j] = TempRange;
                        j++;
                    }

                }

                break;

            case CmResourceTypeInterrupt:

                fdoExtension->MiniportConfigInfo->BusInterruptVector =
                    cmResourceDescriptor->u.Interrupt.Vector;
                fdoExtension->MiniportConfigInfo->BusInterruptLevel =
                    cmResourceDescriptor->u.Interrupt.Level;
                fdoExtension->MiniportConfigInfo->InterruptShareable =
                    bShare;

                break;

            case CmResourceTypeDma:

                fdoExtension->MiniportConfigInfo->DmaChannel =
                    cmResourceDescriptor->u.Dma.Channel;
                fdoExtension->MiniportConfigInfo->DmaPort =
                    cmResourceDescriptor->u.Dma.Port;
                fdoExtension->MiniportConfigInfo->DmaShareable =
                    bShare;

                break;

            default:

                pVideoDebugPrint((1, "VideoPortGetAccessRanges: Unknown descriptor type %x\n",
                                 cmResourceDescriptor->Type ));

                break;

            }

        }
    }

    // Hack remove extra R

    *(LPWSTR) (((PUCHAR)fdoExtension->DriverRegistryPath) +
               fdoExtension->DriverRegistryPathLength) = UNICODE_NULL;


#if DBG

    if (status == NO_ERROR)
    {
        //
        // Indicates resources have been mapped properly
        //

        InterlockedIncrement(&VPResourcesReported);
    }

#endif

    return status;

} // VideoPortGetDeviceResources()

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    Indicates whether the given access range is a vga access range.

Arguments:

    AccessRange - The access range to examine.

Returns:

    TRUE if it is a VGA access range,
    FALSE otherwise.

Notes:

    This routine does not take into account the length of the access range.

--*/

{
    if (AccessRange->RangeInIoSpace) {

        ULONGLONG Port = AccessRange->RangeStart.QuadPart;

        if (((Port >= 0x3b0) && (Port <= 0x3bb)) ||
            ((Port >= 0x3c0) && (Port <= 0x3df))) {

            return TRUE;

        }

    } else {

        if (AccessRange->RangeStart.QuadPart == 0xa0000) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Builds a IoResourceRequirementsList for a given set of access ranges.

Arguments:

    ResourceList - Pointer to location of the requirments list.  Modified
        on completion to point to a new requirements list.

    NumAccessRanges - Number of access ranges in list.

    AccessRanges - List of resources.


Returns:

    STATUS_SUCCESS if successful, otherwise a status code.

Notes:

    This function free's the memory used by the original resource list,
    and allocates a new buffer for the appended resources list.

--*/

{
    PIO_RESOURCE_REQUIREMENTS_LIST OriginalRequirementList = *RequirementList;
    PIO_RESOURCE_DESCRIPTOR pioDescript;
    ULONG RequirementListSize;
    ULONG OriginalListSize;
    ULONG RequirementCount;
    ULONG i;

    RequirementCount = OriginalRequirementList->List[0].Count;
    OriginalListSize = OriginalRequirementList->ListSize;

    RequirementListSize = OriginalListSize +
                              NumAccessRanges * sizeof(IO_RESOURCE_DESCRIPTOR);

    *RequirementList =
        (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool,
                                                        RequirementListSize);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (*RequirementList == NULL) {

        *RequirementList = OriginalRequirementList;
        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Copy the original resource list into the new one.
        //

        memcpy(*RequirementList, OriginalRequirementList, OriginalListSize);

        //
        // Free the original list
        //

        ExFreePool(OriginalRequirementList);

        //
        // Point to first free entry in requirements list
        //

        pioDescript =
            &((*RequirementList)->List[0].Descriptors[(*RequirementList)->List[0].Count]);

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        for (i = 0; i < NumAccessRanges; i++) {

            //
            // We will never claim 0xC0000.
            //

            if ((AccessRanges->RangeStart.LowPart == 0xC0000) &&
                (AccessRanges->RangeInIoSpace == FALSE))
            {
                AccessRanges++;
                continue;
            }

            if (AccessRanges->RangeLength == 0) {

                AccessRanges++;
                continue;
            }

            //
            // Watch to see if the VGA resources get added to the
            // requirements list.  If so set a flag so that we know
            // we don't need to reclaim VGA resources in FindAdapter.
            //

            if (VpIsVgaResource(AccessRanges)) {
                DeviceOwningVga = DeviceObject;
            }

            if (AccessRanges->RangeInIoSpace) {
                pioDescript->Type = CmResourceTypePort;
                pioDescript->Flags = CM_RESOURCE_PORT_IO;

                //
                // Disable 10_BIT_DECODE.  This is causing problems for the
                // PnP folks.  If someone has bad hardware, we'll just
                // require them to report all the passive port explicitly.
                //
                //if (VpIsVgaResource(AccessRanges)) {
                //
                //    pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
                //}

            } else {

                pioDescript->Type = CmResourceTypeMemory;
                pioDescript->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_PASSIVE_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_PASSIVE_DECODE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_10_BIT_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
            }

            pioDescript->ShareDisposition =
                    (AccessRanges->RangeShareable ?
                        CmResourceShareShared :
                        CmResourceShareDeviceExclusive);

            pioDescript->Option = IO_RESOURCE_PREFERRED;
            pioDescript->u.Memory.MinimumAddress = AccessRanges->RangeStart;
            pioDescript->u.Memory.MaximumAddress.QuadPart =
                                                   AccessRanges->RangeStart.QuadPart +
                                                   AccessRanges->RangeLength - 1;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.Length = AccessRanges->RangeLength;

            pioDescript++;
            AccessRanges++;
            RequirementCount++;
        }

        //
        // Update number of elements in list.
        //

        (*RequirementList)->List[0].Count = RequirementCount;
        (*RequirementList)->ListSize = RequirementListSize;
    }

    return STATUS_SUCCESS;
}



VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    VideoPortVerifyAccessRanges


Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    ERROR_INVALID_PARAMETER in an error occured
    NO_ERROR if the call completed successfully

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS status;
    BOOLEAN conflict;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // If the device is not enabled then we won't allow the miniport
    // to claim resources for it.
    //

    if (!CheckIoEnabled(
            HwDeviceExtension,
            NumAccessRanges,
            AccessRanges)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // All resources not passed in during the START_DEVICE irp should
    // be claimed on the FDO.  We will strip out the PDO resources
    // in pVideoPortReportResourceList if the miniport driver tries
    // to verify ranges acquired through VideoPortGetAccessRanges.
    //

    status = STATUS_SUCCESS;
    conflict = FALSE;

    if ((NT_SUCCESS(status)) && (!conflict)) {

#if DBG

        //
        // Indicates resources have been mapped properly
        //

        InterlockedIncrement(&VPResourcesReported);

#endif

        //
        // Track the resources owned by the VGA driver.
        //

        if (fdoExtension->Flags & VGA_DRIVER) {

            if (VgaAccessRanges != AccessRanges) {

                ULONG Size = NumAccessRanges * sizeof(VIDEO_ACCESS_RANGE);

                if (VgaAccessRanges) {
                    ExFreePool(VgaAccessRanges);
                    VgaAccessRanges = NULL;
                    NumVgaAccessRanges = 0;
                }

                if (NumAccessRanges) {
                    VgaAccessRanges = ExAllocatePoolWithTag(PagedPool, Size, POOL_TAG);

                    if (VgaAccessRanges) {
                        memcpy(VgaAccessRanges, AccessRanges, Size);
                        NumVgaAccessRanges = NumAccessRanges;
                    }
                }
            }
        }

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortVerifyAccessRanges()

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    This routine ensures that IO is actually enabled if claiming
    IO ranges.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    TRUE if our IO access checks pass,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->AdapterInterfaceType == PCIBus) {

        //
        // Check to see if there are any IO ranges in the
        // list or resources.
        //

        ULONG i;
        USHORT Command;

        //
        // Get the PCI Command register for this device.
        //

        VideoPortGetBusData(
            HwDeviceExtension,
            PCIConfiguration,
            0,
            &Command,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(USHORT));

        for (i=0; i<NumAccessRanges; i++) {

            if (AccessRanges[i].RangeInIoSpace) {

                if (!(Command & PCI_ENABLE_IO_SPACE))
                    return FALSE;

            } else {

                if (!(Command & PCI_ENABLE_MEMORY_SPACE))
                    return FALSE;
            }
        }

        return TRUE;

    } else {

        //
        // Non-pci devices will always decode IO operations.
        //

        return TRUE;
    }
}

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    This return determines whether a given access range is
    included in the list of legacy access ranges.

Arguments:

    fdoExtension - The FDO extension for the device using the access range.

    AccessRange - The access range to look for in the resource list.

Returns:

    TRUE if the given access range is included in the list of reported
    legacy resources, FALSE otherwise.

--*/

{
    ULONG i;
    PVIDEO_ACCESS_RANGE CurrResource;

    if (fdoExtension->HwLegacyResourceList) {

        CurrResource = fdoExtension->HwLegacyResourceList;

        for (i=0; i<fdoExtension->HwLegacyResourceCount; i++) {

            if ((CurrResource->RangeStart.QuadPart ==
                 AccessRange->RangeStart.QuadPart) &&
                (CurrResource->RangeLength == AccessRange->RangeLength)) {

                return TRUE;
            }

            CurrResource++;
        }
    }

    return FALSE;
}

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    Get the size in bytes of a CmResourceList.

Arguments:

    CmResourceList - The list for which to get the size.

Returns:

    Size in bytes of the CmResourceList.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;
    ULONG i, j;

    pcmFull = &(CmResourceList->List[0]);
    for (i=0; i<CmResourceList->Count; i++) {

        pcmPartial = &(pcmFull->PartialResourceList);
        pcmDescript = &(pcmPartial->PartialDescriptors[0]);
        pcmDescript += pcmPartial->Count;
        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    return (ULONG)(((ULONG_PTR)pcmFull) - ((ULONG_PTR)CmResourceList));
}

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Creates a new CmResourceList with the given access ranges
    removed.

Arguments:

    OriginalList - The original CmResourceList to operate on.

    NumAccessRanges - The number of entries in the remove list.

    AccessRanges - The list of ranges which should be removed from
        the list.

Returns:

    A pointer to the new CmResourceList.

Notes:

    The caller is responsible for freeing the memory returned by this
    function.

--*/

{
    PCM_RESOURCE_LIST FilteredList;
    ULONG Size = GetCmResourceListSize(OriginalList);
    ULONG remainingLength;
    ULONG ResourcesRemoved;

    FilteredList = ExAllocatePoolWithTag(PagedPool, Size, POOL_TAG);

    if (FilteredList) {

        ULONG i, j, k;
        PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
        PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

        //
        // Make a copy of the original list.
        //

        memcpy(FilteredList, OriginalList, Size);
        remainingLength = Size - sizeof(CM_RESOURCE_LIST);

        pcmFull = &(FilteredList->List[0]);
        for (i=0; i<FilteredList->Count; i++) {

            pcmPartial = &(pcmFull->PartialResourceList);
            pcmDescript = &(pcmPartial->PartialDescriptors[0]);

            ResourcesRemoved = 0;

            for (j=0; j<pcmPartial->Count; j++) {

                //
                // See if the current resource is in our legacy list.
                //

                for (k=0; k<NumAccessRanges; k++) {

                    if ((pcmDescript->u.Memory.Start.LowPart ==
                         AccessRanges[k].RangeStart.LowPart) &&
                        (AccessRanges[k].RangeStart.LowPart != 0xC0000)) {

                        //
                        // Remove the resource.
                        //

                        memmove(pcmDescript,
                                pcmDescript + 1,
                                remainingLength);

                        pcmDescript--;
                        ResourcesRemoved++;

                        break;
                    }
                }

                remainingLength -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                pcmDescript++;
            }

            //
            // Update the resource count in the partial resource list
            //

            pcmPartial->Count -= ResourcesRemoved;
            if (pcmPartial->Count == 0) {
                FilteredList->Count--;
            }

            remainingLength -= sizeof(CM_PARTIAL_RESOURCE_LIST);
            pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
        }

    } else {

        //
        // Make sure we always return a list.
        //

        ASSERT(FALSE);
        FilteredList = OriginalList;
    }

    return FilteredList;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\ops.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  ops.c

Abstract:

    video port stub routines for memory and io.

Author:

    Andre Vachon (andreva) 22-Feb-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,VideoPortGetAssociatedDeviceExtension)
#pragma alloc_text(PAGE,VideoPortAcquireDeviceLock)
#pragma alloc_text(PAGE,VideoPortReleaseDeviceLock)
#pragma alloc_text(PAGE,VideoPortGetRomImage)
#pragma alloc_text(PAGE,VpGetBusInterface)
#pragma alloc_text(PAGE,VideoPortGetVgaStatus)
#pragma alloc_text(PAGE,pVideoPortGetVgaStatusPci)

//
//ULONG
//VideoPortCompareMemory (
//    PVOID Source1,
//    PVOID Source2,
//    ULONG Length
//    )
//Forwarded to RtlCompareMemory(Source1,Source2,Length);
//


VP_STATUS
VideoPortDisableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortDisableInterrupt allows a miniport driver to disable interrupts
    from its adapter. This means that the interrupts coming from the device
    will be ignored by the operating system and therefore not forwarded to
    the driver.

    A call to this function is valid only if the interrupt is defined, in
    other words, if the appropriate data was provided at initialization
    time to set up the interrupt.  Interrupts will remain disabled until
    they are reenabled using the VideoPortEnableInterrupt function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
      was not set up at initialization.

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        HalDisableSystemInterrupt(fdoExtension->InterruptVector,
                                  fdoExtension->InterruptIrql);

        fdoExtension->InterruptsEnabled = FALSE;

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortDisableInterrupt()


VP_STATUS
VideoPortEnableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortEnableInterrupt allows a miniport driver to enable interrupts
    from its adapter.  A call to this function is valid only if the
    interrupt is defined, in other words, if the appropriate data was
    provided at initialization time to set up the interrupt.

    This function is used to re-enable interrupts if they have been disabled
    using VideoPortDisableInterrupt.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
        was not set up at initialization.


--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        fdoExtension->InterruptsEnabled = TRUE;

        HalEnableSystemInterrupt(fdoExtension->InterruptVector,
                                 fdoExtension->InterruptIrql,
                                 fdoExtension->InterruptMode);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortEnableInterrupt()

PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine allows a miniport driver to get a copy of its devices
    ROM.  This function returns the pointer to a buffer containing the
    devices ROM.

Arguments;

    HwDeviceExtension - Points to the miniport driver's device extension.

    Unused1 - Reserved for future use.  Must be NULL.  (Buffer)

    Unused2 - Reserved for future use.  Must be zero.  (Offset)

    Length - Number of bytes to return.

--*/

{
    return NULL;
}


ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Issue a warning telling the miniport they should not read everything
    // out of the driver config space otherwise it causes some device like
    // NCR SCSIs to crash.
    //

#if DBG
    if ((BusDataType == PCIConfiguration) &&
        (Length >= sizeof(PCI_COMMON_CONFIG)))
    {
        pVideoDebugPrint((0, "A miniport must only call VideoPortGetBusData with PCI_COMMON_HDR_LENGTH\n"));
        DbgBreakPoint();
    }
#endif

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {
        
#if defined(NO_LEGACY_DRIVERS)
        pVideoDebugPrint((0, "VideoPortGetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));
        
        return 0;
        
#else    
        return HalGetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);        
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.GetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortGetBusData()


//
//UCHAR
//VideoPortGetCurrentIrql(
//    )
//Forwarded to KeGetCurrentIrql();
//


//
//VOID
//VideoPortMoveMemory(
//    IN PVOID Destination,
//    IN PVOID Source,
//    IN ULONG Length
//    )
//
//Forwarded to RtlMoveMemory(Destination,Source,Length);
//


//
// ALL the functions to read ports and registers are forwarded on free
// builds on x86 and ALPHA to the appropriate kernel function.
// This saves time and memory
//

#if (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

UCHAR
VideoPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    VideoPortReadPortUchar reads a byte from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the byte read from the specified port address.

--*/

{

    UCHAR temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_UCHAR(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUchar %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUchar()

USHORT
VideoPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    VideoPortReadPortUshort reads a word from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.


Return Value:

    This function returns the word read from the specified port address.

--*/

{

    USHORT temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_USHORT(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUshort %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUshort()

ULONG
VideoPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    VideoPortReadPortUlong reads a double word from the specified port
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the double word read from the specified port address.

--*/

{

    ULONG temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_ULONG(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUlong %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUlong()

VOID
VideoPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUchar reads a number of bytes from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of UCHAR values into which the values are
        stored.

    Count - Specifes the number of bytes to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUchar %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortReadPortBufferUchar()

VOID
VideoPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUshort reads a number of words from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words into which the values are stored.

    Count - Specifies the number of words to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUshort %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortReadPortBufferUshort()

VOID
VideoPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUlong reads a number of double words from a
    single port into a buffer.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double words into which the values are
        stored.

    Count - Specifies the number of double words to be read into the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortReadPortBufferUlong %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortReadPortBufferUlong()

UCHAR
VideoPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUchar reads a byte from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the byte read from the specified register address.

--*/

{

    UCHAR temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_UCHAR(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUchar %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUchar()

USHORT
VideoPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUshort reads a word from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the word read from the specified register address.

--*/

{

    USHORT temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_USHORT(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUshort %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUshort()

ULONG
VideoPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUlong reads a double word from the specified
    register address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the double word read from the specified register
    address.

--*/

{

    ULONG temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_ULONG(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUlong %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUlong()

VOID
VideoPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
VideoPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
VideoPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

#endif // (DBG || (!defined(_X86_) && !defined(_ALPHA_)))


ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {

#if defined(NO_LEGACY_DRIVERS)
    pVideoDebugPrint((0, "VideoPortGetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));

    return 0;

#else

        return HalSetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.SetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortSetBusData()


//
//VOID
//VideoPortStallExecution(
//    IN ULONG Microseconds
//    )
//
//Forwarded to KeStallExecutionProcessor(Microseconds);
//



//
// ALL the functions to write ports and registers are forwarded on free
// builds on x86 to the appropriate kernel function.
// This saves time and memory
//

#if (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

VOID
VideoPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWritePortUchar writes a byte to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a byte to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUchar %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_UCHAR(Port, Value);

} // VideoPortWritePortUchar()

VOID
VideoPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWritePortUshort writes a word to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a word to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUhort %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_USHORT(Port, Value);

} // VideoPortWritePortUshort()

VOID
VideoPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWritePortUlong writes a double word to the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a double word to be written to the port.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortUlong %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_ULONG(Port, Value);

} // VideoPortWritePortUlong()

VOID
VideoPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUchar writes a number of bytes to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of bytes to be written.

    Count - Specifies the number of bytes to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUchar  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortWritePortBufferUchar()

VOID
VideoPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUshort writes a number of words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words to be written.

    Count - Specifies the number of words to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUshort  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortWritePortBufferUshort()

VOID
VideoPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUlong writes a number of double words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double word to be written.

    Count - Specifies the number of double words to be written to the buffer.
Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWriteBufferUlong  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortWritePortBufferUlong()

VOID
VideoPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUchar writes a byte to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a byte to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUchar  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_UCHAR(Register, Value);

} // VideoPortWriteRegisterUchar()

VOID
VideoPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUshort writes a word to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUshort  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_USHORT(Register, Value);

} // VideoPortWriteRegisterUshort()

VOID
VideoPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUlong writes a double word to the
    specified register address.  It requires a logical port
    address obtained from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a double word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUlong  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_ULONG(Register, Value);

} // VideoPortWriteRegisterUlong()


VOID
VideoPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
VideoPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
VideoPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

#endif // (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

//
//VOID
//VideoPortZeroMemory(
//    IN PVOID Destination,
//    IN ULONG Length
//    )
//
//Forwarded to RtlZeroMemory(Destination,Length);
//

PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This routine will return the HwDeviceExtension for the parent of the
    given device object.

Arguments:

    DeviceObject - The child device object (PDO).

Notes:

    This function is useful if you want to get the parent device extension
    for a child device object.  For example this is useful with I2C.

--*/

{
    PFDO_EXTENSION DeviceExtension;

    DeviceExtension = (PFDO_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    return (PVOID) DeviceExtension->HwDeviceExtension;
}

VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine acquires the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    ACQUIRE_DEVICE_LOCK(fdoExtension);
}

VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine releases the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    RELEASE_DEVICE_LOCK(fdoExtension);
}

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    )

/*++

Routine Description:

    This routine allows a video miniport to get access to VideoPort
    functions without linking to them directly.  This will allow an NT 5.0
    miniport to take advantage of NT 5.0 features while running on NT 5.0,
    but still retain the ability to load on NT 4.0.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

    FunctionName - pointer to a zero terminated ascii string which contains
        the function name we are looking for.

Returns:

    Pointer to the given function if it exists.
    NULL otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PPROC_ADDRESS ProcAddress = VideoPortEntryPoints;

    //
    // Since the list of exported functions is small, and this routine
    // will not be called often we can get away with a linear search.
    //

    while (ProcAddress->FunctionName) {

        if (strcmp(ProcAddress->FunctionName, FunctionName) == 0) {
            return ProcAddress->FunctionAddress;
        }

        ProcAddress++;
    }

    return NULL;
}

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent to retrieve
    the BUS_INTERFACE_STANDARD.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->BusInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->BusInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    FdoExtension->BusInterface.Version = 1;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return Status;
}

//
// ALL the functions to perform interlocked operations are forwarded on free
// builds on x86 and ALPHA to the appropriate kernel function.
// This saves time and memory
//

#if !defined(_X86_)

LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )

{
    return InterlockedExchange(Target, Value);
}

LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    )

{
    return InterlockedIncrement(Addend);
}

LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    )

{
    return InterlockedDecrement(Addend);
}

#endif // !defined(_X86_)

VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    )

/*++

Routine Description:

    VideoPortGetVgaStatus detect if the calling device is decoding
    Vga IO address

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension
    VgaStatus         - Points to the the result

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if it is a non-PCI device

--*/
{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // We can not handle legacy devices
    //

    if (fdoExtension->AdapterInterfaceType != PCIBus) { 

        *VgaStatus = 0;

        return ERROR_INVALID_FUNCTION;
    }
    else {

        *VgaStatus = pVideoPortGetVgaStatusPci( HwDeviceExtension );
        return (NO_ERROR);
   
    }
}

#define VGA_STATUS_REGISTER1 0x3DA

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    )

{

    USHORT Command;
    PCI_COMMON_CONFIG ConfigSpace; 
    PHYSICAL_ADDRESS PhysicalAddress;
    PUCHAR BaseReg;
    ULONG VgaEnable;

    //
    // assume VGA is disabled
    //

    VgaEnable = 0;

    //
    // Get the PCI config for this device
    //

    VideoPortGetBusData( HwDeviceExtension,
                         PCIConfiguration,
                         0,
                         &ConfigSpace,
                         0,
                         PCI_COMMON_HDR_LENGTH);


    if( !(ConfigSpace.Command & PCI_ENABLE_IO_SPACE) ) {

        return VgaEnable;

    }

    if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
        ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {


        //
        // Map the VGA registers we are going to use.
        //

        PhysicalAddress.HighPart = 0;
        PhysicalAddress.LowPart  = VGA_STATUS_REGISTER1;

        BaseReg = VideoPortGetDeviceBase(HwDeviceExtension,
                                         PhysicalAddress,
                                         1,
                                         VIDEO_MEMORY_SPACE_IO);

        if (BaseReg) {

            //
            // If we got here the PCI config space for our device indicates
            // we are the VGA, and we were able to map the VGA resources.
            //

            VgaEnable = DEVICE_VGA_ENABLED;

            VideoPortFreeDeviceBase(HwDeviceExtension, BaseReg);
        }
    }

    return VgaEnable;
}

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    DpcRoutine(HwDeviceExtension, Context);
}

BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    Allows a miniport driver to queue a DPC.

Arguments:

    HwDeviceExtension - The HwDeviceExtension for the miniport.

    CallbackRoutine - The entry point within the miniport to call when the DPC
        is scheduled.

    Context - A miniport supplies context which will be passed to the
        CallbackRoutine.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    return KeInsertQueueDpc(&fdoExtension->Dpc, CallbackRoutine, Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\videoprt.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    videoprt.h

Abstract:

    This module contains the structure definitions private to the video port
    driver.

Author:

    Andre Vachon (andreva) 02-Dec-1991

Notes:

Revision History:

--*/

#ifndef __VIDEOPRT_H__
#define __VIDEOPRT_H__

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntos.h"
#include "pci.h"
#include "wdmguid.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"
#include "ntiologc.h"

#include "ntddvdeo.h"
#include "video.h"
#include "ntagp.h"
#include "agp.h"
#include "inbv.h"


//
//  Forward declare some basic driver objects.
//

typedef struct _FDO_EXTENSION       *PFDO_EXTENSION;
typedef struct _CHILD_PDO_EXTENSION *PCHILD_PDO_EXTENSION;


//
// Debugging Macro
//
//
// When an IO routine is called, we want to make sure the miniport
// in question has reported its IO ports.
// VPResourceReported is TRUE when a miniport has called VideoPort-
// VerifyAccessRanges.
// It is set to FALSE as a default, and set back to FALSE when finishing
// an iteration in the loop of VideoPortInitialize (which will reset
// the default when we exit the loop also).
//
// This flag will also be set to TRUE by the VREATE entry point so that
// the IO functions always work after init.
//

#if DBG

#undef VideoDebugPrint
#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#define IS_ACCESS_RANGES_DEFINED()                                         \
    {                                                                      \
        if (!VPResourcesReported) {                                        \
                                                                           \
            pVideoDebugPrint((0, "The miniport driver is trying to access" \
                                 " IO ports or memory location before the" \
                                 " ACCESS_RANGES have been reported to"    \
                                 " the port driver with the"               \
                                 " VideoPortVerifyAccessRanges(). Please"  \
                                 " fix the miniport driver\n"));           \
                                                                           \
            DbgBreakPoint();                                               \
                                                                           \
        }                                                                  \
    }

#else

#define pVideoDebugPrint(arg)
#define IS_ACCESS_RANGES_DEFINED()

#endif

//
// Useful registry buffer length.
//

#define STRING_LENGTH 60

//
// Queue link for mapped addresses stored for unmapping
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG NumberOfUchars;
    ULONG RefCount;
    UCHAR InIoSpace;
    BOOLEAN bNeedsUnmapping;
    BOOLEAN bLargePageRequest;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;

//
// BusDataRegistry variables
//

typedef struct _VP_QUERY_DEVICE {
    PVOID MiniportHwDeviceExtension;
    PVOID CallbackRoutine;
    PVOID MiniportContext;
    VP_STATUS MiniportStatus;
    ULONG DeviceDataType;
} VP_QUERY_DEVICE, *PVP_QUERY_DEVICE;


//
// Definition of the data passed in for the VideoPortGetRegistryParameters
// function for the DeviceDataType.
//

#define VP_GET_REGISTRY_DATA 0
#define VP_GET_REGISTRY_FILE 1

typedef struct _VIDEO_PORT_DRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;
    VIDEO_HW_INITIALIZATION_DATA HwInitData;

} VIDEO_PORT_DRIVER_EXTENSION, *PVIDEO_PORT_DRIVER_EXTENSION;


//
// PnP Detection flags
//

#define PNP_ENABLED           0x001
#define LEGACY_DETECT         0x002
#define VGA_DRIVER            0x004
#define LEGACY_DRIVER         0x008
#define REPORT_DEVICE         0x020
#define UPGRADE_FAIL_START    0x040
#define FINDADAPTER_SUCCEEDED 0x080
#define UPGRADE_FAIL_HWINIT   0x100
#define VGA_DETECT            0x200


//
// ResetHW Structure
//

typedef struct _VP_RESET_HW {
    PVIDEO_HW_RESET_HW ResetFunction;
    PVOID HwDeviceExtension;
} VP_RESET_HW, *PVP_RESET_HW;


//
// AGP Support
//

#define POOL_TAG 0x72745076 // 'vPrt'

typedef struct _AGP_ALLOCATION
{
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress;
    ULONG Pages;
    PMDL Mdl;
    struct _AGP_ALLOCATION *Next;
} AGP_ALLOCATION, *PAGP_ALLOCATION;


//
// Private EVENT support for miniport.
//

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT has a PKEVENT
//  field filled in by ObReferenceObjectByHandle(). It cannot be waited on
//  at all. Must be consistent with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_MAPPED_USER       0x1

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT is about to be
//  deleted and that the display driver callback is ongoing. Must be consistent
//  with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_INVALID           0x2

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT is in a DPC.
//  It signals the GDI Engine not to delete the VIDEO_POR_EVENT. It signals
//  the VideoPortSetEventDPC to set it then free it. Must be consistent with
//  that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IN_DPC               0x4


typedef struct _VIDEO_PORT_EVENT {
    PVOID   pKEvent;
    volatile ULONG fFlags;
} VIDEO_PORT_EVENT, *PVIDEO_PORT_EVENT;


#define EDID_BUFFER_SIZE 256


typedef enum _HW_INIT_STATUS
{
    HwInitNotCalled,  // HwInitialize has not yet been called
    HwInitSucceeded,  // HwInitialize has been called and succeeded
    HwInitFailed      // HwInitialize has been called and failed
} HW_INIT_STATUS, *PHW_INIT_STATUS;


#define  GET_FDO_EXT(p) (((PFDO_EXTENSION)(p)) - 1)

//
// Define HW_DEVICE_EXTENSION verification macro.
//

#define IS_HW_DEVICE_EXTENSION(p) (GET_FDO_EXT(p)->HwDeviceExtension == (p))

typedef struct _ALLOC_ENTRY {
  PVOID Address;
  ULONG Size;
  struct _ALLOC_ENTRY *Next;
} *PALLOC_ENTRY, ALLOC_ENTRY;

//
// Device Extension for the FUNCTIONAL Driver Object (FDO)
//

typedef struct _FDO_EXTENSION {

    //
    // Location of the miniport device extension.
    //

    PVOID HwDeviceExtension;

    //
    // Power management mappings.
    //

    DEVICE_POWER_STATE DeviceMapping[PowerSystemMaximum] ;
    BOOLEAN IsMappingReady ;

    //
    // Event object for pVideoPortDispatch synchronization.
    //

    KMUTEX                   SyncMutex;

    //
    // Track whether the device has been opened.
    //

    BOOLEAN                  DeviceOpened;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  END common header.
    //
    ////////////////////////////////////////////////////////////////////////////

    //
    // Adapter device objects
    //

    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT AttachedDeviceObject;

    //
    // Pointer to the miniport config info so that the port driver
    // can modify it when the miniport is asking for configuration information.
    //

    PVIDEO_PORT_CONFIG_INFO MiniportConfigInfo;

    //
    // Miniport exports
    //

    PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;
    PVIDEO_HW_INITIALIZE           HwInitialize;
    PVIDEO_HW_INTERRUPT            HwInterrupt;
    PVIDEO_HW_START_IO             HwStartIO;
    PVIDEO_HW_TIMER                HwTimer;
    PVIDEO_HW_POWER_SET            HwSetPowerState;
    PVIDEO_HW_POWER_GET            HwGetPowerState;
    PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;
    PVIDEO_HW_CHILD_CALLBACK       HwChildCallback;

    //
    // Legacy resources used by the driver and reported to Plug and Play
    // via FILTER_RESOURCE_REQUIREMENTS.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;
    ULONG               HwLegacyResourceCount;

    //
    // Linked list of all memory mapped io space (done through MmMapIoSpace)
    // requested by the miniport driver.
    // This list is kept so we can free up those ressources if the driver
    // fails to load or if it is unloaded at a later time.
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // Interrupt object
    //

    PKINTERRUPT InterruptObject;

    //
    // Interrupt vector, irql and mode
    //

    ULONG InterruptVector;
    KIRQL InterruptIrql;
    ULONG InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;
    BOOLEAN InterruptsEnabled;

    //
    // Information about the BUS on which the adapteris located
    //

    INTERFACE_TYPE AdapterInterfaceType;
    ULONG SystemIoBusNumber;

    //
    // Size of the miniport device extensions.
    //

    ULONG HwDeviceExtensionSize;
    ULONG HwChildDeviceExtensionSize;

    //
    // Determines the size required to save the video hardware state
    //

    ULONG HardwareStateSize;

    //
    // Pointer to the path name indicating the path to the drivers node in
    // the registry's current control set
    //

    PWSTR DriverRegistryPath;
    ULONG DriverRegistryPathLength;

    //
    // Total memory usage of PTEs by a miniport driver.
    // This is used to track if the miniport is mapping too much memory
    //

    ULONG MemoryPTEUsage;

    //
    // Pointer to the video request packet;
    //

    PVIDEO_REQUEST_PACKET Vrp;

    //
    // Determines if the port driver is currently handling an attach caused by
    // a video filter drivers.
    //

    BOOLEAN bAttachInProgress;

    //
    // Has the drivers HwInitialize routine been called.
    //

    HW_INIT_STATUS HwInitStatus;

    //
    // VDM and int10 support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;
    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Memory allocation values
    //

#if DBG
    LONG           FreeAllocation;
    PALLOC_ENTRY   AllocationHead;
    PAGED_LOOKASIDE_LIST AllocationList;
#endif

    //
    // DPC Support
    //

    KDPC Dpc;

    ////////////////////////////////////////////////////////////////////////////
    //
    // Plug and Play Support
    //
    ////////////////////////////////////////////////////////////////////////////

    PCM_RESOURCE_LIST ResourceList;
    PCM_RESOURCE_LIST AllocatedResources;   // bus driver list

    PCM_RESOURCE_LIST RawResources;         // complete list
    PCM_RESOURCE_LIST TranslatedResources;  // translated complete list

    ULONG             DeviceNumber;
    ULONG             SlotNumber;

    //
    // Indicates whether we can enumerate children right away, or if
    // we need to wait for HwInitialize to be called first.
    //

    BOOLEAN AllowEarlyEnumeration;

    //
    // Interface for communication with our bus driver.
    //

    BOOLEAN ValidBusInterface;
    BUS_INTERFACE_STANDARD BusInterface;

    //
    // Flags that indicate type of driver (VGA, PNP, etc)
    //

    ULONG             Flags;

    //
    // AGP Support
    //

    AGP_BUS_INTERFACE_STANDARD     AgpInterface;

    //
    // Callout support - Phydisp of the device in GDI
    //

    PVOID             PhysDisp;

} FDO_EXTENSION, *PFDO_EXTENSION;

#define MAXIMUM_MEM_LIMIT_K  64

//
// AGP Data Structures
//

typedef struct _REGION {
    ULONG Length;
    ULONG NumDwords;
    ULONG BitField[1];
} REGION, *PREGION;

typedef struct _RESERVATION_LIST RESERVATION_LIST, *PRESERVATION_LIST;
typedef struct _RESERVATION_LIST
{
    ULONG Offset;
    ULONG Pages;
    ULONG RefCount;
    BOOLEAN Reserved;
    PRESERVATION_LIST Next;
};

typedef struct _PHYSICAL_RESERVE_CONTEXT
{
    ULONG Pages;
    ULONG Caching;
    PVOID MapHandle;
    PHYSICAL_ADDRESS PhysicalAddress;
    PREGION Region;
} PHYSICAL_RESERVE_CONTEXT, *PPHYSICAL_RESERVE_CONTEXT;

typedef struct _VIRTUAL_RESERVE_CONTEXT
{
    HANDLE ProcessHandle;
    PEPROCESS Process;
    PVOID VirtualAddress;
    PPHYSICAL_RESERVE_CONTEXT PhysicalReserveContext;
    PRESERVATION_LIST ReservationList;
    PREGION Region;
} VIRTUAL_RESERVE_CONTEXT, *PVIRTUAL_RESERVE_CONTEXT;

typedef struct _DEVICE_ADDRESS DEVICE_ADDRESS, *PDEVICE_ADDRESS;
typedef struct _DEVICE_ADDRESS
{
    ULONG BusNumber;
    ULONG Slot;
    PDEVICE_ADDRESS Next;
};

//
// Support for GetProcAddress
//

typedef struct _PROC_ADDRESS
{
    PUCHAR FunctionName;
    PVOID  FunctionAddress;
} PROC_ADDRESS, *PPROC_ADDRESS;

#define PROC(x) #x, x

//
// Power Request Context Block
//

typedef struct tagPOWER_BLOCK
{
    PKEVENT     Event;
    union {
        NTSTATUS    Status;
        ULONG       FinalFlag;
    } ;
    PIRP        Irp ;
} POWER_BLOCK, *PPOWER_BLOCK;

//
// Global Data
//


#if DBG
extern ULONG VPResourcesReported;
extern CHAR *BusType[];
#endif

extern BOOLEAN VPFirstTime;
extern PVIDEO_WIN32K_CALLOUT Win32kCallout;
extern BOOLEAN EnableUSWC;
extern ULONG VideoDebugLevel;
extern ULONG VideoDeviceNumber;
extern PWSTR VideoClassString;
extern UNICODE_STRING VideoClassName;
extern VP_RESET_HW HwResetHw[];
extern PVOID PhysicalMemorySection;
extern ULONG VpC0000Compatible;
extern PVOID VgaHwDeviceExtension;
extern PDEVICE_OBJECT VgaCompatibleDevice;
extern PVIDEO_ACCESS_RANGE VgaAccessRanges;
extern ULONG NumVgaAccessRanges;
extern PDEVICE_OBJECT DeviceOwningVga;
extern PROC_ADDRESS VideoPortEntryPoints[];
extern VIDEO_ACCESS_RANGE VgaLegacyResources[];
extern ULONGLONG VpSystemMemorySize;



typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    PKINTERRUPT             pInterrupt,
    PKSYNCHRONIZE_ROUTINE   pkSyncronizeRoutine,
    PVOID                   pSynchContext
    );

//
// Number of legacy vga resources
//

#define NUM_VGA_LEGACY_RESOURCES 3

//
// These macros are used to protect threads which will enter the
// miniport.  We need to guarantee that only one thread enters
// the miniport at a time.
//

#define ACQUIRE_DEVICE_LOCK(DeviceExtension)           \
    KeWaitForSingleObject(&DeviceExtension->SyncMutex, \
                          Executive,                   \
                          KernelMode,                  \
                          FALSE,                       \
                          (PTIME)NULL);

#define RELEASE_DEVICE_LOCK(DeviceExtension)           \
    KeReleaseMutex(&DeviceExtension->SyncMutex,        \
                   FALSE);

//
// Define macros to stall execution for given number of milli or micro seconds.
// Single call to KeStallExecutionProcessor() can be done for 100us max.
//

#define DELAY_MILLISECONDS(n)                           \
{                                                       \
    ULONG ulCount;                                      \
    ULONG ulTotal = 10 * (n);                           \
                                                        \
    for (ulCount = 0; ulCount < (n); ulCount++)         \
        KeStallExecutionProcessor(100);                 \
}

#define DELAY_MICROSECONDS(n)                           \
{                                                       \
    ULONG ulCount = (n);                                \
                                                        \
    while (ulCount > 0)                                 \
    {                                                   \
        if (ulCount >= 100)                             \
        {                                               \
            KeStallExecutionProcessor(100);             \
            ulCount -= 100;                             \
        }                                               \
        else                                            \
        {                                               \
            KeStallExecutionProcessor(ulCount);         \
            ulCount = 0;                                \
        }                                               \
    }                                                   \
}

//
// Private function declarations
//

//
// ddc.c
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    );

//
// agp.c
//

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION DeviceExtension
    );

//
// edid.c
//

BOOLEAN
pVideoPortIsValidEDID(
    PVOID Edid
    );


VOID
pVideoPortGetEDIDId(
    PVOID  pEdid,
    PWCHAR pwChar
    );

PVOID
pVideoPortGetMonitordescription(
    PVOID pEdid
    );

//
// i2c.c
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    );

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    );

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

//
// pnp.c
//

NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// registry.c
//

NTSTATUS
VpGetFlags(
    IN PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    );

NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

//
// videoprt.c
//

NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    );

VOID
pVideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    );

NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
pVPInit(
    VOID
    );

NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    );

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    );

NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    );

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    );

VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    );

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    );

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    );

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    );

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    );

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    );

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    );

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    );

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    );

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VOID
VpEnableDisplay(
    BOOLEAN bState
    );

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    );

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    );

#if DBG
VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    );

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList
    );

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    );

VOID
DumpHwInitData(
    IN PVIDEO_HW_INITIALIZATION_DATA p
    );

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    );
#endif

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    );

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    );

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    );

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    );

#endif // ifndef __VIDEOPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\pnp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This is the pnp portion of the video port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,pVideoPortSendIrpToLowerDevice)
#pragma alloc_text(PAGE,pVideoPortPnpDispatch)


NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will forward the start request to the next lower device and
    block until it's completion.

Arguments:

    DeviceObject - the device to which the start request was issued.

    Irp - the start request

Return Value:

    status

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PKEVENT event;
    NTSTATUS status;

    event = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(KEVENT),
                                  POOL_TAG);

    if (event == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           VpSetEventCompletion,
                           event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    if(status == STATUS_PENDING) {

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    ExFreePool(event);

    return status;

}


ULONG
VpGetDeviceAddress(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will get the address of a device (ie. slot number).

Arguments:

    DeviceObject - Object for which to retrieve the address

Returns:

    The address of the given device.

--*/

{
    KEVENT              Event;
    PIRP                QueryIrp = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIO_STACK_LOCATION  NextStack;
    NTSTATUS            Status;
    DEVICE_CAPABILITIES Capabilities;
    PFDO_EXTENSION      FdoExtension = DeviceObject->DeviceExtension;

    RtlZeroMemory(&Capabilities, sizeof(DEVICE_CAPABILITIES));
    Capabilities.Size = sizeof(DEVICE_CAPABILITIES);
    Capabilities.Version = 1;
    Capabilities.Address = Capabilities.UINumber = (ULONG) -1;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    NextStack->Parameters.DeviceCapabilities.Capabilities = &Capabilities;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }


    ASSERT(NT_SUCCESS(Status));

    return (Capabilities.Address >> 16) | ((Capabilities.Address & 0x7) << 5);
}


NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the PnP dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus;
    ULONG ioControlCode;
    VIDEO_REQUEST_PACKET vrp;

    //
    // Get pointer to the port driver's device extension.
    //

    fdoExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    pVideoDebugPrint((2, "VIDEO_TYPE_FDO : IRP_MJ_PNP: "));

    switch (irpStack->MinorFunction) {

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
        PIO_RESOURCE_REQUIREMENTS_LIST requirements;
        ULONG Length;

        pVideoDebugPrint((2, "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));

        DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                IoGetDriverObjectExtension(
                                    DeviceObject->DriverObject,
                                    DeviceObject->DriverObject);

        //
        // We must first pass the Irp down to the PDO.
        //

        pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

        //
        // Determine the bus type and bus number
        //

        IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                            DevicePropertyLegacyBusType,
                            sizeof(fdoExtension->AdapterInterfaceType),
                            &fdoExtension->AdapterInterfaceType,
                            &Length);

        IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                            DevicePropertyBusNumber,
                            sizeof(fdoExtension->SystemIoBusNumber),
                            &fdoExtension->SystemIoBusNumber,
                            &Length);

        //
        // Get bus interface so we can use Get/SetBusData.
        //

        fdoExtension->ValidBusInterface =
            NT_SUCCESS(VpGetBusInterface(fdoExtension));

        requirements = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if (requirements) {

            //
            // Append any legacy resources decoded by the device.
            //

            if (DriverObjectExtension->HwInitData.HwInitDataSize >
                FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

                if( requirements->InterfaceType == PCIBus )
                {

                    PCI_COMMON_CONFIG ConfigSpace;

                    VideoPortGetBusData((PVOID)(fdoExtension + 1), //HwDeviceExtension
                                        PCIConfiguration,
                                        0,
                                        &ConfigSpace,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);

                    if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
                         (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
                        ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
                         (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {
    
                        if (pVideoPortGetVgaStatusPci((PVOID)(fdoExtension + 1) )) {

                            if (DriverObjectExtension->HwInitData.HwInitDataSize >
                                FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwGetLegacyResources)) {

                                if (DriverObjectExtension->HwInitData.HwGetLegacyResources) {

                                    //
                                    // If the miniport supplied a HwGetLegacyResources routine
                                    // it wasn't able to give us a list of resources at
                                    // DriverEntry time.  We'll give it a vendor/device id now
                                    // and see if it can give us a list of resources.
                                    //

                                    DriverObjectExtension->HwInitData.HwGetLegacyResources(
                                        ConfigSpace.VendorID,
                                        ConfigSpace.DeviceID,
                                        &DriverObjectExtension->HwInitData.HwLegacyResourceList,
                                        &DriverObjectExtension->HwInitData.HwLegacyResourceCount
                                        );
                                }
                            }

                            if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                                if (VgaHwDeviceExtension) {

                                    ULONG Count;
                                    PVIDEO_ACCESS_RANGE AccessRange;

                                    Count       = DriverObjectExtension->HwInitData.HwLegacyResourceCount;
                                    AccessRange = DriverObjectExtension->HwInitData.HwLegacyResourceList;

                                    //
                                    // Mark VGA resources as shared if the vga driver is
                                    // already loaded.  Otherwise the PnP driver won't
                                    // be able to start.
                                    //

                                    while (Count--) {

                                        if (VpIsVgaResource(AccessRange)) {
                                            AccessRange->RangeShareable = TRUE;
                                        }

                                        AccessRange++;
                                    }
                                }

                                VpAppendToRequirementsList(
                                    DeviceObject,
                                    &requirements,
                                    DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                                    DriverObjectExtension->HwInitData.HwLegacyResourceList);

                            } else if (!IsNEC_98) {

                                //
                                // The driver didn't specify legacy resources, but we
                                // know that it is a VGA, so add in the vga resources.
                                //

                                pVideoDebugPrint((0, "VGA device didn't specify legacy resources.\n"));

                                DriverObjectExtension->HwInitData.HwLegacyResourceCount = NUM_VGA_LEGACY_RESOURCES;
                                DriverObjectExtension->HwInitData.HwLegacyResourceList = VgaLegacyResources;

                                VpAppendToRequirementsList(
                                    DeviceObject,
                                    &requirements,
                                    NUM_VGA_LEGACY_RESOURCES,
                                    VgaLegacyResources);
                            }
                        }
                    }
                }
            }

            //
            // Now if there is an interrupt in the list, but
            // the miniport didn't register an ISR, then
            // release our claim on the interrupt.
            //

#if 1
            {
                PIO_RESOURCE_LIST resourceList;
                ULONG i;

                //
                // Scan the IO_RESOURCE_REQUIREMENTS_LIST for an
                // interrupt.
                //

                resourceList = requirements->List;

                for (i=0; i<resourceList->Count; i++) {

                    if (resourceList->Descriptors[i].Type == CmResourceTypeInterrupt) {

                        if( requirements->InterfaceType == PCIBus )
                        {

                            PCI_COMMON_CONFIG ConfigSpace;

                            VideoPortGetBusData((PVOID)(fdoExtension + 1), //HwDeviceExtension
                                                PCIConfiguration,
                                                0,
                                                &ConfigSpace,
                                                0,
                                                PCI_COMMON_HDR_LENGTH);

#if 0
                            if (ConfigSpace.VendorID == ???)

                                //
                                // We found an interrupt resource swap with last
                                // element in list, and decrement structure size and
                                // list count.
                                //

                                resourceList->Descriptors[i].u.Interrupt.MinimumVector = 0x0B;
                                resourceList->Descriptors[i].u.Interrupt.MaximumVector = 0x0B;
                                DbgPrint("VideoPort Requesting IRQ 11.\n");
                            }
#endif
                        }
                    }
                }
            }
#else
            if (!DriverObjectExtension->HwInitData.HwInterrupt) {

                PIO_RESOURCE_LIST resourceList;
                ULONG i;

                //
                // Scan the IO_RESOURCE_REQUIREMENTS_LIST for an
                // interrupt.
                //

                resourceList = requirements->List;

                for (i=0; i<resourceList->Count; i++) {

                    if (resourceList->Descriptors[i].Type == CmResourceTypeInterrupt) {

                        //
                        // We found an interrupt resource swap with last
                        // element in list, and decrement structure size and
                        // list count.
                        //

                        resourceList->Descriptors[i].Type = CmResourceTypeNull;

                        pVideoDebugPrint((1, "Removing Int from requirements list.\n"));
                    }
                }
            }
#endif

        } else {

            pVideoDebugPrint((0, "We expected a list of resources!\n"));
            ASSERT(FALSE);
        }


        statusBlock->Information = (ULONG_PTR) requirements;
        statusBlock->Status = STATUS_SUCCESS;

        }

        break;

    case IRP_MN_START_DEVICE:
        {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
        PCM_RESOURCE_LIST allocatedResources;
        PCM_RESOURCE_LIST translatedResources;
        UCHAR nextMiniport = FALSE;
        ULONG RawListSize;
        ULONG TranslatedListSize;

        pVideoDebugPrint((2, "IRP_MN_START_DEVICE\n"));

        //
        // Retrieve the data we cached away during VideoPortInitialize.
        //

        DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                IoGetDriverObjectExtension(
                                    DeviceObject->DriverObject,
                                    DeviceObject->DriverObject);

        ASSERT(DriverObjectExtension);

        //
        // Grab the allocated resource the system gave us.
        //

        allocatedResources =
            irpStack->Parameters.StartDevice.AllocatedResources;
        translatedResources =
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

        //
        // Filter out any resources that we added to the list
        // before passing the irp on to PCI.
        //

        if (DriverObjectExtension->HwInitData.HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

            if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                if (allocatedResources) {
                    irpStack->Parameters.StartDevice.AllocatedResources =
                        VpRemoveFromResourceList(
                            allocatedResources,
                            DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                            DriverObjectExtension->HwInitData.HwLegacyResourceList);

                }

                if ((irpStack->Parameters.StartDevice.AllocatedResources !=
                     allocatedResources) && translatedResources) {

                    irpStack->Parameters.StartDevice.AllocatedResourcesTranslated =
                        VpRemoveFromResourceList(
                            translatedResources,
                            DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                            DriverObjectExtension->HwInitData.HwLegacyResourceList);

                }
            }
        }

        //
        // The first thing we need to do is send the START_DEVICE
        // irp on to our parent.
        //

        pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

        //
        // Restore the original resources.
        //

        if (irpStack->Parameters.StartDevice.AllocatedResources !=
            allocatedResources) {

            ExFreePool(irpStack->Parameters.StartDevice.AllocatedResources);
            irpStack->Parameters.StartDevice.AllocatedResources
                = allocatedResources;
        }

        if (irpStack->Parameters.StartDevice.AllocatedResourcesTranslated !=
            translatedResources) {

            ExFreePool(irpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated
                = translatedResources;
        }

        if (allocatedResources) {

            ASSERT(translatedResources);

            //
            // Cache assigned and translated resources.
            //

            RawListSize = GetCmResourceListSize(allocatedResources);
            TranslatedListSize = GetCmResourceListSize(translatedResources);

            ASSERT(RawListSize == TranslatedListSize);

            fdoExtension->RawResources = ExAllocatePoolWithTag(PagedPool,
                                                               RawListSize +
                                                               TranslatedListSize,
                                                               POOL_TAG);

            fdoExtension->TranslatedResources = (PCM_RESOURCE_LIST)
                ((PUCHAR)fdoExtension->RawResources + RawListSize);

            if (fdoExtension->RawResources == NULL) {

                statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            memcpy(fdoExtension->RawResources,
                   allocatedResources,
                   RawListSize);

            memcpy(fdoExtension->TranslatedResources,
                   translatedResources,
                   TranslatedListSize);
        }

        //
        // Get slot/function number
        //

        fdoExtension->SlotNumber = VpGetDeviceAddress(DeviceObject);

        //
        // Store the allocatedResources. This will allow us to
        // assign these resources when VideoPortGetAccessRanges
        // routines are called.
        //
        // NOTE: We do not actually have to copy the data, because
        //       we are going to call FindAdapter in the context
        //       of this function.  So, this data will be intact
        //       until we complete.
        //

        if ((allocatedResources != NULL) && (translatedResources != NULL)) {

            ULONG Count;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDesc;

            Count = 0;
            InterruptDesc = RtlUnpackPartialDesc(CmResourceTypeInterrupt,
                                                 translatedResources,
                                                 &Count);
            
            fdoExtension->AllocatedResources = allocatedResources;
            fdoExtension->SystemIoBusNumber =
                allocatedResources->List->BusNumber;
            fdoExtension->AdapterInterfaceType =
                allocatedResources->List->InterfaceType;
            
            //
            // Tuck away the giblets we need for PnP interrupt support!
            //
            if (InterruptDesc) {
                fdoExtension->InterruptVector =
                    InterruptDesc->u.Interrupt.Vector;
                fdoExtension->InterruptIrql =
                    (KIRQL)InterruptDesc->u.Interrupt.Level;
                fdoExtension->InterruptAffinity =
                    InterruptDesc->u.Interrupt.Affinity;
            }
            
        } else {

            //
            // The system doesn't have resource information for this
            // legacy (ex. isa) pnp card.  The user may have incorrectly
            // installed the driver.
            //

            pVideoDebugPrint((0, "The system should pass us resources!\n"));

            ASSERT(FALSE);
        }

        ACQUIRE_DEVICE_LOCK (fdoExtension);

        if (VideoPortFindAdapter(DeviceObject->DriverObject,
                                 (PVOID)&(DriverObjectExtension->RegistryPath),
                                 &(DriverObjectExtension->HwInitData),
                                 NULL,
                                 DeviceObject,
                                 &nextMiniport) == NO_ERROR) {

            //
            // BUGBUG
            // This should not return TRUE for nextMiniport. (???)
            //

            // ASSERT(nextMiniport != TRUE);

            statusBlock->Status = STATUS_SUCCESS;

            //
            // If the system is already up and running, lets call
            // HwInitialize now.  This will allow us to enumerate
            // children.
            //

            if (!InbvCheckDisplayOwnership() ) {

                VpEnableDisplay(FALSE);

                if (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension)) {
                    fdoExtension->HwInitStatus = HwInitSucceeded;
                } else {
                    fdoExtension->HwInitStatus = HwInitFailed;
                }

                VpEnableDisplay(TRUE);
            }

        } else {

            statusBlock->Status = STATUS_UNSUCCESSFUL;

            if (fdoExtension->RawResources) {
                ExFreePool(fdoExtension->RawResources);
            }
        }

        RELEASE_DEVICE_LOCK (fdoExtension);

        }

        break;

    case IRP_MN_QUERY_INTERFACE:

        //
        // Normally I would only expect to get this IRP heading for
        // an PDO.  However, AndrewGo wants to be able to send down
        // these IRP's and he only has an FDO.  Instead of forcing
        // him to get a PDO somehow, we'll just handle the irp for
        // a FDO as well.
        //

        pVideoDebugPrint((2, "IRP_MN_QUERY_INTERFACE\n"));

        ACQUIRE_DEVICE_LOCK (fdoExtension);

        if ((fdoExtension->HwQueryInterface) &&
            (fdoExtension->HwDeviceExtension) &&
            (NO_ERROR == fdoExtension->HwQueryInterface(
                                  fdoExtension->HwDeviceExtension,
                                  (PQUERY_INTERFACE)
                                  &irpStack->Parameters.QueryInterface)))
        {
            statusBlock->Status = STATUS_SUCCESS;
        }
        else if (!NT_SUCCESS(statusBlock->Status))
        {
            //
            // The miniport didn't handle the QueryInterface request, see
            // if its an interface the videoprt supports.
            //

            PQUERY_INTERFACE qi = (PQUERY_INTERFACE)
                                  &irpStack->Parameters.QueryInterface;

            //
            // If we are responding to a known private GUID, expose
            // the known GUID interface ourselves.  Otherwise, pass
            // on to the miniport driver.
            //

            if (IsEqualGUID(qi->InterfaceType, &GUID_AGP_INTERFACE)) {

                PAGP_INTERFACE AgpInterface = (PAGP_INTERFACE)qi->Interface;

                AgpInterface->Size    = sizeof(AGP_INTERFACE);
                AgpInterface->Version = AGP_INTERFACE_VERSION;
                AgpInterface->Context = fdoExtension->HwDeviceExtension;

                if (VideoPortGetAgpServices(fdoExtension->HwDeviceExtension,
                                            &AgpInterface->AgpServices)) {

                    statusBlock->Status = STATUS_SUCCESS;
                }
            }
        }

        RELEASE_DEVICE_LOCK (fdoExtension);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    
        statusBlock->Status = STATUS_SUCCESS;
        statusBlock->Information |= PNP_DEVICE_NOT_DISABLEABLE ;
        IoCopyCurrentIrpStackLocationToNext (Irp) ;
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

        break;

    default:

        pVideoDebugPrint((2, "PNP minor function %x not supported - forwarding \n", irpStack->MinorFunction ));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
    }

    //
    // save the final status so we can return it after the IRP is completed.
    //

    finalStatus = statusBlock->Status;

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    return finalStatus;
}


PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...
    ResList - The list to search
    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the partial descriptor if found, otherwise NULL

--*/
{
    ULONG i, j, hit;

    hit = 0;
    for (i = 0; i < ResList->Count; i++) {
        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {
            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {
                if (hit == *Count) {
                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];
                } else {
                    hit++;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\vpdata.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  vpdata.c

Abstract:

    Global data module for the video port

Author:

    Andre Vachon (andreva) 12-Jul-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

//
//
// Data that is NOT pageable
//
//

//
// Globals to support HwResetHw function
//

VP_RESET_HW HwResetHw[6];

//
// We check for resources reported in read/write functions which
// can be called at raised irql.
//

#if DBG
ULONG VPResourcesReported = TRUE;
#endif

//
// Debug Level for output routine (not pageable because VideoDebugPrint
// can be called at raised irql.
//

ULONG VideoDebugLevel = 0;

//
//
// Data that IS pageable
//
//

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif


//
// Used to do first time initialization of the video port.
//

BOOLEAN VPFirstTime = TRUE;

//
// Callbacks to win32k
//

PVIDEO_WIN32K_CALLOUT Win32kCallout = NULL;

//
// Disable USWC is case the machine does not work properly with it.
//

BOOLEAN EnableUSWC = TRUE;

//
// Count to determine the number of video devices
//

ULONG VideoDeviceNumber = 0;

//
// Registry Class in which all video information is stored.
//

PWSTR VideoClassString = L"VIDEO";
UNICODE_STRING VideoClassName = {10,12,L"VIDEO"};

//
// Pointer to physical memory. It is created during driver initialization
// and is only closed when the driver is closed.
//

PVOID PhysicalMemorySection = NULL;

//
// Variable to determine if there is a ROM at physical address C0000 on which
// we can do the int 10
//

ULONG VpC0000Compatible = 0;

//
// HwDeviceExtension of the VGA miniport driver, if it is loaded.
//

PVOID VgaHwDeviceExtension = NULL;

//
// Pointer to the device object for the device that owns the VGA ports
//

PDEVICE_OBJECT VgaCompatibleDevice = NULL;

//
// Store the amount of physical memory in the machine.
//

ULONGLONG VpSystemMemorySize;

//
// This structure describes to which ports access is required.
//

#define MEM_VGA               0xA0000
#define MEM_VGA_SIZE          0x20000
#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF


PVIDEO_ACCESS_RANGE VgaAccessRanges = NULL;
ULONG               NumVgaAccessRanges = 0;
PDEVICE_OBJECT      DeviceOwningVga = NULL;


VIDEO_ACCESS_RANGE VgaLegacyResources[NUM_VGA_LEGACY_RESOURCES] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT+ 1,
    1,
    1,
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    1
}
};

#if DBG

CHAR *BusType[] = { "Internal",
                    "Isa",
                    "Eisa",
                    "MicroChannel",
                    "TurboChannel",
                    "PCIBus",
                    "VMEBus",
                    "NuBus",
                    "PCMCIABus",
                    "CBus",
                    "MPIBus",
                    "MPSABus",
                    "ProcessorInternal",
                    "InternalPowerBus",
                    "PNPISABus",
                    "MaximumInterfaceType"
                };
#endif

PROC_ADDRESS VideoPortEntryPoints[] =
{
    PROC(VideoPortDDCMonitorHelper),
    PROC(VideoPortGetAgpServices),
    PROC(VideoPortGetRomImage),
    PROC(VideoPortGetAssociatedDeviceExtension),
    PROC(VideoPortAcquireDeviceLock),
    PROC(VideoPortReleaseDeviceLock),
    PROC(VideoPortAllocateBuffer),
    PROC(VideoPortReleaseBuffer),
#if defined(_X86_)
    "VideoPortInterlockedIncrement", InterlockedIncrement,
    "VideoPortInterlockedDecrement", InterlockedDecrement,
    "VideoPortInterlockedExchange", InterlockedExchange,
#else
    PROC(VideoPortInterlockedIncrement),
    PROC(VideoPortInterlockedDecrement),
    PROC(VideoPortInterlockedExchange),
#endif
    PROC(VideoPortGetVgaStatus),
    PROC(VideoPortQueueDpc),
    PROC(VideoPortQueryServices),
    {NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\videoprt.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  videoprt.c

Abstract:

    This is the NT Video port driver.

Author:

    Andre Vachon (andreva) 18-Dec-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#define INITGUID

#include "videoprt.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,pVideoPortCreateDeviceName)
#pragma alloc_text(PAGE,pVideoPortDispatch)
#pragma alloc_text(PAGE,VideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetDeviceBase)
#pragma alloc_text(PAGE,VideoPortGetDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetRegistryCallback)
#pragma alloc_text(PAGE,VideoPortGetRegistryParameters)
#pragma alloc_text(PAGE,pVPInit)
#pragma alloc_text(PAGE,VpAddDevice)
#pragma alloc_text(PAGE,VpCreateDevice)
#pragma alloc_text(PAGE,VideoPortInitialize)
#pragma alloc_text(PAGE,VideoPortFindAdapter2)
#pragma alloc_text(PAGE,VideoPortFindAdapter)
#pragma alloc_text(PAGE,pVideoPortMapToNtStatus)
#pragma alloc_text(PAGE,pVideoPortMapUserPhysicalMem)
#pragma alloc_text(PAGE,VideoPortMapMemory)
#pragma alloc_text(PAGE,VideoPortAllocateBuffer)
#pragma alloc_text(PAGE,VideoPortReleaseBuffer)
#pragma alloc_text(PAGE,VideoPortScanRom)
#pragma alloc_text(PAGE,VideoPortSetRegistryParameters)
#pragma alloc_text(PAGE,VideoPortUnmapMemory)
#pragma alloc_text(PAGE,VpEnableDisplay)
#pragma alloc_text(PAGE,VpWin32kCallout)
#pragma alloc_text(PAGE,VpAllowFindAdapter)
#if DBG
#pragma alloc_text(PAGE,BuildRequirements)
#pragma alloc_text(PAGE,DumpRequirements)
#pragma alloc_text(PAGE,DumpResourceList)
#pragma alloc_text(PAGE,DumpHwInitData)
#pragma alloc_text(PAGE,DumpUnicodeString)
#endif
#pragma alloc_text(PAGE,VideoPortQueryServices)
#pragma alloc_text(PAGE,VpInterfaceDefaultReference)
#pragma alloc_text(PAGE,VpInterfaceDefaultDereference)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the video port driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    ASSERT(0);

    //
    //
    //
    //     WARNING !!!
    //
    //     This function is never called because we are loaded as a DLL by other video drivers !
    //
    //
    //
    //
    //

    //
    // We always return STATUS_SUCCESS because otherwise no video miniport
    // driver will be able to call us.
    //

    return STATUS_SUCCESS;

} // end DriverEntry()



NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    )

/*++

Routine Description:

    Helper function that does string manipulation to create a device name

--*/

{
    WCHAR          ntNumberBuffer[STRING_LENGTH];
    UNICODE_STRING ntNumberUnicodeString;

    //
    // Create the name buffer
    //

    UnicodeString->Buffer = UnicodeBuffer;
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = STRING_LENGTH;

    //
    // Create the miniport driver object name.
    //

    ntNumberUnicodeString.Buffer = ntNumberBuffer;
    ntNumberUnicodeString.Length = 0;
    ntNumberUnicodeString.MaximumLength = STRING_LENGTH;

    if (NT_SUCCESS(RtlIntegerToUnicodeString(DeviceNumber,
                                             10,
                                             &ntNumberUnicodeString))) {

        if (NT_SUCCESS(RtlAppendUnicodeToString(UnicodeString,
                                                DeviceString))) {

            if (NT_SUCCESS(RtlAppendUnicodeStringToString(UnicodeString,
                                                          &ntNumberUnicodeString))) {

                UnicodeString->MaximumLength = (USHORT)
                    (UnicodeString->Length + sizeof(UNICODE_NULL));

                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_INSUFFICIENT_RESOURCES;

} // pVideoPortCreateDeviceName()




VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    This routine allows the miniport drivers (as well as the port driver) to
    display error messages to the debug port when running in the debug
    environment.

    When running a non-debugged system, all references to this call are
    eliminated by the compiler.

Arguments:

    DebugPrintLevel - Debug print level between 0 and 3, with 3 being the
        most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= VideoDebugLevel) {

        char buffer[256];

        vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

} // VideoPortDebugPrint()

VOID
VpEnableDisplay(
    BOOLEAN bState
    )

/*++

Routine Description:

    This routine enables/disables the current display so that we can execut
    the drivers FindAdapter code.

Arugments:

    bState - Should the display be enabled or disabled

Returns:

    none
--*/

{
    if (!InbvCheckDisplayOwnership()) {

        VIDEO_WIN32K_CALLBACKS_PARAMS calloutParams;

        //
        // The system is up and running.  Notify GDI to enable/disable
        // the current display.
        //

        calloutParams.CalloutType = VideoFindAdapterCallout;
        calloutParams.Param       = bState;

        VpWin32kCallout(&calloutParams);

    } else {

        //
        // The boot driver is still in control.  Modify the state of the
        // boot driver.
        //

        InbvEnableBootDriver(bState);
    }
}

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    )

/*++

Routine Description:

    This routine makes a callout into win32k.  It attaches to csrss
    to guarantee that win32k is in the address space on hydra machines.

Arguments:

    calloutParams - a pointer to the callout struture.

Returns:

    none.

--*/

{

    if (Win32kCallout) {

        (*Win32kCallout)(calloutParams);
    }
}

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    )

/*++

Routine Description:

    Determine if we allow this device to be used if part of a multi-function
    board.

Arguments;

    fdoExtension - The device extenstion for the object in question.

Returns:

    TRUE if the device is allowed as part of a multi-function board.
    FALSE otherwise.

--*/

{
    BOOLEAN bRet = TRUE;

    if ((fdoExtension->AdapterInterfaceType == PCIBus) &&
        ((fdoExtension->Flags & PNP_ENABLED) == PNP_ENABLED)) {

        PCI_COMMON_CONFIG ConfigSpace;

        if (PCI_COMMON_HDR_LENGTH ==
            VideoPortGetBusData(fdoExtension->HwDeviceExtension,
                                PCIConfiguration,
                                0,
                                &ConfigSpace,
                                0,
                                PCI_COMMON_HDR_LENGTH)) {


            if (PCI_MULTIFUNCTION_DEVICE(&ConfigSpace)) {

                bRet = FALSE;
            }
        }
    }

    return bRet;
}

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{

    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus = -1 ;
    ULONG ioControlCode;
    VIDEO_REQUEST_PACKET vrp;

    //
    // Get pointer to the port driver's device extension.
    //

    fdoExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    //
    // Synchronize execution of the dispatch routine by acquiring the device
    // event object. This ensures all request are serialized.
    // The synchronization must be done explicitly because the functions
    // executed in the dispatch routine use system services that cannot
    // be executed in the start I/O routine.
    //
    // The synchronization is done on the miniport's event so as not to
    // block commands coming in for another device.
    //

    pVideoDebugPrint((3, "pVideoPortDispatch(), wait for Sync Event, line %d\n", __LINE__));

    ACQUIRE_DEVICE_LOCK(fdoExtension);

    ASSERT(irpStack->MajorFunction != IRP_MJ_PNP);
    ASSERT(irpStack->MajorFunction != IRP_MJ_POWER);

    //
    // Case on the function being requested.
    // If the function is operating specific, intercept the operation and
    // perform directly. Otherwise, pass it on to the appropriate miniport.
    //

    switch (irpStack->MajorFunction) {

    //
    // Called by the display driver *or a user-mode application*
    // to get exclusive access to the device.
    // This access is given by the I/O system (based on a bit set during the
    // IoCreateDevice() call).
    //

    case IRP_MJ_CREATE:

        pVideoDebugPrint((2, "VideoPort - CREATE\n"));

        //
        // Don't let an old driver start during the upgrade
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_START)
        {
            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Special hack to succeed on Attach, but not do anything ...
        // That way on the close caused by the attach we will not actually
        // close the device and screw the HAL.
        //

        if (irpStack->Parameters.Create.SecurityContext->DesiredAccess ==
            FILE_READ_ATTRIBUTES) {

            statusBlock->Information = FILE_OPEN;
            statusBlock->Status = STATUS_SUCCESS;

            fdoExtension->bAttachInProgress = TRUE;

            break;

        }

        //
        // Only allow our device to be opened once!
        //

        if (fdoExtension->DeviceOpened) {

            pVideoDebugPrint((0, "Only one create allowed on this device.\n"));
            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Mark the device as opened so we will fail future opens.
        //

        fdoExtension->DeviceOpened = TRUE;

        //
        // Tell the kernel we are now taking ownership the display.
        //

        InbvNotifyDisplayOwnershipLost(pVideoPortResetDisplay);

        //
        // Now perform basic initialization to allow the Windows display
        // driver to set up the device appropriately.
        //

        statusBlock->Information = FILE_OPEN;

        //
        // We will need to attach to the CSR process to do an int 10.
        // Save the value of that process so we can do an attach later on.
        //

        if ((fdoExtension->Flags & FINDADAPTER_SUCCEEDED) == 0) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;
            pVideoDebugPrint((0, "VideoPortDispatch: START_DEVICE did not succeed\n"));

        } else if ((fdoExtension->HwInitStatus == HwInitNotCalled) &&
                   (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension) == FALSE))
        {
            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;
            fdoExtension->HwInitStatus = HwInitFailed;

            pVideoDebugPrint((0, "VideoPortDispatch: HwInitialize failed\n"));

        } else if (fdoExtension->HwInitStatus == HwInitFailed) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;

        } else {

            fdoExtension->HwInitStatus = HwInitSucceeded;

            statusBlock->Status = STATUS_SUCCESS;
        }

        //
        // We don't want GDI to use any drivers other than display
        // or boot drivers during upgrade setup.
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_HWINIT) {

            statusBlock->Status = STATUS_ACCESS_DENIED;
        }

        break;

    //
    // Called when the display driver wishes to give up it's handle to the
    // device.
    //

    case IRP_MJ_CLOSE:

        pVideoDebugPrint((2, "Videoprt - CLOSE\n"));

        //
        // Special hack to succeed on Attach, but not do anything ...
        // That way on the close caused by the attach we will not actually
        // close the device and screw the HAL.
        //

        if (fdoExtension->bAttachInProgress == TRUE) {

            fdoExtension->bAttachInProgress = FALSE;
            statusBlock->Status = STATUS_SUCCESS;

            break;

        }

        //
        // Allow the device to be opend again.
        //

        fdoExtension->DeviceOpened = FALSE;


        vrp.IoControlCode      = IOCTL_VIDEO_RESET_DEVICE;
        vrp.StatusBlock        = statusBlock;
        vrp.InputBuffer        = NULL;
        vrp.InputBufferLength  = 0;
        vrp.OutputBuffer       = NULL;
        vrp.OutputBufferLength = 0;

        //
        // Send the request to the miniport.
        //

        fdoExtension->HwStartIO(fdoExtension->HwDeviceExtension, &vrp);

        //
        // Override error from the miniport and return success.
        //

        statusBlock->Status = STATUS_SUCCESS;

        break;

    //
    // Device Controls are specific functions for the driver.
    // First check for calls that must be intercepted and hidden from the
    // miniport driver. These calls are hidden for simplicity.
    // The other control functions are passed down to the miniport after
    // the request structure has been filled out properly.
    //

    case IRP_MJ_DEVICE_CONTROL:

        //
        // Get the pointer to the input/output buffer and it's length
        //

        ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
        inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
        outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
        ioControlCode      = irpStack->Parameters.DeviceIoControl.IoControlCode;

        if (ioControlCode == IOCTL_VIDEO_INIT_WIN32K_CALLBACKS) {

            pVideoDebugPrint((2, "VideoPort - IOCTL_VIDEO_INIT_WIN32K_CALLBACKS\n"));

            fdoExtension->PhysDisp = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->PhysDisp;

            Win32kCallout = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->Callout;

            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->bACPI             = FALSE;
            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->pPhysDeviceObject = fdoExtension->PhysicalDeviceObject;

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(VIDEO_WIN32K_CALLBACKS);

        } else if (ioControlCode == IOCTL_VIDEO_IS_VGA_DEVICE) {

            pVideoDebugPrint((2, "VideoPort - IOCTL_VIDEO_IS_VGA_DEVICE\n"));

            *((PBOOLEAN)(ioBuffer)) = (BOOLEAN)(DeviceObject == DeviceOwningVga);

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(BOOLEAN);

        } else {

            //
            // All other request need to be passed to the miniport driver.
            //

            statusBlock->Status = STATUS_SUCCESS;

            switch (ioControlCode) {

#if _X86_
            case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

                pVideoDebugPrint((2, "VideoPort - SaveHardwareState\n"));

                //
                // allocate the memory required by the miniport driver so it can
                // save its state to be returned to the caller.
                //

                if (fdoExtension->HardwareStateSize == 0) {

                    statusBlock->Status = STATUS_NOT_IMPLEMENTED;
                    break;

                }

                ((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength =
                    fdoExtension->HardwareStateSize;

                statusBlock->Status =
                    ZwAllocateVirtualMemory(NtCurrentProcess(),
                                            (PVOID *) &(((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateHeader),
                                            0L,
                                            &((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength,
                                            MEM_COMMIT,
                                            PAGE_READWRITE);

                break;
#endif

            case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

                pVideoDebugPrint((2, "VideoPort - QueryAccessRanges\n"));

                break;

            //
            // The default case is when the port driver does not handle the
            // request. We must then call the miniport driver.
            //

            default:

                break;


            } // switch (ioControlCode)


            //
            // All above cases call the miniport driver.
            //
            // only process it if no errors happened in the port driver
            // processing.
            //

            if (NT_SUCCESS(statusBlock->Status)) {

                pVideoDebugPrint((2, "VideoPort - default function %x\n", ioControlCode));

                vrp.IoControlCode      = ioControlCode;
                vrp.StatusBlock        = statusBlock;
                vrp.InputBuffer        = ioBuffer;
                vrp.InputBufferLength  = inputBufferLength;
                vrp.OutputBuffer       = ioBuffer;
                vrp.OutputBufferLength = outputBufferLength;

                //
                // Send the request to the miniport.
                //

                fdoExtension->HwStartIO(fdoExtension->HwDeviceExtension,
                                        &vrp);

                if (statusBlock->Status != NO_ERROR) {

                    //
                    // Make sure we don't tell the IO system to copy data
                    // on a real error.
                    //

                    if (statusBlock->Status != ERROR_MORE_DATA) {

                        ASSERT(statusBlock->Information == 0);
                        statusBlock->Information = 0;

                    }

                    pVideoPortMapToNtStatus(statusBlock);
                }
            }

        } // if (ioControlCode == ...

        break;

    //
    // Other major entry points in the dispatch routine are not supported.
    //

    default:

        statusBlock->Status = STATUS_SUCCESS;

        break;

    } // switch (irpStack->MajorFunction)

    //
    // save the final status so we can return it after the IRP is completed.
    //

    if (finalStatus == -1) {
        finalStatus = statusBlock->Status;
    }

    pVideoDebugPrint((3, "pVideoPortDispatch(), set Sync Event, line %d\n", __LINE__));

    RELEASE_DEVICE_LOCK(fdoExtension);

    if (finalStatus == STATUS_PENDING) {
        pVideoDebugPrint((1, "VideoPrt: Pending in pVideoPortDispatch.\n")) ;
        return STATUS_PENDING ;
    }

    pVideoDebugPrint((3, "Dispatch: calling IoCompleteRequest with Irp %x\n", Irp));

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    //
    // We never have pending operation so always return the status code.
    //

    pVideoDebugPrint((2, "VideoPort:  final IOCTL status: %08lx\n",
                     finalStatus));

    return finalStatus;

} // pVideoPortDispatch()


VOID
VideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    VideoPortFreeDeviceBase frees a block of I/O addresses or memory space
    previously mapped into the system address space by calling
    VideoPortGetDeviceBase.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    MappedAddress - Specifies the base address of the block to be freed. This
        value must be the same as the value returned by VideoPortGetDeviceBase.

Return Value:

    None.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    pVideoPortFreeDeviceBase(HwDeviceExtension, MappedAddress);
    return;
}


PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    pVideoDebugPrint((2, "VPFreeDeviceBase at mapped address is %08lx\n",
                    MappedAddress));

    lastMappedAddress = NULL;
    nextMappedAddress = fdoExtension->MappedAddressList;

    while (nextMappedAddress) {

        if (nextMappedAddress->MappedAddress == MappedAddress) {

            //
            // Count up how much memory a miniport driver is really taking
            //

            if (nextMappedAddress->bNeedsUnmapping) {

                fdoExtension->MemoryPTEUsage -=
                    COMPUTE_PAGES_SPANNED(nextMappedAddress->MappedAddress,
                                          nextMappedAddress->NumberOfUchars);

            }

            //
            // BUGBUG use reference count temporarily since ATI maps too
            // large a buffer to do two maps of it.
            //

            if (!(--nextMappedAddress->RefCount)) {

                //
                // Unmap address, if necessary.
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    MmUnmapIoSpace(nextMappedAddress->MappedAddress,
                                   nextMappedAddress->NumberOfUchars);
                }

                //
                // Remove mapped address from list.
                //

                if (lastMappedAddress == NULL) {

                    fdoExtension->MappedAddressList =
                    nextMappedAddress->NextMappedAddress;

                } else {

                    lastMappedAddress->NextMappedAddress =
                    nextMappedAddress->NextMappedAddress;

                }

                ExFreePool(nextMappedAddress);

            }

            //
            // We just return the value to show that the call succeeded.
            //

            return (nextMappedAddress);

        } else {

            lastMappedAddress = nextMappedAddress;
            nextMappedAddress = nextMappedAddress->NextMappedAddress;

        }
    }

    return NULL;

} // end VideoPortFreeDeviceBase()


PVOID
VideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    )

/*++

Routine Description:

    VideoPortGetDeviceBase maps a memory or I/O address range into the
    system (kernel) address space.  Access to this mapped address space
    must follow these rules:

        If the input value for InIoSpace is 1 (the address IS in I/O space),
        the returned logical address should be used in conjunction with
        VideoPort[Read/Write]Port[Uchar/Ushort/Ulong] functions.
                             ^^^^

        If the input value for InIoSpace is 0 (the address IS NOT in I/O
        space), the returned logical address should be used in conjunction
        with VideoPort[Read/Write]Register[Uchar/Ushort/Ulong] functions.
                                  ^^^^^^^^

    Note that VideoPortFreeDeviceBase is used to unmap a previously mapped
    range from the system address space.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    IoAddress - Specifies the base physical address of the range to be
        mapped in the system address space.

    NumberOfUchars - Specifies the number of bytes, starting at the base
        address, to map in system space. The driver must not access
        addresses outside this range.

    InIoSpace - Specifies that the address is in the I/O space if 1.
        Otherwise, the address is assumed to be in memory space.

Return Value:

    This function returns a base address suitable for use by the hardware
    access functions. VideoPortGetDeviceBase may be called several times
    by the miniport driver.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    //
    // We specify large page as FALSE for the default since the miniport could
    // be using the address at raise IRQL in an ISR.
    //

    return pVideoPortGetDeviceBase(HwDeviceExtension,
                                   IoAddress,
                                   NumberOfUchars,
                                   InIoSpace,
                                   FALSE);

}

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    )
{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PHYSICAL_ADDRESS cardAddress = IoAddress;
    PVOID mappedAddress = NULL;
    PMAPPED_ADDRESS newMappedAddress;
    BOOLEAN bMapped;

    ULONG addressSpace;
    ULONG p6Caching = FALSE;

    pVideoDebugPrint((2, "VPGetDeviceBase reqested %08lx mem type. address is %08lx %08lx, length of %08lx\n",
                     InIoSpace, IoAddress.HighPart, IoAddress.LowPart, NumberOfUchars));

    //
    // Properly configure the flags for translation
    //

    addressSpace = InIoSpace & 0xFF;

#if defined(_X86_)

    //
    // On X86, determine if we will want to map the memory with the
    // special caching flag.
    //

    p6Caching = addressSpace & VIDEO_MEMORY_SPACE_P6CACHE;

#endif

    addressSpace &= ~VIDEO_MEMORY_SPACE_P6CACHE;

#if !defined(_ALPHA_)

    //
    // On non-alpha, this does'nt mean anything
    //

    addressSpace &= ~VIDEO_MEMORY_SPACE_DENSE;

#endif

    if (addressSpace & VIDEO_MEMORY_SPACE_USER_MODE) {
        ASSERT(FALSE);
        return NULL;
    }

    if ((((cardAddress.QuadPart >= 0x000C0000) && (cardAddress.QuadPart < 0x000C8000)) &&
         (InIoSpace == 0) &&
         (VpC0000Compatible == 2)) ||
        HalTranslateBusAddress(fdoExtension->AdapterInterfaceType,
                               fdoExtension->SystemIoBusNumber,
                               IoAddress,
                               &addressSpace,
                               &cardAddress)) {

        //
        // Use reference counting for addresses to support broken ATI !
        // Return the previously mapped address if we find the same physical
        // address.
        //

        PMAPPED_ADDRESS nextMappedAddress;

        pVideoDebugPrint((2, "VPGetDeviceBase requested %08lx mem type. physical address is %08lx %08lx, length of %08lx\n",
                         addressSpace, cardAddress.HighPart, cardAddress.LowPart, NumberOfUchars));

        nextMappedAddress = fdoExtension->MappedAddressList;

        while (nextMappedAddress) {

            if ((nextMappedAddress->InIoSpace == InIoSpace) &&
                (nextMappedAddress->NumberOfUchars == NumberOfUchars) &&
                (nextMappedAddress->PhysicalAddress.QuadPart == cardAddress.QuadPart)) {


                pVideoDebugPrint((2, "VPGetDeviceBase : refCount hit on address %08lx \n",
                                  nextMappedAddress->PhysicalAddress.LowPart));

                nextMappedAddress->RefCount++;

                //
                // Count up how much memory a miniport driver is really taking
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    fdoExtension->MemoryPTEUsage +=
                        COMPUTE_PAGES_SPANNED(nextMappedAddress->MappedAddress,
                                              nextMappedAddress->NumberOfUchars);

                }

                return (nextMappedAddress->MappedAddress);

            } else {

                nextMappedAddress = nextMappedAddress->NextMappedAddress;

            }
        }

        //
        // If the address is in IO space, don't do anything.
        // If the address is in memory space, map it and save the information.
        //

        if (addressSpace & VIDEO_MEMORY_SPACE_IO) {

            mappedAddress = (PVOID) cardAddress.QuadPart;
            bMapped = FALSE;

        } else {

            //
            // Map the device base address into the virtual address space
            //
            // NOTE: This routine is order dependant, and changing flags like
            // bLargePage will affect the caching of address we do earlier
            // on in this routine.
            //

            if (p6Caching && EnableUSWC) {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             MmFrameBufferCached);

                if (mappedAddress == NULL) {

                    mappedAddress = MmMapIoSpace(cardAddress,
                                                 NumberOfUchars,
                                                 FALSE);
                }

            } else {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             FALSE);
            }

            if (mappedAddress == NULL) {

                //
                // A failiure occured
                // BUGBUG we should log an error here !
                //

                pVideoDebugPrint((0, "VideoPort: MmMapIoSpace FAILED !!!\n"));

                return NULL;
            }

            bMapped = TRUE;

            fdoExtension->MemoryPTEUsage +=
                COMPUTE_PAGES_SPANNED(mappedAddress,
                                      NumberOfUchars);



        }

        //
        // Allocate memory to store mapped address for unmap.
        //

        newMappedAddress = ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(MAPPED_ADDRESS),
                                                 'trpV');

        //
        // Save the reference if we can allocate memory for it. If we can
        // not, just don't save it ... it's not a big deal.
        //

        if (newMappedAddress) {

            //
            // Store mapped address information.
            //

            newMappedAddress->PhysicalAddress = cardAddress;
            newMappedAddress->RefCount = 1;
            newMappedAddress->MappedAddress = mappedAddress;
            newMappedAddress->NumberOfUchars = NumberOfUchars;
            newMappedAddress->InIoSpace = InIoSpace;
            newMappedAddress->bNeedsUnmapping = bMapped;
            newMappedAddress->bLargePageRequest = bLargePage;

            //
            // Link current list to new entry.
            //

            newMappedAddress->NextMappedAddress =
                fdoExtension->MappedAddressList;

            //
            // Point anchor at new list.
            //

            fdoExtension->MappedAddressList = newMappedAddress;

        }

    } else {

        pVideoDebugPrint((1, "HalTranslateBusAddress failed !!\n"));

    }

    pVideoDebugPrint((2, "VPGetDeviceBase mapped virtual address is %08lx\n",
                    mappedAddress));

    return mappedAddress;

} // end VideoPortGetDeviceBase()


NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)

/*++

Routine Description:

    This routine gets information from the system hive, user-specified
    registry (as opposed to the information gathered by ntdetect.

Arguments:


    ValueName - Pointer to a unicode String containing the name of the data
        value being searched for.

    ValueType - Type of the data value.

    ValueData - Pointer to a buffer containing the information to be written
        out to the registry.

    ValueLength - Size of the data being written to the registry.

    Context - Specifies a context parameter passed to the callback routine.

    EntryContext - Specifies a second context parameter passed with the
        request.

Return Value:

    STATUS_SUCCESS

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    PVP_QUERY_DEVICE queryDevice = Context;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_STANDARD_INFORMATION fileStandardInfo;
    PVOID fileBuffer = NULL;
    LARGE_INTEGER byteOffset;

    //
    // If the parameter was a file to be opened, perform the operation
    // here. Otherwise just return the data.
    //

    if (queryDevice->DeviceDataType == VP_GET_REGISTRY_FILE) {

        //
        // For the name of the file to be valid, we must first append
        // \DosDevices in front of it.
        //

        RtlInitUnicodeString(&unicodeString,
                             ValueData);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE) NULL,
                                   (PSECURITY_DESCRIPTOR) NULL);

        ntStatus = ZwOpenFile(&fileHandle,
                              FILE_GENERIC_READ | SYNCHRONIZE,
                              &objectAttributes,
                              &ioStatusBlock,
                              0,
                              FILE_SYNCHRONOUS_IO_ALERT);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not open file\n"));
            goto EndRegistryCallback;

        }

        ntStatus = ZwQueryInformationFile(fileHandle,
                                          &ioStatusBlock,
                                          &fileStandardInfo,
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not get size of file\n"));
            goto EndRegistryCallback;

        }

        if (fileStandardInfo.EndOfFile.HighPart) {

            //
            // If file is too big, do not try to go further.
            //

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto EndRegistryCallback;

        }

        ValueLength = fileStandardInfo.EndOfFile.LowPart;

        fileBuffer = ExAllocatePoolWithTag(PagedPool,
                                           ValueLength,
                                           POOL_TAG);

        if (!fileBuffer) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not allocate buffer to read file\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto EndRegistryCallback;

        }

        ValueData = fileBuffer;

        //
        // Read the entire file for the beginning.
        //

        byteOffset.QuadPart = 0;

        ntStatus = ZwReadFile(fileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &ioStatusBlock,
                              ValueData,
                              ValueLength,
                              &byteOffset,
                              NULL);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not read file\n"));
            goto EndRegistryCallback;

        }

    }

    //
    // Call the miniport with the appropriate information.
    //

    queryDevice->MiniportStatus = ((PMINIPORT_GET_REGISTRY_ROUTINE)
               queryDevice->CallbackRoutine) (queryDevice->MiniportHwDeviceExtension,
                                              queryDevice->MiniportContext,
                                              ValueName,
                                              ValueData,
                                              ValueLength);

EndRegistryCallback:

    if (fileHandle) {

        ZwClose(fileHandle);

    }

    if (fileBuffer) {

        ExFreePool(fileBuffer);

    }

    return ntStatus;

} // end pVideoPortGetRegistryCallback()



VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortGetRegistryParameters retrieves information from the
    CurrentControlSet in the registry.  The function automatically searches
    for the specified parameter name under the \Devicexxx key for the
    current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ParameterName - Points to a Unicode string that contains the name of the
        data value being searched for in the registry.

    IsParameterFileName - If 1, the data retrieved from the requested
        parameter name is treated as a file name.  The contents of the file are
        returned, instead of the parameter itself.

    CallbackRoutine - Points to a function that should be called back with
        the requested information.

    Context - Specifies a context parameter passed to the callback routine.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    NTSTATUS ntStatus;
    VP_QUERY_DEVICE queryDevice;

    queryDevice.MiniportHwDeviceExtension = HwDeviceExtension;
    queryDevice.DeviceDataType = IsParameterFileName ? VP_GET_REGISTRY_FILE : VP_GET_REGISTRY_DATA;
    queryDevice.CallbackRoutine = CallbackRoutine;
    queryDevice.MiniportStatus = NO_ERROR;
    queryDevice.MiniportContext = Context;

    //
    // BUGBUG
    // Can be simplified now since we don't have to go down a directory.
    // It can be just one call.
    //

    queryTable[0].QueryRoutine = pVideoPortGetRegistryCallback;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = ParameterName;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = 0;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;
    queryTable[1].EntryContext = NULL;
    queryTable[1].DefaultType = REG_NONE;
    queryTable[1].DefaultData = 0;
    queryTable[1].DefaultLength = 0;

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                      fdoExtension->DriverRegistryPath,
                                      queryTable,
                                      &queryDevice,
                                      NULL);

    if (!NT_SUCCESS(ntStatus)) {

        queryDevice.MiniportStatus = ERROR_INVALID_PARAMETER;

    }

    return queryDevice.MiniportStatus;

} // end VideoPortGetRegistryParameters()


VOID
pVPInit(
    VOID
    )

/*++

Routine Description:

    First time initialization of the video port.

    Normally, this is the stuff we should put in the DriverEntry routine.
    However, the video port is being loaded as a DLL, and the DriverEntry
    is never called.  It would just be too much work to add it back to the hive
    and setup.

    This little routine works just as well.

--*/

{

    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS ntStatus;
    HANDLE physicalMemoryHandle = NULL;

    HAL_DISPLAY_BIOS_INFORMATION HalBiosInfo;
    ULONG HalBiosInfoLen = sizeof(ULONG);

    SYSTEM_BASIC_INFORMATION basicInfo;

#if defined(_X86_)

    //
    // Check for USWC disabling
    //

    EnableUSWC = TRUE;

#else

    EnableUSWC = FALSE;

#endif

    //
    // Determine if we have a VGA compatible machine
    //

    ntStatus = STATUS_SUCCESS;
    HalBiosInfo = HalDisplayInt10Bios;

    if (NT_SUCCESS(ntStatus)) {

        if (HalBiosInfo == HalDisplayInt10Bios) {

            VpC0000Compatible = 2;

        } else {

            // == HalDisplayEmulatedBios,
            // == HalDisplayNoBios

            VpC0000Compatible = 0;
        }

    } else {

        //
        // In case of an error in the API call, we just assume it's an old HAL
        // and use the old behaviour of the video port which is to assume
        // there is a BIOS at C000
        //

        VpC0000Compatible = 1;
    }


    //
    // Lets open the physical memory section just once, for all drivers.
    //

    //
    // Get a pointer to physical memory so we can map the
    // video frame buffer (and possibly video registers) into
    // the caller's address space whenever he needs it.
    //
    // - Create the name
    // - Initialize the data to find the object
    // - Open a handle to the oject and check the status
    // - Get a pointer to the object
    // - Free the handle
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Device\\PhysicalMemory");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenSection(&physicalMemoryHandle,
                             SECTION_ALL_ACCESS,
                             &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = ObReferenceObjectByHandle(physicalMemoryHandle,
                                             SECTION_ALL_ACCESS,
                                             (POBJECT_TYPE) NULL,
                                             KernelMode,
                                             &PhysicalMemorySection,
                                             (POBJECT_HANDLE_INFORMATION) NULL);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "pVPInit: Could not reference physical memory\n"));
            ASSERT(PhysicalMemorySection == NULL);

        }

        ZwClose(physicalMemoryHandle);
    }

    VpSystemMemorySize = 0;

    ntStatus = ZwQuerySystemInformation(SystemBasicInformation,
                                        &basicInfo,
                                        sizeof(basicInfo),
                                        NULL);

    if (NT_SUCCESS(ntStatus)) {

        VpSystemMemorySize
            = (ULONGLONG)basicInfo.NumberOfPhysicalPages * (ULONGLONG)basicInfo.PageSize;
    }
}


VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

{
    if (ValueLength && ValueData) {

        *((PULONG)Context) = *((PULONG)ValueData);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
)
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      functionalDeviceObject;
    PDEVICE_OBJECT      attachedTo;
    PFDO_EXTENSION      fdoExtension;
    ULONG               extensionAllocationSize;
    PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData;

    pVideoDebugPrint((1, "VpAddDevice\n"));

    DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(DriverObject,
                                                 DriverObject);

    HwInitializationData = &DriverObjectExtension->HwInitData;

    extensionAllocationSize = HwInitializationData->HwDeviceExtensionSize +
                                  sizeof(FDO_EXTENSION);

    ntStatus = VpCreateDevice(DriverObject,
                              extensionAllocationSize,
                              &functionalDeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        VideoDeviceNumber++;

        fdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;

        //
        // Set any deviceExtension fields here that are PnP specific
        //

        fdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;

        //
        // Since the pnp system is notifying us of our device, this is
        // not a legacy device.
        //

        fdoExtension->Flags = PNP_ENABLED;

        //
        // Now attach to the PDO we were given.
        //

        attachedTo = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject);

        if (attachedTo == NULL) {

            ASSERT(attachedTo != NULL);

            //
            // Couldn't attach.  Delete the FDO.
            //

            // BUGBUG
            //IoDeleteDevice(functionalDeviceObject);
            //return STATUS_NO_SUCH_DEVICE;
        }

        fdoExtension->AttachedDeviceObject = attachedTo;

        //
        // Set the power management flag indicating that device mapping
        // has not been done yet.
        //

        fdoExtension->IsMappingReady = FALSE ;

        //
        // Clear DO_DEVICE_INITIALIZING flag.
        //

        functionalDeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        //
        // Save the function pointers to the new 5.0 miniport driver callbacks.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

            fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
            fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
            fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;
        }
    }

    pVideoDebugPrint((1, "*\n* VpAddDevice returned: 0x%x\n*\n", ntStatus));

    return ntStatus;
}


NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
)
{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    UNICODE_STRING deviceNameUnicodeString;
    DEVICE_OBJECT fdo;
    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension;

    ntStatus = pVideoPortCreateDeviceName(L"\\Device\\Video",
                                          VideoDeviceNumber,
                                          &deviceNameUnicodeString,
                                          deviceNameBuffer);

    //
    // Create a device object to represent the Video Adapter.
    //

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = IoCreateDevice(DriverObject,
                                  DeviceExtensionSize,
                                  &deviceNameUnicodeString,
                                  FILE_DEVICE_VIDEO,
                                  0,
                                  TRUE,
                                  FunctionalDeviceObject);

        if (NT_SUCCESS(ntStatus)) {

            (*FunctionalDeviceObject)->DeviceType = FILE_DEVICE_VIDEO;
            fdoExtension = (*FunctionalDeviceObject)->DeviceExtension;

            //
            // Set any deviceExtension fields here
            //

            fdoExtension->DeviceNumber = VideoDeviceNumber;
            fdoExtension->FunctionalDeviceObject = *FunctionalDeviceObject;

            KeInitializeMutex(&fdoExtension->SyncMutex,
                              0);

#if DBG
            fdoExtension->AllocationHead = (PALLOC_ENTRY) NULL;
            ExInitializePagedLookasideList(&fdoExtension->AllocationList,
                                           NULL,
                                           NULL,
                                           0,
                                           sizeof(ALLOC_ENTRY),
                                           'LdiV',
                                           0);
#endif

        }
    }

    return ntStatus;
}

ULONG
VideoPortInitialize(
    IN PVOID Argument1,  // DriverObject
    IN PVOID Argument2,  // RegistryPath
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )
{
    PDRIVER_OBJECT driverObject = Argument1;
    NTSTATUS ntStatus;
    PUNICODE_STRING   registryPath = (PUNICODE_STRING) Argument2;
    ULONG PnpFlags;

    if (VPFirstTime)
    {
        VPFirstTime = FALSE;
        pVPInit();
    }

    //
    // Check if the size of the pointer, or the size of the data passed in
    // are OK.
    //

    ASSERT(HwInitializationData != NULL);

    if (HwInitializationData->HwInitDataSize >
        sizeof(VIDEO_HW_INITIALIZATION_DATA) ) {

        pVideoDebugPrint((0, "VideoPortInitialize: Invalid initialization data size\n"));
        return ((ULONG) STATUS_REVISION_MISMATCH);

    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwStartIO)) {

        pVideoDebugPrint((1, "VideoPortInitialize: miniport missing required entry\n"));
        return ((ULONG)STATUS_REVISION_MISMATCH);

    }

    //
    // Set up the device driver entry points.
    //

    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CREATE]         = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CLOSE]          = pVideoPortDispatch;

    //
    // Check that the device extension size is reasonable.
    //

#if DBG
    if (HwInitializationData->HwDeviceExtensionSize > 0x4000) {
        pVideoDebugPrint((0, "Warning: Device Extension is stored in non-paged pool\n"
                             "         Do you need a 0x%x byte device extension?\n",
                             HwInitializationData->HwDeviceExtensionSize));
    }
#endif

    //
    // Check the registry for PnP Flags.  Currently we recongnize the
    // following values:
    //
    // PnPEnabled -   If this value is set with a non-zero value, we
    //                will treat behave like a PnP driver.
    //
    // LegacyDetect - If this value is non-zero, we will report
    //                a non-pci device to the system via
    //                IoReportDetectedDevice.
    //
    // If we don't get the flags, we don't know how to run this driver.
    // return failure
    //

    if (!(NT_SUCCESS(VpGetFlags(registryPath,
                                HwInitializationData,
                                &PnpFlags))))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // PnP drivers have new rules.
    //

    if (PnpFlags & PNP_ENABLED)
    {
        pVideoDebugPrint((1, "videoprt : VideoPortInitialize with PNP_ENABLED\n"));

        //
        // We also can't be plug and play compatible if the driver passes
        // info in HwContext.  This is because we can't store this.
        //

        if ((PnpFlags & VGA_DRIVER) ||
            (HwContext != NULL))
        {
            pVideoDebugPrint((0, "videoprt : This video driver can not be PnP !\n"));
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Only allow a non-pnp driver to install before win32k has started.
        //

        if (!InbvCheckDisplayOwnership()) {

            pVideoDebugPrint((0, "We can't dynamically start a non PnP device.\n"));
#if defined STATUS_REBOOT_REQUIRED
            return STATUS_REBOOT_REQUIRED;
#else
            return STATUS_INVALID_PARAMETER;
#endif
        }
    }

    //
    // Never do legacy detection of PnP drivers on the PCI Bus.
    //

    if (HwInitializationData->AdapterInterfaceType == PCIBus) {

        pVideoDebugPrint((1, "videoprt : VideoPortInitialize on PCI Bus\n"));

        if ( (PnpFlags & PNP_ENABLED) &&
             ((PnpFlags & LEGACY_DETECT) ||
              (PnpFlags & REPORT_DEVICE)) ) {

            pVideoDebugPrint((0, "videoprt : Trying to detect PnP driver on PCI - fail\n"));
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Set this information for all PnP Drivers
    //
    // Special !!! - we cannot do this in the LEGACY_DETECT because the system
    // will think we failed to load and return a failure code.
    //

    if ( (PnpFlags & PNP_ENABLED) &&
         (!(PnpFlags & LEGACY_DETECT)) )
    {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;

        pVideoDebugPrint((1, "videoprt : We have a PnP Device.\n"));

        //
        // Fill in the new PnP entry points.
        //

        driverObject->DriverExtension->AddDevice  = VpAddDevice;
        driverObject->MajorFunction[IRP_MJ_PNP]   = pVideoPortPnpDispatch;

        //
        // we'll do findadapter during the START_DEVICE irp
        //
        // Store away arguments, so we can retrieve them when we need them.
        //
        // Try to create a DriverObjectExtension
        //

        if (DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(driverObject,
                                                 driverObject))
        {
            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else if (NT_SUCCESS(IoAllocateDriverObjectExtension(
                                driverObject,
                                driverObject,
                                sizeof(VIDEO_PORT_DRIVER_EXTENSION),
                                &DriverObjectExtension)))
        {

            DriverObjectExtension->RegistryPath = *registryPath;
            DriverObjectExtension->RegistryPath.MaximumLength += sizeof(WCHAR);
            DriverObjectExtension->RegistryPath.Buffer =
                ExAllocatePoolWithTag(PagedPool,
                                      DriverObjectExtension->RegistryPath.MaximumLength,
                                      'trpV');

            ASSERT(DriverObjectExtension->RegistryPath.Buffer);

            RtlCopyUnicodeString(&(DriverObjectExtension->RegistryPath),
                                 registryPath);

            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Something went wrong.  We should have a
            // DriverObjectExtension by now.
            //

            pVideoDebugPrint((0, "IoAllocateDriverExtensionObject failed!\n"));
            pVideoDebugPrint((0, "for registry path %ws!\n", registryPath->Buffer));

            ASSERT(FALSE);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }


    //
    // If we are doing legacy detection or reporting, create the FDO
    // right now ...
    //

    if ((!(PnpFlags & PNP_ENABLED))  ||
         (PnpFlags & LEGACY_DETECT)  ||
         (PnpFlags & VGA_DRIVER)     ||
         (PnpFlags & REPORT_DEVICE)  ||
         (HwContext != NULL)) {

        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}


NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    status = VideoPortFindAdapter2(DriverObject,
                                   Argument2,
                                   HwInitializationData,
                                   HwContext,
                                   DeviceObject,
                                   nextMiniport);

    if (NT_SUCCESS(status))
    {
        //
        // Mark this object as supporting buffered I/O so that the I/O system
        // will only supply simple buffers in IRPs.
        //
        // Set and clear the two power fields to ensure we only get called
        // as passive level to do power management operations.
        //
        // Finally, tell the system we are done with Device Initialization
        //

        DeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        fdoExtension->Flags |= FINDADAPTER_SUCCEEDED;
    }

    return status;
}


NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )

{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    POBJECT_NAME_INFORMATION deviceName;
    ULONG strLength;

    NTSTATUS ntStatus;
    WCHAR deviceSubpathBuffer[STRING_LENGTH];
    UNICODE_STRING deviceSubpathUnicodeString;
    WCHAR deviceLinkBuffer[STRING_LENGTH];
    UNICODE_STRING deviceLinkUnicodeString;
    KAFFINITY affinity;

    PVIDEO_PORT_CONFIG_INFO miniportConfigInfo = NULL;
    PDEVICE_OBJECT deviceObject;
    PFDO_EXTENSION fdoExtension;
    VP_STATUS findAdapterStatus = ERROR_DEV_NOT_EXIST;
    ULONG driverKeySize;
    PWSTR driverKeyName = NULL;
    BOOLEAN symbolicLinkCreated = FALSE;

    PDEVICE_OBJECT pdo;

    ntStatus = STATUS_NO_SUCH_DEVICE;

    deviceObject = DeviceObject;
    fdoExtension = deviceObject->DeviceExtension;

    pdo = fdoExtension->PhysicalDeviceObject;

    deviceName = (POBJECT_NAME_INFORMATION) deviceNameBuffer;

    ObQueryNameString(deviceObject,
                      deviceName,
                      STRING_LENGTH * sizeof(WCHAR),
                      &strLength);

    //
    // Allocate the buffer in which the miniport driver will store all the
    // configuration information.
    //

    miniportConfigInfo = (PVIDEO_PORT_CONFIG_INFO)
                             ExAllocatePoolWithTag(PagedPool,
                                                   sizeof(VIDEO_PORT_CONFIG_INFO),
                                                   POOL_TAG);

    if (miniportConfigInfo == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlZeroMemory((PVOID) miniportConfigInfo,
                  sizeof(VIDEO_PORT_CONFIG_INFO));

    miniportConfigInfo->Length = sizeof(VIDEO_PORT_CONFIG_INFO);

    //
    // Put in the BusType specified within the HW_INITIALIZATION_DATA
    // structure by the miniport and the bus number inthe miniport config info.
    //

    miniportConfigInfo->SystemIoBusNumber = fdoExtension->SystemIoBusNumber;
    miniportConfigInfo->AdapterInterfaceType = fdoExtension->AdapterInterfaceType;

    //
    // Initialize the pointer to VpGetProcAddress.
    //

    miniportConfigInfo->VideoPortGetProcAddress = VpGetProcAddress;

    //
    // Initialize the type of interrupt based on the bus type.
    //

    switch (miniportConfigInfo->AdapterInterfaceType) {

    case Internal:
    case MicroChannel:
    case PCIBus:

        miniportConfigInfo->InterruptMode = LevelSensitive;
        break;

    default:

        miniportConfigInfo->InterruptMode = Latched;
        break;

    }

    //
    // Set up device extension pointers and sizes
    //

    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);
    fdoExtension->HwDeviceExtensionSize =
        HwInitializationData->HwDeviceExtensionSize;
    fdoExtension->MiniportConfigInfo = miniportConfigInfo;

    //
    // Save the dependent driver routines in the device extension.
    //

    fdoExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    fdoExtension->HwInitialize = HwInitializationData->HwInitialize;
    fdoExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    fdoExtension->HwStartIO = HwInitializationData->HwStartIO;

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

        fdoExtension->HwLegacyResourceList = HwInitializationData->HwLegacyResourceList;
        fdoExtension->HwLegacyResourceCount = HwInitializationData->HwLegacyResourceCount;
    }

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, AllowEarlyEnumeration)) {

        fdoExtension->AllowEarlyEnumeration = HwInitializationData->AllowEarlyEnumeration;
    }

    //
    // Create the name we will be storing in the \DeviceMap.
    // This name is a PWSTR, not a unicode string
    // This is the name of the driver with an appended device number
    //

    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\Device",
                                               HwInitializationData->StartingDeviceNumber,
                                               &deviceSubpathUnicodeString,
                                               deviceSubpathBuffer))) {

        pVideoDebugPrint((1, "VideoPortInitialize: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    fdoExtension->DriverRegistryPathLength =
        ((PUNICODE_STRING)Argument2)->Length +
        deviceSubpathUnicodeString.Length;

    driverKeySize = fdoExtension->DriverRegistryPathLength +
                    2 * sizeof(UNICODE_NULL);

    if ( (driverKeyName = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                                        driverKeySize,
                                                        POOL_TAG) ) == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlMoveMemory(driverKeyName,
                  ((PUNICODE_STRING)Argument2)->Buffer,
                  ((PUNICODE_STRING)Argument2)->Length);

    RtlMoveMemory((PWSTR)( (ULONG_PTR)driverKeyName +
                           ((PUNICODE_STRING)Argument2)->Length ),
                  deviceSubpathBuffer,
                  deviceSubpathUnicodeString.Length);

    //
    // Put two NULLs at the end so we can play around with the string later.
    //

    *((PWSTR) ((ULONG_PTR)driverKeyName +
        fdoExtension->DriverRegistryPathLength)) = UNICODE_NULL;
    *((PWSTR) ((ULONG_PTR)driverKeyName +
        (fdoExtension->DriverRegistryPathLength + sizeof(UNICODE_NULL)))) =
                                                      UNICODE_NULL;

    //
    // There is a bug in Lotus Screen Cam where it will only work if our
    // reg path is \REGISTRY\Machine\System not \REGISTRY\MACHINE\SYSTEM.
    // so replace the appropriate strings.
    //

    if (wcsstr(driverKeyName, L"MACHINE")) {
        wcsncpy(wcsstr(driverKeyName, L"MACHINE"), L"Machine", sizeof("Machine")-1);
    }

    if (wcsstr(driverKeyName, L"SYSTEM")) {
        wcsncpy(wcsstr(driverKeyName, L"SYSTEM"), L"System", sizeof("System")-1);
    }

    //
    // Store the path name of the location of the driver in the registry.
    //

    fdoExtension->DriverRegistryPath = driverKeyName;
    miniportConfigInfo->DriverRegistryPath = driverKeyName;

    //
    // Let the driver know how much system memory is present.
    //

    miniportConfigInfo->SystemMemorySize = VpSystemMemorySize;

    //
    // Turn on the debug level based on the miniport driver entry
    //

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"VideoDebugLevel",
                                   FALSE,
                                   VpRegistryCallback,
                                   &VideoDebugLevel);

    //
    // Obtain the override value for memory allocation from the registry
    // if present. Otherwise, go with the default.
    //

#if DBG
    //
    // Turn on the debug level based on the miniport driver entry
    //

    fdoExtension->FreeAllocation = MAXIMUM_MEM_LIMIT_K * 1024 ;
    fdoExtension->AllocationHead = (PALLOC_ENTRY) NULL ;

    //
    // Set up the default maximum allocation.  This will change
    // if there is a value in the registry.
    //

    fdoExtension->FreeAllocation = MAXIMUM_MEM_LIMIT_K * 1024 ;

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"MaxAllocationLimit",
                                   FALSE,
                                   VpRegistryCallback,
                                   &(fdoExtension->FreeAllocation));

#endif

    if (VpAllowFindAdapter(fdoExtension)) {

        //
        // Notify the boot driver that we will be accessing the display
        // hardware.
        //

        VpEnableDisplay(FALSE);

#if DBG
        //
        // Mark the resources as not reported so we can detect if a miniport
        // uses an access range before reporting it.
        //

        InterlockedExchange(&VPResourcesReported, FALSE);

        //
        // The driver doesn't have to aquire resources if it claimed
        // them during DriverEntry.
        //

        if (fdoExtension->HwLegacyResourceCount) {
            InterlockedIncrement(&VPResourcesReported);
        }
#endif

        findAdapterStatus =
            fdoExtension->HwFindAdapter(fdoExtension->HwDeviceExtension,
                                        HwContext,
                                        NULL, // BUGBUG What is this string?
                                        miniportConfigInfo,
                                        nextMiniport);

#if DBG
        //
        // By now, the resources should have been claimed.
        //

        InterlockedIncrement(&VPResourcesReported);
#endif

        VpEnableDisplay(TRUE);
    }

    //
    // If the adapter is not found, display an error.
    //

    if (findAdapterStatus != NO_ERROR) {

        pVideoDebugPrint((1, "VideoPortFindAdapter: Find adapter failed\n"));

        ntStatus = STATUS_UNSUCCESSFUL;
        goto EndOfInitialization;

    }

    //
    // Store the required information in the device extension for later use.
    //

    fdoExtension->VdmPhysicalVideoMemoryAddress =
        miniportConfigInfo->VdmPhysicalVideoMemoryAddress;

    fdoExtension->VdmPhysicalVideoMemoryLength =
        miniportConfigInfo->VdmPhysicalVideoMemoryLength;

    fdoExtension->HardwareStateSize =
        miniportConfigInfo->HardwareStateSize;

    //
    // If the device supplies an interrupt service routine, we must
    // set up all the structures to support interrupts. Otherwise,
    // they can be ignored.
    //

    if (fdoExtension->HwInterrupt &&
        ((miniportConfigInfo->BusInterruptLevel != 0) ||
         (miniportConfigInfo->BusInterruptVector != 0)) ) {

        affinity = fdoExtension->InterruptAffinity;

        fdoExtension->InterruptMode = miniportConfigInfo->InterruptMode;

        fdoExtension->InterruptsEnabled = TRUE;

        ntStatus = IoConnectInterrupt(&fdoExtension->InterruptObject,
                                      (PKSERVICE_ROUTINE) pVideoPortInterrupt,
                                      deviceObject,
                                      NULL,
                                      fdoExtension->InterruptVector,
                                      fdoExtension->InterruptIrql,
                                      fdoExtension->InterruptIrql,
                                      fdoExtension->InterruptMode,
                                      (BOOLEAN) ((miniportConfigInfo->InterruptMode ==
                                          LevelSensitive) ? TRUE : FALSE),
                                      affinity,
                                      FALSE);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((0, "VideoPortInitialize: Can't connect interrupt\n"));
            goto EndOfInitialization;
        }

    } else {

        fdoExtension->HwInterrupt = NULL;

    }

    //
    // Initialize DPC Support
    //

    KeInitializeDpc(&fdoExtension->Dpc,
                    pVideoPortDpcDispatcher,
                    fdoExtension->HwDeviceExtension);

    //
    // New, Optional.
    // Setup the timer if it is specified by a driver.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwTimer)){

        fdoExtension->HwTimer = HwInitializationData->HwTimer;

        if (fdoExtension->HwTimer) {
            ntStatus = IoInitializeTimer(deviceObject,
                                         pVideoPortHwTimer,
                                         NULL);

            //
            // If we fail forget about the timer !
            //

            if (!NT_SUCCESS(ntStatus)) {

                ASSERT(FALSE);
                fdoExtension->HwTimer = NULL;

            }
        }
    }

    //
    // New, Optional.
    // Reset Hw function.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

        ULONG iReset;

        for (iReset=0; iReset<6; iReset++) {

            if (HwResetHw[iReset].ResetFunction == NULL) {

                HwResetHw[iReset].ResetFunction = HwInitializationData->HwResetHw;
                HwResetHw[iReset].HwDeviceExtension = fdoExtension->HwDeviceExtension;

                break;
            }
        }
    }

    //
    // NOTE:
    //
    // We only want to reinitialize the device once the Boot sequence has
    // been completed and the HAL does not need to access the device again.
    // So the initialization entry point will be called when the device is
    // opened.
    //


    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\DosDevices\\DISPLAY",
                                               fdoExtension->DeviceNumber + 1,
                                               &deviceLinkUnicodeString,
                                               deviceLinkBuffer))) {

        pVideoDebugPrint((1, "VideoPortInitialize: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString,
                                    &deviceName->Name);


    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((0, "VideoPortInitialize: SymbolicLink Creation failed\n"));
        goto EndOfInitialization;

    }

    symbolicLinkCreated = TRUE;

    //
    // Save the function pointers to the new 5.0 miniport driver callbacks.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

        fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
        fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
        fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;
    }

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwChildDeviceExtensionSize)) {

        fdoExtension->HwChildDeviceExtensionSize =
            HwInitializationData->HwChildDeviceExtensionSize;
    }


EndOfInitialization:

    //
    // If we are doing detection, then don't save all of these objects.
    // We just want to see if the driver would load or not
    //

    if ( (fdoExtension->Flags & LEGACY_DETECT) ||
         (!NT_SUCCESS(ntStatus)) )
    {
        //
        // Free the miniport config info buffer.
        //

        if (miniportConfigInfo) {
            ExFreePool(miniportConfigInfo);
        }

        //
        // These are the things we want to delete if they were created and
        // the initialization *FAILED* at a later time.
        //

        if (fdoExtension->InterruptObject) {
            IoDisconnectInterrupt(fdoExtension->InterruptObject);
        }

        if (driverKeyName) {
            ExFreePool(driverKeyName);
        }

        fdoExtension->DriverRegistryPath = NULL;

        if (symbolicLinkCreated) {
            IoDeleteSymbolicLink(&deviceLinkUnicodeString);
        }

        //
        // Free up any memory mapped in by the miniport using
        // VideoPort GetDeviceBase.
        //

        while (fdoExtension->MappedAddressList != NULL)
        {
            pVideoDebugPrint((0, "VideoPortInitialize: unfreed address %08lx, physical %08lx, size %08lx\n",
                                 fdoExtension->MappedAddressList->MappedAddress,
                                 fdoExtension->MappedAddressList->PhysicalAddress.LowPart,
                                 fdoExtension->MappedAddressList->NumberOfUchars));

            pVideoDebugPrint((0, "VideoPortInitialize: unfreed refcount %d, unmapping %d\n\n",
                                 fdoExtension->MappedAddressList->RefCount,
                                 fdoExtension->MappedAddressList->bNeedsUnmapping));

            VideoPortFreeDeviceBase(fdoExtension->HwDeviceExtension,
                                    fdoExtension->MappedAddressList->MappedAddress);
        }

        //
        // Remove any HwResetHw function we may have added for this device.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

            ULONG iReset;

            for (iReset=0; iReset<6; iReset++) {

                if (HwResetHw[iReset].HwDeviceExtension ==
                    fdoExtension->HwDeviceExtension) {

                    HwResetHw[iReset].ResetFunction = NULL;
                    break;
                }
            }
        }

    } else {

        HwInitializationData->StartingDeviceNumber++;

    }

#if DBG
    if ((!NT_SUCCESS(ntStatus)) || (findAdapterStatus != NO_ERROR)) {
      if (fdoExtension->AllocationHead != NULL) {
        pVideoDebugPrint((0, "VIDEOPRT: CANNOT DELETE DEVICE WITH")) ;
        pVideoDebugPrint((0, "          OUTSTANDING ALLOCATIONS."));
        ASSERT(FALSE);
      }
      ExDeletePagedLookasideList (&fdoExtension->AllocationList);
    }
#endif

    return ntStatus;
}


BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function is the main interrupt service routine. If finds which
    miniport driver the interrupt was for and forwards it.

Arguments:

    Interrupt -

    DeviceObject -

Return Value:

    Returns TRUE if the interrupt was expected.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    BOOLEAN bRet;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // If there is no interrupt routine, fail the assertion
    //

    ASSERT (fdoExtension->HwInterrupt);

#if DBG
    InterlockedIncrement(&VPResourcesReported);
#endif

    if (fdoExtension->InterruptsEnabled) {
        bRet = fdoExtension->HwInterrupt(fdoExtension->HwDeviceExtension);
    } else {
        bRet = FALSE;  // this device did not handle the interrupt
    }

#if DBG
    InterlockedDecrement(&VPResourcesReported);
#endif

    return bRet;

} // pVideoPortInterrupt()


VOID
VideoPortLogError(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    IN VP_STATUS ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information so it can be processed at
    any IRQL.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Vrp - Supplies an optional pointer to a video request packet if there is
        one.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
} // end VideoPortLogError()


VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        pVideoDebugPrint((0, "Invalid return value from HwStartIo!\n"));
        ASSERT(FALSE);

        //
        // Since the driver did not see fit to follow the
        // rules about returning correct error codes. Videoprt will do it for
        // them.
        //

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} // end pVideoPortMapToNtStatus()


NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    )

/*++

Routine Description:

    This function maps a view of a block of physical memory into a process'
    virtual address space.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ProcessHandle - Optional handle to the process into which the memory must
        be mapped.

    PhysicalAddress - Offset from the beginning of physical memory, in bytes.

    Length - Pointer to a variable that will receive that actual size in
        bytes of the view. The length is rounded to a page boundary. THe
        length may not be zero.

    InIoSpace - Specifies if the address is in the IO space if TRUE; otherwise,
        the address is assumed to be in memory space.

    VirtualAddress - Pointer to a variable that will receive the base
        address of the view. If the initial value is not NULL, then the view
        will be allocated starting at teh specified virtual address rounded
        down to the next 64kb addess boundary.

Return Value:

    STATUS_UNSUCCESSFUL if the length was zero.
    STATUS_SUCCESS otherwise.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntStatus;
    HANDLE physicalMemoryHandle;
    PHYSICAL_ADDRESS physicalAddressBase;
    PHYSICAL_ADDRESS physicalAddressEnd;
    PHYSICAL_ADDRESS viewBase;
    PHYSICAL_ADDRESS mappedLength;
    HANDLE processHandle;
    BOOLEAN translateBaseAddress;
    BOOLEAN translateEndAddress;
    ULONG inIoSpace2;
    ULONG inIoSpace1;
    ULONG MapViewFlags;

    //
    // Check for a length of zero. If it is, the entire physical memory
    // would be mapped into the process' address space. An error is returned
    // in this case.
    //

    if (!*Length) {

        return STATUS_INVALID_PARAMETER_4;

    }

    if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)) {

        return STATUS_INVALID_PARAMETER_5;

    }

    //
    // Get a handle to the physical memory section using our pointer.
    // If this fails, return.
    //

    ntStatus = ObOpenObjectByPointer(PhysicalMemorySection,
                                     0L,
                                     (PACCESS_STATE) NULL,
                                     SECTION_ALL_ACCESS,
                                     (POBJECT_TYPE) NULL,
                                     KernelMode,
                                     &physicalMemoryHandle);

    if (!NT_SUCCESS(ntStatus)) {

        return ntStatus;

    }

#ifdef _ALPHA_

    //
    // All flags are necessary for translation on ALPHA, except the P6 FLAG
    //

    inIoSpace1 = *InIoSpace & ~VIDEO_MEMORY_SPACE_P6CACHE;
    inIoSpace2 = *InIoSpace & ~VIDEO_MEMORY_SPACE_P6CACHE;

#else

    //
    // No flags are used in translation on non-alpha
    //

    inIoSpace1 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;
    inIoSpace2 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;

#endif

    //
    // Initialize the physical addresses that will be translated
    //

    physicalAddressEnd.QuadPart = PhysicalAddress.QuadPart + (*Length - 1);

    //
    // Translate the physical addresses.
    //

    translateBaseAddress =
        HalTranslateBusAddress(FdoExtension->AdapterInterfaceType,
                               FdoExtension->SystemIoBusNumber,
                               PhysicalAddress,
                               &inIoSpace1,
                               &physicalAddressBase);

    translateEndAddress =
        HalTranslateBusAddress(FdoExtension->AdapterInterfaceType,
                               FdoExtension->SystemIoBusNumber,
                               physicalAddressEnd,
                               &inIoSpace2,
                               &physicalAddressEnd);

    if ( !(translateBaseAddress && translateEndAddress) ) {

        ZwClose(physicalMemoryHandle);

        return STATUS_DEVICE_CONFIGURATION_ERROR;

    }

    ASSERT(inIoSpace1 == inIoSpace2);

    //
    // Calcualte the length of the memory to be mapped
    //

    mappedLength.QuadPart = physicalAddressEnd.QuadPart -
                            physicalAddressBase.QuadPart + 1;

    pVideoDebugPrint((3, "mapped Length = %x\n", mappedLength));

#ifndef _ALPHA_

    //
    // On all systems except ALPHA the mapped length should be the same as
    // the translated length.
    //

    ASSERT (((ULONG_PTR)mappedLength.QuadPart) == *Length);

#endif

    //
    // If the mappedlength is zero, somthing very weird happened in the HAL
    // since the Length was checked against zero.
    //

    ASSERT (mappedLength.QuadPart != 0);

    //
    // If the address is in io space, just return the address, otherwise
    // go through the mapping mechanism
    //

    if ( (*InIoSpace) & (ULONG)0x01 ) {

        (ULONG_PTR) *VirtualAddress = (ULONG_PTR) physicalAddressBase.QuadPart;

    } else {


        //
        // If no process handle was passed, get the handle to the current
        // process.
        //

        if (ProcessHandle) {

            processHandle = ProcessHandle;

        } else {

            processHandle = NtCurrentProcess();

        }

        //
        // initialize view base that will receive the physical mapped
        // address after the MapViewOfSection call.
        //

        viewBase = physicalAddressBase;

        //
        // Map the section
        //

        //
        // BUGBUG - what to do with already cached memory ???
        //

        if ((*InIoSpace) & VIDEO_MEMORY_SPACE_P6CACHE) {
            MapViewFlags = PAGE_READWRITE | PAGE_WRITECOMBINE;
        } else {
            MapViewFlags = PAGE_READWRITE | PAGE_NOCACHE;
        }

        ntStatus = ZwMapViewOfSection(physicalMemoryHandle,
                                      processHandle,
                                      VirtualAddress,
                                      0L,
                                      (ULONG_PTR) mappedLength.QuadPart,
                                      &viewBase,
                                      (PULONG_PTR) (&(mappedLength.QuadPart)),
                                      ViewUnmap,
                                      0,
                                      MapViewFlags);

        //
        // Close the handle since we only keep the pointer reference to the
        // section.
        //

        ZwClose(physicalMemoryHandle);

        //
        // Mapping the section above rounded the physical address down to the
        // nearest 64 K boundary. Now return a virtual address that sits where
        // we wnat by adding in the offset from the beginning of the section.
        //


        (ULONG_PTR) *VirtualAddress += (ULONG_PTR) (physicalAddressBase.QuadPart -
                                                  viewBase.QuadPart);
    }

#ifdef _ALPHA_

    //
    // Return the proper set of modified flags.
    //

    *InIoSpace = inIoSpace1 | *InIoSpace & VIDEO_MEMORY_SPACE_P6CACHE;

#else

    //
    // Restore all the other FLAGS
    // BUGBUG P6 flag may be affected !!
    //

    *InIoSpace = inIoSpace1 | *InIoSpace & ~VIDEO_MEMORY_SPACE_IO;

#endif

    *Length = mappedLength.LowPart;

    return ntStatus;

} // end pVideoPortMapUserPhysicalMem()

VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    )
{
    //
    // This routine attempts to allocate a paged pool buffer on behalf of a given
    // video miniport driver.
    //

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT (HwDeviceExtension) ;
    PALLOC_ENTRY allocEntry, currentEntry ;

#if DBG
    if ((fdoExtension->FreeAllocation - (LONG)Size) < 0) {
        *Buffer = NULL ;
        pVideoDebugPrint ((0, "VIDEOPRT: Failing excessive allocation.\n"));
        return ERROR_INSUFFICIENT_BUFFER ;
    }
#endif

    *Buffer = ExAllocatePoolWithTag (PagedPool, Size, 'RdiV');
    if (*Buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

#if DBG
    fdoExtension->FreeAllocation -= Size ;
    allocEntry = ExAllocateFromPagedLookasideList (&fdoExtension->AllocationList);
    allocEntry->Address = *Buffer ;
    allocEntry->Size = Size;
    allocEntry->Next = fdoExtension->AllocationHead ;
    fdoExtension->AllocationHead = allocEntry ;
#endif

    return NO_ERROR ;
}

VOID
VideoPortReleaseBuffer(
    IN PVOID HwDeviceExtension,
    IN PVOID Buffer
    )
{
  //
  // This routine releases a buffer allocated for a miniport driver by
  // VideoPortReleaseBuffer.
  //

#if DBG
    PALLOC_ENTRY currentEntry, prevEntry ;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT (HwDeviceExtension) ;
    ASSERT (fdoExtension->AllocationHead != NULL) ;

    prevEntry = NULL ;
    currentEntry = fdoExtension->AllocationHead ;
    while (currentEntry->Address != Buffer) {
        prevEntry = currentEntry ;
        currentEntry = currentEntry->Next ;
        if (currentEntry == NULL) {
            pVideoDebugPrint ((0, "VIDEOPRT: Freeing memory not allocated!\n"));
            ASSERT (FALSE) ;
        }
    }

    if (prevEntry != NULL) {
        prevEntry->Next = currentEntry->Next ;
    } else {
        fdoExtension->AllocationHead = currentEntry->Next ;
    }
    fdoExtension->FreeAllocation += currentEntry->Size ;

    ExFreeToPagedLookasideList (&(fdoExtension->AllocationList),
                                currentEntry) ;
#endif

    ExFreePool (Buffer) ;
}


VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    )

/*++

Routine Description:

    VideoPortMapMemory allows the miniport driver to map a section of
    physical memory (either memory or registers) into the calling process'
    address space (eventhough we are in kernel mode, this function is
    executed within the same context as the user-mode process that initiated
    the call).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    PhysicalAddress - Specifies the physical address to be mapped.

    Length - Points to the number of bytes of physical memory to be mapped.
        This argument returns the actual amount of memory mapped.

    InIoSpace - Points to a variable that is 1 if the address is in I/O
        space.  Otherwise, the address is assumed to be in memory space.

    VirtualAddress - A pointer to a location containing:

        on input: An optional handle to the process in which the memory must
            be mapped. 0 must be used to map the memory for the display
            driver (in the context of the windows server process).

        on output:  The return value is the virtual address at which the
            physical address has been mapped.

Return Value:

    VideoPortMapMemory returns the status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    HANDLE processHandle;

    //
    // Check for valid pointers.
    //

    if (!(ARGUMENT_PRESENT(Length)) ||
        !(ARGUMENT_PRESENT(InIoSpace)) ||
        !(ARGUMENT_PRESENT(VirtualAddress)) ) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Let's handle the special memory types here.
    //
    // NOTE
    // Large pages is automatic - the caller need not specify this attribute
    // since it does not affect the device.

    //
    // Save the process handle and zero out the Virtual address field
    //

    if (*VirtualAddress == NULL) {

        if (*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)
        {
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        pVideoDebugPrint((3, "VideoPortMapMemory: Map Physical Address %08lx\n",
                         PhysicalAddress));

        ntStatus = STATUS_SUCCESS;

        //
        // We specify TRUE for large pages since we know the addrses will only
        // be used in the context of the display driver, at normal IRQL.
        //

        *VirtualAddress = pVideoPortGetDeviceBase(HwDeviceExtension,
                                                  PhysicalAddress,
                                                  *Length,
                                                  (UCHAR) (*InIoSpace),
                                                  TRUE);

        //
        // Zero can only be success if the driver is calling to MAP
        // address 0.  Otherwise, it is an error.
        // BUGBUG - is this really robust.
        //

        if (*VirtualAddress == NULL) {

            //
            // Only on X86 can the logical address also be 0.
            //

#if defined (_X86_) || defined (_ALPHA_) || defined(_IA64_)
            if (PhysicalAddress.QuadPart != 0)
#endif
                ntStatus = STATUS_INVALID_PARAMETER;
        }

    } else {

        if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE))
        {
            //
            // We can not assert since this is an existing path and old
            // drivers will not have this flag set.
            //
            // ASSERT(FALSE);
            // return ERROR_INVALID_PARAMETER;
            //

            *InIoSpace |= VIDEO_MEMORY_SPACE_USER_MODE;
        }

        processHandle = (HANDLE) *VirtualAddress;
        *VirtualAddress = NULL;

        pVideoDebugPrint((3, "VideoPortMapMemory: Map Physical Address %08lx\n",
                         PhysicalAddress));

        ntStatus = pVideoPortMapUserPhysicalMem(fdoExtension,
                                                processHandle,
                                                PhysicalAddress,
                                                Length,
                                                InIoSpace,
                                                VirtualAddress);

    }

    if (!NT_SUCCESS(ntStatus)) {

        *VirtualAddress = NULL;

        pVideoDebugPrint((0, "VideoPortMapMemory failed with NtStatus = %08lx\n",
                         ntStatus));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;

    } else {

        pVideoDebugPrint((3, "VideoPortMapMemory succeded with Virtual Address = %08lx\n",
                         *VirtualAddress));

        return NO_ERROR;

    }

} // end VideoPortMapMemory()



VOID
pVideoPortPowerCompletionIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    Completion routine that is called when one of our power irps has been
    comeplted.  This allows us to fill out the status code for the request.

Arguments:

    DeviceObject  - Pointer to the device object

    MinorFunction - Minor function of the IRP

    PowerState    - Power state that was set

    Context       - Context paramter

    IoStatus      - Status block for that IRP

Return Value:

    VOID

Environment:

--*/

{
    PPOWER_BLOCK powerContext = (PPOWER_BLOCK) Context;

    if (powerContext->FinalFlag == TRUE) {
        powerContext->Irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest (powerContext->Irp, IO_VIDEO_INCREMENT);
    }

    ExFreePool(Context);

    return;
}




BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    )

/*++

Routine Description:

    Callback for the HAL that calls the miniport driver.

Arguments:

    Columns - The number of columns of the video mode.

    Rows - The number of rows for the video mode.

Return Value:

    We always return FALSE so the HAL will always reste the mode afterwards.

Environment:
                        mep videoprt.cod
    Non-paged only.
    Used in BugCheck and soft-reset calls.

--*/

{

    ULONG iReset;
    BOOLEAN bRetVal = FALSE;

    for (iReset=0;
         (iReset < 6) && (HwResetHw[iReset].HwDeviceExtension);
         iReset++) {

        PFDO_EXTENSION fdoExtension =
            GET_FDO_EXT(HwResetHw[iReset].HwDeviceExtension);

        if (HwResetHw[iReset].ResetFunction &&
            fdoExtension->HwInitStatus == HwInitSucceeded) {

            bRetVal &= HwResetHw[iReset].ResetFunction(HwResetHw[iReset].HwDeviceExtension,
                                                       Columns,
                                                       Rows);
        }
    }

    return bRetVal;

} // end pVideoPortResetDisplay()



BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    )

/*++

Routine Description:

    Does a case *SENSITIVE* search for a string in the ROM.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    RomBase - Base address at which the search should start.

    RomLength - Size, in bytes, of the ROM area in which to perform the
        search.

    String - String to search for

Return Value:

    Returns TRUE if the string was found.
    Returns FALSE if it was not found.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    ULONG stringLength, length;
    ULONG_PTR startOffset;
    PUCHAR string1, string2;
    BOOLEAN match;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    stringLength = strlen(String);

    for (startOffset = 0;
         startOffset < RomLength - stringLength + 1;
         startOffset++) {

        length = stringLength;
        string1 = RomBase + startOffset;
        string2 = String;
        match = TRUE;

        IS_ACCESS_RANGES_DEFINED()

        while (length--) {

            if (READ_REGISTER_UCHAR(string1++) - (*string2++)) {

                match = FALSE;
                break;

            }
        }

        if (match) {

            return TRUE;
        }
    }

    return FALSE;

} // end VideoPortScanRom()



VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    VideoPortSetRegistryParameters writes information to the CurrentControlSet
    in the registry.  The function automatically searches for or creates the
    specified parameter name under the parameter key of the current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ValueName - Points to a Unicode string that contains the name of the
        data value being written in the registry.

    ValueData - Points to a buffer containing the information to be written
        to the registry.

    ValueLength - Specifies the size of the data being written to the registry.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Don't let people store as DefaultSettings anymore ...
    // Must still work for older drivers through.
    //

    if (wcsncmp(ValueName,
                L"DefaultSettings.",
                sizeof(L"DefaultSettings.")) == 0) {

        ASSERT(FALSE);

        //
        // check for NT 5.0
        //

        if (fdoExtension->HwGetPowerState) {

            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // BUGBUG What happens for files ... ?
    //

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                     fdoExtension->DriverRegistryPath,
                                     ValueName,
                                     REG_BINARY,
                                     ValueData,
                                     ValueLength);

    if (!NT_SUCCESS(ntStatus)) {

        return ERROR_INVALID_PARAMETER;

    } else {

        return NO_ERROR;

    }

} // end VideoPortSetRegistryParamaters()



VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )

/*++

Routine Description:

    This function is the main entry point for the timer routine that we then
    forward to the miniport driver.

Arguments:

    DeviceObject -

    Context - Not needed

Return Value:

    None.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(Context);

#if DBG
    InterlockedIncrement(&VPResourcesReported);
#endif

    fdoExtension->HwTimer(fdoExtension->HwDeviceExtension);

#if DBG
    InterlockedDecrement(&VPResourcesReported);
#endif

    return;

} // pVideoPortInterrupt()



VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Enables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStartTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Disables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStopTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



BOOLEAN
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

    Stub so we can allow the miniports to link directly

--*/

{
    return pVideoPortSynchronizeExecution(HwDeviceExtension,
                                          Priority,
                                          SynchronizeRoutine,
                                          Context);
} // end VideoPortSynchronizeExecution()

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortSynchronizeExecution synchronizes the execution of a miniport
    driver function in the following manner:

        - If Priority is equal to VpLowPriority, the current thread is
          raised to the highest non-interrupt-masking priority.  In
          other words, the current thread can only be pre-empted by an ISR.

        - If Priority is equal to VpMediumPriority and there is an
          ISR associated with the video device, then the function specified
          by SynchronizeRoutine is synchronized with the ISR.

          If no ISR is connected, synchronization is made at VpHighPriority
          level.

        - If Priority is equal to VpHighPriority, the current IRQL is
          raised to HIGH_LEVEL, which effectively masks out ALL interrupts
          in the system. This should be done sparingly and for very short
          periods -- it will completely freeze up the entire system.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    Priority - Specifies the type of priority at which the SynchronizeRoutine
        must be executed (found in VIDEO_SYNCHRONIZE_PRIORITY).

    SynchronizeRoutine - Points to the miniport driver function to be
        synchronized.

    Context - Specifies a context parameter to be passed to the miniport's
        SynchronizeRoutine.

Return Value:

    This function returns TRUE if the operation is successful.  Otherwise, it
    returns FALSE.

--*/

{
    BOOLEAN status;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    KIRQL oldIrql;

    //
    // Switch on which type of priority.
    //

    switch (Priority) {

    case VpMediumPriority:

        //
        // This is synchronized with the interrupt object
        //

        if (fdoExtension->InterruptObject) {

            status = KeSynchronizeExecution(fdoExtension->InterruptObject,
                                            (PKSYNCHRONIZE_ROUTINE)
                                            SynchronizeRoutine,
                                            Context);

            ASSERT (status == TRUE);

            return status;
        }

        //
        // Fall through for Medium Priority
        //

    case VpLowPriority:

        //
        // Just normal level
        //

        status = SynchronizeRoutine(Context);

        return status;

    case VpHighPriority:

        //
        // This is like cli\sti where we mask out everything.
        //

        //
        // Get the current IRQL to catch re-entrant routines into synchronize.
        //

        oldIrql = KeGetCurrentIrql();

        if (oldIrql < POWER_LEVEL - 1) {

            KeRaiseIrql(POWER_LEVEL, &oldIrql);

        }

        status = SynchronizeRoutine(Context);

        if (oldIrql < POWER_LEVEL - 1) {

            KeLowerIrql(oldIrql);

        }

        return status;

        break;

    default:

        return FALSE;

    }
}



VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    )

/*++

Routine Description:

    VideoPortUnmapMemory allows the miniport driver to unmap a physical
    address range previously mapped into the calling process' address space
    using the VideoPortMapMemory function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    VirtualAddress - Points to the virtual address to unmap from the
        address space of the caller.

    // InIoSpace - Specifies whether the address is in I/O space (1) or memory
    //     space (0).

    ProcessHandle - Handle to the process from which memory must be unmapped.

Return Value:

    This function returns a status code of NO_ERROR if the operation succeeds.
    It returns ERROR_INVALID_PARAMETER if an error occurs.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntstatus;
    VP_STATUS vpStatus = NO_ERROR;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Backwards compatibility to when the ProcessHandle was actually
    // ULONG InIoSpace.
    //

    if (((ULONG_PTR)(ProcessHandle)) == 1) {

        pVideoDebugPrint((0,"\n\n*** VideoPortUnmapMemory - interface change *** Must pass in process handle\n\n"));
        DbgBreakPoint();

        return NO_ERROR;

    }

    if (((ULONG_PTR)(ProcessHandle)) == 0) {

        //
        // If the process handle is zero, it means it was mapped by the display
        // driver and is therefore in kernel mode address space.
        //

        if (!pVideoPortFreeDeviceBase(HwDeviceExtension, VirtualAddress)) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }

    } else {

        //
        // A process handle is passed in.
        // This ms it was mapped for use by an application (DCI \ DirectDraw).
        //

#ifdef _ALPHA_
        //
        // On Alpha, VirtualAddress may not be a true VA if this was
        // a sparse memory or IO space.   Transform the QVA to a VA,
        // if necessary.
        //

        VirtualAddress = HalDereferenceQva(VirtualAddress,
                                           fdoExtension->AdapterInterfaceType,
                                           fdoExtension->SystemIoBusNumber);

#endif

        ntstatus = ZwUnmapViewOfSection ( ProcessHandle,
            (PVOID) ( ((ULONG_PTR)VirtualAddress) & (~(PAGE_SIZE - 1)) ) );

        if ( (!NT_SUCCESS(ntstatus)) &&
             (ntstatus != STATUS_PROCESS_IS_TERMINATING) ) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }
    }

    return NO_ERROR;

} // end VideoPortUnmapMemory()


/////////////////////////////////////////////////////////
//
//  Video port/miniport interface for ENG_EVENTs
//
//  All Events are created or mapped by display driver. If the miniport wants
//  them, the display driver must convey them to the miniport and the miniport
//  must treat them as type VIDEO_PORT_EVENT, which must be the same as
//  ENG_EVENT from winddi.h. Because KEVENTs cannot be set from ISRs, the
//  mechanism provided for SetEvent queues a DPC, which actually sets the
//  event.
//
//

//
// PRIVATE structure. NOTE: this must be same as for ENG/GDI.
//
//
//typedef struct _VIDEO_PORT_EVENT {
//  PKEVENT pKEvent;
//  ULONG   fFlags;
//  } VIDEO_PORT_EVENT, *PVIDEO_PORT_EVENT;
//
//

VOID
pVideoPortSetEvent(
    PVIDEO_PORT_EVENT   pVPEvent
    )
/*++

Routine Description:


Arguments:

    pVPEvent - a PVIDEO_PORT_EVENT

Return Value:

    None.

    Note: this is called via a dpc queued via VideoSetEvent(). It's possible
    that this routine executes after the associated KEVENT is no longer valid
    (either the display driver deleted it or it's DriverObject is being
    deleted via EngUnmapEvent. In either case, the containing VIDEO_PORT_EVENT
    has been marked as both "invalid" and "in a dpc". In this case, we free it,
    possibly ObDereferencing it if it's mapped.

--*/
{
    if ((pVPEvent->pKEvent) &&
        (!(pVPEvent->fFlags & ENG_EVENT_FLAG_IS_INVALID))) {

        pVideoDebugPrint((2, "Set the event at %xin VP DPC\n", pVPEvent));
        KeSetEvent(pVPEvent->pKEvent, 0, FALSE);
        pVPEvent->fFlags &= ~ENG_EVENT_FLAG_IN_DPC;

    } else {

        //
        //  If this is marked as invalid, then the GDI Engine is trying to
        //  delete it. The delete routine in gre will wait until it's the
        //  ENG_EVENT_FLAG_IN_DPC bit is cleared.
        //

        if (pVPEvent->fFlags & ENG_EVENT_FLAG_IS_INVALID) {

            pVPEvent->fFlags &= ~ENG_EVENT_FLAG_IN_DPC;

        } else {

            pVideoDebugPrint((0, "Bad PEVENT\n"));
        }
    }

}

#if DBG

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    )
{
    ULONG i;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    PIO_RESOURCE_REQUIREMENTS_LIST Requirements;
    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount;

    pVideoDebugPrint((1, "Building Requirements List...\n"));

    RequirementCount = pcmResourceList->List[0].PartialResourceList.Count;

    RequirementsListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                              ((RequirementCount - 1) *
                              sizeof(IO_RESOURCE_DESCRIPTOR));

    Requirements = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                                                        PagedPool,
                                                        RequirementsListSize);

    Requirements->ListSize         = RequirementsListSize;
    Requirements->InterfaceType    = pcmResourceList->List[0].InterfaceType;
    Requirements->BusNumber        = pcmResourceList->List[0].BusNumber;
    Requirements->SlotNumber       = -1; // ???
    Requirements->AlternativeLists = 0; // ???

    Requirements->List[0].Version  = pcmResourceList->List[0].PartialResourceList.Version;
    Requirements->List[0].Revision = pcmResourceList->List[0].PartialResourceList.Revision;
    Requirements->List[0].Count    = RequirementCount;

    pcmDescript = &(pcmResourceList->List[0].PartialResourceList.PartialDescriptors[0]);
    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pioDescript->Option = IO_RESOURCE_PREFERRED;
        pioDescript->Type   = pcmDescript->Type;
        pioDescript->ShareDisposition = pcmDescript->ShareDisposition;
        pioDescript->Flags  = pcmDescript->Flags;

        switch (pcmDescript->Type) {
        case CmResourceTypePort:
            pioDescript->u.Port.Length = pcmDescript->u.Port.Length;
            pioDescript->u.Port.Alignment = 1;
            pioDescript->u.Port.MinimumAddress =
            pioDescript->u.Port.MaximumAddress = pcmDescript->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            pioDescript->u.Memory.Length = pcmDescript->u.Memory.Length;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.MinimumAddress =
            pioDescript->u.Memory.MaximumAddress = pcmDescript->u.Memory.Start;
            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
        pcmDescript++;
    }

    return Requirements;
}

VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    )
{
    ULONG i;

    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount = Requirements->List[0].Count;

    char *Table[] = { "Internal",
                      "Isa",
                      "Eisa",
                      "MicroChannel",
                      "TurboChannel",
                      "PCIBus",
                      "VMEBus",
                      "NuBus",
                      "PCMCIABus",
                      "CBus",
                      "MPIBus",
                      "MPSABus",
                      "ProcessorInternal",
                      "InternalPowerBus",
                      "PNPISABus",
                      "MaximumInterfaceType"
                    };

    pVideoDebugPrint((1, "ListSize:         0x%x\n"
                         "InterfaceType:    %s\n"
                         "BusNumber:        0x%x\n"
                         "SlotNumber:       0x%x\n"
                         "AlternativeLists: 0x%x\n",
                         Requirements->ListSize,
                         Table[Requirements->InterfaceType],
                         Requirements->BusNumber,
                         Requirements->SlotNumber,
                         Requirements->AlternativeLists));

    pVideoDebugPrint((1, "List[0].Version:  0x%x\n"
                         "List[0].Revision: 0x%x\n"
                         "List[0].Count:    0x%x\n",
                         Requirements->List[0].Version,
                         Requirements->List[0].Revision,
                         Requirements->List[0].Count));

    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pVideoDebugPrint((1, "\n"
                             "Option:           0x%x\n"
                             "Type:             0x%x\n"
                             "ShareDisposition: 0x%x\n"
                             "Flags:            0x%x\n",
                             pioDescript->Option,
                             pioDescript->Type,
                             pioDescript->ShareDisposition,
                             pioDescript->Flags));

        switch (pioDescript->Type) {
        case CmResourceTypePort:

            pVideoDebugPrint((1, "\nPort...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Port.Length,
                                 pioDescript->u.Port.Alignment,
                                 pioDescript->u.Port.MinimumAddress,
                                 pioDescript->u.Port.MaximumAddress));

            break;

        case CmResourceTypeMemory:

            pVideoDebugPrint((1, "\nMemory...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Memory.Length,
                                 pioDescript->u.Memory.Alignment,
                                 pioDescript->u.Memory.MinimumAddress,
                                 pioDescript->u.Memory.MaximumAddress));
            break;

        case CmResourceTypeInterrupt:

            pVideoDebugPrint((1, "\nInterrupt...\n"
                                 "\tMinimum Vector: 0x%x\n"
                                 "\tMaximum Vector: 0x%x\n",
                                 pioDescript->u.Interrupt.MinimumVector,
                                 pioDescript->u.Interrupt.MaximumVector));

            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
    }

    return;
}

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList)
{
    ULONG i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    pVideoDebugPrint((1, "...StartResourceList...\n"));

    pcmFull = &(pcmResourceList->List[0]);
    for (i=0; i<pcmResourceList->Count; i++) {

        pVideoDebugPrint((1, "List[%d]\n", i));

        pVideoDebugPrint((1, "InterfaceType = 0x%x\n", pcmFull->InterfaceType));
        pVideoDebugPrint((1, "BusNumber = 0x%x\n", pcmFull->BusNumber));

        pcmPartial = &(pcmFull->PartialResourceList);

        pVideoDebugPrint((1, "Version = 0x%x\n", pcmPartial->Version));
        pVideoDebugPrint((1, "Revision = 0x%x\n", pcmPartial->Revision));

        pcmDescript = &(pcmPartial->PartialDescriptors[0]);

        for (j=0; j<pcmPartial->Count; j++) {

            switch (pcmDescript->Type) {
            case CmResourceTypePort:
                pVideoDebugPrint((1, "Port: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Port.Start.LowPart,
                                  pcmDescript->u.Port.Length));

                break;

            case CmResourceTypeInterrupt:
                pVideoDebugPrint((1, "Interrupt: 0x%x Level: 0x%x\n",
                                  pcmDescript->u.Interrupt.Vector,
                                  pcmDescript->u.Interrupt.Level));
                break;

            case CmResourceTypeMemory:
                pVideoDebugPrint((1, "Start: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Memory.Start.LowPart,
                                  pcmDescript->u.Memory.Length));
                break;

            case CmResourceTypeDma:
                pVideoDebugPrint((1, "Dma Channel: 0x%x Port: 0x%x\n",
                                  pcmDescript->u.Dma.Channel,
                                  pcmDescript->u.Dma.Port));
                break;
            }

            pcmDescript++;
        }

        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    pVideoDebugPrint((1, "...EndResourceList...\n"));
}

VOID
DumpHwInitData(
    IN PVIDEO_HW_INITIALIZATION_DATA p
    )

/*++

Routine Description:

    Dump enough of the HwInitData to visually see if it is valid.

Arguments:

    Pointer to HwInitializationData

Return Value:

    none

--*/


{
    pVideoDebugPrint((0, "HwInitializationData...\n"));

    pVideoDebugPrint((0, "  HwInitDataSize: 0x%x\n", p->HwInitDataSize));


    pVideoDebugPrint((0, "  AdapterInterfaceType: %s\n",
                         BusType[p->AdapterInterfaceType]));

    pVideoDebugPrint((0, "  HwDeviceExtensionSize: 0x%x\n",
                         p->HwDeviceExtensionSize));

    pVideoDebugPrint((0, "  StartingDeviceNumber: 0x%x\n",
                         p->StartingDeviceNumber));

    pVideoDebugPrint((0, "  HwStartIO: 0x%x\n",
                         p->HwStartIO));

}

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    )
{
    PUSHORT pus = p->Buffer;
    UCHAR buffer[256];       // the string better not be longer than 255 chars!
    PUCHAR puc = buffer;
    ULONG i;

    for (i = 0; i < p->Length; i++) {

        *puc++ = (UCHAR) *pus++;

    }

    *puc = 0;  // null terminate the string

    pVideoDebugPrint((0, "UNICODE STRING: %s\n", buffer));
}

#endif

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID pHwDeviceExtension,
    IN VIDEO_PORT_SERVICES servicesType,
    IN OUT PINTERFACE pInterface
    )

/*++

Routine Description:

    This routine exposes interfaces to services supported by the videoprt.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    servicesType       - Requested services type.
    pInterface         - Points to services interface structure.

Returns:

    NO_ERROR   - Valid interface in the pInterface.
    Error code - Unsupported / unavailable services.

--*/

{
    VP_STATUS vpStatus;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pInterface);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    if (VideoPortServicesAGP == servicesType)
    {
        PVIDEO_PORT_AGP_INTERFACE pAgpInterface = (PVIDEO_PORT_AGP_INTERFACE)pInterface;

        if ((pAgpInterface->Size != sizeof (VIDEO_PORT_AGP_INTERFACE)) ||
            (pAgpInterface->Version != 1))
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported interface version\n"));
            ASSERT(FALSE);
            vpStatus = ERROR_INVALID_PARAMETER;
        }
        else
        {
            pAgpInterface->Context              = pHwDeviceExtension;
            pAgpInterface->InterfaceReference   = VpInterfaceDefaultReference;
            pAgpInterface->InterfaceDereference = VpInterfaceDefaultDereference;

            if (VideoPortGetAgpServices(pHwDeviceExtension,
                (PVIDEO_PORT_AGP_SERVICES)&(pAgpInterface->AgpReservePhysical)) == TRUE)
            {
                vpStatus = NO_ERROR;
            }
            else
            {
                vpStatus = ERROR_DEV_NOT_EXIST;
            }
        }
    }
    else if (VideoPortServicesI2C == servicesType)
    {
        PVIDEO_PORT_I2C_INTERFACE pI2CInterface = (PVIDEO_PORT_I2C_INTERFACE)pInterface;

        if ((pI2CInterface->Size != sizeof (VIDEO_PORT_I2C_INTERFACE)) ||
            (pI2CInterface->Version != 1))
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported interface version\n"));
            ASSERT(FALSE);
            vpStatus = ERROR_INVALID_PARAMETER;
        }
        else
        {
            pI2CInterface->Context              = pHwDeviceExtension;
            pI2CInterface->InterfaceReference   = VpInterfaceDefaultReference;
            pI2CInterface->InterfaceDereference = VpInterfaceDefaultDereference;
            pI2CInterface->I2CStart             = I2CStart;
            pI2CInterface->I2CStop              = I2CStop;
            pI2CInterface->I2CWrite             = I2CWrite;
            pI2CInterface->I2CRead              = I2CRead;

            vpStatus = NO_ERROR;
        }
    }
    else
    {
        pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported service type\n"));
        ASSERT(FALSE);
        vpStatus = ERROR_INVALID_PARAMETER;
    }

    return vpStatus;
}   // VideoPortQueryServices()

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client before it starts using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    PAGED_CODE();
}   // VpInterfaceDefaultReference()

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client when it stops using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    PAGED_CODE();
}   // VpInterfaceDefaultDereference()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\port\i386\porti386.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    porti386.c

Abstract:

    This is the x86 specific part of the video port driver.

Author:

    Andre Vachon (andreva) 10-Jan-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"
#include "vdm.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,VideoPortInt10)
#pragma alloc_text(PAGE,VideoPortSetTrappedEmulatorPorts)
#endif


VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:


Restrictions:

    Device uses IO ports ONLY.


--*/

{

    return ERROR_NOT_ENOUGH_MEMORY;

} // end VideoPortInt10()

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

    VideoPortSetTrappedEmulatorPorts (x86 machines only) allows a miniport
    driver to dynamically change the list of I/O ports that are trapped when
    a VDM is running in full-screen mode. The default set of ports being
    trapped by the miniport driver is defined to be all ports in the
    EMULATOR_ACCESS_ENTRY structure of the miniport driver.
    I/O ports not listed in the EMULATOR_ACCESS_ENTRY structure are
    unavailable to the MS-DOS application.  Accessing those ports causes a
    trap to occur in the system, and the I/O operation to be reflected to a
    user-mode virtual device driver.

    The ports listed in the specified VIDEO_ACCESS_RANGE structure will be
    enabled in the I/O Permission Mask (IOPM) associated with the MS-DOS
    application.  This will enable the MS-DOS application to access those I/O
    ports directly, without having the IO instruction trap and be passed down
    to the miniport trap handling functions (for example EmulatorAccessEntry
    functions) for validation.  However, the subset of critical IO ports must
    always remain trapped for robustness.

    All MS-DOS applications use the same IOPM, and therefore the same set of
    enabled/disabled I/O ports.  Thus, on each switch of application, the
    set of trapped I/O ports is reinitialized to be the default set of ports
    (all ports in the EMULATOR_ACCESS_ENTRY structure).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Specifies the number of entries in the VIDEO_ACCESS_RANGE
        structure specified in AccessRange.

    AccessRange - Points to an array of access ranges (VIDEO_ACCESS_RANGE)
        defining the ports that can be untrapped and accessed directly by
        the MS-DOS application.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    return NO_ERROR;

} // end VideoPortSetTrappedEmulatorPorts()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\agp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    agp.c

Abstract:

    This is the agp portion of the video port driver.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#if 0 // NUGOOP

extern ULONG VideoDebugLevel;

#if DBG

#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#else

#define pVideoDebugPrint(arg)

#endif

//
// Device extension aliases.
//

typedef PVIDEO_DEVICE_EXTENSION PFDO_EXTENSION;
#define GET_FDO_EXT VIDEO_GET_VIDEO_DEVICE_EXTENSION

//
// AGP Data Structures
//

#define POOL_TAG 0x72745076 // 'vPrt'

typedef struct _AGP_ALLOCATION
{
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress;
    ULONG Pages;
    PMDL Mdl;
    struct _AGP_ALLOCATION *Next;
} AGP_ALLOCATION, *PAGP_ALLOCATION;

typedef struct _REGION {
    ULONG Length;
    ULONG NumDwords;
    ULONG BitField[1];
} REGION, *PREGION;

typedef struct _RESERVATION_LIST RESERVATION_LIST, *PRESERVATION_LIST;
typedef struct _RESERVATION_LIST
{
    ULONG Offset;
    ULONG Pages;
    ULONG RefCount;
    BOOLEAN Reserved;
    PRESERVATION_LIST Next;
};

typedef struct _PHYSICAL_RESERVE_CONTEXT
{
    ULONG Pages;
    ULONG Caching;
    PVOID MapHandle;
    PHYSICAL_ADDRESS PhysicalAddress;
    PREGION Region;
} PHYSICAL_RESERVE_CONTEXT, *PPHYSICAL_RESERVE_CONTEXT;

typedef struct _VIRTUAL_RESERVE_CONTEXT
{
    HANDLE ProcessHandle;
    PEPROCESS Process;
    PVOID VirtualAddress;
    PPHYSICAL_RESERVE_CONTEXT PhysicalReserveContext;
    PRESERVATION_LIST ReservationList;
    PREGION Region;
} VIRTUAL_RESERVE_CONTEXT, *PVIRTUAL_RESERVE_CONTEXT;

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
DumpBitField(
    PREGION Region
    )
{
    ULONG i;
    ULONG Index = 0;
    ULONG Mask = 1;

    for (i=0; i<Region->Length; i++) {
        if (Mask & Region->BitField[Index]) {
            pVideoDebugPrint((1, "1"));
        } else {
            pVideoDebugPrint((1, "0"));
        }
        Mask <<= 1;
        if (Mask == 0) {
            Index++;
            Mask = 1;
        }
    }
    pVideoDebugPrint((1, "\n"));
}

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    )

/*++

Routine Description:

    This routine creates and initializes a bitfield.

Arguments:

    Length - Number of items to track.

    Region - Location in which to store the pointer to the REGION handle.

Returns:

    TRUE - the the bitfield was created successfully, 
    FALSE - otherwise.

--*/

{
    ULONG NumDwords = (Length + 31) / 32;
    BOOLEAN bRet = FALSE;
    PREGION Buffer;

    Buffer = (PREGION) ExAllocatePoolWithTag(PagedPool, sizeof(REGION) + (NumDwords - 1) * sizeof(ULONG), POOL_TAG);

    if (Buffer) {

        Buffer->Length = Length;
        Buffer->NumDwords = NumDwords;
        memset(&Buffer->BitField[0], 0, NumDwords * 4);

        bRet = TRUE;
    }

    *Region = Buffer;
    return bRet;
}

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    )

/*++

Routine Description:

    Sets 'Length' bits starting at position 'Offset' in the bitfield.

Arguments:

    Region - Pointer to the region to modify.

    Offset - Offset into the bitfield at which to start.

    Length - Number of bits to set.

    Set - TRUE if you want to set the region, FALSE to clear it.


--*/

{
    ULONG Index = Offset / 32;
    ULONG Count = ((Offset + Length - 1) / 32) - Index;
    ULONG lMask = ~((1 << (Offset & 31)) - 1);
    ULONG rMask = ((1 << ((Offset + Length - 1) & 31)) * 2) - 1;
    PULONG ptr = &Region->BitField[Index];

    ASSERT(Length != 0);

    if (Count == 0) {

        //
        // Only one DWORD is modified, so combine left and right masks.
        //

        lMask &= rMask;
    }

    if (Set) {

        *ptr++ |= lMask;

        while (Count > 1) {
            *ptr++ |= 0xFFFFFFFF;
            Count--;
        }

        if (Count) {
            *ptr |= rMask;
        }

    } else {

        *ptr++ &= ~lMask;

        while (Count > 1) {
            *ptr++ &= 0;
            Count--;
        }

        if (Count) {
            *ptr++ &= ~rMask;
        }
    }

#if DBG
    pVideoDebugPrint((1, "Current BitField for Region: 0x%x\n", Region));
    DumpBitField(Region);
#endif
}

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    )

/*++

Routine Description:

    This routine finds the first run of bits in a bitfield.

Arguments:

    Region - Pointer to the region to operate on.

    Offset - Pointer to a ULONG to hold the offset of the run.

    Length - Pointer to a ULONG to hold the length of a run.

Returns:

    TRUE if a run was detected,
    FALSE otherwise.

--*/

{
    PULONG ptr = Region->BitField;
    ULONG Index = 0;
    ULONG BitMask;
    ULONG lsb;
    ULONG Count;
    ULONG ptrVal;

    while ((Index < Region->NumDwords) && (*ptr == 0)) {
        ptr++;
        Index++;
    }

    if (Index == Region->NumDwords) {
        return FALSE;
    }

    //
    // Find least significant bit
    //

    lsb = 0;
    ptrVal = *ptr;
    BitMask = 1;

    while ((ptrVal & BitMask) == 0) {
        BitMask <<= 1;
        lsb++;
    }

    *Offset = (Index * 32) + lsb;

    //
    // Determine the run length
    //

    Count = 0;

    while (Index < Region->NumDwords) {
        if (ptrVal & BitMask) {
            BitMask <<= 1;
            Count++;

            if (BitMask == 0) {
                BitMask = 0x1;
                Index++;
                ptrVal = *++ptr;
                while ((ptrVal == 0xFFFFFFFF) && (Index < Region->NumDwords)) {
                    Index++;
                    Count += 32;
                    ptrVal = *ptr++;
                }
            }

        } else {
            break;
        }
    }

    *Length = Count;
    return TRUE;
}

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    Pages - Number of pages to reserve

    Caching - Specifies the type of caching to use

    PhysicalReserveContext - Location to store our reservation context.

Returns:

    The base of the physical address range reserved.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS PhysicalAddress = {0,0};
    NTSTATUS status;
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PVOID MapHandle;

    pVideoDebugPrint((1, "AGP: Reserving 0x%x Pages of Address Space\n", Pages));

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(PHYSICAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(Pages, &ReserveContext->Region)) {

            status = fdoExtension->AgpInterface.ReserveMemory(
                         fdoExtension->AgpInterface.AgpContext,
                         Pages,
                         Caching ? MmWriteCombined : MmNonCached,
                         &MapHandle,
                         &PhysicalAddress);

            if (NT_SUCCESS(status)) {

                ReserveContext->Pages = Pages;
                ReserveContext->Caching = Caching;
                ReserveContext->MapHandle = MapHandle;
                ReserveContext->PhysicalAddress = PhysicalAddress;

            } else {

                ExFreePool(ReserveContext->Region);
                goto FailureCase;
            }

        } else {

            goto FailureCase;
        }
    }

    *PhysicalReserveContext = ReserveContext;
    return PhysicalAddress;

FailureCase:

    PhysicalAddress.QuadPart = 0;
    ExFreePool(ReserveContext);
    *PhysicalReserveContext = NULL;

    return PhysicalAddress;
}

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of reserved physical address.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    ULONG Pages;
    ULONG Offset;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    pVideoDebugPrint((1, "AGP: Releasing 0x%x Pages of Address Space\n", ReserveContext->Pages));

    //
    // Make sure all pages have been freed
    //

    while (FindFirstRun(ReserveContext->Region, &Offset, &Pages)) {
        AgpFreePhysical(Context, PhysicalReserveContext, Pages, Offset);
    }

    fdoExtension->AgpInterface.ReleaseMemory(fdoExtension->AgpInterface.AgpContext,
                                             ReserveContext->MapHandle);

    ExFreePool(ReserveContext->Region);
    ExFreePool(ReserveContext);
}

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS MemoryBase = {0,0};
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    NTSTATUS status;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    status =
        fdoExtension->AgpInterface.CommitMemory(fdoExtension->AgpInterface.AgpContext,
                                                ReserveContext->MapHandle,
                                                Pages,
                                                Offset,
                                                NULL,
                                                &MemoryBase);

    if (NT_SUCCESS(status)) {

        ModifyRegion(ReserveContext->Region, Offset, Pages, TRUE);
        return TRUE;

    } else {

        return FALSE;
    }
}

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    fdoExtension->AgpInterface.FreeMemory(fdoExtension->AgpInterface.AgpContext,
                                          ReserveContext->MapHandle,
                                          Pages,
                                          Offset);

    ModifyRegion(ReserveContext->Region, Offset, Pages, FALSE);
}


PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    )

/*++

Routine Description:

    Reserves a range of virtual addresses for AGP.

Arguments:

    Context - The Agp Context

    ProcessHandle - The handle of the process in which to reserve the
        virtual address range.

    PhysicalReserveContext - The physical reservation context to assoctiate
        with the given virtual reservation.

    VirtualReserveContext - The location in which to store the virtual
        reserve context.

Returns:

    The base of the virtual address range reserved.

Notes:

    You can't reserve a range of kernel address space, but if you want to
    commit into kernel space you still need a reservation handle.  Pass in
    NULL for the process handle in this case.

    For the moment, we'll commit the entire region when the do a reservation
    in kernel space.  Then Commit and Free will be no-ops.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    ULONG Protect = PAGE_READWRITE;
    PVIRTUAL_RESERVE_CONTEXT ReserveContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    SIZE_T Length;
    PVOID VirtualAddress = NULL;
    PEPROCESS Process = NULL;

    PhysicalContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    Length = PhysicalContext->Pages * PAGE_SIZE;

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(VIRTUAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(PhysicalContext->Pages, &ReserveContext->Region)) {

            //
            // BUGBUG: Fix this routine for kernel mode reservation!
            //

            if (!PhysicalContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            //
            // Make sure we have the real process handle.
            //

            if (ProcessHandle == NtCurrentProcess()) {
                Process = PsGetCurrentProcess();
            }

            ReserveContext->ProcessHandle = ProcessHandle;
            ReserveContext->Process = Process;
            ReserveContext->PhysicalReserveContext =
                (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
            ReserveContext->ReservationList = NULL;

            if (ProcessHandle) {

                VirtualAddress =
                    AddRangeToReservedRegion(ReserveContext,
                                             PhysicalContext->Pages,
                                             0);

                ASSERT(VirtualAddress != NULL);

            } else {

                //
                // BUGBUG: Find a better way to reserve in kernel space.
                //
                // For a kernel reservation, go ahead and commit the
                // entire range.
                //

                if (fdoExtension->AgpInterface.Capabilities &
                    AGP_CAPABILITIES_MAP_PHYSICAL)
                {
                    //
                    // CPU can access AGP memory through AGP aperature.
                    //

                    VirtualAddress =
                        MmMapIoSpace(PhysicalContext->PhysicalAddress.LowPart,
                                     PhysicalContext->Pages * PAGE_SIZE,
                                     PhysicalContext->Caching ? MmFrameBufferCached : 0);
                    //
                    // Not all systems support USWC, so if we attempted to map USWC
                    // and failed, try again with just non-cached.
                    //
                    if ((VirtualAddress == NULL) &&
                        (PhysicalContext->Caching)) {
                        VirtualAddress = MmMapIoSpace(PhysicalContext->PhysicalAddress.LowPart,
                                                      PhysicalContext->Pages * PAGE_SIZE,
                                                      MmNonCached);
                    }

                } else {

                    PMDL Mdl;

                    //
                    // Get the MDL for the range we are trying to map.
                    //

                    Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

                    if (Mdl) {

                        fdoExtension->AgpInterface.GetMappedPages(
                                         fdoExtension->AgpInterface.AgpContext,
                                         PhysicalContext->MapHandle,
                                         PhysicalContext->Pages,
                                         0,
                                         Mdl);

                        //
                        // We must use the CPU's virtual memory mechanism to
                        // make the non-contiguous MDL look contiguous.
                        //

                        VirtualAddress =
                            MmMapLockedPagesSpecifyCache(
                                Mdl,
                                PhysicalContext->Caching ? MmCached : MmNonCached);

                        ExFreePool(Mdl);
                    }
                }
            }

            ReserveContext->VirtualAddress = VirtualAddress;

        } else {

            pVideoDebugPrint((1, "Couldn't create bit field.\n"));
            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }

    } else {

        pVideoDebugPrint((1, "AgpReserveVirtual: Out of memory.\n"));
    }

    *VirtualReserveContext = ReserveContext;
    return VirtualAddress;
}

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    ULONG Offset;
    ULONG Pages;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure all pages have been freed
        //

        while (FindFirstRun(VirtualContext->Region, &Offset, &Pages)) {
            AgpFreeVirtual(Context, VirtualReserveContext, Pages, Offset);
        }

        if (VirtualContext->VirtualAddress) {

            ASSERT(VirtualContext->ReservationList->Next == NULL);

            RemoveRangeFromReservedRegion(VirtualContext,
                                          VirtualContext->ReservationList->Pages,
                                          VirtualContext->ReservationList->Offset);

            if (VirtualContext->ReservationList) {

                ExFreePool(VirtualContext->ReservationList);
                VirtualContext->ReservationList = NULL;
            }
        }

        ExFreePool(VirtualContext->Region);
        ExFreePool(VirtualContext);

    } else {

        //
        // This was kernel virtual memory, so release the memory we
        // committed at reserve time.
        //

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            MmUnmapIoSpace(VirtualContext->VirtualAddress,
                           PhysicalContext->Pages * PAGE_SIZE);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                PhysicalContext->Pages,
                                0,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualContext->VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }
    }
}

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Adds a range to a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    NTSTATUS Status;
    PRESERVATION_LIST Curr, Prev = NULL;

    pVideoDebugPrint((1, "AddPagesToReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    if (VirtualContext->ReservationList) {

        //
        // We are making the assumption that if range is added, and we
        // already have a reservation list, that we had removed a region
        // because we mapped it, and now we are adding it back.  So we
        // should be able to scan for a region, and just set the
        // reserved bit to TRUE.  We can then concatinate with existing
        // right or left regions.
        //

        Curr = VirtualContext->ReservationList;

        while (Curr) {

            if (Curr->Offset == Offset)
                break;

            Prev = Curr;
            Curr = Curr->Next;
        }

        pVideoDebugPrint((1, "Region to Reserve:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        //
        // If the region is already reserved, simply return.
        //

        if (Curr->Reserved == TRUE) {
            pVideoDebugPrint((1, "Region is already reserved!\n"));
            return NULL;
        }

        //
        // If there is still an allocation in this region, then return.
        //

        if (--Curr->RefCount) {
            pVideoDebugPrint((1, "Region is still in use.\n"));
            return NULL;
        }

        pVideoDebugPrint((1, "Marking region as reserved.\n"));

        Curr->Reserved = TRUE;

        //
        // See if we can concatinate with the left or right region.
        //

        if (Prev && (Prev->Reserved)) {

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Prev->Offset * PAGE_SIZE);
            Length = Prev->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with previous range.\n"));

            Prev->Pages += Curr->Pages;
            Prev->Next = Curr->Next;

            ExFreePool(Curr);

            Curr = Prev;
        }

        if (Curr->Next && (Curr->Next->Reserved)) {

            PRESERVATION_LIST Next = Curr->Next;

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Next->Offset * PAGE_SIZE);
            Length = Next->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with next range.\n"));

            Curr->Pages += Next->Pages;
            Curr->Next = Next->Next;

            ExFreePool(Next);
        }

        pVideoDebugPrint((1, "Expanded Region:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);

    } else {

        //
        // Indicate we don't care where we reserve from.
        //

        VirtualAddress = NULL;

        Curr = ExAllocatePoolWithTag(PagedPool,
                                     sizeof(RESERVATION_LIST),
                                     POOL_TAG);

        if (Curr) {

            Curr->Offset   = Offset;
            Curr->Pages    = Pages;
            Curr->RefCount = 0;
            Curr->Reserved = TRUE;
            Curr->Next     = NULL;

            VirtualContext->ReservationList = Curr;

        } else {

            return NULL;
        }
    }

    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Reserving 0x%x bytes at virtual address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    Status = NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                            &VirtualAddress,
                                            0,
                                            &Length,
                                            MEM_RESERVE,
                                            Protect);

    if (!NT_SUCCESS(Status)) {

        pVideoDebugPrint((1, "Status = 0x%x\n", Status));
        ASSERT(FALSE);
        return NULL;
    }

    return VirtualAddress;
}

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Release a sub range of a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PRESERVATION_LIST ReservationList, Curr, Prev = NULL;
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    ULONG_PTR Address;

    pVideoDebugPrint((1, "RemovePagesFromReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    ASSERT(VirtualContext->ReservationList != NULL);

    Curr = VirtualContext->ReservationList;

    while (Curr) {

        if ((Curr->Offset <= Offset) &&
            ((Curr->Offset + Curr->Pages) > Offset)) {

            break;
        }

        Prev = Curr;
        Curr = Curr->Next;
    }

    pVideoDebugPrint((1, "Range to fill into:\n"
                         "  Offset: 0x%x\n"
                         "  Pages: 0x%x\n",
                         Curr->Offset,
                         Curr->Pages));


    ASSERT(Curr != NULL);

    //
    // If the region is already free, simply return.
    //

    if (Curr->Reserved == FALSE) {
        Curr->RefCount++;
        return;
    }

    //
    // Release the region which we are mapping into.
    //

    VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);
    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                        &VirtualAddress,
                                        &Length,
                                        MEM_RELEASE)))
    {
        ASSERT(FALSE);
    }

    //
    // Mark the region as not reserved.
    //

    Curr->Reserved = FALSE;
    Curr->RefCount++;

    //
    // Now see if we have sub regions to re-reserve.
    //

    if (Curr->Offset < Offset) {

        //
        // There will be a left over region prior to Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset;
            ReservationList->Pages = Offset - Curr->Offset;
            ReservationList->RefCount = 0;
            ReservationList->Next = Curr;
            ReservationList->Reserved = TRUE;

            Curr->Pages -= Offset - Curr->Offset;
            Curr->Offset = Offset;

        } else {

            return;
        }

        if (Prev) {
            Prev->Next = ReservationList;
        } else {
            VirtualContext->ReservationList = ReservationList;
        }

        pVideoDebugPrint((1, "Creating 'left' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));

        //
        // Calculate the virtual address and length of the memory to reserve.
        // Note that NtAllocateVirtualMemory always rounds to a 64K boundary,
        // so we'll have to round up to prevent it from rounding down.
        //

        Address = ((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        VirtualAddress = (PULONG)Address;

        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    if (Curr->Pages > Pages) {

        //
        // There will be a left over region after Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset + Pages;
            ReservationList->Pages = Curr->Pages - Pages;
            ReservationList->RefCount = 0;
            ReservationList->Reserved = TRUE;

            Curr->Pages = Pages;

        } else {

            //
            // BUGBUG:
            //
            // If we return here then we have to adjacent blocks
            // which are both reserved.  This will not cause a
            // problem, but it will never be cleaned up.
            //

            return;
        }

        pVideoDebugPrint((1, "Creating 'right' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));


        ReservationList->Next = Curr->Next;
        Curr->Next = ReservationList;

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    return;
}

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    The virtual address for the base of the commited pages.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress = NULL;
    PVOID PhysicalMemorySection = NULL;
    HANDLE PhysicalMemoryHandle;
    NTSTATUS ntStatus;
    BOOLEAN bUserMode;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    PhysicalAddress = PhysicalContext->PhysicalAddress;
    PhysicalAddress.LowPart += Offset * PAGE_SIZE;

    bUserMode = (BOOLEAN)(VirtualContext->ProcessHandle != NULL);

    if (bUserMode) {

        //
        // First release the VA range we are going to map into.
        //

        RemoveRangeFromReservedRegion(VirtualContext,
                                      Pages,
                                      Offset);

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            //
            // CPU can access AGP memory through AGP aperature.
            //

            ASSERT(FALSE);

            //
            // Get a handle to the physical memory section using our pointer.
            // If this fails, return.
            //

            ntStatus =
                ObOpenObjectByPointer(
                    PhysicalMemorySection,
                    (POBJECT_TYPE) NULL,
                    &PhysicalMemoryHandle);

            //
            // If successful, map the memory.
            //

            if (NT_SUCCESS(ntStatus)) {

                SIZE_T Length = Pages * PAGE_SIZE;
                ULONG Protect = PAGE_READWRITE;

                VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

                if (!PhysicalContext->Caching) {
                    Protect |= PAGE_NOCACHE;
                }

                ntStatus =
                    NtMapViewOfSection(
                        PhysicalMemoryHandle,
                        VirtualContext->ProcessHandle,
                        &VirtualAddress,
                        0,
                        Pages * PAGE_SIZE,
                        &PhysicalAddress,
                        &Length,
                        ViewUnmap,
                        0,
                        Protect);

                pVideoDebugPrint((1, "ntStatus = 0x%x\n", ntStatus));

                NtClose(PhysicalMemoryHandle);

            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                 fdoExtension->AgpInterface.AgpContext,
                                 PhysicalContext->MapHandle,
                                 Pages,
                                 Offset,
                                 Mdl);

                //
                // We must use the CPU's virtual memory mechanism to
                // make the non-contiguous MDL look contiguous.
                //

                VirtualAddress =
                    MmMapLockedPagesSpecifyCache(
                        Mdl,
                        PhysicalContext->Caching ? MmCached : MmNonCached);

                ExFreePool(Mdl);
            }
        }

        if (VirtualAddress) {
            ModifyRegion(VirtualContext->Region, Offset, Pages, TRUE);
        }

    } else {

        //
        // Kernel mode commit.  Do nothing.
        //

        VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);
    }

    return VirtualAddress;
}

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Frees a range of virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    VirtualAddress = (PUCHAR)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

    //
    // Make sure we are in the correct process context.
    //

    if (VirtualContext->ProcessHandle != NULL) {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

                NtUnmapViewOfSection(
                    VirtualContext->ProcessHandle,
                    VirtualAddress);

            } else {

                MmUnmapIoSpace(VirtualAddress,
                               Pages * PAGE_SIZE);
            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                Pages,
                                Offset,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }

        if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

            AddRangeToReservedRegion(VirtualContext,
                                     Pages,
                                     Offset);
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, FALSE);

    } else {

        //
        // Kernel Space Free - do nothing.
        //
    }
}

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    OUT PVIDEO_PORT_AGP_SERVICES AgpServices
    )
{
    NTSTATUS status;
    SYSTEM_BASIC_INFORMATION BasicInformation;

    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Fill in the AGP services table.
    //

    AgpServices->AgpReservePhysical = AgpReservePhysical;
    AgpServices->AgpCommitPhysical = AgpCommitPhysical;
    AgpServices->AgpFreePhysical = AgpFreePhysical;
    AgpServices->AgpReleasePhysical = AgpReleasePhysical;
    AgpServices->AgpReserveVirtual = AgpReserveVirtual;
    AgpServices->AgpCommitVirtual = AgpCommitVirtual;
    AgpServices->AgpFreeVirtual = AgpFreeVirtual;
    AgpServices->AgpReleaseVirtual = AgpReleaseVirtual;
    AgpServices->AllocationLimit =
        (BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT) / 8;

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\agpuma.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    agpuma.c

Abstract:

    This module maps all physical memory into the AGP address space.  It is
    used by the XBOX to simulate UMA.

--*/

#if 1 // NUGOOP

// Nasty path, but there are only two files that need to make kernel calls.
#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <ntagp.h>
#include <stdio.h>

#if defined(DBG)

    #define RIP(msg)            \
        {                       \
            DbgPrint msg;     \
            DbgPrint("\n");   \
            _asm { int 3 };     \
        }

#else

    #define RIP(msg) {}

#endif

static BOOLEAN s_fInitialized;

//
// Define the location of the GART aperture control registers
//

#define AGP440_TARGET_DEVICE_NUMBER             0
#define AGP440_TARGET_FUNCTION_NUMBER           0

// Defines what mode we're using.  If the hardware doesn't support this then
// we'll RIP.
//
#define AGP_APERTURE_SIZE       0x30
#define AGP_APERTURE_BYTES      (64*1024*1024)
#define AGP_APERTURE_BASE       0xF8000000

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440BX_IDENTIFIER    0x71908086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW 
{
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW 
{
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE 
{
    union 
    {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL 
{
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG 
{
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION 
{
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
} AGP440_EXTENSION, *PAGP440_EXTENSION;

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

typedef struct _AGP_RANGE 
{
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;


//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct 
{
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

typedef struct _BUS_SLOT_ID 
{
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//============================================================================
// AGP Code
//============================================================================


NTSTATUS
ApGetSetDeviceBusData(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    PCI_SLOT_NUMBER SlotNumber;
    ULONG Transferred;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);

    }

    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        RIP(("ApFindAgpCapability - read PCI Config space failed %08lx",
                Status));

        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        RIP(("ApFindAgpCapability - Does not support Capabilities list, not an AGP device"));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            RIP(("ApFindAgpCapability - read PCI Capability at offset %x failed %08lx",
                    CapabilityOffset,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        RIP(("ApFindAgpCapability - Does have an AGP Capability entry, not an AGP device"));
        return(STATUS_NOT_IMPLEMENTED);
    }

    *pOffset = CapabilityOffset;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpLibGetAgpCapability - read AGP Capability at offset %xfailed %08lx",
            CapabilityOffset,
            Status));

        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetMasterCapability(
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibGetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpLibSetAgpCapability - Set AGP command at offset %x failed %08lx",
            CapabilityOffset,
            Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetMasterCapability(
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpEnable()
/*++

Routine Description:

    Enable AGP for both the system and the video card.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    ULONG DataRate;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(&MasterCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpVerifyCapabilities - AgpLibGetMasterCapability failed %08lx", Status));
        return Status;
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        RIP(("AgpVerifyCapabilities - AgpLibGetMasterCapability returned no valid transfer rate"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpVerifyCapabilities   - AgpLibGetPciDeviceCapability failed %08lx", Status));
        return Status;
    }

    //
    // Check the data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    if (!(DataRate & PCI_AGP_RATE_4X))
    {
        RIP(("AgpVerifyCapabilities   - Mainboard/graphic card does not support 4x AGP."));
    }

    // 
    // The current graphics card does not support sideband addressing.  Note if 
    // this changes.
    //
    if (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing)
    {
        RIP(("AgpVerifyCapabilities   - Sideband addressing is now available."));
    }

    // 
    // The current mainboard does not support fast write.  Note if this changes.
    //

    if (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite)
    {
        RIP(("AgpVerifyCapabilities   - Fast write is now available."));
    }

    //
    // Enable the Target first.
    //
    TargetCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = 0;
    TargetCap.AGPCommand.FastWriteEnable = 0;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        RIP(("InitializeAGPUMA - AgpLibSetPciDeviceCapability %08lx for target failed %08lx",
                &TargetCap,
                Status));
        return Status;
    }

    //
    // Now enable the Master
    //
    MasterCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    MasterCap.AGPCommand.AGPEnable = 1;
    MasterCap.AGPCommand.SBAEnable = 0;
    MasterCap.AGPCommand.FastWriteEnable = 0;
    MasterCap.AGPCommand.FourGBEnable = 0;  
    MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
    Status = AgpLibSetMasterCapability(&MasterCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("InitializeAGPUMA - AgpLibSetMasterCapability %08lx failed %08lx",
                &MasterCap,
                Status));
        return Status;
    }

#if DBG

    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(&CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return STATUS_SUCCESS;
}

//============================================================================
// GART code
//============================================================================


NTSTATUS
AgpCreateAndEnableGART()
/*++

Routine Description:

    Create a GART large enough to hold all of physical memory, map
    the memory and enable it.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/
{

    ULONG GartLength;
    PGART_PTE Gart;
    ULONG_PTR GartPhysical;
    PACCFG PACConfig;
    AGPCTRL AgpCtrl;
    ULONG i;

#if DBG

    ULONG ApBase;
    UCHAR ApSize;

#endif DBG

#if DBG

    //
    // Verity the current APBASE and APSIZE settings
    //

    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    if (ApSize != AP_SIZE_64MB)
    {
        RIP(("AgpCreateAndEnableGART - Bad aperture size."));
    }

    if ((ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) != AGP_APERTURE_BASE)
    {
        RIP(("AgpCreateAndEnableGART - Bad Aperature base."));
    }

#endif DBG

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    GartLength = BYTES_TO_PAGES(AGP_APERTURE_BYTES) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength, 0, MAXULONG_PTR, 0, MmNonCached);
    if (Gart == NULL) {
        RIP(("Agp440CreateGart - MmAllocateContiguousMemory %lx failed\n",
            GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);

    //
    // Initialize all the PTEs
    //
    for (i = 0; i < GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Hard.Valid = 1;
        Gart[i].Hard.Page = i;
    }

    //
    // Update the configuration
    //
    Write440Config(&GartPhysical, ATTBASE_OFFSET, sizeof(GartPhysical));

    // 
    // Enable the GTLB
    //
    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
    AgpCtrl.GTLB_Enable = 1;
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    //
    // Enable the GART arpeture.
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 1;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    return STATUS_SUCCESS;
}

//============================================================================
// Main entrypoint
//============================================================================


BOOLEAN
AgpUmaEnable()

/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Return Value:

    S_OK

--*/

{
    NTSTATUS Status;

    if (!s_fInitialized)
    {
        //
        // Enable the devices.
        //
        Status = AgpEnable();
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        Status = AgpCreateAndEnableGART();
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    s_fInitialized = TRUE;

    return TRUE;
}

#endif 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\videoprt.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    videoprt.c

Abstract:

    This module implements a lightweight implementation of a video port driver.

--*/

#include "videoprt.h"

#if 1 // NUGOOP

extern BOOLEAN AgpUmaEnable();

#endif

PVIDEO_DEVICE_EXTENSION VideoGlobalDeviceExtension = NULL;

VOID
DriverEntry(
    IN PDRIVER_OBJECT DriverObject
    )
{
    //
    // We're actually an export library, not a real driver, so the DriverEntry
    // will never be called.  The routine only exists to satisfy the build
    // process.
    //

    ASSERT(FALSE);
}

ULONG VideoDebugLevel = 0;

VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    This routine allows the miniport drivers (as well as the port driver) to
    display error messages to the debug port when running in the debug
    environment.

    When running a non-debugged system, all references to this call are
    eliminated by the compiler.

Arguments:

    DebugPrintLevel - Debug print level between 0 and 3, with 3 being the
        most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= VideoDebugLevel) {

        char buffer[256];

        vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

} // VideoPortDebugPrint()

#if DBG

#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#else

#define pVideoDebugPrint(arg)

#endif

VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        ASSERT(FALSE);

        //
        // Since the driver did not see fit to follow the
        // rules about returning correct error codes. Videoprt will do it for
        // them.
        //

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} // end pVideoPortMapToNtStatus()

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    ((PMINIPORT_DPC_ROUTINE)(ULONG_PTR)DpcRoutine)(HwDeviceExtension, Context);
}

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortSynchronizeExecution synchronizes the execution of a miniport
    driver function in the following manner:

        - If Priority is equal to VpLowPriority, the current thread is
          raised to the highest non-interrupt-masking priority.  In
          other words, the current thread can only be pre-empted by an ISR.

        - If Priority is equal to VpMediumPriority and there is an
          ISR associated with the video device, then the function specified
          by SynchronizeRoutine is synchronized with the ISR.

          If no ISR is connected, synchronization is made at VpHighPriority
          level.

        - If Priority is equal to VpHighPriority, the current IRQL is
          raised to HIGH_LEVEL, which effectively masks out ALL interrupts
          in the system. This should be done sparingly and for very short
          periods -- it will completely freeze up the entire system.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    Priority - Specifies the type of priority at which the SynchronizeRoutine
        must be executed (found in VIDEO_SYNCHRONIZE_PRIORITY).

    SynchronizeRoutine - Points to the miniport driver function to be
        synchronized.

    Context - Specifies a context parameter to be passed to the miniport's
        SynchronizeRoutine.

Return Value:

    This function returns TRUE if the operation is successful.  Otherwise, it
    returns FALSE.

--*/

{
    BOOLEAN status;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    KIRQL oldIrql;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    //
    // Switch on which type of priority.
    //

    switch (Priority) {

    case VpMediumPriority:

        //
        // This is synchronized with the interrupt object
        //

        if (VideoDeviceExtension->InterruptObject) {

            status = KeSynchronizeExecution(VideoDeviceExtension->InterruptObject,
                                            (PKSYNCHRONIZE_ROUTINE)
                                            SynchronizeRoutine,
                                            Context);

            ASSERT (status == TRUE);

            return status;
        }

        //
        // Fall through for Medium Priority
        //

    case VpLowPriority:

        //
        // Just normal level
        //

        status = SynchronizeRoutine(Context);

        return status;

    case VpHighPriority:

        //
        // This is like cli\sti where we mask out everything.
        //

        //
        // Get the current IRQL to catch re-entrant routines into synchronize.
        //

        oldIrql = KeGetCurrentIrql();

        if (oldIrql < POWER_LEVEL - 1) {

            KeRaiseIrql(POWER_LEVEL, &oldIrql);

        }

        status = SynchronizeRoutine(Context);

        if (oldIrql < POWER_LEVEL - 1) {

            KeLowerIrql(oldIrql);

        }

        return status;

        break;

    default:

        return FALSE;

    }
}

BOOLEAN
VideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    )
{
    PVOID HwDeviceExtension;

    if (VideoGlobalDeviceExtension == NULL ||
        VideoGlobalDeviceExtension->HwResetHw == NULL) {
        return FALSE;
    }

    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoGlobalDeviceExtension);

    return VideoGlobalDeviceExtension->HwResetHw(HwDeviceExtension, Columns, Rows);
}

BOOLEAN
VideoPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
{
    BOOLEAN Handled;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)ServiceContext;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    if (VideoDeviceExtension->InterruptsEnabled) {
        Handled = VideoDeviceExtension->HwInterrupt(HwDeviceExtension);
    } else {
        Handled = FALSE;
    }

    return Handled;
}

NTSTATUS
VideoPortCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    if (!VideoDeviceExtension->DeviceOpened) {

        //
        // Invoke the miniport's HwInitialize routine.
        //

        if (VideoDeviceExtension->HwInitialize(HwDeviceExtension)) {

            VideoDeviceExtension->DeviceOpened = TRUE;

            status = STATUS_SUCCESS;

        } else {
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }

    } else {
        status = STATUS_ACCESS_DENIED;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
VideoPortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PSTATUS_BLOCK StatusBlock;
    VIDEO_REQUEST_PACKET vrp;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    StatusBlock = (PSTATUS_BLOCK)&Irp->IoStatus;

    vrp.IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    vrp.StatusBlock = StatusBlock;
    vrp.InputBuffer = IrpSp->Parameters.DeviceIoControl.InputBuffer;
    vrp.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    vrp.OutputBuffer = Irp->UserBuffer;
    vrp.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ACQUIRE_DEVICE_LOCK(VideoDeviceExtension);

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    RELEASE_DEVICE_LOCK(VideoDeviceExtension);

    if (StatusBlock->Status != NO_ERROR) {
        pVideoPortMapToNtStatus(StatusBlock);
    }

    status = Irp->IoStatus.Status;

    if (status == STATUS_PENDING) {
        return STATUS_PENDING;
    }

    IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);

    return status;
}

NTSTATUS
VideoPortClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PSTATUS_BLOCK StatusBlock;
    VIDEO_REQUEST_PACKET vrp;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    StatusBlock = (PSTATUS_BLOCK)&Irp->IoStatus;

    vrp.IoControlCode = IOCTL_VIDEO_RESET_DEVICE;
    vrp.StatusBlock = StatusBlock;
    vrp.InputBuffer = NULL;
    vrp.InputBufferLength = 0;
    vrp.OutputBuffer = NULL;
    vrp.OutputBufferLength = 0;

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    VideoDeviceExtension->DeviceOpened = FALSE;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);

    return STATUS_SUCCESS;
}

ULONG
VideoPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )
{
    NTSTATUS status;
    PDRIVER_OBJECT DriverObject;
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PCI_SLOT_NUMBER SlotNumber;
    PCI_COMMON_CONFIG Configuration;
    OBJECT_STRING ObjectName;
    PDEVICE_OBJECT DeviceObject;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PHYSICAL_ADDRESS ApertureBase;
    ULONG ApertureSizeInPages;
    VP_STATUS vpstatus;
    VIDEO_PORT_CONFIG_INFO ConfigInfo;
    UCHAR Again;
    ULONG InterruptVector;
    KIRQL InterruptIrql;

    DriverObject = (PDRIVER_OBJECT)Argument1;

    //
    // Fill in the driver object's dispatch routines.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = VideoPortCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = VideoPortDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = VideoPortClose;

    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return (ULONG)status;
    }

    //
    // Read the PCI configuration data for the adapter attached to the AGP440
    // bus.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (HalGetBusData(PCIConfiguration, 1, SlotNumber.u.AsULONG, &Configuration,
        sizeof(PCI_COMMON_CONFIG)) != sizeof(PCI_COMMON_CONFIG)) {
        return (ULONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Verify that this looks something like an NVidia display controller and
    // that the configuration is in the state that we expect.
    //

    ASSERT(Configuration.BaseClass == PCI_CLASS_DISPLAY_CTLR);
    ASSERT(Configuration.VendorID == 0x10DE);
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_IO_SPACE));
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_BUS_MASTER));

    //
    // Create the device object.
    //

    RtlInitObjectString(&ObjectName, OTEXT("\\Device\\Video0"));

    status = IoCreateDevice(DriverObject, sizeof(VIDEO_DEVICE_EXTENSION) +
        HwInitializationData->HwDeviceExtensionSize, &ObjectName,
        FILE_DEVICE_VIDEO, FILE_DEVICE_SECURE_OPEN, TRUE, &DeviceObject);

    if (!NT_SUCCESS(status)) {
        return (ULONG)status;
    }

    //
    // Initialize the device extension.
    //

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    RtlZeroMemory(VideoDeviceExtension, sizeof(VIDEO_DEVICE_EXTENSION) +
        HwInitializationData->HwDeviceExtensionSize);

    VideoDeviceExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    VideoDeviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    VideoDeviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    VideoDeviceExtension->HwStartIO = HwInitializationData->HwStartIO;
    VideoDeviceExtension->HwResetHw = HwInitializationData->HwResetHw;
    VideoDeviceExtension->HwTimer = HwInitializationData->HwTimer;

    RtlCopyMemory(VideoDeviceExtension->BaseAddresses, Configuration.u.type0.BaseAddresses,
        sizeof(ULONG) * PCI_TYPE0_ADDRESSES);

#if 0 // NUGOOP

    VideoDeviceExtension->AgpInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    VideoDeviceExtension->AgpInterface.Version = AGP_INTERFACE_VERSION;
    VideoDeviceExtension->AgpInterface.AgpContext = VideoDeviceExtension;
    VideoDeviceExtension->AgpInterface.InterfaceReference = AgpInterfaceReference;
    VideoDeviceExtension->AgpInterface.InterfaceDereference = AgpInterfaceDereference;
    VideoDeviceExtension->AgpInterface.ReserveMemory = AgpInterfaceReserveMemory;
    VideoDeviceExtension->AgpInterface.ReleaseMemory = AgpInterfaceReleaseMemory;
    VideoDeviceExtension->AgpInterface.CommitMemory = AgpInterfaceCommitMemory;
    VideoDeviceExtension->AgpInterface.FreeMemory = AgpInterfaceFreeMemory;
    VideoDeviceExtension->AgpInterface.GetMappedPages = AgpInterfaceGetMappedPages;

    ExInitializeFastMutex(&(VideoDeviceExtension->AgpInterfaceLock));

#endif 0

    KeInitializeDpc(&VideoDeviceExtension->Dpc, pVideoPortDpcDispatcher,
        HwDeviceExtension);

    KeInitializeMutex(&VideoDeviceExtension->SyncMutex, 0);

#if 1 // NUGOOP

    if (!AgpUmaEnable())
    {
        IoDeleteDevice(DeviceObject);
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

#else 

    //
    // Initialize the AGP440.
    //

    status = AgpInitializeTarget(&VideoDeviceExtension->Agp440Extension);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    status = AgpInitializeMaster(&VideoDeviceExtension->Agp440Extension,
        &(VideoDeviceExtension->AgpInterface.Capabilities));

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    //
    // Query the current AGP aperture and immediately write it back out to the
    // hardware.  This is done to ensure that the AGP440 extension has all of
    // its fields set up properly.
    //

    status = AgpQueryAperture(&VideoDeviceExtension->Agp440Extension,
        &ApertureBase, &ApertureSizeInPages, NULL);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    status = AgpSetAperture(&VideoDeviceExtension->Agp440Extension, ApertureBase,
        ApertureSizeInPages);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

#endif

    //
    // Invoke the miniport's HwFindAdapter routine.
    //

    RtlZeroMemory(&ConfigInfo, sizeof(VIDEO_PORT_CONFIG_INFO));

    ConfigInfo.Length = sizeof(VIDEO_PORT_CONFIG_INFO);
    ConfigInfo.BusInterruptLevel = 0xFF;
    ConfigInfo.BusInterruptVector = 0xFF;
    ConfigInfo.SystemMemorySize = /*(ULONGLONG)*/BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT;

    vpstatus = VideoDeviceExtension->HwFindAdapter(HwDeviceExtension, NULL,
        NULL, &ConfigInfo, &Again);

    if (vpstatus != NO_ERROR) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Connect to the device's interrupt.
    //

    if (VideoDeviceExtension->HwInterrupt != NULL) {

        VideoDeviceExtension->InterruptsEnabled = TRUE;

        InterruptVector = HalGetInterruptVector(PCIBus, 0,
            Configuration.u.type0.InterruptLine, Configuration.u.type0.InterruptLine,
            &InterruptIrql);

        status = IoConnectInterrupt(&(VideoDeviceExtension->InterruptObject),
            VideoPortInterrupt, VideoDeviceExtension, InterruptVector,
            InterruptIrql, InterruptIrql, LevelSensitive, TRUE);

        if (!NT_SUCCESS(status)) {
            IoDeleteDevice(DeviceObject);
            return (ULONG)status;
        }
    }

    //
    // Initialize the timer if the miniport requests one.  If this fails, then
    // ignore the error.  This is the same as the old videoprt.sys.
    //

#if 0
    if (VideoDeviceExtension->HwTimer != NULL) {
        IoInitializeTimer(DeviceObject, pVideoPortHwTimer, NULL);
    }
#endif

    //
    // There are some callbacks that don't pass a context parameter, so we need
    // to do this hack of storing our device extension in a global location.
    //

    ASSERT(VideoGlobalDeviceExtension == NULL);
    VideoGlobalDeviceExtension = VideoDeviceExtension;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return (ULONG)STATUS_SUCCESS;
}

PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;

    VideoDeviceExtension =
        (PVIDEO_DEVICE_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    return VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);
}

ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ASSERT(BusDataType == PCIConfiguration);

    return HalGetBusDataByOffset(PCIConfiguration, 1, SlotNumber, Buffer,
        Offset, Length);
}

ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ASSERT(BusDataType == PCIConfiguration);

    return HalSetBusDataByOffset(PCIConfiguration, 1, SlotNumber, Buffer,
        Offset, Length);
}

VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    ULONG Index;
    PCI_SLOT_NUMBER SlotNumber;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    RtlZeroMemory(AccessRanges, sizeof(VIDEO_ACCESS_RANGE) * NumAccessRanges);

    if (NumAccessRanges > PCI_TYPE0_ADDRESSES) {
        NumAccessRanges = PCI_TYPE0_ADDRESSES;
    }

    for (Index = 0; Index < NumAccessRanges; Index++) {

        //
        // NVidia uses only addresses in the memory space, so don't bother to
        // handle port space.
        //

        ASSERT(VideoIsFlagClear(VideoDeviceExtension->BaseAddresses[Index],
            PCI_ADDRESS_IO_SPACE));

        //
        // NVidia only cares about seeing the base address, so don't bother
        // computing the length of the PCI BAR or any of the other attributes in
        // the VIDEO_ACCESS_RANGE.
        //

        AccessRanges[Index].RangeStart.QuadPart =
            (ULONGLONG)VideoDeviceExtension->BaseAddresses[Index] & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    }

    //
    // Fill in the PCI slot number for the display adapter.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    *Slot = SlotNumber.u.AsULONG;

    return NO_ERROR;
}

VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context
    )
{
    ASSERT(!IsParameterFileName);

//    VideoDbgPrint(("VideoPortGetRegistryParameters(%ws)\n", ParameterName));

    return ERROR_INVALID_PARAMETER;
}

VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
{
//    VideoDbgPrint(("VideoPortSetRegistryParameters(%ws)\n", ValueName));

    return NO_ERROR;
}

BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID pHwDeviceExtension,
    IN PVOID pDDCControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize
    )
{
    //
    // The NVidia driver only tries to call this if we ask to enumerate the
    // devices attached to it (as in the monitor).  We won't do that, so don't
    // bother to implement this.
    //

    return FALSE;
}

BOOLEAN
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )
{
    return pVideoPortSynchronizeExecution(HwDeviceExtension, Priority,
        SynchronizeRoutine, Context);
}

PVOID
VideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    MEMORY_CACHING_TYPE CacheType;
    PVOID MappedAddress;
    ULONG Index;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    if ((InIoSpace & VIDEO_MEMORY_SPACE_P6CACHE) != 0) {
        CacheType = MmWriteCombined;
    } else {
        CacheType = MmNonCached;
    }

    MappedAddress = MmMapIoSpace(IoAddress.LowPart, NumberOfUchars, CacheType);

    if (MappedAddress == NULL) {
        return NULL;
    }

    //
    // MmUnmapIoSpace requires the size of the mapping and the miniport doesn't
    // pass that to VideoPortFreeDeviceBase, so we need to store the size in the
    // device extension.
    //

    for (Index = 0; Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES; Index++) {

        if (VideoDeviceExtension->MappedAddresses[Index].MappedAddress == NULL) {

            VideoDeviceExtension->MappedAddresses[Index].MappedAddress = MappedAddress;
            VideoDeviceExtension->MappedAddresses[Index].NumberOfUchars = NumberOfUchars;
            break;
        }
    }

    //
    // If we can't find a free slot for the entry, give up and let the mapping
    // leak.
    //

    ASSERT(Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES);

    return MappedAddress;
}

VOID
VideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    ULONG Index;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    for (Index = 0; Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES; Index++) {

        if (VideoDeviceExtension->MappedAddresses[Index].MappedAddress == MappedAddress) {

            MmUnmapIoSpace(MappedAddress,
                VideoDeviceExtension->MappedAddresses[Index].NumberOfUchars);

            VideoDeviceExtension->MappedAddresses[Index].MappedAddress = NULL;
            break;
        }
    }

    ASSERT(Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES);
}

VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    )
{
    ASSERT(Size != 0);

    *Buffer = ExAllocatePoolWithTag(PagedPool, Size, 'xdiV');

    return (*Buffer != NULL) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
}

VOID
VideoPortReleaseBuffer(
    IN PVOID HwDeviceExtension,
    IN PVOID Buffer
    )
{
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
}

VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    )
{
    *VirtualAddress = VideoPortGetDeviceBase(HwDeviceExtension, PhysicalAddress,
        *Length, (UCHAR)*InIoSpace);

    return (*VirtualAddress != NULL) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
}

VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    )
{
    VideoPortFreeDeviceBase(HwDeviceExtension, VirtualAddress);

    return NO_ERROR;
}

BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    return KeInsertQueueDpc(&VideoDeviceExtension->Dpc,
        (PVOID)(ULONG_PTR)CallbackRoutine, (PVOID)Context);
}

VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )
{
    return ERROR_NOT_ENOUGH_MEMORY;
}

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )
{
    return NO_ERROR;
}


VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    )
{
    //
    // The NVIDIA driver tries to call this only for cursors.  Since
    // we're not using cursors (yet), it's safe to fail this.
    //
}

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/

#include "videoprt.h"

#if 0 // NUGOOP

//
// Local function prototypes
//
NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );

#define Agp440EnableTB(_x_) Agp440SetGTLB_Enable((_x_), TRUE)
#define Agp440DisableTB(_x_) Agp440SetGTLB_Enable((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PAGP440_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    UCHAR ApSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = 4 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGP440 - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        //
        // 440 supports 7 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AP_SIZE_COUNT;
        Length = AP_MAX_SIZE;
        for (i=0; i<AP_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGP440_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    PACCFG PACConfig;
    UCHAR ApSize;
    ULONG ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then reenable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 0;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    Write440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    Write440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        Read440Config(&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
        Read440Config(&DbgBase, APBASE_OFFSET, sizeof(ApBase));
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == ApBase);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        ASSERT(PACConfig.GlobalEnable == 0);
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Agp440EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        Write440Config(&AgpContext->GartPhysical.LowPart,
                       ATTBASE_OFFSET,
                       sizeof(AgpContext->GartPhysical.LowPart));
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReserveMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = Agp440CreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp440CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (BOOLEAN)((Range->Type == MmNonCached) ? TRUE : FALSE);
    FoundRange = Agp440FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

// @@BEGIN_DDKSPLIT
        //
        // BUGBUG John Vert (jvert) 11/4/1997
        //  This is the point where we should try and grow the GART
        //
// @@END_DDKSPLIT

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;

    PAGED_CODE();

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE GartCached;
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

// @@BEGIN_DDKSPLIT
    //
    // BUGBUG John Vert (jvert) 11/5/1997
    //   This is a crock. We really need to use AllocateCommonBuffer here to
    //   get a non-cached contiguous range. Unfortunately, AllocateCommonBuffer
    //   does not actually allocate the memory non-cached. Until this is fixed,
    //   we have this hack-o-rama:
    //      MmAllocateContiguousMemory
    //      MmGetPhysicalAddress
    //      MmMapIoSpace
    //
// @@END_DDKSPLIT

    GartCached = MmAllocateContiguousMemory(GartLength);
    if (GartCached == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)GartCached & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical.QuadPart = MmGetPhysicalAddress(GartCached);
    AGPLOG(AGP_NOISE,
           ("Agp440CreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            GartCached,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Now we need to map this again to get a noncached pointer
    //
    Gart = MmMapIoSpace(GartPhysical.LowPart,
                        GartLength,
                        MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - couldn't map GART at %08lx non-cached\n",
                GartCached));
    }

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }


    Write440Config(&GartPhysical.LowPart, ATTBASE_OFFSET, sizeof(GartPhysical.LowPart));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->GartCached = GartCached;
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    GART_PTE NewPte;
    PACCFG PACConfig;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the 440 spec. This is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB. So flushing the TB seems
    // a little gratuitous but that's what the 440 spec says to do.
    //
    Agp440DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = (ULONG)(*Page++);
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // Re-enable the TB
    //
    Agp440EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Disable the TB to flush it
    //
    Agp440DisableTB(AgpContext);
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = Pte;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    //
    // Reenable the TB
    //
    Agp440EnableTB(AgpContext);

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies the AGP context

    Enable - TRUE, GTLB_Enable is set to 1
             FALSE, GTLB_Enable is set to 0

Return Value:

    None

--*/

{
    AGPCTRL AgpCtrl;

    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    if (Enable) {
        AgpCtrl.GTLB_Enable = 1;
    } else {
        AgpCtrl.GTLB_Enable = 0;
    }
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}

typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTSTATUS
ApGetSetDeviceBusData(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    PCI_SLOT_NUMBER SlotNumber;
    ULONG Transferred;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);

    }

    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read PCI Config space for Context %08lx failed %08lx\n",
                Context,
                Status));
        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does not support Capabilities list, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetAgpCapability - read PCI Capability at offset %x for Context %08lx failed %08lx\n",
                    CapabilityOffset,
                    Context,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does have an AGP Capability entry, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    AGPLOG(AGP_NOISE,
           ("AgpLibGetAgpCapability - Context %08lx has AGP Capability at offset %x\n",
            Context,
            CapabilityOffset));

    *pOffset = CapabilityOffset;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read AGP Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    AGPLOG(AGP_NOISE,
           ("AGP CAPABILITY: version %d.%d\n",Capability->Major, Capability->Minor));
    AGPLOG(AGP_NOISE,
           ("\tSTATUS  - Rate: %x  SBA: %x  RQ: %02x\n",
           Capability->AGPStatus.Rate,
           Capability->AGPStatus.SideBandAddressing,
           Capability->AGPStatus.RequestQueueDepthMaximum));
    AGPLOG(AGP_NOISE,
           ("\tCOMMAND - Rate: %x  SBA: %x  RQ: %02x  AGPEnable: %x\n",
           Capability->AGPCommand.Rate,
           Capability->AGPCommand.SBAEnable,
           Capability->AGPCommand.RequestQueueDepth,
           Capability->AGPCommand.AGPEnable));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibGetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetAgpCapability - Set AGP command at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    PAGP440_EXTENSION Extension = AgpExtension;

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Target first.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    //
    // Now enable the Master
    //
    MasterCap.AGPCommand.Rate = DataRate;
    MasterCap.AGPCommand.AGPEnable = 1;
    MasterCap.AGPCommand.SBAEnable = SBAEnable;
    MasterCap.AGPCommand.FastWriteEnable = FastWrite;
    MasterCap.AGPCommand.FourGBEnable = 0;  
    MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
    Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                &MasterCap,
                Status));
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\intrface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Routines for implementing the AGP_BUS_INTERFACE_STANDARD interface

Author:

    John Vert (jvert) 10/26/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/

#if 0 // NUGOOP

#define INITGUID 1
#include "videoprt.h"

ULONG AgpStopLevel;
ULONG AgpLogLevel;
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented

VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    );

VOID
AgpInterfaceReference(
    IN PVIDEO_DEVICE_EXTENSION Extension
    )
/*++

Routine Description:

    References an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{
}


VOID
AgpInterfaceDereference(
    IN PVIDEO_DEVICE_EXTENSION Extension
    )
/*++

Routine Description:

    Dereferences an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{
}


NTSTATUS
AgpInterfaceReserveMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    )
/*++

Routine Description:

    Reserves memory in the specified aperture

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    NumberOfPages - Supplies the number of pages to reserve.

    MemoryType - Supplies the memory caching type.

    MapHandle - Returns the mapping handle to be used on subsequent calls.

    PhysicalAddress - If present, returns the physical address in the aperture of the reserved 
            space

Return Value:

    NTSTATUS

--*/

{
    PVOID AgpContext;
    NTSTATUS Status;
    PAGP_RANGE Range;

    PAGED_CODE();                              

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    Range = ExAllocatePoolWithTag(PagedPool,
                                  sizeof(AGP_RANGE),
                                  'RpgA');
    if (Range == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Range->CommittedPages = 0;
    Range->NumberOfPages = NumberOfPages;
    Range->Type = MemoryType;

    LOCK_MASTER(Extension);
    Status = AgpReserveMemory(AgpContext,
                              Range);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReserveMemory - reservation of %x pages of type %d failed %08lx\n",
                NumberOfPages,
                MemoryType,
                Status));
    } else {
        AGPLOG(AGP_NOISE,
               ("AgpInterfaceReserveMemory - reserved %x pages of type %d at %I64X\n",
                NumberOfPages,
                MemoryType,
                Range->MemoryBase.QuadPart));
    }

    *MapHandle = Range;
    if (ARGUMENT_PRESENT(PhysicalAddress)) {
        *PhysicalAddress = Range->MemoryBase;
    }
    return(Status);
}


NTSTATUS
AgpInterfaceReleaseMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle
    )
/*++

Routine Description:

    Releases memory in the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range;
    PVOID AgpContext;
    NTSTATUS Status;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);
    Range = (PAGP_RANGE)MapHandle;

    LOCK_MASTER(Extension);
    //
    // Make sure the range is empty
    //
    ASSERT(Range->CommittedPages == 0);
    if (Range->CommittedPages != 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - Invalid attempt to release non-empty range %08lx\n",
                Range));
        UNLOCK_MASTER(Extension);
        return(STATUS_INVALID_PARAMETER);
    }

    AGPLOG(AGP_NOISE,
           ("AgpInterfaceReleaseMemory - releasing range %08lx, %lx pages at %08lx\n",
            Range,
            Range->NumberOfPages,
            Range->MemoryBase.QuadPart));
    Status = AgpReleaseMemory(AgpContext,
                              Range);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - release failed %08lx\n",
                Status));
    }
    UNLOCK_MASTER(Extension);
    ExFreePool(Range);
    return(Status);
}


NTSTATUS
AgpInterfaceCommitMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Commits memory into the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be committed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be committed.

    OffsetInPages - Supplies the offset, in pages, into the aperture reserved by
        AgpInterfaceReserveMemory

    Mdl - Returns the MDL describing the pages of memory committed.

    MemoryBase - Returns the physical memory address of the committed memory.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PMDL NewMdl;
    PVOID AgpContext;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG RunLength, RunOffset;
    ULONG CurrentLength, CurrentOffset;
    PMDL FirstMdl=NULL;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT((Mdl == NULL) || (Mdl->ByteCount == PAGE_SIZE * NumberOfPages));

    CurrentLength = NumberOfPages;
    CurrentOffset = OffsetInPages;

    LOCK_MASTER(Extension);
    do {

        //
        // Find the first free run in the supplied range.
        //
        AgpFindFreeRun(AgpContext,
                       Range,
                       CurrentLength,
                       CurrentOffset,
                       &RunLength,
                       &RunOffset);

        if (RunLength > 0) {
            ASSERT(RunLength <= CurrentLength);
            ASSERT(RunOffset >= CurrentOffset);
            ASSERT(RunOffset < CurrentOffset + CurrentLength);
            ASSERT(RunOffset + RunLength <= CurrentOffset + CurrentLength);

            //
            // Compute the next offset and length
            //
            CurrentLength -= (RunOffset - CurrentOffset) + RunLength;
            CurrentOffset = RunOffset + RunLength;

            //
            // Get an MDL from memory management big enough to map the 
            // requested range.
            //

            NewMdl = AgpLibAllocatePhysicalMemory(AgpContext, RunLength * PAGE_SIZE);

            //
            // This can fail in two ways, either no memory is available at all (NewMdl == NULL)
            // or some pages were available, but not enough. (NewMdl->ByteCount < Length)
            //
            if (NewMdl == NULL) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceReserveMemory - Couldn't allocate pages for %lx bytes\n",
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else if (BYTES_TO_PAGES(NewMdl->ByteCount) < RunLength) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - Only allocated enough pages for %lx of %lx bytes\n",
                        NewMdl->ByteCount,
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                MmFreePagesFromMdl(NewMdl);
                break;
            }

            //
            // Now that we have our MDL, we can map this into the specified
            // range.
            //
            if (AgpFlushPages != NULL) {
                (AgpFlushPages)(AgpContext, NewMdl);
            } else {
                AgpLibFlushDcacheMdl(NewMdl);
            }
            Status = AgpMapMemory(AgpContext,
                                  Range,
                                  NewMdl,
                                  RunOffset,
                                  MemoryBase);
            if (!NT_SUCCESS(Status)) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - AgpMapMemory for Mdl %08lx in range %08lx failed %08lx\n",
                        NewMdl,
                        Range,
                        Status));
                MmFreePagesFromMdl(NewMdl);
                break;
            }
            Range->CommittedPages += RunLength;

            //
            // Add this MDL to our list of allocated MDLs for cleanup
            // If we need to cleanup, we will also need to know the page offset
            // so that we can unmap the memory. Stash that value in the ByteOffset
            // field of the MDL (ByteOffset is always 0 for our MDLs)
            //
            NewMdl->ByteOffset = RunOffset;
            NewMdl->Next = FirstMdl;
            FirstMdl = NewMdl;
        }

    } while (RunLength > 0);

    //
    // Cleanup the MDLs. If the allocation failed, we need to
    // unmap them and free the pages and the MDL itself. If the
    // operation completed successfully, we just need to free the
    // MDL.
    //
    while (FirstMdl) {
        NewMdl = FirstMdl;
        FirstMdl = NewMdl->Next;
        if (!NT_SUCCESS(Status)) {

            //
            // Unmap the memory that was mapped. The ByteOffset field
            // of the MDL is overloaded here to store the offset in pages
            // into the range.
            //
            AgpUnMapMemory(AgpContext,
                           Range,
                           NewMdl->ByteCount / PAGE_SIZE,
                           NewMdl->ByteOffset);
            NewMdl->ByteOffset = 0;
            Range->CommittedPages -= NewMdl->ByteCount / PAGE_SIZE;
            MmFreePagesFromMdl(NewMdl);
        }
        ExFreePool(NewMdl);
    }

    if (NT_SUCCESS(Status)) {

        if (Mdl) {
            //
            // Get the MDL that describes the entire mapped range.
            //
            AgpGetMappedPages(AgpContext,
                              Range,
                              NumberOfPages,
                              OffsetInPages,
                              Mdl);
        }

        MemoryBase->QuadPart = Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE;
    }

    UNLOCK_MASTER(Extension);
    return(Status);
}


NTSTATUS
AgpInterfaceFreeMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Frees memory previously committed by AgpInterfaceCommitMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be freed.

    OffsetInPages - Supplies the start of the range to be freed.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;
    PMDL FreeMdl;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceFreeMemory - Invalid free of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Allocate an MDL big enough to contain the pages to be unmapped.
    //
    FreeMdl = MmCreateMdl(NULL, 0, NumberOfPages * PAGE_SIZE);
    if (FreeMdl == NULL) {

// @@BEGIN_DDKSPLIT
        //
        // This is kind of a sticky situation. We can't allocate the memory that we need to free up
        // some memory! I guess we could have a small MDL on our stack and free things that way.
        // BUGBUG John Vert (jvert) 11/11/1997
        //   implement this
        //
// @@END_DDKSPLIT

        ASSERT(FreeMdl != NULL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    LOCK_MASTER(Extension);

    //
    // Get the MDL that describes the entire mapped range
    //
    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      FreeMdl);
    //
    // Unmap the memory
    //
    Status = AgpUnMapMemory(AgpContext,
                            Range,
                            NumberOfPages,
                            OffsetInPages);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceFreeMemory - UnMapMemory for %x pages at %I64X failed %08lx\n",
                NumberOfPages,
                Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE,
                Status));
    } else {
        //
        // Free the pages
        //
        MmFreePagesFromMdl(FreeMdl);
        ASSERT(Range->CommittedPages >= NumberOfPages);
        Range->CommittedPages -= NumberOfPages;
    }

    //
    // Free the MDL we allocated.
    //
    ExFreePool(FreeMdl);
    return(Status);
}

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped backing the specified range.

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the rangion

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    ASSERT(Mdl->ByteCount == PAGE_SIZE * NumberOfPages);

    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceGetMappedPages - Invalid 'get' of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Get the MDL that describes the entire mapped range
    //
    LOCK_MASTER(Extension);

    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      Mdl);

    UNLOCK_MASTER(Extension);
    return(STATUS_SUCCESS);
}


PMDL
AgpLibAllocatePhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Allocates a set of physical memory pages for use by the AGP driver.
    
    This routine uses MmAllocatePagesForMdl to attempt to allocate
    as many of the pages as possible within favored AGP memory
    ranges (if any).

Arguments:

    AgpContext   - The AgpContext

    TotalBytes   - The total amount of bytes to allocate.

Return Value:

    An MDL that describes the allocated physical pages or NULL
    if this function is unsuccessful.

    NOTE: Just like MmAllocatePagesForMdl, this function can return
    an MDL that describes an allocation smaller than TotalBytes in size.

--*/
{
   PAGED_CODE();

   AGPLOG(AGP_NOISE, ("AGPLIB: Attempting to allocate memory = %u pages.\n",
            BYTES_TO_PAGES(TotalBytes)));

   return MmAllocatePagesForMdl(0,
                                MAXULONG_PTR,
                                TotalBytes);
}


PVOID
AgpLibAllocateMappedPhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Same as AgpLibAllocatePhysicalMemory, except this function will
    also map the allocated memory to a virtual address.

Arguments:

    Same as AgpLibAllocatePhysicalMemory.

Return Value:

    A virtual address of the allocated memory or NULL if unsuccessful.

--*/
{
   PMDL Mdl;
   PVOID Ret;

   PAGED_CODE();
   
   AGPLOG(AGP_NOISE, 
          ("AGPLIB: Attempting to allocate mapped memory = %u.\n", TotalBytes));

   //
   // Call the real memory allocator.
   //

   Mdl = AgpLibAllocatePhysicalMemory(AgpContext, TotalBytes);

   // Two possible failures

   // 1. MDL is NULL. No memory could be allocated.

   if (Mdl == NULL) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate anything.\n"));

      return NULL;
   }

   // 2. MDL has some pages allocated but not enough.

   if (Mdl->ByteCount < TotalBytes) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate enough.\n"));

      MmFreePagesFromMdl(Mdl);
      ExFreePool(Mdl);
      return NULL;
   }

   // Ok. Our allocation succeeded. Map it to a virtual address.

   // Step 1: Map the locked Pages. (will return NULL if failed)

   Mdl->MdlFlags |= MDL_PAGES_LOCKED;
   Ret = MmMapLockedPagesSpecifyCache (Mdl, MmNonCached);

   // Don't need the Mdl anymore, whether we succeeded or failed.

   ExFreePool(Mdl);

   if (Ret == NULL) {
      AGPLOG(AGP_WARNING, ("AGPMAP: Could not map.\n"));
   }

   return Ret;
}

#if defined (_X86_)
#define FLUSH_DCACHE(Mdl) __asm{ wbinvd }
#else
#define FLUSH_DCACHE(Mdl)   \
            AGPLOG(AGP_CRITICAL,    \
                   ("AgpLibFlushDcacheMdl - NEED TO IMPLEMENT DCACHE FLUSH FOR THIS ARCHITECTURE!!\n"))
#endif


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    )
/*++

Routine Description:

    Flushes the specified MDL from the D-caches of all processors
    in the system.

    Current algorithm is to set the current thread's affinity to each
    processor in turn and flush the dcache. This could be made a lot
    more efficient if this turns out to be a hot codepath

Arguments:

    Mdl - Supplies the MDL to be flushed.

Return Value:

    None.

--*/

{
    FLUSH_DCACHE(Mdl);
}

#endif 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\videoprt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    videoprt.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the video port driver.

--*/

#ifndef _VIDEOPRT_
#define _VIDEOPRT_

#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <ntagp.h>
#include <stdio.h>
#include "agp440.h"

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define VideoDbgPrint(x)                        DbgPrint x
#else
#define VideoDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define VideoIsFlagSet(flagset, flag)           (((flagset) & (flag)) != 0)
#define VideoIsFlagClear(flagset, flag)         (((flagset) & (flag)) == 0)
#define VideoIsBitSet(flagset, bit)             VideoIsFlagSet((flagset), (1 << (bit)))
#define VideoIsBitClear(flagset, bit)           VideoIsFlagClear((flagset), (1 << (bit)))

//
// Structure to track the size of memory mappings.
//

typedef struct _VIDEO_MAPPED_ADDRESS {
    PVOID MappedAddress;
    ULONG NumberOfUchars;
} VIDEO_MAPPED_ADDRESS, *PVIDEO_MAPPED_ADDRESS;

#define NUMBER_OF_VIDEO_MAPPED_ADDRESSES        8

//
// Video device extension data.
//

typedef struct _VIDEO_DEVICE_EXTENSION {
    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;
    PVIDEO_HW_INITIALIZE HwInitialize;
    PVIDEO_HW_INTERRUPT HwInterrupt;
    PVIDEO_HW_START_IO HwStartIO;
    PVIDEO_HW_RESET_HW HwResetHw;
    PVIDEO_HW_TIMER HwTimer;
    ULONG BaseAddresses[PCI_TYPE0_ADDRESSES];
    VIDEO_MAPPED_ADDRESS MappedAddresses[NUMBER_OF_VIDEO_MAPPED_ADDRESSES];
    PKINTERRUPT InterruptObject;
    KDPC Dpc;
    BOOLEAN DeviceOpened;
    BOOLEAN InterruptsEnabled;
    KMUTEX SyncMutex;
    AGP_BUS_INTERFACE_STANDARD AgpInterface;
    FAST_MUTEX AgpInterfaceLock;
    AGP440_EXTENSION Agp440Extension;
} VIDEO_DEVICE_EXTENSION, *PVIDEO_DEVICE_EXTENSION;

//
// Macros to convert between the VIDEO_DEVICE_EXTENSION structure and the
// miniport's hardware extension.
//

#define VIDEO_GET_VIDEO_DEVICE_EXTENSION(hwe) \
    (((PVIDEO_DEVICE_EXTENSION)(hwe)) - 1)

#define VIDEO_GET_HW_DEVICE_EXTENSION(vde) \
    ((PVOID)(((PVIDEO_DEVICE_EXTENSION)(vde)) + 1))

//
// Define the slot configuration for the video adapter attached to an AGP440.
//

#define AGP440_TARGET_DEVICE_NUMBER             0
#define AGP440_TARGET_FUNCTION_NUMBER           0

//
// These macros are used to protect threads which will enter the
// miniport.  We need to guarantee that only one thread enters
// the miniport at a time.
//

#define ACQUIRE_DEVICE_LOCK(DeviceExtension)           \
    KeWaitForSingleObject(&DeviceExtension->SyncMutex, \
                          Executive,                   \
                          KernelMode,                  \
                          FALSE,                       \
                          (PTIME)NULL);

#define RELEASE_DEVICE_LOCK(DeviceExtension)           \
    KeReleaseMutex(&DeviceExtension->SyncMutex,        \
                   FALSE);

#endif // VIDEOPRT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\portx\agp440.h ===
//
// Always turned on for now
//
#if DEVL

#define AGP_ALWAYS   0
#define AGP_CRITICAL 1
#define AGP_WARNING  2
#define AGP_IRPTRACE 3
#define AGP_NOISE    4

extern ULONG AgpLogLevel;
extern ULONG AgpStopLevel;
#define AGPLOG(_level_,_x_) if ((_level_) <= AgpLogLevel) DbgPrint _x_; \
                            if ((_level_) <= AgpStopLevel) { DbgBreakPoint();}

#else

#define AGPLOG(_level_,_x_)

#endif

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440BX_IDENTIFIER    0x71908086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL {
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG {
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
} AGP440_EXTENSION, *PAGP440_EXTENSION;

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

typedef struct _AGP_RANGE {
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    );

NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    );

NTSTATUS
AgpQueryAperture(
    IN PVOID AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    );

NTSTATUS
AgpSetAperture(
    IN PVOID AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    OUT ULONG NewSizeInPages
    );

NTSTATUS
AgpReserveMemory(
    IN PVOID AgpContext,
    IN OUT AGP_RANGE *AgpRange
    );

NTSTATUS
AgpReleaseMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange
    );

VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    );

VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

NTSTATUS
AgpMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpUnMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
VOID
(*PAGP_FLUSH_PAGES)(
    IN PVOID AgpContext,
    IN PMDL Mdl
    );

extern PAGP_FLUSH_PAGES AgpFlushPages;

VOID
AgpInterfaceReference(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension
    );

VOID
AgpInterfaceDereference(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension
    );

NTSTATUS
AgpInterfaceReserveMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

NTSTATUS
AgpInterfaceReleaseMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle
    );

NTSTATUS
AgpInterfaceCommitMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpInterfaceFreeMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

NTSTATUS
AgpInterfaceGetMappedPages(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

#define GET_AGP_CONTEXT_FROM_MASTER(_masterext_) (&(_masterext_)->Agp440Extension)

PMDL
AgpLibAllocatePhysicalMemory(
    IN PVOID AgpContext,
    IN ULONG TotalBytes);

//
// Locking macros
//
#define LOCK_MUTEX(_fm_) ExAcquireFastMutex(_fm_); \
                         ASSERT((_fm_)->Count == 0)

#define UNLOCK_MUTEX(_fm_) ASSERT((_fm_)->Count == 0);  \
                           ExReleaseFastMutex(_fm_)

#define LOCK_MASTER(_masterext_) LOCK_MUTEX(&(_masterext_)->AgpInterfaceLock)

#define UNLOCK_MASTER(_masterext_) UNLOCK_MUTEX(&(_masterext_)->AgpInterfaceLock)

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@

xapiw0.c : xapi0.c

xapiwin0.c : xapi0.c

xapiwwin0.c : xapi0.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\dllp.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dllp.h

Abstract:

    Precompiled header.

--*/

#ifndef _DLLP_
#define _DLLP_

#include "xapip.h"
#include <xboxp.h>
#include <stdio.h>
#include <scsi.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <dvdx2.h>

#include "xapiver.h"

#endif // _DLLP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\xapitls.c ===
/*
 *
 * xapitls.c
 *
 * Xapi TLS data
 *
 */

#include "dllp.h"

ULONG _tls_index = 0;

/* Special symbols to mark start and end of Thread Local Storage area. */

#pragma data_seg(".tls")

char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

char _tls_end = 0;

/*
 * Mark the .tls section as discardable so that IMAGEBLD throws the
 * section (non-zero Thread Local Storage data is moved to a different
 * location in the image).
 */

#pragma comment(linker, "/SECTION:.tls,D")

#pragma data_seg(".rdata$T")

const IMAGE_TLS_DIRECTORY _tls_used =
{
        (ULONG)(ULONG_PTR) &_tls_start, // start of tls data
        (ULONG)(ULONG_PTR) &_tls_end,   // end of tls data
        (ULONG)(ULONG_PTR) &_tls_index, // address of tls_index
        (ULONG)(ULONG_PTR) NULL,        // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
        (ULONG) 0                       // characteristics
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\xapi0dat.c ===
/*
 *
 * xapi0dat.c
 *
 * Xapi initializers
 *
 */

#include "dllp.h"

typedef void (__cdecl *PVFV)(void);
typedef int (__cdecl *PIFV)(void);

#pragma data_seg(".CRT$XCA")
PVFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
PVFV __xc_z[] = { NULL };

#pragma data_seg(".CRT$XIA")
PIFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
PIFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$RIA")
PIFV __xri_a[] = { NULL };

#pragma data_seg(".CRT$RIZ")
PIFV __xri_z[] = { NULL };

#ifdef _DEBUG
#pragma data_seg(".CRT$RII15")
extern int __cdecl _RTC_Initialize(void);
void *__rtc_init = _RTC_Initialize;
#endif


#pragma data_seg()

PVFV _FPinit;

#pragma comment(linker, "/merge:.CRT=.data")

static void _initterm(PVFV *a, PVFV *z)
{
	for(; a < z; ++a)
		if(*a != NULL && *a != (PVFV)-1)
			(**a)();
}

static void _initterm_e(PIFV *a, PIFV *z)
{
	for(; a < z; ++a) {
		if(*a != NULL && *a != (PIFV)-1)
			if(0 != (**a)()) {
                RIP("Runtime initialization failed!");
            }
    }
}

void _cinit(void)
{
	/* Init floating point */
	if(_FPinit)
		(*_FPinit)();

	/* Do the initializers */
	_initterm_e(__xi_a, __xi_z);

	/* Now do the constructors */
	_initterm(__xc_a, __xc_z);
}

void _rtinit(void)
{
	/* Do the CRT initializers */
	_initterm_e(__xri_a, __xri_z);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\i386\xapiatls.asm ===
page	,132
    title	atlssup - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Defines the symbol [_]_tls_array which is the offset into the
;	TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;	03-19-93  SKS	Initial version (from ChuckM)
;	03-22-93  SKS	One less leading underscore with new include file 
;	10-06-94  SKS	Added header file comment
;
;*******************************************************************************

.xlist
%   .model small, C
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

		public	_tls_array 
_tls_array 	equ	04h	  ; TIB.StackBase

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\xapiinit.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Initialization code for the win32 api equivalents in kernel mode for xbox

--*/

#include "dllp.h"
#include <xboxverp.h>

#define DASHBOARD_TITLE_ID   0xFFFE0000

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

#include "xmeta.h"

COBJECT_STRING DDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\D:") );
COBJECT_STRING CdDevice    = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\CdRom0") );
COBJECT_STRING MainVol     = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\") );
COBJECT_STRING TDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\T:") );
COBJECT_STRING TitleData   = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\TDATA") );
COBJECT_STRING UDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\U:") );
COBJECT_STRING UserData    = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\UDATA") );

NTSTATUS
XapiValidateDiskPartition(
    POBJECT_STRING PartitionName
    )
{
    return XapiValidateDiskPartitionEx(PartitionName, 16384);
}

NTSTATUS
XapiValidateDiskPartitionEx(
    POBJECT_STRING PartitionName,
    ULONG BytesPerCluster
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;

    InitializeObjectAttributes(
        &Obja,
        PartitionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the partition
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );

    if (NT_SUCCESS(Status))
    {
        //
        // Determine the size parameters of the volume.
        //

        Status = NtQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo),
                    FileFsSizeInformation
                    );

        NtClose(Handle);

        if (NT_SUCCESS(Status))
        {
            if (SizeInfo.BytesPerSector * SizeInfo.SectorsPerAllocationUnit !=
                BytesPerCluster)
            {
                Status = STATUS_UNRECOGNIZED_VOLUME;
            }
        }
    }

    return Status;
}

NTSTATUS
XapiCopySectionToFile(
    HANDLE SectionHandle,
    PSTR pszPathBuffer,
    UINT cchPathBuffer,
    PCSTR pcszFileName
    )
{
    OBJECT_STRING MetaFilePathString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE MetaHandle;
    int nPathLen;

    ASSERT((INVALID_HANDLE_VALUE != SectionHandle) && pszPathBuffer && pcszFileName);

    nPathLen = ocslen(pszPathBuffer);

    lstrcpynO(&(pszPathBuffer[nPathLen]),
              pcszFileName,
              cchPathBuffer - nPathLen);

    RtlInitObjectString(&MetaFilePathString, pszPathBuffer);

    InitializeObjectAttributes(
        &Obja,
        &MetaFilePathString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(&MetaHandle,
                          SYNCHRONIZE | GENERIC_WRITE,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ,
                          FILE_OPEN_IF,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                          );

    pszPathBuffer[nPathLen] = OBJECT_NULL;

    if (NT_SUCCESS(Status))
    {
        FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

        Status = NtQueryInformationFile(
                    MetaHandle,
                    &IoStatusBlock,
                    &NetworkInfo,
                    sizeof(NetworkInfo),
                    FileNetworkOpenInformation
                    );

        if (NT_SUCCESS(Status))
        {
            //
            // Only write if this is an empty file (first creation or first time
            // after an invalid, failed creation)
            //

            if (0 == NetworkInfo.EndOfFile.QuadPart)
            {
                PBYTE pbSection;

                //
                // Attempt to load the title info section
                //

                pbSection = XLoadSectionByHandle(SectionHandle);

                if (pbSection)
                {
                    Status = NtWriteFile(MetaHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         pbSection,
                                         XGetSectionSize(SectionHandle),
                                         NULL
                                         );

                    if (!NT_SUCCESS(Status))
                    {
                        XDBGWRN("XAPI", "XapiCopySectionToFile() failed to write to file");
                    }

                    //
                    // Unload the title info section (we're done with it)
                    //

                    XFreeSectionByHandle(SectionHandle);
                }
            }
        }
        else
        {
            XDBGERR("XAPI", "XapiCopySectionToFile() failed to get meta file size");
        }

        NtClose(MetaHandle);
    }
    else if (STATUS_OBJECT_NAME_COLLISION == Status)
    {
        //
        // If the meta data image file already exists, we should continue
        // as if everything is fine (no need to rewrite this data)
        //

        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
XapiMapLetterToDirectory(
    PCOBJECT_STRING pcDriveString,
    PCOBJECT_STRING pcPathString,
    PCOSTR pcszTitleId,
    BOOL fCreateDirectory,
    LPCWSTR pcszTitleName,
    BOOL fUpdateTimestamp
    )
{
    NTSTATUS Status;
    OCHAR szPathTemp[MAX_PATH];
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING PerTitlePathString;
    HANDLE DirHandle;

    ASSERT(pcDriveString && pcPathString && pcszTitleId);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) pcPathString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    //
    //  The parent of the subirectory may not already exist
    //  so we open it first with 'FILE_OPEN_IF' to create it,
    //  just in case.  This mainly occurs when running
    //  recovery.
    //

    Status = NtCreateFile(
                &DirHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (NT_SUCCESS(Status))
    {
        NtClose(DirHandle);
    }
    else if (STATUS_NOT_A_DIRECTORY == Status)
    {
        //
        //  XMountAlternateTitle when called on an MU passes a volume (not the
        //  volume's root directory) for pcDriveString.  So the above call will
        //  fail with STATUS_NOT_A_DIRECTORY.  This is OK though, so we change
        //  to success and continue.  Note that if we remove FILE_DIRECTORY_FILE
        //  from the above NtCreateFile, then recovery creates a file named UDATA
        //  instead of a directory and promptly crashes.
        //
        Status = STATUS_SUCCESS;
    }
    else
    {
        XDBGWRN("XAPI",
                "XapiMapLetterToDirectory(): NtCreateFile() \"%Z\" failed with 0x%08x",
                pcPathString,
                Status);
    }

    if (NT_SUCCESS(Status))
    {
        ASSERT(ocslen(pcszTitleId) < CCHMAX_HEX_DWORD);
        ASSERT(pcPathString->Length < (sizeof(szPathTemp) - (CCHMAX_HEX_DWORD * sizeof(OCHAR))));
        ocscpy(szPathTemp, pcPathString->Buffer);
        //
        //  Usually, pcDriveString usually does not have a '\\' on the end, the exception
        //  is on mounting MU's.  So here we check for '\\' and only append if necessary.
        //
        if(szPathTemp[(pcPathString->Length / sizeof(OCHAR))-1] != OTEXT('\\'))
        {
            szPathTemp[pcPathString->Length / sizeof(OCHAR)] = OTEXT('\\');
        } else
        {
            pcPathString->Length--;
        }
        ocscpy(&(szPathTemp[(pcPathString->Length + sizeof(OCHAR)) / sizeof(OCHAR)]), pcszTitleId);

        RtlInitObjectString(&PerTitlePathString, szPathTemp);

        InitializeObjectAttributes(
            &Obja,
            &PerTitlePathString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &DirHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    fCreateDirectory ? FILE_OPEN_IF : FILE_OPEN,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );

        if (NT_SUCCESS(Status))
        {
            if (fUpdateTimestamp)
            {
                FILE_BASIC_INFORMATION BasicInfo;

                //
                // Zero all the time values we can set.
                //

                RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));

                //
                // Set the last write times
                //

                KeQuerySystemTime(&BasicInfo.LastWriteTime);

                NtSetInformationFile(
                            DirHandle,
                            &IoStatusBlock,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            FileBasicInformation
                            );
            }

            //
            // Only attempt to write meta data if non-null titlename and pubname strings were passed in
            // (these are not passed in if we're mounting another title's drive)
            //

            if (pcszTitleName)
            {
                HANDLE TitleInfoSection;
                HANDLE TitleImageSection;
                HANDLE SaveImageSection;

                TitleInfoSection = XGetSectionHandle("$$XTINFO");
                TitleImageSection = XGetSectionHandle("$$XTIMAGE");
                SaveImageSection = XGetSectionHandle("$$XSIMAGE");

                if ((INVALID_HANDLE_VALUE != TitleInfoSection) ||
                    (L'\0' != *pcszTitleName))
                {
                    //
                    // Create TITLEMETA.XBX file underneath the save game directory and
                    // write metadata information there
                    //

                    OBJECT_STRING MetaFilePathString;
                    HANDLE MetaHandle;
                    int nPathLen = ocslen(szPathTemp);

                    lstrcpynO(&(szPathTemp[nPathLen]),
                              g_cszTitleMetaFileName,
                              ARRAYSIZE(szPathTemp) - nPathLen);

                    RtlInitObjectString(&MetaFilePathString, szPathTemp);

                    InitializeObjectAttributes(
                        &Obja,
                        &MetaFilePathString,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

                    Status = NtCreateFile(&MetaHandle,
                                          SYNCHRONIZE | GENERIC_WRITE,
                                          &Obja,
                                          &IoStatusBlock,
                                          NULL,
                                          FILE_ATTRIBUTE_SYSTEM,
                                          FILE_SHARE_READ,
                                          FILE_OPEN_IF,
                                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                                          );

                    szPathTemp[nPathLen] = OBJECT_NULL;

                    if (NT_SUCCESS(Status))
                    {
                        FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

                        Status = NtQueryInformationFile(
                                    MetaHandle,
                                    &IoStatusBlock,
                                    &NetworkInfo,
                                    sizeof(NetworkInfo),
                                    FileNetworkOpenInformation
                                    );

                        if (NT_SUCCESS(Status))
                        {
                            //
                            // Only write if this is an empty file (first creation or first time
                            // after an invalid, failed creation)
                            //

                            if (0 == NetworkInfo.EndOfFile.QuadPart)
                            {
                                PVOID pvTitleInfo = NULL;

                                //
                                // Attempt to load the title info section
                                //

                                if (INVALID_HANDLE_VALUE != TitleInfoSection)
                                {
                                    pvTitleInfo = XLoadSectionByHandle(TitleInfoSection);
                                }

                                if (pvTitleInfo)
                                {
                                    //
                                    // Write TITLEMETA.XBX as a copy of the title info section
                                    //

                                    Status = NtWriteFile(MetaHandle,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &IoStatusBlock,
                                                         pvTitleInfo,
                                                         XGetSectionSize(TitleInfoSection),
                                                         NULL
                                                         );

                                    if (!NT_SUCCESS(Status))
                                    {
                                        XDBGWRN("XAPI", "XapiMapLetterToDirectory() failed to write title info file");
                                    }

                                    XFreeSectionByHandle(TitleInfoSection);
                                }
                                else
                                {
                                    //
                                    // Write TITLEMETA.XBX with the title name value from the cert
                                    //

                                    //
                                    // szBuffer size is: 1 signature WCHAR plus one line of metadata
                                    //

                                    WCHAR szBuffer[1 + MAX_METADATA_LINE];
                                    DWORD dwSize;

                                    dwSize = _snwprintf(szBuffer,
                                                        ARRAYSIZE(szBuffer),
                                                        L"%lc%ls%lc%ls%ls",
                                                        g_chUnicodeSignature,
                                                        g_cszTitleNameTag,
                                                        g_chEqual,
                                                        pcszTitleName,
                                                        g_cszCRLF);
                                    dwSize *= sizeof(WCHAR);

                                    Status = NtWriteFile(MetaHandle,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &IoStatusBlock,
                                                         szBuffer,
                                                         dwSize,
                                                         NULL
                                                         );

                                    if (!NT_SUCCESS(Status))
                                    {
                                        XDBGWRN("XAPI", "XapiMapLetterToDirectory() failed to write title info file");
                                    }
                                }
                            }
                        }
                        else
                        {
                            XDBGERR("XAPI", "XapiMapLetterToDirectory() failed to get meta file size");
                        }

                        NtClose(MetaHandle);
                    }
                    else if (STATUS_OBJECT_NAME_COLLISION == Status)
                    {
                        //
                        // If the meta data file already exists, we should continue
                        // as if everything is fine (no need to rewrite this data)
                        //

                        Status = STATUS_SUCCESS;
                    }
                }

                if (NT_SUCCESS(Status) && (INVALID_HANDLE_VALUE != TitleImageSection))
                {
                    Status = XapiCopySectionToFile(TitleImageSection,
                                                   szPathTemp,
                                                   ARRAYSIZE(szPathTemp),
                                                   g_cszTitleImageFileName);
                }

                if (NT_SUCCESS(Status) && (INVALID_HANDLE_VALUE != SaveImageSection))
                {
                    Status = XapiCopySectionToFile(SaveImageSection,
                                                   szPathTemp,
                                                   ARRAYSIZE(szPathTemp),
                                                   g_cszSaveImageFileName);
                }
            }

            NtClose(DirHandle);
        }
        else if (fCreateDirectory)
        {
            XDBGWRN("XAPI",
                    "XapiMapLetterToDirectory(): NtCreateFile() \"%s\" failed with 0x%08x",
                    szPathTemp,
                    Status);
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = IoCreateSymbolicLink((POBJECT_STRING) pcDriveString, &PerTitlePathString);

        if (!NT_SUCCESS(Status))
        {
            XDBGERR("XAPI",
                    "XapiMapLetterToDirectory(): IoCreateSymbolicLink() failed \"%Z\"->\"%Z\"",
                    pcDriveString,
                    pcPathString);
        }
    }

    return Status;
}

NTSTATUS
XapiSetupPerTitleDriveLetters(
    DWORD dwTitleId,
    LPCWSTR pcszTitleName
    )
{
    NTSTATUS Status;
    OCHAR szTitleId[CCHMAX_HEX_DWORD];

    DwordToStringO(dwTitleId, szTitleId);

    Status = XapiMapLetterToDirectory(&TDrive,
                                      &TitleData,
                                      szTitleId,
                                      TRUE,
                                      NULL,
                                      FALSE);

    if (NT_SUCCESS(Status))
    {
        Status = XapiMapLetterToDirectory(&UDrive,
                                          &UserData,
                                          szTitleId,
                                          TRUE,
                                          pcszTitleName,
                                          FALSE);
    }

    return Status;
}

VOID
XapiBootToDash(
    DWORD dwReason,
    DWORD dwParameter1,
    DWORD dwParameter2
    )
{
    if (DASHBOARD_TITLE_ID != XeImageHeader()->Certificate->TitleID)
    {
        LD_LAUNCH_DASHBOARD LaunchDash;

        ZeroMemory(&LaunchDash, sizeof(LD_LAUNCH_DASHBOARD));

        LaunchDash.dwReason = dwReason;
        LaunchDash.dwContext = 0;
        LaunchDash.dwParameter1 = dwParameter1;
        LaunchDash.dwParameter2 = dwParameter2;

        XLaunchNewImage(NULL, (PLAUNCH_DATA) &LaunchDash);
    }
    else
    {
        //
        // Display Universal Error Message
        //

        HalReturnToFirmware(HalFatalErrorRebootRoutine);
    }
}

//
// Macros to swap the byte order of a USHORT or ULONG at compile time.
//

#define XapiConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define XapiConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))


NTSTATUS
XapiVerifyMediaInDrive(
    VOID
    )
/*++

Routine Description:

    Verifies that the DVD drive has in fact authenticated X2 media.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION Authentication;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &CdDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the CD/DVD device
    //

    status = NtOpenFile(
                &Handle,
                (ACCESS_MASK) GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)XapiConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));

    status = NtDeviceIoControlFile(Handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                   &PassThrough,
                                   sizeof(SCSI_PASS_THROUGH_DIRECT),
                                   NULL,
                                   0);

    NtClose(Handle);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if the DVD-X2 drive thinks that this is a valid CDF header.
    //

    if (Authentication.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    //
    // Check if the DVD-X2 drive already thinks that we're authenticated.
    //

    if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
        (Authentication.AuthenticationPage.Authentication != 0)) {
        return STATUS_SUCCESS;
    }

    //
    // The DVD-X2 drive does not think that we're authenticated.
    //

    return STATUS_UNSUCCESSFUL;
}


VOID
XapiInitProcess(
    VOID
    )
/*++

Routine Description:

    Initializes the Xapi process, loads the title and starts its first thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE ThreadHandle;
    /* ULONG_PTR EntryPoint; */
    ULONG ProcessHeapFlags;
    RTL_HEAP_PARAMETERS HeapParameters;
    HANDLE hthread;
    USHORT CharIndex;
    DWORD dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
    DWORD dwParameter1;
    DWORD dwParameter2 = 0;
    NTSTATUS status;

    // Initialize the auto-power-down feature.
    XapiInitAutoPowerDown();

    RtlZeroMemory( &HeapParameters, sizeof( HeapParameters ) );
    ProcessHeapFlags = HEAP_GROWABLE | HEAP_CLASS_0;
    HeapParameters.Length = sizeof( HeapParameters );

    // Note: there are some more parameters in the image that normal Win32 apps use to
    // modify ProcessHeapFlags and HeapParameters. Here, we just use the heap reserve/commit
    // sizes specified
    XapiProcessHeap = RtlCreateHeap(ProcessHeapFlags,
                                    NULL,
                                    XeImageHeader()->SizeOfHeapReserve,
                                    XeImageHeader()->SizeOfHeapCommit,
                                    NULL,
                                    &HeapParameters);

    if (XapiProcessHeap == NULL)
    {
        dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
        dwParameter1 = XLD_ERROR_INVALID_XBE;
        goto handle_error;
    }

    if ((XeImageHeader()->Certificate->AllowedMediaTypes & XBEIMAGE_MEDIA_TYPE_MEDIA_MASK)
        == XBEIMAGE_MEDIA_TYPE_DVD_X2)
    {
        //
        // This title is only allowed to run on X2 media - double check that the drive
        // has mounted X2 media:
        //

        if (!NT_SUCCESS(XapiVerifyMediaInDrive()))
        {
            //
            // Don't display a dash error message - we want to avoid showing an
            // inapplicable errorduring race conditions where valid media was ejected
            // while this code was verifying the media
            //

            XapiBootToDash(XLD_LAUNCH_DASHBOARD_MAIN_MENU, 0, 0);
            return;
        }
    }

    if (!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK))
    {
        // Get the hard disk ready
        if (!NT_SUCCESS(XapiValidateDiskPartition((POBJECT_STRING) &MainVol)))
        {
            dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
            dwParameter1 = XLD_ERROR_INVALID_HARD_DISK;
            goto handle_error;
        }
    }

    // Give the DVD/CD drive a drive letter
    if (!NT_SUCCESS(status = IoCreateSymbolicLink((POBJECT_STRING) &DDrive,
                                                  (POBJECT_STRING) &CdDevice)))
    {
        XDBGWRN("XAPI",
                "The D: drive is not assigned to the CD/DVD device - error 0x%08x",
                status);

        //
        // Devkits will tend to already have the D: drive assigned, so we'll ignore
        // this error, but reboot to the dash in all other cases...
        //

        if (STATUS_OBJECT_NAME_COLLISION != status)
        {
            dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
            dwParameter1 = XLD_ERROR_INVALID_XBE;
            goto handle_error;
        }
    }

    if ((!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK)) &&
        (!(XeImageHeader()->InitFlags & XINIT_DONT_MODIFY_HARD_DISK)))
    {
        // After we've initialized everything, start the process
        if (!NT_SUCCESS(status = XapiSetupPerTitleDriveLetters(
                XeImageHeader()->Certificate->TitleID,
                XeImageHeader()->Certificate->TitleName)))
        {
            XDBGWRN("XAPI", "Could not set up per-title drive letters");

            if (STATUS_DISK_FULL == status)
            {
                dwReason = XLD_LAUNCH_DASHBOARD_MEMORY;
                dwParameter1 = (DWORD) 'T'; // drive letter
                dwParameter2 = 16; // blocks needed
            }
            else
            {
                dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
                dwParameter1 = XLD_ERROR_INVALID_HARD_DISK;
            }
            goto handle_error;
        }
    }

    if ((!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK)) &&
        (XeImageHeader()->InitFlags & XINIT_MOUNT_UTILITY_DRIVE))
    {
        if (!XMountUtilityDrive(XeImageHeader()->InitFlags & XINIT_FORMAT_UTILITY_DRIVE))
        {
            XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR,
                           XLD_ERROR_INVALID_HARD_DISK,
                           0);
        }
    }

    //
    // Check to see if parental control settings should prevent this title from
    // running on this box
    //

    if (XeImageHeader()->Certificate->GameRatings < XGetParentalControlSetting())
    {
        XDBGWRN("XAPI", "The box's parental control setting prohibits this title from starting");
        XDBGWRN("XAPI", "Go to the Xbox dashboard to change the box's parental control setting");

        dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
        dwParameter1 = XLD_ERROR_XBE_PARENTAL_CONTROL;
        dwParameter2 = XeImageHeader()->Certificate->GameRatings;
        goto handle_error;
    }

    XDBGTRC("XAPI", "InitProcess: SizeOfStack=%d", XeImageHeader()->SizeOfStackCommit);

handle_error:
    if (XLD_LAUNCH_DASHBOARD_MAIN_MENU != dwReason)
    {
        XapiBootToDash(dwReason,
                       dwParameter1,
                       dwParameter2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\dll\xapi0.c ===
#include "dllp.h"
#include <xcrypt.h>
#include "dm.h"

extern ULONG XapiTlsSize;

void _cinit(void);
void _rtinit(void);

int __cdecl main(int argc, ...);

DWORD WINAPI mainXapiStartup(
    LPVOID lpvParameter
    )
/*++

Routine Description:

    Starting point for the app's first thread

Arguments:

    lpvParameter - Unused.

Return Value:

    Returns the exit code of the app, it turns into the exit code of the thread.

--*/
{
    XapiInitProcess();

    {
        /* Tell the debugger where some of our data is*/
        PDMXAPI pdmxapi;
        pdmxapi = DmGetCurrentXapi();
        if(pdmxapi) {
            extern __declspec(thread) DWORD XapiLastErrorCode;
            pdmxapi->LastErrorTlsOff = (ULONG_PTR)&XapiLastErrorCode -
                (ULONG_PTR)KeGetCurrentThread()->TlsData;
            pdmxapi->XapiStarted = TRUE;
        }
    }

    _rtinit();
    _cinit();

    main(
           0, // argc
           NULL, // argv
           NULL // envp
         );

    RIP("Main thread should not return.");

    XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR, XLD_ERROR_INVALID_XBE, 0);

    return STATUS_SUCCESS;
}

VOID __cdecl mainCRTStartup(
    VOID
    )
/*++

Routine Description:

    Entrypoint for xapi.dll, initializes api + crt components, launches the
	app

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE hThread;
    PUCHAR EndOfHeaders;
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG MaxSizeOfCertificate;

    /* Verify that the XBE certificate is wholly contained within the signed
     * XBE headers (the kernel only validated the first
     * XBEIMAGE_CERTIFICATE_BASE_SIZEOF bytes.  If it's too big, we truncate
     * the SizeOfCertificate */
    EndOfHeaders = (PUCHAR)XeImageHeader() + XeImageHeader()->SizeOfHeaders;
    Certificate = XeImageHeader()->Certificate;
    MaxSizeOfCertificate = EndOfHeaders - (PUCHAR)Certificate;
    if(MaxSizeOfCertificate < Certificate->SizeOfCertificate)
        Certificate->SizeOfCertificate = MaxSizeOfCertificate;

    /* Set the TLS index, if we have TLS */
    XapiTlsSize = (_tls_used.EndAddressOfRawData -
        _tls_used.StartAddressOfRawData) + _tls_used.SizeOfZeroFill;
    /* The base of the TLS section must be 16-byte aligned.  We know
     * that fs:StackBase is 16-byte aligned, ensuring that TlsSize is
     * 16-byte aligned is sufficient */
    XapiTlsSize = (XapiTlsSize + 15) & ~15;
    /* Add four bytes for the index pointer */
    XapiTlsSize += 4;
    *(PULONG)(_tls_used.AddressOfIndex) = (int)XapiTlsSize / -4;

    // Create the app's primary thread
    hThread = CreateThread(
                            NULL,
                            0,
                            mainXapiStartup,
                            NULL,
                            0,
                            NULL
                          );

    if (NULL == hThread)
    {
        XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR, XLD_ERROR_INVALID_XBE, 0);
    }

    CloseHandle(hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\inc\xapip.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    xapip.h

Abstract:

    Contains common precompiled headers for kernel-mode
    Win32-equivalents for xbox

--*/

#ifndef _XAPIP_
#define _XAPIP_

//  Disable DECLSPEC_IMPORT decoration of locally implemented APIs.
#define _KERNEL32_
#define _USER32_
#define _GDI32_
#define _WINMM_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include "ntos.h"
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <xtl.h>
#include <xdbg.h>
#include <xapidrv.h>
#include <ldr.h>
#include <xbeimage.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern const IMAGE_TLS_DIRECTORY _tls_used;
extern ULONG _tls_index;

//
// Default process heap handle.
//

extern HANDLE XapiProcessHeap;

//
// General critical section used to guard XAPI data structures.
//

extern RTL_CRITICAL_SECTION XapiProcessLock;

#define XapiAcquireProcessLock() RtlEnterCriticalSection(&XapiProcessLock)
#define XapiReleaseProcessLock() RtlLeaveCriticalSection(&XapiProcessLock)

typedef struct _X_CACHE_DB_ENTRY
{
    DWORD    dwTitleId;
    ULONG    nCacheIndex;
    BOOL     fUsed;
} X_CACHE_DB_ENTRY, *PX_CACHE_DB_ENTRY;


FORCEINLINE BOOL XapiIsXapiThread()
{
    return (KeGetCurrentIrql() < DISPATCH_LEVEL &&
        KeGetCurrentThread()->TlsData != NULL);
}

//
// Prototypes
//

VOID
XapiInitProcess(
    VOID
    );

VOID
XapiBootToDash(
    DWORD dwReason,
    DWORD dwParameter1,
    DWORD dwParameter2
    );

BOOL
WINAPI
XapiFormatFATVolume(
    IN POBJECT_STRING pcVolume
    );

BOOL
WINAPI
XapiFormatFATVolumeEx(
    IN POBJECT_STRING pcVolume,
    IN ULONG BytesPerCluster
    );

NTSTATUS
XapiGetCachePartitions(
    IN PX_CACHE_DB_ENTRY pCacheEntriesBuffer,
    IN UINT cbBufferSize,
    OUT PDWORD pdwNumCacheEntries
    );

VOID
XapiDeleteCachePartition(
    IN DWORD dwTitleId
    );

NTSTATUS
XapiValidateDiskPartition(
    POBJECT_STRING PartitionName
    );

NTSTATUS
XapiValidateDiskPartitionEx(
    POBJECT_STRING PartitionName,
    ULONG BytesPerCluster
    );

NTSTATUS
XapiMapLetterToDirectory(
    PCOBJECT_STRING pcDriveString,
    PCOBJECT_STRING pcPathString,
    PCOSTR pcszTitleId,
    BOOL fCreateDirectory,
    LPCWSTR pcszTitleName,
    BOOL fUpdateTimestamp
    );

BOOL
XapiDeleteValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag
    );

void
XapiInitAutoPowerDown();

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#define DwordToStringO(dword, dwordstr) \
{ \
    soprintf(dwordstr, OTEXT("%08lx"), dword); \
}

#define CCHMAX_HEX_DWORD 9


//
//  Exported by MU driver
//  used only by XAPI.
//
NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING  DeviceName
    );

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

#ifdef DBG
extern ULONG MU_MaxUserDevices;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _XAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\inc\xfiber.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xfiber.h

Abstract:

    This module defines fiber structures

--*/

#ifndef _XFIBER_H
#define _XFIBER_H

//
// Structure to hold the per fiber instance data.
//

typedef struct _XFIBER {
    PVOID FiberData;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID KernelStack;
} XFIBER, *PXFIBER;

#endif // _XFIBER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\inc\xapiver.h ===
#include <xboxverp.h>

#pragma comment(linker, "/include:_XboxKrnlBuildNumber")

#pragma data_seg(".XBLD$A")
#ifdef XAPILIBP

#if DBG
#pragma comment(linker, "/include:_XapiBuildNumberPD")
__declspec(selectany) USHORT XapiBuildNumberPD[8] = { 'AX', 'IP', 'BL', 'DP',
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_XapiBuildNumberP")
__declspec(selectany) USHORT XapiBuildNumberP[8] = { 'AX', 'IP', 'BL', 'P',
    VER_PRODUCTVERSION
#endif // DBG

#else  // XAPILIBP

#if DBG
#pragma comment(linker, "/include:_XapiBuildNumberD")
__declspec(selectany) USHORT XapiBuildNumberD[8] = { 'AX', 'IP', 'IL', 'DB',
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_XapiBuildNumber")
__declspec(selectany) USHORT XapiBuildNumber[8] = { 'AX', 'IP', 'IL', 'B',
    VER_PRODUCTVERSION | 0x4000
#endif // DBG

#endif // XAPILIBP
};
#pragma comment(linker, "/SECTION:.XBLD,D")
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\charconv.c ===
#include "basedll.h"

LPSTR
WINAPI
CharUpperA(
    LPSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlUpperChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPSTR)RtlUpperChar((CHAR)psz);
    }
}

LPSTR
WINAPI
CharLowerA(
    LPSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlLowerChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPSTR)RtlLowerChar((CHAR)psz);
    }
}

LPWSTR
WINAPI
CharUpperW(
    LPWSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPWSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlUpcaseUnicodeChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPWSTR)RtlUpcaseUnicodeChar((WCHAR)psz);
    }
}

LPWSTR
WINAPI
CharLowerW(
    LPWSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPWSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlDowncaseUnicodeChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPWSTR)RtlDowncaseUnicodeChar((WCHAR)psz);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\cancelio.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    cancelio.c

Abstract:

    This module implements the Win32 CancelIo service.

--*/

#include "basedll.h"
#pragma hdrstop
#include <idexchan.h>

VOID
XapiDpcForCancelIo(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PLIST_ENTRY CancelListHead;
    PLIST_ENTRY NextListEntry;
    PIRP Irp;

    CancelListHead = (PLIST_ENTRY)DeferredContext;

    //
    // Run through the list of IRPs to be canceled.
    //

    NextListEntry = CancelListHead->Flink;

    while (NextListEntry != CancelListHead) {

        Irp = CONTAINING_RECORD(NextListEntry, IRP, Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        NextListEntry = NextListEntry->Flink;

        Irp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}

BOOL
WINAPI
CancelIo(
    HANDLE hFile
    )
/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        GetLastError.

--*/
{
    LIST_ENTRY CancelListHead;
    NTSTATUS status;
    PFILE_OBJECT FileObject;
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PIRP Irp;
    KDPC WorkerDpc;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    InitializeListHead(&CancelListHead);

    //
    // Reference the file object.
    //

    status = ObReferenceObjectByHandle(hFile, IoFileObjectType,
        (PVOID*)&FileObject);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Scan through the IDEX device queue for any pending IRPs that originated
    // from the supplied file object.  Synchronize with the IDEX channel
    // dispatcher by raising to DPC level.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    NextListEntry = IdexChannelObject->DeviceQueue.DeviceListHead.Flink;

    while (NextListEntry != &IdexChannelObject->DeviceQueue.DeviceListHead) {

        Irp = CONTAINING_RECORD(NextListEntry, IRP, Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        NextListEntry = NextListEntry->Flink;

        if ((Irp->Tail.Overlay.OriginalFileObject == FileObject) &&
            ((Irp->Flags & IRP_NO_CANCELIO) == 0)) {
            RemoveEntryList(&Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
            InsertTailList(&CancelListHead, &Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        }
    }

    KeLowerIrql(OldIrql);

    //
    // If there are any IRPs that need to be canceled, then do so from a worker
    // DPC.  This is done for two reasons.  First, for packets marked as "must
    // complete" using IoMarkIrpMustComplete, IoCompleteRequest must be called
    // at DPC level.  Second, if the number of "must complete" packets reach
    // zero and a shutdown request is pending, then the kernel routine
    // HalMustCompletePacketsFinished expects to be called from a DPC stack, not
    // an arbitrary thread stack.
    //

    if (!IsListEmpty(&CancelListHead)) {
        KeInitializeDpc(&WorkerDpc, XapiDpcForCancelIo, &CancelListHead);
        KeInsertQueueDpc(&WorkerDpc, NULL, NULL);
    }

    //
    // Dereference the file object.
    //

    ObDereferenceObject(FileObject);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\inc\xmeta.h ===
#pragma once

static const OCHAR g_cszSaveMetaFileName[] = OTEXT("\\SaveMeta.xbx");
static const int   g_cchSaveMetaFileName   = ARRAYSIZE(g_cszSaveMetaFileName) - 1;

static const OCHAR g_cszTitleMetaFileName[] = OTEXT("\\TitleMeta.xbx");
static const int   g_cchTitleMetaFileName   = ARRAYSIZE(g_cszTitleMetaFileName) - 1;

static const OCHAR g_cszTitleImageFileName[] = OTEXT("\\TitleImage.xbx");
static const int   g_cchTitleImageFileName   = ARRAYSIZE(g_cszTitleImageFileName) - 1;

static const OCHAR g_cszSaveImageFileName[] = OTEXT("\\SaveImage.xbx");
static const int   g_cchSaveImageFileName   = ARRAYSIZE(g_cszSaveImageFileName) - 1;

static const OCHAR g_cszContentMetaFileName[] = OTEXT("\\ContentMeta.xbx");
static const int   g_cchContentMetaFileName   = ARRAYSIZE(g_cszContentMetaFileName) - 1;

static const WCHAR g_cszNameTag[] = L"Name";
#define g_cchNameTag (ARRAYSIZE(g_cszNameTag) - 1)

static const WCHAR g_cszTitleNameTag[] = L"TitleName";
#define g_cchTitleNameTag (ARRAYSIZE(g_cszTitleNameTag) - 1)

static const OCHAR g_cszStar[] = OTEXT("*");
static const int   g_cchStar   = ARRAYSIZE(g_cszStar) - 1;

static const OCHAR g_cszContentSearch[] = OTEXT("$C\\*");
static const int   g_cchContentSearch   = ARRAYSIZE(g_cszContentSearch) - 1;

static const OCHAR g_cszContentDir[] = OTEXT("$C\\");
static const int   g_cchContentDir   = ARRAYSIZE(g_cszContentDir) - 1;

static const WCHAR g_cszCRLF[] = L"\r\n";
#define g_cchCRLF (ARRAYSIZE(g_cszCRLF) - 1)

static const WCHAR g_cszNoCopyTrue[] = L"NoCopy=1\r\n";
#define g_cchNoCopyTrue (ARRAYSIZE(g_cszNoCopyTrue) - 1)

static const WCHAR g_chEqual = L'=';
static const WCHAR g_chUnicodeSignature = 0xfeff;

#define MAX_TAGNAME       g_cchTitleNameTag
#define MAX_VALUENAME     MAX_GAMENAME
#define MAX_METADATA_LINE (MAX_TAGNAME + 1 + MAX_VALUENAME + g_cchCRLF + 1)

#define CONTENT_DIR_NAME_LENGTH     (8 + 1 + 8) // 00000000.00000000 (does not include null terminator)
#define CONTENT_DIR_DELIMETER       '.'
#define CONTENT_DIR_DELIMETER_INDEX 8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\compstr.c ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     compstr.c
// Contents: This module implements xCompareString functionality.  Note that xCompareString differs
//           from the Win32 CompareString in that it does not take a locale identifier (unnecessary
//           since Xbox only has one locale.
//
// Author:   Jeff Simon (jeffsim) 16-May-2001
//
// UNDONE:   * Verify CompareStringW vs CompareStringA functionality
//           * How do Kanji and the kanas fit into g_rgdwLoc? Or handled algorithmically?
//           * What is Kanji, hira, kata, ascii sort order?
//           * Move defines to private header file to share them with compstra.c
//
// Copyright Microsoft Corporation
// 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "basedll.h"
#include "winnls.h"
#include <assert.h>
#pragma hdrstop


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Externally defined variables
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Conversion table.  This will be filled in algorithmically by InitLocTable at startup.
// UNDONE-ERR: Currently only big enough to hold the 256 ASCII chars.  Not sure how to handle
//             Kanji and the kanas -- will I add them to the table, or handle them algorithmically?
extern DWORD g_rgdwLoc[256];

extern void InitLocTable();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Internal Defines - specific to this file
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Sort order (lower letters are sorted before upper letters; symbols are sorted before numbers...)
// UNDONE-ERR: Just guessing on the sort order of the non-ascii chars (kanji and kanas).  Guessing
//             that the sort order (first->last) would be "ascii", "kata", "hira", "kanji".
#define COMP_INVALID    0x80000000
#define COMP_KANJI      0x00800000
#define COMP_HIRAGANA   0x00400000
#define COMP_KATAKANA   0x00200000
#define COMP_ULETTER    0x00100000
#define COMP_LLETTER    0x00080000
#define COMP_NUMBER     0x00040000
#define COMP_SYMBOL     0x00020000
#define COMP_WORDSORT   0x00010000

// NEXTCHAR -- Simple define for skipping to the next character in the main CompareString loop
#define NEXTCHAR(x) {  pstr##x++; cch##x--;  }

// SYM_*    -- Defines for handling wordsort special symbols
#define SYM_NONE   0                // No special symbol encountered
#define SYM_1      1                // special symbol already encountered in pstr1
#define SYM_2      2                // special symbol already encountered in pstr2
#define SYM_BOTH   SYM_1 | SYM_2    // special symbol already encountered in both pstr1 and pstr2
#define SYM_1FIRST 4                // pstr1 had the first special symbol encountered
#define SYM_2FIRST 8                // pstr2 had the first special symbol encountered


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Functions
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  xCompareStringA/xCompareStringW
// Purpose:   Xbox-specific version of the CompareString function.  Compares two strings using the
//            global Xbox locale.  Differs from the Win32 version of CompareString in that we don't
//            need to have a locale specified.
// Arguments: dwCmpFlags        -- Comparison-style options
//            pstr1             -- First string to compare
//            cch1              -- Number of characters in first string to examine (-1 for 'all')
//            pstr2             -- First string to compare
//            cch2              -- Number of characters in first string to examine (-1 for 'all')
// Return:    CSTR_LESS_THAN    if pstr1 sorts BEFORE pstr2 (ie  CompareString("a","b") )
//            CSTR_EQUAL        if pstr1 EQUALS pstr2       (ie  CompareString("a","a") )
//            CSTR_GREATER_THAN if pstr1 sorts AFTER pstr2  (ie  CompareString("b","a") )
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef COMPSTRA
int xCompareStringA(DWORD dwCmpFlags, LPCSTR pstr1, int cch1, LPCSTR pstr2, int cch2)
#else
int xCompareStringW(DWORD dwCmpFlags, LPCWSTR pstr1, int cch1, LPCWSTR pstr2, int cch2)
#endif
{
    // w1, w2, dw1, dw2 -- Temp variables
    WORD  w1, w2;
    DWORD dw1, dw2;
    
    // nSymFound        -- Track which string(s) had special symbols, and which came first.
    int nSymFound = SYM_NONE;

    // Avoid repetitive flag masking in the while loop by doing it once here...
    BOOL fWordSort      = !(dwCmpFlags & SORT_STRINGSORT);
    BOOL fIgnoreCase    = dwCmpFlags & NORM_IGNORECASE;
    BOOL fIgnoreSymbols = dwCmpFlags & NORM_IGNORESYMBOLS;

    // s_rgnSymLookup   -- Optimization to remove comparisons from the case where both strings are
    //                     the same length and have word-sort symbols in them
    static int s_rgnSymLookup[] = {CSTR_EQUAL, 0,0,0,0, CSTR_GREATER_THAN, 0, CSTR_LESS_THAN, 0,0,
                                   CSTR_LESS_THAN, CSTR_GREATER_THAN};
    
    // Verify parameters
    if (pstr1 == NULL || pstr2 == NULL || cch1 < -1 || cch2 < -1) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }
    // UNDONE-WARN: I'm not sure if we actually need to handle NORM_IGNORENONSPACE.  If I read MSDN
    //              correctly, we can ignore it, but I need to verify this.

    // UNDONE-ERR: Remove following asserts and handle appropriately
    // assert(!(dwCmpFlags & NORM_IGNOREKANATYPE));    // not handled
    // assert(!(dwCmpFlags & NORM_IGNOREWIDTH));       // not handled


    // Loop until one of the limits is reached (or we return from inside the while loop).
    while (cch1 != 0 && cch2 != 0) {
        // Check if we've reached the end of either string.
        if (*pstr1 == '\0' && *pstr2 == '\0') return s_rgnSymLookup[nSymFound];
        if (*pstr1 == '\0')                   return CSTR_LESS_THAN;
        if (*pstr2 == '\0')                   return CSTR_GREATER_THAN;

        // Both strings still have characters -- do locale-specific comparison of next character
        
        // w1, w2   -- Track the character codes
        // UNDONE-ERR: Need to figure out how I'm going to handle the table for >256 and then
        //             modify these lines appropriately.
#if 1   // def COMPSTRA
        w1 = (WORD)((BYTE)*pstr1);
        w2 = (WORD)((BYTE)*pstr2);
#else
        w1 = (WORD)(*pstr1);
        w2 = (WORD)(*pstr2);
#endif

        // dw1, dw2 -- Track character code or'ed in with bucket describing the 'type' of the char.
        dw1 = g_rgdwLoc[w1];
        dw2 = g_rgdwLoc[w2];

        // UNDONE-OPT: Could pull wordsort check outside of the loop to remove an if per iteration.
        //             Same with fIgnoreSymbols, etc.  However, that particular optimization
        //             (#including a file with particular defines) obfuscates the code quite a bit.

        // Word sort -- some chars are special cased; if we hit one, then skip the character,
        // but track which string(s) have the chars, and which had the first special char in case
        // the strings otherwise match. (ie, correct ordering: "ab-cd", "abce", "a-bce", "ab-ce")
        if (fWordSort) {
            if (dw1 & COMP_WORDSORT) {
                // If both are special symbols, then skip them.  Also need to track if they're
                // different symbols (ie "'" in one string and "-" in the other)
                if (dw2 & COMP_WORDSORT) {
                    if (dw1 < dw2)      nSymFound = SYM_BOTH | SYM_1FIRST;
                    else if (dw1 > dw2) nSymFound = SYM_BOTH | SYM_2FIRST;
                    NEXTCHAR(1); NEXTCHAR(2);
                    continue;
                } else {
                    if (nSymFound == SYM_NONE) nSymFound = SYM_1FIRST;
                    nSymFound |= SYM_1;
                    NEXTCHAR(1);
                    continue;
                }
            }
            if (dw2 & COMP_WORDSORT) {
                if (nSymFound == SYM_NONE) nSymFound = SYM_2FIRST;
                nSymFound |= SYM_2;
                NEXTCHAR(2);
                continue;
            }

            // If here, then neither of the current characters were special symbols.  Continue
            // processing them...
        }
        
        if (fIgnoreSymbols) {
            if (dw1 & COMP_SYMBOL) {
                NEXTCHAR(1);
                continue;
            }
            if (dw2 & COMP_SYMBOL) {
                NEXTCHAR(2);
                continue;
            }
        }

        if (fIgnoreCase) {
            // Handle case-insensitivity.  (+32 converts from upper to lower in our table)
            if (dw1 & COMP_ULETTER)  dw1 = COMP_LLETTER | w1 + 32;
            if (dw2 & COMP_ULETTER)  dw2 = COMP_LLETTER | w2 + 32;
        }

        if (dw1 < dw2) return CSTR_LESS_THAN;
        if (dw1 > dw2) return CSTR_GREATER_THAN;

        // Strings Matched.  Move on to the next character
        NEXTCHAR(1); NEXTCHAR(2);
    }
    
    // If here, then we passed the limit on one of the strings, and both strings are equal so far.
    
    // Check if we hit both limits
    if (cch1 == 0 && cch2 == 0) {
        // If we're in a wordsort search, then we need to take the special symbol state into account.
        // (If we're in a stringsort search, then nSymFound == 0, so we'll return CSTR_EQUAL).
        return s_rgnSymLookup[nSymFound];
    }
    
    // If here, then we hit just one limit, and that string comes second...
    return (cch1 == 0) ? CSTR_GREATER_THAN : CSTR_LESS_THAN;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\basedll.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

--*/

#ifndef _BASEP_
#define _BASEP_

#include "xapip.h"
#include "winbasep.h"
#include "xfiber.h"
#include <xcrypt.h>
#include <stdio.h>
#include <wchar.h>
#include "xapiver.h"

UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

POBJECT_ATTRIBUTES
XapiFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT POBJECT_STRING ObjectName,
    IN PCOSTR lpName
    );

PLARGE_INTEGER
XapiFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
XapiSetLastNTError(
    NTSTATUS Status
    );

NTSTATUS
XapiNukeDirectoryFromHandle(
    HANDLE hDirectory,
    PFILE_DIRECTORY_INFORMATION DirectoryInfo
    );

NTSTATUS
XapiNukeDirectory(
    PCOSTR pszPath
    );

DWORD 
XapiNukeEmptySubdirs(
    IN PCOSTR  pszDrivePath,
    IN PCOSTR  pszPreserveDir OPTIONAL,
    IN BOOLEAN fNukeFiles
    );


#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

extern const OBJECT_STRING XapiHardDisk;

typedef struct _FINDGAME_HANDLE
{
    DWORD dwSignature;
    HANDLE hFindFile;
    int cchRootDir;
    OCHAR szRootDir[MAX_PATH];
} FINDGAME_HANDLE, *PFINDGAME_HANDLE;

#define NUM_NICK_ENTRIES            50

typedef struct _X_NICK_DB_ENTRY
{
    DWORD    dwTitleID;
    WCHAR    szNickname[MAX_NICKNAME];
} X_NICK_DB_ENTRY, *PX_NICK_DB_ENTRY;

typedef struct _FINDNICKNAME_HANDLE
{
    DWORD           dwSignature;
    UINT            uCurIndex;
    BOOL            fThisTitleOnly;
    X_NICK_DB_ENTRY Nicknames[NUM_NICK_ENTRIES];
} FINDNICKNAME_HANDLE, *PFINDNICKNAME_HANDLE;

typedef struct _FINDCONTENT_HANDLE
{
    DWORD dwSignature;
    HANDLE hFindFile;
    DWORD dwFlagFilter;
    int cchRootDir;
    CHAR szRootDir[MAX_PATH];
} FINDCONTENT_HANDLE, *PFINDCONTENT_HANDLE;

typedef struct _XAPI_MU_INFO
{
    OCHAR   DriveWithAltDriveMapped;
    ULONG   MountedDrives;
} XAPI_MU_INFO, *PXAPI_MU_INFO;
extern XAPI_MU_INFO XapiMuInfo;

typedef struct _SNDTRK_ENUMSTATE {

    DWORD Signature;
    UINT Index;
    UINT MaxIndex;
    HANDLE DbHandle;

} SNDTRK_ENUMSTATE, *PSNDTRK_ENUMSTATE;


#define FH_SIG_SAVEGAME 0x53425645
#define FH_SIG_NICKNAME 0x4E49434B
#define FH_SIG_CONTENT 0x434F4E54
#define FH_SIG_SOUNDTRACK 0xBE4BEA00

#define HD_TDATA_DRIVE     OTEXT('T')
#define HD_UDATA_DRIVE     OTEXT('U')
#define HD_ALT_TDATA_DRIVE OTEXT('W')
#define HD_ALT_UDATA_DRIVE OTEXT('X')

#define MU_PORT_MIN     XDEVICE_PORT0
#define MU_PORT_MAX     (XDEVICE_PORT0 + XGetPortCount() - 1)

#define MU_SLOT_MIN     XDEVICE_TOP_SLOT
#define MU_SLOT_MAX     XDEVICE_BOTTOM_SLOT
#define MU_SLOTS        2
#define MU_SLOT_FACTOR  (XDEVICE_BOTTOM_SLOT - XDEVICE_TOP_SLOT)

#define MU_FIRST_DRIVE  OTEXT('F')
#define MU_LAST_DRIVE   (OTEXT('F') + (MU_PORT_MAX * MU_SLOTS) + (MU_SLOTS - 1))

#define MU_DRIVE_LETTER_FROM_PORT_SLOT(p, s) \
            ((OCHAR) (MU_FIRST_DRIVE + ((MU_SLOTS) * ((p) - MU_PORT_MIN)) + ((s / MU_SLOT_FACTOR))))

#define MU_PORT_FROM_DRIVE_LETTER(d) \
            (MU_PORT_MIN + (((d) - MU_FIRST_DRIVE) / MU_SLOTS))

#define MU_SLOT_FROM_DRIVE_LETTER(d) \
            ((MU_SLOT_MIN + (((d) - MU_FIRST_DRIVE) % MU_SLOTS)) * MU_SLOT_FACTOR)

#define MU_SET_MOUNTED(d) (XapiMuInfo.MountedDrives |= (1 << ((d) - MU_FIRST_DRIVE)))
#define MU_CLEAR_MOUNTED(d) (XapiMuInfo.MountedDrives &= ~(1 << ((d) - MU_FIRST_DRIVE)))
#define MU_IS_MOUNTED(d) (XapiMuInfo.MountedDrives&(1 << ((d) - MU_FIRST_DRIVE)))


#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\compstra.c ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     compstra.c
// Contents: CompareStringA functionality.  Contains CompareString table initilization functions
//           and includes the C file that has the actual CompareString function definition (we set
//           a define so that the 'A' functionality gets compiled rather than 'W').
// Author:	 Jeff Simon (jeffsim) 16-May-2001
//
// Copyright Microsoft Corporation
// 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "basedll.h"
#pragma hdrstop


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Internal Defines - specific to this file
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Sort order (lower letters are sorted before upper letters; symbols are sorted before numbers, ...)
// UNDONE-ERR: Just guessing on the sort order of the non-ascii chars (kanji and kanas).  Guessing
//             that the sort order (first->last) would be "ascii", "kata", "hira", "kanji".
#define COMP_INVALID    0x80000000
#define COMP_KANJI      0x00800000
#define COMP_HIRAGANA   0x00400000
#define COMP_KATAKANA   0x00200000
#define COMP_ULETTER    0x00100000
#define COMP_LLETTER    0x00080000
#define COMP_NUMBER     0x00040000
#define COMP_SYMBOL     0x00020000
#define COMP_WORDSORT   0x00010000


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Global variables
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Conversion table.  This will be filled in algorithmically by InitLocTable at startup.
// UNDONE-ERR: Currently only big enough to hold the 256 ASCII chars.  Not sure how to handle
//             Kanji and the kanas -- will I add them to the table, or handle them algorithmically?
DWORD g_rgdwLoc[256] = {
    COMP_INVALID |   0, COMP_INVALID |   1, COMP_INVALID |   2, COMP_INVALID |   3, // 
    COMP_INVALID |   4, COMP_INVALID |   5, COMP_INVALID |   6, COMP_INVALID |   7, // 
    COMP_INVALID |   8, COMP_INVALID |   9, COMP_INVALID |  10, COMP_INVALID |  11, // 
    COMP_INVALID |  12, COMP_INVALID |  13, COMP_INVALID |  14, COMP_INVALID |  15, // 
    COMP_INVALID |  16, COMP_INVALID |  17, COMP_INVALID |  18, COMP_INVALID |  19, // 
    COMP_INVALID |  20, COMP_INVALID |  21, COMP_INVALID |  22, COMP_INVALID |  23, // 
    COMP_INVALID |  24, COMP_INVALID |  25, COMP_INVALID |  26, COMP_INVALID |  27, // 
    COMP_INVALID |  28, COMP_INVALID |  29, COMP_INVALID |  30, COMP_INVALID |  31, // 

    COMP_SYMBOL  |  32, COMP_SYMBOL  |  33, COMP_SYMBOL  |  34, COMP_SYMBOL  |  35, //  !"#
    COMP_SYMBOL  |  36, COMP_SYMBOL  |  37, COMP_SYMBOL  |  38, COMP_SYMBOL  |  39, // $%&'
    COMP_SYMBOL  |  40, COMP_SYMBOL  |  41, COMP_SYMBOL  |  42, COMP_SYMBOL  |  43, // ()*+
    COMP_SYMBOL  |  44, COMP_SYMBOL  |  45, COMP_SYMBOL  |  45, COMP_SYMBOL  |  47, // ,-./
    COMP_NUMBER  |  48, COMP_NUMBER  |  49, COMP_NUMBER  |  50, COMP_NUMBER  |  51, // 0123
    COMP_NUMBER  |  52, COMP_NUMBER  |  53, COMP_NUMBER  |  54, COMP_NUMBER  |  55, // 4567
    COMP_NUMBER  |  56, COMP_NUMBER  |  57, COMP_SYMBOL  |  58, COMP_SYMBOL  |  59, // 89:;
    COMP_SYMBOL  |  60, COMP_SYMBOL  |  61, COMP_SYMBOL  |  62, COMP_SYMBOL  |  63, // <=>?
    COMP_SYMBOL  |  64, COMP_ULETTER |  65, COMP_ULETTER |  66, COMP_ULETTER |  67, // @ABC
	
    COMP_ULETTER |  68, COMP_ULETTER |  69, COMP_ULETTER |  70, COMP_ULETTER |  71, // DEFG
    COMP_ULETTER |  72, COMP_ULETTER |  73, COMP_ULETTER |  74, COMP_ULETTER |  75, // HIJK
    COMP_ULETTER |  76, COMP_ULETTER |  77, COMP_ULETTER |  78, COMP_ULETTER |  79, // LMNO
    COMP_ULETTER |  80, COMP_ULETTER |  81, COMP_ULETTER |  82, COMP_ULETTER |  83, // PQRS
    COMP_ULETTER |  84, COMP_ULETTER |  85, COMP_ULETTER |  86, COMP_ULETTER |  87, // TUVW
    COMP_ULETTER |  88, COMP_ULETTER |  89, COMP_ULETTER |  90, COMP_SYMBOL  |  91, // XYZ[
    COMP_SYMBOL  |  92, COMP_SYMBOL  |  93, COMP_SYMBOL  |  94, COMP_SYMBOL  |  95, // \]^_
    COMP_SYMBOL  |  96, COMP_LLETTER |  97, COMP_LLETTER |  98, COMP_LLETTER |  99, // `abc

    COMP_LLETTER | 100, COMP_LLETTER | 101, COMP_LLETTER | 102, COMP_LLETTER | 103, // defg
    COMP_LLETTER | 104, COMP_LLETTER | 105, COMP_LLETTER | 106, COMP_LLETTER | 107, // hijk
    COMP_LLETTER | 108, COMP_LLETTER | 109, COMP_LLETTER | 110, COMP_LLETTER | 111, // lmno
    COMP_LLETTER | 112, COMP_LLETTER | 113, COMP_LLETTER | 114, COMP_LLETTER | 115, // pqrs
    COMP_LLETTER | 116, COMP_LLETTER | 117, COMP_LLETTER | 118, COMP_LLETTER | 119, // tuvw
    COMP_LLETTER | 120, COMP_LLETTER | 121, COMP_LLETTER | 122, COMP_SYMBOL  | 123, // xyz{
    COMP_SYMBOL  | 124, COMP_SYMBOL  | 125, COMP_SYMBOL  | 126, COMP_INVALID | 127, // |}~
    COMP_INVALID | 128, COMP_INVALID | 129, COMP_INVALID | 130, COMP_INVALID | 131, // 

    COMP_INVALID | 132, COMP_INVALID | 133, COMP_INVALID | 134, COMP_INVALID | 135, // 
    COMP_INVALID | 136, COMP_INVALID | 137, COMP_INVALID | 138, COMP_INVALID | 139, // 
    COMP_INVALID | 140, COMP_INVALID | 141, COMP_INVALID | 142, COMP_INVALID | 143, // 
    COMP_INVALID | 144, COMP_INVALID | 145, COMP_INVALID | 145, COMP_INVALID | 147, // 
    COMP_INVALID | 148, COMP_INVALID | 149, COMP_INVALID | 150, COMP_INVALID | 151, // 
    COMP_INVALID | 152, COMP_INVALID | 153, COMP_INVALID | 154, COMP_INVALID | 155, // 
    COMP_INVALID | 156, COMP_INVALID | 157, COMP_INVALID | 158, COMP_INVALID | 159, // 
    COMP_INVALID | 160, COMP_SYMBOL  | 161, COMP_SYMBOL  | 162, COMP_SYMBOL  | 163, //  
    COMP_SYMBOL  | 164, COMP_SYMBOL  | 165, COMP_SYMBOL  | 166, COMP_SYMBOL  | 167, // 
	
    COMP_SYMBOL  | 168, COMP_SYMBOL  | 169, COMP_SYMBOL  | 170, COMP_SYMBOL  | 171, // 
    COMP_SYMBOL  | 172, COMP_SYMBOL  | 173, COMP_SYMBOL  | 174, COMP_SYMBOL  | 175, // 
    COMP_SYMBOL  | 176, COMP_SYMBOL  | 177, COMP_SYMBOL  | 178, COMP_SYMBOL  | 179, // 
    COMP_SYMBOL  | 180, COMP_SYMBOL  | 181, COMP_SYMBOL  | 182, COMP_SYMBOL  | 183, // 
    COMP_SYMBOL  | 184, COMP_SYMBOL  | 185, COMP_SYMBOL  | 186, COMP_SYMBOL  | 187, // 
    COMP_SYMBOL  | 188, COMP_SYMBOL  | 189, COMP_SYMBOL  | 190, COMP_SYMBOL  | 191, // 
    COMP_ULETTER | 192, COMP_ULETTER | 193, COMP_ULETTER | 194, COMP_ULETTER | 195, // 
    COMP_ULETTER | 196, COMP_ULETTER | 197, COMP_ULETTER | 198, COMP_ULETTER | 199, // 

    COMP_ULETTER | 200, COMP_ULETTER | 201, COMP_ULETTER | 202, COMP_ULETTER | 203, // 
    COMP_ULETTER | 204, COMP_ULETTER | 205, COMP_ULETTER | 206, COMP_ULETTER | 207, // 
    COMP_ULETTER | 208, COMP_ULETTER | 209, COMP_ULETTER | 210, COMP_ULETTER | 211, // 
    COMP_ULETTER | 212, COMP_ULETTER | 213, COMP_ULETTER | 214, COMP_SYMBOL  | 215, // 
    COMP_ULETTER | 216, COMP_ULETTER | 217, COMP_ULETTER | 218, COMP_ULETTER | 219, // 
    COMP_ULETTER | 220, COMP_ULETTER | 221, COMP_ULETTER | 222, COMP_ULETTER | 223, // 
    COMP_LLETTER | 224, COMP_LLETTER | 225, COMP_LLETTER | 226, COMP_LLETTER | 227, // 
    COMP_LLETTER | 228, COMP_LLETTER | 229, COMP_LLETTER | 230, COMP_LLETTER | 231, // 

    COMP_LLETTER | 232, COMP_LLETTER | 233, COMP_LLETTER | 234, COMP_LLETTER | 235, // 
    COMP_LLETTER | 236, COMP_LLETTER | 237, COMP_LLETTER | 238, COMP_LLETTER | 239, // 
    COMP_LLETTER | 240, COMP_LLETTER | 241, COMP_LLETTER | 242, COMP_LLETTER | 243, // 
    COMP_LLETTER | 244, COMP_LLETTER | 245, COMP_LLETTER | 245, COMP_SYMBOL  | 247, // 
    COMP_LLETTER | 248, COMP_LLETTER | 249, COMP_LLETTER | 250, COMP_LLETTER | 251, // 
    COMP_LLETTER | 252, COMP_LLETTER | 253, COMP_LLETTER | 254, COMP_LLETTER | 255, // 
};

// Now include the C file that actually defines CompareStringA.  Define 'COMPSTRA' first so that
// the file knows that we want CompareStringA, and not CompareStringW
#define COMPSTRA
#include "compstr.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\dir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements Win32 Directory functions.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
APIENTRY
CreateDirectory(
    PCOSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectory.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.

    This call is similar to DOS (int 21h, function 39h) and OS/2's
    DosCreateDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - Ignored on xbox.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitObjectString(&FileName, lpPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_CREATE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
RemoveDirectory(
    PCOSTR lpPathName
    )

/*++

Routine Description:

    An existing directory can be removed using RemoveDirectory.

    This API causes a directory with the specified pathname to be
    deleted.  The directory must be empty before this call can succeed.

    This call is similar to DOS (int 21h, function 3Ah) and OS/2's
    DosDeleteDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be removed.
        The path must specify an empty directory to which the caller has
        delete access.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;

    RtlInitObjectString(&FileName, lpPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the directory for delete access.
    //

    Status = NtOpenFile(
                 &Handle,
                 DELETE | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\debug.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements Win32 Debug APIs

--*/

#include "basedll.h"
#include <stdio.h>
#pragma hdrstop

VOID
APIENTRY
OutputDebugStringW(
    LPCWSTR lpOutputString
    )

/*++

Routine Description:

    UNICODE thunk to OutputDebugStringA

--*/

{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RtlInitUnicodeString(&UnicodeString,lpOutputString);
    Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if ( !NT_SUCCESS(Status) ) {
        AnsiString.Buffer = "";
        }
    OutputDebugStringA(AnsiString.Buffer);
    if ( NT_SUCCESS(Status) ) {
        RtlFreeAnsiString(&AnsiString);
        }
}

VOID
APIENTRY
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )

/*++

Routine Description:

    This function allows an application to send a string to its debugger
    for display.  If the application is not being debugged, but the
    system debugger is active, the system debugger displays the string.
    Otherwise, this function has no effect.

Arguments:

    lpOutputString - Supplies the address of the debug string to be sent
        to the debugger.

Return Value:

    None.

--*/

{
    ANSI_STRING ast, *past;

    ast.Buffer = (LPSTR)lpOutputString;
    ast.Length = (USHORT)strlen(ast.Buffer);
    ast.MaximumLength = ast.Length+1;
    _asm {
        lea ecx, ast
        mov eax, BREAKPOINT_PRINT
        int 2dh
        int 3
    }
}

#if DBG

ULONG XDebugOutLevel = XDBG_WARNING;
ULONG XDebugBrkLevel = XDBG_ERROR;

PSTR XDebugLevels[] =
{
    "!!!",
    "ERR",
    "WRN",
    "TRC",
    "ENT",
    "EXT",
};

VOID
XDBGAPI
vXDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, va_list arglist)
{
    CHAR string[MAX_PATH];

    if (Level <= XDebugOutLevel)
    {
        _vsnprintf(string, sizeof(string), Format, arglist);
        DbgPrint("%s[%s]: %s\n", (Level <= XDBG_EXIT) ? XDebugLevels[Level] : "???", Module, string);
        if (Level <= XDebugBrkLevel)
        {
            _asm { int 3 };
        }
    }
}

VOID
XDBGAPIV
XDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(Level, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ERROR, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugWarning(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_WARNING, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugTrace(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_TRACE, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugEntry(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ENTRY, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugExit(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_EXIT, Module, Format, arglist);
    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\datetime.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    datetime.c

Abstract:

    This module implements Win32 time of day functions

Author:

    Mark Lucovsky (markl) 08-Oct-1990

Revision History:

--*/

#include "basedll.h"
#include <xboxp.h>
#include "xconfig.h"

VOID XapipGetTimeZoneBias(LARGE_INTEGER* bias);

#ifndef XAPILIBP

BOOLEAN
RtlpCutoverTimeToSystemTime(
    PSYSTEMTIME CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    )
{
    SYSTEMTIME stCurrentSystemTime;

    //
    // Get the current system time
    //

    FileTimeToSystemTime((PFILETIME) CurrentSystemTime, &stCurrentSystemTime);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an abosulte time
    //

    if ( CutoverTime->wYear ) {

        //
        // Convert this to a time value and make sure it
        // is greater than the current system time
        //

        if ( !SystemTimeToFileTime(CutoverTime,(PFILETIME) SystemTime) ) {
            return FALSE;
            }

        if (SystemTime->QuadPart < CurrentSystemTime->QuadPart) {
            return FALSE;
            }
        return TRUE;
        }
    else {

        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->wDay;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->wDayOfWeek;
        TargetMonth = CutoverTime->wMonth;
        MonthMatches = FALSE;
        if ( !ThisYear ) {
            if ( TargetMonth < stCurrentSystemTime.wMonth ) {
                TargetYear = stCurrentSystemTime.wYear + 1;
                }
            else if ( TargetMonth > stCurrentSystemTime.wMonth ) {
                TargetYear = stCurrentSystemTime.wYear;
                }
            else {
                TargetYear = stCurrentSystemTime.wYear;
                MonthMatches = TRUE;
                }
            }
        else {
            TargetYear = stCurrentSystemTime.wYear;
            }
try_next_year:
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->wHour;
        WorkingTimeField.Minute = CutoverTime->wMinute;
        WorkingTimeField.Second = CutoverTime->wSecond;
        WorkingTimeField.Milliseconds = CutoverTime->wMilliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < stCurrentSystemTime.wDay ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == stCurrentSystemTime.wDay ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
}

__inline VOID
XboxTimeZoneDateToSystemTime(
    const XBOX_TIMEZONE_DATE* tzdate,
    SYSTEMTIME* systime
    )
{
    memset(systime, 0, sizeof(*systime));
    systime->wMonth = tzdate->Month;
    systime->wDay = tzdate->Day;
    systime->wDayOfWeek = tzdate->DayOfWeek;
    systime->wHour = tzdate->Hour;
}

DWORD
WINAPI
XapipQueryTimeZoneInformation(
    OUT PTIME_ZONE_INFORMATION TimeZoneInformation,
    OUT PBOOL pfUseDST
    )
{
    ULONG ulType;
    DWORD dwRet;
    UCHAR buf[EEPROM_TOTAL_MEMORY_SIZE];
    XBOX_USER_SETTINGS* config;

    dwRet = XQueryValue(XC_MAX_OS, &ulType, buf, sizeof(buf), NULL);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;

    config = (XBOX_USER_SETTINGS*) buf;
    TimeZoneInformation->Bias = config->TimeZoneBias;
    
    ASSERT(ARRAYSIZE(TimeZoneInformation->StandardName) >= (XC_TZNAMELEN + 1));
    XboxTimeZoneNameToWstr(config->TimeZoneStdName, TimeZoneInformation->StandardName);
    XboxTimeZoneNameToWstr(config->TimeZoneDltName, TimeZoneInformation->DaylightName);

    XboxTimeZoneDateToSystemTime(&config->TimeZoneStdDate, &TimeZoneInformation->StandardDate);
    XboxTimeZoneDateToSystemTime(&config->TimeZoneDltDate, &TimeZoneInformation->DaylightDate);

    TimeZoneInformation->StandardBias = config->TimeZoneStdBias;
    TimeZoneInformation->DaylightBias = config->TimeZoneDltBias;

    if (pfUseDST)
    {
        *pfUseDST = !(config->MiscFlags & XC_MISC_FLAG_DONT_USE_DST);
    }
    
    return ERROR_SUCCESS;
}

BOOL
WINAPI
XapipUseDaylightSavingTime()
{
    ULONG type, size;
    DWORD flags;

    return XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size) != ERROR_SUCCESS ||
           !(flags & XC_MISC_FLAG_DONT_USE_DST);
}

VOID XapipGetTimeZoneBias(LARGE_INTEGER* bias)
{
    TIME_ZONE_INFORMATION tzinfo;
    LONG tzbias;
    
    switch (GetTimeZoneInformation(&tzinfo)) {
    case TIME_ZONE_ID_UNKNOWN:
        tzbias = tzinfo.Bias;
        break;
    case TIME_ZONE_ID_STANDARD:
        tzbias = tzinfo.Bias + tzinfo.StandardBias;
        break;
    case TIME_ZONE_ID_DAYLIGHT:
        tzbias = tzinfo.Bias + tzinfo.DaylightBias;
        break;
    default:
        tzbias = 0;
        break;
    }

    bias->QuadPart = Int32x32To64(tzbias * 60, 10000000);
}

VOID
WINAPI
GetLocalTime(
    LPSYSTEMTIME lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be returned using
    GetLocalTime.

Arguments:

    lpLocalTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER Bias;
    TIME_FIELDS TimeFields;

    KeQuerySystemTime(&SystemTime);

    XapipGetTimeZoneBias(&Bias);
    LocalTime.QuadPart = SystemTime.QuadPart - Bias.QuadPart;

    RtlTimeToTimeFields(&LocalTime,&TimeFields);

    lpLocalTime->wYear         = TimeFields.Year        ;
    lpLocalTime->wMonth        = TimeFields.Month       ;
    lpLocalTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpLocalTime->wDay          = TimeFields.Day         ;
    lpLocalTime->wHour         = TimeFields.Hour        ;
    lpLocalTime->wMinute       = TimeFields.Minute      ;
    lpLocalTime->wSecond       = TimeFields.Second      ;
    lpLocalTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTime.

Arguments:

    lpSystemTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;

    KeQuerySystemTime(&SystemTime);

    RtlTimeToTimeFields(&SystemTime,&TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
}


DWORD
GetTickCount(
    VOID
    )

/*++

Routine Description:

    Win32 systems implement a free-running millisecond counter.  The
    value of this counter can be read using GetTickCount.

Arguments:

    None.

Return Value:

    This function returns the number of milliseconds that have elapsed
    since the system was started. If the system has been running for
    a long time, it is possible that the count will repeat. The value of
    the counter is accurate within 55 milliseconds.

--*/

{
    return (DWORD)NtGetTickCount();
}

BOOL
APIENTRY
FileTimeToSystemTime(
    CONST FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    This functions converts a 64-bit file time value to a time in system
    time format.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to the system
        date and time format.

    lpSystemTime - Returns the converted value of the 64-bit file time.

Return Value:

    TRUE - The 64-bit file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER FileTime;
    TIME_FIELDS TimeFields;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

#if DBG
    if (FileTime.QuadPart < 0)
    {
        RIP("FileTimeToSystemTime() invalid parameter (lpFileTime)");
    }
#endif // DBG

    RtlTimeToTimeFields(&FileTime, &TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;

    return TRUE;
}


BOOL
APIENTRY
SystemTimeToFileTime(
    CONST SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a system time value into a 64-bit file time.

Arguments:

    lpSystemTime - Supplies the time that is to be converted into
        the 64-bit file time format.  The wDayOfWeek field is ignored.

    lpFileTime - Returns the 64-bit file time representation of
        lpSystemTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
    else {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
}

BOOL
WINAPI
FileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )

/*++

Routine Description:

    This functions converts a UTC based file time to a local file time.

Arguments:

    lpFileTime - Supplies the UTC based file time that is to be
        converted into a local file time

    lpLocalFileTime - Returns the 64-bit local file time representation of
        lpFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    LocalFileTime.QuadPart = FileTime.QuadPart - Bias.QuadPart;

    lpLocalFileTime->dwLowDateTime = LocalFileTime.LowPart;
    lpLocalFileTime->dwHighDateTime = LocalFileTime.HighPart;

    return TRUE;
}

BOOL
WINAPI
LocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a local file time to a UTC based file time.

Arguments:

    lpLocalFileTime - Supplies the local file time that is to be
        converted into a UTC based file time

    lpFileTime - Returns the 64-bit UTC based file time representation of
        lpLocalFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);

    LocalFileTime.LowPart = lpLocalFileTime->dwLowDateTime;
    LocalFileTime.HighPart = lpLocalFileTime->dwHighDateTime;

    FileTime.QuadPart = LocalFileTime.QuadPart + Bias.QuadPart;

    lpFileTime->dwLowDateTime = FileTime.LowPart;
    lpFileTime->dwHighDateTime = FileTime.HighPart;

    return TRUE;
}

LONG
APIENTRY
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    )

/*++

Routine Description:

    This function compares two 64-bit file times.

Arguments:

    lpFileTime1 - pointer to a 64-bit file time.

    lpFileTime2 - pointer to a 64-bit file time.

Return Value:

    -1 - *lpFileTime1 <  *lpFileTime2

     0 - *lpFileTime1 == *lpFileTime2

    +1 - *lpFileTime1 >  *lpFileTime2

--*/

{
    ULARGE_INTEGER FileTime1;
    ULARGE_INTEGER FileTime2;

    FileTime1.LowPart = lpFileTime1->dwLowDateTime;
    FileTime1.HighPart = lpFileTime1->dwHighDateTime;
    FileTime2.LowPart = lpFileTime2->dwLowDateTime;
    FileTime2.HighPart = lpFileTime2->dwHighDateTime;
    if (FileTime1.QuadPart < FileTime2.QuadPart) {
        return( -1 );
        }
    else
    if (FileTime1.QuadPart > FileTime2.QuadPart) {
        return( 1 );
        }
    else {
        return( 0 );
        }
}

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    DWORD dwStatus;
    DWORD dwRet = TIME_ZONE_ID_UNKNOWN;
    BOOL fUseDST;
    LARGE_INTEGER StandardTime, DaylightTime, CurrentUniversalTime;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    //
    // get the timezone data from the system
    //

    dwStatus = XapipQueryTimeZoneInformation(lpTimeZoneInformation, &fUseDST);
    if (ERROR_SUCCESS != dwStatus)
    {
        SetLastError(dwStatus);
        return 0xffffffff;
    }

    if (!fUseDST)
    {
        //
        // If we're not using daylight saving time, clear all fields related to
        // daylight savings time
        //
        
        lpTimeZoneInformation->StandardBias = 0;
        RtlZeroMemory(&(lpTimeZoneInformation->StandardDate),
                      sizeof(lpTimeZoneInformation->StandardDate));
        
        lpTimeZoneInformation->DaylightBias = 0;
        RtlZeroMemory(&(lpTimeZoneInformation->DaylightDate),
                      sizeof(lpTimeZoneInformation->DaylightDate));
        RtlZeroMemory(lpTimeZoneInformation->DaylightName,
                      sizeof(lpTimeZoneInformation->DaylightName));
    }

    KeQuerySystemTime(&CurrentUniversalTime);

    //
    // Check to see if we have timezone cutover information and if so,
    // compute the cutover dates and compute what our current bias is
    //

    if (lpTimeZoneInformation->StandardDate.wMonth &&
        lpTimeZoneInformation->DaylightDate.wMonth &&
        RtlpCutoverTimeToSystemTime(
                &(lpTimeZoneInformation->StandardDate),
                &StandardTime,
                &CurrentUniversalTime,
                TRUE) &&
        RtlpCutoverTimeToSystemTime(
                &(lpTimeZoneInformation->DaylightDate),
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE))
    {
        //
        // Get the new timezone bias
        //

        NewTimeZoneBias.QuadPart = Int32x32To64(lpTimeZoneInformation->Bias*60, 10000000);
    
        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(lpTimeZoneInformation->StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(lpTimeZoneInformation->DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;
        
        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if (UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart)
        {
            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) )
            {
                dwRet = TIME_ZONE_ID_DAYLIGHT;
            }
            else
            {
                dwRet = TIME_ZONE_ID_STANDARD;
            }
        }
        else
        {
            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart) )
            {
                dwRet = TIME_ZONE_ID_STANDARD;
            }
            else
            {
                dwRet = TIME_ZONE_ID_DAYLIGHT;
            }
        }
    }

    return dwRet;
}

#else  // ! XAPILIBP

__inline VOID
SystemTimeToXboxTimeZoneDate(
    const SYSTEMTIME* systime,
    XBOX_TIMEZONE_DATE* tzdate
    )
{
    ASSERT(systime->wYear == 0);
    tzdate->Month = (BYTE) systime->wMonth;
    tzdate->Day = (BYTE) systime->wDay;
    tzdate->DayOfWeek = (BYTE) systime->wDayOfWeek;
    tzdate->Hour = (BYTE) systime->wHour;
}

DWORD
WINAPI
XapipSetTimeZoneInformation(
    IN PTIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    ULONG ulType, ulSize;
    DWORD dwRet;
    CHAR buf[EEPROM_TOTAL_MEMORY_SIZE];
    XBOX_USER_SETTINGS* config;

    dwRet = XQueryValue(XC_MAX_OS, &ulType, buf, sizeof(buf), &ulSize);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;

    config = (XBOX_USER_SETTINGS*) buf;
    config->TimeZoneBias = TimeZoneInformation->Bias;

    WstrToXboxTimeZoneName(TimeZoneInformation->StandardName, config->TimeZoneStdName);
    WstrToXboxTimeZoneName(TimeZoneInformation->DaylightName, config->TimeZoneDltName);

    SystemTimeToXboxTimeZoneDate(&TimeZoneInformation->StandardDate, &config->TimeZoneStdDate);
    SystemTimeToXboxTimeZoneDate(&TimeZoneInformation->DaylightDate, &config->TimeZoneDltDate);

    config->TimeZoneStdBias = TimeZoneInformation->StandardBias;
    config->TimeZoneDltBias = TimeZoneInformation->DaylightBias;

    return XSetValue(XC_MAX_OS, REG_BINARY, buf, ulSize);
}


BOOL
WINAPI
XapiSetSystemTime(
    CONST SYSTEMTIME *lpSystemTime
    )

/*++

Routine Description:

    The current UTC based system date and time can be set using
    SetSystemTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;

    ReturnValue = TRUE;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&SystemTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {
        NtSetSystemTime(&SystemTime,NULL);
        }

    if ( !ReturnValue ) {
        XapiSetLastNTError(Status);
        }

    return ReturnValue;
}

BOOL
WINAPI
XapiSetLocalTime(
    CONST SYSTEMTIME *lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be set using
    SetLocalTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);
    ReturnValue = TRUE;

    TimeFields.Year         = lpLocalTime->wYear        ;
    TimeFields.Month        = lpLocalTime->wMonth       ;
    TimeFields.Day          = lpLocalTime->wDay         ;
    TimeFields.Hour         = lpLocalTime->wHour        ;
    TimeFields.Minute       = lpLocalTime->wMinute      ;
    TimeFields.Second       = lpLocalTime->wSecond      ;
    TimeFields.Milliseconds = lpLocalTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&LocalTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {

        SystemTime.QuadPart = LocalTime.QuadPart + Bias.QuadPart;
        NtSetSystemTime(&SystemTime,NULL);
        }

    if ( !ReturnValue ) {
        XapiSetLastNTError(Status);
        }

    return ReturnValue;
}

#endif // ! XAPILIBP


// xbox doesn't allow you to set the time (at least, for now)
#if 0
BOOL
WINAPI
SetTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to set timezone parameters into
    their system.  These parameters control the Universal time to Local
    time translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    This API allows the caller to program the current time zone bias,
    and optionally set up the system to automatically sense daylight
    savings time and standard time transitions.

    The timezone bias information is controlled by the
    TIME_ZONE_INFORMATION structure.

    Bias - Supplies the current bias in minutes for local time
        translation on this machine where LocalTime + Bias = UTC.  This
        is a required filed of this structure.

    StandardName - Supplies an optional abbreviation string associated
        with standard time on this system.  This string is uniterpreted
        and is supplied and used only by callers of this API and of
        GetTimeZoneInformation.

    StandardDate - Supplies an optional date and time (UTC) that
        describes the transition into standard time.  A value of 0 in
        the wMonth field tells the system that StandardDate is not
        specified.  If this field is specified, then DaylightDate must
        also be specified.  Additionally, local time translations done
        during the StandardTime range will be done relative to the
        supplied StandardBias value (added to Bias).

        This field supports two date formats. Absolute form specifies and
        exact date and time when standard time begins. In this form, the
        wYear, wMonth, wDay, wHour, wMinute, wSecond, and wMilliseconds
        of the SYSTEMTIME structure are used to specify an exact date.

        Day-in-month time is specified by setting wYear to 0, setting
        wDayOfWeek to an appropriate weekday, and using wDay in the
        range of 1-5 to select the correct day in the month.  Using this
        notation, the first sunday in april may be specified as can be
        the last thursday in october (5 is equal to "the last").

    StandardBias - Supplies an optional bias value to be used during
        local time translations that occur during Standard Time. This
        field is ignored if StandardDate is not supplied.
         This bias value
        is added to the Bias field to form the Bias used during standard
        time. In most time zones, the value of this field is zero.

    DaylightName - Supplies an optional abbreviation string associated
        with daylight savings time on this system.  This string is
        uniterpreted and is supplied and used only by callers of this
        API and of GetTimeZoneInformation.

    DaylightDate - Supplies an optional date and time (UTC) that
        describes the transition into daylight savings time.  A value of
        0 in the wMonth field tells the system that DaylightDate is not
        specified.  If this field is specified, then StandardDate must
        also be specified.  Additionally, local time translations done
        during the DaylightTime range will be done relative to the
        supplied DaylightBias value (added to Bias). The same dat formats
        supported by StandardDate are supported ib DaylightDate.

    DaylightBias - Supplies an optional bias value to be used during
        local time translations that occur during Daylight Savings Time.
        This field is ignored if DaylightDate is not supplied.  This
        bias value is added to the Bias field to form the Bias used
        during daylight time.  In most time zones, the value of this
        field is -60.

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    tzi.Bias            = lpTimeZoneInformation->Bias;
    tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
    tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
    tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

    Status = RtlSetTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    //
    // Refresh the system's concept of time
    //

    NtSetSystemTime(NULL,NULL);

    return TRUE;
}
#endif // 0

// xbox does not support these:
#if 0

BOOL
WINAPI
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to support algorithms that want to synchronize
    the time of day (reported via GetSystemTime and GetLocalTime) with
    another time source using a programmed clock adjustment over a
    period of time.

    To facilitate this, the system computes the time of day by adding a
    value to a time of day counter at a periodic interval.  This API
    allows the caller to obtain the periodic interval (clock interrupt
    rate), and the amount added to the time of day with each interrupt.

    A boolean value is also returned which indicates whether or not this
    time adjustment algorithm is even being used.  A value of TRUE
    indicates that adjustment is not being used.  If this is the case,
    the system may attempt to keep the time of day clock in sync using
    its own internal mechanisms.  This may cause time of day to
    periodicly "jump" to the "correct time".


Arguments:

    lpTimeAdjustment - Returns the number of 100ns units added to the
        time of day counter at each clock interrupt.

    lpTimeIncrement - Returns the clock interrupt rate in 100ns units.

    lpTimeAdjustmentDisabled - Returns an indicator which specifies
        whether or not time adjustment is inabled.  A value of TRUE
        indicates that periodic adjustment is disabled
        (*lpTimeAdjustment == *lpTimeIncrement), AND that the system is
        free to serialize time of day using any mechanism it wants.
        This may cause periodic time jumps as the system serializes time
        of day to the "correct time".  A value of false indicates that
        programmed time adjustment is being used to serialize the time
        of day, and that the system will not interfere with this scheme
        and will not attempt to synchronize time of day on its own.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/
{
    NTSTATUS Status;
    SYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;
    Status = NtQuerySystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        b = FALSE;
        }
    else {
        *lpTimeAdjustment = TimeAdjust.TimeAdjustment;
        *lpTimeIncrement = TimeAdjust.TimeIncrement;
        *lpTimeAdjustmentDisabled = TimeAdjust.Enable;
        b = TRUE;
        }

    return b;
}

BOOL
WINAPI
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to tell the system the parameters it should
    use to periodicaly synchronize time of day with some other source.

    This API supports two modes of operation.

    In the first mode, bTimeAdjustmentDisabled is set to FALSE.  At each
    clock interrupt, the value of dwTimeAdjustment is added to the time
    of day.  The clock interrupt rate may be obtained using
    GetSystemTimeAdjustment, and looking at the returned value of
    lpTimeIncrement.

    In the second mode, bTimeAdjustmentDisabled is set to TRUE.  At each
    clock interrupt, the clock interrupt rate is added to the time of
    day.  The system may also periodically refresh the time of day using
    other internal algorithms.  These may produce "jumps" in time.

    The application must have system-time privilege (the
    SE_SYSTEMTIME_NAME privilege) for this function to succeed.  This
    privilege is disabled by default.  Use the AdjustTokenPrivileges
    function to enable the privilege and again to disable it after the
    time adjustment has been set.

Arguments:

    dwTimeAdjustment - Supplies the value (in 100ns units) that is to be
        added to the time of day at each clock interrupt.

    bTimeAdjustmentDisabled - Supplies a flag which specifies the time
        adjustment mode that the system is to use.  A value of TRUE
        indicates the the system should synchronize time of day using
        its own internal mechanisms.  When this is the case, the value
        of dwTimeAdjustment is ignored.  A value of FALSE indicates that
        the application is in control, and that the value specified by
        dwTimeAdjustment is to be added to the time of day at each clock
        interrupt.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/

{
    NTSTATUS Status;
    SYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;

    b = TRUE;
    TimeAdjust.TimeAdjustment = dwTimeAdjustment;
    TimeAdjust.Enable = (BOOLEAN)bTimeAdjustmentDisabled;
    Status = NtSetSystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust)
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        b = FALSE;
        }

    return b;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    LARGE_INTEGER ComputedLocalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
        }
    else {
        Tzi = lpTimeZoneInformation;
        }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input universal time to NT style time
    //
    if ( !SystemTimeToFileTime(lpUniversalTime,(LPFILETIME)&CurrentUniversalTime) ) {
        return FALSE;
        }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlpCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        if ( !RtlpCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(tzi.StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(tzi.DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

        }
    else {
        TimeZoneBias = NewTimeZoneBias;
        }

    ComputedLocalTime.QuadPart = CurrentUniversalTime.QuadPart - TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedLocalTime,lpLocalTime) ) {
        return FALSE;
        }

    return TRUE;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\fiber.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    fiber.c

Abstract:

    This module implements the Win32 fiber services.

--*/

#include "basedll.h"
#pragma hdrstop
#include "dm.h"

//
// Per thread fiber data pointer.
//
__declspec(thread) LPVOID XapiCurrentFiber;

//
// For threads that have been converted to fibers, this per thread structure
// holds its fiber data.
//
__declspec(thread) XFIBER XapiThreadFiberData;

VOID
XapiFiberStartup(
    LPFIBER_START_ROUTINE lpStartAddress
    )
{
    __try {

        lpStartAddress(GetFiberData());

    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {

        //
        // UnhandledExceptionFilter will return either EXCEPTION_CONTINUE_SEARCH,
        // in which case, the exception search will stop since we're the top of
        // the exception stack, or it will return EXCEPTION_CONTINUE_EXECUTION.
        // We'll never execute this handler.
        //

        ASSERT(FALSE);
    }

    RIP("Fiber should not return.");

    KeBugCheck(0);
}

LPVOID
WINAPI
CreateFiber(
    IN DWORD dwStackSize,
    IN LPFIBER_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter
    )
{
    PVOID StackBase;
    PXFIBER Fiber;
    PULONG_PTR Context;

    //
    // Allocate the stack for the fiber.
    //

    if (dwStackSize == 0) {
        dwStackSize = XeImageHeader()->SizeOfStackCommit;
    }

    if (dwStackSize < KERNEL_STACK_SIZE) {
        dwStackSize = KERNEL_STACK_SIZE;
    }

    dwStackSize = ROUND_TO_PAGES(dwStackSize);

    StackBase = MmCreateKernelStack(dwStackSize, FALSE);

    if (StackBase == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Allocate the fiber structure at the top of the fiber stack.
    //

    Fiber = (PXFIBER)StackBase - 1;

    //
    // Initialize the fiber state.
    //

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = StackBase;
    Fiber->StackLimit = (PUCHAR)StackBase - dwStackSize;

    //
    // Initialize the start context for the fiber.  The start context consists
    // of the parameter to XapiFiberStartup, a dummy return address for the
    // 'call' to XapiFiberStartup (we use XapiFiberStartup itself in order to
    // make the kernel debugger happy), a dummy parameter to SwitchToFiber, the
    // return address for SwitchToFiber, and the initial non-volatile context.
    //

    Context = (PULONG_PTR)Fiber - 1;

    *(Context--) = (ULONG_PTR)lpStartAddress;
    *(Context--) = (ULONG_PTR)XapiFiberStartup;
    *(Context--) = 0;
    *(Context--) = (ULONG_PTR)XapiFiberStartup;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context) = (ULONG_PTR)EXCEPTION_CHAIN_END;

    Fiber->KernelStack = Context;

#if 0
    // Tell the debugger we've created the fiber
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_CREATE_FIBER
            mov ecx, Fiber
            mov edx, lpStartAddress
            int 2dh
            int 3
        }
    }
#endif

    return Fiber;
}

VOID
WINAPI
DeleteFiber(
    IN LPVOID lpFiber
    )
{
    PXFIBER Fiber;

    RIP_ON_NOT_TRUE("DeleteFiber()", (lpFiber != NULL));

    Fiber = (PXFIBER)lpFiber;

    //
    // Unlike Win32, we cannot delete the currently executing fiber.  Win32
    // would call ExitThread here, but if we do that, then that doesn't end up
    // freeing the fiber's stack, but ends up killing a thread that called
    // ConvertThreadToFiber.
    //

    if (Fiber->KernelStack == NULL) {
        RIP("DeleteFiber() - Cannot delete an active fiber.");
    }

    //
    // Fibers created from ConvertThreadToFiber use the stack of the calling
    // thread.  We can't delete this fiber without destroying the thread.  We
    // could choose to delete just the fiber structure, but that alters the
    // behavior of the original API too much.
    //

    if (Fiber->StackLimit == NULL) {
        RIP("DeleteFiber() - Cannot delete a fiber from ConvertThreadToFiber.");
    }

#if 0
    // Tell the debugger this fiber is going away
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_DELETE_FIBER
            mov ecx, Fiber
            int 2dh
            int 3
        }
    }
#endif

    //
    // Delete the fiber's stack.  The fiber structure is allocated as a part of
    // the stack, so Fiber is not valid after this point.
    //

    MmDeleteKernelStack(Fiber->StackBase, Fiber->StackLimit);
}

LPVOID
WINAPI
ConvertThreadToFiber(
    IN LPVOID lpParameter
    )
{
    PXFIBER Fiber;

    //
    // Check that the current thread isn't already hosting a fiber.
    //

    if (XapiCurrentFiber != NULL) {
        RIP("ConvertThreadToFiber() - Cannot convert a thread to a fiber multiple times.");
    }

    //
    // Initialize the fiber state.
    //

    Fiber = &XapiThreadFiberData;

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = KeGetCurrentThread()->StackBase;
    Fiber->StackLimit = NULL;

#if 0
    // Tell the debugger how to find a fiber
    DmTell(DMTELL_FIBERTLS, (PVOID)((ULONG_PTR)&XapiCurrentFiber -
        (ULONG_PTR)KeGetCurrentThread()->TlsData));

    // Tell the debugger we've created the fiber
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_CREATE_FIBER
            mov ecx, Fiber
            xor edx, edx
            int 2dh
            int 3
        }
    }
#endif

    //
    // Make this fiber the current fiber for the thread.
    //

    XapiCurrentFiber = Fiber;

    return Fiber;
}

__declspec(naked)
VOID
WINAPI
#if DBG
XapiSwitchToFiberRetail(
#else
SwitchToFiber(
#endif
    LPVOID lpFiber
    )
{
    __asm {

        //
        // Fetch the offset to the TLS data and the base pointer to the TLS
        // data.
        //

        mov     edx,_tls_index
        mov     ecx,fs:[NT_TIB.StackBase]

        //
        // Load the pointer to the new fiber.
        //

        mov     eax,[esp+4]

        //
        // Save the old fiber's nonvolatile state and exception list.
        //

        push    ebp
        push    esi
        push    edi
        push    ebx
        push    DWORD PTR fs:[NT_TIB.ExceptionList]

        //
        // Load the pointer to the old fiber from XapiCurrentFiber.
        //

        mov     edx,[ecx+edx*4]
        mov     ecx,XapiCurrentFiber[edx]

        //
        // Switch from the old fiber's stack to the new fiber's stack.
        //

        mov     [ecx+XFIBER.KernelStack],esp
        mov     esp,[eax+XFIBER.KernelStack]

#if DBG
        //
        // Null out the kernel stack pointer so that we can use this as a flag
        // in SwitchToFiber to detect a fiber that's already running.
        //

        mov     DWORD PTR [eax+XFIBER.KernelStack], 0
#endif

        //
        // Update XapiCurrentFiber to point at the new fiber.
        //

        mov     XapiCurrentFiber[edx],eax

        //
        // Restore the new fiber's nonvolatile state and exception list.
        //

        pop     DWORD PTR fs:[NT_TIB.ExceptionList]
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp

        ret     4
    }
}

#if DBG

VOID
WINAPI
SwitchToFiber(
    LPVOID lpFiber
    )
{
    PXFIBER Fiber;

    RIP_ON_NOT_TRUE("SwitchToFiber()", (lpFiber != NULL));

    //
    // Check that the current thread has called ConvertThreadToFiber.
    //

    if (XapiCurrentFiber == NULL) {
        RIP("SwitchToFiber() - Thread hasn't called ConvertThreadToFiber().");
    }

    //
    // Check that the fiber isn't already running on another thread.  We'll
    // allow a fiber to switch to itself on the same thread (Win32 documents
    // this as "unpredictable".)
    //

    Fiber = (PXFIBER)lpFiber;

    if ((Fiber->KernelStack == NULL) && (XapiCurrentFiber != Fiber)) {
        RIP("SwitchToFiber() - Fiber is already active on another thread.");
    }

    //
    // Jump to the retail version of this routine.
    //

    XapiSwitchToFiberRetail(lpFiber);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\debugver.c ===
#include "basedll.h"
#include "xboxverp.h"
#pragma hdrstop

#ifdef _DEBUG

DWORD
WINAPI
XDebugGetSystemVersion(
    PSTR pszVersionString,
    UINT cchVersionString
    )
{
    RIP_ON_NOT_TRUE("XDebugGetSystemVersion()", (pszVersionString != NULL));

    _snprintf(pszVersionString,
              cchVersionString,
              "%d.%02d.%d.%02d",
              XboxKrnlVersion->Major,
              XboxKrnlVersion->Minor,
              XboxKrnlVersion->Build,
              (XboxKrnlVersion->Qfe & 0x7FFF));

    return (XboxKrnlVersion->Qfe & 0x8000) ? XVER_DEVKIT : XVER_RETAIL;
}

DWORD
WINAPI
XDebugGetXTLVersion(
    PSTR pszVersionString,
    UINT cchVersionString
    )
{
    RIP_ON_NOT_TRUE("XDebugGetXTLVersion()", (pszVersionString != NULL));

    _snprintf(pszVersionString,
              cchVersionString,
              "%d.%02d.%d.%02d",
              XeImageHeader()->XapiLibraryVersion->MajorVersion,
              XeImageHeader()->XapiLibraryVersion->MinorVersion,
              XeImageHeader()->XapiLibraryVersion->BuildVersion,
              XeImageHeader()->XapiLibraryVersion->QFEVersion);

    return XeImageHeader()->XapiLibraryVersion->DebugBuild ? XVER_DEVKIT : XVER_RETAIL;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\filefind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filefind.c

Abstract:

    This module implements Win32 FindFirst/FindNext

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

VOID
XapiDirectoryInformationToFindData(
    IN PFILE_DIRECTORY_INFORMATION DirInfo,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )
{
    lpFindFileData->dwFileAttributes = DirInfo->FileAttributes;
    lpFindFileData->ftCreationTime = *(LPFILETIME)&DirInfo->CreationTime;
    lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirInfo->LastAccessTime;
    lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirInfo->LastWriteTime;
    lpFindFileData->nFileSizeHigh = DirInfo->EndOfFile.HighPart;
    lpFindFileData->nFileSizeLow = DirInfo->EndOfFile.LowPart;

    RtlCopyMemory(lpFindFileData->cFileName, DirInfo->FileName,
        DirInfo->FileNameLength);
    lpFindFileData->cFileName[DirInfo->FileNameLength / sizeof(OCHAR)] = OBJECT_NULL;

    lpFindFileData->cAlternateFileName[0] = OBJECT_NULL;
}

HANDLE
APIENTRY
FindFirstFile(
    PCOSTR lpFileName,
    LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFile.

    This API is provided to open a find file handle and return
    information about the first file whose name match the specified
    pattern.  Once established, the find file handle can be used to
    search for other files that match the same pattern.  When the find
    file handle is no longer needed, it should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Eh), and OS/2's
    DosFindFirst.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file:

        WIN32_FIND_DATA Structure:

        DWORD dwFileAttributes - Returns the file attributes of the found
            file.

        FILETIME ftCreationTime - Returns the time that the file was created.
            A value of 0,0 specifies that the file system containing the
            file does not support this time field.

        FILETIME ftLastAccessTime - Returns the time that the file was last
            accessed.  A value of 0,0 specifies that the file system
            containing the file does not support this time field.

        FILETIME ftLastWriteTime - Returns the time that the file was last
            written.  A file systems support this time field.

        DWORD nFileSizeHigh - Returns the high order 32 bits of the
            file's size.

        DWORD nFileSizeLow - Returns the low order 32-bits of the file's
            size in bytes.

        UCHAR cFileName[MAX_PATH] - Returns the null terminated name of
            the file.

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    ULONG EndingIndex;
    OBJECT_STRING FileName;
    OBJECT_STRING SearchName;
    IO_STATUS_BLOCK IoStatusBlock;
    struct {
        FILE_DIRECTORY_INFORMATION DirInfo;
        OCHAR FileName[256];
    } FullDirInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Strip off the search specification from the file name.
    //

    EndingIndex = (FileName.Length / sizeof(OCHAR));

    while (EndingIndex > 0) {

        if (FileName.Buffer[EndingIndex - 1] == OTEXT('\\')) {
            break;
        }

        EndingIndex--;
    }

    SearchName.Length = (USHORT)(FileName.Length - (EndingIndex * sizeof(OCHAR)));
    SearchName.MaximumLength = SearchName.Length;
    SearchName.Buffer = &FileName.Buffer[EndingIndex];

    FileName.Length = (USHORT)(EndingIndex * sizeof(OCHAR));
    FileName.MaximumLength = FileName.Length;

    //
    // Make sure that we didn't consume the entire string while searching for
    // the search specification and that the search specification is not empty.
    //

    if ((FileName.Length == 0) || (SearchName.Length == 0)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // If the search name is "*.*", then convert it to an empty string so that
    // we end up matching all names, not just those with an extension.
    //

    if (SearchName.Length == sizeof(OCHAR) * 3 &&
        SearchName.Buffer[0] == OTEXT('*') && SearchName.Buffer[1] == OTEXT('.') &&
        SearchName.Buffer[2] == OTEXT('*')) {
        SearchName.Length = 0;
    }

    //
    // Open the directory for list access.
    //

    Status = NtOpenFile(
                 &Handle,
                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Get the first entry from the directory.
    //

    Status = NtQueryDirectoryFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &FullDirInfo,
                 sizeof(FullDirInfo),
                 FileDirectoryInformation,
                 &SearchName,
                 FALSE
                 );

    if ( !NT_SUCCESS(Status) ) {
        NtClose(Handle);
        XapiSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    XapiDirectoryInformationToFindData(&FullDirInfo.DirInfo, lpFindFileData);

    return Handle;
}

BOOL
APIENTRY
FindNextFile(
    HANDLE hFindFile,
    LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Once a successful call has been made to FindFirstFile, subsequent
    matching files can be located using FindNextFile.

    This API is used to continue a file search from a previous call to
    FindFirstFile.  This API returns successfully with the next file
    that matches the search pattern established in the original
    FindFirstFile call.  If no file match can be found NO_MORE_FILES is
    returned.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Fh), and OS/2's
    DosFindNext.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    struct {
        FILE_DIRECTORY_INFORMATION DirInfo;
        OCHAR FileName[256];
    } FullDirInfo;

    Status = NtQueryDirectoryFile(
                 hFindFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &FullDirInfo,
                 sizeof(FullDirInfo),
                 FileDirectoryInformation,
                 NULL,
                 FALSE
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    XapiDirectoryInformationToFindData(&FullDirInfo.DirInfo, lpFindFileData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\filehops.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filehops.c

Abstract:

    This module implements Win32 file handle APIs

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFile.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFile will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else  {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
SetEndOfFile(
    HANDLE hFile
    )

/*++

Routine Description:

    The end of file position of an open file can be set to the current
    file pointer using SetEndOfFile.

    This API is used to set the end of file position of a file to the
    same value as the current file pointer.  This has the effect of
    truncating or extending a file.  This functionality is similar to
    DOS (int 21h, function 40H with CX=0).

Arguments:

    hFile - Supplies an open handle to a file that is to be extended or
        truncated.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_END_OF_FILE_INFORMATION EndOfFile;
    FILE_ALLOCATION_INFORMATION Allocation;

    //
    // Get the current position of the file pointer
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the end of file based on the current file position
    //

    EndOfFile.EndOfFile = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &EndOfFile,
                sizeof(EndOfFile),
                FileEndOfFileInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the allocation based on the current file size
    //

    Allocation.AllocationSize = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &Allocation,
                sizeof(Allocation),
                FileAllocationInformation
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        GetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LARGE_INTEGER Large;

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        default:
            RIP("SetFilePointer() - invalid parameter (dwMoveMethod)");
            //
            // Fall through
            //
            
        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &NetworkInfo,
                        sizeof(NetworkInfo),
                        FileNetworkOpenInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                NetworkInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }

    //
    // NOTE: leaving this parameter check in the retail build, because it
    // isn't likely to be hit right away in debug builds - which could hide
    // the problem.
    //
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }

    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        XapiSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}


BOOL
WINAPI
SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    liDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpNewFilePointer - An optional parameter that if specified returns
        the new file pointer

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed. Extended error status is available using
        GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LARGE_INTEGER Large;

    Large = liDistanceToMove;

    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        default:
            RIP("SetFilePointerEx() - invalid parameter (dwMoveMethod)");
            //
            // Fall through
            //
            
        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &NetworkInfo,
                        sizeof(NetworkInfo),
                        FileNetworkOpenInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                NetworkInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;
        }

    //
    // If the resulting file position is negative fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return FALSE;
        }

    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpNewFilePointer)){
            *lpNewFilePointer = CurrentPosition.CurrentByteOffset;
            }
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}



BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    )

/*++

Routine Description:


Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BY_HANDLE_FILE_INFORMATION LocalFileInformation;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    FILE_INTERNAL_INFORMATION InternalInfo;
    FILE_FS_VOLUME_INFORMATION VolumeInfo;

    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &VolumeInfo,
                sizeof(VolumeInfo),
                FileFsVolumeInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &InternalInfo,
                sizeof(InternalInfo),
                FileInternalInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.nFileIndexHigh = InternalInfo.IndexNumber.HighPart;
        LocalFileInformation.nFileIndexLow = InternalInfo.IndexNumber.LowPart;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );

    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwFileAttributes = NetworkInfo.FileAttributes;
        LocalFileInformation.ftCreationTime = *(LPFILETIME)&NetworkInfo.CreationTime;
        LocalFileInformation.ftLastAccessTime = *(LPFILETIME)&NetworkInfo.LastAccessTime;
        LocalFileInformation.ftLastWriteTime = *(LPFILETIME)&NetworkInfo.LastWriteTime;
        LocalFileInformation.nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        LocalFileInformation.nFileSizeLow = NetworkInfo.EndOfFile.LowPart;
        LocalFileInformation.nNumberOfLinks = 0;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    *lpFileInformation = LocalFileInformation;
    return TRUE;
}

BOOL
APIENTRY
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be read using GetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastAccessTime - An optional parameter that if specified points to
        the location to return the date and time the file was last accessed.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastWriteTime - An optional parameter that if specified points to
        the location to return the date and time the file was last written.
        A file system must support this time and thus a valid value will
        always be returned for this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    //
    // Get the attributes
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );

    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT( lpCreationTime )) {
            *lpCreationTime = *(LPFILETIME)&NetworkInfo.CreationTime;
            }

        if (ARGUMENT_PRESENT( lpLastAccessTime )) {
            *lpLastAccessTime = *(LPFILETIME)&NetworkInfo.LastAccessTime;
            }

        if (ARGUMENT_PRESENT( lpLastWriteTime )) {
            *lpLastWriteTime = *(LPFILETIME)&NetworkInfo.LastWriteTime;
            }
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be modified using SetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be written.  The file handle must have been created
        with GENERIC_WRITE access to the file.

    lpCreationTime - An optional parameter, that if specified supplies
        the new creation time for the file.  Some file system's do not
        support this time value, so this parameter may be ignored.

    lpLastAccessTime - An optional parameter, that if specified supplies
        the new last access time for the file.  Some file system's do
        not support this time value, so this parameter may be ignored.

    lpLastWriteTime - An optional parameter, that if specified supplies
        the new last write time for the file.  A file system must support
        this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    //
    // Zero all the time values we can set.
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
FlushFileBuffers(
    HANDLE hFile
    )

/*++

Routine Description:

    Buffered data may be flushed out to the file using the
    FlushFileBuffers service.

    The FlushFileBuffers service causes all buffered data to be written
    to the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose buffers are to be
        flushed.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    Status = NtFlushBuffersFile(hFile,&IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

    The return value contains the low order 32-bits of the file's size.
    The optional lpFileSizeHigh returns the high order 32-bits of the
    file's size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSizeHigh - An optional parameter, that if specified, returns
        the high order 64-bits of the file's size.


Return Value:

    Not -1 - Returns the low order 32-bits of the specified file's size.


    0xffffffff - If the value of size of the file cannot be determined,
        or an invalid handle or handle with inappropriate access, or a
        handle to a non-file is specified, this error is returned.  If
        the file's size (low 32-bits) is -1, then this value is
        returned, and GetLastError() will return 0.  Extended error
        status is available using GetLastError.


--*/

{
    BOOL b;
    LARGE_INTEGER Li;

    b = GetFileSizeEx(hFile,&Li);

    if ( b ) {

        if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
            *lpFileSizeHigh = (DWORD)Li.HighPart;
            }
        if (Li.LowPart == -1 ) {
            SetLastError(0);
            }
        }
    else {
        Li.LowPart = -1;
        }

    return Li.LowPart;
}

BOOL
WINAPI
GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSize - Returns the files size


Return Value:

    TRUE - The operation was successful


    FALSE - The operation failed. Extended error
        status is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        *lpFileSize = NetworkInfo.EndOfFile;
        return TRUE;
        }
}

BOOL
WINAPI
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be read from a file using ReadFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the read is to begin from.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.  If this call fails because the
    thread issued a read beyond the end of file, GetLastError will
    return a value of ERROR_HANDLE_EOF.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.  The file must have been created with the
        FILE_FLAG_OVERLAPPED flag.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the read from.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    Status = NtReadFile(
                hFile,
                NULL,
                NtUserIoApcDispatcher,
                (PVOID) lpCompletionRoutine,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li
                );
    if ( NT_ERROR(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the write is to begin.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the write to.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    Status = NtWriteFile(
                hFile,
                NULL,
                NtUserIoApcDispatcher,
                (PVOID) lpCompletionRoutine,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (LPVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li
                );
    if ( NT_ERROR(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Data can be read from a file using ReadFileScatter.  The data
    is then scatter to specified buffer segements.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.

Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFileScatter(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToRead,
                &Li
                );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFileScatter(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToRead,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileGather.  The data can
    be in multple file segement buffers.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary. The number of
        entries in the array must be equal to nNumberOfBytesToRead /
        PAGE_SIZE.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFileGather will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFileGather(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToWrite,
                &Li
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else  {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFileGather(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToWrite,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\error.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the Win32 error APIs.

--*/

#include "basedll.h"

//
// Per thread last error code.
//
__declspec(thread) DWORD XapiLastErrorCode = 0;

ULONG
XapiSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

#ifndef BUILD_FOR_XBDM

DWORD
WINAPI
GetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    if (!XapiIsXapiThread())
    {
        XDBGERR("XAPI", "GetLastError() called on non-XAPI thread");
    }
    return XapiLastErrorCode;
}

VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    if (!XapiIsXapiThread())
    {
        XDBGERR("XAPI", "SetLastError() called on non-XAPI thread");
    }
    XapiLastErrorCode = (ULONG)dwErrCode;
}

HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    )

/*++

Routine Description:

    This function creates an I/O completion port.  Completion ports
    provide another mechanism that can be used to to recive I/O
    completion notification.

    Completion ports act as a queue.  The Win32 I/O system can be
    instructed to queue I/O completion notification packets to
    completion ports.  This API provides this mechanism.  If a file
    handle is created for overlapped I/O completion
    (FILE_FLAG_OVERLAPPED) , a completion port can be associated with
    the file handle.  When I/O operations are done on a file handle that
    has an associated completion port, the I/O system will queue a
    completion packet when the I/O operation completes.  The
    GetQueuedCompletionStatus is used to pick up these queued I/O
    completion packets.

    This API can be used to create a completion port and associate it
    with a file.  If you supply a completion port, it can be used to
    associate the specified file with the specified completion port.

Arguments:

    FileHandle - Supplies a handle to a file opened for overlapped I/O
        completion.  This file is associated with either the specified
        completion port, or a new completion port is created, and the
        file is associated with that port.  Once associated with a
        completion port, the file handle may not be used in ReadFileEx
        or WriteFileEx operations.  It is not advisable to share an
        associated file handle through either handle inheritence or
        through DuplicateHandle.  I/O operations done on these
        duplicates will also generate a completion notification.

    ExistingCompletionPort - If this parameter is specified, it supplies
        an existing completion port that is to be associated with the
        specified file handle.  Otherwise, a new completion port is
        created and associated with the specified file handle.

    CompletionKey - Supplies a per-file completion key that is part of
        every I/O completion packet for this file.

    NumberOfConcurrentThreads - This is the number of threads that are
        alowed to be concurrently active and can be used to avoid
        spurious context switches, e.g., context switches that would
        occur simply because of quantum end.  Up to the number of
        threads specified are allowed to execute concurrently.  If one
        of the threads enters a wait state, then another thread is
        allowed to procede.  There may be times when more then the
        specified number of threads are active, but this will be quickly
        throttled.  A value of 0 tells the system to allow the same
        number of threads as there are processors to run.

Return Value:

    Not NULL - Returns the completion port handle associated with the file.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    HANDLE Port;
    IO_STATUS_BLOCK IoSb;
    FILE_COMPLETION_INFORMATION CompletionInfo;

    Port = ExistingCompletionPort;
    if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
        Status = NtCreateIoCompletion (
                    &Port,
                    IO_COMPLETION_ALL_ACCESS,
                    NULL,
                    NumberOfConcurrentThreads
                    );
        if ( !NT_SUCCESS(Status) ) {
            XapiSetLastNTError(Status);
            return NULL;
            }
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CompletionInfo.Port = Port;
        CompletionInfo.Key = (PVOID)CompletionKey;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoSb,
                    &CompletionInfo,
                    sizeof(CompletionInfo),
                    FileCompletionInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            XapiSetLastNTError(Status);
            if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
                NtClose(Port);
                }
            return NULL;
            }
        }
    else {

        //
        // file handle is INVALID_HANDLE_VALUE. Usually this is
        // used to create a new unassociated completion port.
        //
        // Special case here to see if existing completion port was
        // specified and fail if it is
        //

        if ( ARGUMENT_PRESENT(ExistingCompletionPort) ) {
            Port = NULL;
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }

    return Port;
}

BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function allows the caller to post an I/O completion packet to
    a completion port. This packet will satisfy an outstanding call to
    GetQueuedCompletionStatus and will provide that caller with the three values
    normally returned from that call.

Arguments:

    CompletionPort - Supplies a handle to a completion port that the caller wants to
        post a completion packet to.

    dwNumberOfBytesTransferred - Supplies the value that is to be
        returned through the lpNumberOfBytesTransfered parameter of the
        GetQueuedCompletionStatus API.

    dwCompletionKey - Supplies the value that is to be returned through
        the lpCompletionKey parameter of the GetQueuedCompletionStatus
        API.

    lpOverlapped - Supplies the value that is to be returned through the
        lpOverlapped parameter of the GetQueuedCompletionStatus API.

Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed, use GetLastError to get detailed error information

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtSetIoCompletion(
                CompletionPort,
                (PVOID)dwCompletionKey,
                (PVOID)lpOverlapped,
                STATUS_SUCCESS,
                dwNumberOfBytesTransferred
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for an I/O completion
        packet.

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{

    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;


    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
    Status = NtRemoveIoCompletion(
                CompletionPort,
                (PVOID *)lpCompletionKey,
                (PVOID *)&LocalOverlapped,
                &IoSb,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;
        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
            }
        else {
            XapiSetLastNTError(Status);
            }
        rv = FALSE;
        }
    else {
        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            XapiSetLastNTError( IoSb.Status );
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    return rv;
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls XapiSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        XapiSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}

#endif /// BUILD_FOR_XBDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\filemisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    Misc file operations for Win32

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <basedll.h>
#include "..\..\fatx\fat.h"

BOOL
APIENTRY
SetFileAttributes(
    PCOSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file.
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the attributes
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
APIENTRY
GetFileAttributes(
    PCOSTR lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );
    if ( NT_SUCCESS(Status) ) {
        return NetworkInfo.FileAttributes;
        }
    else {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
}

BOOL
APIENTRY
GetFileAttributesEx(
    PCOSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    The main attributes of a file can be obtained using GetFileAttributesEx.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    fInfoLevelId - Supplies the info level indicating the information to be
        returned about the file.

    lpFileInformation - Supplies a buffer to receive the specified information
        about the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LPWIN32_FILE_ATTRIBUTE_DATA AttributeData;

    //
    // Check the parameters.  Note that for now there is only one info level,
    // so there's no special code here to determine what to do.
    //

    RIP_ON_NOT_TRUE("GetFileAttributesEx()",
                    (fInfoLevelId < GetFileExMaxInfoLevel && fInfoLevelId >= GetFileExInfoStandard));

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );

    if ( NT_SUCCESS(Status) ) {
        AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
MoveFile(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_RENAME_INFORMATION RenameInfo;

    RtlInitObjectString(&FileName, lpExistingFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the existing file for delete access.
    //

    Status = NtOpenFile( &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Rename the file.
    //

    RenameInfo.ReplaceIfExists = FALSE;
    RenameInfo.RootDirectory = ObDosDevicesDirectory();

    RtlInitObjectString(&RenameInfo.FileName, lpNewFileName);

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &RenameInfo,
                 sizeof(RenameInfo),
                 FileRenameInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
MoveFileEx(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgress(  lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}

BOOL
APIENTRY
MoveFileWithProgress(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    An existing file can be renamed using MoveFileWithProgressW.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        renamed.

    lpNewFileName - Supplies the new name for the existing file.  The new
        name must reside in the same file system/drive as the existing
        file and must not already exist.

    lpProgressRoutine - Supplies a callback routine that is notified.

    lpData - Supplies context data passed to the progress routine.

    dwFlags - Supplies optional flag bits to control the behavior of the
        rename.  The following bits are currently defined:

        MOVEFILE_REPLACE_EXISTING - if the new file name exists, replace
            it by renaming the old file name on top of the new file name.

        MOVEFILE_COPY_ALLOWED - if the new file name is on a different
            volume than the old file name, and causes the rename operation
            to fail, then setting this flag allows the MoveFileEx API
            call to simulate the rename with a call to CopyFile followed
            by a call to DeleteFile to the delete the old file if the
            CopyFile was successful.

        MOVEFILE_WRITE_THROUGH - perform the rename operation in such a
            way that the file has actually been moved on the disk before
            the API returns to the caller.  Note that this flag causes a
            flush at the end of a copy operation (if one were allowed and
            necessary), and has no effect if the rename operation is
            delayed until the next reboot.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_RENAME_INFORMATION RenameInfo;
    BOOL b;

    RtlInitObjectString(&FileName, lpExistingFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the existing file for delete access.
    //

    Status = NtOpenFile( &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    //
    // Rename the file.
    //

    RenameInfo.ReplaceIfExists = ((dwFlags & MOVEFILE_REPLACE_EXISTING) != 0);
    RenameInfo.RootDirectory = ObDosDevicesDirectory();

    RtlInitObjectString(&RenameInfo.FileName, lpNewFileName);

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &RenameInfo,
                 sizeof(RenameInfo),
                 FileRenameInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    }
    else {

        if ((Status == STATUS_NOT_SAME_DEVICE) &&
            ((dwFlags & MOVEFILE_COPY_ALLOWED) != 0)) {

            b = CopyFileEx(lpExistingFileName,
                           lpNewFileName,
                           lpProgressRoutine,
                           lpData,
                           NULL,
                           (RenameInfo.ReplaceIfExists ? 0 : COPY_FILE_FAIL_IF_EXISTS) |
                               COPY_FILE_OPEN_SOURCE_FOR_WRITE
                           );

            //
            // the copy worked... Delete the source of the rename
            // if it fails, try a set attributes and then a delete
            //

            if (b && !DeleteFile( lpExistingFileName ) ) {

                //
                // If the delete fails, we will return true, but possibly
                // leave the source dangling
                //

                SetFileAttributes(lpExistingFileName,FILE_ATTRIBUTE_NORMAL);
                DeleteFile( lpExistingFileName );
            }

            return b;
        }

        XapiSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
APIENTRY
DeleteFile(
    PCOSTR lpFileName
    )

/*++

    Routine Description:

    An existing file can be deleted using DeleteFile.

    This API provides the same functionality as DOS (int 21h, function 41H)
    and OS/2's DosDelete.

Arguments:

    lpFileName - Supplies the file name of the file to be deleted.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file for delete access.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
XSetFileCacheSize(
    SIZE_T dwCacheSize
    )
/*++

Routine Description:

    This routine changes the number of bytes allocated to the file system cache.

Arguments:

    dwCacheSize - Supplies the number of bytes that should be allocated to the
        file system cache.  The number of bytes is rounded up to a multiple of
        the page size.

Return Value:

    Status of operation.

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS status;
    PFN_COUNT NumberOfCachePages;

    //
    // Carefully compute the number of cache pages if the cache size is near
    // MAXULONG.
    //

    NumberOfCachePages = dwCacheSize >> PAGE_SHIFT;

    if (BYTE_OFFSET(dwCacheSize) != 0) {
        NumberOfCachePages++;
    }

    status = FscSetCacheSize(NumberOfCachePages);

    if (NT_SUCCESS(status)) {
        return TRUE;
    } else {
        XapiSetLastNTError(status);
        return FALSE;
    }
}

SIZE_T
WINAPI
XGetFileCacheSize(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of bytes allocated to the file system cache.

Arguments:

    None.

Return Value:

    Number of bytes currently allocated to the file system cache.

--*/
{
    return FscGetCacheSize() << PAGE_SHIFT;
}



NTSTATUS
XapiGetDirectoryDisplayBlocks(
        HANDLE                      DirHandle,
        DWORD                       *TotalBlocks,
        PFILE_DIRECTORY_INFORMATION DirectoryInfo
        )
/*++
  Routine Description:
    Helper function for XDisplayBlocksFromPath.  Does the recursion of directories.
--*/
{
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatusBlock;
    BOOLEAN           fFindFirst = TRUE;
    DWORD             fileCount = 0;
    HANDLE            subdirHandle;
    OBJECT_STRING     subdirName;
    OBJECT_ATTRIBUTES objectAttributes;
    DWORD             directorySize;

    do
    {
       status = NtQueryDirectoryFile(
                        DirHandle,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        DirectoryInfo,
                        sizeof(FILE_DIRECTORY_INFORMATION)+sizeof(OCHAR)*254,
                        FileDirectoryInformation,
                        NULL,
                        fFindFirst
                        );

        fFindFirst = FALSE;

        //
        // If we succesfully found a file or directory then we have work to do
        //
        if (NT_SUCCESS(status))
        {
            //
            //  The fileCount and fileNameSizes will go into 
            //  computing the blocks required by this directory.
            //

            fileCount++;
            
            //
            //  If this is a directory we will need to recurse it.
            //
            if(FILE_ATTRIBUTE_DIRECTORY&DirectoryInfo->FileAttributes)
            {
            
                //
                //  Null terminate filename
                //

                DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

                //
                //  Create an OBJECT_STRING for the relative path of the directory
                //

                RtlInitObjectString(&subdirName, DirectoryInfo->FileName);

                //
                //  Initialize Obja with Handle of the parent and the relative path.
                //
                InitializeObjectAttributes(
                    &objectAttributes,
                    &subdirName,
                    OBJ_CASE_INSENSITIVE,
                    DirHandle,
                    NULL
                    );

                //
                // Open the directory
                //

                status = NtOpenFile(
                            &subdirHandle,
                            FILE_LIST_DIRECTORY | SYNCHRONIZE,
                            &objectAttributes,
                            &ioStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                            );

                if(NT_SUCCESS(status))
                {
                    status = XapiGetDirectoryDisplayBlocks(subdirHandle, TotalBlocks, DirectoryInfo);
                    NtClose(subdirHandle);
                }
            } else
            {
                 if(DirectoryInfo->EndOfFile.HighPart)
                 {
                    *TotalBlocks = MAX_DISPLAY_BLOCKS;
                    break;
                 } else
                 {
                    DWORD fileBytes, fileBlocks;
                    fileBytes = DirectoryInfo->EndOfFile.LowPart;
                    fileBlocks = (fileBytes/0x4000) + ((fileBytes%0x4000) ? 1 : 0);
                    if(fileBlocks >= MAX_DISPLAY_BLOCKS)
                    {
                        fileBlocks = MAX_DISPLAY_BLOCKS;
                    } else
                    {
                        *TotalBlocks += fileBlocks;
                    }
                 }
            }
            if(*TotalBlocks >= MAX_DISPLAY_BLOCKS)
            {
                *TotalBlocks = MAX_DISPLAY_BLOCKS;
                break;
            }
        }
    } while(NT_SUCCESS(status));

    
    //
    //  How much space the directory itself occupies.
    //  CAVEAT: directory entries don't shrink so 
    //  this calculation could underestimate the size
    //  if many files\or subdirectoires have been deleted.
    //
    directorySize = fileCount*sizeof(DIRENT);
    *TotalBlocks += (directorySize/0x4000);
    *TotalBlocks += (directorySize%0x4000) ? 1 : 0;
    if(*TotalBlocks >= MAX_DISPLAY_BLOCKS)
    {
       *TotalBlocks = MAX_DISPLAY_BLOCKS;
    }

    //
    //  Don't fail if we just found an empty directory
    //  or got to the end of it.
    //

    if(
        (status == STATUS_NO_MORE_FILES) ||
        (status == STATUS_NO_SUCH_FILE)
    ){
        status = STATUS_SUCCESS;
    }

    return status;
}


DWORD
WINAPI
XGetDisplayBlocks(
    PCOSTR lpPathName
    )
/*++

 Routine Description:

    Given a path to a file or directory, recursively computes the number
    of display blocks (bytes on disk\16kbytes) taken up by that file or
    directory and all of its subdirectories and files.

 Arguments:

    On Success:
      

 Return Value:

    On Success: Number of Display Blocks used by the path.  If the total is greater than 50,000,
    then MAX_DISPLAY_BLOCKS is returned.

    On Failure: 0, call GetLastError() for extended error information.

--*/
{
    OBJECT_STRING                 objectName;
    OBJECT_ATTRIBUTES             objectAttributes;
    FILE_NETWORK_OPEN_INFORMATION networkInfo;
    HANDLE                        dirHandle;
    IO_STATUS_BLOCK               ioStatusBlock;
    NTSTATUS                      status;
    DWORD                         totalBlocks;


    //
    //  Open a handle to the path.
    //

    RtlInitObjectString(&objectName, lpPathName);
    InitializeObjectAttributes(&objectAttributes,
                               &objectName,
                               OBJ_CASE_INSENSITIVE,
                               ObDosDevicesDirectory(),
                               NULL
                               );

    status = NtQueryFullAttributesFile(&objectAttributes, &networkInfo);
    
    if(NT_SUCCESS(status))
    {
        if(networkInfo.FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
        {
            totalBlocks = 0;
            
            status = NtOpenFile(
                &dirHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

             if(NT_SUCCESS(status))
             {
                struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} buffer;
                PFILE_DIRECTORY_INFORMATION directoryInfo = &buffer.DirInfo;
                status = XapiGetDirectoryDisplayBlocks(dirHandle, &totalBlocks, directoryInfo);
                NtClose(dirHandle);
             }
        } else
        {
            if(networkInfo.EndOfFile.HighPart)
            {
                totalBlocks = MAX_DISPLAY_BLOCKS;
            } else
            {
                DWORD fileBytes;
                fileBytes = networkInfo.EndOfFile.LowPart;
                totalBlocks = (fileBytes/0x4000) + ((fileBytes%0x4000) ? 1 : 0);
                if(totalBlocks > MAX_DISPLAY_BLOCKS) totalBlocks = MAX_DISPLAY_BLOCKS;
            }
        }
    }

    //
    //  Set an error on failure.
    //
    if(!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return 0;
    }
    
    return totalBlocks;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\format.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    format.c

Abstract:

    This module implements routines to format a FAT volume.

--*/

#include "basedll.h"
#include "..\..\fatx\fat.h"

BOOL
WINAPI
XapiFormatFATVolume(
    IN POBJECT_STRING VolumePath
    )
{
    return XapiFormatFATVolumeEx(VolumePath, 16384);
}

BOOL
WINAPI
XapiFormatFATVolumeEx(
    IN POBJECT_STRING VolumePath,
    IN ULONG BytesPerCluster
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    PARTITION_INFORMATION PartitionInformation;
    ULONG StructureAlignment;
    ULONG NumberOfReservedBytes;
    ULONG NumberOfClustersLimit;
    ULONG NumberOfBytesPerFat;
    BOOLEAN Fat16X;
    ULONGLONG NumberOfUnreservedBytes;
    ULONGLONG NumberOfFileAreaBytes;
    PUCHAR Buffer;
    PFAT_VOLUME_METADATA VolumeMetadata;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER ByteOffset;
    ULONG BytesRemaining;

    //
    // Open the volume for read/write access.
    //

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    if (BytesPerCluster < StructureAlignment) {
        BytesPerCluster = StructureAlignment;
    }

    //
    // Compute the number of reserved bytes for the volume.
    //
    // We only need to reserve enough space for the volume metadata block.
    //

    NumberOfReservedBytes = PAGE_SIZE;

    if (NumberOfReservedBytes < StructureAlignment) {
        NumberOfReservedBytes = StructureAlignment;
    }

    //
    // Verify that the partition has enough space to contain the reserved bytes.
    //

    if ((ULONGLONG)NumberOfReservedBytes >=
        (ULONGLONG)PartitionInformation.PartitionLength.QuadPart) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Compute the limit of the number of clusters given the length of the
    // partition (bump up the count by two to account for the two reserved
    // entries in the FAT).  With this limit, decide whether or not we'll
    // use 16-bit or 32-bit FAT entries.
    //
    // Near the limit of the number of bytes per cluster multiplied by
    // FAT_CLUSTER16_AVAILABLE, we could end up using a bigger FAT than we
    // really need, but the math is very simple to understand.
    //

    NumberOfClustersLimit =
        (ULONG)(PartitionInformation.PartitionLength.QuadPart /
        BytesPerCluster) + FAT_RESERVED_FAT_ENTRIES;

    if (NumberOfClustersLimit < FAT_CLUSTER16_RESERVED) {
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(USHORT);
        Fat16X = TRUE;
    } else {
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(ULONG);
        Fat16X = FALSE;
    }

    NumberOfBytesPerFat = (NumberOfBytesPerFat + (StructureAlignment - 1)) &
        ~(StructureAlignment - 1);

    //
    // Compute the number of bytes that haven't been reserved above.
    //

    NumberOfUnreservedBytes =
        (ULONGLONG)PartitionInformation.PartitionLength.QuadPart -
        NumberOfReservedBytes;

    //
    // Verify that the partition has enough space to contain the FAT.
    //

    if ((ULONGLONG)NumberOfBytesPerFat > NumberOfUnreservedBytes) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Verify that the partition has enough space for a single cluster to hold
    // the root directory.
    //

    NumberOfFileAreaBytes = NumberOfUnreservedBytes - NumberOfBytesPerFat;

    if (BytesPerCluster > NumberOfFileAreaBytes) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Allocate a buffer to hold the sectors we're writing to the disk.
    //

    Buffer = (PUCHAR) LocalAlloc(LMEM_FIXED, StructureAlignment);

    if (Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Prepare the reserved sectors.
    //

    RtlFillMemory(Buffer, StructureAlignment, 0xFF);

    VolumeMetadata = (PFAT_VOLUME_METADATA)Buffer;

    VolumeMetadata->Signature = FAT_VOLUME_SIGNATURE;
    VolumeMetadata->SectorsPerCluster = (UCHAR)(BytesPerCluster >> SectorShift);
    VolumeMetadata->RootDirFirstCluster = 1;
    VolumeMetadata->VolumeName[0] = L'\0';

    //
    // Use the system time for the serial number.
    //

    KeQuerySystemTime(&SystemTime);
    VolumeMetadata->SerialNumber = SystemTime.LowPart;

    //
    // After this point, any failures leaves the volume in an intermediate
    // state.  Jump to DismountAndExit to force a dismount of the volume so that
    // we don't leave a file system device object in a random state.
    //

    //
    // Write out the reserved sectors.
    //

    ByteOffset.QuadPart = 0;
    BytesRemaining = NumberOfReservedBytes;

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        //
        // Wipe out the reserved bytes for the second and greater passes of this
        // loop.
        //

        RtlZeroMemory(Buffer, StructureAlignment);

        //
        // Advance to the next reserved bytes page.
        //

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    //
    // Prepare and write out the initial FAT sectors.  For the first page of FAT
    // sectors, mark the root directory's cluster as allocated and the end of
    // the file allocation table.
    //

    RtlZeroMemory(Buffer, StructureAlignment);

    ByteOffset.QuadPart = NumberOfReservedBytes;
    BytesRemaining = NumberOfBytesPerFat;

    if (Fat16X) {
        ((PUSHORT)Buffer)[0] = FAT_CLUSTER16_MEDIA;
        ((PUSHORT)Buffer)[1] = FAT_CLUSTER16_LAST;
    } else {
        ((PULONG)Buffer)[0] = FAT_CLUSTER_MEDIA;
        ((PULONG)Buffer)[1] = FAT_CLUSTER_LAST;
    }

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        //
        // Wipe out the cluster values that we filled out above.
        //

        RtlZeroMemory(Buffer, sizeof(ULONG) * (FAT_RESERVED_FAT_ENTRIES + 1));

        //
        // Advance to the next FAT page.
        //

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    //
    // Write out an empty cluster for the directory.  The byte offset is already
    // set to point at the first allocatable cluster.
    //

    RtlFillMemory(Buffer, StructureAlignment, FAT_DIRENT_NEVER_USED2);

    BytesRemaining = BytesPerCluster;

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    LocalFree(Buffer);

    //
    // Dismount the file system so that we get a new file system the next time
    // somebody touches this volume.
    //

DismountAndExit:
    NtFsControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

    NtClose(VolumeHandle);

    if (NT_SUCCESS(status)) {
        return TRUE;
    } else {
        XapiSetLastNTError(status);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\kthunks.c ===
#include "basedll.h"
#include <stdio.h>


VOID
WINAPI
DebugBreak()
{
    DbgBreakPoint();
}

VOID
WINAPI
GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
{
    KeQuerySystemTime((PLARGE_INTEGER) lpSystemTimeAsFileTime);
}

int
WINAPIV
wsprintfW(LPWSTR lpOut, LPCWSTR lpFmt, ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);

    va_end(arglist);
    return ret;
}

int
WINAPIV
wsprintfA(LPSTR lpOut, LPCSTR lpFmt, ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfA(lpOut, lpFmt, arglist);

    va_end(arglist);
    return ret;
}

//
// We need a wrapper for wvsprintf() (as opposed to forwarding it to NTOSKRNL)
// because the calling convention is not the same as vwsprintf()
//

int
WINAPI
wvsprintfW(
    OUT LPWSTR lpOut,
    IN LPCWSTR lpFmt,
    IN va_list arglist)
{
    return vswprintf(lpOut, lpFmt, arglist);
}

int
WINAPI
wvsprintfA(
    OUT LPSTR lpOut,
    IN LPCSTR lpFmt,
    IN va_list arglist)
{
    return vsprintf(lpOut, lpFmt, arglist);
}

ULONG
WINAPIV
DebugPrint(PCHAR Format, ...)
{
    va_list arglist;
    CHAR string[MAX_PATH];
    ULONG ret;

    va_start(arglist, Format);
    ret = _vsnprintf(string, sizeof(string), Format, arglist);
    OutputDebugStringA(string);

    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\handle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the Win32 handle management services.

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CloseHandle(
    HANDLE hObject
    )

/*++

Routine Description:

    An open handle to any object can be closed using CloseHandle.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    Closing an open handle to an object causes the handle to become
    invalid and the HandleCount of the associated object to be
    decremented and object retention checks to be performed.  Once the
    last open handle to an object is closed, the object is removed from
    the system.

Arguments:

    hObject - An open handle to an object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtDuplicateObject(hSourceHandle, lpTargetHandle, dwOptions);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\fileopcr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fileopcr.c

Abstract:

    This module implements File open and Create APIs for Win32

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"

#define BASE_COPY_FILE_CHUNK (64*1024)

HANDLE
WINAPI
CreateFile(
    PCOSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - Ignored on xbox

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

    hTemplateFile - Not supported on xbox (used for EA's)

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    BOOL EndsInSlash;

#if DBG
    if ( NULL != hTemplateFile )
    {
        // xbox doesn't support this parameter because we don't support EA's
        RIP("CreateFile() - invalid parameter (hTemplateFile not supported)");
    }
#endif // DBG

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OVERWRITE;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                XapiSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    RtlInitObjectString(&FileName,lpFileName);

    if ( FileName.Length > 1 &&
         lpFileName[(FileName.Length / sizeof(OCHAR))-1] == (OCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    CreateFlags = 0;
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                SetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                SetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        SetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        SetLastError(0);
        }

    return Handle;
}

BOOL
WINAPI
CopyFile(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFile.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL b;

    b = CopyFileEx(
            lpExistingFileName,
            lpNewFileName,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    return b;
}

BOOL
CopyFileEx(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )
/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LPVOID CopyBuffer;
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING PathName;
    HANDLE SourceHandle;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    HANDLE DestinationHandle;
    LARGE_INTEGER ByteOffset;
    DWORD dwProgress;
    ULONG BytesThisPass;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_END_OF_FILE_INFORMATION EndOfFileInfo;
    FILE_DISPOSITION_INFORMATION DispositionInfo;

    InitializeObjectAttributes(&ObjectAttributes,
                               &PathName,
                               OBJ_CASE_INSENSITIVE,
                               ObDosDevicesDirectory(),
                               NULL
                               );

    //
    // Allocate a buffer to copy the file stream.
    //

    CopyBuffer = MmAllocateSystemMemory(BASE_COPY_FILE_CHUNK, PAGE_READWRITE);

    if (CopyBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Open the source file.
    //

    RtlInitObjectString(&PathName, lpExistingFileName);

    status = NtOpenFile(&SourceHandle,
                        GENERIC_READ | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(status)) {
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Get the attributes for the source file.
    //

    status = NtQueryInformationFile(SourceHandle,
                                    &IoStatusBlock,
                                    &NetworkInfo,
                                    sizeof(NetworkInfo),
                                    FileNetworkOpenInformation
                                    );

    if (!NT_SUCCESS(status)) {
        NtClose(SourceHandle);
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Create the destination file.  The file is created with the attributes of
    // the source file and given an initial file allocation equal to the size of
    // the source file.
    //

    RtlInitObjectString(&PathName, lpNewFileName);

    status = NtCreateFile(&DestinationHandle,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          &NetworkInfo.EndOfFile,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ?
                              FILE_CREATE : FILE_OVERWRITE_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY
                          );

    if (!NT_SUCCESS(status)) {
        NtClose(SourceHandle);
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    ByteOffset.QuadPart = 0;

    //
    // Invoke the callback to inform it of the start of the copy process.  Note
    // that for simplicity, we treat PROGRESS_STOP or any unknow return value as
    // PROGRESS_CANCEL.
    //

    if (lpProgressRoutine != NULL) {

        dwProgress = lpProgressRoutine(NetworkInfo.EndOfFile,
                                       ByteOffset,
                                       NetworkInfo.EndOfFile,
                                       ByteOffset,
                                       1,
                                       CALLBACK_STREAM_SWITCH,
                                       SourceHandle,
                                       DestinationHandle,
                                       lpData
                                       );

        if (dwProgress == PROGRESS_QUIET) {
            lpProgressRoutine = NULL;
        } else if (dwProgress != PROGRESS_CONTINUE) {
            status = STATUS_REQUEST_ABORTED;
            goto CancelOperation;
        }
    }

    //
    // Set the end of file for the destination file to the size of the source
    // file.
    //

    EndOfFileInfo.EndOfFile = NetworkInfo.EndOfFile;

    status = NtSetInformationFile(DestinationHandle,
                                  &IoStatusBlock,
                                  &EndOfFileInfo,
                                  sizeof(EndOfFileInfo),
                                  FileEndOfFileInformation
                                  );

    if (!NT_SUCCESS(status)) {
        goto CancelOperation;
    }

    //
    // Copy the bytes from the source file to the destination file.
    //

    while (ByteOffset.QuadPart < NetworkInfo.EndOfFile.QuadPart) {

        status = NtReadFile(SourceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            CopyBuffer,
                            BASE_COPY_FILE_CHUNK,
                            &ByteOffset
                            );

        if (!NT_SUCCESS(status)) {
            break;
        }

        BytesThisPass = IoStatusBlock.Information;

        status = NtWriteFile(DestinationHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             CopyBuffer,
                             BytesThisPass,
                             &ByteOffset
                             );

        if (!NT_SUCCESS(status)) {
            break;
        }

        ByteOffset.QuadPart += BytesThisPass;

        //
        // Invoke the callback to inform it that another chunk has been copied.
        //

        if (lpProgressRoutine != NULL) {

            dwProgress = lpProgressRoutine(NetworkInfo.EndOfFile,
                                           ByteOffset,
                                           NetworkInfo.EndOfFile,
                                           ByteOffset,
                                           1,
                                           CALLBACK_CHUNK_FINISHED,
                                           SourceHandle,
                                           DestinationHandle,
                                           lpData
                                           );

            if (dwProgress == PROGRESS_QUIET) {
                lpProgressRoutine = NULL;
            } else if (dwProgress != PROGRESS_CONTINUE) {
                status = STATUS_REQUEST_ABORTED;
                break;
            }
        }
    }

    //
    // Apply the time stamps from the source file to the destination file.
    //

    if (NT_SUCCESS(status)) {

        BasicInfo.CreationTime = NetworkInfo.CreationTime;
        BasicInfo.LastAccessTime = NetworkInfo.LastAccessTime;
        BasicInfo.LastWriteTime = NetworkInfo.LastWriteTime;
        BasicInfo.ChangeTime = NetworkInfo.ChangeTime;
        BasicInfo.FileAttributes = NetworkInfo.FileAttributes;

        status = NtSetInformationFile(DestinationHandle,
                                      &IoStatusBlock,
                                      &BasicInfo,
                                      sizeof(BasicInfo),
                                      FileBasicInformation
                                      );
    }

    //
    // If the copy operation failed or a progress callback canceled the
    // operation, then delete the file.
    //

CancelOperation:
    MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
    NtClose(SourceHandle);

    if (!NT_SUCCESS(status)) {

#undef DeleteFile
        DispositionInfo.DeleteFile = TRUE;

        NtSetInformationFile(DestinationHandle,
                             &IoStatusBlock,
                             &DispositionInfo,
                             sizeof(DispositionInfo),
                             FileDispositionInformation
                             );

        XapiSetLastNTError(status);
        NtClose(DestinationHandle);
        return FALSE;
    }

    NtClose(DestinationHandle);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\findcont.c ===
#include "basedll.h"
#include "xmeta.h"
#include <xboxp.h>


BOOL
XapiFindValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag,
    LPWSTR pszValue,
    int cchValue);

BOOL
XapiValidateAndSkipUnicodeSignature(
    HANDLE hMetaFile);

BOOL
XapiFillInContentData(
    PXCONTENT_FIND_DATA pFindContentData,
    DWORD dwFlagFilter,
    PCSTR pszRootDir,
    int cchRootDir)
{
    int nNameLen;
    int iCurIdentity;
    BOOL fRet = FALSE;
    PSTR pszEnd;

    ASSERT(pFindContentData);

    if (0 == (pFindContentData->wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected file found in content directory");
        return FALSE;
    }

    nNameLen = strlen(pFindContentData->wfd.cFileName);

    if ((nNameLen != CONTENT_DIR_NAME_LENGTH) ||
        (CONTENT_DIR_DELIMETER != pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX]))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }

    //
    // Temporarily replace delimiter with NULL
    //
    
    pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX] = '\0';

    //
    // Read the offering id and flags from the directory name
    //

    pFindContentData->dwOfferingId = strtoul(pFindContentData->wfd.cFileName, &pszEnd, 16);

    if (pszEnd != (pFindContentData->wfd.cFileName + (CCHMAX_HEX_DWORD - 1)))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }
    
    pFindContentData->dwFlags = strtoul(&(pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX + 1]),
                                        &pszEnd,
                                        16);

    if (pszEnd != (pFindContentData->wfd.cFileName + (CONTENT_DIR_DELIMETER_INDEX + 1) + (CCHMAX_HEX_DWORD - 1)))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }

    //
    // Restore the delimiter
    //
    
    pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX] = CONTENT_DIR_DELIMETER;

    if ((0 != dwFlagFilter) && (0 == (dwFlagFilter & pFindContentData->dwFlags)))
    {
        //
        // dwFlagFilter is set to ignore this directory, so bail out here
        //

        return FALSE;
    }

    ASSERT(cchRootDir + nNameLen < ARRAYSIZE(pFindContentData->szContentDirectory));

    strcpy(pFindContentData->szContentDirectory, pszRootDir);
    strcpy(&(pFindContentData->szContentDirectory[cchRootDir]),
           pFindContentData->wfd.cFileName);

    //
    // Append a backslash if there is room
    //

    if (cchRootDir + nNameLen < ARRAYSIZE(pFindContentData->szContentDirectory) - 1)
    {
        pFindContentData->szContentDirectory[cchRootDir + nNameLen] = '\\';
        pFindContentData->szContentDirectory[cchRootDir + nNameLen + 1] = '\0';
    }

    //
    // Attempt to open the metadata file
    //

    if (cchRootDir + nNameLen <
        (int) ARRAYSIZE(pFindContentData->szContentDirectory) - g_cchContentMetaFileName)
    {
        HANDLE hMetaFile;

        //
        // Borrow the output buffer temporarily to append the metadata filename
        //

        strcpy(&(pFindContentData->szContentDirectory[cchRootDir + nNameLen]),
               g_cszContentMetaFileName);

        hMetaFile = CreateFile(pFindContentData->szContentDirectory,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (INVALID_HANDLE_VALUE != hMetaFile)
        {
            fRet = XapiValidateAndSkipUnicodeSignature(hMetaFile);

            if (fRet)
            {
                fRet = XapiFindValueInMetaFile(hMetaFile,
                                               g_cszNameTag,
                                               pFindContentData->szDisplayName,
                                               ARRAYSIZE(pFindContentData->szDisplayName));
            }

            CloseHandle(hMetaFile);
        }

        //
        // Restore the buffer (truncate to remove the metadata filename)
        //

        pFindContentData->szContentDirectory[cchRootDir + nNameLen + 1] = '\0';
    }

    return fRet;
}

HANDLE
WINAPI
XFindFirstContent(
    IN PCSTR lpRootPathName,
    IN DWORD dwFlagFilter,
    OUT PXCONTENT_FIND_DATA pFindContentData
    )
{
    CHAR szDirName[MAX_PATH];
    int cchRootDir;
    HANDLE hRet;

#if DBG
    if ((NULL == pFindContentData) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XFindFirstContent() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        CHAR chDrive = lpRootPathName[0] & (~0x20);

        if ((HD_TDATA_DRIVE != chDrive) &&
            (HD_ALT_TDATA_DRIVE != chDrive))
        {
            RIP("XFindFirstContent() invalid drive letter parameter");
        }
    }
#endif // DBG

    //
    // Create <path>\$C\* in our own buffer
    //

    strcpy(szDirName, lpRootPathName);
    cchRootDir = strlen(szDirName);

    if (cchRootDir > ((int) ARRAYSIZE(szDirName) - 1 - g_cchContentSearch))
    {
        RIP("XFindFirstContent() lpRootPathName parameter too long");
    }

    strcpy(&(szDirName[cchRootDir]), g_cszContentSearch);

    hRet = FindFirstFile(szDirName, (PWIN32_FIND_DATA) pFindContentData);

    //
    // Recreate the <path>\$C without the wildcard string
    //

    ASSERT(g_cchContentDir < g_cchContentSearch);
    strcpy(szDirName, lpRootPathName);
    strcpy(&(szDirName[cchRootDir]), g_cszContentDir);
    cchRootDir += g_cchContentDir;

    if (INVALID_HANDLE_VALUE != hRet)
    {
        if (!XapiFillInContentData(pFindContentData,
                                   dwFlagFilter,
                                   szDirName,
                                   cchRootDir))
        {
            BOOL fFound;

            while (fFound = FindNextFile(hRet, (PWIN32_FIND_DATA) pFindContentData))
            {
                if (XapiFillInContentData(pFindContentData,
                                          dwFlagFilter,
                                          szDirName,
                                          cchRootDir))
                {
                    break;
                }
            }

            if (!fFound)
            {
                //
                // We didn't find a content directory
                //

                FindClose(hRet);
                hRet = INVALID_HANDLE_VALUE;
                SetLastError(ERROR_NO_MORE_FILES);
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hRet)
    {
        PFINDCONTENT_HANDLE pFindContent = LocalAlloc(LMEM_FIXED, sizeof(FINDCONTENT_HANDLE));

        if (NULL != pFindContent)
        {
            pFindContent->dwSignature = FH_SIG_CONTENT;
            pFindContent->dwFlagFilter = dwFlagFilter;
            pFindContent->hFindFile = hRet;
            pFindContent->cchRootDir = cchRootDir;
            lstrcpynA(pFindContent->szRootDir, szDirName, ARRAYSIZE(pFindContent->szRootDir));
            hRet = (HANDLE) pFindContent;
        }
        else
        {
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return hRet;
}

BOOL
WINAPI
XFindNextContent(
    IN HANDLE hFindContent,
    OUT PXCONTENT_FIND_DATA pFindContentData
    )
{
    BOOL bRet = FALSE;

#if DBG
    if ((NULL == hFindContent) ||
        (INVALID_HANDLE_VALUE == hFindContent) ||
        (FH_SIG_CONTENT != ((PFINDCONTENT_HANDLE) hFindContent)->dwSignature) ||
        (NULL == pFindContentData))
    {
        RIP("XFindNextContent() invalid parameter");
    }
#endif // DBG

    {
        PFINDCONTENT_HANDLE pFindContent = (PFINDCONTENT_HANDLE) hFindContent;

        while (bRet = FindNextFile(pFindContent->hFindFile, (PWIN32_FIND_DATA) pFindContentData))
        {
            if (XapiFillInContentData(pFindContentData,
                                      pFindContent->dwFlagFilter,
                                      pFindContent->szRootDir,
                                      pFindContent->cchRootDir))
            {
                break;
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\launch.c ===
#include "basedll.h"
#include "xlaunch.h"
#include <xboxp.h>
#include <dm.h>
#include <idexchan.h>

static const OBJECT_STRING g_DDosDevicePrefix =  CONSTANT_OBJECT_STRING(OTEXT("\\??\\D:"));
static const CHAR g_szDVDDevicePrefix[] =        "\\Device\\Cdrom0";
static const int  g_cchDVDDevicePrefix =         ARRAYSIZE(g_szDVDDevicePrefix) - 1;

extern PLAUNCH_DATA_PAGE *LaunchDataPage;

DWORD
WINAPI
XLaunchNewImage(
    LPCSTR lpTitlePath,
    PLAUNCH_DATA pLaunchData
    )
{
    //
    // We require the path is NULL or D:\something
    //

    if ((NULL != lpTitlePath) &&
        ((('D' != lpTitlePath[0]) && ('d' != lpTitlePath[0])) ||
         (':' != lpTitlePath[1]) ||
         ('\\' != lpTitlePath[2])))
    {
        XDBGWRN("XAPI", "XLaunchNewImage() ignoring invalid lpTitlePath (%s)", lpTitlePath);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == lpTitlePath)
    {
        //
        // NULL lpTitlePath means reboot to the dashboard - don't preserve D: drive mapping
        //

        return XWriteTitleInfoAndReboot(NULL,
                                        NULL,
                                        (NULL != pLaunchData) ? LDT_LAUNCH_DASHBOARD : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
    else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        HANDLE LinkHandle;
        OCHAR szLinkTarget[MAX_PATH * 2];
        OCHAR szDDrivePath[MAX_LAUNCH_PATH];
        OBJECT_STRING LinkTarget;
        int cch;

        szDDrivePath[0] = '\0';

        //
        // If the D: drive is mapped in some unique fashion, preserve that mapping
        // across the reboot
        //

        InitializeObjectAttributes(&Obja,
                                   (POBJECT_STRING) &g_DDosDevicePrefix,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

        if (NT_SUCCESS(Status))
        {
            LinkTarget.Buffer = szLinkTarget;
            LinkTarget.Length = 0;
            LinkTarget.MaximumLength = sizeof(szLinkTarget);

            Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);

            NtClose(LinkHandle);
        }

        if (NT_SUCCESS(Status))
        {
            lstrcpynA(szDDrivePath,
                      szLinkTarget,
                      min(ARRAYSIZE(szDDrivePath), (LinkTarget.Length / sizeof(CHAR)) + 1));
        }
        else
        {
            /* Got no path.  The D: drive should always be mapped to something, so
             * we're in trouble if we get here.  Fall back on the DVD device
             * path */
            ASSERT(FALSE);
            strcpy(szDDrivePath, g_szDVDDevicePrefix);
        }

        return XWriteTitleInfoAndReboot(&(lpTitlePath[3]),
                                        szDDrivePath,
                                        (NULL != pLaunchData) ? LDT_TITLE : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
}

NTSTATUS
WINAPI
XWriteTitleInfoNoReboot(
    PCOSTR pszLaunchPath,
    PCOSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    )
/*
 *
 * This is a private function, called by the reboot API and by the
 * debugger
 *
 */
{
    LARGE_INTEGER ByteOffset;
    PSTR pszOutput;
    int cch;

    if (NULL == *LaunchDataPage)
    {
        *LaunchDataPage = MmAllocateContiguousMemory(PAGE_SIZE);
    }

    if (NULL == *LaunchDataPage)
    {
        return STATUS_NO_MEMORY;
    }

    MmPersistContiguousMemory(*LaunchDataPage, PAGE_SIZE, TRUE);

#ifndef BUILD_FOR_XBDM
    if (NULL == pszDDrivePath)
    {
        pszDDrivePath = g_szDVDDevicePrefix;
    }
#endif

    pszOutput = ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath;

    ASSERT(PAGE_SIZE == sizeof(LAUNCH_DATA_PAGE));

    RtlZeroMemory(*LaunchDataPage, PAGE_SIZE);

    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwLaunchDataType = dwLaunchDataType;
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwTitleId = dwTitleId;

    if (dwLaunchDataType != LDT_NONE)
    {
        memcpy(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData,
               pLaunchData,
               sizeof(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData));
    }

    if (NULL != pszLaunchPath)
    {
#ifdef BUILD_FOR_XBDM
        if(!pszDDrivePath)
            cch = 0;
        else
#endif
        {
        lstrcpynA(pszOutput,
                  pszDDrivePath,
                  ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);
        cch = strlen(pszOutput);
        pszOutput[cch++] = TITLE_PATH_DELIMITER;
        }
        lstrcpynA(&(pszOutput[cch]),
                  pszLaunchPath,
                  ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
    }

    return STATUS_SUCCESS;
}

DWORD
WINAPI
XWriteTitleInfoAndReboot(
    LPCSTR pszLaunchPath,
    LPCSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    )
{
    NTSTATUS Status = XWriteTitleInfoNoReboot(pszLaunchPath,
                                              pszDDrivePath,
                                              dwLaunchDataType,
                                              dwTitleId,
                                              pLaunchData);

    if (NT_SUCCESS(Status))
    {
        //
        // Notify the debugger that we're about to reboot and then reboot
        //
        DmTell(DMTELL_REBOOT, NULL);

#if DBG
        if (NULL != IdexChannelObject->CurrentIrp)
        {
            XDBGERR("XAPI", "I/O still in progress when XLaunchNewImage was called!");
        }
#endif // DBG

        HalReturnToFirmware(HalQuickRebootRoutine);
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
WINAPI
XGetLaunchInfo(
    OUT PDWORD pdwLaunchDataType,
    OUT PLAUNCH_DATA pLaunchData
    )
{
    RIP_ON_NOT_TRUE("XGetLaunchInfo()", (pdwLaunchDataType != NULL));
    RIP_ON_NOT_TRUE("XGetLaunchInfo()", (pLaunchData != NULL));

    if ((*LaunchDataPage) &&
        (((*LaunchDataPage)->Header.dwLaunchDataType == LDT_FROM_DASHBOARD) ||
         ((*LaunchDataPage)->Header.dwLaunchDataType == LDT_FROM_DEBUGGER_CMDLINE) ||
         ((*LaunchDataPage)->Header.dwTitleId == XeImageHeader()->Certificate->TitleID)))
    {
        PLAUNCH_DATA_PAGE pTemp;

        *pdwLaunchDataType = (*LaunchDataPage)->Header.dwLaunchDataType;
        memcpy(pLaunchData, (*LaunchDataPage)->LaunchData, sizeof(LAUNCH_DATA));

        pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_FOUND;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\lcompat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lcompat.c

Abstract:

    This module implements the _l and l compatability functions
    like _lread, lstrlen...

Author:

    Mark Lucovsky (markl) 13-Mar-1991

Revision History:

--*/

#include "basedll.h"
#ifdef _XBOX
#include "winnls.h"
#endif
#pragma hdrstop

#ifdef _XBOX
// Xbox-specific versions of CompareString (differ from Win32 version in that they don't need to
// have a locale specified, since the Xbox only has one locale supported).
extern int xCompareStringA(DWORD dwCmpFlags, LPCSTR psz1, int cch1, LPCSTR psz2, int cch2);
extern int xCompareStringW(DWORD dwCmpFlags, LPCTSTR psz1, int cch1, LPCTSTR psz2, int cch2);
#endif

int
APIENTRY
#ifdef LCOMPATA
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    int retval;

#ifdef _XBOX 	// Only one locale on the xbox
#ifdef LCOMPATA
    retval = xCompareStringA(
#else
    retval = xCompareStringW(
#endif
#else
#ifdef LCOMPATA
    retval = CompareStringA( GetThreadLocale(),
#else
    retval = CompareStringW( GetThreadLocale(),
#endif
#endif
                             0,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
#ifndef _XBOX
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 0,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
#endif
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
#ifdef LCOMPATA
            return ( strcmp(lpString1, lpString2) );
#else  // LCOMPATA
            return ( wcscmp(lpString1, lpString2) );
#endif // LCOMPATA
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
#ifdef LCOMPATA
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    int retval;

#ifdef _XBOX	 // Only one locale on the xbox
#ifdef LCOMPATA
    retval = xCompareStringA(
#else
    retval = xCompareStringW(
#endif
#else
#ifdef LCOMPATA
    retval = CompareStringA( GetThreadLocale(),
#else
    retval = CompareStringW( GetThreadLocale(),
#endif
#endif
                             NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
#ifndef _XBOX
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
#endif
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
#ifdef LCOMPATA
            return ( _stricmp(lpString1, lpString2) );
#else  // LCOMPATA
            return ( _wcsicmp(lpString1, lpString2) );
#endif // LCOMPATA
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}


#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    __try {
#ifdef LCOMPATA
        return strcpy(lpString1, lpString2);
#else  // LCOMPATA
        return wcscpy(lpString1, lpString2);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
#endif // LCOMPATA
{
#ifdef LCOMPATA
    LPSTR src,dst;
#else  // LCOMPATA
    LPWSTR src,dst;
#endif // LCOMPATA

    __try {
#ifdef LCOMPATA
        src = (LPSTR)lpString2;
#else  // LCOMPATA
        src = (LPWSTR)lpString2;
#endif // LCOMPATA
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
#ifdef LCOMPATA
                *dst = '\0';
#else  // LCOMPATA
                *dst = L'\0';
#endif // LCOMPATA
                }
            else {
                dst--;
#ifdef LCOMPATA
                *dst = '\0';
#else  // LCOMPATA
                *dst = L'\0';
#endif // LCOMPATA
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    __try {
#ifdef LCOMPATA
        return strcat(lpString1, lpString2);
#else  // LCOMPATA
        return wcscat(lpString1, lpString2);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
#ifdef LCOMPATA
lstrlenA(
    LPCSTR lpString
    )
#else  // LCOMPATA
lstrlenW(
    LPCWSTR lpString
    )
#endif // LCOMPATA
{
    if (!lpString)
        return 0;
    __try {
#ifdef LCOMPATA
        return strlen(lpString);
#else  // LCOMPATA
        return wcslen(lpString);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\lcompata.c ===
#include "basedll.h"
#pragma hdrstop

#define LCOMPATA
#include "lcompat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\makefile.inc ===
..\lcompata.c : ..\lcompat.c

..\compstra.c : ..\compstr.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\nickname.c ===
#include "basedll.h"

const OBJECT_STRING NickFile = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\UDATA\\NICKNAME.XBN"));

BOOL
WINAPI
XSetNicknameW(
    IN LPCWSTR lpNickname,
    IN BOOL fPreserveCase)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK Iosb;
    HANDLE FileHandle;
    X_NICK_DB_ENTRY Nicknames[NUM_NICK_ENTRIES];
    DWORD dwTitleID;

    RIP_ON_NOT_TRUE("XSetNicknameW()", (NULL != lpNickname));
    RIP_ON_NOT_TRUE("XSetNicknameW()", (wcslen(lpNickname) < MAX_NICKNAME));

    if (L'\0' == *lpNickname)
    {
        return FALSE;
    }

    dwTitleID = XeImageHeader()->Certificate->TitleID;

    InitializeObjectAttributes(&Obja, (POBJECT_STRING) &NickFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open an existing nickname file
    //

    Status = NtCreateFile(&FileHandle,
                          SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                          &Obja,
                          &Iosb,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(Status))
    {
        Status = NtReadFile(FileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &Iosb,
                            Nicknames,
                            sizeof(Nicknames),
                            NULL);

        if (NT_SUCCESS(Status) && (sizeof(Nicknames) != (DWORD) Iosb.Information))
        {
            //
            // We didn't read the right number of bytes, so don't do anything with this
            // data (the file will need to be recreated below)
            //
            Status = STATUS_END_OF_FILE;
        }

        if (NT_SUCCESS(Status))
        {
            WCHAR szNewNick[MAX_NICKNAME];
            int i;
            BOOL fNewEntry;

            lstrcpynW(szNewNick, lpNickname, ARRAYSIZE(szNewNick));

            //
            // Look to see if this nickname/titleid combo already exists in the table
            //

            for (i = 0; i < ARRAYSIZE(Nicknames); i++)
            {
                if ((FALSE != (fNewEntry = (L'\0' == Nicknames[i].szNickname[0]))) ||
                    ((dwTitleID == Nicknames[i].dwTitleID) &&
                        (0 == _wcsicmp(lpNickname, Nicknames[i].szNickname))))
                {
                    if (!fNewEntry && !fPreserveCase)
                    {
                        //
                        // The title didn't want us to preserve the case passed in, so
                        // use the name as it was last written instead
                        //

                        lstrcpynW(szNewNick, Nicknames[i].szNickname, ARRAYSIZE(szNewNick));
                    }
                    break;
                }
            }

            if (ARRAYSIZE(Nicknames) == i)
            {
                fNewEntry = TRUE;
            }

            if (!fNewEntry && (0 == i) && (0 == (wcscmp(szNewNick, Nicknames[0].szNickname))))
            {
                //
                // No change - the most recent nickname is exactly the same, so just close the file
                // and return TRUE without rewriting the exact same data.
                //

                NtClose(FileHandle);
                return TRUE;
            }

            if (0 != i)
            {
                //
                // Shift all of the entries further down the table to make room for this entry
                // at the top of the table
                //

                RtlMoveMemory(&(Nicknames[1]),
                              &(Nicknames[0]),
                              sizeof(X_NICK_DB_ENTRY) * min(i, ARRAYSIZE(Nicknames) - 1));
            }

            //
            // Write the new entry at the top of the table
            //

            Nicknames[0].dwTitleID = dwTitleID;
            lstrcpynW(Nicknames[0].szNickname, szNewNick, ARRAYSIZE(Nicknames[0].szNickname));
        }
        else
        {
            NtClose(FileHandle);
        }
    }
    else if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // The open failed for an unexpected reason - we don't want to proceed and
        // overwrite a valid nickname file...
        //

        return FALSE;
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Attempt to create a new nickname file
        //

        Status = NtCreateFile(&FileHandle,
                              SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                              &Obja,
                              &Iosb,
                              NULL,
                              FILE_ATTRIBUTE_SYSTEM,
                              FILE_SHARE_READ,
                              FILE_OVERWRITE_IF,
                              FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT);

        if (NT_SUCCESS(Status))
        {
            //
            // Zero out the memory that we're going to write to the file
            //

            RtlZeroMemory(&Nicknames, sizeof(Nicknames));

            //
            // Write the new entry at the top of the table
            //

            Nicknames[0].dwTitleID = dwTitleID;
            lstrcpynW(Nicknames[0].szNickname, lpNickname, ARRAYSIZE(Nicknames[0].szNickname));
        }
    }

    if (NT_SUCCESS(Status))
    {
        //
        // We have a valid FileHandle and Nicknames array at this point.
        // It is time to write it back to disk and close the file..
        //

        LARGE_INTEGER liByteOffset;

        liByteOffset.QuadPart = 0;
        
        Status = NtWriteFile(FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             Nicknames,
                             sizeof(Nicknames),
                             &liByteOffset);

        NtClose(FileHandle);
    }

    return(NT_SUCCESS(Status));
}

BOOL
GetNextNickname(
    PFINDNICKNAME_HANDLE pFindNick,
    LPWSTR lpNickname,
    UINT uSize)
{
    DWORD dwTitleID;

    ASSERT(pFindNick && (FH_SIG_NICKNAME == pFindNick->dwSignature));

    dwTitleID = XeImageHeader()->Certificate->TitleID;

    for (; pFindNick->uCurIndex < ARRAYSIZE(pFindNick->Nicknames); (pFindNick->uCurIndex)++)
    {
        if ((L'\0' != pFindNick->Nicknames[pFindNick->uCurIndex].szNickname[0]) &&
            (wcslen(pFindNick->Nicknames[pFindNick->uCurIndex].szNickname) < uSize) &&
            (!pFindNick->fThisTitleOnly ||
             (dwTitleID == pFindNick->Nicknames[pFindNick->uCurIndex].dwTitleID)))
        {
            BOOL fPrevMatch = FALSE;
#if DBG
            //
            // Always check for previous matches in the debug build
            // (so we can validate that the nickfile doesn't have duplicates with
            // the same title id)
            //
#else  // DBG
            //
            // If we're searching all title's, we need to check for previous matches
            // so that we don't return duplicate names (the same name can appear
            // many times with a different title id each time)
            //
            if (!pFindNick->fThisTitleOnly)
#endif // DBG
            {
                UINT uCompIndex;
                for (uCompIndex = 0; uCompIndex < pFindNick->uCurIndex; uCompIndex++)
                {
                    if (0 == _wcsicmp(pFindNick->Nicknames[pFindNick->uCurIndex].szNickname,
                                      pFindNick->Nicknames[uCompIndex].szNickname))
                    {
                        fPrevMatch = TRUE;
                        break;
                    }
                }
            }

            if (pFindNick->fThisTitleOnly || !fPrevMatch)
            {
#if DBG
                if (pFindNick->fThisTitleOnly && fPrevMatch)
                {
                    XDBGERR("XAPI", "XFindNextNicknameW() found corrupt data (duplicate nicknames)");
                }
#endif // DBG
                wcscpy(lpNickname, pFindNick->Nicknames[pFindNick->uCurIndex].szNickname);
                (pFindNick->uCurIndex)++;
                return TRUE;
            }
        }
    }
    
    return FALSE;    
}

HANDLE
WINAPI
XFindFirstNicknameW(
    IN BOOL fThisTitleOnly,
    OUT LPWSTR lpNickname,
    IN UINT uSize)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK Iosb;
    HANDLE FileHandle;
    PFINDNICKNAME_HANDLE pFindNick = NULL;
    
    RIP_ON_NOT_TRUE("XFindFirstNicknameW()", (NULL != lpNickname));

    InitializeObjectAttributes(&Obja, (POBJECT_STRING) &NickFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open an existing nickname file
    //
    
    Status = NtCreateFile(&FileHandle,
                          SYNCHRONIZE | GENERIC_READ,
                          &Obja,
                          &Iosb,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(Status))
    {
        pFindNick = LocalAlloc(LMEM_FIXED, sizeof(FINDNICKNAME_HANDLE));
        
        if (pFindNick)
        {
            pFindNick->dwSignature = FH_SIG_NICKNAME;
            pFindNick->uCurIndex = 0;
            pFindNick->fThisTitleOnly = fThisTitleOnly;
            
            Status = NtReadFile(FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &Iosb,
                                pFindNick->Nicknames,
                                sizeof(pFindNick->Nicknames),
                                NULL);

            if (NT_SUCCESS(Status) && (sizeof(pFindNick->Nicknames) != (DWORD) Iosb.Information))
            {
                //
                // We didn't read the right number of bytes, so don't do anything with this
                // data (the file will need to be recreated below)
                //
                Status = STATUS_END_OF_FILE;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        NtClose(FileHandle);
    }

    if (NT_SUCCESS(Status))
    {
        if (!GetNextNickname(pFindNick, lpNickname, uSize))
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status) && (NULL != pFindNick))
    {
        LocalFree(pFindNick);
        pFindNick = NULL;
    }

    return (HANDLE) (pFindNick ? pFindNick : INVALID_HANDLE_VALUE);
}

BOOL
WINAPI
XFindNextNicknameW(
    IN HANDLE hFindNickname,
    OUT LPWSTR lpNickname,
    IN UINT uSize)
{
    PFINDNICKNAME_HANDLE pFindNick = (PFINDNICKNAME_HANDLE) hFindNickname;

    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (NULL != hFindNickname));
    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (INVALID_HANDLE_VALUE != hFindNickname));
    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (NULL != lpNickname));

#if DBG
    if (FH_SIG_NICKNAME != pFindNick->dwSignature)
    {
        RIP("XFindNextNicknameW() - invalid parameter (hFindNickname)");
    }
#endif // DBG
    
    return GetNextNickname(pFindNick, lpNickname, uSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\mmtimer.c ===
/*++

Copyright (c) 1985-2000  Microsoft Corporation

Module Name:

    mmtimer.c

Abstract:

    This module implements the Win32 multimedia timer services.

--*/

#include "basedll.h"

//
// Define the maximum number of multimedia timers allowed.
//

#define MAXIMUM_MMTIMERS                (MAXIMUM_WAIT_OBJECTS - 1)

//
// Structure used to bind the parameters from timeSetEvent to its corresponding
// kernel timer object.
//

#include <pshpack4.h>

typedef struct _MMTIMER {
    KTIMER KernelTimer;
    LPTIMECALLBACK lpTimeCallback;
    DWORD dwTimeCallbackData;
    BOOLEAN Allocated;
    UCHAR Flags;
    USHORT SerialNumber;
    LARGE_INTEGER FireTime;
    LARGE_INTEGER Interval;
} MMTIMER, *PMMTIMER;

#include <poppack.h>

//
// Structure used to bind all of the timer state that is allocated on the timer
// thread's stack.
//

typedef struct _MMTIMER_THREAD_STATE {
    MMTIMER Timers[MAXIMUM_MMTIMERS];
    KEVENT ThreadEvent;
} MMTIMER_THREAD_STATE, *PMMTIMER_THREAD_STATE;

INITIALIZED_CRITICAL_SECTION(XapiMmTimerCriticalSection);
USHORT XapiMmTimerSerialNumber;
PMMTIMER_THREAD_STATE XapiMmTimerThreadState;

DWORD
WINAPI
XapiMmTimerThread(
    LPVOID lpThreadParameter
    )
{
    ULONG Index;
    MMTIMER_THREAD_STATE MmTimerThreadState;
    KWAIT_BLOCK WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
    USHORT SerialNumbers[MAXIMUM_WAIT_OBJECTS];
    ULONG WaitObjectCount;
    NTSTATUS status;
    PMMTIMER MmTimer;
    LPTIMECALLBACK lpTimeCallback;
    DWORD dwTimeCallbackData;
    UINT uTimerID;
    UINT fuEvent;
    LARGE_INTEGER DueTime;

    //
    // Initialize the event used to signal that this thread needs to rebuild its
    // wait object array.
    //

    KeInitializeEvent(&MmTimerThreadState.ThreadEvent, SynchronizationEvent,
        FALSE);

    //
    // Initialize the kernel timers.
    //

    for (Index = 0; Index < MAXIMUM_MMTIMERS; Index++) {
        KeInitializeTimerEx(&MmTimerThreadState.Timers[Index].KernelTimer,
            SynchronizationTimer);
        MmTimerThreadState.Timers[Index].Allocated = FALSE;
    }

    //
    // The thread's state is now initialized.  Notify the thread that created us
    // that we're ready.
    //

    XapiMmTimerThreadState = &MmTimerThreadState;

    KeSetEvent((PKEVENT)lpThreadParameter, EVENT_INCREMENT, FALSE);

    //
    // Initially, we wait on only our thread event.
    //

    WaitObjects[0] = &MmTimerThreadState.ThreadEvent;
    WaitObjectCount = 1;

    for (;;) {

        //
        // Wait to be notified of the arrival or removal of a timer or for a
        // timer to be signaled.
        //

        status = KeWaitForMultipleObjects(WaitObjectCount, WaitObjects, WaitAny,
            UserRequest, UserMode, FALSE, NULL, WaitBlocks);

        if (status == STATUS_WAIT_0) {

            //
            // We've been signaled due to an addition or removal of a timer
            // from our thread state structure.  Recompute the local wait object
            // array.
            //

            EnterCriticalSection(&XapiMmTimerCriticalSection);

RecomputeWaitObjects:
            WaitObjectCount = 1;

            for (Index = 0; Index < MAXIMUM_WAIT_OBJECTS - 1; Index++) {

                //
                // If the timer has been allocated, add it to the wait object
                // array and capture the timer's serial number.  We need the
                // serial number to deal with a race where this thread is woken
                // in response to a signaled timer and another thread has
                // already called timeKillEvent.
                //

                if (MmTimerThreadState.Timers[Index].Allocated) {
                    SerialNumbers[WaitObjectCount] =
                        MmTimerThreadState.Timers[Index].SerialNumber;
                    WaitObjects[WaitObjectCount] =
                        &MmTimerThreadState.Timers[Index].KernelTimer;
                    WaitObjectCount++;
                }
            }

            LeaveCriticalSection(&XapiMmTimerCriticalSection);

        } else if (status >= STATUS_WAIT_1 && status < (STATUS_WAIT_1 +
            MAXIMUM_MMTIMERS)) {

            //
            // We've been signaled due to a timer firing.  Verify that the timer
            // is still allocated and that the serial number matches what we
            // think it should be.
            //

            EnterCriticalSection(&XapiMmTimerCriticalSection);

            MmTimer = CONTAINING_RECORD(WaitObjects[status], MMTIMER, KernelTimer);

            if (MmTimer->Allocated &&
                (MmTimer->SerialNumber == SerialNumbers[status])) {

                //
                // The timer is still allocated.  Depending on the timer flags,
                // either set an event, pulse an event, or invoke a callback.
                //

                fuEvent = (UINT)MmTimer->Flags;

                if ((fuEvent & TIME_CALLBACK_EVENT_SET) != 0) {

                    NtSetEvent((HANDLE)MmTimer->lpTimeCallback, NULL);

                } else if ((fuEvent & TIME_CALLBACK_EVENT_PULSE) != 0) {

                    NtPulseEvent((HANDLE)MmTimer->lpTimeCallback, NULL);

                } else {

                    //
                    // Capture the timer data to the stack so that we can invoke
                    // the callback outside of the critical section.
                    //

                    lpTimeCallback = MmTimer->lpTimeCallback;
                    dwTimeCallbackData = MmTimer->dwTimeCallbackData;
                    Index = MmTimer - &MmTimerThreadState.Timers[0];
                    uTimerID = MAKELONG(Index + 1, MmTimer->SerialNumber);

                    LeaveCriticalSection(&XapiMmTimerCriticalSection);

                    //
                    // Invoke the callback.  The callback or another thread may
                    // end up calling timeKillEvent for our timer ID so we can't
                    // touch the MMTIMER structure until we validate it again.
                    //

                    lpTimeCallback(uTimerID, 0, dwTimeCallbackData, 0, 0);

                    //
                    // Reenter the critical section and verify that the timer
                    // hasn't been killed.
                    //

                    EnterCriticalSection(&XapiMmTimerCriticalSection);

                    if (!MmTimer->Allocated ||
                        (MmTimer->SerialNumber != SerialNumbers[status])) {
                        LeaveCriticalSection(&XapiMmTimerCriticalSection);
                        continue;
                    }
                }

                if ((fuEvent & TIME_PERIODIC) != 0) {

                    //
                    // Initialize the timer with its new due time.  If the timer
                    // has already expired, then set the due time to zero so
                    // that we can immediately wake up and process the timer
                    // again.
                    //

                    MmTimer->FireTime.QuadPart -= MmTimer->Interval.QuadPart;

                    DueTime.QuadPart = KeQueryInterruptTime() -
                        MmTimer->FireTime.QuadPart;

                    if (DueTime.QuadPart > 0) {
                        DueTime.QuadPart = 0;
                    }

                    KeSetTimerEx(&MmTimer->KernelTimer, DueTime, 0, NULL);

                } else {

                    //
                    // Mark the timer as unallocated.
                    //

                    MmTimer->Allocated = FALSE;

                    //
                    // Jump into the code to recompute the wait objects array.
                    //

                    goto RecomputeWaitObjects;
                }
            }

            LeaveCriticalSection(&XapiMmTimerCriticalSection);

        } else {
            XDBGERR("XAPI", "XapiMmTimerThread woke for unexpected reason: %08x\n", status);
        }
    }
}

UINT
WINAPI
timeSetEvent(
    UINT uDelay,
    UINT uResolution,
    LPTIMECALLBACK lpTimeCallback,
    DWORD dwTimeCallbackData,
    UINT fuEvent
    )
{
    KEVENT ThreadReadyEvent;
    HANDLE hThread;
    ULONG Index;
    UINT uTimerID;
    PMMTIMER MmTimer;
    USHORT SerialNumber;

    EnterCriticalSection(&XapiMmTimerCriticalSection);

    //
    // Check if the multimedia timer thread has been started yet.
    //

    if (XapiMmTimerThreadState == NULL) {

        //
        // Create an event that the multimedia timer thread will signal when it
        // has finished initializating itself.
        //

        KeInitializeEvent(&ThreadReadyEvent, NotificationEvent, FALSE);

        //
        // Create the multimedia timer thread with the default stack size for
        // the title.
        //

        hThread = CreateThread(NULL, 0, XapiMmTimerThread, &ThreadReadyEvent, 0,
            NULL);

        if (hThread == NULL) {
            XDBGERR("XAPI", "XapiMmTimerThread cannot be created\n");
            LeaveCriticalSection(&XapiMmTimerCriticalSection);
            return 0;
        }

        CloseHandle(hThread);

        //
        // Wait for the multimedia timer thread to initialize itself.
        //

        KeWaitForSingleObject(&ThreadReadyEvent, Executive, UserMode, FALSE,
            NULL);

        //
        // At this point, the global timer thread state should have been filled
        // in.
        //

        ASSERT(XapiMmTimerThreadState != NULL);
    }

    uTimerID = 0;

    for (Index = 0; Index < MAXIMUM_WAIT_OBJECTS - 1; Index++) {

        if (!XapiMmTimerThreadState->Timers[Index].Allocated) {

            SerialNumber = XapiMmTimerSerialNumber++;

            MmTimer = &XapiMmTimerThreadState->Timers[Index];

            MmTimer->Allocated = TRUE;
            MmTimer->Flags = (UCHAR)fuEvent;
            MmTimer->SerialNumber = SerialNumber;
            MmTimer->lpTimeCallback = lpTimeCallback;
            MmTimer->dwTimeCallbackData = dwTimeCallbackData;

            //
            // Compute the initial due time for the timer and start the timer.
            //
            // We track the fire time and period interval ourselves instead of
            // using the period functionality of the kernel timer to avoid
            // timer drift that can occur.
            //

            MmTimer->Interval.QuadPart = -10000 * (LONGLONG)uDelay;

            MmTimer->FireTime.QuadPart = KeQueryInterruptTime() -
                MmTimer->Interval.QuadPart;

            KeSetTimerEx(&MmTimer->KernelTimer, MmTimer->Interval, 0, NULL);

            //
            // Signal the multimedia timer thread that it needs to add a timer
            // to its wait list.
            //

            KeSetEvent(&XapiMmTimerThreadState->ThreadEvent, EVENT_INCREMENT,
                FALSE);

            uTimerID = MAKELONG(Index + 1, SerialNumber);
            break;
        }
    }

    LeaveCriticalSection(&XapiMmTimerCriticalSection);

    return uTimerID;
}

MMRESULT
WINAPI
timeKillEvent(
    UINT uTimerID
    )
{
    MMRESULT mmresult;
    ULONG Index;
    PMMTIMER MmTimer;

    EnterCriticalSection(&XapiMmTimerCriticalSection);

    Index = LOWORD(uTimerID) - 1;

    //
    // Validate that this is a legal timer identifier.  The timer thread must be
    // already running in order to have obtained a valid identifier from
    // timeSetEvent.  The timer identifier must be in legal range and the timer
    // must be marked as having been allocated.
    //

    if ((XapiMmTimerThreadState != NULL) && (Index < MAXIMUM_MMTIMERS) &&
        XapiMmTimerThreadState->Timers[Index].Allocated &&
        XapiMmTimerThreadState->Timers[Index].SerialNumber == HIWORD(uTimerID)) {

        //
        // Cancel the timer and mark the timer as unallocated.
        //

        MmTimer = &XapiMmTimerThreadState->Timers[Index];

        KeCancelTimer(&MmTimer->KernelTimer);

        MmTimer->Allocated = FALSE;

        //
        // Signal the multimedia timer thread that it needs to remove a timer
        // from its wait list.
        //

        KeSetEvent(&XapiMmTimerThreadState->ThreadEvent, EVENT_INCREMENT, FALSE);

        mmresult = MMSYSERR_NOERROR;

    } else {
        mmresult = TIMERR_NOCANDO;
    }

    LeaveCriticalSection(&XapiMmTimerCriticalSection);

    return mmresult;
}

MMRESULT
WINAPI
timeGetSystemTime(
    LPMMTIME lpTime,
    UINT wSize
    )
{
    lpTime->u.ms = NtGetTickCount();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\perfctr.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    perfctr.c

Abstract:

    This module contains the Win32 Performance Counter APIs

--*/

#include "basedll.h"

__declspec(naked)
BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    )
/*++

    QueryPerformanceCounter -   provides access to a high-resolution
                                counter; frequency of this counter
                                is supplied by QueryPerformanceFrequency

        Inputs:

            lpPerformanceCount  -   a pointer to variable which
                                    will receive the counter

        Outputs:

            lpPerformanceCount  -   the current value of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.


--*/
{
    __asm {
        mov     ecx, DWORD PTR [esp+4]  // ecx = lpPerformanceCount
        rdtsc
        mov     DWORD PTR [ecx], eax
        mov     DWORD PTR [ecx+4], edx
        xor     eax, eax
        inc     eax                     // return TRUE;
        ret     4
    }
}

BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    )
/*++

    QueryPerformanceFrequency -   provides the frequency of the high-
                                  resolution counter returned by
                                  QueryPerformanceCounter

        Inputs:

            lpFrequency         -   a pointer to variable which
                                    will receive the frequency

        Outputs:

            lpPerformanceCount  -   the frequency of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.

--*/
{
    lpFrequency->QuadPart = 733333333i64;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\pathmisc.c ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    pathmisc.c

Abstract:

    Win32 miscellaneous path functions

--*/

#include "basedll.h"
#include <xboxp.h>
#include <xdisk.h>
#include <xconfig.h>
#include "xmeta.h"
#include "..\..\fatx\fat.h"

static const OBJECT_STRING ZDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\Z:") );
static const OCHAR CacheDriveFormat[]  = OTEXT("\\Device\\Harddisk0\\Partition%d\\");
static COBJECT_STRING WDrive           = CONSTANT_OBJECT_STRING( OTEXT("\\??\\W:") );
static COBJECT_STRING XDrive           = CONSTANT_OBJECT_STRING( OTEXT("\\??\\X:") );

#ifdef XAPILIBP

extern XAPI_MU_INFO XapiMuInfo;

#else  // XAPILIBP

XAPI_MU_INFO XapiMuInfo = {0};
#if DBG
BOOL g_fMountedUtilityDrive = FALSE;
#endif // DBG

#endif // XAPILIBP

//
//  Define the FAT32 X-Box cache db sector
//

typedef struct _XBOX_CACHE_DB_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    ULONG Version;                                  // offset = 0x004   4
    UCHAR Data[496];                                // offset = 0x008   8
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} XBOX_CACHE_DB_SECTOR, *PXBOX_CACHE_DB_SECTOR;

#define XBOX_HD_SECTOR_SIZE                    512

#define XBOX_CACHE_DB_DATA_SIZE                (sizeof(((PXBOX_CACHE_DB_SECTOR) 0)->Data))

#define XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE   0x97315286
#define XBOX_CACHE_DB_SECTOR_END_SIGNATURE     0xAA550000
#define XBOX_CACHE_DB_CUR_VERSION              0x00000002
#define XBOX_CACHE_DB_MAX_ENTRY_COUNT          (XBOX_CACHE_DB_DATA_SIZE / sizeof(X_CACHE_DB_ENTRY))

#ifndef XAPILIBP

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceEx(
    PCOSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    ULARGE_INTEGER BytesPerAllocationUnit;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;

    RIP_ON_NOT_TRUE("GetDiskFreeSpaceEx()", ARGUMENT_PRESENT(lpDirectoryName));

    RtlInitObjectString(&FileName, lpDirectoryName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return FALSE;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    BytesPerAllocationUnit.QuadPart =
        NormalSizeInfo.BytesPerSector * NormalSizeInfo.SectorsPerAllocationUnit;

    FreeBytesAvailableToCaller.QuadPart =
        BytesPerAllocationUnit.QuadPart * NormalSizeInfo.AvailableAllocationUnits.QuadPart;

    TotalNumberOfBytes.QuadPart =
        BytesPerAllocationUnit.QuadPart * NormalSizeInfo.TotalAllocationUnits.QuadPart;

    if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
        lpFreeBytesAvailableToCaller->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
        lpTotalNumberOfBytes->QuadPart = TotalNumberOfBytes.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {
        lpTotalNumberOfFreeBytes->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }

    return TRUE;
}


BOOL
APIENTRY
GetVolumeInformation(
    PCOSTR lpRootPathName,
    POSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    POSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    This function returns information about the file system whose root
    directory is specified.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the file system that information is to be
        returned about.  If this parameter is not specified, then the
        root of the current directory is used.

    lpVolumeNameBuffer - An optional parameter that if specified returns
        the name of the specified volume.

    nVolumeNameSize - Supplies the length of the volume name buffer.
        This parameter is ignored if the volume name buffer is not
        supplied.

    lpVolumeSerialNumber - An optional parameter that if specified
        points to a DWORD.  The DWORD contains the 32-bit of the volume
        serial number.

    lpMaximumComponentLength - An optional parameter that if specified
        returns the maximum length of a filename component supported by
        the specified file system.  A filename component is that portion
        of a filename between pathname seperators.

    lpFileSystemFlags - An optional parameter that if specified returns
        flags associated with the specified file system.

        lpFileSystemFlags Flags:

            FS_CASE_IS_PRESERVED - Indicates that the case of file names
                is preserved when the name is placed on disk.

            FS_CASE_SENSITIVE - Indicates that the file system supports
                case sensitive file name lookup.

            FS_UNICODE_STORED_ON_DISK - Indicates that the file system
                supports unicode in file names as they appear on disk.

    lpFileSystemNameBuffer - An optional parameter that if specified returns
        the name for the specified file system (e.g. FAT, HPFS...).

    nFileSystemNameSize - Supplies the length of the file system name
        buffer.  This parameter is ignored if the file system name
        buffer is not supplied.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG AttributeInfoLength;
    ULONG VolumeInfoLength;
    BOOL rv;

    rv = FALSE;

    nVolumeNameSize *= 2;
    nFileSystemNameSize *= 2;

    RIP_ON_NOT_TRUE("GetVolumeInformation()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    AttributeInfo = NULL;
    VolumeInfo = NULL;

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ||
         ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            VolumeInfoLength = sizeof(*VolumeInfo)+nVolumeNameSize;
            }
        else {
            VolumeInfoLength = sizeof(*VolumeInfo)+MAX_PATH;
            }
        VolumeInfo = RtlAllocateHeap(XapiProcessHeap, 0, VolumeInfoLength);

        if ( !VolumeInfo ) {
            NtClose(Handle);
            XapiSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ||
         ARGUMENT_PRESENT(lpMaximumComponentLength) ||
         ARGUMENT_PRESENT(lpFileSystemFlags) ) {
        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            AttributeInfoLength = sizeof(*AttributeInfo) + nFileSystemNameSize;
            }
        else {
            AttributeInfoLength = sizeof(*AttributeInfo) + MAX_PATH;
            }
        AttributeInfo = RtlAllocateHeap(XapiProcessHeap, 0, AttributeInfoLength);
        if ( !AttributeInfo ) {
            NtClose(Handle);
            if ( VolumeInfo ) {
                RtlFreeHeap(XapiProcessHeap, 0,VolumeInfo);
                }
            XapiSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    try {
        if ( VolumeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        VolumeInfo,
                        VolumeInfoLength,
                        FileFsVolumeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }

        if ( AttributeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        AttributeInfo,
                        AttributeInfoLength,
                        FileFsAttributeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }
        try {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                if ( VolumeInfo->VolumeLabelLength >= nVolumeNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpVolumeNameBuffer,
                                   VolumeInfo->VolumeLabel,
                                   VolumeInfo->VolumeLabelLength );

                    *(lpVolumeNameBuffer + (VolumeInfo->VolumeLabelLength / sizeof(OCHAR))) = OBJECT_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
                *lpVolumeSerialNumber = VolumeInfo->VolumeSerialNumber;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {

                if ( AttributeInfo->FileSystemNameLength >= nFileSystemNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpFileSystemNameBuffer,
                                   AttributeInfo->FileSystemName,
                                   AttributeInfo->FileSystemNameLength );

                    *(lpFileSystemNameBuffer + (AttributeInfo->FileSystemNameLength / sizeof(OCHAR))) = OBJECT_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpMaximumComponentLength) ) {
                *lpMaximumComponentLength = AttributeInfo->MaximumComponentNameLength;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemFlags) ) {
                *lpFileSystemFlags = AttributeInfo->FileSystemAttributes;
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            XapiSetLastNTError(STATUS_ACCESS_VIOLATION);
            return FALSE;
            }
        rv = TRUE;
finally_exit:;
        }
    finally {
        NtClose(Handle);
        if ( VolumeInfo ) {
            RtlFreeHeap(XapiProcessHeap, 0,VolumeInfo);
            }
        if ( AttributeInfo ) {
            RtlFreeHeap(XapiProcessHeap, 0,AttributeInfo);
            }
        }
    return rv;
}

NTSTATUS
XapiSelectCachePartition(
    IN BOOL fAlwaysFormat,
    OUT PULONG pnCachePartition,
    OUT PBOOL pfForceFormat
    )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    DWORD             dwTitleId = XeImageHeader()->Certificate->TitleID;
    ULONG             CachePartitionCount;
    ULONG             nCachePartition;

    ASSERT(pnCachePartition && pfForceFormat);

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;
            ULONG iPrevDBIndex = (*HalDiskCachePartitionCount - 1);
            ULONG iNewDBIndex;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                RtlZeroMemory(rgbSectorBuffer, sizeof(rgbSectorBuffer));

                pCacheDBSec->SectorBeginSignature = XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE;
                pCacheDBSec->Version = XBOX_CACHE_DB_CUR_VERSION;
                pCacheDBSec->SectorEndSignature = XBOX_CACHE_DB_SECTOR_END_SIGNATURE;
            }

            //
            // Assume that we're going to force the partition to be formatted unless
            // we find out otherwise
            //

            *pfForceFormat = TRUE;

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            nCachePartition = 0;

            //
            // Search for a cache partition already allocated by this title
            //
            
            for (i = 0; i < CachePartitionCount; i++)
            {
                if ((dwTitleId == pCacheDB[i].dwTitleId) && pCacheDB[i].fUsed)
                {
                    nCachePartition = pCacheDB[i].nCacheIndex + XDISK_FIRST_CACHE_PARTITION;
                    iPrevDBIndex = i;
                    
                    //
                    // We found an existing cache partition, there is no longer a
                    // requirement that the partition be formatted.
                    //

                    *pfForceFormat = FALSE;
                    
                    break;
                }
            }

            //
            // If that search failed, search for a cache partition that is not in use
            // using ugly n-squared algorithm (fortunately, CachePartitionCount is small)
            //
            
            if (0 == nCachePartition)
            {
                UINT j;
                for (j = 0; j < CachePartitionCount; j++)
                {
                    for (i = 0; i < CachePartitionCount; i++)
                    {
                        if ((pCacheDB[i].fUsed) && (pCacheDB[i].nCacheIndex == j))
                        {
                            break;
                        }
                    }

                    //
                    // If we made it through the loop without a match, then this
                    // cache partition (index stored in the j variable) is available
                    //
                    
                    if (i == CachePartitionCount)
                    {
                        nCachePartition = j + XDISK_FIRST_CACHE_PARTITION;
                    }
                }
            }
                
            //
            // If that search failed, grab the oldest cache partition
            //
            // The Cache DB is stored in MRU order - the first entry was the most recently
            // used and the last entry was the least recently used
            //
            
            if (0 == nCachePartition)
            {
                nCachePartition = pCacheDB[CachePartitionCount - 1].nCacheIndex + XDISK_FIRST_CACHE_PARTITION;
            }

            //
            // If the value we've chosen is too large for some reason, pull it back and give
            // it a reasonable value
            //
            
            if (nCachePartition >= CachePartitionCount + XDISK_FIRST_CACHE_PARTITION)
            {
                nCachePartition = (CachePartitionCount - 1) + XDISK_FIRST_CACHE_PARTITION;
            }

            ASSERT(nCachePartition != 0);
            *pnCachePartition = nCachePartition;

            //
            // Normally, we bump this to the top of the cache db because that is how we
            // indicate that it was most recently used.  When fAlwaysFormat is set, we
            // always put it at the end of the list because we want it to be reclaimed
            // when the next title asks for a cache partition
            //
            
            iNewDBIndex = fAlwaysFormat ? (CachePartitionCount - 1) : 0;

            if (!fAlwaysFormat && (0 != iPrevDBIndex))
            {
                //
                // Modify the cache db - slide everything down and make room for this
                // entry at the top of the list
                //

                ASSERT(iPrevDBIndex < CachePartitionCount);
                
                RtlMoveMemory(&(pCacheDB[1]),
                              &(pCacheDB[0]),
                              iPrevDBIndex * sizeof(X_CACHE_DB_ENTRY));
            }
            
            //
            // Write this entry into the new index of the cache db
            //
            // Note that if this function was called with fAlwaysFormat set to TRUE,
            // the entry will be marked with fUsed == FALSE, so that it will be chosen
            // first the next time a title needs to allocate a new partition
            //

            pCacheDB[iNewDBIndex].dwTitleId = dwTitleId;
            pCacheDB[iNewDBIndex].nCacheIndex = (nCachePartition - XDISK_FIRST_CACHE_PARTITION);
            pCacheDB[iNewDBIndex].fUsed = (!fAlwaysFormat);

            //
            // Ignore status result
            //

            NtWriteFile(hVolume,
                        0,
                        NULL,
                        NULL,
                        &statusBlock,
                        rgbSectorBuffer,
                        sizeof(rgbSectorBuffer),
                        &byteOffset);
        }

        NtClose(hVolume);
    }

    return Status;
}


BOOL
WINAPI
XMountUtilityDrive(
    BOOL fFormatClean
    )
{
    BOOL fRet = TRUE;
    BOOL fForceFormat;
    ULONG nPartition;
    NTSTATUS Status;

#if DBG
    if (g_fMountedUtilityDrive)
    {
        RIP("XMountUtilityDrive(): Utility Drive has already been mounted");
    }
#endif // DBG

    Status = XapiSelectCachePartition(fFormatClean, &nPartition, &fForceFormat);

    if (NT_SUCCESS(Status))
    {
        OCHAR szCacheDrive[MAX_PATH];
        OBJECT_STRING VolString, DriveString;
        BOOL fDoFormat = (fFormatClean || fForceFormat);
        ULONG BytesPerCluster = XeUtilityDriveClusterSize();

        _snoprintf(szCacheDrive,
                   ARRAYSIZE(szCacheDrive),
                   CacheDriveFormat,
                   nPartition);

        RtlInitObjectString(&VolString, szCacheDrive);

        //
        // The DriveString should not end in a backslash, so init from the same
        // string, but subtract a character on the Length member.
        //

        RtlInitObjectString(&DriveString, szCacheDrive);
        DriveString.Length -= sizeof(OCHAR);

        if (fDoFormat)
        {
            fRet = XapiFormatFATVolumeEx(&DriveString, BytesPerCluster);
        }

        if (fRet)
        {
            Status = XapiValidateDiskPartitionEx(&VolString, BytesPerCluster);

            if (!NT_SUCCESS(Status) && !fDoFormat)
            {
                //
                // If the validate failed for some reason and we didn't just format
                // the partition, go ahead and format it now (make the system more
                // self-healing)
                //

                if (XapiFormatFATVolumeEx(&DriveString, BytesPerCluster))
                {
                    Status = XapiValidateDiskPartitionEx(&VolString, BytesPerCluster);
                }
            }

            if (NT_SUCCESS(Status))
            {
                // Give the cache partition a drive letter
                Status = IoCreateSymbolicLink((POBJECT_STRING) &ZDrive, &DriveString);
            }

            fRet = NT_SUCCESS(Status);

            if (!fRet)
            {
                XapiSetLastNTError(Status);
            }
        }
    }
    else
    {
        fRet = FALSE;
        XapiSetLastNTError(Status);
    }

#if DBG
    if (fRet)
    {
        g_fMountedUtilityDrive = TRUE;
    }
#endif // DBG

    return fRet;
}


BOOL
WINAPI
XFormatUtilityDrive(
    VOID
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CHAR Target[MAX_PATH];
    ULONG TargetLength;
    OBJECT_STRING ObjectTarget;
    HANDLE Handle;

#if DBG
    if (!g_fMountedUtilityDrive)
    {
        RIP("XFormatUtilityDrive(): Utility Drive has not been mounted");
    }
#endif // DBG

    InitializeObjectAttributes(&ObjectAttributes,
                               (POBJECT_STRING) &ZDrive,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return FALSE;
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target);

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return FALSE;
    }

    return XapiFormatFATVolumeEx(&ObjectTarget, XeUtilityDriveClusterSize());
}


DWORD
WINAPI
XMountAlternateTitle(
    IN PCOSTR lpRootPath,
    IN DWORD dwAltTitleId,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING ObjectName;
    OCHAR szDosDevice[MAX_PATH];
    OCHAR Target[MAX_PATH];
    ULONG TargetLength;
    OBJECT_STRING ObjectTarget;
    OCHAR AltTitleId[CCHMAX_HEX_DWORD];
    HANDLE Handle;
    OCHAR chDrive;
    BOOL fTData;
    PXBEIMAGE_CERTIFICATE Certificate = XeImageHeader()->Certificate;
    int i;

    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath != NULL));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[0] != '\0'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[1] == ':'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[2] == '\\'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[3] == '\0'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (pchDrive != NULL));

    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive = lpRootPath[0] & (~0x20);
    fTData = (HD_TDATA_DRIVE == chDrive);

#if DBG
    if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
        (HD_UDATA_DRIVE != chDrive) &&
        (!fTData))
    {
        RIP("XFindFirstSaveGame() invalid drive letter parameter");
    }
#endif // DBG

    for (i = 0; i < ARRAYSIZE(Certificate->AlternateTitleIDs); i++)
    {
        if (0 == Certificate->AlternateTitleIDs[i])
        {
            return ERROR_ACCESS_DENIED;
        }

        if (dwAltTitleId == Certificate->AlternateTitleIDs[i])
        {
            break;
        }
    }

    if (i >= sizeof(Certificate->AlternateTitleIDs))
    {
        return ERROR_ACCESS_DENIED;
    }

    soprintf(szDosDevice, OTEXT("\\??\\%c:"), lpRootPath[0]);

    RtlInitObjectString(&ObjectName, szDosDevice);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target);

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    if ((TargetLength < CCHMAX_HEX_DWORD) ||
        ('\\' != Target[TargetLength - (CCHMAX_HEX_DWORD)]))
    {
        return ERROR_INVALID_DRIVE;
    }

    //
    // Remove the existing title id from the end of the string so we can
    // reuse ObjectTarget below in XapiMapLetterToDirectory()
    //

    ObjectTarget.Length -= CCHMAX_HEX_DWORD;

    DwordToStringO(dwAltTitleId, AltTitleId);

    status = XapiMapLetterToDirectory(fTData ? &WDrive : &XDrive,
                                      (PCOBJECT_STRING) &ObjectTarget,
                                      AltTitleId,
                                      FALSE,
                                      NULL,
                                      FALSE);

    if (NT_SUCCESS(status))
    {
        *pchDrive = fTData ? HD_ALT_TDATA_DRIVE : HD_ALT_UDATA_DRIVE;

        if (!fTData && (HD_UDATA_DRIVE != chDrive))
        {
            //
            // Remember that we've mapped an alternate drive letter to this MU
            // drive so that we can unmount the alternate drive automatically
            // if the "real" MU drive is unmounted later using XUnmountMU()
            //

            ASSERT(OBJECT_NULL == XapiMuInfo.DriveWithAltDriveMapped);
            XapiMuInfo.DriveWithAltDriveMapped = chDrive;
        }
    }

    return RtlNtStatusToDosError(status);
}

DWORD
WINAPI
XUnmountAlternateTitle(
    IN OCHAR chDrive
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[MAX_PATH];
    OBJECT_STRING DosDevice;

    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= (~0x20);

#if DBG
    switch (chDrive)
    {
        case HD_ALT_TDATA_DRIVE:
        case HD_ALT_UDATA_DRIVE:
            break;

        default:
            RIP("XUnmountAlternateTitle() - invalid chDrive parameter");
    }
#endif // DBG

    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);

    RtlInitObjectString(&DosDevice, szDosDevice);

    //
    // BUGBUG: Do more than remove the symbolic link - we need to unmount
    // the filesystem here.
    //

    Status = IoDeleteSymbolicLink(&DosDevice);

    if ((HD_ALT_UDATA_DRIVE == chDrive) && NT_SUCCESS(Status))
    {
        XapiMuInfo.DriveWithAltDriveMapped = OBJECT_NULL;
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
WINAPI
XGetDiskClusterSize(
    PCOSTR lpRootPathName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    RIP_ON_NOT_TRUE("XGetDiskClusterSize()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return 0;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return 0;
        }

    ASSERT((0 != NormalSizeInfo.BytesPerSector) && (0 != NormalSizeInfo.SectorsPerAllocationUnit));

    return (ULONG) (NormalSizeInfo.BytesPerSector * NormalSizeInfo.SectorsPerAllocationUnit);
}

DWORD
WINAPI
XGetDiskSectorSize(
    PCOSTR lpRootPathName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    RIP_ON_NOT_TRUE("XGetDiskSectorSize()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return 0;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return 0;
        }

    ASSERT(0 != NormalSizeInfo.BytesPerSector);

    return NormalSizeInfo.BytesPerSector;
}


DWORD
WINAPI
XMUNameFromDriveLetter(
    IN CHAR chDrive,
    OUT LPWSTR lpName,
    IN UINT cchName
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[8];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FSCTL_VOLUME_METADATA VolumeMetadata;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    //
    // Fail if the device is not already mounted.
    //
    if (!MU_IS_MOUNTED(chDrive))
    {
        XDBGERR("XAPI", "XMUNameFromDriveLetter() MU %c: is not mounted", chDrive);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Open a handle to the volume or directory of the drive.
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(&Handle,
                        SYNCHRONIZE | GENERIC_READ,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
        VolumeMetadata.TransferLength = sizeof(VolumeName);
        VolumeMetadata.TransferBuffer = VolumeName;

        Status = NtFsControlFile(Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_READ_VOLUME_METADATA,
                                 &VolumeMetadata,
                                 sizeof(VolumeMetadata),
                                 NULL,
                                 0);

        if (NT_SUCCESS(Status))
        {
            lstrcpynW(lpName, VolumeName, min(cchName, FAT_VOLUME_NAME_LENGTH));
        }

        NtClose(Handle);
    }

    return RtlNtStatusToDosError(Status);
}

#endif // ! XAPILIBP

#ifdef XAPILIBP

VOID
XapiDeleteCachePartition(
    IN DWORD dwTitleId
    )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    ULONG             CachePartitionCount;

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                NtClose(hVolume);

                return;
            }

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            //
            // Search the cache partition database for a matching title ID
            // If found, clear the title ID so we can write it back to the sector
            //

            for (i = 0; i < CachePartitionCount; i++)
            {
                if (dwTitleId == pCacheDB[i].dwTitleId)
                {
                    pCacheDB[i].dwTitleId = 0;
                    pCacheDB[i].fUsed = FALSE;

                    break;
                }
            }

            //
            // If we picked this partition because it is the oldest and not because
            // we matched a TitleId, then we must format the cache partition before
            // giving it to the title
            //

            //
            // Write back into the cache db
            //

            //
            // Ignore status result
            //

            Status = NtWriteFile(hVolume,
                                 0,
                                 NULL,
                                 NULL,
                                 &statusBlock,
                                 rgbSectorBuffer,
                                 sizeof(rgbSectorBuffer),
                                 &byteOffset);
        }

        NtClose(hVolume);
    }
}


NTSTATUS
XapiGetCachePartitions(
    IN PX_CACHE_DB_ENTRY pCacheEntriesBuffer,
    IN UINT cbBufferSize,
    OUT PDWORD pdwNumCacheEntries )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    ULONG             CachePartitionCount;

    ASSERT(pdwNumCacheEntries);

    //
    // Set the number of entries written to 0, in case of failure
    //

    *pdwNumCacheEntries = 0;

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                RtlZeroMemory(rgbSectorBuffer, sizeof(rgbSectorBuffer));
            }

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            //
            // Search the cache partition database for a matching title ID
            //

            for (i = 0; i < CachePartitionCount; i++)
            {
                if( 0 != pCacheDB[i].dwTitleId )
                {
                    if( ( pCacheEntriesBuffer != NULL ) && ( ( sizeof( X_CACHE_DB_ENTRY ) * (*pdwNumCacheEntries + 1) ) <= cbBufferSize ) )
                    {
                        RtlCopyMemory(&(pCacheEntriesBuffer[*pdwNumCacheEntries]),
                                      &(pCacheDB[i]),
                                      sizeof(X_CACHE_DB_ENTRY));
                    }

                    *pdwNumCacheEntries += 1;
                }
            }
        }

        NtClose(hVolume);
    }

    return Status;
}


DWORD
WINAPI
XMUWriteNameToDriveLetter(
    IN CHAR chDrive,
    IN LPCWSTR lpName
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[8];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FSCTL_VOLUME_METADATA VolumeMetadata;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    //
    //  Fail if the device is not already mounted.
    //
    if (!MU_IS_MOUNTED(chDrive))
    {
        XDBGERR("XAPI", "XMUNameFromDriveLetter() MU %c: is not mounted", chDrive);
        return ERROR_INVALID_DRIVE;
    }

    ASSERT(wcslen(lpName) < MAX_MUNAME);

    //
    // Open a handle to the volume or directory of the drive.
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(&Handle,
                        SYNCHRONIZE | GENERIC_WRITE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        lstrcpynW(VolumeName, lpName, FAT_VOLUME_NAME_LENGTH);

        VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
        VolumeMetadata.TransferLength = sizeof(VolumeName);
        VolumeMetadata.TransferBuffer = VolumeName;

        Status = NtFsControlFile(Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_WRITE_VOLUME_METADATA,
                                 &VolumeMetadata,
                                 sizeof(VolumeMetadata),
                                 NULL,
                                 0);

        NtClose(Handle);
    }

    return RtlNtStatusToDosError(Status);
}

#endif // XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\mountmu.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    mountmu.c

Abstract:

    This module implements the XTL memory unit services.

--*/

#include "basedll.h"
#include <usbxapi.h>
#include <xboxp.h>
#include "..\..\fatx\fat.h"

#ifdef XAPILIBP

extern CRITICAL_SECTION XapiMountMUCriticalSection;

#ifdef DBG
extern ULONG g_XapiCurrentUserDevices;
#endif

#else  // XAPILIBP

INITIALIZED_CRITICAL_SECTION(XapiMountMUCriticalSection);

#ifdef DBG
ULONG g_XapiCurrentUserDevices = 0;
#endif

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
WINAPI
XMountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS Status;
    OCHAR szTitleId[CCHMAX_HEX_DWORD];
    OCHAR szDeviceName[64];
    OCHAR szDosDevice[64];
    OCHAR chDrive;
    OBJECT_STRING DeviceName, DosDevice;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XMountMU: XInitDevices must be called first!");

    if (NULL != pchDrive)
    {
        *pchDrive = OBJECT_NULL;
    }
    
    EnterCriticalSection(&XapiMountMUCriticalSection);

#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XMountMU() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XMountMU() invalid parameter (dwSlot)");
    }
    
    if(MU_MaxUserDevices <= g_XapiCurrentUserDevices)
    {
        RIP("XMountMU() more devices than specified in XInitDevices");
    }
#endif // DBG

    //
    //  Make sure that the device is not already mounted.
    //  (if it is, we sort of fail)
    chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    if(MU_IS_MOUNTED(chDrive))
    {
        RIP("XMountMU() MU already mounted.");
        *pchDrive = chDrive;
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_ALREADY_ASSIGNED;
    }

    //
    // Setup the string buffer
    //
    DeviceName.Length = 0;
    DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-1;
    DeviceName.Buffer = szDeviceName;

    //
    //  create the device object
    //
    Status = MU_CreateDeviceObject(
                dwPort,
                dwSlot,
                &DeviceName
                );

    if(NT_SUCCESS(Status))
    {
        soprintf(szDosDevice,
                 OTEXT("\\??\\%c:"),
                 chDrive);

        RtlInitObjectString(&DosDevice, szDosDevice);

        DwordToStringO(XeImageHeader()->Certificate->TitleID, szTitleId);

        //
        //  Tack on a '\\' to the end.  This way we are passing the MU's root directory,
        //  rather than the raw volume.  This is important to prevent the raw file system
        //  from mounting by mistake on a corrupt or unformatted MU.  The main evil of
        //  mounting the raw file system is that the error codes coming will be really
        //  strange.
        //
        ASSERT(DeviceName.Length+sizeof(OCHAR)<=DeviceName.MaximumLength);
        DeviceName.Buffer[DeviceName.Length++ / sizeof(OCHAR)] = OTEXT('\\');

        Status = XapiMapLetterToDirectory((PCOBJECT_STRING)&DosDevice,
                                          (PCOBJECT_STRING)&DeviceName,
                                          szTitleId,
                                          TRUE,
                                          XeImageHeader()->Certificate->TitleName,
                                          FALSE);

        if (NT_SUCCESS(Status))
        {
            if (NULL != pchDrive)
            {
                *pchDrive = chDrive;
            }
            MU_SET_MOUNTED(chDrive);
            #if DBG
            g_XapiCurrentUserDevices++;
            #endif
        }
        else
        {
            // Dismount the volume if necessary.
            IoDismountVolumeByName(&DeviceName);

            // We must assume that either a handle was successfully opened and
            // the filesystem was dismounted, or that it never managed to mount.
            // If not, then the following step breaks all further attempts to
            // mount MU's, but things were probably pretty well broken before
            // this anyway.
            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }
		
    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XMountMURoot(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS Status;
    OCHAR szDeviceName[64];
    OCHAR szDosDevice[64];
    OCHAR chDrive;
    OBJECT_STRING DeviceName, DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE DirHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Fill out the MU type so that XAPI can
    // find it without explicitly referencing it.
    // This way the MU driver is not sucked in
    // by XAPI unless the MU is used.
    //

    if (NULL != pchDrive)
    {
        *pchDrive = OBJECT_NULL;
    }

    EnterCriticalSection(&XapiMountMUCriticalSection);
    
#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XMountMURoot() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XMountMURoot() invalid parameter (dwSlot)");
    }
    if(MU_MaxUserDevices <= g_XapiCurrentUserDevices)
    {
        RIP("XMountMU() more devices than specified in XInitDevices");
    }
#endif // DBG

    //
    //  Make sure that the device is not already mounted.
    //  (if it is, we sort of fail)
    chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    if(MU_IS_MOUNTED(chDrive))
    {
        RIP("XMountMU() MU already mounted.");
        *pchDrive = chDrive;
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_ALREADY_ASSIGNED;
    }

    //
    // Setup the string buffer
    //
    DeviceName.Length = 0;
    //lie - so we have guaranteed space for a back slash (lie leave room for NULL, and a '\\')
    DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-2;
    DeviceName.Buffer = szDeviceName;

    //
    //  create the device object
    //
    Status = MU_CreateDeviceObject(
                dwPort,
                dwSlot,
                &DeviceName
                );

    if(NT_SUCCESS(Status))
    {
        //We previously lied about the maximum length to guarantee room for a backslash
        //undo that lie.
        DeviceName.MaximumLength++;

        //Add a back slash to the name returned from MU_CreateDeviceObject
        szDeviceName[DeviceName.Length++] = OTEXT('\\');
        szDeviceName[DeviceName.Length] = OTEXT('\0');

        //Attempt to open the root directory (this effectively mounts the drive).
        InitializeObjectAttributes(
            &Obja,
            (POBJECT_STRING)&DeviceName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &DirHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );

        //Whack the backslash off the device name
        szDeviceName[--DeviceName.Length] = OTEXT('\0');

        //If we succeeded in opening the root directory we can
        //create the symbolic link, etc.
        if (NT_SUCCESS(Status))
        {
            NtClose(DirHandle);  //Close the handle, we no longer need it

            soprintf(szDosDevice,
                 OTEXT("\\??\\%c:"),
                 chDrive);
            RtlInitObjectString(&DosDevice, szDosDevice);

            Status = IoCreateSymbolicLink(&DosDevice, &DeviceName);
            if(NT_ERROR(Status))
            {
                XDBGWRN("XAPI", "XMountMURoot() - IoCreateSymbolicLink failed with 0x%0.8x", Status);
            }
        }

        if (NT_SUCCESS(Status))
        {
            if (NULL != pchDrive)
            {
                *pchDrive = chDrive;
            }
            MU_SET_MOUNTED(chDrive);
	        #if DBG
            g_XapiCurrentUserDevices++;
            #endif
        } else
        //
        //  Failed to open the root or to create a symbolic link.  This does not mean a filesystem
        //  didn't mount, just in case we must force a dismount.
        {
            IoDismountVolumeByName(&DeviceName);

            //We must assume that either a handle was successfully opened and the filesystem was dismounted, or
            //that it never managed to mount.  If not, then the following step breaks all further attempts to
            //mount MU's, but things were probably pretty well broken before this anyway.
            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XUnmountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[64];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE VolHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    OCHAR chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);

#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XUnmountMU() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XUnmountMU() invalid parameter (dwSlot)");
    }
#endif // DBG

    EnterCriticalSection(&XapiMountMUCriticalSection);

    //
    //  Fail if the device is not already mounted.
    //
    if(!MU_IS_MOUNTED(chDrive))
    {
        RIP("XUnmountMU() MU not mounted.");
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_INVALID_DRIVE;
    }

    //
    //  Unmount an alternate drive if it is mapped.
    //
    if (XapiMuInfo.DriveWithAltDriveMapped == chDrive)
    {
        //
        // An alternate drive is mapped to this MU drive, so let's auto dismount it here
        //

        XDBGWRN("XAPI", "XUnmountMU() called on MU drive (%c:) with alternate drive mapped (%c:)",
                chDrive, HD_ALT_UDATA_DRIVE);

        XUnmountAlternateTitle(HD_ALT_UDATA_DRIVE);
    }

    //
    //  open the symbolic link
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING)&DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                    &VolHandle,
                    SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

    //
    //  send FSCTL_DISMOUNT_VOLUME
    //
    if(NT_SUCCESS(Status))
    {
        Status = NtFsControlFile(VolHandle, NULL, NULL, NULL, &IoStatusBlock, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);
        NtClose(VolHandle); //Close handle whether the dismount succeeded or not.
    }

    if(NT_SUCCESS(Status))
    {
        //
        // Delete the symbolic link.
        //

        Status = IoDeleteSymbolicLink(&DosDevice);

        //
        //  Tell the MU driver to delete the DeviceObject
        //

        MU_CloseDeviceObject(dwPort, dwSlot);

        //
        //  Mark the drive as not mounted
        //

        MU_CLEAR_MOUNTED(chDrive);
        #if DBG
        g_XapiCurrentUserDevices--;
        #endif    
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XReadMUMetaData(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN LPVOID lpBuffer,
    IN DWORD dwByteOffset,
    IN DWORD dwNumberOfBytesToRead
    )
{
    NTSTATUS Status;
    OCHAR szDeviceName[64];
    OBJECT_STRING DeviceName;
    OCHAR chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    PDEVICE_OBJECT DeviceObject;
    PFAT_VOLUME_METADATA VolumeMetadata;
    LARGE_INTEGER StartingOffset;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

#if DBG
    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XReadMUMetaData: XInitDevices must be called first!");

    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XReadMUMetaData() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XReadMUMetaData() invalid parameter (dwSlot)");
    }

    if (dwByteOffset >= PAGE_SIZE)
    {
        RIP("XReadMUMetaData() invalid parameter (dwByteOffset)");
    }

    if ((PAGE_SIZE - dwByteOffset) < dwNumberOfBytesToRead)
    {
        RIP("XReadMUMetaData() invalid parameter (dwNumberOfBytesToRead)");
    }
#endif // DBG

    EnterCriticalSection(&XapiMountMUCriticalSection);

    if(!MU_IS_MOUNTED(chDrive))
    {
        //
        // Setup the string buffer
        //
        DeviceName.Length = 0;
        //lie - so we have guaranteed space for a back slash (lie leave room for NULL, and a '\\')
        DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-2;
        DeviceName.Buffer = szDeviceName;

        //
        //  create the device object
        //
        Status = MU_CreateDeviceObject(
                    dwPort,
                    dwSlot,
                    &DeviceName
                    );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        DeviceObject = MU_GetExistingDeviceObject(dwPort, dwSlot),

        //
        //  Before the memory unit can accept read requests, it must first
        //  initialize its drive geometry information.  Send the same IOCTLs
        //  that the file system would send during the mount process.  Neither
        //  of these need to synchronized with a file system that has already
        //  mounted, so send them directly to the device.
        //

        Status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
            DeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY),
            NULL, FALSE);

        if (NT_SUCCESS(Status))
        {
            Status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                DeviceObject, NULL, 0, &PartitionInformation,
                sizeof(PARTITION_INFORMATION), NULL, FALSE);

            if (PartitionInformation.PartitionLength.QuadPart < PAGE_SIZE)
            {
                Status = STATUS_UNRECOGNIZED_VOLUME;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            //  Allocate a block of memory to hold the volume metadata block.  All
            //  device objects must support at least PAGE_SIZE transfers in order to
            //  support the file system cache.  Memory units typically have at least
            //  PAGE_SIZE sector sizes, so there's no point in trying to reduce this
            //  memory requirement.
            //

            VolumeMetadata = (PFAT_VOLUME_METADATA)LocalAlloc(LMEM_FIXED, PAGE_SIZE);

            if (VolumeMetadata != NULL)
            {
                //
                //  Submit a read request for PAGE_SIZE bytes from the start of
                //  the device.  Note that we don't need to synchronize this
                //  with the file system because all of the file systems we care
                //  about immediately flush any metadata writes to media.
                //

                StartingOffset.QuadPart = 0;

                Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                    VolumeMetadata, PAGE_SIZE, &StartingOffset);

                if (NT_SUCCESS(Status))
                {
                    //
                    //  Verify that the volume is formatted as FATX.  Memory units
                    //  never use any other file system.
                    //

                    if (VolumeMetadata->Signature == FAT_VOLUME_SIGNATURE)
                    {
                        CopyMemory(lpBuffer, (LPBYTE)VolumeMetadata + dwByteOffset,
                            dwNumberOfBytesToRead);

                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        Status = STATUS_UNRECOGNIZED_VOLUME;
                    }
                }

                LocalFree(VolumeMetadata);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if(!MU_IS_MOUNTED(chDrive))
        {
            //
            //  Tell the MU driver to delete the DeviceObject
            //

            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}

#endif // ! XAPILIBP

#ifdef XAPILIBP

DWORD
WINAPI
XMUNameFromPortSlot(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT LPWSTR lpName,
    IN UINT cchName
    )
{
    DWORD dwError;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    dwError = XReadMUMetaData(dwPort, dwSlot, VolumeName,
        FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName), sizeof(VolumeName));

    if (dwError == ERROR_SUCCESS)
    {
        lstrcpynW(lpName, VolumeName, min(cchName, FAT_VOLUME_NAME_LENGTH));
    }

    return dwError;
}

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
WINAPI
XMUPortFromDriveLetter(
    OCHAR chDrive
    )
{
    if ((chDrive >= MU_FIRST_DRIVE) && (chDrive <= MU_LAST_DRIVE))
    {
        return MU_PORT_FROM_DRIVE_LETTER(chDrive);
    }
    else
    {
        return -1;
    }
}

DWORD
WINAPI
XMUSlotFromDriveLetter(
    OCHAR chDrive
    )
{
    if ((chDrive >= MU_FIRST_DRIVE) && (chDrive <= MU_LAST_DRIVE))
    {
        return MU_SLOT_FROM_DRIVE_LETTER(chDrive);
    }
    else
    {
        return -1;
    }
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\powerdwn.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    powerdwn.c

Abstract:

    Xbox Auto Power Down

    Provides a 6 hour auto power off timer.

    The following private API's are provided the dashboard
    and internal XSS components to manage the auto power down
    feature.

    XAutoPowerDownSet
    XAutoPowerDownGet
    XAutoPowerDownResetTimer

    For debug builds there is also:

    XAutoPowerDownDebugSetTimeout

Environment:

    XAPI

Notes:

Revision History:

    05-17-01 created by Mitchell Dernis (mitchd)

--*/
#include "basedll.h"
#include <xboxp.h>

#define AUTOPOWERDOWNTIMEOUT (-216000000000)  //This should be 6 hours worth of 100 ns intervals
                                              //6*60*60*1000*1000*10 : negative means from current time.
//---------------------------------------------------------
//  Declaration of Globals used in this module
//---------------------------------------------------------
typedef struct _XAPI_AUTOPOWERDOWN_GLOBAL
{
    KDPC    AutoPowerDownDpc;
    KTIMER  AutoPowerDownTimer;
    BOOL    fAutoPowerDown;
    BOOL    fReadWriteFailure;
#if DBG
    LARGE_INTEGER liTimeOut;  //The timeout is adjustable in debug builds only
#endif
} XAPI_AUTOPOWERDOWN_GLOBAL;
XAPI_AUTOPOWERDOWN_GLOBAL XapiAutoPowerDownGlobals;

//---------------------------------------------------------
//  Forward Declaration of Support Routines
//---------------------------------------------------------
VOID  XapiAutoPowerDownTimeout(PKDPC, PVOID, PVOID, PVOID); //Dpc Timeout

#ifdef XAPILIBP

/*
**  PRIVATE API ACCESSIBLE TO OTHER COMPONENTS
**  OF XSS and THE DASHBOARD
*/

DWORD
XAutoPowerDownSet(BOOL fAutoPowerDown)
/*++
  Routine Description:
   Turns the auto-power-down feature on and off.

  Arguments:
   fAutoPowerDown - The desired new setting.
  
  Return Value:
   Error code returned by XSetValue.

  Remarks:
   
   The only portion of this API that can fail is writing the new setting
   to EEPROM.  The error code returned is the one returned by this
   XSetValue. Regardless of whether the new value was successfully persisted,
   the new setting is adopted for the current session.

   THIS ROUTINE IS NOT THREAD SAFE!!! The only intended client
   is XDash, nobody else should be touching this.
   
--*/
{
    DWORD dwError;
    ULONG ulType, ulSize;
    DWORD dwMiscFlags;

    //
    //  Save the new value of the flag.
    //
    XapiAutoPowerDownGlobals.fAutoPowerDown = fAutoPowerDown;
    
    dwError = XQueryValue(XC_MISC_FLAGS, &ulType, &dwMiscFlags, sizeof(dwMiscFlags), &ulSize);

    //
    //  Sets or cancels the timer as appropriate.
    //
    if(fAutoPowerDown)
    {
        XAutoPowerDownResetTimer();
        dwMiscFlags |= XC_MISC_FLAG_AUTOPOWERDOWN;
    } else
    {
        dwMiscFlags &= ~XC_MISC_FLAG_AUTOPOWERDOWN;
    }

    //
    //  If the query succeeded, then write out the new value.
    //
    if(!dwError)
    {
        dwError = XSetValue(XC_MISC_FLAGS, REG_DWORD, &dwMiscFlags, sizeof(dwMiscFlags));
    }

    //
    //  Whether error or not we need to update the fReadWriteFailure flag.
    //
    XapiAutoPowerDownGlobals.fReadWriteFailure = dwError;

    return dwError;
}

DWORD
XAutoPowerDownGet(BOOL *pfAutoPowerDown)
/*++
  Routine Description:
   Retrieves the current setting of the
   auto-power-down feature.

  Arguments:
   pfAutoPowerDown - pointer to BOOL to receive setting.

  Return Value:
   Error code returned by XAutoPowerDownGet.
 
  Remarks:
   The API maintains the current operating mode of the feature
   separate from the persisted value.

   On each call to XAutoPowerDownGet, the API attempts to reestablish
   coherency between the persisted value and the current operating
   value.  It does this by checking to see if the last read\write
   operation falied.  If it was a failure, it calls
   XAutoPowerDownSet with the current operating value.
   
   In all cases, *pfAutoPowerDown is set to the current operating
   value.
--*/
{
    DWORD dwError = 0;

    //
    //  Save out the return value
    //
    *pfAutoPowerDown = XapiAutoPowerDownGlobals.fAutoPowerDown;

    //
    //  If the last read or write was a failure, try writing
    //  out the setting again.
    //
    if(XapiAutoPowerDownGlobals.fReadWriteFailure)
    {
        dwError = XAutoPowerDownSet(XapiAutoPowerDownGlobals.fAutoPowerDown);
    }
    return dwError;
}


#if DBG
void XAutoPowerDownDebugSetTimeout(LONGLONG llTimeout)
/*++
  Routine Description:
   In debug builds only we need a way to set the timer to something short to test
   the feature.

  Arguments:
   liTimeout - Time in 100 ns intervals to set the timeout.  This value should be negative.
               If the time is not negative, it is the absolute time after boot that the box should
               go off.
--*/
{
    XapiAutoPowerDownGlobals.liTimeOut.QuadPart = llTimeout;
}
#endif

#endif // XAPILIBP

#ifndef XAPILIBP

//---------------------------------------------------------
//  Initialization method called by Xapi Init
//---------------------------------------------------------
void XapiInitAutoPowerDown()
{
    ULONG ulSize, ulType;
    DWORD dwError, dwMiscFlags;

    //
    //  Initialize Dpc and Timer Structures
    //
    KeInitializeDpc(&XapiAutoPowerDownGlobals.AutoPowerDownDpc, XapiAutoPowerDownTimeout, NULL);
    KeInitializeTimer(&XapiAutoPowerDownGlobals.AutoPowerDownTimer);

#if DBG
    //
    //  In release builds, the timeout is hardcoded to six hours
    //  in debug builds it is variable.
    XapiAutoPowerDownGlobals.liTimeOut.QuadPart = AUTOPOWERDOWNTIMEOUT;
#endif

    //
    //  Initialize the feature state from the config settings
    //
    XapiAutoPowerDownGlobals.fAutoPowerDown = FALSE;
    XapiAutoPowerDownGlobals.fReadWriteFailure = FALSE;

    dwError = XQueryValue(XC_MISC_FLAGS, &ulType, &dwMiscFlags, sizeof(dwMiscFlags), &ulSize);
    if(!dwError)
    {
        XapiAutoPowerDownGlobals.fAutoPowerDown = (dwMiscFlags&XC_MISC_FLAG_AUTOPOWERDOWN) ? TRUE : FALSE;
    } else
    {
        XapiAutoPowerDownGlobals.fReadWriteFailure = TRUE;
    }

    //
    //  Start the timer.
    //
    XAutoPowerDownResetTimer();
}

void
XAutoPowerDownResetTimer()
/*++
  Routine Description:
   Resets the AutoPowerDownTimer so that the unit does not shut off.

  Remarks:
   Note that we always set the timer and never check XapiAutoPowerDownGlobals.fAutoPowerDown.
   This is by design.  The DPC timeout routine checks XapiAutoPowerDownGlobals.fAutoPowerDown.

   After some thought, it is not enough to check XapiAutoPowerDownGlobals.fAutoPowerDown here,
   unless you synchronize this routine with XAutoPowerDownSet.  That is a hassle, and it
   it is more code.

   Games must be able to run well with the timer running so you cannot argue that the having the
   timer running negatively affects performance.  In fact, if does negatively affect performance,
   it is even more important that it run all the time.

   So just let the timer run, we will check if the auto-power-down feature is on, only at the last
   moment when we need to turn off the box.

--*/
{
#if DBG
    KeSetTimer(
        &XapiAutoPowerDownGlobals.AutoPowerDownTimer,
        XapiAutoPowerDownGlobals.liTimeOut,
        &XapiAutoPowerDownGlobals.AutoPowerDownDpc
        );
#else
    LARGE_INTEGER liDueTime;
    liDueTime.QuadPart = AUTOPOWERDOWNTIMEOUT;
    KeSetTimer(&XapiAutoPowerDownGlobals.AutoPowerDownTimer, liDueTime, &XapiAutoPowerDownGlobals.AutoPowerDownDpc);
#endif
}

ULONG XAutoPowerDownTimeRemaining()
/*++
  Routine Description:
    This routine is available to games so that they may poll to see if an auto power down is imminent.
    Developers want this so that they may auto-save before the box shuts down.  Notifying them would be
    too hard, as we would need to call them at DPC.

  Return Value:
    If the auto power down feature is off, the return value is 0xFFFFFFFF.  If the auto power
    down feature is on, the return value is the time in milliseconds until auto power-down.
--*/
{
    KIRQL  oldIrql;
    ULARGE_INTEGER uliTimeRemaining;
    ULONGLONG ullCurrentTime;
    if(!XapiAutoPowerDownGlobals.fAutoPowerDown)
    {
        return 0xFFFFFFFF;
    }
    
    //synchronize access to timer structure
    oldIrql = KeRaiseIrqlToDpcLevel();
    
    //Get the current interrupt time
    ullCurrentTime = KeQueryInterruptTime();

    // Comute the difference, in 100 ns intervals.  The interrupt timer starts out at zero at boot and just runs.
    // With a 64-bit - 100 ns counter - it will wrap once every 58,494 and a quater years.  Don't worry about
    // counter wrap!
    if(XapiAutoPowerDownGlobals.AutoPowerDownTimer.DueTime.QuadPart >= ullCurrentTime)
    {
        uliTimeRemaining.QuadPart = XapiAutoPowerDownGlobals.AutoPowerDownTimer.DueTime.QuadPart - ullCurrentTime;
    } else
    {
        uliTimeRemaining.QuadPart = 0;
    }

    //Done synchronizing.
    KeLowerIrql(oldIrql);

    //Convert from 100 ns intevals to milliseconds
    uliTimeRemaining.QuadPart /= 10000;

    //Since we know that the time was never set for more than
    //six hours, we can trust that the HighPart is now zero.
    return uliTimeRemaining.LowPart;
}

/*
**  INTERNAL SUPPORT METHODS
**  
*/

VOID
XapiAutoPowerDownTimeout(
    PKDPC bogus1,
    PVOID bogus2,
    PVOID bogus3,
    PVOID bogus4
    )
/*++
  Routine Description:
    This is the timeout DPC for the Auto-power-down feature.
    When this routine is called it checks XapiAutoPowerDownGlobals.fAutoPowerDown.
    If TRUE it calls the appropriate Hal method to power down Xbox.
--*/
{
    if(XapiAutoPowerDownGlobals.fAutoPowerDown)
    {
        HalInitiateShutdown();
    }
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\physical.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    This module implements the XBOX physical memory management services.

--*/

#include "basedll.h"
#pragma hdrstop

LPVOID
WINAPI
XPhysicalAlloc(
    IN SIZE_T dwSize,
    IN ULONG_PTR ulPhysicalAddress,
    IN ULONG_PTR ulAlignment,
    IN DWORD flProtect
    )
{
    ULONG ulLowestAcceptableAddress;
    ULONG ulHighestAcceptableAddress;
    LPVOID lpAddress;

    RIP_ON_NOT_TRUE("XPhysicalAlloc()", (dwSize != 0));
    RIP_ON_NOT_TRUE("XPhysicalAlloc()", ((ulAlignment & (ulAlignment - 1)) == 0));
    RIP_ON_NOT_TRUE("XPhysicalAlloc()",
        ((flProtect & ~(PAGE_READWRITE | PAGE_READONLY | PAGE_WRITECOMBINE | PAGE_NOCACHE)) == 0));

    if (ulPhysicalAddress != MAXULONG_PTR) {

        RIP_ON_NOT_TRUE("XPhysicalAlloc()", (BYTE_OFFSET(ulPhysicalAddress) == 0));

        ulLowestAcceptableAddress = ulPhysicalAddress;
        ulHighestAcceptableAddress = ulPhysicalAddress + dwSize - 1;

        //
        // Ignore the alignment parameter; the caller gave us a physical address
        // and we assume it has the appropriate alignment already applied.
        //

        ulAlignment = 0;

    } else {
        ulLowestAcceptableAddress = 0;
        ulHighestAcceptableAddress = MAXULONG_PTR;
    }

    lpAddress = MmAllocateContiguousMemoryEx(dwSize, ulLowestAcceptableAddress,
        ulHighestAcceptableAddress, ulAlignment, flProtect);

    if (lpAddress == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return lpAddress;
}

SIZE_T
WINAPI
XPhysicalSize(
    IN LPVOID lpAddress
    )
{
    RIP_ON_NOT_TRUE("XPhysicalSize()", ((ULONG_PTR)lpAddress >= 0x80000000));

    return MmQueryAllocationSize(lpAddress);
}

VOID
WINAPI
XPhysicalProtect(
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD flNewProtect
    )
{
    RIP_ON_NOT_TRUE("XPhysicalProtect()", ((ULONG_PTR)lpAddress >= 0x80000000));
    RIP_ON_NOT_TRUE("XPhysicalProtect()",
        ((flNewProtect & ~(PAGE_READWRITE | PAGE_READONLY | PAGE_WRITECOMBINE | PAGE_NOCACHE)) == 0));

    if (dwSize != 0) {
        MmSetAddressProtect(lpAddress, dwSize, flNewProtect);
    }
}

VOID
WINAPI
XPhysicalFree(
    IN LPVOID lpAddress
    )
{
    RIP_ON_NOT_TRUE("XPhysicalFree()", ((ULONG_PTR)lpAddress >= 0x80000000));

    MmFreeContiguousMemory(lpAddress);
}

DWORD
WINAPI
XQueryMemoryProtect(
    IN LPVOID lpAddress
    )
{
    return MmQueryAddressProtect(lpAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sources

Abstract:

    Specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=Xapi

TARGETTYPE=LIBRARY
UMTYPE=xbox

INCLUDES=..;..\..\inc;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\inc\crypto;$(DDK_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_XAPI_
MSC_WARNING_LEVEL=/W3

PRECOMPILED_INCLUDE=..\basedll.h
PRECOMPILED_PCH=basedll.pch
PRECOMPILED_OBJ=basedll.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\rect.c ===
#include "basedll.h"

#define VALIDATERECT(prc, retval)                              \
            RIP_ON_NOT_TRUE_WITH_MESSAGE(                      \
                (NULL != prc),                                 \
                "NULL LPRECT pointer passed to Rect function")

/***********************************************************************\
* SetRect (API)
*
* This function fills a rectangle structure with the passed in coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\***********************************************************************/

BOOL APIENTRY SetRect(
    LPRECT prc,
    int left,
    int top,
    int right,
    int bottom)
{
    VALIDATERECT(prc, FALSE);

    prc->left = left;
    prc->top = top;
    prc->right = right;
    prc->bottom = bottom;
    return TRUE;
}

#if 0

/************************************************************************\
* CopyInflateRect (API)
*
* This function copies the rect from prcSrc to prcDst, and inflates it.
*
* History:
* 12-16-93  FritzS
\************************************************************************/

BOOL APIENTRY CopyInflateRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   - cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    - cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* CopyOffsetRect (API)
*
* This function copies the rect from prcSrc to prcDst, and offsets it.
*
* History:
* 01-03-94  FritzS
\************************************************************************/

BOOL APIENTRY CopyOffsetRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   + cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    + cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

#endif // 0

/************************************************************************\
* IsRectEmpty (API)
*
* This function returns TRUE if *prc is an empty rect, FALSE
* otherwise.  An empty rect is one that has no area: right is
* less than or equal to left, bottom is less than or equal to top.
*
* Warning:
*   This function assumes that the rect is in device coordinates
*   mode where left and top coordinate are smaller than right and
*   bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IsRectEmpty(
    CONST RECT *prc)
{
    VALIDATERECT(prc, TRUE);

    return ((prc->left >= prc->right) || (prc->top >= prc->bottom));
}

/***********************************************************************\
* PtInRect (API)
*
* This function returns TRUE if *ppt falls inside of *prc.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY PtInRect(
    CONST RECT *prc,
    POINT  pt)
{
    VALIDATERECT(prc, FALSE);

    return ((pt.x >= prc->left) && (pt.x < prc->right) &&
            (pt.y >= prc->top)  && (pt.y < prc->bottom));
}

/************************************************************************\
* OffsetRect (API)
*
* This function offsets the coordinates of *prc by adding cx to
* both the left and right coordinates, and cy to both the top and
* bottom coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY OffsetRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   += cx;
    prc->right  += cx;
    prc->bottom += cy;
    prc->top    += cy;
    return TRUE;
}

/************************************************************************\
* InflateRect (API)
*
* This function expands the given rect by cx horizantally and cy
* vertically on all sides.  If cx or cy are negative, the rect
* is inset.  cx is subtracted from the left and added to the right,
* and cy is subtracted from the top and added to the bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY InflateRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   -= cx;
    prc->right  += cx;
    prc->top    -= cy;
    prc->bottom += cy;
    return TRUE;
}

/************************************************************************\
* IntersectRect (API)
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IntersectRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)

{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return TRUE;        // not empty
        }
    }

    /*
     * empty rect
     */
    SetRectEmpty(prcDst);

    return FALSE;
}

/********************************************************************\
* UnionRect (API)
*
* This function calculates a rect that bounds *prcSrc1 and
* *prcSrc2, returning the result in *prcDst.  If either
* *prcSrc1 or *prcSrc2 are empty, then the other rect is
* returned.  Returns TRUE if *prcDst is a non-empty rect,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*******************************************************************/

BOOL APIENTRY UnionRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    BOOL frc1Empty, frc2Empty;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    frc1Empty = ((prcSrc1->left >= prcSrc1->right) ||
            (prcSrc1->top >= prcSrc1->bottom));

    frc2Empty = ((prcSrc2->left >= prcSrc2->right) ||
            (prcSrc2->top >= prcSrc2->bottom));

    if (frc1Empty && frc2Empty) {
        SetRectEmpty(prcDst);
        return FALSE;
    }

    if (frc1Empty) {
        *prcDst = *prcSrc2;
        return TRUE;
    }

    if (frc2Empty) {
        *prcDst = *prcSrc1;
        return TRUE;
    }

    /*
     * form the union of the two non-empty rects
     */
    prcDst->left   = min(prcSrc1->left,   prcSrc2->left);
    prcDst->top    = min(prcSrc1->top,    prcSrc2->top);
    prcDst->right  = max(prcSrc1->right,  prcSrc2->right);
    prcDst->bottom = max(prcSrc1->bottom, prcSrc2->bottom);

    return TRUE;
}

/********************************************************************\
* EqualRect (API)
*
* This function returns TRUE if *prc1 and *prc2 are identical,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*****************************************************************/

#undef EqualRect     // don't let macro interfere with API
BOOL APIENTRY EqualRect(
    CONST RECT *prc1,
    CONST RECT *prc2)
{
    VALIDATERECT(prc1, FALSE);
    VALIDATERECT(prc2, FALSE);

    /*
     * Test equality only. This is what win31 does. win31 does not check to
     * see if the rectangles are "empty" first.
     */
    return RtlEqualMemory(prc1, prc2, sizeof(RECT));
}

/**********************************************************************\
* SubtractRect (API)
*
* This function subtracts *prc2 from *prc1, returning the result in *prcDst
* Returns FALSE if *lprDst is empty, TRUE otherwise.
*
* Warning:
*   Subtracting one rect from another may not always result in a
*   rectangular area; in this case SubtractRect will return *prc1 in
*   *prcDst.  For this reason, SubractRect provides only an
*   approximation of subtraction.  However, the area described by
*   *prcDst will always be greater than or equal to the "true" result
*   of the subtraction.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowsese.
\**********************************************************************/

BOOL APIENTRY SubtractRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    int cSidesOut;
    BOOL fIntersect;
    RECT rcInt;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    fIntersect = IntersectRect(&rcInt, prcSrc1, prcSrc2);

    /*
     * this is done after the intersection in case prcDst is the same
     * pointer as prcSrc2
     */
    *prcDst = *prcSrc1;

    if (fIntersect) {
        /*
         * exactly any 3 sides of prc2 must be outside prc1 to subtract
         */
        cSidesOut = 0;
        if (rcInt.left   <= prcSrc1->left)
            cSidesOut++;
        if (rcInt.top    <= prcSrc1->top)
            cSidesOut++;
        if (rcInt.right  >= prcSrc1->right)
            cSidesOut++;
        if (rcInt.bottom >= prcSrc1->bottom)
            cSidesOut++;

        if (cSidesOut == 4) {
            /*
             * result is the empty rect
             */
             SetRectEmpty(prcDst);
             return FALSE;
        }

        if (cSidesOut == 3) {
            /*
             * subtract the intersecting rect
             */
            if (rcInt.left > prcSrc1->left)
                prcDst->right = rcInt.left;

            else if (rcInt.right < prcSrc1->right)
                prcDst->left = rcInt.right;

            else if (rcInt.top > prcSrc1->top)
                prcDst->bottom = rcInt.top;

            else if (rcInt.bottom < prcSrc1->bottom)
                prcDst->top = rcInt.bottom;
        }
    }

    if ((prcDst->left >= prcDst->right) || (prcDst->top >= prcDst->bottom))
        return FALSE;

    return TRUE;
}

/************************************************************************\
* CopyRect (API)
*
* This function copies the rect from prcSrc to prcDst.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef CopyRect     // don't let macro interfere with API
BOOL APIENTRY CopyRect(
    LPRECT prcDst,
    CONST RECT *prcSrc)
{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc, FALSE);

    *prcDst = *prcSrc;
    return TRUE;
}


/************************************************************************\
* SetRectEmpty (API)
*
* This fuction sets *prc to an empty rect by setting each field to 0.
* Equivalent to SetRect(prc, 0, 0, 0, 0).
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef SetRectEmpty     // don't let macro interfere with API
BOOL APIENTRY SetRectEmpty(
    LPRECT prc)
{
    VALIDATERECT(prc, FALSE);

    RtlZeroMemory(prc, sizeof(RECT));
    return TRUE;
}


#if 0

/***************************************************************************\
* RECTFromSIZERECT
*
* This function converts a SIZERECT to a RECT.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc)
{
    prc->left = psrc->x;
    prc->top = psrc->y;
    prc->right = psrc->x + psrc->cx;
    prc->bottom = psrc->y + psrc->cy;
}


/***************************************************************************\
* SIZERECTFromRECT
* 
* Converts a RECT to a SIZERECT.
* 
* History:
* 09-May-1997 adams     Created.
\***************************************************************************/

void
SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc)
{
    psrc->x = prc->left;
    psrc->y = prc->top;
    psrc->cx = prc->right - prc->left;
    psrc->cy = prc->bottom - prc->top;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\process.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    process.c

Abstract:

    Process management routines

--*/

#include "basedll.h"
#pragma hdrstop

BOOL
WINAPI
IsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for read access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lp;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
           return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PAGE_SIZE - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PAGE_SIZE - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PAGE_SIZE;
                    *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be written by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

    Also not that implementations are free to do a write test by reading
    a value and then writing it back.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for write access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for write access.

    FALSE - All pages within the specified range have been successfully
        written.

--*/
{
    PSZ EndAddress;
    PSZ StartAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PCHAR)lp;

        //
        // Compute the ending address of the structure and probe for
        // write accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
            return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PAGE_SIZE - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PAGE_SIZE - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PAGE_SIZE;
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    )

/*++

    Same as IsBadReadPtr with a length of 1

--*/

{
    return IsBadReadPtr((LPVOID)lpfn,1);
}

BOOL
WINAPI
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*sizeof(WCHAR)) - sizeof(WCHAR));
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCSTR EndAddress;
    LPCSTR StartAddress;
    CHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCSTR)((PSZ)StartAddress + (cchMax*sizeof(CHAR)) - sizeof(CHAR));
        try {
            c = *(volatile CHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile CHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\support.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    support.c

Abstract:

    This module implements various conversion routines
    that transform Win32 parameters into NT parameters.

Author:

    Mark Lucovsky (markl) 20-Sep-1990

Revision History:

--*/

#include "basedll.h"

POBJECT_ATTRIBUTES
XapiFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT POBJECT_STRING ObjectName,
    IN PCOSTR lpName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes structure.

    ObjectName - Returns an initialized OBJECT_STRING structure.

    lpName - Supplies the name of the object relative to the
        ObWin32NamedObjectsDirectory() object directory.

Return Value:

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    RtlInitObjectString(ObjectName, lpName);

    InitializeObjectAttributes(
        ObjectAttributes,
        ObjectName,
        OBJ_OPENIF,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    return ObjectAttributes;
}

PLARGE_INTEGER
XapiFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\thread.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Object APIs

--*/

#include "basedll.h"
#pragma hdrstop

//
// Number of bytes that need to be allocated for thread local storage.
//
ULONG XapiTlsSize;

//
// General critical section used to guard XAPI data structures.
//
INITIALIZED_CRITICAL_SECTION(XapiProcessLock);

//
// List of routines to be notified at thread creation and deletion.  Access is
// guarded by the XapiProcessLock.
//
INITIALIZED_LIST_ENTRY(XapiThreadNotifyRoutineList);

//
// Top level Win32 exception filter implemented by the title.
//
LPTOP_LEVEL_EXCEPTION_FILTER XapiCurrentTopLevelFilter;

VOID
XapiCallThreadNotifyRoutines(
    BOOL Create
    )

/*++

Routine Description:

    Calls the registered thread notification routines when the active thread is
    created or deleted.

Arguments:

    Create - TRUE if the active thread has been created, else FALSE if the
        active thread is to be deleted.

Return Value:

    None.

--*/

{
    PLIST_ENTRY NextListEntry;
    PXTHREAD_NOTIFICATION ThreadNotification;

    XapiAcquireProcessLock();

    NextListEntry = XapiThreadNotifyRoutineList.Flink;

    while (NextListEntry != &XapiThreadNotifyRoutineList) {

        ThreadNotification = CONTAINING_RECORD(NextListEntry,
            XTHREAD_NOTIFICATION, ListEntry);
        NextListEntry = ThreadNotification->ListEntry.Flink;

        ThreadNotification->pfnNotifyRoutine(Create);
    }

    XapiReleaseProcessLock();
}

LONG
WINAPI
UnhandledExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Exception filter for exceptions that don't get handled before the
    top-level handler. This filter always spews debug info and passes
    on the exception to the exception handler.

Arguments:

    ExceptionPointers - Exception information

Return Value:

    EXCEPTION_EXECUTE_HANDLER - passes on control to the handler

--*/

{
#if DBG
    DbgPrint("Unhandled XAPI Exception. Exception Pointers = 0x%p\n", ExceptionPointers);
    DbgPrint("Code %x Addr %p\nInfo0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        );
#endif // DBG

    if ( XapiCurrentTopLevelFilter )
    {
        LONG FilterReturn = (XapiCurrentTopLevelFilter)(ExceptionPointers);
        if ( FilterReturn == EXCEPTION_CONTINUE_EXECUTION )
        {
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
XapiThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    Called by the kernel on thread startup. We set up the default exception handler
    and a data structure to keep track of Xapi data.

Arguments:

    StartRoutine - address the thread should be started at.

    StartContext - an LPVOID pointer passed in to CreateThread to pass on to the thread.

Return Value:

    None.

--*/

{
    DWORD dwExitCode;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    try
    {
        /* Need to set up the TLS data */
        PULONG TlsData;
        DWORD RawDataSize;

        ASSERT(KeGetCurrentThread()->TlsData);

#if DBG
        /* First make sure the TLS data is where we think it should be */
        ASSERT((ULONG_PTR)KeGetCurrentThread()->TlsData -
            (ULONG_PTR)KeGetCurrentTlsDataTop() == *((PULONG)_tls_used.AddressOfIndex) * 4);
#endif

        /* Need to fill the first slot with a pointer to the remainder */
        TlsData = (PULONG)KeGetCurrentThread()->TlsData + 1;
        TlsData[-1] = (ULONG_PTR)TlsData;

        /* Ensure 16-byte alignment */
        ASSERT(((ULONG_PTR)TlsData & 15) == 0);

        RawDataSize = _tls_used.EndAddressOfRawData - _tls_used.StartAddressOfRawData;

        RtlCopyMemory(TlsData, (PVOID)_tls_used.StartAddressOfRawData,
            RawDataSize);

        if (_tls_used.SizeOfZeroFill != 0) {
            RtlZeroMemory((PBYTE)TlsData + RawDataSize, _tls_used.SizeOfZeroFill);
        }

        XapiCallThreadNotifyRoutines(TRUE);

        dwExitCode = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);

        XapiCallThreadNotifyRoutines(FALSE);
    }
    except (UnhandledExceptionFilter(GetExceptionInformation()))
    {
        //
        // UnhandledExceptionFilter will return either EXCEPTION_CONTINUE_SEARCH,
        // in which case, the exception search will stop since we're the top of
        // the exception stack, or it will return EXCEPTION_CONTINUE_EXECUTION.
        // We'll never execute this handler.
        //

        ASSERT(FALSE);
    }

    PsTerminateSystemThread(dwExitCode);
}

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;

    if (dwStackSize == 0) {
        dwStackSize = XeImageHeader()->SizeOfStackCommit;
    }

    Status = PsCreateSystemThreadEx(
                &Handle,
                0,
                dwStackSize,
                XapiTlsSize,
                (PHANDLE)lpThreadId,
                (PKSTART_ROUTINE)lpStartAddress,
                lpParameter,
                (BOOLEAN)((dwCreationFlags & CREATE_SUSPENDED) ? TRUE : FALSE),
                FALSE,
                (PKSYSTEM_ROUTINE)XapiThreadStartup
                );

    if (!NT_SUCCESS(Status) && XapiIsXapiThread()) {
        XapiSetLastNTError(Status);
        return NULL;
    }

    return Handle;
}

BOOL
APIENTRY
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        BasePriority = (LONG)nPriority;
        if (BasePriority == THREAD_PRIORITY_TIME_CRITICAL) {
            BasePriority = ((HIGH_PRIORITY + 1) / 2);
        } else if (BasePriority == THREAD_PRIORITY_IDLE) {
            BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }

        KeSetBasePriorityThread(&Thread->Tcb, BasePriority);
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

int
APIENTRY
GetThreadPriority(
    HANDLE hThread
    )

/*++

Routine Description:

    The specified thread's priority can be read using GetThreadPriority.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

Return Value:

    The value of the thread's current priority is returned.  If an error
    occured, the value THREAD_PRIORITY_ERROR_RETURN is returned.
    Extended error status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;
    int returnvalue;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        returnvalue = (int)KeQueryBasePriorityThread(&Thread->Tcb);
        if (returnvalue == ((HIGH_PRIORITY + 1) / 2)) {
            returnvalue = THREAD_PRIORITY_TIME_CRITICAL;
        } else if (returnvalue == -((HIGH_PRIORITY + 1) / 2)) {
            returnvalue = THREAD_PRIORITY_IDLE;
        }

        ObDereferenceObject(Thread);
        return returnvalue;
    } else {
        XapiSetLastNTError(Status);
        return (int)THREAD_PRIORITY_ERROR_RETURN;
    }
}

BOOL
WINAPI
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        KeSetDisableBoostThread(&Thread->Tcb, bDisablePriorityBoost ? TRUE : FALSE);
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        *pDisablePriorityBoost = Thread->Tcb.DisableBoost ? TRUE : FALSE;
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

    The thread ID of the current thread may be retrieved using
    GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(PsGetCurrentThreadId());
}

DWORD
APIENTRY
SuspendThread(
    HANDLE hThread
    )

/*++

Routine Description:

    A thread can be suspended using SuspendThread.

    Suspending a thread causes the thread to stop executing user-mode
    (or application) code.  Each thread has a suspend count (with a
    maximum value of MAXIMUM_SUSPEND_COUNT).  If the suspend count is
    greater than zero, the thread is suspended; otherwise, the thread is
    not suspended and is eligible for execution.

    Calling SuspendThread causes the target thread's suspend count to
    increment.  Attempting to increment past the maximum suspend count
    causes an error without incrementing the count.

Arguments:

    hThread - Supplies a handle to the thread that is to be suspended.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
         GetLastError.

    Other - The target thread was suspended. The return value is the thread's
        previous suspend count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtSuspendThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

DWORD
APIENTRY
ResumeThread(
    IN HANDLE hThread
    )

/*++

Routine Description:

    A thread can be resumed using ResumeThread.

    Resuming a thread object checks the suspend count of the subject
    thread.  If the suspend count is zero, then the thread is not
    currently suspended and no operation is performed.  Otherwise, the
    subject thread's suspend count is decremented.  If the resultant
    value is zero , then the execution of the subject thread is resumed.

    The previous suspend count is returned as the function value.  If
    the return value is zero, then the subject thread was not previously
    suspended.  If the return value is one, then the subject thread's
    the subject thread is still suspended and must be resumed the number
    of times specified by the return value minus one before it will
    actually resume execution.

    Note that while reporting debug events, all threads withing the
    reporting process are frozen.  This has nothing to do with
    SuspendThread or ResumeThread.  Debuggers are expected to use
    SuspendThread and ResumeThread to limit the set of threads that can
    execute within a process.  By suspending all threads in a process
    except for the one reporting a debug event, it is possible to
    "single step" a single thread.  The other threads will not be
    released by a continue if they are suspended.

Arguments:

    hThread - Supplies a handle to the thread that is to be resumed.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
        GetLastError.

    Other - The target thread was resumed (or was not previously
        suspended).  The return value is the thread's previous suspend
        count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtResumeThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

VOID
APIENTRY
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST ULONG_PTR *lpArguments
    )

/*++

Routine Description:

    Raising an exception causes the exception dispatcher to go through
    its search for an exception handler.  This includes debugger
    notification, frame based handler searching, and system default
    actions.

Arguments:

    dwExceptionCode - Supplies the exception code of the exception being
        raised.  This value may be obtained in exception filters and in
        exception handlers by calling GetExceptionCode.

    dwExceptionFlags - Supplies a set of flags associated with the exception.

    dwExceptionFlags Flags:

        EXCEPTION_NONCONTINUABLE - The exception is non-continuable.
            Returning EXCEPTION_CONTINUE_EXECUTION from an exception
            marked in this way causes the
            STATUS_NONCONTINUABLE_EXCEPTION exception.

    nNumberOfArguments - Supplies the number of arguments associated
        with the exception.  This value may not exceed
        EXCEPTION_MAXIMUM_PARAMETERS.  This parameter is ignored if
        lpArguments is NULL.

    lpArguments - An optional parameter, that if present supplies the
        arguments for the exception.

Return Value:

    None.

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);
}

VOID
XapiDispatchAPC(
    LPVOID lpApcArgument1,
    LPVOID lpApcArgument2,
    LPVOID lpApcArgument3
    )
{
    PAPCFUNC pfnAPC;
    ULONG_PTR dwData;

    pfnAPC = (PAPCFUNC)lpApcArgument1;
    dwData = (ULONG_PTR)lpApcArgument2;
    (pfnAPC)(dwData);
}


WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    )
/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.

Arguments:

    pfnAPC - Supplies the address of the APC routine to execute when the
        APC fires.

    hHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    dwData - Supplies a DWORD passed to the APC

Return Value:

    TRUE - The operations was successful

    FALSE - The operation failed. GetLastError() is not defined.

--*/

{
    NTSTATUS Status;

    Status = NtQueueApcThread(
                hThread,
                (PPS_APC_ROUTINE)XapiDispatchAPC,
                (PVOID)pfnAPC,
                (PVOID)dwData,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return 1;
}

BOOL
WINAPI
SwitchToThread(
    VOID
    )

/*++

Routine Description:

    This function causes a yield from the running thread to any other
    thread that is ready and can run on the current processor.  The
    yield will be effective for up to one quantum and then the yielding
    thread will be scheduled again according to its priority and
    whatever other threads may also be avaliable to run.  The thread
    that yields will not bounce to another processor even it another
    processor is idle or running a lower priority thread.

Arguments:

    None

Return Value:

    TRUE - Calling this function caused a switch to another thread to occur
    FALSE - There were no other ready threads, so no context switch occured

--*/

{

    if ( NtYieldExecution() == STATUS_NO_YIELD_PERFORMED ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}

VOID
APIENTRY
ExitThread(
    DWORD dwExitCode
    )

/*++

Routine Description:

    The current thread can exit using ExitThread.

    ExitThread is the prefered method of exiting a thread.  When this
    API is called (either explicitly or by returning from a thread
    procedure), The current thread's stack is deallocated and the thread
    terminates.  If the thread is the last thread in the process when
    this API is called, the behavior of this API does not change.  DLLs
    are not notified as a result of a call to ExitThread.

Arguments:

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    None.

--*/

{
    XapiCallThreadNotifyRoutines(FALSE);

    PsTerminateSystemThread(dwExitCode);
}

BOOL
APIENTRY
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a thread can be read using
    GetExitCodeThread.

    If a Thread is in the signaled state, calling this function returns
    the termination status of the thread.  If the thread is not yet
    signaled, the termination status returned is STILL_ACTIVE.

Arguments:

    hThread - Supplies a handle to the thread whose termination status is
        to be read.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the
        thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        *lpExitCode = KeReadStateThread(&Thread->Tcb) ? Thread->ExitStatus : STATUS_PENDING;
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )

/*++

Routine Description:

    This function allows an application to supersede the top level
    exception handler that Win32 places at the top of each thread and
    process.

    If an exception occurs, and it makes it to the Win32 unhandled
    exception filter, and the process is not being debugged, the Win32
    filter will call the unhandled exception filter specified by
    lpTopLevelExceptionFilter.

    This filter may return:

        EXCEPTION_EXECUTE_HANDLER - Return from the Win32
            UnhandledExceptionFilter and execute the associated
            exception handler.  This will usually result in process
            termination

        EXCEPTION_CONTINUE_EXECUTION - Return from the Win32
            UnhandledExceptionFilter and continue execution from the
            point of the exception.  The filter is of course free to
            modify the continuation state my modifying the passed
            exception information.

        EXCEPTION_CONTINUE_SEARCH - Proceed with normal execution of the
            Win32 UnhandledExceptionFilter.  e.g.  obey the SetErrorMode
            flags, or invoke the Application Error popup.

    This function is not a general vectored exception handling
    mechanism.  It is intended to be used to establish a per-process
    exception filter that can monitor unhandled exceptions at the
    process level and respond to these exceptions appropriately.

Arguments:

    lpTopLevelExceptionFilter - Supplies the address of a top level
        filter function that will be called whenever the Win32
        UnhandledExceptionFilter gets control, and the process is NOT
        being debugged.  A value of NULL specifies default handling
        within the Win32 UnhandledExceptionFilter.

Return Value:

    This function returns the address of the previous exception filter
    established with this API.  A value of NULL means that there is no
    current top level handler.

--*/

{
    LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

    PreviousTopLevelFilter = XapiCurrentTopLevelFilter;
    XapiCurrentTopLevelFilter = lpTopLevelExceptionFilter;

    return PreviousTopLevelFilter;
}

BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    thread specified by hThread.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hThread - Supplies an open handle to the specified thread.  The
        handle must have been created with THREAD_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the thread.

    lpExitTime - Returns the exit time of a thread.  If the thread has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this thread has
        executed in kernel-mode.

    lpUserTime - Returns the amount of time that this thread has
        executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        *((PLARGE_INTEGER)lpCreationTime) = Thread->CreateTime;

        if (KeReadStateThread(&Thread->Tcb)) {
            *((PLARGE_INTEGER)lpExitTime) = Thread->ExitTime;
        } else {
            ((PLARGE_INTEGER)lpExitTime)->QuadPart = 0;
        }

        ((PLARGE_INTEGER)lpKernelTime)->QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
            *KeTimeIncrement);
        ((PLARGE_INTEGER)lpUserTime)->QuadPart = 0;

        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

XBOXAPI
VOID
WINAPI
XRegisterThreadNotifyRoutine(
    PXTHREAD_NOTIFICATION pThreadNotification,
    BOOL fRegister
    )

/*++

Routine Description:

    Register or deregister a notification routine
    which will be called when a thread is created or deleted.

Arguments:

    pThreadNotification - Points to a XTHREAD_NOTIFICATION structure
        NOTE: The XTHREAD_NOTIFICATION structure must remain
        valid until the thread notification routine is deregistered.
        For example, you can use a global variable for this.
        But you should NOT use a local variable inside a function.

    fRegister - TRUE to register a new thread notification routine
        FALSE to deregister a previously registered notification routine

Return Value:

    None.

--*/

{
    XapiAcquireProcessLock();

    if (fRegister) {
        InsertTailList(&XapiThreadNotifyRoutineList,
            &pThreadNotification->ListEntry);
    } else {
        RemoveEntryList(&pThreadNotification->ListEntry);
    }

    XapiReleaseProcessLock();
}

XBOXAPI
VOID
XSetProcessQuantumLength(
    IN DWORD dwMilliseconds
    )

/*++

Routine Description:

    This routine changes the quantum length for the current process.  Changing
    the quantum length does not affect the quantum of the current thread.

    The quantum length determines the number of milliseconds that a thread is
    executed before the scheduler selects the next ready thread to execute.

Arguments:

    dwMilliseconds - Supplies the number of milliseconds for the process quantum
        length.

Return Value:

    None.

--*/

{
    LONG ThreadQuantum;

    if (dwMilliseconds == 0 || dwMilliseconds > 1000) {
        RIP("XSetProcessQuantumSize() invalid parameter (dwMilliseconds)");
    }

    ThreadQuantum = dwMilliseconds * CLOCK_QUANTUM_DECREMENT;
    KeGetCurrentThread()->ApcState.Process->ThreadQuantum = ThreadQuantum;
}

XBOXAPI
DWORD
XGetProcessQuantumLength(
    VOID
    )

/*++

Routine Description:

    This routine returns the quantum length for the current process.

    The quantum length determines the number of milliseconds that a thread is
    executed before the scheduler selects the next ready thread to execute.

Arguments:

    None.

Return Value:

    Returns the number of milliseconds for the process quantum length.

--*/

{
    LONG ThreadQuantum;

    ThreadQuantum = KeGetCurrentThread()->ApcState.Process->ThreadQuantum;

    return ThreadQuantum / CLOCK_QUANTUM_DECREMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\synch.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements all Win32 syncronization
    objects.

--*/

#include "basedll.h"

//
// Event Services
//

HANDLE
APIENTRY
CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    PCOSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateEvent(
                &Handle,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExEventObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
PulseEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the Signaled state and reset to the Not-
    Signaled state atomically with the PulseEvent function.

    Pulsing the event causes the event to attain a state of Signaled,
    release appropriate threads, and then reset the event.  When no
    waiters are currently waiting on the event, pulsing an event causes
    the event to release no threads and end up in the Not-Signaled
    state.  With waiters waiting on an event, pulsing an event has a
    different effect for manual reset events that it does for automatic
    reset events.  For manual reset events, pulsing releases all waiters
    and then leaves the event in the Not-Signaled state.  For automatic
    reset events, pulsing the event releases a single waiter and then
    leaves the event in the Not-Signaled state.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtPulseEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Semaphore Services
//

HANDLE
APIENTRY
CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    PCOSTR lpName
    )

/*++

Routine Description:

    A semaphore object is created and a handle opened for access to the
    object with the CreateSemaphore function.

    The CreateSemaphore function causes a semaphore object to be created
    which contains the specified initial and maximum counts.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for semaphore
    objects:

        - SEMAPHORE_MODIFY_STATE - Modify state access (release) to the
            semaphore is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the semaphore
            is desired.

        - SEMAPHORE_ALL_ACCESS - This set of access flags specifies all
            of the possible access flags for a semaphore object.


Arguments:

    lpSemaphoreAttributes - An optional parameter that may be used to
        specify the attributes of the new semaphore.  If the parameter
        is not specified, then the semaphore is created without a
        security descriptor, , and the resulting handle is not inherited
        on process creation.

    lInitialCount - The initial count for the semaphore, this value
        must be positive and less than or equal to the maximum count.

    lMaximumCount - The maximum count for the semaphore, this value
        must be greater than zero..

    lpName - Supplies an optional unicode name for the object.

Return Value:

    NON-NULL - Returns a handle to the new semaphore.  The handle has
        full access to the new semaphore and may be used in any API that
        requires a handle to a semaphore object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateSemaphore(
                &Handle,
                pObja,
                lInitialCount,
                lMaximumCount
                );
    
    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenSemaphore(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExSemaphoreObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


BOOL
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    )

/*++

Routine Description:

    A semaphore object can be released with the ReleaseSemaphore
    function.

    When the semaphore is released, the current count of the semaphore
    is incremented by the ReleaseCount.  Any threads that are waiting
    for the semaphore are examined to see if the current semaphore value
    is sufficient to satisfy their wait.

    If the value specified by ReleaseCount would cause the maximum count
    for the semaphore to be exceeded, then the count for the semaphore
    is not affected and an error status is returned.


Arguments:

    hSemaphore - Supplies an open handle to a semaphore object.  The
        handle must have SEMAPHORE_MODIFY_STATE access to the semaphore.

    lReleaseCount - The release count for the semaphore.  The count
        must be greater than zero and less than the maximum value
        specified for the semaphore.

    lpPreviousCount - An optional pointer to a variable that receives
        the previous count for the semaphore.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseSemaphore(hSemaphore,lReleaseCount,lpPreviousCount);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Mutex Services
//

HANDLE
APIENTRY
CreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    PCOSTR lpName
    )

/*++

Routine Description:

    A mutex object can be created and a handle opened for access to the
    object with the CreateMutex function.

    A new mutex object is created and a handle opened to the object with
    ownership as determined by the InitialOwner parameter.  The status
    of the newly created mutex object is set to not abandoned.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for mutex
    objects:

        - MUTEX_MODIFY_STATE - Modify access to the mutex is desired.
          This allows a process to release a mutex.

        - SYNCHRONIZE - Synchronization access (wait or release) to the
          mutex object is desired.

        - MUTEX_ALL_ACCESS - All possible types of access to the mutex
          object are desired.


Arguments:

    lpMutexAttributes - An optional parameter that may be used to specify
        the attributes of the new mutex.  If the parameter is not
        specified, then the mutex is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bInitialOwner - A boolean value that determines whether the creator
        of the object desires immediate ownership of the mutex object.


    lpName - Supplies an optional unicode name for the mutex.

Return Value:

    NON-NULL - Returns a handle to the new mutex.  The handle has full
        access to the new mutex and may be used in any API that
        requires a handle to a mutex object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateMutant(
                &Handle,
                pObja,
                (BOOLEAN)bInitialOwner
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenMutex(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExMutantObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
ReleaseMutex(
    HANDLE hMutex
    )

/*++

Routine Description:

    Ownership of a mutex object can be released with the ReleaseMutex
    function.

    A mutex object can only be released by a thread that currently owns
    the mutex object.  When the mutex is released, the current count of
    the mutex object is incremented by one.  If the resultant count is
    one, then the mutex object is no longer owned.  Any threads that are
    waiting for the mutex object are examined to see if their wait can
    be satisfied.

Arguments:

    hMutex - An open handle to a mutex object.  The handle must
        have MUTEX_MODIFY_STATE access to the mutex.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseMutant(hMutex,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Wait Services
//

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForSingleObjectEx(hHandle,
                                     UserMode,
                                     (BOOLEAN)bAlertable,
                                     pTimeOut);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }
    return (DWORD)Status;
}


DWORD
WINAPI
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtSignalAndWaitForSingleObjectEx(
                hObjectToSignal,
                hObjectToWaitOn,
                UserMode,
                (BOOLEAN)bAlertable,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }
    return (DWORD)Status;
}

DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    HANDLE HandleArray[MAXIMUM_WAIT_OBJECTS];

    if (nCount > MAXIMUM_WAIT_OBJECTS) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return (DWORD)0xffffffff;
    }
    RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForMultipleObjectsEx(
                 (CHAR)nCount,
                 HandleArray,
                 bWaitAll ? WaitAll : WaitAny,
                 UserMode,
                 (BOOLEAN)bAlertable,
                 pTimeOut
                 );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }

    return (DWORD)Status;
}

VOID
Sleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    SleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
    if (pTimeOut == NULL) {
        //
        // If Sleep( -1 ) then delay for the longest possible integer
        // relative to now.
        //

        TimeOut.LowPart = 0x0;
        TimeOut.HighPart = 0x80000000;
        pTimeOut = &TimeOut;
        }

rewait:
    Status = KeDelayExecutionThread(
                UserMode,
                (BOOLEAN)bAlertable,
                pTimeOut
                );
    if ( bAlertable && Status == STATUS_ALERTED ) {
        goto rewait;
        }
    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE
WINAPI
CreateWaitableTimer(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    PCOSTR lpTimerName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpTimerName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateTimer(
                &Handle,
                pObja,
                bManualReset ? NotificationTimer : SynchronizationTimer
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenWaitableTimer(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpTimerName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpTimerName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitObjectString(&ObjectName,lpTimerName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExTimerObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
WINAPI
SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    )
{
    NTSTATUS Status;

    Status = NtSetTimerEx(
                hTimer,
                (PLARGE_INTEGER)lpDueTime,
                (PTIMER_APC_ROUTINE)pfnCompletionRoutine,
                UserMode,
                lpArgToCompletionRoutine,
                (BOOLEAN) fResume,
                lPeriod,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        if ( Status == STATUS_TIMER_RESUME_IGNORED ) {
            SetLastError(ERROR_NOT_SUPPORTED);
            }
        else {
            SetLastError(0);
            }
        return TRUE;
        }
}

BOOL
WINAPI
CancelWaitableTimer(
    HANDLE hTimer
    )
{
    NTSTATUS Status;

    Status = NtCancelTimer(hTimer,NULL);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\tls.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Local Storage APIs

--*/

#include "basedll.h"
#pragma hdrstop

//
// Array of per thread TLS slots.
//
__declspec(thread) PVOID XapiTlsSlots[TLS_MINIMUM_AVAILABLE];

//
// Bitmap of the allocated TLS slots.
//
ULONG XapiTlsAllocBitmap[TLS_MINIMUM_AVAILABLE / 32] = {
    0xFFFFFFFF
};

DWORD
APIENTRY
TlsAlloc(
    VOID
    )
/*++

Routine Description:

    A TLS index may be allocated using TlsAlloc.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFree, TlsSetValue, or TlsGetValue.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    DWORD dwBitmapIndex;
    DWORD dwBitIndex;
    DWORD dwTlsIndex;

    XapiAcquireProcessLock();

    dwTlsIndex = 0xffffffff;

    for (dwBitmapIndex = 0; dwBitmapIndex < ARRAYSIZE(XapiTlsAllocBitmap);
        dwBitmapIndex++) {

        //
        // If the bitmap location contains a non-zero value, then there's at
        // least TLS index that we can allocate from this block.  Find the
        // lowest free bit and remove it from the bitmap.
        //

        if (XapiTlsAllocBitmap[dwBitmapIndex] != 0) {
            dwBitIndex = RtlFindFirstSetRightMember(XapiTlsAllocBitmap[dwBitmapIndex]);
            XapiTlsAllocBitmap[dwBitmapIndex] &= ~(1 << dwBitIndex);
            dwTlsIndex = (dwBitmapIndex * 32) + dwBitIndex;
            break;
        }
    }

    XapiReleaseProcessLock();

    return dwTlsIndex;
}

LPVOID
APIENTRY
TlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAlloc and TlsGetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    RIP_ON_NOT_TRUE("TlsGetValue()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    return XapiTlsSlots[dwTlsIndex];
}

BOOL
APIENTRY
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAlloc and TlsSetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    RIP_ON_NOT_TRUE("TlsSetValue()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    XapiTlsSlots[dwTlsIndex] = lpTlsValue;

    return TRUE;
}

BOOL
APIENTRY
TlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFree.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful. TlsAlloc is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    DWORD dwBitmapIndex;
    DWORD dwBitIndex;
    ULONG TlsDataRelativeOffset;
    KIRQL OldIrql;
    PKPROCESS Process;
    PLIST_ENTRY NextListEntry;
    PKTHREAD Thread;

    RIP_ON_NOT_TRUE("TlsFree()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    XapiAcquireProcessLock();

    dwBitmapIndex = dwTlsIndex / 32;
    dwBitIndex = dwTlsIndex % 32;

    //
    // Mark the TLS index as free.
    //

    XapiTlsAllocBitmap[dwBitmapIndex] |= (1 << dwBitIndex);

    //
    // Compute the TLS data relative byte offset for the supplied TLS index.
    //

    TlsDataRelativeOffset = (ULONG_PTR)&XapiTlsSlots[dwTlsIndex] -
        (ULONG_PTR)KeGetCurrentThread()->TlsData;

    //
    // Loop over the active threads and zero out the freed TLS slot.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();
    Process = KeGetCurrentThread()->ApcState.Process;
    NextListEntry = Process->ThreadListHead.Flink;

    while (NextListEntry != &Process->ThreadListHead) {

        Thread = CONTAINING_RECORD(NextListEntry, KTHREAD, ThreadListEntry);

        //
        // Only zero out the freed TLS slot for threads created by XAPI.
        //

        if (Thread->TlsData != NULL) {
            *((LPVOID*)((ULONG_PTR)Thread->TlsData + TlsDataRelativeOffset)) = NULL;
        }

        NextListEntry = Thread->ThreadListEntry.Flink;
    }

    KeLowerIrql(OldIrql);

    XapiReleaseProcessLock();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\virtual.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    virtual.c

Abstract:

    This module implements the Win32 virtual memory management services.

--*/

#include "basedll.h"
#pragma hdrstop


PVOID
WINAPI
VirtualAlloc(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

#if DBG
    if (lpAddress != NULL && (ULONG_PTR)lpAddress < MM_ALLOCATION_GRANULARITY)
    {
        RIP("VirtualAlloc() invalid parameter (lpAddress)");
    }
#endif // DBG

    Status = NtAllocateVirtualMemory( &lpAddress,
                                      0,
                                      &dwSize,
                                      flAllocationType,
                                      flProtect
                                    );

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
        }
    else {
        XapiSetLastNTError( Status );
        return( NULL );
        }
}

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;

    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        XapiSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        XapiSetLastNTError( Status );
        return( FALSE );
        }
}


BOOL
WINAPI
VirtualProtect(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        XapiSetLastNTError( Status );
        return( FALSE );
        }
}

DWORD
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    )
{
    NTSTATUS Status;

    Status = NtQueryVirtualMemory( (LPVOID)lpAddress,
                                   lpBuffer
                                 );
    if (NT_SUCCESS( Status )) {
        return( sizeof(*lpBuffer) );
        }
    else {
        XapiSetLastNTError( Status );
        return( 0 );
        }
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{

    return VirtualAlloc(
                lpAddress,
                dwSize,
                flAllocationType,
                flProtect
                );

}


BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    return VirtualFree(lpAddress,dwSize,dwFreeType);
}


BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{

    return VirtualProtect( lpAddress,
                           dwSize,
                           flNewProtect,
                           lpflOldProtect
                         );
}


DWORD
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    )
{

    return VirtualQuery( lpAddress,
                         (PMEMORY_BASIC_INFORMATION)lpBuffer,
                         dwLength
                       );
}


VOID
WINAPI
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    )
{
    MM_STATISTICS MemoryStatistics;

    MemoryStatistics.Length = sizeof(MM_STATISTICS);
    MmQueryStatistics(&MemoryStatistics);

    lpBuffer->dwLength = sizeof(*lpBuffer);
    lpBuffer->dwMemoryLoad = 0;
    lpBuffer->dwTotalPageFile = 0;
    lpBuffer->dwAvailPageFile = 0;
    lpBuffer->dwTotalPhys = (MemoryStatistics.TotalPhysicalPages << PAGE_SHIFT);
    lpBuffer->dwAvailPhys = (MemoryStatistics.AvailablePages << PAGE_SHIFT);
    lpBuffer->dwTotalVirtual = (ULONG_PTR)MM_HIGHEST_USER_ADDRESS -
        (ULONG_PTR)MM_LOWEST_USER_ADDRESS + 1;
    lpBuffer->dwAvailVirtual = lpBuffer->dwTotalVirtual -
        MemoryStatistics.VirtualMemoryBytesReserved;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xclndrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   xclndrv.c

Abstract:

    API's that clean drives by reclaiming empty title directories
    and corrupt games.

Author:

    Mitchell S. Dernis (mitchd) 05-Jun-2001

Revision History:

--*/

#include "basedll.h"



#ifdef XAPILIBP

DWORD
WINAPI
XCleanMUFromRoot(
    IN OCHAR chDrive,
    PCOSTR pszPreserveDir OPTIONAL
    )
/*++
  Routine Description:
    From a root mounted MU drive, clean all the title directories that do not
    contain games.  Except do not cleanup the directory specified by pszPreserveDir
  Arguments:
    chDrive - drive letter of root mounted MU.
    pszPreserveDir OPTIONAL - title directory to preserve, even if it has no games.
--*/
{
    NTSTATUS status;
    OCHAR szDosDevice[25];
    
    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= ~0x20;

    //
    //  Debug check to make sure that this is an MU it should be root mounted.
    //
#if DBG
    if (
         ((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE))
    )
    {
        RIP("XCleanDrive() invalid drive letter parameter");
    }
#endif // DBG
    
    //
    //  Create a string with the full dos name
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:\\"), chDrive);

    //
    // Call XapiNukeSubdirsWithoutSubdirs.  
    //
    return XapiNukeEmptySubdirs(szDosDevice, pszPreserveDir, TRUE);
}

DWORD 
WINAPI
XCleanDrive(
    IN OCHAR chDrive
)
/*++
  Routine Description:
    From a mounted title drive (T, or any mounted MU, but not a root mounted MU),
    find all the title areas on the drive and cleanup any directory that does not
    contain valid saved games.  Except do not cleanup the directory of the current
    title.

  Arguments:
    chDrive - drive letter to cleanup

  Comments:
    XCleanDrive and DWORD XCleanMUFromRoot are both tasked with finding the root of a volume of
    title directories, and then cleaning them up.  XapiNukeSubdirsWithoutSubdirs
    does the work.
--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING ObjectName;
    OCHAR szDosDevice[25];
    OCHAR Target[MAX_PATH+1];
    ULONG TargetLength;
    OCHAR oszPreserveDir[CCHMAX_HEX_DWORD];
    OBJECT_STRING ObjectTarget;
    HANDLE Handle;
    
    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= ~0x20;

    //
    //  Debug check to make sure that this is an MU or the T: drive.
    //
#if DBG
    if ((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE))
    {
        RIP("XCleanDrive() invalid drive letter parameter");
    }
#endif // DBG
    
    //
    //  Open the symbolic link, at the real path
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);

    RtlInitObjectString(&ObjectName, szDosDevice);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target)-1;

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    //
    //  The title directory must be of length CCHMAX_HEX_DWORD.
    //
    if ((TargetLength < CCHMAX_HEX_DWORD) ||
        ('\\' != Target[TargetLength - (CCHMAX_HEX_DWORD)]))
    {
        return ERROR_INVALID_DRIVE;
    }

    //
    //  Break the Target into two strings.  The root path,
    //  and the current title library.
    //
    Target[TargetLength] = OBJECT_NULL;
    ocscpy(oszPreserveDir, &Target[TargetLength - (CCHMAX_HEX_DWORD)+1]);
    Target[TargetLength - (CCHMAX_HEX_DWORD)+1] = OBJECT_NULL; //remove subdir - maintain '\\'

    //
    // Call XapiNukeEmptySubdirs.  For all drives but T, we nuke the directory even if it contains  
    // files, as long as it has no subdirectories.
    //
    return XapiNukeEmptySubdirs(Target, oszPreserveDir, (HD_TDATA_DRIVE == chDrive) ? FALSE : TRUE );
}


DWORD 
XapiNukeEmptySubdirs(
    IN PCOSTR  pszDrivePath,
    IN PCOSTR  pszPreserveDir OPTIONAL,
    IN BOOLEAN fNukeFiles
    )
/*++
  Routine Description:
    
    Nukes all "empty} subdirectories under pszDrivePath, excluding the
    directory optionally specified by pszPreserveDir.

  Arguments:

    pszDrivePath   - path to directory that contains subdirectories.
    pszPreserveDir - optional relative path to single subdirectory
                     to preserve even if it does not have any subdirectories.
    fNukeFiles     - if true, it consider subdirectories empty even if they 
                     contain files, as long as they do not contain more
                     subdirectories.
  Comments:
    The motivation for having such a bizarre routine in XAPI is as a helper for cleaning
    up title directories.

    The primary clients are XCleanDrive and XCleanMUFromRoot.  The idea is
    to nuke empty title directories that do not contain useful user data.  There
    are two cases: U:\ (and all the MU's) and T:\.  In both cases, every time a
    game boots (and in the case of MU's mounts them) a subdirectory is created for
    that title.  For U:\ (and the MUs) each saved game is in a subdirectory.  Files
    that are not in a subdirectory are considered expandable.  In the T:\ case even
    individual files should be saved.  Thus fNukeFiles is passed as FALSE when
    cleaning the T:\ drive and TRUE for the other drives.

    pszPreserveDir is used to avoid deleting the title directory of the current title.
    It can be NULL.  The dashboard does this when cleaning up MU's.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE hRoot;
    ULONG EndingIndex;
    OBJECT_STRING DirectoryName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN fFindFirstFile = TRUE;
    struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} Buffer;
    PFILE_DIRECTORY_INFORMATION DirectoryInfo = &Buffer.DirInfo;
    

    RtlInitObjectString(&DirectoryName, pszDrivePath);

    InitializeObjectAttributes(
        &Obja,
        &DirectoryName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access.
    //

    Status = NtOpenFile(
                 &hRoot,
                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    //
    // Loop over and find all the subdirectories
    //
    while(NT_SUCCESS(Status))
    {
        Status = NtQueryDirectoryFile(
                 hRoot,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 DirectoryInfo,
                 sizeof(Buffer)-sizeof(OCHAR),
                 FileDirectoryInformation,
                 NULL,
                 fFindFirstFile
                 );
        fFindFirstFile = FALSE;
        //
        //  If we found a file, we need to determine if it is a subdirectory
        //  without subdirectories.
        //
        if(NT_SUCCESS(Status))
        {
           //
           //  Proceed only if it is a directory
           //
           if(DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
           {
               //
               //  Null terminate the name in place.  Note that we passed
               //  NtQueryDirectoryFile a small buffer length to save room for a NULL.
               //
               DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

               //
               //  Proceed only if we were not passed a directory to preserve, or
               //  if this is not that directory.
               //
               if(!pszPreserveDir || ocscmp(DirectoryInfo->FileName, pszPreserveDir))
               {
                   HANDLE   hSubDir;
                   NTSTATUS SubDirStatus;
                   BOOLEAN  fFindFirstSubDir = TRUE;
                   
                   //
                   // Open the subdirectory with FILE_LIST_DIRECTORY access
                   // to see if it has any subdirectories, and with DELETE and 
                   // FILE_WRITE_ATTRIBUTES access.
                   // 
                   // DELETE in case we need to delete it.  FILE_WRITE_ATTRIBUTES
                   // in case it turns out to have FILE_ATTRIBUTE_READONLY set
                   // when we go to DELETE it.
                   //
                   RtlInitObjectString(&DirectoryName, DirectoryInfo->FileName);
                   InitializeObjectAttributes(
                     &Obja,
                     &DirectoryName,
                     OBJ_CASE_INSENSITIVE,
                     hRoot,
                     NULL
                     );
                   SubDirStatus = NtOpenFile(
                         &hSubDir,
                         FILE_LIST_DIRECTORY | DELETE | FILE_WRITE_ATTRIBUTES |SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

                   //
                   // Loop while successful, except we break if we 
                   // as soon as we know that we want to preserve
                   // this subdirectory.
                   //
                   while(NT_SUCCESS(SubDirStatus))
                   {
                      SubDirStatus = NtQueryDirectoryFile(
                                         hSubDir,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         DirectoryInfo,
                                         sizeof(Buffer)-sizeof(OCHAR),
                                         FileDirectoryInformation,
                                         NULL,
                                         fFindFirstSubDir
                                         );
                       fFindFirstSubDir = FALSE;
                       
                       if(NT_SUCCESS(SubDirStatus))
                       {
                           //
                           //  If the fNukeFiles is not set, or 
                           //  if this is a directory, then we break.
                           //  This will leave the loop with Status ==
                           //  STATUS_SUCCESS, which prevents this subdirectory 
                           //  from being nuked.
                           //
                           if(!fNukeFiles || DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
                           {
                             break;
                           }
                       }
                   }

                   //
                   //  If !fFindFirstSubDir, then we have an opened
                   //  hSubDir handle.
                   //
                   if(!fFindFirstSubDir)
                   {
                       //
                       //   If we got to the end of the loop and didn't
                       //   find a file (if fNukeFile not set) or a
                       //   subdirectory in the subdirectory, then
                       //   nuke it.
                       //
                       if(
                           (STATUS_NO_MORE_FILES == SubDirStatus) ||
                           (STATUS_NO_SUCH_FILE == SubDirStatus)
                        )
                       {
                           XapiNukeDirectoryFromHandle(hSubDir, DirectoryInfo);    
                       }
                       //
                       //   We are done with the subdirectory, if we
                       //   called XapiNukeDirectoryFromHandle on the
                       //   handle, this finishes the job.  Otherwise,
                       //   the directory should still be around.
                       //
                       NtClose(hSubDir);
                   }
               }
           }
        }
    }

    //
    //  !fFindFirstFile implies that we manage open the root directory.
    //  If so we know that STATUS_NO_SUCH_FILE refers to the attempt
    //  to find subdirectories, and not to opening the root.
    //  Doctor error codes, and close the root.
    //
    if(!fFindFirstFile)
    {
        //
        //  The normal "successful" thing is that Status is STATUS_NO_MORE_FILES or
        //  STATUS_NO_SUCH_FILE. The caller just wants to see STATUS_SUCCESS.
        //
        if(
            (Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_SUCH_FILE)
        )
        {
            Status = STATUS_SUCCESS;
        }
        NtClose(hRoot);
    }

    return RtlNtStatusToDosError(Status);
}

#endif //XAPILIBP

#ifndef XAPILIBP

#undef DeleteFile
NTSTATUS
XapiNukeDirectoryFromHandle(
    HANDLE                      hDirectory,
    PFILE_DIRECTORY_INFORMATION DirectoryInfo
    )
/*++
  Routine Description:
    Helper function for XapiNukeDirectory.  Basically, it does the
    recursion of subdirectories.  It is more convenient to recursive
    using a handle.  This avoids writing ugly string parsing code which
    I am sure already exists in the object manager.  Additionally, since
    it doesn't open and close handles it is probably more efficient too.

  Arguments:
    hDirectory    - handle to directory to recursively delete.  Must be opened
                    with (FILE_LIST_DIRECTORY|DELETE|SYNCHRONIZE) access.
    DirectoryInfo - pointer to a FILE_DIRECTORY_INFORMATION immediately followed
                    by 255 characters (i.e. size must be sizeof(FILE_DIRECTORY_INFORMATION)
                    +sizeof(OCHAR)*255.
--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING FileName;
    HANDLE hFile;
    BOOLEAN fFindFirst = TRUE;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_DISPOSITION_INFORMATION Disposition;

    do
    {
        Status = NtQueryDirectoryFile(
                    hDirectory,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(FILE_DIRECTORY_INFORMATION)+sizeof(OCHAR)*254,
                    FileDirectoryInformation,
                    NULL,
                    fFindFirst
                    );
        fFindFirst = FALSE;
        //
        // If we succesfully found a file or directory then we have work to do
        //
        if (NT_SUCCESS(Status))
        {
            BOOLEAN fIsDirectory = (FILE_ATTRIBUTE_DIRECTORY&DirectoryInfo->FileAttributes) ? TRUE : FALSE;
            ACCESS_MASK accessMask = FILE_WRITE_ATTRIBUTES | DELETE | SYNCHRONIZE | (fIsDirectory ? FILE_LIST_DIRECTORY : 0);
            ULONG OpenOptions = FILE_OPEN_FOR_BACKUP_INTENT | (fIsDirectory ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE);
            
            //
            //  Null terminate filename
            //
            DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

            //
            //  Create an OBJECT_STRING for the relative path of the filename
            //
            RtlInitObjectString(&FileName, DirectoryInfo->FileName);

            //
            //  Initialize Obja with Handle of the parent and the relative path.
            //
            InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                hDirectory,
                NULL
                );

            //
            // Open the file
            //
            Status = NtOpenFile(
                        &hFile,
                        accessMask,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        OpenOptions
                        );

            if(NT_SUCCESS(Status))
            {
                //
                //  If it is a directory call ourselves recursively.
                //
                if(fIsDirectory)
                {
                    XapiNukeDirectoryFromHandle(hFile, DirectoryInfo);
                } else
                //
                //  Otherwise, Set FileDispositionInformation.DeleteFile = TRUE
                //
                {
                    //
                    //  If it has FILE_ATTRIBUTE_READONLY clear that first.
                    //
                    if(DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_READONLY)
                    {
                        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
                        BasicInfo.FileAttributes = 
                            (DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_VALID_SET_FLAGS)&
                            ~FILE_ATTRIBUTE_READONLY;
                        BasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            
                        Status = NtSetInformationFile(
                                    hFile,
                                    &IoStatusBlock,
                                    &BasicInfo,
                                    sizeof(BasicInfo),
                                    FileBasicInformation
                                    );
                    }

                    if(NT_SUCCESS(Status))
                    {
                        //
                        // Sets to delete on close
                        //
                        Disposition.DeleteFile = TRUE;
                        Status = NtSetInformationFile(
                                    hFile,
                                    &IoStatusBlock,
                                    &Disposition,
                                    sizeof(Disposition),
                                    FileDispositionInformation
                                    );
                    }
                }
                //
                //  Close the handle, if it was a file this will delete it.
                //  If it was a directory, this should also delete it,
                //  provided the recursion succeeded.
                //
                NtClose(hFile);
            }
        }
    }while(NT_SUCCESS(Status));

    //
    //  If the loop terminated normally (we ran out of files to
    //  delete, or there were none in the first place), delete
    //  this handle.
    //
    if(
        (STATUS_NO_MORE_FILES == Status) ||
        (STATUS_NO_SUCH_FILE == Status)
    )
    {
        //
        //  Don't know if it is READ_ONLY.  Just blast over it,
        //  it will be deleted in a second anyway.
        //
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = 
            (DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_VALID_SET_FLAGS)&
            ~FILE_ATTRIBUTE_READONLY;
            BasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
        //
        //  Don't checked the error, this could conceivably fail
        //  and the coming delete will work anyway.  We would be fully
        //  satisfied.
        //
        NtSetInformationFile(
            hDirectory,
            &IoStatusBlock,
            &BasicInfo,
            sizeof(BasicInfo),
            FileBasicInformation
            );
        

        //
        // Sets to delete on close, the caller will
        // finish off the delete by closing the handle
        // it passed in.
        //
        Disposition.DeleteFile = TRUE;
        Status = NtSetInformationFile(
                        hDirectory,
                        &IoStatusBlock,
                        &Disposition,
                        sizeof(Disposition),
                        FileDispositionInformation
                        );
    }
    return Status;
}


NTSTATUS
XapiNukeDirectory(
    PCOSTR pszPath
    )
/*++
  Routine Description:
   Deletes a directory and all of its contents.
--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING DirectoryName;
    HANDLE hDirectory;
    ASSERT(pszPath);

    //
    //  Open the file with delete permission
    //

    RtlInitObjectString(&DirectoryName, pszPath);
    InitializeObjectAttributes(
        &Obja,
        &DirectoryName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
            &hDirectory,
            FILE_LIST_DIRECTORY | DELETE | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
            &Obja,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
            );

    if(NT_SUCCESS(Status))
    {
        struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} Buffer;
        PFILE_DIRECTORY_INFORMATION DirectoryInfo = &Buffer.DirInfo;

        //
        //  Delegate to XapiNukeDirectoryFromHandle.
        //
        
        Status = XapiNukeDirectoryFromHandle(hDirectory, DirectoryInfo);

        //
        //  Close the handle, if XapiNukeDirectoryFromHandle was successful
        //  this will delete the file.
        //
        NtClose(hDirectory);
    }
    return Status;
}

#endif //XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xemodule.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    xemodule.c

Abstract:

    This module contains implementation of the routines that interface with
    XE loader in the kernel

--*/

#include "basedll.h"
#pragma hdrstop

#define IsValidSectionHandle(hSection) \
    (((PVOID)hSection >= (PVOID)XeImageHeader()->SectionHeaders) && \
    ((PVOID)hSection < (PVOID)(XeImageHeader()->SectionHeaders + XeImageHeader()->NumberOfSections)))

HANDLE
WINAPI
XGetSectionHandle(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Finds a section in the current XE image

Arguments:

    lpSectionName - Supplies the name of the section to find.

Return Value:

    A handle to the section if found,
    otherwise INVALID_HANDLE_VALUE (GetLastError)

--*/
{
    STRING SearchString;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;
    STRING SectionName;

    RIP_ON_NOT_TRUE("XGetSectionHandle()", (lpSectionName != NULL));

    RtlInitAnsiString(&SearchString, lpSectionName);

    //
    // Walk through each of the sections looking for a match by name.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        RtlInitAnsiString(&SectionName, Section->SectionName);

        if (RtlEqualString(&SearchString, &SectionName, TRUE)) {
            return (HANDLE)Section;
        }

        Section++;
    }

    //
    // The section name was not found.
    //

    SetLastError(ERROR_NOT_FOUND);

    return INVALID_HANDLE_VALUE;
}

LPVOID
WINAPI
XLoadSectionByHandle(
    IN HANDLE hSection
    )
/*++

Routine Description:

    Loads a section from the current XE image file into memory.  If the section
    is already loaded, its reference count is incremented,

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    Return the virtual address of the loaded section if succesful
    otherwise NULL (GetLastError)

--*/
{
    NTSTATUS status;
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XLoadSectionByHandle()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    status = XeLoadSection(Section);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return NULL;
    }

    return (LPVOID)Section->VirtualAddress;
}

BOOL
WINAPI
XFreeSectionByHandle(
    HANDLE hSection
    )
/*++

Routine Description:

    Unloads a section from memory.  The section is only unloaded when
    its reference count goes to zero.

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    TRUE if successful, 
    FALSE otherwise (GetLastError)

--*/
{
    NTSTATUS status;
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XFreeSectionByHandle()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    status = XeUnloadSection(Section);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    return TRUE;
}

PVOID
WINAPI
XLoadSection(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Loads a section from the current XE image file into memory.  If the section
    is already loaded, its reference count is incremented,

Arguments:

    lpSectionName - Supplies the name of the section from the XE file

Return Value:

    Return the virtual address of the loaded section if succesful
    otherwise NULL (GetLastError)

--*/
{
    HANDLE hSection;

    RIP_ON_NOT_TRUE("XLoadSection()", (lpSectionName != NULL));

    hSection = XGetSectionHandle(lpSectionName);

    if (hSection != INVALID_HANDLE_VALUE) {
        return XLoadSectionByHandle(hSection);
    } else {
        return NULL;
    }
}

BOOL
WINAPI
XFreeSection(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Unloads a section from memory.  The section is only unloaded when
    its reference count goes to zero.

Arguments:

    lpSectionName - Supplies the name of the section from the XE file

Return Value:

    TRUE if successful,
    FALSE otherwise (GetLastError)

--*/
{
    HANDLE hSection;

    RIP_ON_NOT_TRUE("XFreeSection()", (lpSectionName != NULL));

    hSection = XGetSectionHandle(lpSectionName);

    if (hSection != INVALID_HANDLE_VALUE) {
        return XFreeSectionByHandle(hSection);
    } else {
        return FALSE;
    }
}

DWORD
WINAPI
XGetSectionSize(
    IN HANDLE hSection
    )
/*++

Routine Description:

    Returns the size of a section

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    Return the size of a section or 0 (GetLastError)

--*/
{
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XGetSectionSize()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    return Section->VirtualSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xpp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xpp.c

Abstract:

    Xbox Peripheral Port support

    The USB stack reports the insertion and removal of all devices here.  This module converts the PNP_CLASS_ID
    to the Xbox Device Type and vice versa.

    The Xbox device type is a simple 0 based index into a table of devices allowing an efficient implementation
    of XGetDevices, XGetDeviceChanges.

Environment:

    XAPI

Notes:

Revision History:

    06-26-00 created by Mitchell Dernis (mitchd)

--*/

#include "basedll.h"
#pragma warning( push, 4 )
#pragma warning( disable: 4213)
#include <usbxapi.h>

typedef struct _XPP_DEVICE_TYPE_INTERNAL
{
    ULONG CurrentConnected;
    ULONG ChangeConnected;
    ULONG PreviousConnected;
} XPP_DEVICE_TYPE_INTERNAL, *PXPP_DEVICE_TYPE_INTERNAL;

BOOL XPP_XInitDevicesHasBeenCalled = FALSE;

VOID
XdReportDeviceInsertionRemoval(
    PXPP_DEVICE_TYPE XppDeviceType,
    ULONG    PortBit,
    BOOLEAN  fInserted
    )

/*++
Routine Description:

    Called by the USB stack to report the insertion and removal of devices.
    Keeps the XPP_GlobalDeviceTable up-to-date.

Comments:
    This routine is called at DPC level

Parameters:
    XppDeviceType - Pointer to XPP type.
    PortBit   - Port bit position in bitmap.
    fInserted - TRUE on device insertion, FALSE on removal.

--*/
{
    DWORD dwPortMask = 1 << PortBit;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal =
        (PXPP_DEVICE_TYPE_INTERNAL) XppDeviceType;
    ASSERT(sizeof(PXPP_DEVICE_TYPE_INTERNAL)==sizeof(PXPP_DEVICE_TYPE));

    //
    //  Set the change flag
    //
    pXppTypeInternal->ChangeConnected |=dwPortMask;
    //
    //  Set or clear the CurrentConnected bit
    //
    if(fInserted)
    {
        pXppTypeInternal->CurrentConnected |= dwPortMask;
    } else
    {
        pXppTypeInternal->CurrentConnected &= ~dwPortMask;
    }
}

//------------------------------------------------------------------
//  Internal API
//------------------------------------------------------------------
DWORD
WINAPI
XPeekDevices(
    IN  PXPP_DEVICE_TYPE DeviceType,
    IN  OUT PDWORD pLastGotten,
    IN  OUT PDWORD pStale
    )
/*++
  Routine Description:
    This is an internal routine which can be used to determine which devices are connected.
    It is designed not to interfere with the game which calles XGetDevices and XGetDeviceChanges.
    It also allows the caller to track what the game knows about.
  Arguments:
    DeviceType  - the device for which information is requested.
    pLastGotten - If non-NULL, filled out on exit with a bitmap of connected devices
                  as seen by the game.
    pState      - If non-NULL, filled out on exit with a bitmap of devices which have
                  been removed and reinserted since the last time the game called
                  XGetDevices or XGetDeviceChanges.
--*/
{
    KIRQL oldIrql;
    DWORD dwRetVal;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDevices: XInitDevices must be called first!");
  
    //
    //  Raise to DPC for sync.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Return all devices
    //
    dwRetVal = pXppTypeInternal->CurrentConnected;

    //
    //  Fill out *pLastGotten.
    //
    if(pLastGotten)
    {
        *pLastGotten = pXppTypeInternal->PreviousConnected;
    }

    //
    //  Fill out *pStale.
    //
    if(pStale)
    {
        *pStale = pXppTypeInternal->CurrentConnected & 
                  pXppTypeInternal->PreviousConnected &
                  pXppTypeInternal->ChangeConnected;
    }

    //
    //  Done with syncronization.
    //
    KeLowerIrql(oldIrql);
    return dwRetVal;
}


//------------------------------------------------------------------
//  Public API
//------------------------------------------------------------------

VOID
WINAPI
XInitDevices(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes)
{
#if DBG
    if(XPP_XInitDevicesHasBeenCalled)
    {
        RIP("XInitDevices() is called more than once.  Fatal Error.");
    }
    else
    {
        XPP_XInitDevicesHasBeenCalled = TRUE;
    }
#endif

    USBD_Init(NumDeviceTypes, DeviceTypes);
}


DWORD
WINAPI
XGetDevices(
    IN  PXPP_DEVICE_TYPE DeviceType
    )
{
    KIRQL oldIrql;
    DWORD dwRetVal;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDevices: XInitDevices must be called first!");
  
    //
    //  Raise to DPC for sync.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Fill in insertion bitmap with all devices
    //
    dwRetVal = pXppTypeInternal->CurrentConnected;
    //
    //  Erase changed and reset previous
    //
    pXppTypeInternal->ChangeConnected = 0;
    pXppTypeInternal->PreviousConnected = pXppTypeInternal->CurrentConnected;

    //
    //  Done with syncronization.
    //
    KeLowerIrql(oldIrql);
    return dwRetVal;
}

BOOL
WINAPI
XGetDeviceChanges(
    IN  IN  PXPP_DEVICE_TYPE DeviceType,
    OUT PDWORD pInsertions,
    OUT PDWORD pRemovals
    )
{
    KIRQL oldIrql;

    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDeviceChanges: XInitDevices must be called first!");
    
    if(!pXppTypeInternal->ChangeConnected)
    {
        //
        //  Nothing has changed since the last call.  Get out quickly.
        //
        *pInsertions = 0;
        *pRemovals = 0;
        return FALSE;
    }
    else
    {
      //
      //  Something has changed, so calculate the full info.
      //

      ULONG RemoveInsert;

      //
      //  Raise to DPC for sync.
      //

      oldIrql = KeRaiseIrqlToDpcLevel();

      //
      //  Construct the simple case of add or remove.
      //

      *pInsertions = (pXppTypeInternal->CurrentConnected & ~pXppTypeInternal->PreviousConnected);
      *pRemovals = (pXppTypeInternal->PreviousConnected & ~pXppTypeInternal->CurrentConnected);

      //
      // Now add more insertions and removals for the case of remove and reinsert
      //

      RemoveInsert = pXppTypeInternal->ChangeConnected &
                     pXppTypeInternal->CurrentConnected &
                     pXppTypeInternal->PreviousConnected;
      *pRemovals |= RemoveInsert;
      *pInsertions |= RemoveInsert;

      //
      //  Record that we retrieved info
      //
      
      pXppTypeInternal->ChangeConnected = 0;
      pXppTypeInternal->PreviousConnected = pXppTypeInternal->CurrentConnected;
      
      //
      //  Done with syncronization.
      //

      KeLowerIrql(oldIrql);
      return (*pInsertions|*pRemovals) ? TRUE : FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\widechar.c ===
#include "basedll.h"

int
UnicodeToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cbUTF8
    );

int
UTF8ToUnicode(
    IN LPCSTR lpUTF8Str,
    IN int cbUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

int WINAPI MultiByteToWideChar(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    OUT LPWSTR  lpWideCharStr,
    IN int      cchWideChar)
{
    USHORT LengthRequires;
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;

    if ( CodePage == 65000 ) {
        ASSERT( 0 && "CP_UTF7 is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( CodePage == CP_UTF8 ) {
        return UTF8ToUnicode(lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
    }

    if ( cbMultiByte == -1 ) {
        LengthRequires = (USHORT)(strlen(lpMultiByteStr) + sizeof(ANSI_NULL));
    } else {
        LengthRequires = (USHORT)(cbMultiByte + sizeof(ANSI_NULL));
    }

    if ( cchWideChar == 0 ) {
        return LengthRequires;
    }
    else if ( cchWideChar < (int)LengthRequires ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    Ansi.Buffer = (PSTR)lpMultiByteStr;
    Ansi.Length = (USHORT)(LengthRequires - sizeof(ANSI_NULL));
    Ansi.MaximumLength = (USHORT)(LengthRequires);

    Unicode.Buffer = lpWideCharStr;
    Unicode.Length = (USHORT)((LengthRequires - sizeof(ANSI_NULL)) * sizeof(WCHAR));
    Unicode.MaximumLength = cchWideChar * sizeof(WCHAR);

    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        return LengthRequires;
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
        return 0;
    }
}

int WINAPI WideCharToMultiByte(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCWSTR  lpWideCharStr,
    IN int      cchWideChar,
    OUT LPSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    IN LPCSTR   lpDefaultChar,
    OUT LPBOOL  lpUsedDefaultChar)
{
    USHORT LengthRequires;
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;

    if ( CodePage == 65000 ) {
        ASSERT( 0 && "CP_UTF7 is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( CodePage == CP_UTF8 ) {
        return UnicodeToUTF8(lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte);
    }

    if ( lpDefaultChar ) {
        ASSERT( 0 && "lpDefaultChar is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( lpUsedDefaultChar ) {
        *lpUsedDefaultChar = FALSE;
    }

    if ( cchWideChar == -1 ) {
        LengthRequires = wcslen(lpWideCharStr) + sizeof(ANSI_NULL);
    } else {
        LengthRequires = cchWideChar + sizeof(ANSI_NULL);
    }

    if ( cbMultiByte == 0 ) {
        return LengthRequires;
    }
    else if ( cbMultiByte < (int)LengthRequires ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    Ansi.Buffer = lpMultiByteStr;
    Ansi.Length = 0;
    Ansi.MaximumLength = (USHORT)cbMultiByte;

    Unicode.Buffer = (PWSTR)lpWideCharStr;
    Unicode.Length = (USHORT)(LengthRequires * sizeof(WCHAR) - sizeof(UNICODE_NULL));
    Unicode.MaximumLength = (USHORT)(LengthRequires * sizeof(WCHAR));

    Status = RtlUnicodeStringToAnsiString( &Ansi, &Unicode, FALSE );

    if ( NT_SUCCESS(Status) ) {
        return LengthRequires;
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
        return 0;
    }
}


//*****************************************************************************
// UTF8 <-> Unicode conversion functions
//

#define HIGH_BITS1 0x80
#define HIGH_BITS2 0xC0
#define HIGH_BITS3 0xE0
#define HIGH_BITS4 0xF0
#define LOW_BITS4  0x0F
#define LOW_BITS5  0x1F
#define LOW_BITS6  0x3F

unsigned long offsetsFromUTF8[6] = { 0x00000000, 0x00003080, 0x000E2080,
                                     0x03C82080, 0xFA082080, 0x82082080};

char bytesFromUTF8[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5};

unsigned long kReplacementCharacter = 0x0000FFFD;
unsigned long kMaximumSimpleUniChar = 0x0000FFFF;
unsigned long kMaximumUniChar       = 0x0010FFFF;
int           halfShift             = 10;
unsigned long halfBase              = 0x0010000;
unsigned long halfMask              = 0x3FF;
unsigned long kSurrogateHighStart   = 0xD800;
unsigned long kSurrogateLowStart    = 0xDC00;

/*******************************************************************************
UTF8ToUnicode
 
Converts a UTF8 string to a Unicode string.
 
Returns:
    DWORD size of Unicode string
*******************************************************************************/
int
UTF8ToUnicode(
    IN LPCSTR lpUTF8Str,
    IN int cbUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int LengthRequires = 0;
    unsigned short *pchWideChar = (unsigned short *) lpWideCharStr;
    unsigned char *lpUTF8StrPtr = (unsigned char *)lpUTF8Str;
    unsigned long ch = 0;
    unsigned short extraBytesToWrite = 0;

    if ( cbUTF8 == -1 )
    {
        cbUTF8 = strlen(lpUTF8Str) + sizeof(ANSI_NULL);
    }

    while ((lpUTF8StrPtr - ((unsigned char *)lpUTF8Str)) < cbUTF8)
    {
        ch = 0;
        extraBytesToWrite = bytesFromUTF8[*lpUTF8StrPtr];

        if (((lpUTF8StrPtr - ((unsigned char *)lpUTF8Str)) + extraBytesToWrite) > cbUTF8)
        {
            break;
        }

        switch(extraBytesToWrite)
        {
            case 5:ch += *lpUTF8StrPtr++; ch <<=6;
            case 4:ch += *lpUTF8StrPtr++; ch <<=6;
            case 3:ch += *lpUTF8StrPtr++; ch <<=6;
            case 2:ch += *lpUTF8StrPtr++; ch <<=6;
            case 1:ch += *lpUTF8StrPtr++; ch <<=6;
            case 0:ch += *lpUTF8StrPtr++;
        }

        ch -= offsetsFromUTF8[extraBytesToWrite];

        if (ch <= kMaximumSimpleUniChar)
        {
            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ch;
                pchWideChar++;
            }
        }
        else if (ch > kMaximumUniChar)
        {
            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = kReplacementCharacter;
                pchWideChar++;
            }
        }
        else
        {
            ch -= halfBase;

            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ((ch >> halfShift) + kSurrogateHighStart);
                pchWideChar++;
            }

            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ((ch & halfMask) + kSurrogateLowStart);
                pchWideChar++;
            }
        }
    }

    if ( cchWideChar == 0 )
    {
        return LengthRequires;
    }
    else if ( cchWideChar < LengthRequires )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    return LengthRequires;
}

/*******************************************************************************
UnicodeToUTF8
 
Converts a Unicode string to a UTF-8 string.
 
Returns:
    DWORD size of UTF8 string
*******************************************************************************/
int
UnicodeToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cbUTF8
    )
{
    BYTE b;
    int LengthRequires = 0;
    HRESULT hr = S_OK;
    int i = 0;
 
    if ( cchWideChar == -1 ) {
        cchWideChar = wcslen(lpWideCharStr) + sizeof(ANSI_NULL);
    }

    for ( i = 0; i < cchWideChar; i += 1 )
    {
        if (*lpWideCharStr <= 0x7F)
        {
            // Single byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL) 
                { 
                    *lpUTF8Str++ = (char) *lpWideCharStr; 
                }
            }
        }
        else if (*lpWideCharStr <= 0x7FF)
        {
            // Double byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS5 << 6)) >> 6);
                    b |= HIGH_BITS2;
                    *lpUTF8Str++ = (char) b;
                }
            } 

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) (*lpWideCharStr & LOW_BITS6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }
        }
        else 
        {
            // Triple byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS4 << 12)) >> 12);
                    b |= HIGH_BITS3;
                    *lpUTF8Str++ = (char) b;
                }
            }

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS6 << 6)) >> 6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) (*lpWideCharStr & LOW_BITS6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }
        }
 
        lpWideCharStr++;
    }

    if ( cbUTF8 == 0 )
    {
        return LengthRequires;
    }
    else if ( cbUTF8 < LengthRequires )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    return LengthRequires;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\dbgmon\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xprofile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofile.c

Abstract:

    XAPI profiling support functions

Notes:

    We access the kernel's profiling data buffer directly.
    If the kernel's data structure changes, be sure to
    update the CAP_Start_Profiling and CAP_End_Profiling
    functions accordingly.

--*/

#include "basedll.h"

#ifdef _XBOX_ENABLE_PROFILING

#include "xprofp.h"

//
// Pointer to the kernel's global profiling data structure
//
XProfpGlobals* XapipProfileData;

VOID XapipInitProfiling() {
    XapipProfileData = XProfpGetData();
}


VOID __declspec(naked) __stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )

/*++

Routine Description:

    Just before a function is about to be called

Arguments:

    caller - Specifies the caller function
    callee - Specifies the called function

Return Value:

    NONE

Notes:

    All registers are preserved.

--*/

{
    /*
        ULONG* buf;

    loop:
        buf = XProfpData.bufnext
        if buf >= XProfpData.bufend, return
        Atomical incremnt XProfpData.bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    ecx
        mov     ecx, XapipProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     eax
    ret2:
        pop     ecx
        ret     8
    }
}


VOID __declspec(naked) __stdcall
_CAP_End_Profiling(
    VOID* caller
    )
/*++

Routine Description:

    Just after a function call is made

Arguments:

    caller - Specifies the caller function

Return Value:

    NONE

Notes:

    All registers are preserved.

--*/

{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    ecx
        mov     ecx, XapipProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+12]       ; XProfpData.bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_CALL_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

    ret1:
        pop     edx
        pop     eax
    ret2:
        pop     ecx
        ret     4
    }
}

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xapiheap.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    Maps the Win32 heap APIs to the Rtl heap functions

--*/

#include "basedll.h"
#pragma hdrstop

//
// Handle of the default process heap.
//
HANDLE XapiProcessHeap;

HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
/*++

Routine Description:

    Creates a new heap

Arguments:

    flOptions - either HEAP_GENERATE_EXCEPTIONS or HEAP_NO_SERIALIZE
    dwInitialSize - initial heap size
    dwMaximumSize - maximum heap size

Return Value:

    Returns the new heap handle

--*/
{
    HANDLE hHeap;
    ULONG GrowthThreshold;
    ULONG Flags;


    Flags = (flOptions & (HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE)) | HEAP_CLASS_1;
    GrowthThreshold = 0;

    if (dwMaximumSize < PAGE_SIZE) {

        if (dwMaximumSize == 0) {

            GrowthThreshold = PAGE_SIZE * 16;
            Flags |= HEAP_GROWABLE;
            }
        else {
            dwMaximumSize = PAGE_SIZE;
            }
        }

    if (GrowthThreshold == 0 && dwInitialSize > dwMaximumSize) {
        dwMaximumSize = dwInitialSize;
        }

    hHeap = (HANDLE)RtlCreateHeap( Flags,
                                   NULL,
                                   dwMaximumSize,
                                   dwInitialSize,
                                   0,
                                   NULL
                                 );
    if (hHeap == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    return( hHeap );
}


BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    )
{
    if (RtlDestroyHeap( (PVOID)hHeap ) == NULL ) {
        return( TRUE );
        }
    else {
        SetLastError( ERROR_INVALID_HANDLE );
        return( FALSE );
        }
}


BOOL
WINAPI
HeapFree(
    HANDLE hHeap,
    DWORD  dwFlags,
    LPVOID lpMem
    )
{
    return (BOOL) RtlFreeHeap( (PVOID)hHeap, dwFlags, lpMem );
}

#if DBG

BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    )
{
    return RtlValidateHeap( hHeap, dwFlags, lpMem );
}

#endif // DBG

HANDLE
WINAPI
GetProcessHeap( VOID )
/*++

Routine Description:

    Returns the handle for the process default heap (used with Local/GlobalXxxx functions)

Arguments:

Return Value:

    Process heap handle (can be used with HeapAlloc/HeapFree/HeapSize functions)

--*/
{
    return XapiProcessHeap;
}

#if DBG

WINBASEAPI
SIZE_T
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
    return RtlCompactHeap( hHeap, dwFlags );
}


WINBASEAPI
BOOL
WINAPI
HeapLock(
    HANDLE hHeap
    )
{
    return RtlLockHeap( hHeap );
}


WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    HANDLE hHeap
    )
{
    return RtlUnlockHeap( hHeap );
}

WINBASEAPI
BOOL
WINAPI
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    )
{
    RTL_HEAP_WALK_ENTRY Entry;
    NTSTATUS Status;

    if (lpEntry->lpData == NULL) {
        Entry.DataAddress = NULL;
        Status = RtlWalkHeap( hHeap, &Entry );
        }
    else {
        Entry.DataAddress = lpEntry->lpData;
        Entry.SegmentIndex = lpEntry->iRegionIndex;
        if (lpEntry->wFlags & PROCESS_HEAP_REGION) {
            Entry.Flags = RTL_HEAP_SEGMENT;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
            Entry.Flags = RTL_HEAP_UNCOMMITTED_RANGE;
            Entry.DataSize = lpEntry->cbData;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            Entry.Flags = RTL_HEAP_BUSY;
            }
        else {
            Entry.Flags = 0;
            }

        Status = RtlWalkHeap( hHeap, &Entry );
        }

    if (NT_SUCCESS( Status )) {
        lpEntry->lpData = Entry.DataAddress;
        lpEntry->cbData = (DWORD)Entry.DataSize;
        lpEntry->cbOverhead = Entry.OverheadBytes;
        lpEntry->iRegionIndex = Entry.SegmentIndex;
        if (Entry.Flags & RTL_HEAP_BUSY) {
            lpEntry->wFlags = PROCESS_HEAP_ENTRY_BUSY;

            //
            // DDESHARE and MOVEABLE are not meaningful on Xbox
            //
#if 0
            if (Entry.Flags & BASE_HEAP_FLAG_DDESHARE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_DDESHARE;
                }

            if (Entry.Flags & BASE_HEAP_FLAG_MOVEABLE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_MOVEABLE;
                lpEntry->Block.hMem = (HLOCAL)Entry.Block.Settable;
                }
#endif // 0

            memset( lpEntry->Block.dwReserved, 0, sizeof( lpEntry->Block.dwReserved ) );
            }
        else
        if (Entry.Flags & RTL_HEAP_SEGMENT) {
            lpEntry->wFlags = PROCESS_HEAP_REGION;
            lpEntry->Region.dwCommittedSize = Entry.Segment.CommittedSize;
            lpEntry->Region.dwUnCommittedSize = Entry.Segment.UnCommittedSize;
            lpEntry->Region.lpFirstBlock = Entry.Segment.FirstEntry;
            lpEntry->Region.lpLastBlock = Entry.Segment.LastEntry;
            }
        else
        if (Entry.Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
            lpEntry->wFlags = PROCESS_HEAP_UNCOMMITTED_RANGE;
            memset( &lpEntry->Region, 0, sizeof( lpEntry->Region ) );
            }
        else {
            lpEntry->wFlags = 0;
            }

        return TRUE;
        }
    else {
        XapiSetLastNTError( Status );
        return FALSE;
        }
}

#endif // DBG

HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    )
/*++

Routine Description:

    The LocalAlloc function allocates the specified number of bytes from the heap.
    In the linear Win32 API environment, there is no difference between the
    local heap and the global heap.

    NOTE: Moveable memory is not implemented. LMEM_FIXED is always on.
Arguments:

    UINT uFlags - allocation attributes
    UINT uBytes - number of bytes to allocate

Return Value:

    Returns pointer to newly allocated memory or NULL on failure.

--*/
{
#if DBG
    // Validate flags
    if (uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
    {
        RIP("LocalAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlAllocateHeap(XapiProcessHeap,
        (uFlags & LMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0, (DWORD)uBytes);
}

HLOCAL
WINAPI
LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
/*++

Routine Description:

    The LocalReAlloc function changes the size of a specified 
    local memory object. The size can increase or decrease.

    NOTE: Since moveable memory isn't implemented, passing LMEM_MOVEABLE allows the handle
    (pointer) value to change on return. If LMEM_MOVEABLE is not passed in and there is
    no space following the memory block, the call may fail to grow the block size. Note
    that this is the opposite sense of the HEAP_REALLOC_IN_PLACE_ONLY flag.

Arguments:

    hMem - pointer to memory object to resize
    uBytes - new size
    uFlags - options for reallocation (same semantics as HeapReAlloc)

Return Value:

    returns the new handle (may have changed) or NULL on failure.

--*/
{
#if DBG
    // Validate flags
    if (uFlags & (LMEM_DISCARDABLE | LMEM_MODIFY))
    {
        RIP("LocalReAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlReAllocateHeap(XapiProcessHeap,
        (uFlags & LMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0 +
        (uFlags & LMEM_MOVEABLE) ? 0 : HEAP_REALLOC_IN_PLACE_ONLY,
        (PVOID)hMem, (DWORD)uBytes);
}

SIZE_T
WINAPI
LocalSize(
    HLOCAL hMem
    )
/*++

Routine Description:

    Returns the size of an allocation in bytes. Also implements GlobalSize()

Arguments:

    hMem - pointer to memory

Return Value:

    size or zero on error.

--*/
{
    return (SIZE_T)RtlSizeHeap(XapiProcessHeap, 0, (LPVOID)hMem);
}

HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    )
/*++

Routine Description:

    The LocalFree function frees the specified local memory object and
    invalidates its handle. Also implements GlobalFree().

Arguments:

    hMem - handle of local memory object

Return Value:

    If the function succeeds, the return value is NULL. If the function fails,
    the return value is equal to the handle of the local memory object.

--*/
{
    if (RtlFreeHeap(XapiProcessHeap, 0, (LPVOID)hMem))
        return NULL;
    else
        return hMem;
}

WINBASEAPI
LPVOID
WINAPI
LocalLock(
    IN HLOCAL hMem
    )
/*++

Routine Description:

    Maps a handle to a pointer. Since only fixed memory is supported,
    the input value is returned. This function is unneccesary overhead
    for applications to call. Note that no reference count is maintained.

Arguments:

    hMem - memory handle

Return Value:

    returns hMem cast to a pointer.

--*/
{
    return (LPVOID)hMem;
}

WINBASEAPI
HLOCAL
WINAPI
LocalHandle(
    IN LPCVOID pMem
    )
/*++

Routine Description:

    Maps a pointer to a handle. Since only fixed memory is supported,
    the input value is returned. It is safe to assume that handles == pointers
    for LocalXxxx functions.

Arguments:

    pMem - memory pointer

Return Value:

    returns pMem cast as a handle

--*/
{
    return (HLOCAL)pMem;
}

WINBASEAPI
BOOL
WINAPI
LocalUnlock(
    IN HLOCAL hMem
    )
/*++

Routine Description:

    Does nothing at all since only fixed memory is supported
    
Arguments:

    hMem - memory handle

Return Value:

    Always returns true

--*/
{
    return TRUE;
}

HGLOBAL
WINAPI
GlobalAlloc(
    UINT uFlags,
    SIZE_T dwBytes
    )
/*++

Routine Description:

    The GlobalAlloc function allocates the specified number of bytes from the heap.
    In the linear Win32 API environment, there is no difference between the 
    local heap and the global heap. 

    NOTE: Moveable memory is not implemented. GMEM_FIXED is always on.

Arguments:

    UINT uFlags - allocation attributes
    UINT uBytes - number of bytes to allocate  

Return Value:

    Returns pointer to newly allocated memory or NULL on failure.

--*/
{
#if DBG
    // Validate flags (don't allow GMEM_MOVEABLE or GMEM_DISCARDABLE
    // ignore all other flags--they should be completely benign)
    if (uFlags & (GMEM_MOVEABLE | GMEM_DISCARDABLE))
    {
        RIP("GlobalAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlAllocateHeap(XapiProcessHeap,
        (uFlags & GMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0, (DWORD)dwBytes);
}

HGLOBAL
WINAPI
GlobalReAlloc(
    HANDLE hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
/*++

Routine Description:

    The GlobalReAlloc function changes the size of a specified 
    local memory object. The size can increase or decrease.

    NOTE: Since moveable memory isn't implemented, passing GMEM_MOVEABLE allows the handle
    (pointer) value to change on return. If GMEM_MOVEABLE is not passed in and there is
    no space following the memory block, the call may fail to grow the block size. Note
    that this is the opposite sense of the HEAP_REALLOC_IN_PLACE_ONLY flag.

Arguments:

    hMem - pointer to memory object to resize
    uBytes - new size
    uFlags - options for reallocation (same semantics as HeapReAlloc)
    
Return Value:

    returns the new handle (may have changed) or NULL on failure.
    
--*/
{
#if DBG
    // Validate flags (don't allow GMEM_DISCARDABLE or GMEM_MODIFY, ignore others
    // as they should be completely benign)
    if (uFlags & (GMEM_DISCARDABLE | GMEM_MODIFY))
    {
        RIP("GlobalReAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlReAllocateHeap(XapiProcessHeap,
        (uFlags & GMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0 +
        (uFlags & GMEM_MOVEABLE) ? 0 : HEAP_REALLOC_IN_PLACE_ONLY,
        (PVOID)hMem, (DWORD)uBytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xcalcsig.c ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Implementation of routines to calculate the signature
    given a series of piecemeal data blobs

Module Name:

    xcalcsig.c

--*/

#include "basedll.h"
#pragma hdrstop

#include <sha.h>
#include <shahmac.h>

//
// Define the actual context structure
//
typedef struct
{
    DWORD                dwFlags;    // Flags
    PBYTE                pbTitleKey;    // Per-title key 
    XSHAHMAC_CONTEXT    shactx;        // SHA1 context

} XCALCSIG_CONTEXT, *PXCALCSIG_CONTEXT;

//
// Define some macros to abstract memory management
//
#define XCalcSigAlloc(n)        LocalAlloc(LMEM_FIXED, (n))
#define XCalcSigFree(p)            LocalFree(p)

//
// Define some debug facilities to track invalid contexts
//
#if DBG
#define XCALCSIG_FLAG_INVALID_CONTEXT    (0x80000000)
#endif

//
// Define the K padding size for SHA1-Hmac
//
#define HMAC_K_PADSIZE              64

//
// Define the well-known XOR factors for Kipad and Kopad
//
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)

//
// Function to initialize a piecemeal SHA1-Hmac evaluation
//
VOID WINAPI XShaHmacInitialize(
            IN PBYTE                pbKey,
            IN DWORD                cbKey,
            IN OUT XSHAHMAC_CONTEXT Shactx
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKipad[HMAC_K_PADSIZE];
    ULONG        dwBlock;

    RIP_ON_NOT_TRUE("XShaHmacInitialize", (pbKey != NULL));
    RIP_ON_NOT_TRUE("XShaHmacInitialize", (cbKey >= sizeof(DWORD)));
    RIP_ON_NOT_TRUE("XShaHmacInitialize", (Shactx != NULL));
    
    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKipad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKipad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
    }

    // Initialize our SHA1 Hmac context
    XcSHAInit(Shactx);

    // Run our Kipad through this ...
    XcSHAUpdate(Shactx, rgbKipad, HMAC_K_PADSIZE);
}

//
// Function to update the Hmac
//
VOID WINAPI XShaHmacUpdate(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbData,
            IN DWORD            cbData
            )
{
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (Shactx != NULL));
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (pbData != NULL));
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (cbData > 0));

    XcSHAUpdate(Shactx, pbData, cbData);
}
            
//
// Function to calculate the final Hmac
//
VOID WINAPI XShaHmacComputeFinal(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbKey,
            IN DWORD            cbKey,
            OUT PBYTE           pbHmac
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKopad[HMAC_K_PADSIZE + A_SHA_DIGEST_LEN];
    ULONG        dwBlock;

    RIP_ON_NOT_TRUE("XShaHmacComputeFinal", (Shactx != NULL));
    RIP_ON_NOT_TRUE("XShaHmacComputeFinal", (pbHmac != NULL));
    
    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKopad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKopad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    // Finish off the hash, and place the result right
    // after the Kopad data
    XcSHAFinal(Shactx, rgbKopad + HMAC_K_PADSIZE);

    // Do another hash, now with the Kopad data
    XcSHAInit(Shactx);
    XcSHAUpdate(Shactx, rgbKopad, sizeof(rgbKopad));
    XcSHAFinal(Shactx, pbHmac);
}            

//
// Function to make a signature non-roamable. The two
// signature buffers must be different and must not overlap
//
BOOL XapiConvertSignatureToNonRoamable(
            PXCALCSIG_CONTEXT    pCalcSig,
            PXCALCSIG_SIGNATURE  psignatureRoamable,
            PXCALCSIG_SIGNATURE  psignatureNonRoamable
            )
{
    // Compute the Keyed SHA Hmac
    XShaHmacInitialize((LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH, 
                pCalcSig->shactx);
    
    XShaHmacUpdate(pCalcSig->shactx, 
                psignatureRoamable->Signature, 
                XCALCSIG_SIGNATURE_SIZE);
                
    XShaHmacComputeFinal(pCalcSig->shactx, 
                (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
                psignatureNonRoamable->Signature);

    return(TRUE);
}

//
// Wrapper to XCalculateSignatureBeginEx() that does not take a
// title ID parameter (uses the current title's ID implicitly)
//
HANDLE WINAPI XCalculateSignatureBegin(
            IN DWORD dwFlags
            )
{
    return XCalculateSignatureBeginEx(dwFlags, XeImageHeader()->Certificate->TitleID);
}


//
// Function to begin the piecemeal process to calculate the
// signature of a blob of data
//
// Arguments:
//    dwFlags - Optional flags. Currently defined flags are:
//        XCALCSIG_FLAG_NON_ROAMABLE - this forces the resulting
//                signature to be unusable on any XBox other than
//                the one on which the signature is computed.
//    dwAltTitleId - Alternate title id or the current title id
//
// Return Values:
//    On success, this function returns a HANDLE that can be used
//    in subsequent calls to calculate a signature. On failure,
//    function returns INVALID_HANDLE_VALUE, extended error
//    information can be retrieved using GetLastError().
//
// Remarks:
//    On success, this fucntion allocates memory for the
//    returned HANDLE. The caller must explicitly call
//    XCalculateSignatureEnd to free the handle resources,
//    regardless of any intermediate failures.
//
HANDLE WINAPI XCalculateSignatureBeginEx(
            IN DWORD dwFlags,
            IN DWORD dwAltTitleId
            )
{
    PXCALCSIG_CONTEXT pCalcSig;
    PXBEIMAGE_CERTIFICATE Certificate = XeImageHeader()->Certificate;

    RIP_ON_NOT_TRUE("XCalculateSignatureBegin",
                    ((dwFlags & (~XCALCSIG_FLAG_NON_ROAMABLE)) == 0));
    
    // Allocate the context
    pCalcSig = XCalcSigAlloc(sizeof(XCALCSIG_CONTEXT));
    if (!pCalcSig)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    // Initialize 
    pCalcSig->dwFlags = dwFlags;

    //
    // Get the per-title key
    // If dwAltTitleId is the current title's id, use XboxSignatureKey
    // Otherwise, try to user XboxAlternateSignatureKeys
    //
    
    if (Certificate->TitleID != dwAltTitleId)
    {
        int i;
        for (i = 0; i < ARRAYSIZE(Certificate->AlternateTitleIDs); i++)
        {
            if (0 == Certificate->AlternateTitleIDs[i])
            {
                SetLastError(ERROR_ACCESS_DENIED);
                goto Error;
            }

            if (dwAltTitleId == Certificate->AlternateTitleIDs[i])
            {
                break;
            }
        }

        if (i >= sizeof(Certificate->AlternateTitleIDs))
        {
            SetLastError(ERROR_ACCESS_DENIED);
            goto Error;
        }

        ASSERT(i < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT);
        
        pCalcSig->pbTitleKey = (PBYTE)XboxAlternateSignatureKeys[i];
        
    }
    else
    {
        pCalcSig->pbTitleKey = (PBYTE)XboxSignatureKey;
    }

    // Initialize SHA Hmac
    XShaHmacInitialize(pCalcSig->pbTitleKey, 
                       XC_SYMMETRIC_KEY_SIZE,
                       pCalcSig->shactx);

    // Return context as opaque handle
    return((HANDLE)pCalcSig);

Error:
    return(INVALID_HANDLE_VALUE);
}


//
// This function continues to to update the calculation
// for the specified signature context handle. 
//
// Arguments:
//    hCalcSig - the context to update
//    pbData - the next chunk of data to update with
//    cbData - the size of the data chunk
//
// Return Values:
//    This function returns ERROR_SUCCESS on success, and if this
//    function failed, an appropriate Win32 error code is returned.
//    Either case, XCalculateSignatureEnd must be called to free 
//    any resources associated with the HANDLE.
//
DWORD WINAPI XCalculateSignatureUpdate(
            IN HANDLE hCalcSig,
            IN const BYTE *pbData,
            IN ULONG cbData
            )
{
    PXCALCSIG_CONTEXT pCalcSig = (PXCALCSIG_CONTEXT)hCalcSig;

    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", (pCalcSig != NULL));
    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", (pbData != NULL));

#if DBG
    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", 
                    ((pCalcSig->dwFlags & XCALCSIG_FLAG_INVALID_CONTEXT) == 0));
#endif

    // Call update
    XShaHmacUpdate(pCalcSig->shactx, (PBYTE)pbData, cbData);
    return(ERROR_SUCCESS);
}

//
// This function performs the last bit of precessing
// required to calculate the signature, returns the 
// signature blob, and releases the context.
//
// Arguments:
//    hCalcSig - the context to close
//    Signature - the buffer to receive the final signature
//
// Return Values:
//    On success, this function returns ERROR_SUCCESS, and the
//    final computed signature is returned in signature. If this 
//    function failed, an appropriate Win32 error code is returned.
//
// Remarks:
//    The context specified by hCalcSig will be released 
//    regardless of whether this function call succeeded
//    or not. hCalcSig should not be used after this function
//    returns unless it is reinitialized by XCalculateSignatureBegin.
//    This function can be used to just free the context. In
//    this case, NULL should be specified for the Signature argument.
//
DWORD WINAPI XCalculateSignatureEnd(
            IN HANDLE hCalcSig,
            OUT PXCALCSIG_SIGNATURE pSignature
            )
{
    BOOL                fResult = TRUE;
    PXCALCSIG_CONTEXT   pCalcSig = (PXCALCSIG_CONTEXT)hCalcSig;
    XCALCSIG_SIGNATURE  xcsSignature;
    BOOL                fNonRoamable;

    RIP_ON_NOT_TRUE("XCalculateSignatureEnd", (pCalcSig != NULL));

#if DBG
    RIP_ON_NOT_TRUE("XCalculateSignatureEnd", 
            ((pCalcSig->dwFlags & XCALCSIG_FLAG_INVALID_CONTEXT) == 0));
#endif

    fNonRoamable = ((pCalcSig->dwFlags & XCALCSIG_FLAG_NON_ROAMABLE) != 0);

    // Finish the calculation
    if (pSignature)
    {
        // Figure out the Hmac
        XShaHmacComputeFinal(pCalcSig->shactx, 
                    pCalcSig->pbTitleKey, 
                    XC_SYMMETRIC_KEY_SIZE,
                    (fNonRoamable)?xcsSignature.Signature:pSignature->Signature);
                        
        if (fNonRoamable)
        {
            fResult = XapiConvertSignatureToNonRoamable(
                        pCalcSig, &xcsSignature, pSignature);
        }
    }

    // Well, free the context either case
#if DBG
    pCalcSig->dwFlags |= XCALCSIG_FLAG_INVALID_CONTEXT;
#endif
    XCalcSigFree(pCalcSig);
    
    return(fResult?ERROR_SUCCESS:GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xsaveapi.c ===
#include "basedll.h"
#include "xmeta.h"

// Closest prime number to 2^48:
// 2^48 - 59 =  281474976710597 =  0xFFFFFFFFFFC5

#define SAVE_DIR_HASH_M 0xFFFFFFFFFFC5

#define HASHED_SAVE_GAME_CHARACTERS 12


__inline CHAR HexDigitToChar(INT d)
{
    return (d <= 9) ? (d + '0') : (d - 0xA + 'A');
}

//
// Unicode save game names are hashed into 48 bit numbers (12 8-bit hex characters)
//

VOID
XapiSaveGameHashEncode(
    PCWSTR pszSource,
    PSTR pszDestination,
    int cchDestination)
{
    int nChar = 0;
    DWORDLONG qwHashValue = 0;

    ASSERT(pszSource);
    ASSERT(pszDestination);
    ASSERT(cchDestination > HASHED_SAVE_GAME_CHARACTERS);

    while (pszSource[nChar])
    {
        //
        // This is effectively what we are doing below:
        //
        // qwHashValue = (((0x10000) * qwHashValue) + pszSource[nChar]) % SAVE_DIR_HASH_M;
        //

        qwHashValue = ((qwHashValue << 16) + pszSource[nChar]) % SAVE_DIR_HASH_M;
        nChar++;
    }

    for (nChar = (HASHED_SAVE_GAME_CHARACTERS - 1); nChar >= 0; nChar--)
    {
        pszDestination[nChar] =
            HexDigitToChar(
                ((INT) (qwHashValue >> (4 * ((HASHED_SAVE_GAME_CHARACTERS - 1) - nChar)))) & 0xF);
    }

    pszDestination[HASHED_SAVE_GAME_CHARACTERS] = '\0';
}

#if 0

//
// Note: hMetaFile should have been opened without FILE_SHARE_READ or
// FILE_SHARE_WRITE set, because we are potentially rewriting the entire file
// in this function
//

BOOL
XapiDeleteValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag)
{
    PBYTE pBuffer;
    BOOL fRet = FALSE;
    DWORD dwSize = GetFileSize(hMetaFile, NULL);

    ASSERT(pszTag);

    if (dwSize)
    {
        pBuffer = (PBYTE) LocalAlloc(LMEM_FIXED, dwSize + sizeof(WCHAR));
        if (pBuffer)
        {
            PBYTE pCurrent = pBuffer;
            DWORD dwBytesRead;

            //
            // Place a NULL at the end of the buffer that should never
            // be overwritten - this makes it safe to use the wcsstr()
            // function later without worrying about running of the end
            //

            *((PWSTR) (&pBuffer[dwSize])) = UNICODE_NULL;

            SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

            while (ReadFile(hMetaFile,
                            pCurrent,
                            pBuffer - pCurrent - sizeof(WCHAR),
                            &dwBytesRead,
                            NULL))
            {
                if (0 == dwBytesRead)
                {
                    //
                    // The whole file has been read in
                    //

                    fRet = TRUE;
                    break;
                }
                pCurrent += dwBytesRead;

                if (pBuffer - pCurrent < sizeof(WCHAR))
                {
                    //
                    // Hmm.. the file is bigger than it used to be
                    //

                    break;
                }
            }

            if (fRet)
            {
                //
                // Scan the buffer for the tag/value pairs
                //

                DWORD dwNewSize = dwSize;
                PWSTR pszMatchTag, pszCRLF;
                int nTagLength = wcslen(pszTag);

                pCurrent = pBuffer;

                while ((pszMatchTag = wcsstr((PWSTR) pCurrent, pszTag)) &&
                       (pszCRLF = wcsstr((PWSTR) pCurrent, g_cszCRLF)))
                {
                    if ((pszMatchTag == (PWSTR) pCurrent) &&
                        (g_chEqual == pszMatchTag[nTagLength]))
                    {
                        //
                        // Got one
                        //

                        DWORD dwCutSize = sizeof(WCHAR) * (pszCRLF + g_cchCRLF - pszMatchTag);

                        ASSERT(dwNewSize >= dwCutSize);

                        dwNewSize -= dwCutSize;

                        //
                        // If we're not at the end of the buffer, slide the remaining
                        // buffer back to remove the part we just cut out
                        //

                        if (dwNewSize > (DWORD) (pCurrent - pBuffer))
                        {
                            RtlMoveMemory(pCurrent,
                                          pCurrent + dwCutSize,
                                          dwNewSize - (pCurrent - pBuffer));
                        }
                    }
                    else
                    {
                        pCurrent = (PBYTE) ((PWSTR) (pszCRLF + g_cchCRLF));
                    }

                    if ((DWORD) (pCurrent - pBuffer) >= dwNewSize)
                    {
                        //
                        // We've hit the end of the valid buffer
                        //

                        break;
                    }
                }

                if (dwNewSize != dwSize)
                {
                    DWORD dwBytesWritten;

                    //
                    // We've shrunk the size, so we need to write the file out
                    //

                    SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);
                    SetEndOfFile(hMetaFile);

                    fRet = FALSE;

                    pCurrent = pBuffer;

                    while (WriteFile(hMetaFile,
                                     pCurrent,
                                     pBuffer + dwNewSize - pCurrent,
                                     &dwBytesWritten,
                                     NULL))
                    {
                        pCurrent += dwBytesWritten;

                        if ((DWORD) (pCurrent - pBuffer) >= dwNewSize)
                        {
                            fRet = TRUE;
                            break;
                        }
                    }
                }
            }

            SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

            LocalFree(pBuffer);
        }
    }

    return fRet;
}

#endif // 0

BOOL
XapiValidateAndSkipUnicodeSignature(
    HANDLE hMetaFile)
{
    WCHAR wchSig;
    DWORD dwRead;
    
    ASSERT(INVALID_HANDLE_VALUE != hMetaFile);
    ASSERT(hMetaFile);

    SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

    return (ReadFile(hMetaFile, &wchSig, sizeof(wchSig), &dwRead, NULL) &&
            (dwRead == sizeof(wchSig)) ||
            (wchSig == g_chUnicodeSignature));
}

BOOL
XapiFindValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag,
    LPWSTR pszValue,
    int cchValue)
{
    BOOL  fRet = FALSE;
    DWORD dwBytesRead;
    WCHAR szBuffer[MAX_METADATA_LINE];
    PWSTR pszNextRead = szBuffer;
    UINT  cchRead = ARRAYSIZE(szBuffer) - 1;
    BOOL  fSkipThroughNextCRLF = FALSE;
    BOOL  fReuseBuffer = FALSE;
    int   nTagLength = wcslen(pszTag);

    //
    // Null terminate the end of the read buffer - we should never overwrite this
    //

    szBuffer[cchRead] = UNICODE_NULL;

    while (fReuseBuffer ||
           (ReadFile(hMetaFile,
                     pszNextRead,
                     cchRead * sizeof(WCHAR),
                     &dwBytesRead,
                     NULL) &&
            (0 != dwBytesRead)))
    {
        DWORD dwBytesValid = dwBytesRead + ((pszNextRead - szBuffer) * sizeof(WCHAR));

        fReuseBuffer = FALSE;

        if (fSkipThroughNextCRLF)
        {
            PWSTR pszCRLF = wcsstr(szBuffer, g_cszCRLF);
            pszNextRead = szBuffer;
            cchRead = ARRAYSIZE(szBuffer) - 1;

            if (pszCRLF)
            {
                DWORD dwBytesSkip;

                pszCRLF += g_cchCRLF;
                dwBytesSkip = ((PBYTE) pszCRLF - (PBYTE) szBuffer);

                ASSERT(dwBytesValid >= dwBytesSkip);

                if (dwBytesSkip < dwBytesValid)
                {
                    //
                    // move the next line of data that we just read to
                    // the beginning of the buffer
                    //

                    DWORD dwBytesMove = dwBytesValid - dwBytesSkip;

                    RtlMoveMemory(szBuffer,
                                  ((PBYTE) szBuffer) + dwBytesSkip,
                                  dwBytesMove);

                    pszNextRead = (PWSTR) (((PBYTE) szBuffer) + dwBytesMove);
                    cchRead = ARRAYSIZE(szBuffer) - 1 - (dwBytesMove >> 1);
                }

                fSkipThroughNextCRLF = FALSE;
            }
        }
        else
        {
            PWSTR pszMatchTag = wcsstr(szBuffer, pszTag);
            if (pszMatchTag && (g_chEqual == pszMatchTag[nTagLength]))
            {
                PWSTR pszCRLF;

                pszMatchTag += (nTagLength + 1);
                pszCRLF = wcsstr(pszMatchTag, g_cszCRLF);

                ASSERT(cchValue > 0);

                if (pszCRLF)
                {
                    DWORD dwBytesUsed;
                    int cchCopy = min(cchValue - 1, (pszCRLF - pszMatchTag));

                    //
                    // Copy the value string to the output buffer
                    //

                    wcsncpy(pszValue, pszMatchTag, cchCopy);

                    //
                    // Null terminate the output buffer
                    //

                    pszValue[cchCopy] = UNICODE_NULL;

                    pszCRLF += g_cchCRLF;

                    dwBytesUsed = ((PBYTE) pszCRLF - (PBYTE) szBuffer);

                    ASSERT(dwBytesValid >= dwBytesUsed);

                    if (dwBytesUsed < dwBytesValid)
                    {
                        //
                        // Move the file pointer back if we didn't use all of
                        // the data that we read
                        //

                        SetFilePointer(hMetaFile,
                                       (dwBytesUsed - dwBytesValid),
                                       NULL,
                                       FILE_CURRENT);
                    }

                    fRet = TRUE;

                    break;
                }
                else
                {
                    fSkipThroughNextCRLF = TRUE;
                    pszNextRead = szBuffer;
                    cchRead = ARRAYSIZE(szBuffer) - 1;
                }
            }
            else
            {
                fSkipThroughNextCRLF = TRUE;
                fReuseBuffer = TRUE;
            }
        }
    }

    return fRet;
}

BOOL
XapiFillInSaveGameData(
    PXGAME_FIND_DATA pFindGameData,
    PCOSTR pszRootDir,
    int cchRootDir)
{
    int nNameLen;
    int iCurIdentity;
    BOOL fRet = FALSE;

    ASSERT(pFindGameData);

    if (0 == (pFindGameData->wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        XDBGWRN("XAPI", "XFindSaveGame: Unexpected file found on save game drive");
        return FALSE;
    }

    nNameLen = ocslen(pFindGameData->wfd.cFileName);

    ASSERT(cchRootDir + nNameLen < ARRAYSIZE(pFindGameData->szSaveGameDirectory));

    ocscpy(pFindGameData->szSaveGameDirectory, pszRootDir);
    ocscpy(&(pFindGameData->szSaveGameDirectory[cchRootDir]),
           pFindGameData->wfd.cFileName);

    //
    // Append a backslash if there is room
    //

    if (cchRootDir + nNameLen < ARRAYSIZE(pFindGameData->szSaveGameDirectory) - 1)
    {
        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen] = OTEXT('\\');
        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen + 1] = OBJECT_NULL;
    }

    //
    // Attempt to open the metadata file
    //

    if (cchRootDir + nNameLen < (int) ARRAYSIZE(pFindGameData->szSaveGameDirectory) - g_cchSaveMetaFileName)
    {
        HANDLE hMetaFile;

        //
        // Borrow the output buffer temporarily to append the metadata filename
        //

        ocscpy(&(pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen]), g_cszSaveMetaFileName);

        hMetaFile = CreateFile(pFindGameData->szSaveGameDirectory,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (INVALID_HANDLE_VALUE != hMetaFile)
        {
            fRet = XapiValidateAndSkipUnicodeSignature(hMetaFile);

            if (fRet)
            {
                fRet = XapiFindValueInMetaFile(hMetaFile,
                                               g_cszNameTag,
                                               pFindGameData->szSaveGameName,
                                               ARRAYSIZE(pFindGameData->szSaveGameName));
            }

            CloseHandle(hMetaFile);
        }

        //
        // Restore the buffer (truncate to remove the metadata filename)
        //

        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen + 1] = OBJECT_NULL;
    }

    return fRet;
}

DWORD
XapiVerifyGameName(
    PCOSTR lpMetaFilePath,
    LPCWSTR lpSaveGameName)
{
    DWORD dwRet;

    HANDLE hMetaFile = CreateFile( lpMetaFilePath,
                                   SYNCHRONIZE | GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_SYSTEM,
                                   NULL);

    if (INVALID_HANDLE_VALUE != hMetaFile)
    {
        WCHAR szName[MAX_GAMENAME];

        if (XapiValidateAndSkipUnicodeSignature(hMetaFile) &&
            XapiFindValueInMetaFile(hMetaFile, g_cszNameTag, szName, ARRAYSIZE(szName)) &&
            (0 == wcscmp(szName, lpSaveGameName)))
        {
            dwRet = ERROR_SUCCESS;
        }
        else
        {
            dwRet = ERROR_NO_MATCH;
        }

        CloseHandle(hMetaFile);
    }
    else
    {
        dwRet = GetLastError();
    }

    return dwRet;
}

VOID
XapiTouchDirectoryTimestamp(
    LPCSTR pcszDir
    )
{
    HANDLE hDir = CreateFile(pcszDir,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);

    if (INVALID_HANDLE_VALUE != hDir)
    {
        FILE_BASIC_INFORMATION BasicInfo;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Zero all the time values we can set.
        //

        RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));

        //
        // Set the last write times
        //

        KeQuerySystemTime(&BasicInfo.LastWriteTime);

        NtSetInformationFile(
                    hDir,
                    &IoStatusBlock,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    FileBasicInformation
                    );

        CloseHandle(hDir);
    }
}

DWORD
WINAPI
XCreateSaveGame(
    IN PCOSTR lpRootPathName,
    IN LPCWSTR lpSaveGameName,
    IN DWORD dwCreationDisposition,
    IN DWORD dwCreateFlags,
    OUT POSTR lpPathBuffer,
    IN UINT uSize)
{
    OCHAR szDirName[MAX_PATH];
    int nPathLength;
    int iCurIdentity;
    HANDLE hMetaFile;
    BOOL fNewCreation;
    DWORD dwNameVerifyResult;

#if DBG
    if ((NULL == lpSaveGameName) ||
        (wcslen(lpSaveGameName) >= MAX_GAMENAME) ||
        (NULL != wcsstr(lpSaveGameName, g_cszCRLF)) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':') != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]) ||
        ((CREATE_NEW != dwCreationDisposition) &&
         (OPEN_EXISTING != dwCreationDisposition) &&
         (OPEN_ALWAYS != dwCreationDisposition)))
    {
        RIP("XCreateSaveGame() invalid parameter");
    }

    RIP_ON_NOT_TRUE("XCreateSaveGame()",
                    ((0 == dwCreateFlags) ||
                     ((XSAVEGAME_NOCOPY == dwCreateFlags) && (OPEN_EXISTING != dwCreationDisposition))));

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XCreateSaveGame() invalid drive letter parameter");
        }
    }

#endif // DBG

    ocscpy(szDirName, lpRootPathName);
    nPathLength = ocslen(szDirName);
    XapiSaveGameHashEncode(lpSaveGameName,
                           &(szDirName[nPathLength]),
                           ARRAYSIZE(szDirName) - nPathLength - g_cchSaveMetaFileName);

    nPathLength = ocslen(szDirName);

    ASSERT(nPathLength < (int) ARRAYSIZE(szDirName) - g_cchSaveMetaFileName);

    if (OPEN_EXISTING == dwCreationDisposition)
    {
        ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
        dwNameVerifyResult = XapiVerifyGameName(szDirName, lpSaveGameName);
        szDirName[nPathLength] = OBJECT_NULL;

        if (ERROR_SUCCESS == dwNameVerifyResult)
        {
            //
            // The existing directory has a metadata file with the same game name,
            // so we're done
            //
            fNewCreation = FALSE;
        }
        else
        {
            return dwNameVerifyResult;
        }
    }
    else
    {
        if (CreateDirectory(szDirName, NULL))
        {
            fNewCreation = TRUE;
        }
        else
        {
            DWORD dwErr = GetLastError();

            dwNameVerifyResult = ERROR_NO_MATCH;

            if (ERROR_ALREADY_EXISTS == dwErr)
            {
                ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
                dwNameVerifyResult = XapiVerifyGameName(szDirName, lpSaveGameName);
                szDirName[nPathLength] = OBJECT_NULL;

                if (ERROR_SUCCESS == dwNameVerifyResult)
                {
                    //
                    // This is the right directory - touch the timestamp
                    // so that the dashboard will see this as the most recently
                    // used save game
                    //

                    XapiTouchDirectoryTimestamp(szDirName);
                }
                else
                {
                    return ERROR_CANNOT_MAKE;
                }
            }

            if ((CREATE_NEW != dwCreationDisposition) && (ERROR_SUCCESS == dwNameVerifyResult))
            {
                //
                // The save game name in the metadata file matched, so we're ok to
                // continue with the rest of this function
                //
                fNewCreation = FALSE;
            }
            else
            {
                return dwErr;
            }
        }
    }

    if (fNewCreation)
    {
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK   ioStatusBlock;
        LARGE_INTEGER     allocationSize;
        OBJECT_STRING     metaFilePathString;
        NTSTATUS          status;

        //
        // Create SAVEMETA.XBX file underneath the save game directory and
        // write metadata information there
        //
        ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);

        RtlInitObjectString(&metaFilePathString, szDirName);
        
        InitializeObjectAttributes(
            &objectAttributes,
            &metaFilePathString,
            OBJ_CASE_INSENSITIVE,
            ObDosDevicesDirectory(),
            NULL
            );

        allocationSize.QuadPart = 1;

        status = NtCreateFile(
                      &hMetaFile,
                      SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                      &objectAttributes,
                      &ioStatusBlock,
                      &allocationSize,
                      FILE_ATTRIBUTE_SYSTEM,
                      0,
                      FILE_OPEN_IF,
                      FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                      );

        szDirName[nPathLength] = OBJECT_NULL;

        if(FAILED(status))
        {
            DWORD dwErr = RtlNtStatusToDosError(status);

            //
            // We failed, so try to remove the directory that we just created
            // so we don't leave an orphan empty directory in the file system.
            //

            RemoveDirectory(szDirName);

            return dwErr;
        }
        else
        {
            DWORD dwBytesWritten = 0;
            DWORD dwSize;

            //
            // One signature WCHAR plus a line of meta data
            //
            
            WCHAR szBuffer[1 + MAX_METADATA_LINE + g_cchNoCopyTrue];

            //
            // Only write the name into the metadata file when we first create it
            //

            _snwprintf(szBuffer,
                       ARRAYSIZE(szBuffer),
                       (XSAVEGAME_NOCOPY & dwCreateFlags) ?
                           L"%lc%ls%lc%ls%ls%ls" :
                           L"%lc%ls%lc%ls%ls",
                       g_chUnicodeSignature,
                       g_cszNameTag,
                       g_chEqual,
                       lpSaveGameName,
                       g_cszCRLF,
                       g_cszNoCopyTrue);

            dwSize = sizeof(WCHAR) * wcslen(szBuffer);

            while (dwSize)
            {
                DWORD dwWrittenNow;
                
                if (!WriteFile(hMetaFile,
                               (PBYTE) szBuffer + dwBytesWritten,
                               dwSize,
                               &dwWrittenNow,
                               NULL))
                {
                    DWORD dwErr = GetLastError();

                    CloseHandle(hMetaFile);
                    
                    //
                    // We failed, so try to remove the directory that we just created
                    // so we don't leave an orphan empty directory in the file system.
                    //
                    
                    RemoveDirectory(szDirName);

                    return dwErr;
                }

                dwSize -= dwWrittenNow;
            }

            CloseHandle(hMetaFile);
        }
    }
#if DBG
    else if (0 != dwCreateFlags)
    {
        XDBGWRN("XAPI",
                "XCreateSaveGame() ignoring dwCreateFlags because save game %ls already exists",
                lpSaveGameName);
    }
#endif // DBG

    if (NULL != lpPathBuffer)
    {
        lstrcpynO(lpPathBuffer, szDirName, uSize);

        if ((UINT) nPathLength < (uSize - 1))
        {
            //
            // Append a backslash (if there is room)
            //

            lpPathBuffer[nPathLength] = OTEXT('\\');
            lpPathBuffer[nPathLength + 1] = OBJECT_NULL;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
WINAPI
XDeleteSaveGame(
    IN PCOSTR lpRootPathName,
    IN LPCWSTR lpSaveGameName)
{
    OCHAR szDirName[64 + MAX_PATH];
    int nPathLength;
    DWORD dwNameVerifyResult;
    int nPrefixLength;
    NTSTATUS Status;

#if DBG
    if ((NULL == lpSaveGameName) ||
        (wcslen(lpSaveGameName) >= MAX_GAMENAME) ||
        (NULL != wcsstr(lpSaveGameName, g_cszCRLF)) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XDeleteSaveGame() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XDeleteSaveGame() invalid drive letter parameter");
        }
    }
#endif // DBG

    ocscpy(szDirName, OTEXT("\\??\\"));
    nPrefixLength = ocslen(szDirName);

    ocscpy(&(szDirName[nPrefixLength]), lpRootPathName);
    nPathLength = ocslen(szDirName);

    XapiSaveGameHashEncode(lpSaveGameName,
                           &(szDirName[nPathLength]),
                           ARRAYSIZE(szDirName) - nPathLength - g_cchSaveMetaFileName);

    nPathLength = ocslen(szDirName);

    ASSERT(nPathLength < (int) ARRAYSIZE(szDirName) - g_cchSaveMetaFileName);

    ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
    dwNameVerifyResult = XapiVerifyGameName(&(szDirName[nPrefixLength]), lpSaveGameName);
    szDirName[nPathLength] = OBJECT_NULL;

    if (ERROR_SUCCESS != dwNameVerifyResult)
    {
        return dwNameVerifyResult;
    }

    //
    // The directory exists with a metadata file in it with a matching game
    // name, so it is safe to proceed
    //
    
    szDirName[nPathLength] = OTEXT('\\');
    szDirName[nPathLength + 1] = OBJECT_NULL;

    Status = XapiNukeDirectory(szDirName);

    return RtlNtStatusToDosError(Status);
}

HANDLE
WINAPI
XFindFirstSaveGame(
    IN PCOSTR lpRootPathName,
    OUT PXGAME_FIND_DATA pFindGameData)
{
    OCHAR szDirName[MAX_PATH];
    int cchRootDir;
    HANDLE hRet;

#if DBG
    if ((NULL == pFindGameData) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XFindFirstSaveGame() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XFindFirstSaveGame() invalid drive letter parameter");
        }
    }
#endif // DBG

    //
    // Create <path>\<*.*> in our own buffer
    //

    ocscpy(szDirName, lpRootPathName);
    cchRootDir = ocslen(szDirName);

    if (cchRootDir > ((int) ARRAYSIZE(szDirName) - 1 - g_cchStar))
    {
        RIP("XFindFirstSaveGame() lpRootPathName parameter too long");
    }

    ocscpy(&(szDirName[cchRootDir]), g_cszStar);

    hRet = FindFirstFile(szDirName, (PWIN32_FIND_DATA) pFindGameData);

    if (INVALID_HANDLE_VALUE != hRet)
    {
        if (!XapiFillInSaveGameData(pFindGameData, lpRootPathName, cchRootDir))
        {
            BOOL fFound;

            while (fFound = FindNextFile(hRet, (PWIN32_FIND_DATA) pFindGameData))
            {
                if (XapiFillInSaveGameData(pFindGameData, lpRootPathName, cchRootDir))
                {
                    break;
                }
            }

            if (!fFound)
            {
                //
                // We didn't find a save game directory
                //

                FindClose(hRet);
                hRet = INVALID_HANDLE_VALUE;
                SetLastError(ERROR_NO_MORE_FILES);
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hRet)
    {
        PFINDGAME_HANDLE pFindGame = LocalAlloc(LMEM_FIXED, sizeof(FINDGAME_HANDLE));

        if (NULL != pFindGame)
        {
            pFindGame->dwSignature = FH_SIG_SAVEGAME;
            pFindGame->hFindFile = hRet;
            pFindGame->cchRootDir = cchRootDir;
            lstrcpynO(pFindGame->szRootDir, lpRootPathName, ARRAYSIZE(pFindGame->szRootDir));
            hRet = (HANDLE) pFindGame;
        }
        else
        {
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return hRet;
}

BOOL
WINAPI
XFindNextSaveGame(
    IN HANDLE hFindGame,
    OUT PXGAME_FIND_DATA pFindGameData)
{
    BOOL bRet = FALSE;

#if DBG
    if ((NULL == hFindGame) ||
        (INVALID_HANDLE_VALUE == hFindGame) ||
        (FH_SIG_SAVEGAME != ((PFINDGAME_HANDLE) hFindGame)->dwSignature) ||
        (NULL == pFindGameData))
    {
        RIP("XFindNextSaveGame() invalid parameter");
    }
#endif // DBG

    {
        PFINDGAME_HANDLE pFindGame = (PFINDGAME_HANDLE) hFindGame;

        while (bRet = FindNextFile(pFindGame->hFindFile, (PWIN32_FIND_DATA) pFindGameData))
        {
            if (XapiFillInSaveGameData(pFindGameData, pFindGame->szRootDir, pFindGame->cchRootDir))
            {
                break;
            }
        }
    }

    return bRet;
}

BOOL
WINAPI
XFindClose(
    IN HANDLE hFindGame)
{
    BOOL fRet = FALSE;

    //
    // Note that all XFind handles begin with a DWORD signature that
    // identifies the type of XFind handle we're dealing with
    //

#if DBG
    if ((INVALID_HANDLE_VALUE == hFindGame) ||
        (NULL == hFindGame) ||
        ((FH_SIG_SAVEGAME != *((PDWORD) hFindGame)) &&
         (FH_SIG_NICKNAME != *((PDWORD) hFindGame)) &&
         (FH_SIG_CONTENT!= *((PDWORD) hFindGame)) &&
         (FH_SIG_SOUNDTRACK != *((PDWORD) hFindGame))))
    {
        RIP("XFindClose() invalid parameter (hFindGame)");
    }
#endif // DBG

    switch (*((PDWORD) hFindGame))
    {
        case FH_SIG_SAVEGAME:
        {
            PFINDGAME_HANDLE pFindGame = (PFINDGAME_HANDLE) hFindGame;
            HANDLE hFindFile = pFindGame->hFindFile;
            LocalFree(pFindGame);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_CONTENT:
        {
            PFINDCONTENT_HANDLE pFindCont = (PFINDCONTENT_HANDLE) hFindGame;
            HANDLE hFindFile = pFindCont->hFindFile;
            LocalFree(pFindCont);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_SOUNDTRACK:
        {
            PSNDTRK_ENUMSTATE pst = (PSNDTRK_ENUMSTATE) hFindGame;
            HANDLE hFindFile = pst->DbHandle;
            LocalFree(pst);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_NICKNAME:
        {
            LocalFree(hFindGame);
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\lib\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xsndtrk.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xsndtrk.c

Abstract:

    XTL Soundtrack Enumeration APIs

Notes:

    Provides support for enumerating the soundtracks a user has ripped through
    the dash and enumerating the songs w/in those soundtracks.

--*/

#include "basedll.h"
#include <xboxp.h>

const OBJECT_STRING XapiStDbFile = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\TDATA\\FFFE0000\\MUSIC\\ST.DB"));
#define STDB_MUSICDIR "\\Device\\Harddisk0\\partition1\\TDATA\\FFFE0000\\MUSIC\\"


//
// Lookaside variables for fast access to data when querying for songs.
//
STDB_LIST XapiListLookaside = {0,INVALID_STID};
STDB_STDESC XapiStLookaside = {0,INVALID_STID};

BOOL
XapiReadFromStDb (
    HANDLE Handle,
    PBYTE Buffer,
    DWORD Signature
    )

/*++

Routine Description:

    Simple helper routing for reading data from the database.

Arguments:

    Handle - Contains a valid file handle of the open soundtrack database.
    Buffer - Used as a buffer for the read.
    Signature - If non-zero, assumes that the first DWORD in the buffer is a signature
                and checks it against this value.

Return Value:

    TRUE if the data was successfully read and the (optional) signature matches. FALSE otherwise.

Notes:



--*/

{

    DWORD byteCount;
    return ReadFile (Handle, Buffer, STDB_PAGE_SIZE, &byteCount, NULL)
        && byteCount == STDB_PAGE_SIZE
        && (!Signature || (*(PDWORD) Buffer) == Signature);
}


NTSTATUS
XapiOpenStDbAndReadHeader (
    HANDLE * Handle,
    PBYTE Buffer
    )

/*++

Routine Description:

    Opens the soundtrack database and validates the header.

Arguments:

    Handle - Receives a valid file handle on success.
    Buffer - Used as a buffer for reading. Receives the header structure of
             the soundtrack database on success.

Return Value:

    STATUS_SUCCESS or error code.

Notes:



--*/

{

    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;



    InitializeObjectAttributes (&obja, (POBJECT_STRING) &XapiStDbFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open the soundtrack database.
    //

    status = NtCreateFile (
                Handle,
                SYNCHRONIZE | GENERIC_READ,
                &obja,
                &iosb,
                NULL,
                FILE_ATTRIBUTE_SYSTEM | FILE_NO_INTERMEDIATE_BUFFERING,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (NT_SUCCESS(status) && !XapiReadFromStDb (*Handle, Buffer, 0)) {

            status = STATUS_UNSUCCESSFUL;
            NtClose (*Handle);
    }

    return status;

}



BOOL
XapiGetNextSoundtrack (
    PBYTE Buffer,
    PSNDTRK_ENUMSTATE State,
    PXSOUNDTRACK_DATA Data
    )

/*++

Routine Description:

    Worker function for retrieving the next soundtrack from the database.

Arguments:

    Buffer - Buffer for reading from the soundtrack database.
    State - State variable used for internal tracking of enumeration data.
    Data - receives soundtrack data for the next soundtrack.

Return Value:

    TRUE if there are additional soundtracks to enumerate, FALSE otherwise.

Notes:



--*/


{
    BOOL ok = FALSE;

    //
    // Note that Buffer is passed down to XapiGetNextSoundtrack for use as a temporary buffer.
    // XFindFirstSoundtrack and XFindNextSoundtrack must not assume anything about the contents
    // of this buffer following the call. Therefore, if they use the buffer (like XFindFirstSoundtrack
    // does) they are responsible for ensuring that the data in that buffer is not needed after the
    // XapiGetNextSoundtrack call. This was done to reduce the size of the stack allocations when using
    // the enum APIs.
    //


    if (State->Index < State->MaxIndex) {

        SetFilePointer (State->DbHandle, STDB_PAGE_SIZE * (State->Index + 1), NULL, FILE_BEGIN);
        State->Index++;

        ok = XapiReadFromStDb (State->DbHandle, Buffer, STDB_STSIG);
    }

    if (ok) {

        memcpy (&XapiStLookaside, Buffer, sizeof(STDB_STDESC));
        wcsncpy (Data->szName, XapiStLookaside.Name, MAX_SOUNDTRACK_NAME);
        Data->uSoundtrackId = XapiStLookaside.Id;
        Data->uSongCount = XapiStLookaside.SongCount;
        Data->uSoundtrackLength = XapiStLookaside.SoundtrackLength;

    }

    return ok;
}

XBOXAPI
BOOL
WINAPI
XFindNextSoundtrack (
    IN HANDLE FindHandle,
    OUT PXSOUNDTRACK_DATA SoundtrackData
    )

/*++

Routine Description:

    Continues an enumeration of soundtracks begun with XFindFirstSoundtrack.

Arguments:

    Handle - Contains a valid file handle returned from XFindFirstSoundtrack.
    SoundtrackData - Valid pointer to a soundtrack data structure. On
                     success, receives the data of the next soundtrack in the list.

Return Value:

    TRUE if there are additional soundtracks to enumerate, FALSE otherwise.

Notes:



--*/

{
    BYTE buf[STDB_PAGE_SIZE];

    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (NULL != FindHandle));
    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (INVALID_HANDLE_VALUE != FindHandle));
    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (NULL != SoundtrackData));

#if DBG
    if (FH_SIG_SOUNDTRACK != ((PSNDTRK_ENUMSTATE) FindHandle)->Signature)
    {
        RIP("XFindNextSoundtrack() - invalid parameter (FindHandle)");
    }
#endif // DBG

    return XapiGetNextSoundtrack (buf, (PSNDTRK_ENUMSTATE) FindHandle, SoundtrackData);

}

XBOXAPI
HANDLE
WINAPI
XFindFirstSoundtrack (
    OUT PXSOUNDTRACK_DATA SoundtrackData
    )

/*++

Routine Description:

    Begins an enumeration of the soundtracks on the media and returns the
    first soundtrack.

Arguments:

    SoundtrackData - Valid pointer to a soundtrack data structure. On
                     success, receives the data of the first soundtrack.

Return Value:

    valid HANDLE which may be used in future calls to XFindNextSoundtrack on success,
    otherwise, INVALID_HANDLE_VALUE.

Notes:



--*/

{


    HANDLE h;
    PSNDTRK_ENUMSTATE state = NULL;
    NTSTATUS status;
    BYTE buf[STDB_PAGE_SIZE];
    PSTDB_HDR hdr;



    RIP_ON_NOT_TRUE("XFindFirstSoundtrack()", (NULL != SoundtrackData));


    status = XapiOpenStDbAndReadHeader (&h, buf);

    //
    // Build the enum state data that will be passed back to the caller.
    //
    if (NT_SUCCESS (status)) {

        hdr = (PSTDB_HDR) buf;
        state = LocalAlloc (LMEM_FIXED, sizeof (SNDTRK_ENUMSTATE));

        if (!state) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            SetLastError (RtlNtStatusToDosError (status));
            NtClose (h);
        }
        else {

            state->Signature = FH_SIG_SOUNDTRACK;
            state->MaxIndex = hdr->StCount;
            state->Index = 0;
            state->DbHandle = h;
        }
    }
    else {

        SetLastError (RtlNtStatusToDosError (status));

    }

    //
    // Now, attempt to retrieve the first soundtrack from the database.
    //
    if (NT_SUCCESS (status)) {

            if (!XapiGetNextSoundtrack (buf, state, SoundtrackData)) {

                NtClose (h);
                LocalFree (state);
                state = NULL;

            }
    }


    return state ? (HANDLE) state : INVALID_HANDLE_VALUE;
}

XBOXAPI
BOOL
WINAPI
XGetSoundtrackSongInfo (
    IN DWORD SoundtrackId,
    IN UINT Index,
    OUT PDWORD SongId,
    OUT PDWORD SongLength,
    OUT OPTIONAL PWSTR NameBuffer,
    IN UINT BufferSize
    )

/*++

Routine Description:

    Retrieves information about a particular song index in a soundtrack.

Arguments:

    SoundtrackId - Contains the soundtrack identifier of interest.
    Index - Contains the index of the song within the soundtrack of interest.
    SongId - Receives the unique identifier of the song at the given index within the soundtrack.
    NameBuffer - Optionally receives the UNICODE name of the song.
    BufferSize - If NameBuffer is non null, specifies the size of NameBuffer in UNICODE characters.

Return Value:

    TRUE if the data was successfully returned, FALSE otherwise.

Notes:

    This API allows a title to randomly access songs from within a given soundtrack (for doing things
    such as shuffle, random play, etc.) However, linearly incrementing index is the most efficient
    way to enumerate songs because individual songs are batched in groups of 7 within the database. As long
    as the index is within the same group of seven as the last call to this function, no additional read
    is necessary.

--*/

{
    BOOL ok = TRUE;
    HANDLE h = INVALID_HANDLE_VALUE;
    PSTDB_HDR hdr;
    BYTE buf[STDB_PAGE_SIZE];
    UINT i;
    UINT val;
    NTSTATUS status;

    RIP_ON_NOT_TRUE("XGetSongInfo()", (INVALID_STID != SoundtrackId));
    RIP_ON_NOT_TRUE("XGetSongInfo()", (NULL != SongId));

#if DBG

    if (NameBuffer && BufferSize < MAX_SONG_NAME) {

        RIP ("XGetSongInfo() - 'NameBuffer' Buffer too small.");
    }

#endif

    //
    // Make sure the correct soundtrack is in the lookaside list.
    //
    if (XapiStLookaside.Id != SoundtrackId) {

        status = XapiOpenStDbAndReadHeader (&h, buf);
        ok = NT_SUCCESS(status);
        if (ok) {

            //
            // The header contains an array of all the possible soundtrack blocks
            // and the soundtrack ids in each of those blocks. Read through
            // the array to find the block to seek to.
            //

            hdr = (PSTDB_HDR) buf;
            val = min (hdr->StCount, MAX_SOUNDTRACKS);


            for (i = 0; i < val; i++) {
                if (hdr->StBlocks[i] == SoundtrackId) {
                    break;
                }
            }

            if (i == val)  {
                ok = FALSE;
                SetLastError (ERROR_INVALID_PARAMETER);
            }
        }
        else {

            SetLastError (RtlNtStatusToDosError (status));
        }


        if (ok) {
            ok = (SetFilePointer (h, i * STDB_PAGE_SIZE, NULL, FILE_CURRENT) != INVALID_SET_FILE_POINTER);
            if (!ok) {
                SetLastError (ERROR_INVALID_DATA);
            }

        }

        if (ok) {
            ok = XapiReadFromStDb (h, buf, STDB_STSIG);
        }

        if (ok) {
            memcpy (&XapiStLookaside, buf, sizeof (STDB_STDESC));
            ok = XapiStLookaside.Id == SoundtrackId && XapiStLookaside.SongCount > Index;
            if (!ok) {
                SetLastError (ERROR_INVALID_PARAMETER);
            }
        }
    }


    //
    // Make sure the correct list segment is in the lookaside list.
    //
    if (ok) {

        if (XapiListLookaside.StId != SoundtrackId ||
            Index < (XapiListLookaside.ListIndex * WMADESC_LIST_SIZE) ||
            Index >= (XapiListLookaside.ListIndex + 1) * WMADESC_LIST_SIZE
            ) {


            if (h == INVALID_HANDLE_VALUE) {
                status = XapiOpenStDbAndReadHeader (&h, buf);
                ok = NT_SUCCESS(status);
                if (!ok) {
                    SetLastError (RtlNtStatusToDosError (status));
                }
            }

            if (ok) {
                val = (XapiStLookaside.ListBlocks[Index / WMADESC_LIST_SIZE] + 1 + MAX_SOUNDTRACKS) * STDB_PAGE_SIZE;
                ok = (SetFilePointer (h, val, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER);
                if (!ok) {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }


            if (ok) {
                ok = XapiReadFromStDb (h, buf, STDB_LISTSIG);
            }

            if (ok) {
                memcpy (&XapiListLookaside, buf, sizeof (STDB_LIST));
                ok = XapiListLookaside.StId == SoundtrackId;
                if (!ok) {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }
        }
    }

    //
    // Get the song info for the selected song.
    //
    if (Index > XapiStLookaside.SongCount) {

        ok = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    if (ok) {



        *SongId = XapiListLookaside.SongIds[Index % WMADESC_LIST_SIZE];
        *SongLength = XapiListLookaside.SongLengths[Index % WMADESC_LIST_SIZE];
        if (NameBuffer) {
            wcsncpy (NameBuffer, XapiListLookaside.SongNames[Index % WMADESC_LIST_SIZE], MAX_SONG_NAME);
        }

    }

    if (h != INVALID_HANDLE_VALUE) {
        CloseHandle (h);
    }

    return ok;
}
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xsndtrk.c

Abstract:

    This module contains the Xbox Soundtrack APIs

Author:

    Marc R. Whitten (marcw)  13-Feb-2001

Revision History:

--*/


XBOXAPI
HANDLE
WINAPI
XOpenSoundtrackSong (
    IN DWORD SongId,
    IN BOOL Asynchronous
    )

/*++

Routine Description:

    Opens the WMA song matching the song ID in the Dash Music directory.

Arguments:

    SongId - Contains the songid to open.
    Asynchronous - TRUE if the flag should be opened for asynchronous reads, FALSE if
                   it should be opened for synchronous reading.

Return Value:

    A valid file handle to the WMA song represented by the songid if successful, or
    INVALID_HANDLE_VALUE otherwise.

Notes:



--*/
{
    CHAR path[MAX_PATH];
    HANDLE h;
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING oPath;



    sprintf (path, "%s%04x\\%08x.WMA", STDB_MUSICDIR, HIWORD(SongId), SongId);


    RtlInitObjectString(&oPath, path);
    InitializeObjectAttributes (&obja, &oPath, OBJ_CASE_INSENSITIVE, NULL, NULL);


    //
    // Attempt to open the soundtrack.
    //
    status = NtCreateFile (
            &h,
            SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES,
            &obja,
            &iosb,
            NULL,
            0,
            FILE_SHARE_READ,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | (Asynchronous ? FILE_NO_INTERMEDIATE_BUFFERING : FILE_SYNCHRONOUS_IO_NONALERT)
            );



    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError (status);
    }

    return NT_SUCCESS (status) ? h : INVALID_HANDLE_VALUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\xvalue.c ===
#include "basedll.h"
#include "..\..\fatx\fatx.h"
#include "av.h"
#include "xconfig.h"
#include <xboxp.h>

#ifdef XAPILIBP

extern const OBJECT_STRING XapiHardDisk;

#else  // XAPILIBP

const OBJECT_STRING XapiHardDisk = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition0") );

#endif // XAPILIBP


#ifdef XAPILIBP

DWORD
XSetValue(
    IN ULONG ulValueIndex,
    IN ULONG ulType,
    IN PVOID pValue,
    IN ULONG cbValueLength
    )
{
    NTSTATUS status;
    status = ExSaveNonVolatileSetting(ulValueIndex, ulType, pValue, cbValueLength);
    return RtlNtStatusToDosError(status);
}

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
XQueryValue(
    IN ULONG ulValueIndex,
    OUT PULONG pulType,
    OUT PVOID pValue,
    IN ULONG cbValueLength,
    IN OUT PULONG pcbResultLength
    )
{
    NTSTATUS status;

    status = ExQueryNonVolatileSetting(
                ulValueIndex,
                pulType,
                pValue,
                cbValueLength,
                pcbResultLength);

    return RtlNtStatusToDosError(status);
}


DWORD
XGetLanguage(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_LANGUAGE,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : XC_LANGUAGE_UNKNOWN;
}


DWORD
XGetAVPack(
    VOID
    )
{
    return *HalBootSMCVideoMode;
}


DWORD
XGetVideoStandard(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_FACTORY_AV_REGION,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ?
                          ((dwValue & AV_STANDARD_MASK) >> AV_STANDARD_BIT_SHIFT) :
                          0;
}


DWORD
XGetVideoFlags(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue = NT_SUCCESS(ExQueryNonVolatileSetting(
                               XC_VIDEO_FLAGS,
                               &ulType,
                               &dwValue,
                               sizeof(dwValue),
                               NULL)) ?
                                 ((dwValue & AV_USER_FLAGS_MASK) >> AV_USER_FLAGS_BIT_SHIFT) :
                                 0;

    switch (XGetAVPack())
    {
        case XC_AV_PACK_SCART:
        case XC_AV_PACK_VGA:
        case XC_AV_PACK_RFU:
        case XC_AV_PACK_SVIDEO:
        case XC_AV_PACK_STANDARD:

            //
            // Do not allow HDTV flags for AV packs that we know do not
            // support component out
            //

            dwValue &= ~(XC_VIDEO_FLAGS_HDTV_720p |
                         XC_VIDEO_FLAGS_HDTV_1080i |
                         XC_VIDEO_FLAGS_HDTV_480p);
            break;

        case XC_AV_PACK_HDTV:
        default:

             //
             // Allow HDTV flags for everything else
             //

             break;
    }

    return dwValue;
}


DWORD
XGetAudioFlags(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue = NT_SUCCESS(ExQueryNonVolatileSetting(
                               XC_AUDIO_FLAGS,
                               &ulType,
                               &dwValue,
                               sizeof(dwValue),
                               NULL)) ? dwValue : 0;

    switch (XGetAVPack())
    {
        case XC_AV_PACK_RFU:

            //
            // RF pack should always be mono because that is all that it can output
            //

            dwValue = XC_AUDIO_FLAGS_MONO;
            break;

        case XC_AV_PACK_STANDARD:

            //
            // Std pack has no optical output so we mask off DD & DTS bits
            //

            dwValue = XC_AUDIO_FLAGS_BASIC(dwValue);
            break;
    }

    return dwValue;
}


DWORD
XGetParentalControlSetting(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_PARENTAL_CONTROL_GAMES,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : 0;
}


DWORD
XGetGameRegion(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_FACTORY_GAME_REGION,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : 0;
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\i386\intrlock.asm ===
title   "Interlocked API Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     intrlock.asm
;
;  Abstract:
;
;     This module implements functions to support user mode interlocked operations.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

Addend      equ     [esp + 4]

        page , 132
        subttl  "InterlockedIncrement"
;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - the incremented value.
;
;--

cPublicProc __InterlockedIncrement,1
cPublicFpo 1,0
        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,1                   ; set increment value

        xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
        stdRET __InterlockedIncrement    ;

stdENDP __InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicProc __InterlockedDecrement,1
cPublicFpo 1,0

        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value

        xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
        stdRET __InterlockedDecrement    ;

stdENDP __InterlockedDecrement

        page , 132
        subttl  "Interlocked Exchange"
;++
;
; LONG
; InterlockedExchange(
;    IN OUT LPLONG Target,
;    IN LONG Value
;    )
;
; Routine Description:
;
;    This function atomically exchanges the Target and Value, returning
;    the prior contents of Target
;
; Arguments:
;
;    Target - Address of LONG to exchange
;    Value  - New value of LONG
;
; Return Value:
;
;    (eax) - The prior value of target.
;--

cPublicProc __InterlockedExchange, 2
cPublicFpo 2,0

        mov     ecx, [esp+4]                ; (ecx) = Target
        mov     edx, [esp+8]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
        cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
        stdRET  __InterlockedExchange

stdENDP __InterlockedExchange

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    Destination - Supplies a pointer to destination value.
;
;    Exchange - Supplies the exchange value.
;
;    Comperand - Supplies the comperand value.
;
; Return Value:
;
;    (eax) - The initial destination value.
;
;--

cPublicProc __InterlockedCompareExchange, 3
cPublicFpo 3,0

        mov     ecx, [esp + 4]          ; get destination address
        mov     edx, [esp + 8]          ; get exchange value
        mov     eax, [esp + 12]         ; get comperand value

        cmpxchg [ecx], edx              ; compare and exchange
        stdRET  __InterlockedCompareExchange

stdENDP __InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
; Return Value:
;
;    (eax) - The initial value of the addend.
;
;--

cPublicProc __InterlockedExchangeAdd, 2
cPublicFpo 2,0

        mov     ecx, [esp + 4]          ; get addend address
        mov     eax, [esp + 8]          ; get increment value

        xadd    [ecx], eax              ; exchange add
        stdRET  __InterlockedExchangeAdd

stdENDP __InterlockedExchangeAdd

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xapi\k32\i386\muldiv.asm ===
title   "Multiply and Divide"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     muldiv.asm (taken from base\client\i386\critsect.asm)
;
;  Abstract:
;
;     Optimized multiply and divide routines
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\sources.inc ===
INCLUDES=\
    $(BASEDIR)\private\ntos\xnet\inc; \
    $(BASEDIR)\private\ntos\inc

C_DEFINES=\
    $(C_DEFINES) \
    -D_UNICODE \
    -DUNICODE \
    -DNT

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=$(TARGETNAME)pre.obj

!if defined(XNET_DEBUG_COMPILE_LEVEL)
C_DEFINES=$(C_DEFINES) -DXNET_DEBUG_COMPILE_LEVEL=$(XNET_DEBUG_COMPILE_LEVEL)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dhcp\dhcp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    DHCP client protocol handling code
    as well as Autonet implementation

Revision History:

    04/21/2000 davidx
        Created it.

    05/25/2000 davidx
        Ported over to the new net tree.

--*/

#include "precomp.h"


//
// First 4 bytes of the options field in a DHCP message
// must match the following magic cookie
//
const BYTE DhcpMagicCookie[DHCPCOOKIELEN] = { 99, 130, 83, 99 };

//
// Default address lease time requested:
//  let the server decide
//
UINT cfgDefaultLeaseTime = 0;

//
// Minimum retransmission timeout while in
// RENEWING and REBINDING states: 60 seconds
//
UINT cfgMinRenewTimeout = 60;

//
// Number of seconds to wait after reboot
// before we start sending out DHCPDISCOVER packets
//
// NOTE: RFC2131 recommends that we wait between 1 to 10 seconds.
// But we're only doing 1 seconds here for faster startup time.
//
UINT cfgStartupWaitMin = 0;
UINT cfgStartupWaitMax = 1;

//
// Number of times we'll attempt to resend
// DHCPDISCOVER and DHCPREQUEST packets
//
// NOTE: Non-standard behavior!!!
//  We're capping the timeout between retries to a maximum of 10 seconds.
//
UINT cfgDhcpRetryCount = 3;
UINT cfgDhcpRetryMaxTimeout = 10;

//
// Number of autonet addresses we'll attempt before giving up
//
UINT cfgAutonetAddrRetries = 10;

//
// How frequently to look for DHCP server when in Autonet mode
//
UINT cfgAutonetDhcpCheckInterval = 5*60;

//
// How many ARP requests to send
// when checking for address conflict
//
UINT cfgConflictCheckRetries = 2;

//
// Global transaction ID
//
PRIVATE DWORD DhcpGlobalXid = 0;

//
// Forward function declarations
//
PRIVATE VOID DhcpChangeState(DhcpInfo*, INT);
PRIVATE VOID DhcpSetIfTimerRelative(DhcpInfo*, UINT, UINT);
PRIVATE VOID DhcpSetIfTimerAbsolute(DhcpInfo*, DHCPTIME);
PRIVATE VOID DhcpHandleTimeout(DhcpInfo*);
PRIVATE VOID DhcpResetInterface(DhcpInfo*);
PRIVATE VOID DhcpSelectAutonetAddr(DhcpInfo*);

PRIVATE NTSTATUS DhcpSendDiscover(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendRequest(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendInform(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendDecline(DhcpInfo*, IPADDR, IPADDR);
PRIVATE NTSTATUS DhcpSendRelease(DhcpInfo*);

PRIVATE VOID DhcpUseOptionParams(DhcpInfo*, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpParseOptionParams(DhcpOptionParam*, const BYTE*, UINT, BYTE*);
PRIVATE NTSTATUS DhcpProcessOffer(DhcpInfo*, IPADDR, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpProcessAck(DhcpInfo*, IPADDR, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpProcessNak(DhcpInfo*, IPADDR);
PRIVATE VOID DhcpLoadConfigInfo(DhcpInfo*);

// Check to see if we're forced to use autonet address
//  (without trying to find DHCP servers)
INLINE BOOL DhcpForceAutonet(IPADDR addr, IPADDR mask) {
    return (mask == HTONL(AUTONET_ADDRMASK)) && 
           (addr & mask) == (HTONL(AUTONET_ADDRBASE) & mask);
}



NTSTATUS
DhcpInitialize(
    IfInfo* ifp
    )

/*++

Routine Description:

    Initialize the DHCP related data structure for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp;

    if ((dhcp = ifp->dhcpInfo) != NULL) {
        dhcp->flags |= FLAG_CREATED_BY_DEBUGGER;
        return NETERR_OK;
    }

    dhcp = (DhcpInfo*) SysAlloc0(sizeof(DhcpInfo), PTAG_DHCP);
    if (!dhcp) return NETERR_MEMORY;

    KeInitializeEvent(&dhcp->addrEvent, NotificationEvent, FALSE);
    dhcp->ifp = ifp;
    dhcp->state = STATE_NONE;
    dhcp->flags = FLAG_SEND_DHCPINFORM;
    dhcp->timer = 0xffffffff;

    ifp->dhcpInfo = dhcp;

    // Load persistent DHCP configuration parameters
    DhcpLoadConfigInfo(dhcp);

    if (dhcp->activeaddr != 0 &&
        !DhcpForceAutonet(dhcp->activeaddr, dhcp->activemask)) {

        //
        // If we're using static address, inform the IP stack
        // BUGBUG - also need to set up the default DNS server?
        //
        IfSetIpAddr(ifp, dhcp->activeaddr, dhcp->activemask);
        DhcpSignalAddrEvent(dhcp);
        DhcpSetDefaultGateways(ifp);
        DhcpChangeState(dhcp, STATE_STATIC_ADDR);

    } else if (!(ifp->flags & IFFLAG_CONNECTED_BOOT) ||
               (cfgXnetConfigFlags & XNET_INITFLAG_FORCE_AUTONET) ||
               dhcp->activeaddr != 0) {

        //
        // Skip the DHCP address discovery process and
        // go straight to autonet mode if:
        //  1. The net cable is disconnected at boot time
        //  2. XnetInitialize was called with force-autonet mode
        //  3. User has configed static IP address = 169.254.x.x
        //
        WARNING_("Forcing autonet...");
        dhcp->activeaddr = dhcp->activemask = 0;
        DhcpChangeState(dhcp, STATE_SELECT_AUTOADDR);

    } else {

        //
        // Obtain address via DHCP or Autonet
        // Be quiet for a while after startup
        //
        DhcpSetIfTimerRelative(dhcp, cfgStartupWaitMin, cfgStartupWaitMax);
    }

    return NETERR_OK;
}


VOID
DhcpCleanup(
    IfInfo* ifp
    )

/*++

Routine Description:

    Clean up DHCP related data for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;
    if (dhcp->flags & FLAG_CREATED_BY_DEBUGGER) {
        dhcp->flags &= ~FLAG_CREATED_BY_DEBUGGER;
        return;
    }
    ifp->dhcpInfo = NULL;

    // Release the DHCP address if necessary
    if (ActiveDhcpAddr(dhcp) && (dhcp->flags & FLAG_RELEASE_ON_REBOOT)) {
        DhcpSendRelease(dhcp);
    }

    // Free the memory for the interface structure
    SysFree(dhcp);
}


VOID
DhcpTimerProc(
    IfInfo* ifp
    )

/*++

Routine Description:

    DHCP timer routine for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    // Do nothing if the timer hasn't expired
    if (dhcp == NULL ||
        dhcp->timer == 0xffffffff ||
        dhcp->timer-- > 1)
        return;

    DhcpHandleTimeout(dhcp);
}


VOID
DhcpReceivePacket(
    IfInfo* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Handle a UDP packet received on an interface
    that's destined for the DHCP client port

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the received packet

Return Value:

    NONE

Note:

    The caller retains ownership of the received packet.
    So we don't call CompletePacket on it here.

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    DhcpMessage* msg;
    UINT msglen;
    DhcpOptionParam* dhcpParams = NULL;
    BYTE* option;
    BYTE overload = 0;
    NTSTATUS status = NETERR_DISCARDED;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;

    msg = GETPKTDATA(pkt, DhcpMessage);
    msglen = pkt->datalen;

    DhcpDumpMessage(msg, msglen);

    //
    // Basic sanity checks: was the packet really meant for us?
    //
    if (msglen < DHCPHDRLEN ||
        msg->op != BOOTREPLY ||
        msg->htype != DhcpMapHwtype(ifp->iftype) ||
        msg->hlen != ifp->hwaddrlen ||
        !EqualMem(msg->chaddr, ifp->hwaddr, ifp->hwaddrlen) ||
        NTOHL(msg->xid) != dhcp->xid) {
        return;
    }

    dhcpParams = (DhcpOptionParam*) XnetAlloc0(sizeof(*dhcpParams), PTAG_DHCP);
    if (!dhcpParams) {
        status = NETERR_MEMORY;
        goto exit;
    }

    //
    // Skip the DHCP magic cookie
    //
    option = msg->options;
    msglen -= DHCPHDRLEN;
    if (msglen < DHCPCOOKIELEN ||
        !EqualMem(option, DhcpMagicCookie, DHCPCOOKIELEN)) {
        goto exit;
    }
    msglen -= DHCPCOOKIELEN;
    option += DHCPCOOKIELEN;

    //
    // Parse the regular options
    //
    status = DhcpParseOptionParams(dhcpParams, option, msglen, &overload);
    if (!NT_SUCCESS(status)) goto exit;

    //
    // Parse overloaded options in the msg->file field
    //
    if (overload & 1) {
        status = DhcpParseOptionParams(dhcpParams, msg->file, sizeof(msg->file), NULL);
        if (!NT_SUCCESS(status)) goto exit;
    }

    //
    // Parse overloaded options in the msg->sname field
    //
    if (overload & 2) {
        status = DhcpParseOptionParams(dhcpParams, msg->sname, sizeof(msg->sname), NULL); 
        if (!NT_SUCCESS(status)) goto exit;
    }

    //
    // The received packet must have a server identifier option
    //
    if (dhcpParams->dhcpServer == 0) {
        status = NETERR_PARAM;
        goto exit;
    }

    //
    // Now that we've parsed the option data,
    // use it appropriately
    //
    status = NETERR_DISCARDED;

    switch (dhcp->state) {
    case STATE_INIT:
        // Expecting DHCPOFFER...
        if (dhcpParams->recvMsgType == DHCPOFFER)
            status = DhcpProcessOffer(dhcp, msg->yiaddr, dhcpParams);
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Expecting DHCPACK or DHCPNAK...
        if (dhcpParams->recvMsgType == DHCPACK)
            status = DhcpProcessAck(dhcp, msg->yiaddr, dhcpParams);
        else if (dhcpParams->recvMsgType == DHCPNAK)
            status = DhcpProcessNak(dhcp, dhcpParams->dhcpServer);
        break;

    case STATE_STATIC_ADDR:
        // Expecting DHCPACK...
        if (dhcpParams->recvMsgType == DHCPACK) {
            // Use the option parameters from the server
            DhcpUseOptionParams(dhcp, dhcpParams);
            status = NETERR_OK;
        }
        break;
    }

exit:

    if (!NT_SUCCESS(status) && status != NETERR_DISCARDED) {
        WARNING_("ProcessDhcpPacket failed: 0x%x", status);
    }

    XnetFree(dhcpParams);
}


VOID
DhcpNotifyAddressConflict(
    IfInfo* ifp
    )

/*++

Routine Description:

    This is called when the interface layer detects
    an address conflict (e.g. through ARP)

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;

    if (dhcp->state == STATE_SELECT_AUTOADDR) {
        // the last autonet address we chose was no good
        // so we need to find another one
        DhcpSelectAutonetAddr(dhcp);
    } else {
        WARNING_("!!! Address conflict: %s", IPADDRSTR(dhcp->activeaddr));
    }
}


//
// Number of seconds from start of 1601 to start of 2000
//
static const LONGLONG StartOf2000 = 0x2ee7dd480;

PRIVATE DHCPTIME
DhcpTime()

/*++

Routine Description:

    Return the number of seconds ellapsed since 00:00:00
    January 1, 2000, coordinated universal time.

Arguments:

    NONE

Return Value:

    See above.

--*/

{
    LARGE_INTEGER currentTime;

    // Get the current UTC time
    //  = number of 100 nanoseconds since 1/1/1601
    KeQuerySystemTime(&currentTime);

    // Return the number of seconds since the start of 2000
    return (DHCPTIME) (currentTime.QuadPart / 10000000 - StartOf2000);
}


PRIVATE VOID
DhcpSetIfTimerRelative(
    DhcpInfo* dhcp,
    UINT minWait,
    UINT maxWait
    )

/*++

Routine Description:

    Set the timer for an interface:
        randomized and relative to current time

Arguments:

    dhcp - Points to the DHCP structure
    minWait, maxWait - minimum and maximum wait time, in seconds

Return Value:

    NONE

--*/

{
    // Compute the randomized wait time
    minWait += XnetRandScaled(maxWait - minWait);

    if ((dhcp->timer = minWait) == 0) {
        DhcpHandleTimeout(dhcp);
    }
}


PRIVATE VOID
DhcpSetIfTimerAbsolute(
    DhcpInfo* dhcp,
    DHCPTIME timer
    )

/*++

Routine Description:

    Set the timer for an interface: absolute time

Arguments:

    dhcp - Points to the DHCP structure
    timer - When the timer should expire
        number of seconds since the start of 1/1/2000

Return Value:

    NONE

--*/

{
    DHCPTIME now;

    if (timer == DHCPTIME_INFINITE) {
        // Infinite wait
        dhcp->timer = 0xffffffff;
        return;
    }

    now = DhcpTime();
    if (timer > now) {
        dhcp->timer = timer - now;
    } else {
        dhcp->timer = 0;
        DhcpHandleTimeout(dhcp);
    }
}


PRIVATE VOID
DhcpComputeTimeout(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Compute the next timeout interval after sending out a packet

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    UINT minWait, maxWait;

    switch (dhcp->state) {
    case STATE_INIT:
        if (ActiveAutonetAddr(dhcp)) {
            //
            // Special case: we're currently using an Autonet address
            // and we're sending out periodic DHCPDISCOVER packets.
            //
            // DhcpSetIfTimerRelative(
            //     dhcp,
            //     cfgAutonetDhcpCheckInterval,
            //     cfgAutonetDhcpCheckInterval);

            // NOTE: Non-standard behavior!!!
            //  We do not send out DHCPDISCOVER messages
            //  while we're using an active AutoNet address.
            DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
            break;
        }

        // Fall through

    case STATE_REQUESTING:
    case STATE_INIT_REBOOT:
        //
        // timeout = 2**retry x 2 +/- 1, i.e.
        //  4 +/- 1
        //  8 +/- 1
        //  16 +/- 1
        //  32 +/- 1
        //

        minWait = 2 << dhcp->retries;
        if (minWait > cfgDhcpRetryMaxTimeout)
            minWait = cfgDhcpRetryMaxTimeout;

        minWait -= 1;
        maxWait = minWait + 2;
        DhcpSetIfTimerRelative(dhcp, minWait, maxWait);
        break;

    case STATE_BOUND:
        //
        // timeout when T1 expires
        //
        DhcpSetIfTimerAbsolute(dhcp, dhcp->t1time);
        break;

    case STATE_RENEWING:
    case STATE_REBINDING: {
        //
        // calculate retransmission timeout for
        // RENEWING and REBINDING states:
        //  1. half the time from now to T2 (renew) or expiration (rebind)
        //  2. make sure it's at least 60 seconds
        //

        DHCPTIME t1, t2;
        t1 = DhcpTime();
        t2 = (dhcp->state == STATE_RENEWING) ? dhcp->t2time : dhcp->exptime;

        if (t1 < t2) {
            minWait = (t2-t1) / 2;
            if (minWait >= cfgMinRenewTimeout)
                t1 += minWait;
            else {
                t1 += cfgMinRenewTimeout;
                if (t1 > t2) t1 = t2;
            }
        }

        DhcpSetIfTimerAbsolute(dhcp, t1);
        }
        break;

    case STATE_DECLINING:
        //
        // Wait 10 seconds after sending DHCP decline
        //
        DhcpSetIfTimerRelative(dhcp, 10, 10);
        break;
    
    case STATE_SELECT_AUTOADDR:
        //
        // Wait ~2 seconds for address conflict detection
        //
        DhcpSetIfTimerRelative(dhcp, 2, 2);
        break;

    default:
        // Should not happen - shut off the timer just in case
        ASSERT(FALSE);

    case STATE_STATIC_ADDR:
    case STATE_NONE:
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpHandleTimeout(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Handle a timeout event for an interface

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    switch (dhcp->state) {
    case STATE_NONE:
        //
        // We got here because we just finished the quiet
        // period after startup
        //
        // If we had a valid lease before, start in
        // INIT-REBOOT state; otherwise, start in INIT state
        //
        DhcpChangeState(dhcp, dhcp->dhcpaddr ? STATE_INIT_REBOOT : STATE_INIT);
        break;
    
    case STATE_INIT:
        //
        // We're sending DHCPDISCOVER messages
        //
        if (dhcp->retries >= cfgDhcpRetryCount && !ActiveAutonetAddr(dhcp)) {
            //
            // Too many retries, give up and
            // start Autonet address acquisition process
            //
            VERBOSE_("Couldn't discover DHCP server, trying autonet...");
            DhcpChangeState(dhcp, STATE_SELECT_AUTOADDR);
        } else {
            //
            // Send out another DHCPDISCOVER packet
            //
            VERBOSE_("Retransmit DHCPDISCOVER");
            DhcpSendDiscover(dhcp);
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
        //
        // We're sending DHCPREQUEST
        //
        if (dhcp->retries >= cfgDhcpRetryCount) {
            //
            // Too many retries, go back to INIT state
            //
            VERBOSE_(dhcp->state == STATE_INIT_REBOOT ?
                        "Failed to reuse a prior lease" :
                        "No ack for an offered address");

            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            //
            // Send out another DHCPREQUEST packet
            //
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;
    
    case STATE_DECLINING:
        //
        // We just finished waiting after sending DHCPDECLINE
        //
        DhcpChangeState(dhcp, STATE_INIT);
        break;
    
    case STATE_BOUND:
        //
        // T1 expired, start the renewing process
        //
        VERBOSE_("Switching to RENEWING state");
        DhcpChangeState(dhcp, STATE_RENEWING);
        break;

    case STATE_RENEWING:
        //
        // We're trying to renew a valid address.
        // If T2 expired, start the rebinding process.
        //
        if (DhcpTime() >= dhcp->t2time) {
            VERBOSE_("Switching to REBINDING state");
            DhcpChangeState(dhcp, STATE_REBINDING);
        } else {
            // Send out another DHCPREQUEST
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;

    case STATE_REBINDING:
        //
        // We're trying to rebind a valid lease
        //  did our lease expire?
        //
        if (DhcpTime() >= dhcp->exptime) {
            // Inform IP stack to discard the active address
            VERBOSE_("Address lease expired - start over");
            DhcpResetInterface(dhcp);

            // Too bad, go back to INIT state
            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            // Send out another DHCPREQUEST
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;

    case STATE_SELECT_AUTOADDR:
        if (++dhcp->retries >= cfgConflictCheckRetries) {
            // We've successfully picked an autonet address.
            VERBOSE_("Selected autonet address: %s", IPADDRSTR(dhcp->autonetaddr));

            dhcp->activeaddr = dhcp->autonetaddr;
            dhcp->activemask = HTONL(AUTONET_ADDRMASK);
            dhcp->flags |= FLAG_ACTIVE_AUTONETADDR;
            IfSetIpAddr(dhcp->ifp, dhcp->activeaddr, dhcp->activemask);
            DhcpSignalAddrEvent(dhcp);

            // Switch to INIT state to continue looking
            // for a DHCP server
            dhcp->initRetryCount = 0;
            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            // No response to our previous ARP request.
            // Try again just to be sure.
            DhcpCheckAddressConflict(dhcp->ifp, dhcp->autonetaddr);
            DhcpComputeTimeout(dhcp);
        }
        break;

    default:
        VERBOSE_("Unexpected timeout");
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpChangeState(
    DhcpInfo* dhcp,
    INT state
    )

/*++

Routine Description:

    Change the state of an interface

Arguments:

    dhcp - Points to the DHCP structure
    state - Specifies the new state for the interface

Return Value:

    NONE

--*/

{
    INT oldstate = dhcp->state;

    dhcp->state = state;
    dhcp->retries = 0;

    // Assign a new transaction ID for the next outgoing message.

    if (DhcpGlobalXid == 0) DhcpGlobalXid = XnetRand();
    dhcp->xid = DhcpGlobalXid++;

    switch (state) {
    case STATE_STATIC_ADDR:
        // Should we send DHCPINFORM?
        if (dhcp->flags & FLAG_SEND_DHCPINFORM) {
            DhcpSendInform(dhcp);
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Send out DHCPREQUEST
        DhcpSendRequest(dhcp);
        break;

    case STATE_INIT:
        if (oldstate == STATE_SELECT_AUTOADDR) {
            // We just selected an autonet address.
            // Continue to look for a DHCP server.
            DhcpComputeTimeout(dhcp);
        } else if (++dhcp->initRetryCount > cfgDhcpRetryCount) {
            // We went through the INIT state too many times
            // without getting a valid address lease. Just give up.
            // We don't try Autonet because in this case there
            // is a DHCP server but somehow we can't work with it.
            WARNING_("Couldn't get a valid DHCP address after many tries");
            DhcpChangeState(dhcp, STATE_NONE);

            // Signal that Xnet initialization was completed abnormally
            DhcpSignalAddrEvent(dhcp);
        } else {
            // Send out DHCPDISCOVER
            DhcpSendDiscover(dhcp);
        }
        break;

    case STATE_BOUND:
        DhcpComputeTimeout(dhcp);
        VERBOSE_("Sleep %d seconds till renewal...", dhcp->t1time - DhcpTime());
        break;

    case STATE_SELECT_AUTOADDR:
        dhcp->initRetryCount = 0;
        DhcpSelectAutonetAddr(dhcp);
        break;

    case STATE_NONE:
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpResetInterface(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Reset an interface to have no address

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    IfSetIpAddr(dhcp->ifp, 0, 0);
    dhcp->flags &= ~FLAG_ACTIVE_ADDRMASK;
    if (dhcp->state != STATE_STATIC_ADDR)
        dhcp->activeaddr = 0;

    // Since we don't have an active address anymore,
    // we need to notify the DNS module of the change.
    DnsNotifyDefaultServers(dhcp->ifp);
}


PRIVATE NTSTATUS
DhcpSendMessage(
    DhcpInfo* dhcp,
    Packet* pkt,
    BOOL broadcast
    )

/*++

Routine Description:

    Send out a DHCP message on the specified interface

Arguments:

    dhcp - Points to the DHCP structure
    pkt - Points to the message to be sent
        !!! we assume the message buffer is at least 300 bytes
        and unused bytes are zero-filled.
    broadcast - Whether to use broadcast or unicast

Return Value:

    Status code

--*/

{
    IpAddrPair addrpair;
    DhcpMessage* msg;
    UINT msglen;

    addrpair.dstaddr = broadcast ? IPADDR_BCAST : dhcp->dhcpServer;
    addrpair.srcaddr = dhcp->activeaddr;
    addrpair.dstport = DHCP_SERVER_PORT;
    addrpair.srcport = DHCP_CLIENT_PORT;

    msg = GETPKTDATA(pkt, DhcpMessage);
    msglen = pkt->datalen;

    // Debug trace
    DhcpDumpMessage(msg, msglen);

    // Set broadcast flag if necessary
    if (!dhcp->activeaddr || ActiveAutonetAddr(dhcp))
        msg->flags |= HTONS(DHCP_BROADCAST);

    // Call UDP directly to send out the packet
    UdpSendPacketInternal(pkt, &addrpair, dhcp->ifp);

    // Calculate the timeout value
    dhcp->retries++;
    DhcpComputeTimeout(dhcp);

    return NETERR_OK;
}


//
// Append the 'parameter request list' option
//  !!! we assume the data buffer is large enough.
//
PRIVATE BYTE*
DhcpAppendParamReqList(
    BYTE* option
    )
{
    //
    // our default list of option parameters
    //
    static const BYTE defaultParamReqList[] = {
        DHCPOPT_SUBNET_MASK,
        DHCPOPT_ROUTERS,
        DHCPOPT_DNS_SERVERS,
        DHCPOPT_DOMAIN_NAME
    };

    UINT count = sizeof(defaultParamReqList);

    option[0] = DHCPOPT_PARAM_REQUEST_LIST;
    option[1] = (BYTE) count;
    option += 2;

    CopyMem(option, defaultParamReqList, count);
    return option + count;
}

//
// Append an option whose value is a DWORD
//
PRIVATE BYTE*
DhcpAppendDWordOption(
    BYTE* option,
    INT tag,
    DWORD val
    )
{
    option[0] = (BYTE) tag;
    option[1] = sizeof(DWORD);
    option += 2;

    CopyMem(option, &val, sizeof(DWORD));
    return option + sizeof(DWORD);
}


//
// Append the 'address lease time' option
//
PRIVATE BYTE*
DhcpAppendLeaseTimeOption(
    BYTE* option
    )
{
    if (cfgDefaultLeaseTime == 0) return option;

    return DhcpAppendDWordOption(   
                option,
                DHCPOPT_IPADDR_LEASE_TIME,
                HTONL(cfgDefaultLeaseTime));
}


PRIVATE BYTE*
DhcpFillMessageHeader(
    DhcpInfo* dhcp,
    BYTE* buf,
    INT msgtype
    )

/*++

Routine Description:

    Fill in the common header information for
    all outgoing DHCP messages

Arguments:

    dhcp - Points to the DHCP structure
    buf - Points to the message buffer
        !!! must be at least DEFAULT_DHCP_BUFSIZE bytes
    msgtype - DHCP message type

Return Value:

    Points to the first byte after the common options:
        magic cookie
        DHCP message type
        client identifier

--*/

{
    DhcpMessage* msg = (DhcpMessage*) buf;
    BYTE* option = msg->options;
    IfInfo* ifp = dhcp->ifp;
    BYTE hwtype;

    ZeroMem(buf, DEFAULT_DHCP_BUFSIZE);
    msg->op = BOOTREQUEST;
    msg->htype = hwtype = DhcpMapHwtype(ifp->iftype);
    msg->hlen = (BYTE) ifp->hwaddrlen;
    CopyMem(msg->chaddr, ifp->hwaddr, ifp->hwaddrlen);

    //
    // Fill in the transaction ID field
    // NOTE: We reuse the same XID for retransmissions.
    //
    msg->xid = HTONL(dhcp->xid);

    // Number of seconds since we started the address
    // acquisition process.
    msg->secs = (WORD) HTONS(dhcp->secsSinceStart);

    // Start with the magic cookie
    CopyMem(option, DhcpMagicCookie, DHCPCOOKIELEN);
    option += DHCPCOOKIELEN;

    // Append the message type option
    option[0] = DHCPOPT_DHCP_MESSAGE_TYPE;
    option[1] = 1;
    option[2] = (BYTE) msgtype;
    option += 3;

    // Append the client identifier option
    option[0] = DHCPOPT_CLIENTID;
    option[1] = (BYTE) (ifp->hwaddrlen+1);
    option[2] = hwtype;
    option += 3;
    CopyMem(option, ifp->hwaddr, ifp->hwaddrlen);
    option += ifp->hwaddrlen;

    return option;
}


PRIVATE VOID
DhcpComputeSecsSinceStart(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Compute the number of seconds since the current
    address acqusition process started.

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    DHCPTIME now = DhcpTime();

    if (dhcp->retries == 0) dhcp->acqtime = now;
    dhcp->secsSinceStart = now - dhcp->acqtime;
}


//
// Common prolog and epilog for SendDhcpXXX functions
//
#define SEND_DHCP_MESSAGE_PROLOG() \
        DhcpMessage* msg; \
        BYTE* buf; \
        BYTE* option; \
        Packet* pkt = XnetAllocIpPacket(UDPHDRLEN, DEFAULT_DHCP_BUFSIZE); \
        if (!pkt) return NETERR_MEMORY; \
        buf = pkt->data; \
        msg = (DhcpMessage*) buf

#define SEND_DHCP_MESSAGE_RETURN(_bcast) \
        pkt->datalen = option - buf; \
        return DhcpSendMessage(dhcp, pkt, _bcast)


PRIVATE NTSTATUS
DhcpSendDiscover(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Broadcast a DHCPDISCOVER message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_INIT);

    DhcpComputeSecsSinceStart(dhcp);

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPDISCOVER);

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in requested ip address and lease time option
    if (dhcp->dhcpaddr)
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, dhcp->dhcpaddr);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


PRIVATE NTSTATUS
DhcpSendRequest(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Send (broadcast/unicast) a DHCPREQUEST message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    INT state = dhcp->state;
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(state == STATE_REQUESTING ||
           state == STATE_RENEWING ||
           state == STATE_REBINDING ||
           state == STATE_INIT_REBOOT);

    //
    // If we're in REQUESTING state, then don't update
    // the secsSinceStart field. This is so that the
    // secs in DHCPREQUEST message will be the same as
    // what's in the original DHCPDISCOVER message.
    //
    if (state != STATE_REQUESTING) {
        DhcpComputeSecsSinceStart(dhcp);
    }

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPREQUEST);

    // Fill in the ciaddr field and the 'requested ip addr' option
    if (state == STATE_RENEWING || state == STATE_REBINDING) {
        msg->ciaddr = dhcp->dhcpaddr;
    } else if (dhcp->dhcpaddr) {
        // state == STATE_INIT_REBOOT || state == STATE_REQUESTING
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, dhcp->dhcpaddr);
    }

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);

    // Fill in the server identifier option
    if (state == STATE_REQUESTING)
        option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcp->dhcpServer);

    *option++ = DHCPOPT_END;

    // Emit the message:
    //  unicast in RENEWING state, broadcast otherwise
    SEND_DHCP_MESSAGE_RETURN(state != STATE_RENEWING);
}


PRIVATE NTSTATUS
DhcpSendInform(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Broadcast a DHCPINFORM message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_STATIC_ADDR);

    DhcpComputeSecsSinceStart(dhcp);

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPINFORM);

    // Fill in ciaddr field
    msg->ciaddr = dhcp->activeaddr;

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


#ifdef _ENABLE_SEND_DECLINE

PRIVATE NTSTATUS
DhcpSendDecline(
    DhcpInfo* dhcp,
    IPADDR dhcpServer,
    IPADDR ipaddr
    )

/*++

Routine Description:

    Broadcast a DHCPDECLINE message

Arguments:

    dhcp - Points to the DHCP structure
    dhcpServer - The server that offered the IP address
    ipaddr - The IP address to decline

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING);

    DhcpChangeState(dhcp, STATE_DECLINING);
    dhcp->secsSinceStart = 0;

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPDECLINE);

    // Fill in 'requested ip addr' and 'server identifier' options
    option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, ipaddr);
    option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcpServer);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}

#endif // _ENABLE_SEND_DECLINE


PRIVATE NTSTATUS
DhcpSendRelease(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Unicast a DHCPRELEASE message to the server

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_BOUND ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    DhcpChangeState(dhcp, STATE_NONE);
    dhcp->secsSinceStart = 0;

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPRELEASE);

    // Fill in 'server identifier' option
    option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcp->dhcpServer);
    *option++ = DHCPOPT_END;

    // Fill in ciaddr field
    msg->ciaddr = dhcp->dhcpaddr;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(FALSE);
}


PRIVATE BOOL
DhcpValidateOffer(
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Perform simple sanity check of offered DHCP parameters

Arguments:

    yiaddr - Offered IP address
    param - Other offered parameters

Return Value:

    TRUE if ok, FALSE otherwise

--*/

{
    if (!XnetIsValidUnicastAddr(yiaddr) ||
        !XnetIsValidUnicastAddr(param->dhcpServer) ||
        param->exptime < 8*cfgMinRenewTimeout)
        return FALSE;

    if (param->dhcpmask == 0)
        param->dhcpmask = XnetGetDefaultSubnetMask(yiaddr);

    if (param->t1time == 0 ||
        param->t2time == 0 ||
        param->t1time >= param->t2time ||
        param->t2time - param->t1time < cfgMinRenewTimeout ||
        param->t2time >= param->exptime ||
        param->exptime - param->t2time < cfgMinRenewTimeout) {
        param->t1time = param->exptime / 2;
        param->t2time = param->exptime * 7 / 8;
    }

    return TRUE;
}


PRIVATE NTSTATUS
DhcpProcessOffer(
    DhcpInfo* dhcp,
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Process a received DHCPOFFER packet

Arguments:

    dhcp - Points to the DHCP structure
    yiaddr - Offered address
    param - Option parameters

Return Value:

    Status code

--*/

{
    ASSERT(dhcp->state == STATE_INIT);

    VERBOSE_("Received DHCPOFFER %s", IPADDRSTR(yiaddr));
    VERBOSE_(" from %s", IPADDRSTR(param->dhcpServer));
    VERBOSE_(" @ time %d", DhcpTime());

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    dhcp->dhcpServer = param->dhcpServer;
    dhcp->dhcpaddr = yiaddr;

    // Send DHCPREQUEST and ignore error
    DhcpChangeState(dhcp, STATE_REQUESTING);
    return NETERR_OK;
}


PRIVATE VOID
DhcpAddOrRemoveGateways(
    DhcpInfo* dhcp,
    BOOL doDelete
    )

/*++

Routine Description:

    Set or delete default gateways

Arguments:

    dhcp - Points to the DHCP structure
    doDelete - Whether to set or delete gateways

Return Value:

    NONE

--*/

#define DEFAULT_METRIC 1

{
    UINT i;
    IPADDR addr;

    if (doDelete) {
        for (i=0; i < dhcp->gatewayCount; i++) {
            addr = dhcp->gateways[i];
            TRACE_("Remove gateway: %s", IPADDRSTR(addr));
            IpRemoveDefaultGateway(addr);
        }
    } else {
        for (i=0; i < dhcp->gatewayCount; i++) {
            addr = dhcp->gateways[i];
            TRACE_("Add gateway: %s", IPADDRSTR(addr));
            IpAddDefaultGateway(addr, DEFAULT_METRIC+i, dhcp->ifp);
        }
    }
}


VOID
DhcpSetDefaultGateways(
    IfInfo* ifp
    )
{
    KIRQL irql = RaiseToDpc();
    DhcpInfo* dhcp = ifp->dhcpInfo;

    if (dhcp) {
        DhcpAddOrRemoveGateways(dhcp, FALSE);
    }

    LowerFromDpc(irql);
}


PRIVATE VOID
DhcpUseOptionParams(
    DhcpInfo* dhcp,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Make use of the option parameters received from the server

Arguments:

    dhcp - Points to the DHCP structure
    param - Optional parameter values

Return Value:

    Status code

--*/

{
    BOOL resetGateways;

    //
    // Remember the originating server address and lease info
    //
    dhcp->dhcpServer = param->dhcpServer;

    if (param->exptime == DHCPTIME_INFINITE) {
        dhcp->t1time =
        dhcp->t2time =
        dhcp->exptime = DHCPTIME_INFINITE;
    } else {
        dhcp->t1time = dhcp->acqtime + param->t1time;
        dhcp->t2time = dhcp->acqtime + param->t2time;
        dhcp->exptime = dhcp->acqtime + param->exptime;
    }

    //
    // Set gateways in the IP stack
    //
    if (param->gatewayCount == 0 || dhcp->gatewayCount == 0) {
        resetGateways = TRUE;
    } else {
        UINT oldcnt = dhcp->gatewayCount;
        UINT newcnt = param->gatewayCount;
        UINT i, j;

        for (i=0; i < newcnt; i++) {
            for (j=0; j < oldcnt; j++)
                if (param->gateways[i] != dhcp->gateways[j]) break;
            if (j < oldcnt) break;
        }
        resetGateways = (i < newcnt);
    }

    if (resetGateways) {
        //
        // Reset gateways if anything has changed
        //  first delete existing gateways
        //  then set new gateways
        //
        // NOTE: should we ping the new gateways here?
        //
        DhcpAddOrRemoveGateways(dhcp, TRUE);

        dhcp->gatewayCount = param->gatewayCount;
        CopyMem(dhcp->gateways,
                param->gateways,
                param->gatewayCount * sizeof(IPADDR));

        DhcpAddOrRemoveGateways(dhcp, FALSE);
    }

    dhcp->dnsServerCount = param->dnsServerCount;
    CopyMem(dhcp->dnsServers,
            param->dnsServers,
            param->dnsServerCount * sizeof(IPADDR));

    strcpy(dhcp->domainName, param->domainName);
}


PRIVATE NTSTATUS
DhcpProcessAck(
    DhcpInfo* dhcp,
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Process a received DHCPACK packet

Arguments:

    dhcp - Points to the DHCP structure
    yiaddr - Offered address
    param - Option parameters

Return Value:

    Status code

--*/

{
    VERBOSE_("Received DHCPACK %s", IPADDRSTR(yiaddr));
    VERBOSE_("  from %s", IPADDRSTR(param->dhcpServer));

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    // Note: We're not checking for address conflicts
    // and just assume the offered address is valid.

    // If we're currently using a different address, give it up
    if ((dhcp->activeaddr != 0) &&
        (dhcp->activeaddr != yiaddr ||
         dhcp->activemask != param->dhcpmask) ||
         ActiveAutonetAddr(dhcp))
    {
        VERBOSE_("Giving up old IP address %s", IPADDRSTR(dhcp->activeaddr));
        DhcpResetInterface(dhcp);
    }

    // If we got a new address, set it down in the IP stack
    if (dhcp->activeaddr == 0) {
        IfSetIpAddr(dhcp->ifp, yiaddr, param->dhcpmask);
        DhcpSignalAddrEvent(dhcp);
        dhcp->activeaddr = dhcp->dhcpaddr = yiaddr;
        dhcp->activemask = dhcp->dhcpmask = param->dhcpmask;
        dhcp->flags |= FLAG_ACTIVE_DHCPADDR;
    }

    VERBOSE_("Accepted IP address: %s", IPADDRSTR(yiaddr));
    VERBOSE_("Lease time: %d / %d / %d", param->t1time, param->t2time, param->exptime);

    //
    // Set other option parameters
    //
    dhcp->initRetryCount = 0;
    DhcpUseOptionParams(dhcp, param);

    // We're now in bound state.
    // Set timer to expire at T1 time.
    DhcpChangeState(dhcp, STATE_BOUND);
    return NETERR_OK;
}


PRIVATE NTSTATUS
DhcpProcessNak(
    DhcpInfo* dhcp,
    IPADDR dhcpServer
    )

/*++

Routine Description:

    Process a received DHCPNAK packet

Arguments:

    dhcp - Points to the DHCP structure
    dhcpServer - The originating server address

Return Value:

    Status code

--*/

{
    VERBOSE_("Received DHCPNAK from %s", IPADDRSTR(dhcpServer));

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    // Barf if we got DHCPNAK from an unexpected server
    if (dhcp->state != STATE_INIT_REBOOT && dhcpServer != dhcp->dhcpServer) {
        WARNING_("Random DHCPNAK from %s?", IPADDRSTR(dhcpServer));
    }

    // If we're using an address, give it up
    if (dhcp->activeaddr) {
        DhcpResetInterface(dhcp);
    }

    //
    // Go to INIT state to start over again
    // Send DHCPDISCOVER and ignore error
    //
    DhcpChangeState(dhcp, STATE_INIT);
    return NETERR_OK;
}


PRIVATE NTSTATUS
DhcpParseOptionParams(
    DhcpOptionParam* param,
    const BYTE* buf,
    UINT buflen,
    BYTE* overload
    )

/*++

Routine Description:

    Parse option parameters in a received DHCP packet

Arguments:

    param - Where to store the resulting information
    buf - Points to the option data buffer
    buflen - Buffer length
    overload - Returns the overload option value

Return Value:

    Status code

--*/

// NOTE: we're assuming little-endian machine here.
#define EXTRACT_DWORD_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) { \
            _result = (((DWORD) buf[0] << 24) | \
                       ((DWORD) buf[1] << 16) | \
                       ((DWORD) buf[2] <<  8) | \
                       ((DWORD) buf[3]      )); \
        }

#define EXTRACT_IPADDR_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) _result = *((IPADDR*) buf)

{
    while (buflen) {
        UINT tag, len;

        // Stop after seeing the 'end' option
        if ((tag = buf[0]) == DHCPOPT_END) break;

        // Skip the 'pad' option
        if (tag == DHCPOPT_PAD) {
            buf++; buflen--;
            continue;
        }

        // Is the option length field valid?
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto exit;
        buf += 2; buflen -= 2;
    
        // Interpret option data
        switch (tag) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto exit;
            if (param->recvMsgType == 0)
                param->recvMsgType = *buf;
            break;

        case DHCPOPT_SERVERID:
            EXTRACT_IPADDR_OPTION(param->dhcpServer);
            break;

        case DHCPOPT_SUBNET_MASK:
            EXTRACT_IPADDR_OPTION(param->dhcpmask);
            break;

        case DHCPOPT_ROUTERS:
        case DHCPOPT_DNS_SERVERS: {
            UINT* pcount;
            IPADDR* parray;
            UINT n;

            if (len == 0 || len % sizeof(IPADDR) != 0) goto exit;
            if (tag == DHCPOPT_ROUTERS) {
                pcount = &param->gatewayCount;
                parray = param->gateways;
                n = MAX_DEFAULT_GATEWAYS * sizeof(IPADDR);
            } else {
                pcount = &param->dnsServerCount;
                parray = param->dnsServers;
                n = MAX_DEFAULT_DNSSERVERS * sizeof(IPADDR);
            }
        
            if (n > len) n = len;
            if (*pcount == 0) {
                *pcount = n / sizeof(IPADDR);
                CopyMem(parray, buf, n);
            }
            }
            break;

        case DHCPOPT_DOMAIN_NAME:
            if (len < 1 || len >= sizeof(param->domainName)) goto exit;
            if (param->domainName[0] == 0) {
                CopyMem(param->domainName, buf, len);
                param->domainName[len] = 0;
            }
            break;

        case DHCPOPT_IPADDR_LEASE_TIME:
            EXTRACT_DWORD_OPTION(param->exptime);
            break;

        case DHCPOPT_T1_INTERVAL:
            EXTRACT_DWORD_OPTION(param->t1time);
            break;

        case DHCPOPT_T2_INTERVAL:
            EXTRACT_DWORD_OPTION(param->t2time);
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto exit;
            if (overload && *overload == 0) *overload = *buf;
            break;
        }

        buf += len; buflen -= len;
    }

    return NETERR_OK;

exit:
    WARNING_("Invalid option data");
    return NETERR_PARAM;
}


PRIVATE VOID
DhcpSelectAutonetAddr(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Attempt to select an autonet address

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    IPADDR addr;

    ASSERT(dhcp->state == STATE_SELECT_AUTOADDR);

    if (++dhcp->initRetryCount > cfgAutonetAddrRetries) {
        //
        // We tried too many autonet addresses without success.
        // Just give up.
        //
        dhcp->initRetryCount = 0;
        DhcpChangeState(dhcp, STATE_NONE);

        // Signal that Xnet initialization was completed abnormally
        WARNING_("Failed to pick an autonet address.");
        DhcpSignalAddrEvent(dhcp);
        return;
    }

    // Generate a random autonet address
    addr = AUTONET_ADDRBASE + XnetRandScaled(AUTONET_ADDRRANGE);
    dhcp->autonetaddr = addr = HTONL(addr);

    VERBOSE_("Trying autonet address: %s", IPADDRSTR(addr));

    if (dhcp->ifp->flags & IFFLAG_CONNECTED_BOOT) {
        DhcpCheckAddressConflict(dhcp->ifp, addr);
        dhcp->retries = 0;
        DhcpComputeTimeout(dhcp);
    } else {
        //
        // NOTE: if net cable isn't connected at boot time,
        // there is no point trying to check for address conflicts.
        //
        dhcp->retries = cfgConflictCheckRetries;
        DhcpHandleTimeout(dhcp);
    }
}


NTSTATUS
DhcpGetDefaultDnsServers(
    IfInfo* ifp,
    CHAR* domainName,
    UINT namelen,
    IPADDR* serverAddrs,
    UINT* serverCnt
    )

/*++

Routine Description:

    Get the default DNS server information
    associated with the specified interface

Arguments:

    ifp - Points to an interface structure
    domainName - Buffer for receiving the default domain name
    namelen - Size of the domain name buffer
    serverAddrs - Buffer for receiving the default server addresses
    serverCnt - Number of default servers
        On entry, it specifies the size of the server address buffer
        On return, it contains the actual number of default servers

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    UINT count;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return NETERR_PARAM;

    //
    // Return the default domain name
    //
    count = dhcp->domainName ? strlen(dhcp->domainName) : 0;
    if (namelen <= count) return NETERR_MEMORY;
    if (count) {
        CopyMem(domainName, dhcp->domainName, count);
    }
    domainName[count] = 0;

    //
    // Return the default DNS server addresses
    //
    if (dhcp->dnsServerCount) {
        count = min(*serverCnt, dhcp->dnsServerCount);
        *serverCnt = count;
        CopyMem(serverAddrs, dhcp->dnsServers, count*sizeof(IPADDR));
    } else {
        *serverCnt = 0;
    }

    return NETERR_OK;
}


PRIVATE IPADDR
DhcpReadConfigIpAddr(
    ULONG index
    )

/*++

Routine Description:

    Wrapper function to read an IP address value
    from the xbox configuration sector

Arguments:

    index - Specifies the address of interest

Return Value:

    IP address value, 0 if there is an error

--*/

{
    ULONG type, size, addr;
    INT err = XQueryValue(index, &type, (VOID*) &addr, IPADDRLEN, &size);

    // If the query call failed, return 0 address.
    if (err != NO_ERROR || type != REG_DWORD || size != IPADDRLEN) {
        VERBOSE_("XQueryValue(%d) failed: %d, %d, %d", index, err, type, size);
        return 0;
    }

    return addr;
}


PRIVATE VOID
DhcpLoadConfigInfo(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Load persistent DHCP configuration parameters

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    //
    // Read the static IP address value.
    // Return right away if none is set.
    //
    dhcp->activeaddr = DhcpReadConfigIpAddr(XC_ONLINE_IP_ADDRESS);
    if (dhcp->activeaddr == 0) return;

    //
    // Read the subnet mask value.
    // If none is set, generate a default mask.
    //
    dhcp->activemask = DhcpReadConfigIpAddr(XC_ONLINE_SUBNET_ADDRESS);
    if (dhcp->activemask == 0) {
        dhcp->activemask = XnetGetDefaultSubnetMask(dhcp->activeaddr);
    }

    //
    // Read the default gateway address.
    //
    dhcp->gateways[0] = DhcpReadConfigIpAddr(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS);
    if (dhcp->gateways[0] != 0)
        dhcp->gatewayCount = 1;
}


DWORD
DhcpGetActiveAddressType(
    IfInfo* ifp
    )

/*++

Routine Description:

    Determine how we obtained our currently active IP address

Arguments:

    ifp - Points to the interface structure

Return Value:

    Flags (see winsockx.h)

--*/

{
    DhcpInfo* dhcp;
    DWORD flags = 0;

    RUNS_AT_DISPATCH_LEVEL

    if ((dhcp = ifp->dhcpInfo) != NULL) {
        if (ActiveDhcpAddr(dhcp)) {
            flags = XNET_ADDR_DHCP;
        } else if (ActiveAutonetAddr(dhcp)) {
            flags = XNET_ADDR_AUTOIP;
        } else if (dhcp->state == STATE_STATIC_ADDR) {
            flags = XNET_ADDR_STATIC;
        }

        if (dhcp->gatewayCount)
            flags |= XNET_HAS_GATEWAY;
    }

    return flags;
}


NTSTATUS
DhcpWaitForAddress(
    IfInfo* ifp
    )

/*++

Routine Description:

    Wait for address acquisition process to complete

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    NTSTATUS status;

    if (dhcp) {
        status = WaitKernelEventObject(&dhcp->addrEvent, 0);

        // Check if the acquisition process failed
        if (status == NETERR_OK && dhcp->state == STATE_NONE)
            status = NETERR_NETDOWN;
    } else
        status = NETERR(WSASYSNOTREADY);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dhcp\dhcplib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    DHCP client implementation for XBox

Revision History:

    04/21/2000 davidx
        Created it.

--*/

#ifndef _DHCPLIB_H
#define _DHCPLIB_H

//
// Information we extract from DHCP options
//
typedef struct _DhcpOptionParam {
    INT recvMsgType;        // type message received
    IPADDR dhcpmask;        // subnet mask
    IPADDR dhcpServer;      // dhcp server address
    DHCPTIME t1time;        // when to enter renewing state
    DHCPTIME t2time;        // when to enter rebinding state
    DHCPTIME exptime;       // lease expiration time
    UINT gatewayCount;      // number of gateways
    IPADDR gateways[MAX_DEFAULT_GATEWAYS];
    UINT dnsServerCount;    // number of DNS servers
    IPADDR dnsServers[MAX_DEFAULT_DNSSERVERS];
    CHAR domainName[256];   // domain name
} DhcpOptionParam;


//
// Information we maintain for each interface
//
typedef struct _DhcpInfo {
    IfInfo* ifp;            // Pointer back to the interface
    KEVENT addrEvent;       // address acquisition event
    INT state;              // current state of the interface
    INT flags;              // misc. flags (see constants below)
    IPADDR activeaddr;      // active IP address and mask
    IPADDR activemask;      //
    IPADDR dhcpaddr;        // last DHCP address
    IPADDR autonetaddr;     // last autonet address
    DHCPTIME acqtime;       // when lease acquisition started
    DWORD xid;              // XID for the next outgoing message
    UINT retries;           // number of retries for the current message
    UINT initRetryCount;    // how many retries into INIT state
    UINT secsSinceStart;    // secs since the address-req process started
    UINT timer;             // timer (unit = second)
    union {                 // DHCP option paramters
        // We're using this odd-looking syntax construct so that
        // we can reference the fields in DhcpOptionParam directly.
        DhcpOptionParam;
        DhcpOptionParam optionParam;
    };
} DhcpInfo;


//
// States for an interface
//
enum {
    STATE_NONE,             // temporary wait state after startup
    STATE_STATIC_ADDR,      // statically assigned address
    STATE_INIT,             // sending discover
    STATE_REQUESTING,       // waiting for DHCPACK after selecting
    STATE_INIT_REBOOT,      // rebooting with valid lease
    STATE_BOUND,            // bound with valid address lease
    STATE_RENEWING,         // renewing after T1 expires
    STATE_REBINDING,        // rebinding after T2 expires
    STATE_DECLINING,        // temporary wait state after sending decline
    STATE_SELECT_AUTOADDR   // checking autonet address conflicts
};

//
// Constants for the DhcpInfo.flags field:
//
#define FLAG_RELEASE_ON_REBOOT  0x0001
#define FLAG_SEND_DHCPINFORM    0x0002
#define FLAG_CREATED_BY_DEBUGGER 0x0004

#define FLAG_ACTIVE_DHCPADDR    0x00010000
#define FLAG_ACTIVE_AUTONETADDR 0x00020000
#define FLAG_ACTIVE_ADDRMASK    (FLAG_ACTIVE_DHCPADDR | FLAG_ACTIVE_AUTONETADDR)

INLINE BOOL ActiveDhcpAddr(DhcpInfo* dhcp) {
    return (dhcp->flags & FLAG_ACTIVE_DHCPADDR);
}

INLINE BOOL ActiveAutonetAddr(DhcpInfo* dhcp) {
    return (dhcp->flags & FLAG_ACTIVE_AUTONETADDR);
}

//
// Dump DHCP message in the debugger
//

#if DBG
VOID DhcpDumpMessage(const DhcpMessage* msg, UINT msglen);
#else
#define DhcpDumpMessage(msg, msglen)
#endif

//
// Map interface hardware type to DHCP hardware type
//
INLINE BYTE DhcpMapHwtype(WORD iftype) {
    return (BYTE) ((iftype == IFTYPE_ETHERNET) ?
                    HWTYPE_10MB_ETHERNET :
                    HWTYPE_PPP);
}

//
// Check whether there is a conflict with an IP address
//
INLINE VOID DhcpCheckAddressConflict(IfInfo* ifp, IPADDR ipaddr) {
    ifp->Ioctl(ifp, IFCTL_CHECK_ADDR_CONFLICT, &ipaddr, sizeof(ipaddr), NULL, NULL);
}

//
// Signal address acquisition event
//
INLINE VOID DhcpSignalAddrEvent(DhcpInfo* dhcp) {
    KeSetEvent(&dhcp->addrEvent, IO_NO_INCREMENT, FALSE);
}

#endif // !_DHCPLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dhcp\precomp.h ===
#include "xnetp.h"
#include "xboxp.h"
#include "route.h"
#include "dhcp.h"
#include "dhcplib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dhcp\dhcpdump.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcpdump.c

Abstract:

    Dump DHCP message content to the debugger

Revision History:

    05/25/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Whether to dump incoming and outgoing DHCP messages
//
#if DBG

INT _dhcpDumpFlag = FALSE;

PRIVATE VOID
DhcpDumpByteArray(
    const BYTE* buf,
    UINT buflen
    )

/*++

Routine Description:

    Dump a byte array in hexdecimal format

Arguments:

    buf - Points to the data buffer
    buflen - Buffer length

Return Value:

    NONE

--*/

{
    for ( ; buflen--; buf++) {
        DbgPrint("%02x", *buf);
    }
}


PRIVATE VOID
DhcpDumpOption(
    IN const BYTE* buf,
    IN UINT buflen,
    OUT BYTE* overload
    )

/*++

Routine Description:

    Dump DHCP options

Arguments:

    buf - Points to the option data buffer
    buflen - Data buffer length
    overload - Returns the option overload flags

Return Value:

    NONE

--*/

{
    static PCSTR dhcpMessageTypeStrs[] = {
        "***",
        "DHCPDISCOVER",
        "DHCPOFFER",
        "DHCPREQUEST",
        "DHCPDECLINE",
        "DHCPACK",
        "DHCPNAK",
        "DHCPRELEASE",
        "DHCPINFORM"
    };

    UINT tag, len, val;

    while (buflen && *buf != DHCPOPT_END) {
        // Special case for DHCPOPT_PAD - single byte
        if (*buf == DHCPOPT_PAD) {
            DbgPrint("    PAD\n");
            buflen--, buf++;
            continue;
        }

        // Check option length
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto badopt;

        switch (tag = buf[0]) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto badopt;
            val = buf[2];
            if (val > 0 && val < ARRAYCOUNT(dhcpMessageTypeStrs)) {
                DbgPrint("    %s", dhcpMessageTypeStrs[val]);
            } else {
                DbgPrint("    Unknown DHCP message type: %d", val);
            }
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto badopt;
            DbgPrint("    OVERLOAD: %d", buf[2]);
            if (overload)
                *overload = buf[2];
            else
                DbgPrint(" !!!");
            break;

        case DHCPOPT_REQUESTED_IPADDR:
        case DHCPOPT_SERVERID:
            if (len != 4) goto badopt;
            DbgPrint("    %s %d.%d.%d.%d",
                (tag == DHCPOPT_SERVERID) ? "SERVERID" : "REQUEST IP ADDR",
                buf[2], buf[3], buf[4], buf[5]);
            break;

        default:
            DbgPrint("    %d - ", tag);
            DhcpDumpByteArray(buf+2, len);
            break;
        }

        DbgPrint("\n");
        buf += len+2;
        buflen -= len+2;
    }

    if (buflen == 0) {
        DbgPrint("!!! Missing 'end' option\n");
    } else {
        do {
            buflen--, buf++;
        } while (buflen && *buf == 0);

        if (buflen != 0)
            DbgPrint("!!! Extra data after 'end' option\n");
    }
    return;

badopt:
    DbgPrint("!!! Bad DHCP option data\n");
}


VOID
DhcpDumpMessage(
    const DhcpMessage* msg,
    UINT msglen
    )

/*++

Routine Description:

    Dump the content of a DHCP message

Arguments:

    msg - Points to the DHCP message
    msglen - Message length

Return Value:

    NONE

--*/

{
    const BYTE* option;
    BYTE overload = 0;

    if (!_dhcpDumpFlag) return;

    //
    // Sanity check
    //
    if (msglen < DHCPHDRLEN) {
        DbgPrint("!!! DHCP message too small: %d bytes\n", msglen);
        return;
    }

    //
    // Dump out fixed header information
    //
    DbgPrint("DHCP message: ");
    if (msg->op == BOOTREQUEST)
        DbgPrint("BOOTREQUEST\n");
    else if (msg->op == BOOTREPLY)
        DbgPrint("BOOTREPLY\n");
    else
        DbgPrint("%d\n", msg->op);

    DbgPrint("  htype: %d\n", msg->htype);
    if (msg->hlen > sizeof(msg->chaddr)) {
        DbgPrint("!!! Invalid hardware address length: %d\n", msg->hlen);
    } else if (msg->hlen) {
        DbgPrint("  chaddr: ");
        DhcpDumpByteArray(msg->chaddr, msg->hlen);
        DbgPrint("\n");
    }

    DbgPrint("  hops: %d\n", msg->hops);
    DbgPrint("  xid: 0x%08x\n", NTOHL(msg->xid));
    DbgPrint("  secs: %d\n", NTOHS(msg->secs));
    DbgPrint("  flags: 0x%04x\n", NTOHS(msg->flags));
    DbgPrint("  ciaddr: %s\n", IPADDRSTR(msg->ciaddr));
    DbgPrint("  yiaddr: %s\n", IPADDRSTR(msg->yiaddr));
    DbgPrint("  siaddr: %s\n", IPADDRSTR(msg->siaddr));
    DbgPrint("  giaddr: %s\n", IPADDRSTR(msg->giaddr));

    //
    // Dump options
    //
    option = msg->options;
    msglen -= DHCPHDRLEN;

    if (msglen < DHCPCOOKIELEN ||
        !EqualMem(option, DhcpMagicCookie, DHCPCOOKIELEN)) {
        DbgPrint("!!! Invalid DHCP magic cookie\n");
        return;
    }
    msglen -= DHCPCOOKIELEN;
    option += DHCPCOOKIELEN;

    DbgPrint("  options:\n");
    DhcpDumpOption(option, msglen, &overload);

    if (overload & 1) {
        DbgPrint("  overload options (file):\n");
        DhcpDumpOption(msg->file, sizeof(msg->file), NULL);
    }

    if (overload & 2) {
        DbgPrint("  overload options (sname):\n");
        DhcpDumpOption(msg->sname, sizeof(msg->sname), NULL);
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dhcp\dhcp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    DHCP and Autonet protocol related declarations

Revision History:

    04/21/2000 davidx
        Created it.

Notes:

    Please refer to RFC2131, RFC2132, and RFC951. Also, the internet draft
    http://search.ietf.org/internet-drafts/draft-ietf-dhc-ipv4-autoconfig-05.txt.

--*/

#ifndef _DHCP_H
#define _DHCP_H

//
// UDP port numbers used by DHCP
//
#define DHCP_SERVER_PORT HTONS(67)
#define DHCP_CLIENT_PORT HTONS(68)

//
// DHCP message format
// NOTE: default the options field to 64 bytes
// which is the size of BOOTP vendor-specified area
//

typedef struct _DhcpMessage {
    BYTE op;                // message type
    BYTE htype;             // hareware address type
    BYTE hlen;              // hardware address length
    BYTE hops;              // relay hops
    DWORD xid;              // transaction ID
    WORD secs;              // seconds since address acquisition process began
    WORD flags;             // flags
    IPADDR ciaddr;          // client IP address
    IPADDR yiaddr;          // "your" (client) IP address
    IPADDR siaddr;          // server IP address
    IPADDR giaddr;          // relay agent IP address
    BYTE chaddr[16];        // client hardware address
    BYTE sname[64];         // optional server hostname
    BYTE file[128];         // boot filename
    BYTE options[64];       // optional parameters (variable length)
} DhcpMessage;

//
// Our default DHCP packet buffer is 576 bytes
//
#define BOOTP_MESSAGE_SIZE sizeof(DhcpMessage)
#define DEFAULT_DHCP_BUFSIZE 576
#define DHCPHDRLEN offsetof(DhcpMessage, options)

//
// Minimum and maximum DHCP hardware address length
//
#define MIN_DHCP_HWADDRLEN 1
#define MAX_DHCP_HWADDRLEN 16

//
// BOOTP message type constants
//
#define BOOTREQUEST 1
#define BOOTREPLY   2

//
// Hardware type constants
//
#define HWTYPE_10MB_ETHERNET 1
#define HWTYPE_PPP           8

//
// Constants for DHCP_MESSAGE.flags
//
#define DHCP_BROADCAST 0x8000

//
// DHCP message type constants
//
#define DHCPDISCOVER    1
#define DHCPOFFER       2
#define DHCPREQUEST     3
#define DHCPDECLINE     4
#define DHCPACK         5
#define DHCPNAK         6
#define DHCPRELEASE     7
#define DHCPINFORM      8

//
// DHCP option tag constants
//

// Fixed-length options

#define DHCPOPT_PAD                     0
#define DHCPOPT_END                     255

// Standard options

#define DHCPOPT_SUBNET_MASK             1
#define DHCPOPT_TIME_OFFSET             2
#define DHCPOPT_ROUTERS                 3
#define DHCPOPT_TIME_SERVERS            4
#define DHCPOPT_IEN116_SERVERS          5
#define DHCPOPT_DNS_SERVERS             6
#define DHCPOPT_LOG_SERVERS             7
#define DHCPOPT_COOKIE_SERVERS          8
#define DHCPOPT_LPR_SERVERS             9
#define DHCPOPT_IMPRESS_SERVERS         10
#define DHCPOPT_RLP_SERVERS             11
#define DHCPOPT_HOST_NAME               12
#define DHCPOPT_BOOT_FILESIZE           13
#define DHCPOPT_DUMP_FILE               14
#define DHCPOPT_DOMAIN_NAME             15
#define DHCPOPT_SWAP_SERVER             16
#define DHCPOPT_ROOT_PATH               17
#define DHCPOPT_EXTENSIONS_PATH         18

// IP parameters (per host)

#define DHCPOPT_ENABLE_FORWARD          19
#define DHCPOPT_NONLOCAL_SRCROUTING     20
#define DHCPOPT_POLICY_FILTER           21
#define DHCPOPT_MAX_REASSEMBLY_SIZE     22
#define DHCPOPT_DEFAULT_IP_TTL          23
#define DHCPOPT_PMTU_AGING_TIMEOUT      24
#define DHCPOPT_PMTU_PLATEAU_TABLE      25

// IP parameters (per interface)

#define DHCPOPT_INTERFACE_MTU           26
#define DHCPOPT_ALL_SUBNETS_LOCAL       27
#define DHCPOPT_BROADCAST_ADDRESS       28
#define DHCPOPT_MASK_DISCOVERY          29
#define DHCPOPT_MASK_SUPPLIER           30
#define DHCPOPT_ROUTER_DISCOVERY        31
#define DHCPOPT_SOLICIT_ROUTER_ADDR     32
#define DHCPOPT_STATIC_ROUTES           33

// Link layer parameters

#define DHCPOPT_TRAILER_ENCAPS          34
#define DHCPOPT_ARP_CACHE_TIMEOUT       35
#define DHCPOPT_ETHERNET_ENCAPS         36

// TCP parameters

#define DHCPOPT_DEFAULT_TCP_TTL         37
#define DHCPOPT_KEEPALIVE_INTERVAL      38
#define DHCPOPT_KEEPALIVE_GARBAGE       39

// Application parameters

#define DHCPOPT_NIS_DOMAIN              40
#define DHCPOPT_NIS_SERVERS             41
#define DHCPOPT_NTP_SERVERS             42

// DHCP extensions

#define DHCPOPT_REQUESTED_IPADDR        50
#define DHCPOPT_IPADDR_LEASE_TIME       51
#define DHCPOPT_FIELD_OVERLOAD          52
#define DHCPOPT_TFTP_SERVER_NAME        66
#define DHCPOPT_BOOT_FILENAME           67
#define DHCPOPT_DHCP_MESSAGE_TYPE       53
#define DHCPOPT_SERVERID                54
#define DHCPOPT_PARAM_REQUEST_LIST      55
#define DHCPOPT_MESSAGE                 56
#define DHCPOPT_MAX_DHCP_MESSAGESIZE    57
#define DHCPOPT_T1_INTERVAL             58
#define DHCPOPT_T2_INTERVAL             59
#define DHCPOPT_VENDOR_CLASSID          60
#define DHCPOPT_CLIENTID                61

// Vendor-specific information

#define DHCPOPT_VENDOR_INFO             43
#define DHCPOPT_NETBIOS_NAMESERVERS     44
#define DHCPOPT_NETBIOS_DATASERVERS     45
#define DHCPOPT_NETBIOS_NODETYPE        46
#define DHCPOPT_NETBIOS_SCOPE           47
#define DHCPOPT_X11_FONTSERVERS         48
#define DHCPOPT_X11_DISPLAYSERVERS      49
#define DHCPOPT_NIS2_DOMAIN             64
#define DHCPOPT_NIS2_SERVERS            65
#define DHCPOPT_MOBILEIP_HOME_AGENTS    68
#define DHCPOPT_SMTP_SERVERS            69
#define DHCPOPT_POP3_SERVERS            70
#define DHCPOPT_NNTP_SERVERS            71
#define DHCPOPT_WWW_SERVERS             72
#define DHCPOPT_FINGER_SERVERS          73
#define DHCPOPT_IRC_SERVERS             74
#define DHCPOPT_STREETTALK_SERVERS      75
#define DHCPOPT_STREETTALKDA_SERVERS    76

//
// DHCP magic cookie: 99, 130, 83, 99
//
#define DHCPCOOKIELEN 4
extern const BYTE DhcpMagicCookie[DHCPCOOKIELEN];

//
// DHCP time value (in seconds)
//
// NOTE: We use 32-bit unsigned interface to represent
// the number of seconds ellapsed since the start of 1/1/2000.
// This should last until year 2136 before overflowing.
//
typedef DWORD DHCPTIME;

#define DHCPTIME_INFINITE 0xffffffff

//
// Autonet address range: 169.254/16
//  don't use the first 256 and the last 256 addresses
//
#define AUTONET_ADDRMASK    0xffff0000
#define AUTONET_ADDRBASE    0xa9fe0100
#define AUTONET_ADDRRANGE   0x0000fcff

#endif // !_DHCP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dns\dns.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dns.c

Abstract:

    DNS client implementation

Revision History:

    07/12/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Access to global DNS client data is protected by a mutex
//
RTL_CRITICAL_SECTION DnsCritSect;

#define DnsLock()   RtlEnterCriticalSection(&DnsCritSect)
#define DnsUnlock() RtlLeaveCriticalSection(&DnsCritSect)

//
// Default suffixes we'll try to append to the user specified
// name when doing a DNS lookup.
// 
#define MAX_DEFAULT_SUFFIXES 2
DnsName* DnsDefaultSuffixes[MAX_DEFAULT_SUFFIXES];
UINT DnsDefaultSuffixCount;

const DnsName* DnsRootDomainName = "\1\0";

//
// Cached list of DNS servers
//
LIST_ENTRY DnsServerCache;
UINT DnsServerCacheSize;
UINT cfgMaxDnsServerCacheSize = 16;

// Loop through all entries of the DNS server cache

#define DnsServerCacheFirst() ((DnsServerCacheEntry*) DnsServerCache.Flink)
#define DnsServerCacheNull() ((DnsServerCacheEntry*) &DnsServerCache)
#define DnsServerCacheFlink(_dnssrv) ((DnsServerCacheEntry*) (_dnssrv)->links.Flink)

#define LOOP_THRU_DNSSERVER_CACHE(_dnssrv) { \
            DnsServerCacheEntry* _next; \
            _dnssrv = DnsServerCacheFirst(); \
            for (; _dnssrv != DnsServerCacheNull(); _dnssrv = _next) { \
                _next = DnsServerCacheFlink(_dnssrv);

#define END_DNSSERVER_CACHE_LOOP \
            } \
        }

//
// Cached result of DNS lookups
// NOTE: we're using a simple linked list structure here.
// If the number of cache entries gets big, we may need
// something more elaborated for better perf.
//
LIST_ENTRY DnsCache;
UINT DnsCacheSize;
UINT cfgMaxDnsCacheSize = 64;
UINT cfgMaxLookupRetries = 4;
UINT cfgMinLookupTimeout = 5;
UINT cfgMaxDnsCacheTtl = 2*60*60;

// Loop through all entries of the DNS lookup cache

#define DnsCacheFirst() ((DnsCacheEntry*) DnsCache.Flink)
#define DnsCacheNull() ((DnsCacheEntry*) &DnsCache)
#define DnsCacheFlink(_dnsent) ((DnsCacheEntry*) (_dnsent)->links.Flink)

#define LOOP_THRU_DNS_CACHE(_dnsent) { \
            DnsCacheEntry* _next; \
            _dnsent = DnsCacheFirst(); \
            for (; _dnsent != DnsCacheNull(); _dnsent = _next) { \
                _next = DnsCacheFlink(_dnsent);

#define END_DNS_CACHE_LOOP \
            } \
        }

//
// Pending request to set default DNS domain and servers
//
IfInfo* DnsSetDefaultIfp;

//
// Next DNS query message ID
//
WORD DnsQueryMsgId;

//
// Forward function declarations
//
PRIVATE NTSTATUS DnsLookupProc(DnsName*, IPADDR, DnsCacheEntry**);


NTSTATUS
DnsInitialize()

/*++

Routine Description:

    Initialize the DNS client module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    RtlInitializeCriticalSection(&DnsCritSect);

    ZeroMem(DnsDefaultSuffixes, sizeof(DnsDefaultSuffixes));
    DnsDefaultSuffixCount = 0;

    InitializeListHead(&DnsServerCache);
    InitializeListHead(&DnsCache);
    DnsServerCacheSize = DnsCacheSize = 0;

    DnsQueryMsgId = (WORD) XnetRand();
    return NETERR_OK;
}


//
// Clean up the default search suffixes
//
INLINE VOID DnsCleanupDefaultSuffixes() {
    while (DnsDefaultSuffixCount) {
        DnsDefaultSuffixCount--;
        FreeDnsName(DnsDefaultSuffixes[DnsDefaultSuffixCount]);
        DnsDefaultSuffixes[DnsDefaultSuffixCount] = NULL;
    }
}

//
// Remove an entry from the DNS lookup cache
//
INLINE VOID FreeDnsCacheEntry(DnsCacheEntry* dnsent) {
    UINT index;
    for (index=0; index < dnsent->namecnt; index++) {
        FreeDnsName(dnsent->names[index]);
    }
    SysFree(dnsent);
}

INLINE VOID RemoveDnsCacheEntry(DnsCacheEntry* dnsent) {
    RemoveEntryList(&dnsent->links);
    DnsCacheSize--;

    ASSERT(dnsent->refcount != 0);
    if (dnsent->refcount > 1) {
        dnsent->refcount--;
        if (dnsent->status == NETERR_PENDING) {
            dnsent->status = NETERR_NETDOWN;
            SetKernelEvent(&dnsent->event);
        }
    } else {
        FreeDnsCacheEntry(dnsent);
    }
}

INLINE VOID DnsCacheEntryRelease(DnsCacheEntry* dnsent) {
    if (InterlockedDecrement(&dnsent->refcount) == 0) {
        FreeDnsCacheEntry(dnsent);
    }
}


//
// Remove an entry from the DNS server cache
//
INLINE VOID RemoveDnsServerCacheEntry(DnsServerCacheEntry* dnssrv) {
    RemoveEntryList(&dnssrv->links);
    SysFree(dnssrv);
    DnsServerCacheSize--;
}


VOID
DnsCleanup()

/*++

Routine Description:

    Clean up all DNS client data

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    // If DnsInitialize hasn't been called, do nothing
    if (IsListNull(&DnsServerCache)) return;

    DnsLock();

    // Clean up the default search suffixes
    DnsCleanupDefaultSuffixes();

    // Clean up the cached DNS servers
    while (!IsListEmpty(&DnsServerCache)) {
        DnsServerCacheEntry* dnssrv = DnsServerCacheFirst();
        RemoveDnsServerCacheEntry(dnssrv);
    }

    // Clean up the cached DNS lookup results
    while (!IsListEmpty(&DnsCache)) {
        DnsCacheEntry* dnsent = DnsCacheFirst();
        RemoveDnsCacheEntry(dnsent);
    }

    DnsUnlock();

    RtlDeleteCriticalSection(&DnsCritSect);
    DnsSetDefaultIfp = NULL;
}


DnsName*
CreateDnsNameFromString(
    const CHAR* str
    )

/*++

Routine Description:

    Create a DNS name structure from a character string

Arguments:

    str - Points to the domain name character string 

Return Value:

    Pointer to the new DNS name structure
    NULL if there is an error

--*/

{
    DnsName* dnsname;
    BYTE* data;
    BYTE* p;
    BYTE* q;
    UINT labels = 0;
    UINT len = strlen(str);

    // Validate length
    if (len == 0 || len >= DNS_MAXNAMELEN-1) return NULL;

    dnsname = (DnsName*) SysAlloc(len+4, PTAG_DNS);
    if (!dnsname) return NULL;

    data = GetDnsNameData(dnsname);
    p = data+1;
    CopyMem(p, str, len+1);

    // parse the '.' separated labels
    do {
        for (q=p; *q && *q != '.'; q++)
            NULL;
        
        // zero-length label is an error unless it's at the end
        // (in that case, the extra . is ignored).

        if (q == p) {
            if (*q == 0 && labels > 0) {
                *--q = 0;
                break;
            }
            SysFree(dnsname);
            return NULL;
        }

        if (q-p > DNS_MAXLABELLEN) {
            SysFree(dnsname);
            return NULL;
        }
        p[-1] = (BYTE) (q-p);
        labels++;
        p = q+1;
    } while (*q);

    SetDnsNameLen(dnsname, q-data+1);
    SetDnsNameLabels(dnsname, labels);
    return dnsname;
}


PRIVATE DnsName*
CreateDnsNameFromLabels(
    const BYTE* data
    )

/*++

Routine Description:

    Create a DNS name structure from a sequence of labels

Arguments:

    data - Points to the label data

Return Value:

    Pointer to the newly created DNS name
    NULL if there is an error

Note:

    We assume the label data is already validated.

--*/

{
    UINT len = 1;
    UINT labels = 0;
    const BYTE* p = data;
    DnsName* dnsname;

    while (*p) {
        labels++;
        len += 1 + *p;
        p = SkipDnsNameLabel(p);
    }
    
    dnsname = (DnsName*) SysAlloc(len+2, PTAG_DNS);
    if (dnsname) {
        SetDnsNameLen(dnsname, len);
        SetDnsNameLabels(dnsname, labels);
        CopyMem(GetDnsNameData(dnsname), data, len);
    }

    return dnsname;
}


PRIVATE DnsName*
CreateDnsNameFromAddr(
    IPADDR addr
    )

/*++

Routine Description:

    Create a DNS name from an IP address:
        x.x.x.x.IN-ADDR.ARPA

Arguments:

    addr - Specifies the IP address

Return Value:

    Pointer to the newly created DNS name
    NULL if there is an error

--*/

{
    CHAR buf[32];

    // Reverse the byte order
    addr = HTONL(addr);
    IpAddrToString(addr, buf, sizeof(buf));
    strcat(buf, ".IN-ADDR.ARPA");

    return CreateDnsNameFromString(buf);
}


PRIVATE UINT
MatchDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Compare two DNS names and how closely they match

Arguments:

    name1, name2 - Specifies the two DNS names to be compared

Return Value:

    Number of labels that are common between the two DNS names

--*/

#define IsEqualDnsNameLabel(_p1, _p2) \
        (*(_p1) == *(_p2) && _strnicmp((_p1), (_p2), *(_p1)) == 0)

{
    UINT labels, l1, l2;
    const BYTE* data1;
    const BYTE* data2;

    l1 = GetDnsNameLabels(name1);
    l2 = GetDnsNameLabels(name2);
    labels = min(l1, l2);
    data1 = GetDnsNameData(name1);
    data2 = GetDnsNameData(name2);

    data1 = SkipDnsNameLabels(data1, l1-labels);
    data2 = SkipDnsNameLabels(data2, l2-labels);

    l1 = labels;
    while (labels--) {
        if (!IsEqualDnsNameLabel(data1, data2))
            l1 = labels;
        data1 = SkipDnsNameLabel(data1);
        data2 = SkipDnsNameLabel(data2);
    }

    return l1;
}


PRIVATE BOOL
IsEqualDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Check if two DNS names are the same (case insensitive)

Arguments:

    name1, name2 - Specifies the two DNS names to be compared

Return Value:

    TRUE if two names are the same, FALSE otherwise

--*/

{
    BYTE labels = GetDnsNameLabels(name1);
    const BYTE* data1;
    const BYTE* data2;

    // must have the same number of labels
    if (labels != GetDnsNameLabels(name2)) return FALSE;

    data1 = GetDnsNameData(name1);
    data2 = GetDnsNameData(name2);
    while (labels--) {
        // every label must be equal
        if (!IsEqualDnsNameLabel(data1, data2))
            return FALSE;
        data1 = SkipDnsNameLabel(data1);
        data2 = SkipDnsNameLabel(data2);
    }
    return TRUE;
}


PRIVATE VOID
DnsNameToString(
    const DnsName* dnsname,
    CHAR* buf,
    UINT buflen
    )

/*++

Routine Description:

    Convert a DNS name string to a null-terminated ASCII string

Arguments:

    dnsname - Points to the DNS name structure
    buf - Points to the buffer for storing the ASCII string
    buflen - Size of the buffer

Return Value:

    NONE

--*/

{
    const BYTE* data = GetDnsNameData(dnsname);
    UINT len;

    // If the output buffer is not big enough,
    // just return an empty string.
    if (buflen < GetDnsNameLen(dnsname) ||
        GetDnsNameLen(dnsname) <= 1) {
        *buf = 0;
        return;
    }

    while ((len = *data++) != 0) {
        CopyMem(buf, data, len);
        data += len;
        buf += len;
        *buf++ = '.';
    }

    buf[-1] = 0;
}


INLINE CHAR* DNSNAMESTR(const DnsName* dnsname) {
    static CHAR buf[256];
    DnsNameToString(dnsname, buf, sizeof(buf));
    return buf;
}

DnsName*
ConcatDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Concatenate two DNS names together to form a new name

Arguments:

    name1 - Specifies the name to put in the front
    name2 - Specifies the name to put at the end

Return Value:

    Points to the new concatenated name
    NULL if there is an error

--*/

{
    DnsName* dnsname;
    BYTE* data;
    UINT l1, l2, labels;

    l1 = GetDnsNameLen(name1);
    l2 = GetDnsNameLen(name2);
    labels = (UINT) GetDnsNameLabels(name1) +
             (UINT) GetDnsNameLabels(name2);

    // Make sure the resulting DNS is not too long
    if (l1+l2-1 > DNS_MAXNAMELEN)
        return NULL;

    dnsname = (DnsName*) SysAlloc(l1+l2+1, PTAG_DNS);
    if (dnsname) {
        data = GetDnsNameData(dnsname);
        CopyMem(data, GetDnsNameData(name1), l1);
        CopyMem(data+l1-1, GetDnsNameData(name2), l2);
        SetDnsNameLen(dnsname, l1+l2-1);
        SetDnsNameLabels(dnsname, labels);
    }

    return dnsname;
}


VOID
DnsNotifyDefaultServers(
    IfInfo* ifp
    )

/*++

Routine Description:

    This is called by the lower level modules to notify us
    that the default DNS server information has changed.

Arguments:

    ifp - Points to the interface in question

Return Value:

    NONE

Note:

    This function is called by the DHCP module
    (potentially at DISPATCH_LEVEL).

--*/

{
    // We don't immediately set the default servers.
    // Rather, we'll queue up a request which will be
    // executed upon the next lookup operation.
    //
    // If there is another pending request,
    // it'll be replaced by the new request.

    CACHE_IFP_REFERENCE(DnsSetDefaultIfp, ifp);
}


PRIVATE NTSTATUS
AddDnsServerCacheEntry(
    const DnsName* domain,
    IPADDR serverAddr,
    UINT expires,
    UINT priority
    )

/*++

Routine Description:

    Add an entry to the DNS server cache

Arguments:

    domain - Specifies the domain for which the server is responsible
    serverAddr - Specifies the server's IP address
    expires - When will this entry be no longer valid
    priority - The server precedence value (smaller is better)

Return Value:

    Status code

--*/

{
    DnsServerCacheEntry* newsrv;
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* oldie;
    UINT len;

    TRACE_("Adding DNS server: %s %s %d",
           DNSNAMESTR(domain),
           IPADDRSTR(serverAddr),
           expires);

    if (!XnetIsValidUnicastAddr(serverAddr))
        return NETERR_PARAM;

    len = GetDnsNameLen(domain) + 2;
    newsrv = (DnsServerCacheEntry*) SysAlloc(sizeof(*newsrv) + len, PTAG_DNS);
    if (!newsrv) return NETERR_MEMORY;

    newsrv->serverAddr = serverAddr;
    newsrv->expires = expires;
    newsrv->priority = priority;
    newsrv->domain = (DnsName*) (newsrv+1);
    CopyMem(newsrv->domain, domain, len);

    DnsLock();
    expires = (UINT) -1;
    oldie = DnsServerCacheNull();
    LOOP_THRU_DNSSERVER_CACHE(dnssrv)

        // If the specified domain/server combination is
        // already in the cache, just return success.
        if ((dnssrv->serverAddr == serverAddr) &&
            IsEqualDnsNames(dnssrv->domain, domain)) {
            dnssrv->expires = max(newsrv->expires, dnssrv->expires);
            dnssrv->priority = min(newsrv->priority, dnssrv->priority);
            DnsUnlock();
            SysFree(newsrv);
            return NETERR_OK;
        }

        // Remember the entry that'll expire the earliest.
        if (dnssrv->expires < expires) {
            oldie = dnssrv;
            expires = dnssrv->expires;
        }

    END_DNSSERVER_CACHE_LOOP

    if (DnsServerCacheSize >= cfgMaxDnsServerCacheSize) {
        // If there are too many entries in the DNS server cache,
        // remove the one with the smallest TTL. If no such
        // entry exists, return error.

        if (oldie == DnsServerCacheNull()) {
            DnsUnlock();
            SysFree(newsrv);
            WARNING_("DNS server cache is full.");
            return NETERR_MEMORY;
        }

        RemoveDnsServerCacheEntry(oldie);
    }

    InsertHeadList(&DnsServerCache, &newsrv->links);
    DnsServerCacheSize++;
    DnsUnlock();

    return NETERR_OK;
}


PRIVATE VOID
DnsExecutePendingSetDefaultReq()

/*++

Routine Description:

    Execute pending request to set default DNS domain and servers

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    DnsName* domainName;
    CHAR namestr[DNS_MAXNAMELEN+1];
    IPADDR addrs[MAX_DEFAULT_DNSSERVERS];
    UINT index, addrcnt;
    IfInfo* ifp;
    NTSTATUS status;

    ifp = DnsSetDefaultIfp;
    DnsSetDefaultIfp = NULL;
    if (!ifp) return;

    addrcnt = MAX_DEFAULT_DNSSERVERS;
    status = IfGetDefaultDnsServers(ifp, namestr, ARRAYCOUNT(namestr), addrs, &addrcnt);
    if (!NT_SUCCESS(status)) return;

    // Cleanup the DNS cache first
    DnsCleanup();
    if (addrcnt == 0) return;

    domainName = namestr[0] ?
                    CreateDnsNameFromString(namestr) :
                    CopyDnsName(DnsRootDomainName);

    if (!domainName) return;

    DnsLock();
    DnsCleanupDefaultSuffixes();

    DnsDefaultSuffixCount = 1;
    DnsDefaultSuffixes[0] = domainName;
    TRACE_("Default DNS search suffix: %s", DNSNAMESTR(domainName));

    // If the domain name has 3 or more labels, we'll add
    // the parent domain to the default search suffix list as well
    if (GetDnsNameLabels(domainName) >= 3) {
        BYTE* data;
        DnsName* dnsname;

        data = GetDnsNameData(domainName);
        data = SkipDnsNameLabel(data);
        dnsname = CreateDnsNameFromLabels(data);
        if (dnsname) {
            DnsDefaultSuffixCount++;
            DnsDefaultSuffixes[1] = dnsname;
            TRACE_("Default DNS search suffix: %s", DNSNAMESTR(dnsname));
        }
    }

    // Add default DNS servers to the cache
    for (index=0; index < addrcnt; index++) {
        AddDnsServerCacheEntry(domainName, *addrs, (UINT) -1, index);
    }

    DnsUnlock();
}


PRIVATE DnsCacheEntry*
CreateDnsCacheEntry(
    DnsName* dnsname,
    IPADDR addr
    )

/*++

Routine Description:

    Create a new entry in the DNS cache

Arguments:

    dnsname - Points to the name for the new entry

Return Value:

    Pointer to the newly created DNS cache entry
    NULL if there is an error

--*/

{
    DnsCacheEntry* dnsent;

    // Create a new entry and inserted it into the list
    dnsent = (DnsCacheEntry*) SysAlloc0(sizeof(*dnsent), PTAG_DNS);
    if (!dnsent) return NULL;

    if (dnsname) {
        dnsname = CopyDnsName(dnsname);
        if (!dnsname) {
            SysFree(dnsent);
            return NULL;
        }

        dnsent->namecnt = 1;
        dnsent->names[0] = dnsname;
    } else {
        dnsent->addrcnt = 1;
        dnsent->addrs[0] = addr;
    }

    // Refcount is initialized to 2 here:
    //  1 for keeping it in the cache
    //  1 for the caller 
    dnsent->refcount = 2;
    dnsent->status = NETERR_PENDING;
    dnsent->type = (WORD) (dnsname ? RRTYPE_A : RRTYPE_PTR);
    KeInitializeEvent(&dnsent->event, NotificationEvent, FALSE);

    InsertHeadList(&DnsCache, &dnsent->links);
    DnsCacheSize++;
    return dnsent;
}


PRIVATE IPADDR
FindBestDnsServer(
    DnsName* qname
    )

/*++

Routine Description:

    Find the best DNS server to use for the specified query

Arguments:

    qname - Specifies the query name

Return Value:

    IP address of the DNS server to use
    0 if no server is found

--*/

{
    UINT match, bestMatch, priority;
    IPADDR serverAddr;
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* found;

    found = NULL;
    priority = (UINT) -1;
    bestMatch = 0;
    DnsLock();

    LOOP_THRU_DNSSERVER_CACHE(dnssrv)
        
        // Get rid of expired cache entries
        if (dnssrv->expires <= TcpTickCount) {
            RemoveDnsServerCacheEntry(dnssrv);
            continue;
        }

        match = MatchDnsNames(qname, dnssrv->domain);
        if (match > bestMatch ||
            match == bestMatch && dnssrv->priority < priority) {
            found = dnssrv;
            priority = dnssrv->priority;
            bestMatch = match;
        }

    END_DNSSERVER_CACHE_LOOP

    if (found) {
        // Move the server to the end of the search list
        // so that another server with the same priority
        // will get taken for the next lookup.
        RemoveEntryList(&found->links);
        InsertTailList(&DnsServerCache, &found->links);
        serverAddr = found->serverAddr;
    } else
        serverAddr = 0;

    DnsUnlock();
    return serverAddr;
}


PRIVATE VOID
MarkBadDnsServer(
    IPADDR serverAddr
    )

/*++

Routine Description:

    This function is called when we timed out while waiting
    for a response from the specified DNS server.

Arguments:

    serverAddr - Specifies the DNS server's IP address

Return Value:

    NONE

--*/

{
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* prev;

    DnsLock();

    // NOTE: We can't use the LOOP_THRU_DNSSERVER_CACHE macro here
    // because we must go through the list in reverse order

    dnssrv = (DnsServerCacheEntry*) DnsServerCache.Blink;
    while (dnssrv != DnsServerCacheNull()) {
        prev = (DnsServerCacheEntry*) dnssrv->links.Blink;

        // Lower the server's precedence and
        // also move it to the end of the search list.
        if (dnssrv->serverAddr == serverAddr) {
            dnssrv->priority++;
            if (dnssrv->priority == -1)
                dnssrv->priority = 0;

            RemoveEntryList(&dnssrv->links);
            InsertTailList(&DnsServerCache, &dnssrv->links);
        }
        dnssrv = prev;
    }

    DnsUnlock();
}


PRIVATE INT
ComposeDnsQuery(
    BYTE* buf,
    DnsName* qname,
    WORD qtype
    )

/*++

Routine Description:

    Compose a DNS query message

Arguments:

    buf - Points to the data buffer
    qname - Query name
    qtype - Query type: RRTYPE_A or RRTYPE_PTR

Return Value:

    The length of the composed DNS query message

Note:
    
    We assume the data buffer size is at least DNS_MAXMSGLEN bytes.

--*/

{
    DnsHeader* dnshdr = (DnsHeader*) buf;
    WORD code;
    BYTE* p;
    UINT len;

    DnsQueryMsgId++;
    dnshdr->id = HTONS(DnsQueryMsgId);
    dnshdr->questions = HTONS(1);
    dnshdr->answers = dnshdr->nservers = dnshdr->extras = HTONS(0);

    // We always request recursive mode. But if the server
    // doesn't support, we'll fall back to use iterative mode.
    code = DNSFLAG_QUERY | DNSFLAG_RD | DNSOPCODE_STDQUERY;
    dnshdr->code = HTONS(code);

    p = buf + DNSHDRLEN;
    len = GetDnsNameLen(qname);
    CopyMem(p, GetDnsNameData(qname), len);
    p += len;

    *((WORD*) p) = HTONS(qtype);
    p += 2;

    *((WORD*) p) = HTONS(RRCLASS_IN);
    p += 2;

    return (p - buf);
}


//
// Extract a 16-bit value from the received message.
// NOTE: we're assuming little-endian machines here.
//
#define DNS_EXTRACT_WORD(_p) ((WORD) \
        (((WORD) (_p)[0] << 8) | \
         ((WORD) (_p)[1]     )))

// Extract a 32-bit value from the received message.
#define DNS_EXTRACT_DWORD(_p) \
        (((DWORD) (_p)[0] << 24) | \
         ((DWORD) (_p)[1] << 16) | \
         ((DWORD) (_p)[2] <<  8) | \
         ((DWORD) (_p)[3]      ))


//
// Free information about a resource record section
//
PRIVATE VOID FreeDnsRRList(DnsRR* rrlist) {
    while (rrlist) {
        DnsRR* rr = rrlist;
        rrlist = rrlist->next;

        FreeDnsName(rr->rrname);
        if (rr->type != RRTYPE_A) {
            FreeDnsName(rr->dataname);
        }
        SysFree(rr);
    }
}

//
// Free the information we parsed out of a DNS response
// Note: The DnsResp structure itself is not freed. 
//
PRIVATE VOID FreeDnsResp(DnsResp* dnsresp) {
    FreeDnsRRList(dnsresp->answers);
    FreeDnsRRList(dnsresp->nservers);
    FreeDnsRRList(dnsresp->extras);
}


PRIVATE BYTE*
DnsParseName(
    DnsResp* dnsresp,
    BYTE* p,
    DnsName** result
    )

/*++

Routine Description:

    Parse a name field out of a DNS response message
    (handles message compression too)

Arguments:

    dnsresp - Points to the information about the DNS response message
    p - Where the name field starts
    result - Returns a pointer to the parsed DNS name
        or NULL if there is an error

Return Value:

    Points to the first byte after the DNS name
    NULL if there is an error

--*/

{
    UINT totallen = 0;
    UINT ptrcnt = 0;
    BYTE* end = dnsresp->end;
    BYTE* retval = NULL;
    BYTE* namebuf = dnsresp->namebuf;

    *result = NULL;
    while (TRUE) {
        UINT b1, b2;

        if (p == end) return NULL;
        b1 = *p++;

        // Stop if we see the last label
        if (b1 == 0) {
            if (retval == NULL) retval = p;
            namebuf[totallen++] = 0;
            break;
        }

        b2 = b1 >> 6;
        if (b2 == 0) {
            // Regular label
            if (totallen + b1 + 1 >= DNS_MAXNAMELEN) return NULL;
            namebuf[totallen++] = (BYTE) b1;
            CopyMem(namebuf+totallen, p, b1);
            p += b1;
            totallen += b1;
        } else {
            // Name compression
            //  we artificially limit the number of name pointers to 8
            //  to avoid infinite recursion.
            INT offset;

            if (b2 == 1 || b2 == 2 || p == end || ++ptrcnt > 8)
                return NULL;
            
            offset = ((b1 & 0x3f) << 8) | *p++;
            if (offset >= end - dnsresp->start) return NULL;

            if (retval == NULL) retval = p;
            p = dnsresp->start + offset;
        }
    }

    *result = CreateDnsNameFromLabels(namebuf);
    return *result ? retval : NULL;
}


PRIVATE BYTE*
DnsParseRRSection(
    DnsResp* dnsresp,
    BYTE* p,
    DnsRR** sect,
    WORD count
    )

/*++

Routine Description:

    Parse a resource record section of a DNS response message

Arguments:

    dnsresp - Points to the information about the DNS response message
    p - Where the resource record section starts
    sect - Returns parsed information about the RR section
    count - Number of RRs as specified in the DNS message header

Return Value:

    Points to the first byte after the RR section

--*/

{
    BYTE* end = dnsresp->end;
    DnsRR* rrlist;
    DnsRR* rr;
    DnsName* dnsname;

    ASSERT(*sect == NULL);
    rrlist = NULL;
    count = NTOHS(count);

    while (count-- && p < end) {
        WORD type, cls, rdlen;
        DWORD ttl;
        BYTE* rdata;

        // record name
        p = DnsParseName(dnsresp, p, &dnsname);
        if (!p) break;

        // record type and class, ttl, and data length
        if (end-p < 10) goto badrr2;
        type = DNS_EXTRACT_WORD(p); p += 2;
        cls = DNS_EXTRACT_WORD(p); p += 2;
        ttl = DNS_EXTRACT_DWORD(p); p += 4;
        rdlen = DNS_EXTRACT_WORD(p); p += 2;
        if (end-p < rdlen) goto badrr2;
        rdata = p;
        p += rdlen;

        if (cls != RRCLASS_IN ||
            type != RRTYPE_A &&
            type != RRTYPE_NS &&
            type != RRTYPE_CNAME &&
            type != RRTYPE_SOA &&
            type != RRTYPE_PTR) {
            FreeDnsName(dnsname);
            continue;
        }

        rr = (DnsRR*) SysAlloc(sizeof(DnsRR), PTAG_DNS);
        if (!rr) goto badrr2;
        
        // record data
        switch (rr->type = type) {
        case RRTYPE_A:
            if (rdlen < IPADDRLEN) goto badrr1;
            CopyMem(&rr->addr, rdata, IPADDRLEN);
            break;

        case RRTYPE_NS:
        case RRTYPE_CNAME:
        case RRTYPE_PTR:
            if (!DnsParseName(dnsresp, rdata, &rr->dataname))
                goto badrr1;
            break;

        case RRTYPE_SOA: {
            DnsName* mxadmin;

            rdata = DnsParseName(dnsresp, rdata, &rr->dataname);
            if (rdata == NULL) goto badrr1;

            rdata = DnsParseName(dnsresp, rdata, &mxadmin);
            if (rdata == NULL) goto badrr1;

            FreeDnsName(mxadmin);
            if (end-rdata < 20) goto badrr1;

            // The TTL field isn't meaningful for SOA records.
            // Instead, we use the MINIMUM field as the TTL value
            // for negative caching.
            rdata += 16;
            ttl = DNS_EXTRACT_DWORD(rdata);
            }
            break;
        }

        rr->rrname = dnsname;
        rr->next = rrlist;
        rr->ttl = min(ttl, cfgMaxDnsCacheTtl);
        rrlist = rr;
    }

exit:
    // Reverse the resource record list
    // NOTE: even in case of error, a partial resource record list
    // is still returned to the caller.

    rr = rrlist;
    rrlist = NULL;
    while (rr) {
        DnsRR* next = rr->next;
        rr->next = rrlist;
        rrlist = rr;
        rr = next;
    }

    *sect = rrlist;
    return p;

badrr1:
    SysFree(rr);
badrr2:
    FreeDnsName(dnsname);
    p = NULL;
    goto exit;
}


//
// Check if a name is already associated with a DNS cache entry
//
INLINE BOOL DnsEntHasName(DnsName** names, UINT namecnt, DnsName* dnsname) {
    while (namecnt--) {
        if (IsEqualDnsNames(*names, dnsname)) return TRUE;
        names++;
    }
    return FALSE;
}


//
// Check if an address is already associated with a DNS cache entry
//
INLINE BOOL DnsEntHasAddr(IPADDR* addrs, UINT addrcnt, IPADDR addr) {
    while (addrcnt--) {
        if (*addrs++ == addr) return TRUE;
    }
    return FALSE;
}


//
// Add a name to a DNS cache entry
//
PRIVATE BOOL DnsEntAddName(DnsCacheEntry* dnsent, DnsName* dnsname) {
    if (DnsEntHasName(dnsent->names, dnsent->namecnt, dnsname) ||
        dnsent->namecnt >= MAXALIASCNT)
        return FALSE;

    dnsent->names[dnsent->namecnt++] = dnsname;
    return TRUE;
}


//
// Process CNAME records in a DNS response message
//
PRIVATE VOID DnsProcessCNames(DnsCacheEntry* dnsent, DnsRR* rrlist) {
    DnsName* dnsname;
    DnsRR* rr;
    UINT high, index = 0;

    while (index < dnsent->namecnt) {
        dnsname = dnsent->names[index++];
        for (rr=rrlist; rr; rr=rr->next) {
            if (rr->type == RRTYPE_CNAME && IsEqualDnsNames(rr->rrname, dnsname)) {
                DnsEntAddName(dnsent, rr->dataname);
            }
        }
    }

    // Reverse the name list
    ASSERT(dnsent->namecnt);
    index = 0;
    high = dnsent->namecnt - 1;
    while (index < high) {
        dnsname = dnsent->names[index];
        dnsent->names[index++] = dnsent->names[high];
        dnsent->names[high--] = dnsname;
    }
}


//
// Find the first DNS resource record of the specified
// name/type combination in a RR section
//
INLINE DnsRR* DnsFindRR(DnsRR* rrlist, DnsName* name, WORD type) {
    while (rrlist) {
        if ((rrlist->type == type) && 
            (name == NULL || IsEqualDnsNames(name, rrlist->rrname)))
            break;
        rrlist = rrlist->next;
    }
    return rrlist;
}


PRIVATE VOID
DnsProcessPositiveResp(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    DnsName* qname
    )

/*++

Routine Description:

    Process a positive answer from the DNS server

Arguments:

    dnsent - Points to the DNS cache entry corresponding to the DNS query
    dnsresp - Information about the DNS response message
    qname - Specifies the original DNS query name

Return Value:

    NONE

--*/

{
    DnsRR* rr = dnsresp->answers;
    UINT ttl = (UINT) -1;

    if (dnsent->type == RRTYPE_PTR) {
        // Process all PTR records first
        while (rr) {
            if (rr->type == RRTYPE_PTR && IsEqualDnsNames(rr->rrname, qname)) {
                if (DnsEntAddName(dnsent, rr->dataname)) {
                    rr->dataname = NULL;
                    ttl = min(ttl, rr->ttl);
                }
            }
            rr = rr->next;
        }

        // Then process all CNAME records
        DnsProcessCNames(dnsent, dnsresp->answers);
    } else {
        // Process all CNAME records first
        DnsProcessCNames(dnsent, rr);

        // Then process all A records
        while (rr) {
            if (rr->type == RRTYPE_A &&
                DnsEntHasName(dnsent->names, dnsent->namecnt, rr->rrname) &&
                !DnsEntHasAddr(dnsent->addrs, dnsent->addrcnt, rr->addr) &&
                dnsent->addrcnt < MAXALIASCNT) {
                dnsent->addrs[dnsent->addrcnt++] = rr->addr;
                ttl = min(ttl, rr->ttl);
            }
            rr = rr->next;
        }
    }

    dnsent->expires = DnsCacheExpires(ttl);
}


PRIVATE VOID
DnsProcessNegativeResp(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp
    )

/*++

Routine Description:

    Process negative response to a DNS query

Arguments:

    dnsent - Points to the DNS cache entry corresponding to the query
    dnsresp - Information about the DNS response message

Return Value:

    NONE

--*/

{
    DnsRR* rr;

    // If this was a name-to-address query,
    // process the CNAME records.
    if (dnsent->type == RRTYPE_A) {
        DnsProcessCNames(dnsent, dnsresp->answers);
    }

    // Figure out the negative cache TTL
    rr = DnsFindRR(dnsresp->nservers, NULL, RRTYPE_SOA);
    dnsent->expires = DnsCacheExpires(rr ? rr->ttl : 0);
}


PRIVATE NTSTATUS
DnsProcessNServers(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    BOOL referral
    )

/*++

Routine Description:

    Process the name server information inside the nservers and extras
    sections of a DNS response message

Arguments:

    dnsent - Points to the DNS cache entry corresponding to a DNS query
    dnsresp - Information about the DNS response message
    referral - Whether the response is a referral

Return Value:

    Status code

--*/

{
    DnsRR* rrNS;
    DnsRR* rrA;
    IPADDR serverAddr;
    NTSTATUS status = NETERR_OK;

    for (rrNS = dnsresp->nservers; rrNS; rrNS = rrNS->next) {
        if (rrNS->type != RRTYPE_NS) continue;
        rrA = DnsFindRR(dnsresp->extras, rrNS->dataname, RRTYPE_A);

        if (rrA) {
            serverAddr = rrA->addr;
        } else {
            serverAddr = 0;

            if (referral) {
                DnsCacheEntry* found;
                status = DnsLookupProc(rrNS->dataname, 0, &found);
                if (NT_SUCCESS(status)) {
                    status = found->status;
                    serverAddr = found->addrs[0];
                    DnsCacheEntryRelease(found);

                    // If anther thread is actively resolving
                    // the address of our referred server,
                    // return WSATRY_AGAIN error rather than wait here
                    // to avoid potential deadlock.
                    if (status == NETERR_PENDING) {
                        status = NETERR(WSATRY_AGAIN);
                    }
                }
            }
        }

        if (serverAddr) {
            status = AddDnsServerCacheEntry(
                            rrNS->rrname,
                            serverAddr,
                            DnsCacheExpires(rrNS->ttl),
                            0);
        }

        // If this function was called because of a referral response,
        // we'll return after seeing the first NS records.
        if (referral) return status;
    }

    return referral ? NETERR_PARAM : NETERR_OK;
}


PRIVATE NTSTATUS
DnsProcessResponse(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    DnsName* qname,
    DnsName** tempname
    )

/*++

Routine Description:

    Process a received DNS query response

Arguments:

    dnsent - Points to the DNS cache entry
    dnsresp - Points to the DNS response information
    qname - Specifies the name that's being queried
    tempname - Returns a pointer to the new query name
        if the response is a referral and
        the query type involved was RRTYPE_PTR

Return Value:

    Status code:
        NETERR_OK - the response was a positive answer to our query
        NETERR(WSAHOST_NOT_FOUND)
        NETERR(WSANO_DATA) - the response was a negative answer
        DNSRESP_REFERRAL - the response was a referral
        other error code - there was an error interpreting the response

--*/

#define DNSRESP_REFERRAL 1

{
    NTSTATUS status;
    DnsHeader* dnshdr;
    WORD code, type, cls;
    BYTE* p;
    DnsName* dnsname;

    // Validate header information
    // NOTE: We don't compare DNS message ID here.
    if (dnsresp->end - dnsresp->start < DNSHDRLEN)
        return NETERR_PARAM;

    dnshdr = (DnsHeader*) dnsresp->start;
    code = NTOHS(dnshdr->code);
    if (!(code & DNSFLAG_RESPONSE) ||
        DNSGETOPCODE(code) != DNSOPCODE_STDQUERY ||
        dnshdr->questions != HTONS(1)) {
        return NETERR_PARAM;
    }

    // Interpret the RCODE
    code = (WORD) DNSGETRCODE(code);
    switch (code) {
    case RCODE_OK:
    case RCODE_NAME_ERROR:
        // continue processing
        break;

    case RCODE_SERVER_FAILED:
        return NETERR(WSATRY_AGAIN);

    case RCODE_FORMAT_ERROR:
    default:
        return NETERR_PARAM;
    }

    // Parse the questions section

    p = dnsresp->start + DNSHDRLEN;
    p = DnsParseName(dnsresp, p, &dnsname);
    if (!dnsname || !IsEqualDnsNames(dnsname, qname)) {
        FreeDnsName(dnsname);
        return NETERR_PARAM;
    }
    FreeDnsName(dnsname);

    if (dnsresp->end - p < 4) return NETERR_PARAM;
    type = DNS_EXTRACT_WORD(p); p += 2;
    cls = DNS_EXTRACT_WORD(p); p += 2;
    if (type != dnsent->type || cls != RRCLASS_IN)
        return NETERR_PARAM;

    // Parse the resource record sections:
    //  We only require the answers section to be complete.
    //  Errors in the other two sections are ignored.
    p = DnsParseRRSection(dnsresp, p, &dnsresp->answers, dnshdr->answers);
    if (!p) return NETERR_PARAM;

    p = DnsParseRRSection(dnsresp, p, &dnsresp->nservers, dnshdr->nservers);
    if (p) {
        DnsParseRRSection(dnsresp, p, &dnsresp->extras, dnshdr->extras);
    }

    // Process the information in the answers section
    if (code == RCODE_OK) {
        if (DnsFindRR(dnsresp->answers, qname, dnsent->type)) {
            // Positive answer
            DnsProcessPositiveResp(dnsent, dnsresp, qname);
            status = NETERR_OK;
        } else {
            // We differentiate the "no data" case from the "referral" case
            // by the presence of SOA record or the absence of NS record
            // in the nservers section.
            if (DnsFindRR(dnsresp->nservers, NULL, RRTYPE_SOA) ||
                !DnsFindRR(dnsresp->nservers, NULL, RRTYPE_NS)) {
                TRACE_("No data for host: %s", DNSNAMESTR(qname));
                DnsProcessNegativeResp(dnsent, dnsresp);
                status = NETERR(WSANO_DATA);
            } else {
                TRACE_("Referral for host: %s", DNSNAMESTR(qname));
                if (dnsent->type == RRTYPE_A) {
                    DnsProcessCNames(dnsent, dnsresp->answers); 
                    TRACE_("  %s", DNSNAMESTR(dnsent->names[0]));
                } else {
                    DnsRR* rr = DnsFindRR(dnsresp->answers, qname, RRTYPE_CNAME);
                    if (rr) {
                        TRACE_("  %s", DNSNAMESTR(rr->dataname));
                        FreeDnsName(*tempname);
                        *tempname = rr->dataname;
                        rr->dataname = NULL;
                    }
                }
                status = DNSRESP_REFERRAL;
            }
        }
    } else {
        // Name error
        TRACE_("Host not found: %s", DNSNAMESTR(qname));
        DnsProcessNegativeResp(dnsent, dnsresp);
        status = NETERR(WSAHOST_NOT_FOUND);
    }

    // Process the information in the nservers and extras sections
    if (status == DNSRESP_REFERRAL) {
        NTSTATUS status1 = DnsProcessNServers(dnsent, dnsresp, TRUE);
        if (!NT_SUCCESS(status1)) status = status1;
    } else {
        DnsProcessNServers(dnsent, dnsresp, FALSE);
    }

    return status;
}


PRIVATE NTSTATUS
ResolveDnsCacheEntry(
    DnsCacheEntry* dnsent
    )

/*++

Routine Description:

    Resolve a DNS cache entry

Arguments:

    dnsent - Points to the DNS cache entry to be resolved

Return Value:

    Status code

--*/

{
    SOCKET s = INVALID_SOCKET;
    struct sockaddr_in sockname;
    INT fromlen, datalen;
    NTSTATUS status;
    UINT retries, timeout;
    CHAR* databuf;
    DnsName* qname;
    DnsName* tempname = NULL;
    IPADDR serverAddr;
    UINT cnames = 0;
    DnsResp* dnsresp;

    ASSERT(dnsent->status == NETERR_PENDING);
    dnsent->expires = (UINT) -1;

    // allocate temporary buffer for send and receive
    // create a UDP socket and bind it
    databuf = (BYTE*) SysAlloc(DNS_MAXMSGLEN, PTAG_DNS);
    dnsresp = (DnsResp*) SysAlloc(sizeof(DnsResp), PTAG_DNS);
    if (!databuf || !dnsresp) {
        status = NETERR_MEMORY; goto exit;
    }

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET) goto errexit;

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

    status = bind(s, (struct sockaddr*) &sockname, sizeof(sockname));
    if (status != NO_ERROR) goto errexit;

    // Generate IN-ADDR.ARPA query name if we're
    // doing an address-to-name lookup
    if (dnsent->type == RRTYPE_PTR) {
        tempname = CreateDnsNameFromAddr(dnsent->addrs[0]);
        if (!tempname) {
            status = NETERR_MEMORY; goto exit;
        }
    }

newlookup:
    // Give up if there are too many levels of CNAMEs
    if (cnames++ >= MAXALIASCNT) {
        status = NETERR(WSAHOST_NOT_FOUND);
        goto exit;
    }

    timeout = cfgMinLookupTimeout * 1000;
    retries = cfgMaxLookupRetries;
    while (TRUE) {
        if (retries-- == 0) {
            status = NETERR(WSATRY_AGAIN);
            break;
        }

        // Look for an appropriate DNS server
        qname = (dnsent->type == RRTYPE_A) ? dnsent->names[0] : tempname;
        TRACE_("Query DNS name: %s", DNSNAMESTR(qname));

        serverAddr = FindBestDnsServer(qname);
        if (serverAddr == 0) {
            status = NETERR(WSAENETDOWN);
            break;
        }
        // Send out a message
        datalen = ComposeDnsQuery(databuf, qname, dnsent->type);

        sockname.sin_port = HTONS(DNS_SERVER_PORT);
        sockname.sin_addr.s_addr = serverAddr;
        TRACE_("  DNS server: %s", inet_ntoa(sockname.sin_addr));

        fromlen = sizeof(sockname);
        datalen = sendto(s, databuf, datalen, 0, (struct sockaddr*) &sockname, fromlen);
        if (datalen == SOCKET_ERROR) continue;

        // wait for reply
        status = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
        if (status != NO_ERROR) goto errexit;
        timeout += timeout;

        datalen = recvfrom(s, databuf, DNS_MAXMSGLEN, 0, (struct sockaddr*) &sockname, &fromlen);
        if (datalen == SOCKET_ERROR) {
            if (WSAGetLastError() != WSAETIMEDOUT) goto errexit;
            MarkBadDnsServer(serverAddr);
            continue;
        }
        TRACE_("Response recieved from server: %s", inet_ntoa(sockname.sin_addr));

        // Process the received message
        dnsresp->start = databuf;
        dnsresp->end = databuf + datalen;
        dnsresp->answers = dnsresp->nservers = dnsresp->extras = NULL;
        status = DnsProcessResponse(dnsent, dnsresp, qname, &tempname);
        FreeDnsResp(dnsresp);

        switch (status) {
        case DNSRESP_REFERRAL:
            // Iterative lookup
            goto newlookup;
        
        case NETERR_OK:
        case NETERR(WSAHOST_NOT_FOUND):
        case NETERR(WSANO_DATA):
            // stop searching and return appropriate error code
            goto exit;

        default:
            // continue on with the next server
            VERBOSE_("Error processing response: 0x%x", status);
            break;
        }
    }

exit:
    if (s != INVALID_SOCKET) {
        closesocket(s);
    }
    SysFree(databuf);
    SysFree(dnsresp);
    FreeDnsName(tempname);

    // In case of temporary server error,
    // cache the negative response for a few seconds
    if (dnsent->expires == -1) {
        dnsent->expires = DnsCacheExpires(cfgMinLookupTimeout);
    }
    dnsent->status = status;
    SetKernelEvent(&dnsent->event);
    return status;

errexit:
    status = WSAGetLastError();
    status = (status == NO_ERROR) ? NETERR_SYSCALL : NETERR(status);
    goto exit;
}


PRIVATE NTSTATUS
DnsLookupProc(
    DnsName* dnsname,
    IPADDR addr,
    DnsCacheEntry** result
    )

/*++

Routine Description:

    DNS lookup function - called to:
    - resolve a host name to IP addresses,
    - resolve an IP address to host names

Arguments:

    dnsname - Specifies the host name (NULL if doing lookup by address)
    addr - Specifies the IP address
    result - Return the result of the lookup

Return Value:

    Status code

--*/

{
    DnsCacheEntry* dnsent;
    DnsCacheEntry* found;
    DnsCacheEntry* oldie;
    UINT expires;

    *result = NULL;
    found = NULL;
    expires = (UINT) -1;
    oldie = DnsCacheNull();

    DnsLock();
    LOOP_THRU_DNS_CACHE(dnsent)
        
        // If we have an entry that's already expired,
        // remove it from the list now.
        if (dnsent->expires <= TcpTickCount) {
            RemoveDnsCacheEntry(dnsent);
            continue;
        }

        // Check if the specified name or address matches
        // the names or addresses associated with this DNS cache entry
        if (dnsname && DnsEntHasName(dnsent->names, dnsent->namecnt, dnsname) ||
            !dnsname && DnsEntHasAddr(dnsent->addrs, dnsent->addrcnt, addr)) {
            dnsent->refcount++;
            found = dnsent;
            break;
        }

        // Remember the entry that has the earliest
        // expiration time.

        if (dnsent->expires < expires) {
            oldie = dnsent;
            expires = dnsent->expires;
        }

    END_DNS_CACHE_LOOP

    if (!found) {
        // If the name is not already in the cache,
        // we'll create a new DNS cache entry.

        if (DnsCacheSize >= cfgMaxDnsCacheSize) {
            if (oldie == DnsCacheNull()) {
                DnsUnlock();
                WARNING_("DNS cache is full.");
                return NETERR_MEMORY;
            }
            RemoveDnsCacheEntry(oldie);
        }

        found = CreateDnsCacheEntry(dnsname, addr);
        DnsUnlock();
        if (!found) return NETERR_MEMORY;

        // Resolve the new entry now
        ResolveDnsCacheEntry(found);
    } else {
        DnsUnlock();
    }

    *result = found;
    return NETERR_OK;
}


PRIVATE NTSTATUS
ReturnDnsEntryInfo(
    DnsCacheEntry* dnsent,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Return information for a DNS lookup

Arguments:

    dnsent - Points to the cached DNS entry
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    UINT size;
    BYTE index, namecnt, addrcnt, namelen;
    struct hostent* hostentbuf;
    BYTE *p;

    // Check if some other thread is actively resolving this entry.
    // If so, we'll just wait until the other thread complete its work.
    if (dnsent->status == NETERR_PENDING) {
        WaitKernelEventObject(&dnsent->event, 0);
    }

    // If the result was unsuccessful, return error
    if (!NT_SUCCESS(dnsent->status))
        return dnsent->status;

    namecnt = dnsent->namecnt;
    addrcnt = dnsent->addrcnt;
    ASSERT(namecnt && addrcnt);

    // Figure out the total buffer size we need to
    // output the information in the DNS entry
    size = sizeof(struct hostent) +
           sizeof(CHAR*) * namecnt +
           sizeof(CHAR*) * (addrcnt + 1) +
           sizeof(struct in_addr) * addrcnt;

    for (index=0; index < namecnt; index++) {
        size += GetDnsNameLen(dnsent->names[index]);
    }

    // Allocate memory buffer
    hostentbuf = callback(size, param);
    if (!hostentbuf) return NETERR_MEMORY;

    hostentbuf->h_addrtype = AF_INET;
    hostentbuf->h_length = IPADDRLEN;

    // 1. null-terminated array of alias name pointers
    // comes after the hostent structure itself

    p = (BYTE*) (hostentbuf+1);
    hostentbuf->h_aliases = (CHAR**) p;
    p += sizeof(CHAR*) * namecnt;

    // 2. then comes the null-terminate array of pointers to
    // the list of addresses.

    hostentbuf->h_addr_list = (CHAR**) p;
    p += sizeof(CHAR*) * (addrcnt + 1);

    // 3. then comes the array of addresses themselves

    for (index=0; index < addrcnt; index++) {
        hostentbuf->h_addr_list[index] = (CHAR*) p;
        ((struct in_addr*) p)->s_addr = dnsent->addrs[index];
        p += sizeof(struct in_addr);
    }
    hostentbuf->h_addr_list[addrcnt] = NULL;

    // 4. then comes the primary DNS name

    hostentbuf->h_name = (CHAR*) p;
    namelen = GetDnsNameLen(dnsent->names[0]);
    DnsNameToString(dnsent->names[0], p, namelen);
    p += namelen;

    // 5. and finally the list of name aliases

    for (index=1; index < namecnt; index++) {
        hostentbuf->h_aliases[index-1] = (CHAR*) p;
        namelen = GetDnsNameLen(dnsent->names[index]);
        DnsNameToString(dnsent->names[index], p, namelen);
        p += namelen;
    }
    hostentbuf->h_aliases[namecnt-1] = NULL;

    return NETERR_OK;
}


NTSTATUS
DnsLookupByName(
    const CHAR* name,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Map a hostname to its corresponding IP addresses

Arguments:

    name - Specifies the host name to be looked up
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    DnsCacheEntry* found;
    DnsName* dnsname;
    DnsName* names[MAX_DEFAULT_SUFFIXES+1];
    UINT index, namecnt;
    NTSTATUS status = NETERR_OK;

    // If there is a pending request to set default
    // DNS domain and servers, execute it now.
    if (DnsSetDefaultIfp) {
        DnsExecutePendingSetDefaultReq();
    }

    dnsname = CreateDnsNameFromString(name);
    if (!dnsname) return NETERR_MEMORY;

    // Compose a list of names to search for
    // by appending the default search suffixes.

    namecnt = 0;
    DnsLock();

    // If the specified name has more than 1 labels,
    // then search it first.
    if (GetDnsNameLabels(dnsname) > 1)
        names[namecnt++] = dnsname;

    // If the specified name ends in '.'
    // then we don't try the default search suffixes
    if (name[strlen(name)-1] != '.') {
        for (index=0; index < DnsDefaultSuffixCount; index++) {
            names[namecnt] = ConcatDnsNames(dnsname, DnsDefaultSuffixes[index]);
            if (names[namecnt]) 
                namecnt++;
        }
    }
    
    // If the specified name has just 1 label, then
    // search it last.
    if (GetDnsNameLabels(dnsname) <= 1)
        names[namecnt++] = dnsname;

    DnsUnlock();

    // Try all the name combinations and stop until one succeeds
    for (index=0; index < namecnt; index++) {
        NTSTATUS statusTemp;

        statusTemp = DnsLookupProc(names[index], 0, &found);
        if (NT_SUCCESS(statusTemp)) {
            statusTemp = ReturnDnsEntryInfo(found, callback, param);
            DnsCacheEntryRelease(found);

            if (NT_SUCCESS(statusTemp)) {
                status = statusTemp;
                break;
            }
        }

        // Remember the error code if this was the original name
        if (names[index] == dnsname)
            status = statusTemp;
    }

    for (index=0; index < namecnt; index++) {
        FreeDnsName(names[index]);
    }
    return status;
}


NTSTATUS
DnsLookupByAddr(
    IPADDR addr,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Map an IP address to its corresponding hostnames

Arguments:

    addr - Specifies the IP address to be looked up
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    DnsCacheEntry* found;
    NTSTATUS status;

    // If there is a pending request to set default
    // DNS domain and servers, execute it now.
    if (DnsSetDefaultIfp) {
        DnsExecutePendingSetDefaultReq();
    }

    status = DnsLookupProc(NULL, addr, &found);
    if (NT_SUCCESS(status)) {
        status = ReturnDnsEntryInfo(found, callback, param);
        DnsCacheEntryRelease(found);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dns\precomp.h ===
#define WINSOCK_API_LINKAGE

#include "xnetp.h"
#include "dns.h"
#include "dnslib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dns\dnslib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dnslib.h

Abstract:

    DNS client implementation related declarations

Revision History:

    07/11/2000 davidx
        Created it.

--*/

#ifndef _DNSLIB_H
#define _DNSLIB_H

//
// Internal DNS domain name representation
//  We represent the DNS domain name as an array of bytes.
//  1st byte is the total length of the name (not including the first two bytes)
//  2nd byte is the number of labels.
//  followed by the normal domain name data (as in RFC1035).
//  e.g.
//      19
//      3
//      3 www
//      9 microsoft
//      3 com
//      0
//
typedef BYTE DnsName;
DnsName* CreateDnsNameFromString(const CHAR* buf);
INLINE VOID FreeDnsName(DnsName* dnsname) {
    SysFree(dnsname);
}

#define SetDnsNameLen(_dnsname, _len)       ((_dnsname)[0] = (BYTE) (_len))
#define SetDnsNameLabels(_dnsname, _labels) ((_dnsname)[1] = (BYTE) (_labels))
#define GetDnsNameLen(_dnsname)             (_dnsname)[0]
#define GetDnsNameLabels(_dnsname)          (_dnsname)[1]
#define GetDnsNameData(_dnsname)            ((_dnsname) + 2)

#define SkipDnsNameLabel(_p) ((_p) + 1 + *(_p))

INLINE const BYTE* SkipDnsNameLabels(const BYTE* p, UINT n) {
    while (n--) {
        p = SkipDnsNameLabel(p);
    }
    return p;
}

// Make a copy of a DNS name
INLINE DnsName* CopyDnsName(const DnsName* dnsname) {
    UINT len = (UINT) GetDnsNameLen(dnsname) + 2;
    DnsName* newname = (DnsName*) SysAlloc(len, PTAG_DNS);
    if (newname) {
        CopyMem(newname, dnsname, len);
    }
    return newname;
}


//
// Cached DNS server entry
//
typedef struct _DnsServerCacheEntry {
    LIST_ENTRY links;
        // doubly-linked list pointers
        // must be the first field!

    UINT expires;
        // expiration time (in 0.5 seconds)

    IPADDR serverAddr;
        // DNS server address

    DnsName* domain;
        // name of the domain this server can handle

    UINT priority;
        // server precedence
        // lower value is more preferred
} DnsServerCacheEntry;


//
// Cached DNS lookup entry
//  we artifically limit the maximum number of aliases to 4
//
#define MAXALIASCNT 4

typedef struct _DnsCacheEntry {
    LIST_ENTRY links;
        // doubly-linked list pointers
        // must be the first field!
    
    LONG refcount;
        // reference count

    UINT expires;
        // expiration time (in 0.5 seconds)

    NTSTATUS status;
        // entry status

    WORD type;
        // entry type:
        //  RRTYPE_A
        //  RRTYPE_PTR

    BYTE namecnt;
        // number of names

    BYTE addrcnt;
        // number of addresses

    IPADDR addrs[MAXALIASCNT];
        // list of addresses

    DnsName* names[MAXALIASCNT];
        // list of names

    KEVENT event;
        // wait event object
} DnsCacheEntry;

//
// Map relative TTL value in seconds to
// absolute expiration time in ticks
//
#define DnsCacheExpires(_ttl) \
        (TcpTickCount + (_ttl) * SLOW_TCP_TIMER_FREQ)


//
// Data structure for storing parsed information
// from a DNS response message
//
typedef struct _DnsRR DnsRR;
typedef struct _DnsRR {
    DnsRR* next;            // points to the next RR
    DnsName* rrname;        // record name
    WORD type;              // record type
    WORD unused;
    UINT ttl;               // TTL
    union {
        IPADDR addr;        // IP address for RRTYPE_A record
        DnsName* dataname;  // data for other records:
                            //  RRTYPE_NS
                            //  RRTYPE_CNAME
                            //  RRTYPE_SOA
                            //  RRTYPE_PTR
    };
};

typedef struct _DnsResp {
    BYTE* start;            // points to where the DNS response message starts
    BYTE* end;              // points to after the DNS message
    DnsRR* answers;         // information in the answers section
    DnsRR* nservers;        // ... the nservers section
    DnsRR* extras;          // ... the extras section

    // temporary name buffer
    BYTE namebuf[DNS_MAXNAMELEN+1];
} DnsResp;

#endif // !_DNSLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\dns\dns.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dns.h

Abstract:

    DNS protocol related declarations

Revision History:

    07/12/2000 davidx
        Created it.

--*/

#ifndef _DNS_H
#define _DNS_H

//
// DNS name format:
//  1 byte - label length (N)
//  N bytes - label
//  ... more labels
//  0 - root label
//
// Compression:
//  Normally, the two high bits of the label length byte is 00.
//  But if the two high bits are 11, then the remaining 6 bits
//  and the next byte form an offset. The offset is relative to
//  the beginning of the DNS message. The domain name continues
//  with data from that offset.
//

//
// Resource record (RR) format
//  NAME - see above
//  2 bytes - type
//  2 bytes - class
//  4 bytes - TTL (time-to-live)
//  2 bytes - RDATA length
//  RDATA - variable length
//

//
// RDATA format for well-known types
//
// A
//  4 bytes - internet address
//
// PTR
//  PTRDNAME: <name> - pointer to some location in the domain name space
//
// CNAME
//  CNAME: <name> - canonical name for the record owner
//
// MX
//  2 bytes - preference value
//  EXCHANGE: <name> - domain name for the mail exchange host
//
// SOA
//  MNAME: <name> - name server that's the primary data source for this zone
//  RNAME: <name> - mailbox of the zone administrator
//  4 bytes - version number of the original copy of the zone
//  4 bytes - time interval before the zone should be refreshed
//  4 bytes - wait time before a failed refresh should be retried
//  4 bytes - max time interval before the zone is no longer authoritative
//  4 bytes - minimum TTL that should be used for any RR in this zone
//

//
// RR type constants
//
#define RRTYPE_A        1   // a host address
#define RRTYPE_NS       2   // an authoritative name server
#define RRTYPE_MD       3   // a mail destination (Obsolete - use MX)
#define RRTYPE_MF       4   // a mail forwarder (Obsolete - use MX)
#define RRTYPE_CNAME    5   // the canonical name for an alias
#define RRTYPE_SOA      6   // marks the start of a zone of authority
#define RRTYPE_MB       7   // a mailbox domain name (EXPERIMENTAL)
#define RRTYPE_MG       8   // a mail group member (EXPERIMENTAL)
#define RRTYPE_MR       9   // a mail rename domain name (EXPERIMENTAL)
#define RRTYPE_NULL     10  // a null RR (EXPERIMENTAL)
#define RRTYPE_WKS      11  // a well known service description
#define RRTYPE_PTR      12  // a domain name pointer
#define RRTYPE_HINFO    13  // host information
#define RRTYPE_MINFO    14  // mailbox or mail list information
#define RRTYPE_MX       15  // mail exchange
#define RRTYPE_TXT      16  // text strings

// Additional query type constants
#define QTYPE_AXFR      252 // a transfer of an entire zone
#define QTYPE_MAILB     253 // mailbox-related records (MB, MG or MR)
#define QTYPE_MAILA     254 // mail agent RRs (Obsolete - see MX)
#define QTYPE_ALL       255 // all records

//
// RR class constants
//
#define RRCLASS_IN      1   // the Internet
#define QCLASS_ANY      255 // any class

//
// Limits
//
#define DNS_MAXLABELLEN 63
#define DNS_MAXNAMELEN  255
#define DNS_MAXMSGLEN   512

//
// DNS message format
//  header section
//  question section
//  answer section
//  authority section
//  additional section
//

typedef struct _DnsHeader {
    WORD id;
    WORD code;
    WORD questions;
    WORD answers;
    WORD nservers;
    WORD extras;
} DnsHeader;

#define DNSHDRLEN sizeof(DnsHeader)

//
// Bit assignment for the DnsHeader.code field
//  bit 15: whether the message is a query or a response
//  bit 14-11: specifies the kind of query
//      0 - standard query
//      1 - inverse query
//      2 - server status request
//      others - reserved
//  bit 10: whether the responding name server is an authority
//      for the domain name in question
//  bit 9: whether this message was truncated
//  bit 8: whether recursion is desired by the requester
//  bit 7: whether recursion is available on the server
//  bit 6-4: reserved
//  bit 3-0: response code (see below)
//
#define DNSFLAG_QUERY       (0 << 15)
#define DNSFLAG_RESPONSE    BIT(15)
#define DNSFLAG_AA          BIT(10)
#define DNSFLAG_TC          BIT(9)
#define DNSFLAG_RD          BIT(8)
#define DNSFLAG_RA          BIT(7)

#define DNSGETOPCODE(x)     (((x) >> 11) & 0xf)
#define DNSOPCODE_STDQUERY  0

#define DNSGETRCODE(x)      ((x) & 0xf)
#define RCODE_OK            0
#define RCODE_FORMAT_ERROR  1
#define RCODE_SERVER_FAILED 2
#define RCODE_NAME_ERROR    3
#define RCODE_NOTIMPL       4
#define RCODE_REFUSED       5

//
// Data format for the query section
//  QNAME: <name> - the domain name in question
//  QTYPE: 2 bytes - query type
//  QCLASS: 2 bytes - query class
//

//
// DNS server port number
//
#define DNS_SERVER_PORT 53

#endif // !_DNS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\dbgmon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgmon.h

Abstract:

    Macros to hide the difference between normal build
    and the special build for the debug monitor

Revision History:

    07/21/2000 davidx
        Created it.

Note:

    This header file must not be included into multiple C files!

--*/

#ifndef _DBGMON_H
#define _DBGMON_H

// IP packet reception function
typedef VOID (*IPRECEIVEPROC)(Packet*);
typedef VOID (*FREEPKTPROC)(Packet*);
typedef VOID* (*UNCACHEDALLOCPROC)(SIZE_T, ULONG);
typedef VOID (*UNCACHEDFREEPROC)(VOID*);

typedef struct _ENETINITPARAMS {
    IN IPRECEIVEPROC IpReceiveProc;
    IN FREEPKTPROC FreePktProc;
    OUT UNCACHEDALLOCPROC UncachedAllocProc;
    OUT UNCACHEDFREEPROC UncachedFreeProc;
} ENETINITPARAMS;

// Enet initialization function provided by the debug monitor
typedef IfEnet* (*DBGMON_ENETINITPROC)(ENETINITPARAMS*);

#ifndef BUILD_FOR_DEBUGGER

// Pass the received frame up to the IP layer
#define IPRECEIVEPACKET IpReceivePacket

// Dispose of a packet after transmission
#define COMPLETEPACKET XnetCompletePacket

// Check to see if we should delete the enet interface
#define IFENET_DELETE_CHECK(ifp) \
        ASSERT((ifp)->refcount == 1); \
        (ifp)->refcount--

// Set the enet interface information in the process control block
#define SET_DBGMON_ENETINFO(ifp)

//
// Function called by the debug monitor enet driver to
// dispose of packets that the regular stack has passed down
//
INLINE VOID FreePacketCallback(Packet* pkt) {
    XnetFreePacket(pkt);
}

//
// Check if the debug monitor has already initialized the enet interface
//
#define CHECK_DBGMON_ENETINFO() { \
            DBGMON_ENETINITPROC enetInitProc; \
            enetInitProc = (DBGMON_ENETINITPROC) KeGetCurrentPrcb()->DmEnetFunc; \
            if (enetInitProc) { \
                ENETINITPARAMS initParams = { IpReceivePacket, FreePacketCallback, }; \
                ifp = enetInitProc(&initParams); \
                *newifp = (IfInfo*) ifp; \
                XnetUncachedAllocProc = initParams.UncachedAllocProc; \
                XnetUncachedFreeProc = initParams.UncachedFreeProc; \
                IfSetIpAddr(*newifp, ifp->ipaddr, ifp->addrmask); \
                DhcpSetDefaultGateways(*newifp); \
                return NETERR_OK; \
            } \
        }

#else // BUILD_FOR_DEBUGGER

#include "dm.h"
#include "xbdm.h"

// Pass the received frame up to the IP layer
VOID IPRECEIVEPACKET(Packet* pkt);

// Dispose of a packet after transmission
VOID COMPLETEPACKET(Packet* pkt, NTSTATUS status);

// Check to see if we should delete the enet interface
VOID IFENET_DELETE_CHECK(IfEnet* ifp);

// Set the enet interface information in the process control block
VOID SET_DBGMON_ENETINFO(IfEnet* ifp);

// Check if the debug monitor has already initialized the enet interface
#define CHECK_DBGMON_ENETINFO()

#endif // BUILD_FOR_DEBUGGER

#endif // !_DBGMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\enet.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    enet.c

Abstract:

    Handle Ethernet frame transmission and reception

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Ethernet broadcast address
//
const BYTE EnetBroadcastAddr[ENETADDRLEN] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

//
// IEEE LLC and SNAP headers for an Ethernet frame
//
const BYTE IeeeEnetHeaders[] = {
    SNAP_DSAP,      // DSAP - 0xaa
    SNAP_SSAP,      // SSAP - 0xaa
    LLC_DGRAM,      // control - 3
    0, 0, 0         // org code
};

//
// Maximum length of the transmit and receive queue.
//
UINT cfgXmitQLength = 8;
UINT cfgRecvQLength = 10;

//
// Enet system shutdown notification routine
//
PRIVATE BOOL EnetShutdownNotifyRegistered;
PRIVATE HAL_SHUTDOWN_REGISTRATION EnetShutdownNotification;


PRIVATE VOID
EnetTransmitPacket(
    IfEnet* ifp,
    Packet* pkt,
    const BYTE* dsthwaddr
    )

/*++

Routine Description:

    Transmit an IP datagram to the Ethernet interface

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the packet to be transmitted
    dsthwaddr - Specifies the destination Ethernet hardware address

Return Value:

    NONE

--*/

{
    EnetFrameHeader* enethdr;

    //
    // We assume that the outgoing packet has enough free
    // space before the data buffer to hold the Ethernet frame header.
    //
    ASSERT(PktSpaceBefore(pkt) >= ENETHDRLEN);

    pkt->data -= ENETHDRLEN;
    pkt->datalen += ENETHDRLEN;

    // Now slap on the Ethernet frame header and send it out
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    CopyMem(enethdr->dstaddr, dsthwaddr, ENETADDRLEN);
    CopyMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN);
    
    enethdr->etherType = HTONS(ENETTYPE_IP);
    NicTransmitFrame(ifp, pkt);
}


VOID
EnetReceiveFrame(
    IfEnet* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Process a received Ethernet frame

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    EnetFrameHeader* enethdr;
    WORD etherType;

    // We assume the whole frame fits inside a single Packet
    // and the packet data length is validated by the NIC functions.
    // We also assume the Ethernet frame header starts on
    // a WORD-aligned boundary.
    ASSERT(pkt->datalen >= ENETHDRLEN + ENET_MINDATASIZE &&
           pkt->datalen <= ENETHDRLEN + ENET_MAXDATASIZE);

    // Peel off the Ethernet frame header
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    pkt->data += ENETHDRLEN;
    pkt->datalen -= ENETHDRLEN;
    etherType = NTOHS(enethdr->etherType);

    // Peel off the IEEE 802.3 LLC and SNAP headers if necessary
    if (IsIEEE802Frame(etherType)) {
        IEEE802Header* ieeehdr = GETPKTDATA(pkt, IEEE802Header);
        pkt->data += IEEE802HDRLEN;
        pkt->datalen -= IEEE802HDRLEN;

        // If the IEEE frame wasn't meant for us, discard it.
        if (!EqualMem(ieeehdr, IeeeEnetHeaders, IEEE802HDRLEN))
            goto discard;

        etherType = NTOHS(ieeehdr->etherType);
    }

    if (etherType == ENETTYPE_IP) {
        // Was the frame received as a broadcast or multicast?
        if (IsEnetAddrMcast(enethdr->dstaddr))
            pkt->pktflags |= PKTFLAG_MCAST;

        // Pass the received frame up to the IP layer and return
        IPRECEIVEPACKET(pkt);
        return;
    }
    
    if (etherType == ENETTYPE_ARP) {
        if (EqualMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN)) {
            // If an ARP packet was receive and the source address
            // was the same as ours, then we have an Ethernet
            // address conflict. We assume we don't receive
            // our own transmissions.
            WARNING_("Ethernet address conflict: db %x!", enethdr);
            ASSERT(FALSE);
        } else {
            // Process incoming ARP packets
            ArpReceivePacket(ifp, pkt);
            return;
        }
    }

discard:
    // Ethernet frame wasn't recognized; quietly discard it.
    COMPLETEPACKET(pkt, NETERR_DISCARDED);
}


VOID
EnetStartOutput(
    IfEnet* ifp
    )

/*++

Routine Description:

    Start output on the Ethernet interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    Packet* pkt;
    ArpCacheEntry* arpEntry;
    NTSTATUS status;
    IPADDR nexthop;

    // Must be called at DISPATCH_LEVEL.
    ASSERT_DISPATCH_LEVEL();

    //
    // Remove the packet at the head of the output queue
    // NOTE: We need to make sure we don't flood the NIC's command queue.
    // 
    while (!PktQIsEmpty(&ifp->sendq) && !NicIsXmitQFull(ifp)) {
        pkt = IfDequeuePacket(ifp);

        nexthop = pkt->nexthop;
        if (IfBcastAddr(ifp, nexthop)) {
            // Broadcast packet
            // NOTE: We assume broadcast loopback is handled in the upper layer.
            if (IfUp(ifp)) {
                EnetTransmitPacket(ifp, pkt, EnetBroadcastAddr);
                continue;
            }
            status = NETERR_NETDOWN;
        } else if (IS_MCAST_IPADDR(nexthop)) {
            // Multicast packet
            // NOTE: We assume multicast loopback is handled in the upper layer.
            if (IfUp(ifp)) {
                BYTE mcastaddr[ENETADDRLEN];
                EnetGenerateMcastAddr(nexthop, mcastaddr);
                EnetTransmitPacket(ifp, pkt, mcastaddr);
                continue;
            }
            status = NETERR_NETDOWN;
        } else {
            // Unicast packet
            // Otherwise, resolve the nexthop IP address to Ethernet address
            if (!IfRunning(ifp)) {
                // Can't send unicast message if the interface is inactive
                status = NETERR_NETDOWN;
            } else if ((arpEntry = ArpFindCacheEntry(ifp, nexthop, RESOLVE_SEND_REQUEST)) == NULL) {
                status = NETERR_MEMORY;
            } else if (IsArpEntryOk(arpEntry)) {
                // Found a valid existing entry in the ARP cache
                // for the next hop address
                EnetTransmitPacket(ifp, pkt, arpEntry->enetaddr);
                continue;
            } else if (IsArpEntryBad(arpEntry)) {
                // Found an existing entry for the next hop address
                // but the entry indicates the target is unreachable.
                status = NETERR_UNREACHABLE;
            } else {
                // Created a new entry for the next hop address
                // or found an existing entry that's currently being resolved
                ASSERT(IsArpEntryBusy(arpEntry));
                PktQInsertTail(&arpEntry->waitq, pkt);
                continue;
            }
        }

        // Complete the packet with error status and move on
        VERBOSE_("Failed to send packet: 0x%x", status);
        COMPLETEPACKET(pkt, status);
    }
}


PRIVATE VOID
EnetDelete(
    IfEnet* ifp
    )

/*++

Routine Description:

    Delete the Ethernet interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    IFENET_DELETE_CHECK(ifp);
    if (ifp->refcount) return;

    // Unregister shutdown notification routine
    if (EnetShutdownNotifyRegistered) {
        HalRegisterShutdownNotification(&EnetShutdownNotification, FALSE);
        EnetShutdownNotifyRegistered = FALSE;
    }

    // Make sure the NIC is stopped
    ifp->flags &= ~(IFFLAG_UP|IFFLAG_RUNNING);
    NicReset(ifp, TRUE);

    // Cleanup the send queue
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    ArpCleanup(ifp);
    NicCleanup(ifp);
    SysFree(ifp);
}


PRIVATE VOID
EnetShutdownNotifyProc(
    HAL_SHUTDOWN_REGISTRATION* param
    )

/*++

Routine Description:

    Notification routine that's called during system shutdown

Arguments:

    param - Shutdown notification parameters

Return Value:

    NONE

--*/

{
    KIRQL irql = RaiseToDpc();
    IfEnet* ifp = (IfEnet*) LanIfp;

    // Make sure the NIC is stopped
    ifp->flags &= ~(IFFLAG_UP|IFFLAG_RUNNING);
    NicReset(ifp, TRUE);

    LowerFromDpc(irql);
}


PRIVATE VOID
EnetTimer(
    IfEnet* ifp
    )

/*++

Routine Description:

    Ethernet interface timer routine (called once a second)

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    if (IfUp(ifp)) {
        ArpTimerProc(ifp);
        NicTimerProc(ifp);
    }
}


PRIVATE NTSTATUS
EnetSetMcastAddrs(
    IfEnet* ifp
    )

/*++

Routine Description:

    Update the multicast filter on the NIC hardware

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    BYTE* addrs;
    UINT count;
    NTSTATUS status;

    RUNS_AT_DISPATCH_LEVEL

    count = ifp->mcastData->groupCount;
    if (count) {
        addrs = SysAlloc(count * ENETADDRLEN, PTAG_MCAST);
        if (addrs) {
            BYTE* p = addrs;
            IfMcastGroup* mcastgrp = ifp->mcastData->mcastGroups;
            UINT i;

            for (i=0; i < count; i++) {
                EnetGenerateMcastAddr(mcastgrp->mcastaddr, p);
                mcastgrp++;
                p += ENETADDRLEN;
            }
        } else {
            return NETERR_MEMORY;
        }
    } else {
        addrs = NULL;
    }

    status = NicSetMcastAddrs(ifp, addrs, count);
    SysFree(addrs);
    return status;
}


PRIVATE NTSTATUS
EnetIoctl(
    IfEnet* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )

/*++

Routine Description:

    Ethernet interface I/O control function

Arguments:

    ifp - Points to the interface structure
    ctlcode - Control code
    inbuf - Points to the input buffer
    inlen - Size of the input buffer
    outbuf - Points to the output buffer
    outlen - On entry, this contains the size of the output buffer
        On return, this is the actually number of output bytes

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    IPADDR ipaddr;
    KIRQL irql = RaiseToDpc();

    switch (ctlcode) {
    case IFCTL_SET_MCAST_ADDRS:
        //
        // Send multicast addresses down to the NIC
        //
        status = EnetSetMcastAddrs(ifp);
        break;

    case IFCTL_CHECK_ADDR_CONFLICT:
        //
        // Check for IP address conflict
        //
        ASSERT(inlen == IPADDRLEN);

        ipaddr = *((IPADDR*) inbuf);
        ASSERT(XnetIsValidUnicastAddr(ipaddr));
        
        ifp->checkConflictAddr = ipaddr;
        status = ipaddr ? ArpSendRequest(ifp, ipaddr, ipaddr) : NETERR_OK;
        break;

    default:
        status = NETERR_NOTIMPL;
        break;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
EnetInitialize(
    IfInfo** newifp
    )

/*++

Routine Description:

    Initialize the Ethernet interface.

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    IfEnet* ifp;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // Check if the debug monitor has already initialized the enet interface
    #pragma warning(disable:4055)
    CHECK_DBGMON_ENETINFO();

    #ifdef DVTSNOOPBUG
    status = XnetUncachedPoolInit();
    if (!NT_SUCCESS(status)) return NETERR_MEMORY;
    #endif

    // Allocate memory to hold our interface structure

    ifp = SysAlloc0(sizeof(IfEnet), PTAG_ENET);
    if (!ifp) return NETERR_MEMORY;
    ifp->refcount = 1;
    ifp->ifname = "Ethernet";
    ifp->magicCookie = 'TENE';

    // Interface functions
    ifp->Delete = (IfDeleteProc) EnetDelete;
    ifp->StartOutput = (IfStartOutputProc) EnetStartOutput;
    ifp->Timer = (IfTimerProc) EnetTimer;
    ifp->Ioctl = (IfIoctlProc) EnetIoctl;

    ifp->iftype = IFTYPE_ETHERNET;
    ifp->framehdrlen = ENETHDRLEN;
    ifp->mtu = ENET_MAXDATASIZE;

    // Initialize the NIC interface
    status = NicInitialize(ifp);
    if (!NT_SUCCESS(status)) goto failed;

    // Now mark the interface as fully initialized
    // and start handling interrupts.

    ifp->flags |= IFFLAG_UP |
                  IFFLAG_DHCP_ENABLED |
                  IFFLAG_BCAST |
                  IFFLAG_MCAST;

    *newifp = (IfInfo*) ifp;
    IfSetIpAddr(*newifp, 0, 0);

    // Set the enet interface information in the process control block
    SET_DBGMON_ENETINFO(ifp);

    // Register shutdown notification routine
    EnetShutdownNotification.NotificationRoutine = EnetShutdownNotifyProc;
    HalRegisterShutdownNotification(&EnetShutdownNotification, TRUE);
    EnetShutdownNotifyRegistered = TRUE;

    NicEnableInterrupt();
    return NETERR_OK;

failed:
    WARNING_("EnetInitialize failed: 0x%x", status);
    EnetDelete(ifp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\i82558.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    i82558.h

Abstract:

    Intel 82558 NIC hardware related declarations

Revision History:

    05/07/2000 davidx
        Created it.

--*/

#ifndef _82558_H
#define _82558_H

//
// Vendor and device IDs for EPRO100+
//
#define NIC_VENDORID 0x8086
#define NIC_DEVICEID 0x1229

//------------------------------------------------------------------------
// I82558 command/status registers
//------------------------------------------------------------------------

typedef struct _NIC_CSR {
    BYTE cusRus;
        // CU and RU status
        // Bit 7-6: CUS - CU status field
        //  00 - idle
        //  01 - suspended
        //  10 - active
        //  11 - * (reserved)
        // Bit 5-2: RUS - RU status field
        //  0000 - idle
        //  0001 - suspended
        //  0010 - no resources
        //  0011 - *
        //  0100 - ready
        //  0101 - *
        //  0110 - *
        //  0111 - *
        //  1000 - *
        //  1001 - suspended with no more RBDs
        //  1010 - No resources due to no more RBDs
        //  1011 - *
        //  1100 - ready with no RBDs present
        //  1101 - *
        //  1110 - *
        //  1111 - *
        // Bit 1-0: reserved

    #define SCB_STAT_CUS(x) (((x) >> 6) & 3)
    #define   CUS_IDLE          0
    #define   CUS_SUSPENDED     1
    #define   CUS_ACTIVE        2
    #define SCB_STAT_RUS(x) (((x) >> 2) & 0xf)
    #define   RUS_IDLE          0
    #define   RUS_SUSPENDED     1
    #define   RUS_NORES         2
    #define   RUS_READY         4
    #define   RUS_SUSPENDED_RBD 9
    #define   RUS_NORES_RBD     10
    #define   RUS_READY_RBD     12

    BYTE statAck;
        // Interrupt status and acknowledgement bits
        // Bit 7: CX - CU finished executing a command with I-bit set
        // Bit 6: FR - RU finished receiving a frame
        // Bit 5: CNA - CU went from active to idle or suspended state
        // Bit 4: RNR - RU left ready state
        // Bit 3: MDI - MDI read or write cycle is done
        // Bit 2: SWI - software generated an interrupt
        // Bit 1: reserved
        // Bit 0: FCP - flow control pause interrupt bit

    #define SCB_STAT_CX     BIT(7)
    #define SCB_STAT_FR     BIT(6)
    #define SCB_STAT_CNA    BIT(5)
    #define SCB_STAT_RNR    BIT(4)
    #define SCB_STAT_MDI    BIT(3)
    #define SCB_STAT_SWI    BIT(2)
    #define SCB_STAT_FCP    BIT(0)

    BYTE cucRuc;
        // Bit 7-4: CUC - CU command field
        //  0000 - NOP
        //  0001 - CU start
        //  0010 - CU resume
        //  0011 - *
        //  0100 - load dump counters address
        //  0101 - dump statistical counters
        //  0110 - load CU base
        //  0111 - dump and reset statistical counters
        //  1000 - *
        //  1001 - *
        //  1010 - static resume
        //  1011 - *
        //  ...
        //  1111 - *
        // Bit 3: reserved
        // Bit 2-0: RU command field
        //  000 - NOP
        //  001 - RU start
        //  010 - RU resume
        //  011 - RU DMA redirect
        //  100 - RU abort
        //  101 - load header data size
        //  110 - load RU base
        //  111 - RBD resume

    #define CUC_NOP             (0 << 4)
    #define CUC_START           (1 << 4)
    #define CUC_RESUME          (2 << 4)
    #define CUC_LOAD_DUMP_ADDR  (4 << 4)
    #define CUC_DUMP_STAT       (5 << 4)
    #define CUC_LOAD_CU_BASE    (6 << 4)
    #define CUC_DUMP_RESET_STAT (7 << 4)
    #define CUC_STATIC_RESUME   (10 << 4)

    #define RUC_NOP             0
    #define RUC_START           1
    #define RUC_RESUME          2
    #define RUC_RCVDMA_REDIRECT 3
    #define RUC_ABORT           4
    #define RUC_LOAD_HDS        5
    #define RUC_LOAD_RU_BASE    6
    #define RUC_RBD_RESUME      7

    BYTE intrMask;
        // Bit 7: CX interrupt mask bit
        // Bit 6: FR interrupt mask bit
        // Bit 5: CNA interrupt mask bit
        // Bit 4: RNR interrupt mask bit
        // Bit 3: ER interrupt mask bit
        // Bit 2: FCP interrupt mask bit
        // Bit 1: SI - software interrupt request
        // Bit 0: M - global interrupt mask

    #define CX_INTR_BIT     BIT(7)
    #define FR_INTR_BIT     BIT(6)
    #define CNA_INTR_BIT    BIT(5)
    #define RNR_INTR_BIT    BIT(4)
    #define ER_INTR_BIT     BIT(3)
    #define FCP_INTR_BIT    BIT(2)
    #define SW_INTR_BIT     BIT(1)
    #define INTR_MASK_BIT   BIT(0)

    DWORD scbGeneralPtr;
        // SCB general pointer

    DWORD port;
        // PORT interface
        // Bit 31-4: address bits
        // Bit 3-0: port function selection
        //  0000 - software reset
        //  0001 - self-test
        //  0010 - selective reset
        //  0011 - dump
        //  0100 - *
        //  ...
        //  1111 - *

    #define PORTCMD_SOFTWARE_RESET  0
    #define PORTCMD_SELF_TEST       1
    #define PORTCMD_SELECTIVE_RESET 2
    #define PORTCMD_DUMP            3

    WORD flashCtrl;
        // Flash control register

    WORD eepromCtrl;
        // EEPROM control register
        // Bit 7-4: reserved
        // Bit 3: EEDO - data out
        // Bit 2: EEDI - data in
        // Bit 1: EECS - chip select
        // Bit 0: EESK - serial clock

    #define EEPROM_DO   BIT(3)
    #define EEPROM_DI   BIT(2)
    #define EEPROM_CS   BIT(1)
    #define EEPROM_SK   BIT(0)

    #define EEPROMOP_WRITE  1
    #define EEPROMOP_READ   2

    DWORD mdiCtrl;
        // MDI control register
        // Bit 31-30: reserved
        // Bit 29: interrupt enable
        // Bit 28: ready
        // Bit 27-26: opcode
        //  00 - *
        //  01 - MDI write
        //  10 - MDI read
        //  11 - *
        // Bit 25-21: PHY address
        // Bit 20-16: PHY register address
        // Bit 15-0: data field

    #define MDI_INTR_ENABLE     BIT(29)
    #define MDI_READY           BIT(28)
    #define MDIOP_WRITE         (1 << 26)
    #define MDIOP_READ          (2 << 26)
    #define MDI_PHY_ADDR(x)     ((x) << 21)
    #define MDI_PHY_REG_ADDR(x) ((x) << 16)

    DWORD reserved1;
    DWORD reserved2;
        // Bit 31-24: PMDR - power management driver register
        // Bit 23-8: flow control register
        // Bit 7-0: reserved
} volatile *PNIC_CSR;

extern PNIC_CSR NicCsr;

//------------------------------------------------------------------------
// 82558 general action command format
// NOTE: We store this information in the Packet.ifdata field
// of an outgoing packet. And it's tail-aligned so that it's
// contiguous with the packet data field.
//------------------------------------------------------------------------

typedef struct _ActionCmdBlock {
    DWORD cmdstatus;
        // Command and status:
        //  bit 31 (EL) - end of command block list
        //  bit 30 (S) - suspend after command completion
        //  bit 29 (I) - interrupt after command completion
        //  bit 28-19 - varies with different commands
        //  bit 18-16 (CMD) - command code
        //  bit 15 (C) - command completed
        //  bit 14 - reserved
        //  bit 13 - command executed ok
        //  bit 12-0 - varies with different commands

    #define CMDFLAG_EL          BIT(31)
    #define CMDFLAG_S           BIT(30)
    #define CMDFLAG_I           BIT(29)

    #define ACTIONCMD_NOP       (0 << 16)
    #define ACTIONCMD_IA_SETUP  (1 << 16)
    #define ACTIONCMD_CONFIGURE (2 << 16)
    #define ACTIONCMD_MC_SETUP  (3 << 16)
    #define ACTIONCMD_TRANSMIT  (4 << 16)
    #define ACTIONCMD_DUMP      (6 << 16)
    #define ACTIONCMD_DIAGNOSE  (7 << 16)

    #define CMDSTATUS_C         BIT(15)
    #define CMDSTATUS_OK        BIT(13)

    DWORD link;
        // link to the next command block in the list
        //  this is a physical address
        //  use 0xffffffff at the end of the list

    #define LINK_OFFSET_NULL 0xffffffff

} ActionCmdBlock;

//------------------------------------------------------------------------
// Transmit command block (TxCB)
//------------------------------------------------------------------------

typedef struct _TransmitCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
        // Additional command and status flags:
        //  bit 20 (NC) - no CRC and source address insertion
        //  bit 19 (SF) - simple or flexible mode
        //  bit 12 (U) - transmit underrun encountered

    #define TxCBFLAG_NC     BIT(20)
    #define TxCBFLAG_SF     BIT(19)

    #define TxCBSTATUS_U    BIT(12)

    DWORD tbdArray;
        // in flexible mode, physical address of the TBD array

    WORD byteCount;
        // bit 15 (EOF) - whole frame is kept inside the command block itself
        // bit 14 - reserved
        // bit 13-0: amount of data in the transmit command block itself

    #define TxCB_EOF        BIT(15)

    BYTE txThreshold;
        // number of bytes that should be present in the Tx FIFO
        // before it starts transmitting the frame

    BYTE tbdNumber;
        // in flexible mode, represent the number of transmit buffers
        // in the TBD array
} TransmitCmdBlock;

//
// Early transmit threshold
//  This number is multiplied by 8 to get the actual byte count.
//  BOGUS: Not sure why w2k driver uses such a high value which
//  basically disables the early transmit feature.
//
#define DEFAULT_Tx_THRESHOLD 200

//
// Maximum number of TBD's for transmitting a single packet.
// This is not a hardware limit. Rather it's an arbitrary software
// limit we set. When there are two many fragments for a single
// packet, something upstream must be pretty bad and it's better
// to address the real issues there.
//
#define MAX_TBD_PER_XMIT 4

//
// TBD (Transmit Buffer Descriptor) entry
//
typedef struct _TBDEntry {
    DWORD bufaddr;
        // physical address of the buffer data

    DWORD bufsize;
        // bit 31-16: reserved
        // bit 15 (EL): end of the TBD array
        // bit 14: reserved
        // bit 13-0: buffer size (in bytes)
} TBDEntry;

//------------------------------------------------------------------------
// Multicast setup command block
//------------------------------------------------------------------------

typedef struct _McastSetupCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
    
    WORD mcastCount;
        // Number of multicast addresses to follow
    
    BYTE mcastAddrs[ENETADDRLEN];
        // variable number of Ethernet multicast addresses
} McastSetupCmdBlock;

//------------------------------------------------------------------------
// Individual address setup command block
//------------------------------------------------------------------------

typedef struct _IASetupCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link

    BYTE hwaddr[ENETADDRLEN];
        // Individual address
} IASetupCmdBlock;

//------------------------------------------------------------------------
// Configure command block
//------------------------------------------------------------------------

typedef struct _ConfigCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link

    // Maximum number of configuration parameters
    #define CONFIG_PARAM_COUNT 22

    BYTE params[CONFIG_PARAM_COUNT];
        // Configuration parameters
} ConfigCmdBlock;

//------------------------------------------------------------------------
// Receive frame descriptor (RFD)
//------------------------------------------------------------------------

typedef struct _RecvFrameDesc {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
        // Additional command and status flags:
        //  bit 20 (H) - indicate this RFD is a Header RFC
        //  bit 19 (SF) - simple or flexible mode
        //
        //  bit 11 - CRC error in an aligned frame
        //  bit 10 - alignment error (number of bits is not 8x)
        //  bit 9 - ran out of buffer space - no resources
        //  bit 8 - DMA overrun - failed to acquire the system bus
        //  bit 7 - frame too short
        //  bit 5 - type/length: 1 for Ethernet frame, 0 for 802.3 frame
        //  bit 4 - receive error
        //  bit 2 - no address match
        //  bit 1 - IA match bit
        //  bit 0 - receive collision
    
    #define RFDFLAG_H   BIT(20)
    #define RFDFLAG_SF  BIT(19)

    #define RFDSTATUS_CRC_ERROR     BIT(11)
    #define RFDSTATUS_ALIGN_ERROR   BIT(10)
    #define RFDSTATUS_NO_BUFFER     BIT(9)
    #define RFDSTATUS_DMA_OVERRUN   BIT(8)
    #define RFDSTATUS_SHORT_FRAME   BIT(7)
    #define RFDSTATUS_ENET_FRAME    BIT(5)
    #define RFDSTATUS_RECV_ERROR    BIT(4)
    #define RFDSTATUS_NOADDR_MATCH  BIT(2)
    #define RFDSTATUS_IA_MATCH      BIT(1)
    #define RFDSTATUS_COLLISION     BIT(0)

    DWORD rbdAddr;
        // only used in flexible mode
        // address of RBD (receive buffer descriptor)
    
    WORD actualCount;
        // bit 15 (EOF): set by 82558 when it writes data into the data area
        // bit 14 (F): set by 82558 when it updates the actualCount field
        // bit 13-0: number of bytes written into the data area

    #define RFD_EOF     BIT(15)
    #define RFD_F       BIT(14)
    #define RFD_CNTMASK 0x3fff

    WORD size;
        // bit 15-14: reserved
        // bit 13-0: size of the data buffer
} RecvFrameDesc;

//------------------------------------------------------------------------
// 82558 Statistical Counters
//------------------------------------------------------------------------

typedef struct _NicStatCounters {
    DWORD xmitGoodFrames;
    DWORD xmitMaxCollisionsErrors;
    DWORD xmitLateCollisionsErrors;
    DWORD xmitUnderrunErrors;
    DWORD xmitLostCarrierSense;
    DWORD xmitDeferred;
    DWORD xmitSingleCollisions;
    DWORD xmitMultipleCollisions;
    DWORD xmitTotalCollisions;
    DWORD recvGoodFrames;
    DWORD recvCrcErrors;
    DWORD recvAlignmentErrors;
    DWORD recvResourceErrors;
    DWORD recvOverrunErrors;
    DWORD recvCollisionDetectErrors;
    DWORD recvShortFrameErrors;
    DWORD dumpCompletionStatus;
} NicStatCounters;


//
// We allocate a page of physically contiguous memory that's shared by
// the CPU and the NIC. This buffer is used for storing action command
// data (e.g. transmit command block and transmit buffer descriptor)
// that's passed to the NIC.
//
//  start  head        tail         last
//   |      |           |           |
//   v      v           v           v
//  |       xxxxxxxxxxxx           |
//
// Note that we always leave at least one unit empty in the buffer.
// If head = tail, that means the whole buffer is empty.
//
typedef struct _NicCmdBuffer {
    BYTE* start;        // buffer base virtual address
    BYTE* last;         // points to after the buffer
    BYTE* head;         // points to the first busy entry
    BYTE* tail;         // points to the first free entry
    UINT phyaddrOffset; // offset between virtual and physical address
} NicCmdBuffer;

// The smallest allocation unit is 8 bytes.
#define CMDBUF_ALLOC_UNIT 8

// Map virtual command buffer address to physical address
#define CmdBufferGetPhyAddr(nic, p) \
        ((UINT_PTR) (p) + (nic)->cmdbuf.phyaddrOffset)

//
// Extra header information at the beginning of the DMA packet
// that's used by the NIC for receiving frames:
//  receive frame descriptor
//
#define RECVPKT_OVERHEAD sizeof(RecvFrameDesc)

//
// Allocate shared memory buffers for the NIC
//
#define NicAllocSharedMem(size) MmAllocateContiguousMemory(size)
#define NicFreeSharedMem(p) MmFreeContiguousMemory(p)

//
// Disable and enable NIC interrupts
//
INLINE VOID NicDisableInterrupt() {
    NicCsr->intrMask = INTR_MASK_BIT;
}

INLINE VOID NicEnableInterrupt() {
    NicCsr->intrMask = 0;
}

#endif // !_82558_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\arp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    arp.c

Abstract:

    Handles the ARP protocol

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Global ARP configuration info:
//  ARP cache entry timeout value (in seconds)
//  # of ARP cache entries per-interface
//  # of retries for ARP requests
//
UINT cfgPositiveArpCacheTimeout = POSITIVE_ARP_CACHE_TIMEOUT;
UINT cfgNegativeArpCacheTimeout = NEGATIVE_ARP_CACHE_TIMEOUT;
UINT cfgArpRequestRetries = ARP_REQUEST_RETRIES;


NTSTATUS
ArpSendPacket(
    IfEnet* ifp,
    WORD op,
    IPADDR tpa,
    IPADDR spa,
    const BYTE* tha
    )

/*++

Routine Description:

    Send out an ARP packet

Arguments:

    ifp - Points to the interface structure
    op - opcode: ARP_REQUEST or ARP_REPLY
    tpa - Specifies the target IP address
    spa - Specifies the source IP address
    tha - Sppecifies the target hardware address
        NULL when opcode is ARP_REQUEST

Return Value:

    Status code

--*/

{
    Packet* pkt;
    EnetFrameHeader* enethdr;
    ArpPacket* arppkt;
    UINT size = ENETHDRLEN + ARPPKTLEN;

    // Allocate memory for the packet
    pkt = XnetAllocPacket(size, PKTFLAG_NETPOOL);
    if (!pkt) return NETERR_MEMORY;
    pkt->datalen = size;

    // Fill out Ethernet header
    //  assume pkt->data is DWORD-aligned initially
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    CopyMem(enethdr->dstaddr, tha ? tha : EnetBroadcastAddr, ENETADDRLEN);
    CopyMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN);
    enethdr->etherType = HTONS(ENETTYPE_ARP);
    
    // Fill out the ARP request packet
    arppkt = (ArpPacket*) (enethdr+1);
    arppkt->hrd = HTONS(ARP_HWTYPE_ENET);
    arppkt->pro = HTONS(ENETTYPE_IP);
    arppkt->hln = ENETADDRLEN;
    arppkt->pln = IPADDRLEN;
    arppkt->op = HTONS(op);
    CopyMem(arppkt->sha, ifp->hwaddr, ENETADDRLEN);
    arppkt->spa = spa;
    arppkt->tpa = tpa;
    if (tha) {
        CopyMem(arppkt->tha, tha, ENETADDRLEN);
    } else {
        ZeroMem(arppkt->tha, ENETADDRLEN);
    }

    NicTransmitFrame(ifp, pkt);
    return NETERR_OK;
}


ArpCacheEntry*
ArpFindCacheEntry(
    IfEnet* ifp,
    IPADDR ipaddr,
    INT resolve
    )

/*++

Routine Description:

    Resolve the specified target IP address to an ARP cache entry.
    If no existing entry is found, then:
    - if resolve is RESOLVE_NONE, we'll simple return NULL;
    - if resolve is RESOLVE_CREATE_ENTRY, we'll try to make a new entry
      for the specified address and return it to the caller;
    - if resolve is RESOLVE_SEND_REQUEST, we'll create the entry
      as well as send out a ARP request packet.

Arguments:

    ifp - Points to the interface structure
    ipaddr - Specifies the target address
    resolve - What to do if no existing entry is found

Return Value:

    ARP cache entry for the specified IP address
    NULL if there is an error

--*/

// Not a terribly fancy hash function
// but it should serve our purpose.
#define ARPHASH(_addr) ((_addr) % ARP_HASH_MODULO)

{
    ArpCacheEntry* arpEntry;
    ArpCacheEntry* retryEnd;
    ArpCacheEntry* hashEntry;
    UINT hash;

    RUNS_AT_DISPATCH_LEVEL
    ASSERT(XnetIsValidUnicastAddr(ipaddr));

    // Fast check
    if (ipaddr == ifp->lastArpAddr)
        return ifp->lastArpEntry;

    // Get the hash bucket for the specified address
    hash = ARPHASH(ipaddr);
    arpEntry = &ifp->arpCache[hash];

    // Found the target address in the cache via a direct hash hit
    if (arpEntry->ipaddr == ipaddr) {
found:
        ifp->lastArpAddr = ipaddr;
        return (ifp->lastArpEntry = arpEntry);
    }

    // No direct hash hit, try linear search
    hashEntry = arpEntry;
    retryEnd = arpEntry + ARP_HASH_RETRY;
    while (++arpEntry < retryEnd) {
        if (arpEntry->ipaddr == ipaddr) goto found;
    }

    if (resolve == RESOLVE_NONE)
        return NULL;

    //
    // The target IP address is not in the cache:
    //  send out an ARP request if specified;
    //  and make a new cache entry for the target
    //
    
    // Check to see if the hack bucket is free
    arpEntry = hashEntry;
    if (!IsArpEntryFree(arpEntry)) {
        while (++arpEntry < retryEnd) {
            if (IsArpEntryFree(arpEntry)) break;
        }
        
        // Couldn't find a free entry
        //  fall back and try to find a non-busy entry
        if (arpEntry == retryEnd) {
            arpEntry = hashEntry;
            while (++arpEntry < retryEnd) {
                if (!IsArpEntryBusy(arpEntry)) break;
            }

            if (arpEntry == retryEnd) {
                // Too bad: couldn't find either a free or non-busy entry
                //  emit a warning and give up
                WARNING_("ARP cache collision error");
                return NULL;
            }

            // This entry is currently used for another address:
            // we'll just bump it off here.
            VERBOSE_("Bumped ARP entry for %s", IPADDRSTR(arpEntry->ipaddr));
            ifp->arpCacheCount--;
        }
    }

    TRACE_("Add ARP entry for %s", IPADDRSTR(ipaddr));
    arpEntry->ipaddr = ipaddr;
    ASSERT(PktQIsEmpty(&arpEntry->waitq));

    if (resolve == RESOLVE_SEND_REQUEST) {
        arpEntry->state = ARPST_BUSY;
        arpEntry->timer = cfgArpRequestRetries;
        ArpSendRequest(ifp, ipaddr, ifp->ipaddr);
    } else {
        // NOTE: we mark the entry free here
        // It'll be immediately marked as OK in ArpReceivePacket
        // after this function returns.
        arpEntry->state = ARPST_FREE;
    }

    ifp->arpCacheCount++;
    goto found;
}


VOID
ArpTimerProc(
    IfEnet* ifp
    )

/*++

Routine Description:

    ARP timer routine

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    ArpCacheEntry* arpEntry;
    INT index;

    // Quick check: do nothing if all entries are free
    if (ifp->arpCacheCount == 0) return;
    ASSERT(ifp->arpCacheCount > 0);

    // Loop through all cache entries
    for (index=0; index < ARP_CACHE_SIZE; index++) {
        arpEntry = &ifp->arpCache[index];
        if (arpEntry->state == ARPST_FREE) continue;

        switch (arpEntry->state) {
        case ARPST_BUSY:
            //
            // The entry is currently being resolved
            //
            if (--arpEntry->timer == 0) {
                //
                // And the entry has expired:
                //  mark the entry as bad and complete any waiting packet
                //  with error status
                //
                arpEntry->state = ARPST_BAD;
                arpEntry->timer = cfgNegativeArpCacheTimeout;

                while (!PktQIsEmpty(&arpEntry->waitq)) {
                    Packet* pkt = PktQRemoveHead(&arpEntry->waitq);
                    COMPLETEPACKET(pkt, NETERR_UNREACHABLE);
                }
            } else {
                //
                // Timeout while waiting for ARP reply:
                //  retransmit the ARP request frame
                //
                ArpSendRequest(ifp, arpEntry->ipaddr, ifp->ipaddr);
            }
            break;
        
        case ARPST_OK:
        case ARPST_BAD:
            if (--arpEntry->timer == 0) {
                //
                // If the entry has expired, remove it from the cache
                //
                TRACE_("ARP entry for %s timed out", IPADDRSTR(arpEntry->ipaddr));

                // Reset the last ARP lookup info if applicable.
                if (arpEntry == ifp->lastArpEntry) {
                    ifp->lastArpAddr = 0;
                    ifp->lastArpEntry = NULL;
                }

                ZeroMem(arpEntry, sizeof(*arpEntry));
                ifp->arpCacheCount--;
            }
            break;
        }
    }
}


VOID
ArpReceivePacket(
    IfEnet* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Process an incoming ARP packet

Arguments:

    ifp - Points to the interface structure
    pkt - The received ARP packet

Return Value:

    NONE

--*/

{
    ArpPacket* arppkt = GETPKTDATA(pkt, ArpPacket);
    WORD op;
    IPADDR spa, tpa;
    ArpCacheEntry* arpEntry;
    INT resolve;
    BYTE sha[ENETADDRLEN];

    ASSERT(pkt->datalen >= ARPPKTLEN);

    op = NTOHS(arppkt->op);
    spa = arppkt->spa;
    tpa = arppkt->tpa;

    // Simple sanity check
    if (arppkt->hrd != HTONS(ARP_HWTYPE_ENET) &&
        arppkt->hrd != HTONS(ARP_HWTYPE_802) ||
        arppkt->pro != HTONS(ENETTYPE_IP) ||
        arppkt->hln != ENETADDRLEN ||
        arppkt->pln != IPADDRLEN ||
        op != ARP_REQUEST && op != ARP_REPLY ||
        !XnetIsValidUnicastAddr(spa) ||
        !XnetIsValidUnicastAddr(tpa)) {
        goto exit;
    }

    // Check to see if we have an existing entry for the sender
    // in our ARP cache. If we're the target and there is no
    // existing entry, then we'll create a new entry.
    // This assumes that communication will likely be bidirectional.

    if (spa == ifp->ipaddr || spa == ifp->checkConflictAddr) {
        if (IfDhcpEnabled(ifp)) {
            ifp->checkConflictAddr = 0;
            DhcpNotifyAddressConflict((IfInfo*) ifp);
        }

        // In case the other case is checking for address conflict,
        // send out a reply to indicate we already have the address.
        if (tpa == ifp->ipaddr && op == ARP_REQUEST) {
            ArpSendReply(ifp, spa, arppkt->sha);
        }
        goto exit;
    } else if (!IfRunning(ifp)) {
        goto exit;
    }

    CopyMem(sha, arppkt->sha, ENETADDRLEN);
    resolve = (tpa == ifp->ipaddr) ? RESOLVE_CREATE_ENTRY : RESOLVE_NONE;
    
    // We should return the incoming packet structure
    // back to the Enet driver as soon as possible.
    COMPLETEPACKET(pkt, NETERR_OK);
    arpEntry = ArpFindCacheEntry(ifp, spa, resolve);

    if (arpEntry) {
        arpEntry->state = ARPST_OK;
        arpEntry->timer = cfgPositiveArpCacheTimeout;
        CopyMem(arpEntry->enetaddr, sha, ENETADDRLEN);

        // If there were packets waiting on this entry,
        // now that we have the address resolve, it's
        // time to start the transmission.
        //
        // NOTE: We insert the waiting packets at the head of
        // the interface's send queue. We're not calling
        // EnetTransmitPacket directly because we want to
        // limit the depth of the command queue (which is
        // done inside EnetStartOutput).

        if (!PktQIsEmpty(&arpEntry->waitq)) {
            PktQJoinBefore(&ifp->sendq, &arpEntry->waitq);
            PktQInit(&arpEntry->waitq);
            EnetStartOutput(ifp);
        }
    }
    
    // If we're the target and the packet is an ARP request,
    // then send out an ARP reply. Notice that we allocate a
    // new Packet here instead reusing the incoming packet.

    if (tpa == ifp->ipaddr && op == ARP_REQUEST) {
        ArpSendReply(ifp, spa, sha);
    }
    return;

exit:
    // Return the packet to the caller
    COMPLETEPACKET(pkt, NETERR_DISCARDED);
}


VOID
ArpCleanup(
    IfEnet* ifp
    )

/*++

Routine Description:

    Clean up ARP related data

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    ArpCacheEntry* arpEntry;
    Packet* pkt;
    INT index;

    // Loop thru all cache entries
    for (index=0; index < ARP_CACHE_SIZE; index++) {
        arpEntry = &ifp->arpCache[index];
        arpEntry->state = ARPST_BAD;

        // Complete any packets waiting on the entry
        while (!PktQIsEmpty(&arpEntry->waitq)) {
            pkt = PktQRemoveHead(&arpEntry->waitq);
            COMPLETEPACKET(pkt, NETERR_CANCELLED);
        }
    }

    ifp->lastArpAddr = 0;
    ifp->lastArpEntry = NULL;
    ifp->arpCacheCount = 0;
    ZeroMem(&ifp->arpCache, sizeof(ifp->arpCache));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\i82558.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    82558.c

Abstract:

    Intel 82558 NIC related functions

Revision History:

    05/09/2000 davidx
        Created it.

    01/24/2000 davidx
        Moved into the kernel.

Note:

    We assume every NIC function here runs at DISPATCH_LEVEL
    unless noted otherwise.

--*/

#include "precomp.h"

#ifdef SILVER
#include <pci.h>


//
// NIC driver global variables
//
PNIC_CSR NicCsr;
BYTE* NicPktPoolBase;
UINT_PTR NicPktPoolPhyAddrOffset;
KINTERRUPT NicIntrObject;

// Forward declaration of local functions
PRIVATE VOID NicProcessRecvInterrupt(IfEnet* nic);
PRIVATE BOOL NicProcessXmitInterrupt(IfEnet* nic, BYTE statAck);

//
// Interlocked bit-wise AND and OR operations
//
INLINE __declspec(naked) VOID __fastcall InterlockedAND(DWORD* p, DWORD mask) {
    __asm and DWORD PTR [ecx], edx
    __asm ret
}

INLINE __declspec(naked) VOID __fastcall InterlockedOR(DWORD* p, DWORD mask) {
    __asm or DWORD PTR [ecx], edx
    __asm ret
}

//
// For an outgoing packet, we store the command block information
// associated with the packet in the Packet.ifdata field.
//  high word: offset to where the command block starts
//  low word: command block size
//
#define SetPktCmdBlk(nic, pkt, cmdblk, cmdsize) \
        (pkt)->ifdata = ((cmdsize) | (((BYTE*) (cmdblk) - (nic)->cmdbuf.start) << 16))

#define GetPktCmdBlk(nic, pkt) \
        ((ActionCmdBlock*) ((nic)->cmdbuf.start + ((pkt)->ifdata >> 16)))

#define GetPktCmdBlkSize(nic, pkt) ((pkt)->ifdata & 0xffff)

//
// For a received packet, the packet content after the the packet header is:
//  RecvFrameDesc - receive frame descriptor
//  Ethernet frame header
//  frame data
//
#define GetPktRFD(pkt) GETPKTBUF(pkt, RecvFrameDesc)
#define GetPktRFDPhy(pkt) NicPktGetPhyAddr((pkt)->buf)

//
// Lock and unlock the physical pages containing packet data
//
INLINE VOID NicLockPacketPages(Packet* pkt) {
    if (pkt->datalen) {
        MmLockUnlockBufferPages(pkt->data, pkt->datalen, FALSE);
    }
}

INLINE VOID NicUnlockPacketPages(Packet* pkt) {
    if (pkt->datalen) {
        MmLockUnlockBufferPages(pkt->data, pkt->datalen, TRUE);
    }
}


PRIVATE NTSTATUS
NicWaitScb(
    PNIC_CSR csr
    )

/*++

Routine Description:

    Wait for the low SCB command byte to be clear
    (before we can issue CU or RU commands)

Arguments:

    csr - Points to the 82558 CSR registers

Return Value:

    Status code

--*/

{
    // BOGUS: not sure where w2k driver got this 600ms number
    //  which seems an awfully long time to wait
    UINT timeout = 60000;

    while (timeout--) {
        if (csr->cucRuc == 0) return NETERR_OK;
        KeStallExecutionProcessor(10);
    }

    WARNING_("NicWaitScb failed!");
    return NETERR_HARDWARE;
}


PRIVATE NTSTATUS
NicExecuteActionCmdAndWait(
    IfEnet* nic,
    ActionCmdBlock* cmdblk,
    INT opcode
    )

/*++

Routine Description:

    Execute an action command and wait for its completion

Arguments:

    nic - Points to the NIC data structure
    cmdblk - Points to the action command data block
    opcode - Specifies the command opcode

Return Value:

    Status code

Note:

    This function should only be called when the command unit is idle
    and interrupts are disabled. It issues the command and busy-wait
    for the command to complete. It's intended to be called during
    initialization.

--*/

{
    NTSTATUS status;
    PNIC_CSR csr = nic->CSR;
    UINT timeout;

    // Wait until the command unit is ready to accept
    // a new command and then issue the command.
    cmdblk->cmdstatus = opcode | CMDFLAG_EL;
    cmdblk->link = LINK_OFFSET_NULL;
    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) return status;

    csr->scbGeneralPtr = CmdBufferGetPhyAddr(nic, cmdblk);
    csr->cucRuc = CUC_START;

    // Now wait for command completion
    //  BOGUS: seems to be an extremely long timeout period (3sec)
    timeout = 300000;
    while (!(cmdblk->cmdstatus & CMDSTATUS_C) && timeout--) {
        KeStallExecutionProcessor(10);
    }

    // Acknowledge any pending interrupts
    csr->statAck = csr->statAck;

    if (cmdblk->cmdstatus & CMDSTATUS_OK) return NETERR_OK;

    WARNING_("NicExecuteActionCmdAndWait failed!");
    return NETERR_HARDWARE;
}


PRIVATE NTSTATUS
NicDoIASetupCmd(
    IfEnet* nic
    )

/*++

Routine Description:

    Configure the individual address

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    // We assume the CU is idle and we can use
    // the entire shared command data buffer.
    IASetupCmdBlock* cmdblk = (IASetupCmdBlock*) nic->cmdbuf.start;

    CopyMem(cmdblk->hwaddr, nic->hwaddr, ENETADDRLEN);
    return NicExecuteActionCmdAndWait(nic, (ActionCmdBlock*) cmdblk, ACTIONCMD_IA_SETUP);
}


PRIVATE NTSTATUS
NicDoConfigureCmd(
    IfEnet* nic
    )

/*++

Routine Description:

    Configure the default 82558 operating parameters

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    // These values are copied directly from w2k driver.
    static const BYTE defaultParams[CONFIG_PARAM_COUNT] = {
        CONFIG_PARAM_COUNT,
        0x88, // 1: Tx and Rx FIFO limits
        0x00, // 2: no adaptive IFS
        0x01, // 3: MWI enable
        0x00, // 4: Rx DMA max count
        0x00, // 5: Tx DMA max count
        0x32, // 6: discard bad frames, extended stats, CNA intr, non-direct recv DMA
        0x03, // 7: 1 underrun retry, discard short frames
        0x01, // 8:
        0x00, // 9:
        0x2e, // 10: no loopback, 7 bytes preamble, no SA insertion
        0x00, // 11:
        0x60, // 12: inter-frame spacing (IFS) = 96 bit time
        0x00, // 13:
        0xf2, // 14:
        0xc8, // 15:
        0x00, // 16: 
        0x40, // 17:
        0xf2, // 18: padding enabled
        0x80, // 19: auto full-duplex
        0x3f, // 20:
        0x05  // 21:
    };

    // We assume the CU is idle and we can use
    // the entire shared command data buffer.
    ConfigCmdBlock* cmdblk = (ConfigCmdBlock*) nic->cmdbuf.start;

    CopyMem(cmdblk->params, defaultParams, CONFIG_PARAM_COUNT);
    return NicExecuteActionCmdAndWait(nic, (ActionCmdBlock*) cmdblk, ACTIONCMD_CONFIGURE);
}


PRIVATE NTSTATUS
NicCmdBufferInit(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the shared command data buffer

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    BYTE* buf;

    // Allocate a page and get its physical address
    buf = (BYTE*) NicAllocSharedMem(PAGE_SIZE);
    if (!buf) return NETERR_MEMORY;

    nic->cmdbuf.head = nic->cmdbuf.tail = nic->cmdbuf.start = buf;
    nic->cmdbuf.last = buf + PAGE_SIZE;
    nic->cmdbuf.phyaddrOffset = MmGetPhysicalAddress(buf) - (UINT_PTR) buf;

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicStartCommandUnit(
    IfEnet* nic,
    ActionCmdBlock* cmdblk
    )

/*++

Routine Description:

    Start the 82558 CU (command unit) if it's idle

Arguments:

    nic - Points to the NIC data structure
    cmdblk - Points to the action command data block

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = nic->CSR;
    INT cus = SCB_STAT_CUS(csr->cusRus);
    NTSTATUS status;

    // CU is active, do nothing
    if (cus != CUS_IDLE || (cmdblk->cmdstatus & CMDSTATUS_C))
        return NETERR_OK;

    // Wait for SCB and then issue CUC_START command
    status = NicWaitScb(csr);
    if (NT_SUCCESS(status)) {
        csr->scbGeneralPtr = CmdBufferGetPhyAddr(nic, cmdblk);
        csr->cucRuc = CUC_START;
    }
    return status;
}


PRIVATE VOID
NicEnqueueRecvBuffer(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Queue up a packet in the receive queue

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the packet to be queue

Return Value:

    NONE

Notes:

    We maintain a queue of buffers to try to always keep
    the 82558 receive unit (RU) ready. The buffers are
    allocated for DMA transfer.

    After a packet is received, we pass it up to upper
    layer protocols. Those protocols are expected to
    process the packet as soon as possible and return
    the packet back to us with a CompletePacket call.

    When a packet is returned to us by the upper layer
    protocols, we'll put the packet back to the receive
    queue (unless we already have enough packets in the queue).

--*/

{
    Packet* q;
    RecvFrameDesc* rfd;

    //
    // Initialize the packet header fields
    //
    rfd = GetPktRFD(pkt);
    pkt->nextpkt = NULL;
    pkt->pktflags = PKTFLAG_DMA;
    pkt->data = (BYTE*) (rfd+1);
    pkt->datalen = 0;

    //
    // Initialize the RFD structure, which is stored in the first
    // 16 bytes of the packet buffer is used to store the RFD structure.
    // Note that we always use the simple mode.
    //
    rfd->cmdstatus = CMDFLAG_EL;
    rfd->rbdAddr = rfd->link = LINK_OFFSET_NULL;
    rfd->size = ENETHDRLEN + ENET_MAXDATASIZE;
    rfd->actualCount = 0;

    // Append the packet to the receive queue
    q = nic->recvq.tail;
    PktQInsertTail(&nic->recvq, pkt);

    if (q) {
        // Chain the previous RFD to the current one
        // and clear its EOL flag bit.
        rfd = GetPktRFD(q);
        rfd->link = GetPktRFDPhy(pkt);
        InterlockedAND(&rfd->cmdstatus, ~CMDFLAG_EL);
    }
}


PRIVATE VOID
NicRecvBufferPktCompletion(
    Packet* pkt,
    NTSTATUS status
    )

/*++

Routine Description:

    Receive packet completion routine

Arguments:

    pkt - Points to the packet being completed
    status - Completion status

Return Value:

    NONE

--*/

{
    // Insert the packet back into the receive queue
    NicEnqueueRecvBuffer((IfEnet*) pkt->recvifp, pkt);
}

    
PRIVATE NTSTATUS
NicRecvBufferInit(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the receive packet queue

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT index;
    Packet* pkt;
    
    status = NicPktPoolInit(cfgRecvQLength);
    if (!NT_SUCCESS(status)) {
        WARNING_("Couldn't allocate DMA receive buffers.");
        return status;
    }

    for (index=0; index < cfgRecvQLength; index++) {
        pkt = NicPktAlloc(index);
        pkt->recvifp = (IfInfo*) nic;
        XnetSetPacketCompletion(pkt, NicRecvBufferPktCompletion);
        NicEnqueueRecvBuffer(nic, pkt);
    }

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicStartReceiveUnit(
    IfEnet* nic
    )

/*++

Routine Description:

    Start the 82558 RU (receive unit). We assume the RU is
    not in the ready state when this function is called.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = nic->CSR;
    NTSTATUS status = NETERR_OK;

    while (SCB_STAT_RUS(csr->cusRus) != RUS_READY) {
        Packet* pkt = nic->recvq.head;

        if (GetPktRFD(pkt)->cmdstatus & CMDSTATUS_C) {
            // If the head of the receive buffer queue is completed
            // but not yet processed, process it first.
            NicProcessRecvInterrupt(nic);
        } else {
            UINT timeout;

            // Wait for SCB and then issue the RUC_START command
            status = NicWaitScb(csr);
            if (NT_SUCCESS(status)) {
                ASSERT(SCB_STAT_RUS(csr->cusRus) != RUS_READY);
                csr->scbGeneralPtr = GetPktRFDPhy(pkt);
                csr->cucRuc = RUC_START;

                // Wait until the RU to accept the command
                // BOGUS: the 80000 number came from w2k driver
                NicWaitScb(csr);
                timeout = 80000;
                while (timeout && SCB_STAT_RUS(csr->cusRus) != RUS_READY) {
                    timeout--;
                    KeStallExecutionProcessor(10);
                }

                if (timeout == 0)
                    status = NETERR_HARDWARE;
            }

            if (!NT_SUCCESS(status)) {
                WARNING_("Failed to start receiveer.");
            }

            break;
        }
    }

    return status;
}


PRIVATE WORD
NicReadEEPROM(
    volatile WORD* eepromCtrl,
    INT addr
    )

/*++

Routine Description:

    Read a WORD out of the 82558 EEPROM

Arguments:

    eepromCtrl - Address of the EEPROM control register
    addr - EEPROM location to be read

Return Value:

    WORD value read out of the EEPROM

--*/

// Wait for about 100us after toggling signals to the EEPROM
//  BOGUS: not sure why w2k driver picked this 100us number
#define WaitEEPROM() KeStallExecutionProcessor(100)

// Toggle EEPROM SK bit
#define RaiseEEPROMClock() \
        reg |= EEPROM_SK; \
        *eepromCtrl = reg; \
        WaitEEPROM()

#define LowerEEPROMClock() \
        reg &= ~EEPROM_SK; \
        *eepromCtrl = reg; \
        WaitEEPROM()

{
    INT bit;
    WORD reg, result;

    // start bit + opcode + address
    addr = (1 << 8) | (EEPROMOP_READ << 6) | (addr & 0x3f);

    //
    // Set EEPROM CS bit
    //
    reg = *eepromCtrl;
    reg &= ~(EEPROM_SK | EEPROM_DI | EEPROM_DO);
    reg |= EEPROM_CS;
    *eepromCtrl = reg;

    //
    // Shift out 9 bits - from MSB to LSB
    //
    for (bit=8; bit >= 0; bit--) {
        // Write EEPROM DI bit
        if (addr & (1 << bit))
            reg |= EEPROM_DI;
        else
            reg &= ~EEPROM_DI;
        *eepromCtrl = reg;
        WaitEEPROM();

        // Toggle EEPROM SK bit
        RaiseEEPROMClock();
        LowerEEPROMClock();
    }

    // EEPROM DO bit must be 0 at this point

    //
    // Read out 16 data bits
    //
    result = 0;
    reg &= ~EEPROM_DI;

    for (bit=0; bit < 16; bit++) {
        // Raise EEPROM SK bit
        // then read EEPROM DO bit
        // finally lower EEPROM SK bit

        RaiseEEPROMClock();

        result = (WORD) (result << 1);
        if (*eepromCtrl & EEPROM_DO)
            result |= 1;

        LowerEEPROMClock();
    }

    //
    // Deassert EEPROM CS bit
    //  BOGUS: not sure why we need to toggle the clock bit here
    //
    reg &= ~EEPROM_CS;
    *eepromCtrl = reg;
    RaiseEEPROMClock();
    LowerEEPROMClock();

    return result;
}


PRIVATE NTSTATUS
NicReadEnetAddr(
    IfEnet* nic
    )

/*++

Routine Description:

    Read permanent Ethernet address from the EEPROM

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    volatile WORD* eepromCtrl;
    WORD* addr;

    eepromCtrl = &nic->CSR->eepromCtrl;
    addr = (WORD*) nic->hwaddr;

    addr[0] = NicReadEEPROM(eepromCtrl, 0);
    addr[1] = NicReadEEPROM(eepromCtrl, 1);
    addr[2] = NicReadEEPROM(eepromCtrl, 2);

    nic->hwaddrlen = ENETADDRLEN;
    return NETERR_OK;
}


VOID
NicReset(
    IfEnet* nic,
    BOOL disconnectIntr
    )

/*++

Routine Description:

    Reset the NIC (stop both command and receive units)
    Also disconnects the NIC interrupts.

Arguments:

    nic - Points to the NIC data structure
    disconnectIntr - Whether to disconnect NIC interrupts

Return Value:

    NONE

--*/

{
    if (!nic->CSR) return;

    nic->CSR->port = PORTCMD_SELECTIVE_RESET;
    KeStallExecutionProcessor(20);
    NicDisableInterrupt();

    // Clear pending interrupts
    nic->CSR->statAck = nic->CSR->statAck;

    if (disconnectIntr) {
        NicDisconnectInterrupt(nic);
    }
}


VOID
NicTimerProc(
    IfEnet* nic
    )

/*++

Routine Description:

    NIC interface timer routine

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    BYTE cusRus = nic->CSR->cusRus;

    // NOTE:
    //  We shouldn't have to do any of the following
    //  under normal operations. Just being paranoid here.

    // If RU is idle, start it
    if (SCB_STAT_RUS(cusRus) != RUS_READY) {
        NicProcessRecvInterrupt(nic);
        NicStartReceiveUnit(nic);
    }

    // If CU is stuck, start or resume it
    if (!PktQIsEmpty(&nic->cmdq) && nic->cmdqWatchdog++ > 2) {
        Packet* pkt = nic->cmdq.head;
        ActionCmdBlock* cmdblk = GetPktCmdBlk(nic, pkt);

        WARNING_("Transmitter is stuck.");
        nic->cmdqWatchdog = 0;

        if ((cmdblk->cmdstatus & CMDSTATUS_C) || SCB_STAT_CUS(cusRus) != CUS_IDLE) {
            nic->CSR->cucRuc = CUC_RESUME;
        } else {
            NicStartCommandUnit(nic, cmdblk);
        }
    }
}


PRIVATE VOID*
NicCmdBufferReserve(
    IfEnet* nic,
    UINT count
    )

/*++

Routine Description:

    Reserve the requested number of bytes in the shared command buffer

Arguments:

    nic - Points to the NIC data structure
    count - Specifies the desired number of bytes

Return Value:

    Pointer to the first reserved byte in the command buffer
    NULL if the request cannot be satisfied (no space left)

--*/

{
    BYTE* addr;
    UINT freeCount;
    INT reclaim = 0;

    // We always allocate in 8-byte chunks
    ASSERT(count % CMDBUF_ALLOC_UNIT == 0);

retry: 

    if (nic->cmdbuf.tail >= nic->cmdbuf.head) {
        // we have the following case:
        //       head        tail
        //  |    xxxxxxxxxxxxx   |

        // first check to see if we have enough room at the end of the buffer
        if (count <= (freeCount = nic->cmdbuf.last - nic->cmdbuf.tail)) {
            // yes, reserve space at the end
            if (nic->cmdbuf.head > nic->cmdbuf.start) freeCount++;
            addr = nic->cmdbuf.tail;
        } else {
            freeCount = nic->cmdbuf.head - nic->cmdbuf.start;
            addr = nic->cmdbuf.start;
        }
    } else {
        // we have the following case:
        //      tail       head
        //  |xxxx           xxxxx|

        freeCount = nic->cmdbuf.head - nic->cmdbuf.tail;
        addr = nic->cmdbuf.tail;
    }

    //
    // If there is enough room, then return success.
    // Otherwise, try to process any pending CU interrupts
    // and reclaim the shared command buffer space.
    //
    if (count < freeCount) return addr;
    if (reclaim++ == 0 && NicProcessXmitInterrupt(nic, 0)) goto retry;

    WARNING_("Failed to allocate command buffer space.");
    return NULL;
}

//
// Commit the command buffer space previously reserved by NicCmdBufferReserve.
// The count parameter must be equal to or less than the original
// value passed to NicCmdBufferReserve.
//
INLINE VOID NicCmdBufferCommit(IfEnet* nic, VOID* addr, UINT count) {
    BYTE* tail = (BYTE*) addr + count;
    nic->cmdbuf.tail = (tail < nic->cmdbuf.last) ? tail : (tail-PAGE_SIZE);
}


PRIVATE NTSTATUS
NicEnqueueCmdBlock(
    IfEnet* nic,
    Packet* pkt,
    ActionCmdBlock* cmdblk,
    UINT cmdsize
    )

/*++

Routine Description:

    Queue up a command description block for execution

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the packet to be queued
    cmdblk - Points to the data for this command in the shared buffer
    cmdsize - Number of bytes taken by this command

Return Value:

    Status code

--*/

{
    Packet* q;

    // Keep a pointer to the command block in the packet
    cmdblk->link = LINK_OFFSET_NULL;
    SetPktCmdBlk(nic, pkt, cmdblk, cmdsize);

    // If the 82558 command unit is idle or suspended
    // and the command queue was empty, start or resume it here.
    if ((q = nic->cmdq.tail) == NULL) {
        NTSTATUS status = NicStartCommandUnit(nic, cmdblk);
        if (!NT_SUCCESS(status)) return status;
    }

    // Append this entry to the command queue
    NicCmdBufferCommit(nic, cmdblk, cmdsize);
    PktQInsertTail(&nic->cmdq, pkt);
    nic->cmdqCount++;

    // And modify the last command's link field
    // and clear its EOL flag.
    if (q != NULL) {
        ActionCmdBlock* lastcmd = GetPktCmdBlk(nic, q);
        lastcmd->link = CmdBufferGetPhyAddr(nic, cmdblk);
        InterlockedAND(&lastcmd->cmdstatus, ~CMDFLAG_EL);
    }
    return NETERR_OK;
}


VOID
NicWaitForXmitQEmpty(
    IfEnet* nic
    )

/*++

Routine Description:

    Wait until the transmit queue is empty
    This is only called by the debug monitor when the regular net stack is unloaded.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    UINT timeout = 0;
    while (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic, nic->CSR->statAck);
        KeStallExecutionProcessor(50);

        timeout++;
        ASSERT(timeout < 20000);
    }
}


PRIVATE BOOL
NicProcessXmitInterrupt(
    IfEnet* nic,
    BYTE statAck
    )

/*++

Routine Description:

    Process command completion interrupts

Arguments:

    nic - Points to the NIC data structure
    statAck - NIC interrupt status bits

Return Value:

    TRUE if any command was completed
    FALSE otherwise

--*/

{
    Packet* pkt;
    ActionCmdBlock* cmdblk;
    NTSTATUS status;
    BOOL processed = FALSE;

    // Loop through our command queue
    while ((pkt = nic->cmdq.head) != NULL) {
        // Stop when we encounter a command which hasn't completed yet
        cmdblk = GetPktCmdBlk(nic, pkt);
        if (!(cmdblk->cmdstatus & CMDSTATUS_C)) {
            if (processed || (statAck & SCB_STAT_CNA)) {
                //
                // HACK to take care of the following scenario:
                //  We appended an entry to the command queue and
                //  modified the link and EOL info in the previous
                //  command (inside function NicEnqueueCmdBlock). But
                //  CU could be completing the previous command just
                //  as we were modifying it. So it could end up in
                //  the idle state instead of starting to execute
                //  the new command.
                // 
                NicStartCommandUnit(nic, cmdblk);
            }
            break;
        }

        // Remove the completed command from the queue
        // and do any necessary post-processing.
        processed = TRUE;
        PktQRemoveHead(&nic->cmdq);
        nic->cmdqCount--;
        nic->cmdqWatchdog = 0;
        status = (cmdblk->cmdstatus & CMDSTATUS_OK) ?
                    NETERR_OK :
                    NETERR_HARDWARE;

        // Free up the space taken in the shared command data buffer
        if (PktQIsEmpty(&nic->cmdq)) {
            //
            // no more outstanding commands
            //  reset the command buffer to its default state
            //
            nic->cmdbuf.head =
            nic->cmdbuf.tail = nic->cmdbuf.start;
        } else {
            //
            // Notice that if there is a gap at the end of
            // the command data buffer after , the head pointer
            // won't be correctly updated here. But that's ok
            // because it'll be correct again after the next
            // command is completed.
            //
            nic->cmdbuf.head = (BYTE*) cmdblk + GetPktCmdBlkSize(nic, pkt);
            if (nic->cmdbuf.head >= nic->cmdbuf.last)
                nic->cmdbuf.head -= PAGE_SIZE;
        }
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, status);
    }

    return processed;
}


PRIVATE VOID
NicProcessRecvInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process packet reception interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    while (TRUE) {
        Packet* pkt = nic->recvq.head;
        RecvFrameDesc* rfd = GetPktRFD(pkt);
        UINT pktlen;
        
        // No more received packets
        if (!(rfd->cmdstatus & CMDSTATUS_C)) return;
        
        // Take the packet off the receive buffer queue
        PktQRemoveHead(&nic->recvq);

        if (rfd->cmdstatus & CMDSTATUS_OK) {
            //
            // If the packet was received without error, process it.
            //
            ASSERT(rfd->actualCount & RFD_EOF);
            ASSERT(rfd->actualCount & RFD_F);

            pkt->datalen = pktlen = (rfd->actualCount & RFD_CNTMASK);
            ASSERT(pktlen >= ENETHDRLEN + ENET_MINDATASIZE);

            EnetReceiveFrame(nic, pkt);
        } else {
            //
            // Bad reception: just recycle the packet back into
            // the receive buffer queue
            //
            NicEnqueueRecvBuffer(nic, pkt);
        }
    }
}


PRIVATE VOID
NicInterruptDpc(
    PKDPC dpc,
    IfEnet* nic,
    VOID* arg1,
    VOID* arg2
    )

/*++

Routine Description:

    Ethernet interface interrupt service routine
    (runs at DISPATCH_LEVEL)

Arguments:

    dpc - Pointer to the DPC object
    nic - Points to the NIC data structure
    arg1, arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    BYTE statAck = csr->statAck;

    // Acknowledge pending interrupts
    csr->statAck = statAck;

    // Process any received packets
    NicProcessRecvInterrupt(nic);

    // Process any completed action commands
    if (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic, statAck);
    }

    // Start the receive unit if it has been stopped
    NicStartReceiveUnit(nic);

    // If there is more room now in the command queue, we can
    // move some packets from the send queue to the command queue.
    if (!EnetIsSendQEmpty(nic) && nic->cmdqCount < cfgXmitQLength) {
        EnetStartOutput(nic);
    }

    // Reenable interrupts
    NicEnableInterrupt();
}


PRIVATE BOOLEAN
NicIsr(
    PKINTERRUPT interrupt,
    IfEnet* nic
    )

/*++

Routine Description:

    Ethernet interrupt service routine (runs at DIRQL)

Arguments:

    interrupt - Interrupt object
    nic - Points to the NIC data structure

Return Value:

    TRUE if the interrupt was handled
    FALSE if the interrupt wasn't generated by our device

--*/

{
    if ((nic->CSR->intrMask & INTR_MASK_BIT) || !nic->CSR->statAck)
        return FALSE;

    // Yep, this is ours:
    //  schedule the DPC routine for execution
    //  and disable further interrupts
    KeInsertQueueDpc(&nic->dpc, NULL, NULL);
    NicDisableInterrupt();
    return TRUE;
}


VOID
NicTransmitFrame(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Transmit an Ethernet frame to the NIC

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the frame to be transmitted
        We assume the Ethernet frame has been completed filled out
        and all the data are inside a single Packet structure.

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    TransmitCmdBlock* txcb;
    TBDEntry* tbdArray;
    UINT tbdCount, cmdsize, len;
    UINT_PTR phyaddr0, phyaddr1;

    //
    // Lock the physical pages contain packet data
    //
    NicLockPacketPages(pkt);

    //
    // Allocate space in the shared command buffer:
    //  transmit command block followed by
    //  max number of transmission block descriptors
    //
    cmdsize = sizeof(TransmitCmdBlock) + sizeof(TBDEntry) * MAX_TBD_PER_XMIT;
    txcb = (TransmitCmdBlock*) NicCmdBufferReserve(nic, cmdsize);
    if (!txcb) {
        status = NETERR_MEMORY;
        goto exit;
    }

    // Make sure the packet is not too big
    ASSERT(pkt->datalen != 0);
    if (pkt->datalen > ENETHDRLEN+ENET_MAXDATASIZE) {
        status = NETERR_MSGSIZE;
        goto exit;
    }

    // Since the total buffer size is <= 1500+14 bytes,
    // it can at most span two physical pages.
    len = pkt->datalen;
    phyaddr0 = MmGetPhysicalAddress(pkt->data);
    phyaddr1 = MmGetPhysicalAddress(pkt->data + (len-1));

    tbdArray = (TBDEntry*) (txcb+1);
    tbdCount = 0;
    tbdArray[tbdCount].bufaddr = phyaddr0;

    if ((phyaddr1 - phyaddr0) == len-1) {
        // The buffer is physically contiguous.
        // We only need one TBD here.
        tbdArray[tbdCount++].bufsize = len;
    } else {
        // The buffer is not physically contiguous.
        // So we need two TBDs.
        UINT len0 = PAGE_SIZE - (phyaddr0 & (PAGE_SIZE-1));
        tbdArray[tbdCount++].bufsize = len0;
        tbdArray[tbdCount].bufaddr = phyaddr1 & ~(PAGE_SIZE-1);
        tbdArray[tbdCount++].bufsize = len - len0;
    }

    cmdsize = sizeof(TransmitCmdBlock) + sizeof(TBDEntry) * tbdCount;

    //
    // Fill out the TxCB (transmit command block) itself
    //
    txcb->cmdstatus =
        ACTIONCMD_TRANSMIT |    // transmit command
        CMDFLAG_EL |            // end-of-list
        CMDFLAG_I |             // interrupt after completion
        TxCBFLAG_SF;            // flexible mode

    txcb->tbdArray = CmdBufferGetPhyAddr(nic, tbdArray);
    txcb->byteCount = 0;        // no data bytes in the TxCB
    txcb->txThreshold = DEFAULT_Tx_THRESHOLD;
    txcb->tbdNumber = (BYTE) tbdCount;

    // Queue up the transmit command for execution
    status = NicEnqueueCmdBlock(nic, pkt, (ActionCmdBlock*) txcb, cmdsize);

exit:
    //
    // If we failed to insert the packet into the NIC's command queue,
    // complete the packet here with error status. This is because we
    // won't get a command-completion interrupt and do it then.
    //
    if (!NT_SUCCESS(status)) {
        WARNING_("NicTransmitFrame failed: 0x%x", status);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, status);
    }
}


NTSTATUS
NicSetMcastAddrs(
    IfEnet* nic,
    const BYTE* addrs,
    UINT count
    )

/*++

Routine Description:

    Send multicast addresses down to the NIC.
    We assume the new list will replace the existing one.

Arguments:

    nic - Points to the NIC data structure
    addrs - Points to an array of multicast addresses
    count - Specifies the number of multicast addresses

Return Value:

    Status code

--*/

{
    McastSetupCmdBlock* mcastcmd;
    UINT cmdsize;
    Packet* pkt;
    NTSTATUS status;

    //
    // Reserve space in the shared command data buffer
    //
    cmdsize = offsetof(McastSetupCmdBlock, mcastAddrs) + count * ENETADDRLEN;
    cmdsize = ROUNDUP8(cmdsize);
    mcastcmd = (McastSetupCmdBlock*) NicCmdBufferReserve(nic, cmdsize);
    if (!mcastcmd) return NETERR_MEMORY;

    // Allocate a dummy packet for the command queue
    //  HACK: When the command finishes, CompletePacket is called.
    //  That ends up in the up-level Ethernet interface code.
    //  It'll just free the memory back to the system pool.
    pkt = SysAlloc0(PKTHDRLEN, PTAG_NIC);
    if (!pkt) return NETERR_MEMORY;

    pkt->data = pkt->buf;
    pkt->pktflags = (WORD)defaultPacketAllocFlag;
    NicLockPacketPages(pkt);

    //
    // Fill out the multicast setup command block
    //
    mcastcmd->cmdstatus =
        ACTIONCMD_MC_SETUP |
        CMDFLAG_EL |
        CMDFLAG_I;

    mcastcmd->mcastCount = (WORD) (count * ENETADDRLEN);
    if (count) {
        CopyMem(mcastcmd->mcastAddrs, addrs, count * ENETADDRLEN);
    }

    // Queue up the multicast setup command for execution
    status = NicEnqueueCmdBlock(nic, pkt, (ActionCmdBlock*) mcastcmd, cmdsize);
    if (!NT_SUCCESS(status)) {
        NicUnlockPacketPages(pkt);
        SysFree(pkt);
    }
    return status;
}


PRIVATE NTSTATUS
NicClaimHardware(
    IfEnet* nic
    )

/*++

Routine Description:

    Locate and claim the NIC adapter and
    map the NIC's CSR register into memory space

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    ULONG deviceCount = 1;
    PCI_DEVICE_DESCRIPTOR hwres;

    ZeroMem(&hwres, sizeof(hwres));
    hwres.Bus =
    hwres.Slot = 0xffffffff;
    hwres.VendorID = NIC_VENDORID;
    hwres.DeviceID = NIC_DEVICEID;
    hwres.BaseClass = PCI_CLASS_NETWORK_CTLR;
    hwres.SubClass = PCI_SUBCLASS_NET_ETHERNET_CTLR;
    hwres.ProgIf = 0xff;

    status = HalSetupPciDevice(&hwres, &deviceCount);
    if (!NT_SUCCESS(status)) {
        WARNING_("Couldn't find NIC adapter: 0x%x!", status);
        return NETERR_HARDWARE;
    }

    ASSERT(hwres.ResourceData.Address[0].Type == CmResourceTypeMemory);
    ASSERT(hwres.ResourceData.Address[0].u.Memory.Length >= sizeof(struct _NIC_CSR));

    NicCsr = nic->CSR = (PNIC_CSR) hwres.ResourceData.Address[0].u.Memory.TranslatedAddress;
    nic->csrSize = hwres.ResourceData.Address[0].u.Memory.Length;
    nic->intrVector = hwres.ResourceData.Interrupt.Vector;
    nic->intrIrql = hwres.ResourceData.Interrupt.Irql;

    return NETERR_OK;
}


VOID
NicCleanup(
    IfEnet* nic
    )

/*++

Routine Description:

    Cleanup the NIC interface

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // Clean up the command queue and the shared command data buffer
    while (!PktQIsEmpty(&nic->cmdq)) {
        Packet* pkt = PktQRemoveHead(&nic->cmdq);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    if (nic->cmdbuf.start) {
        NicFreeSharedMem(nic->cmdbuf.start);
        nic->cmdbuf.start = NULL;
    }

    // Clean up the receive buffer queue
    NicPktPoolCleanup();
    PktQInit(&nic->recvq);

    // Acknowledge pending interrupts
    if (NicCsr) {
        NicCsr->statAck = NicCsr->statAck;
        NicDisableInterrupt();
        NicDisconnectInterrupt(nic);

        // Unmap CSR from the virtual address space.
        MmUnmapIoSpace((VOID*) NicCsr, nic->csrSize);
        NicCsr = NULL;
    }
}


NTSTATUS
NicInitialize(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the NIC "driver" code

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr;
    NTSTATUS status = NETERR_HARDWARE;
    DWORD linkState;

    // Locate the NIC card and get the assigned resources
    status = NicClaimHardware(nic);
    if (!NT_SUCCESS(status)) goto err;
    csr = NicCsr;

    KeInitializeDpc(&nic->dpc, (PKDEFERRED_ROUTINE) NicInterruptDpc, nic);
    KeInitializeInterrupt(
        &NicIntrObject,
        (PKSERVICE_ROUTINE) NicIsr,
        nic,
        nic->intrVector,
        nic->intrIrql,
        LevelSensitive,
        TRUE);


    // Per 82558 manual, we should do a selective reset first
    // before doing a full software reset.
    csr->port = PORTCMD_SELECTIVE_RESET;
    KeStallExecutionProcessor(20);
    csr->port = PORTCMD_SOFTWARE_RESET;
    KeStallExecutionProcessor(20);

    // Interrupts are enabled after a reset.
    // So disable them here.
    NicDisableInterrupt();

    // Load CU and RU base to 0 (linear flat addressing)
    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) goto err;
    csr->scbGeneralPtr = 0;
    csr->cucRuc = CUC_LOAD_CU_BASE;

    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) goto err;
    csr->scbGeneralPtr = 0;
    csr->cucRuc = RUC_LOAD_RU_BASE;

    // Initialize the shared command data buffer
    // and the receive buffer queue
    status = NicCmdBufferInit(nic);
    if (!NT_SUCCESS(status)) goto err;
    status = NicRecvBufferInit(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Read permanent Ethernet address from EEPROM
    status = NicReadEnetAddr(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Configure the NIC parameters
    status = NicDoConfigureCmd(nic);
    if (!NT_SUCCESS(status)) goto err;

    // BOGUS: why in the world do we need to wait 500msec here?
    // The number is from win2k driver. But the NIC seems to work fine
    // if we take out the wait. The wait has also been taken out of the
    // current driver in Whistler.
    // KeStallExecutionProcessor(500000);

    // Set up the individual address
    status = NicDoIASetupCmd(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Start the RU and enable interrupts
    status = NicStartReceiveUnit(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Check if the Ethernet link is up
    PhyInitialize(FALSE, (VOID*) nic->CSR);
    linkState = PhyGetLinkState(FALSE);

    VERBOSE_("Ethernet link status: %s %dMbps %s-duplex",
        (linkState & XNET_LINK_IS_UP) ? "up" : "down",
        (linkState & XNET_LINK_100MBPS) ? 100 :
            (linkState & XNET_LINK_10MBPS) ? 10 : 0,
        (linkState & XNET_LINK_FULL_DUPLEX) ? "full" :
            (linkState & XNET_LINK_HALF_DUPLEX) ? "half" : "?");

    if (linkState & XNET_LINK_IS_UP)
        nic->flags |= IFFLAG_CONNECTED_BOOT;

    // Connect the NIC interrupt
    if (KeConnectInterrupt(&NicIntrObject))
        return NETERR_OK;

    status = STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT;

err:
    NicReset(nic, FALSE);
    NicCleanup(nic);
    return status;
}

#endif // SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\ifenet.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ifenet.h

Abstract:

    Ethernet and ARP implementation related declarations

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _IFENET_H
#define _IFENET_H

//
// ARP cache entry
//
typedef struct _ArpCacheEntry {
    IPADDR ipaddr;              // target IP address
    UINT timer;                 // timer (in seconds)
    PacketQueue waitq;          // outgoing packets blocked on this entry
    WORD state;                 // current state of the entry
    BYTE enetaddr[ENETADDRLEN]; // target Ethernet address
} ArpCacheEntry;

//
// Constants for ArpCacheEntry.flags
//
#define ARPST_FREE  0           // entry is free
#define ARPST_BUSY  1           // entry is being resolved
#define ARPST_OK    2           // entry is good
#define ARPST_BAD   3           // target is unreachable

#define IsArpEntryFree(_arpEntry) ((_arpEntry)->state == ARPST_FREE)
#define IsArpEntryBusy(_arpEntry) ((_arpEntry)->state == ARPST_BUSY)
#define IsArpEntryOk(_arpEntry) ((_arpEntry)->state == ARPST_OK)
#define IsArpEntryBad(_arpEntry) ((_arpEntry)->state == ARPST_BAD)

//
// Ethernet interface data structure
//
typedef struct _IfEnet {
    //
    // Information common to all network interfaces
    // !! must be the first field of the structure
    //
    IfInfo;
    DWORD magicCookie;          // magic cookie for debugging purpose

    //
    // NIC specific information
    //
    NicInfo;

    //
    // Used for DHCP/autonet: the tentative address that
    //  we need to check for conflict
    //
    IPADDR checkConflictAddr;

    //
    // ARP cache (the modulo value should be a prime number)
    //
    #define ARP_CACHE_SIZE  64
    #define ARP_HASH_RETRY  5
    #define ARP_HASH_MODULO (ARP_CACHE_SIZE-ARP_HASH_RETRY)

    IPADDR lastArpAddr;
    ArpCacheEntry* lastArpEntry;
    INT arpCacheCount;
    ArpCacheEntry arpCache[ARP_CACHE_SIZE];
} IfEnet;


//
// ARP configuration parameters
//
extern UINT cfgPositiveArpCacheTimeout;
extern UINT cfgNegativeArpCacheTimeout;
extern UINT cfgArpRequestRetries;

//
// Default ARP cache entry timeout (in seconds)
//  = 10 minutes for positive cache
//  = 1 minute for negative cache
//
#define POSITIVE_ARP_CACHE_TIMEOUT (10*60)
#define NEGATIVE_ARP_CACHE_TIMEOUT 60

//
// Number of times we try to retransmit an ARP request
//  (with 1 second delay)
//
#define ARP_REQUEST_RETRIES 2

//
// Resolve an IP address to an ARP cache entry
//  
#define RESOLVE_NONE            0
#define RESOLVE_CREATE_ENTRY    1
#define RESOLVE_SEND_REQUEST    2

ArpCacheEntry* ArpFindCacheEntry(IfEnet* ifp, IPADDR ipaddr, INT resolve);

// ARP timer function
VOID ArpTimerProc(IfEnet* ifp);

// Send out an ARP request or reply packet
NTSTATUS ArpSendPacket(IfEnet*, WORD, IPADDR, IPADDR, const BYTE*);

INLINE NTSTATUS ArpSendRequest(IfEnet* ifp, IPADDR tpa, IPADDR spa) {
    return ArpSendPacket(ifp, ARP_REQUEST, tpa, spa, NULL);
}

INLINE NTSTATUS ArpSendReply(IfEnet* ifp, IPADDR tpa, const BYTE* tha) {
    return ArpSendPacket(ifp, ARP_REPLY, tpa, ifp->ipaddr, tha);
}

// Process an incoming ARP packet
VOID ArpReceivePacket(IfEnet* ifp, Packet* pkt);

// Cleanup ARP related data
VOID ArpCleanup(IfEnet* ifp);

// Start output on the Ethernet interface
VOID EnetStartOutput(IfEnet* ifp);

// Generate an Ethernet multicast address from an IP multicast address
INLINE VOID EnetGenerateMcastAddr(IPADDR ipaddr, BYTE* hwaddr) {
    //
    // Refer to RFC1112 - section 6.4:
    // An IP host group address is mapped to an Ethernet multicast address
    // by placing the low-order 23-bits of the IP address into the low-order
    // 23 bits of the Ethernet multicast address 01-00-5E-00-00-00 (hex).
    //
    hwaddr[0] = 0x01;
    hwaddr[1] = 0x00;
    hwaddr[2] = 0x5e;

    // Note that IPADDR is in network byte order
    hwaddr[3] = (BYTE) ((ipaddr >> 8) & 0x7f);
    hwaddr[4] = (BYTE) (ipaddr >> 16);
    hwaddr[5] = (BYTE) (ipaddr >> 24);
}

//
// NIC functions
//
NTSTATUS NicInitialize(IfEnet* nic);
VOID NicReset(IfEnet* nic, BOOL disconnectIntr);
VOID NicCleanup(IfEnet* nic);
VOID NicTimerProc(IfEnet* nic);
VOID NicTransmitFrame(IfEnet* nic, Packet* pkt);
NTSTATUS NicSetMcastAddrs(IfEnet* nic, const BYTE* addrs, UINT count);
VOID NicWaitForXmitQEmpty(IfEnet* nic);
INLINE BOOL NicIsXmitQFull(IfEnet* nic) { return (nic->cmdqCount >= cfgXmitQLength); }

extern KINTERRUPT NicIntrObject;
INLINE VOID NicDisconnectInterrupt(IfEnet* nic) {
    if (NicIntrObject.Connected) {
        KeDisconnectInterrupt(&NicIntrObject);
        KeRemoveQueueDpc(&nic->dpc);
    }
}

VOID EnetReceiveFrame(IfEnet* ifp, Packet* pkt);
INLINE BOOL EnetIsSendQEmpty(IfEnet* ifp) { return PktQIsEmpty(&ifp->sendq); }

#endif // !_IFENET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\nicp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nicp.h

Abstract:

    Private header file for the NIC "driver" code

Revision History:

    01/24/2001 davidx
        Created it.

--*/

#ifndef _NICP_H
#define _NICP_H

//
// NIC data structure
//
typedef struct _NicInfo {
    PNIC_CSR CSR;               // points to NIC CSR structure
    ULONG csrSize;              // size of mapped CSR structure
    PacketQueue recvq;          // receive packet queue
    PacketQueue cmdq;           // NIC command queue
    UINT cmdqCount;             // # of entries in the command queue
    UINT cmdqWatchdog;          // command queue watchdog timer
    NicCmdBuffer cmdbuf;        // NIC command buffer
    KDPC dpc;                   // DPC object
    ULONG intrVector;           // interrupt vector
    KIRQL intrIrql;             // interrupt IRQ level
    DWORD rxpollFreq;           // XNIC Rx polling frequency
    DWORD linkStatus;           // last known link status
} NicInfo;

//
// Functions for managing DMA packet pool
//
// NOTE: The DMA packet size actually only needs to be as big as:
//      PKTHDRLEN + RECVPKT_OVERHEAD + ENETHDRLEN + ENET_MAXDATASIZE = 1546
// But we're have to use 2KB here to workaround an nVidia NIC hardware problem
// whether a receive buffer cannot cross physical page boundary.
//
#define DMAPKT_SIZE 2048
#define DMAPKT_MAXDATA (DMAPKT_SIZE - PKTHDRLEN - RECVPKT_OVERHEAD)

// Virtual and physical offset of the DMA packet pool
extern BYTE* NicPktPoolBase;
extern UINT_PTR NicPktPoolPhyAddrOffset;

INLINE Packet* NicPktAlloc(UINT index) {
    Packet* pkt = (Packet*) (NicPktPoolBase + index*DMAPKT_SIZE);
    ZeroMem(pkt, PKTHDRLEN);
    pkt->pktflags = PKTFLAG_DMA;
    pkt->data = pkt->buf;
    return pkt;
}

INLINE UINT_PTR NicPktGetPhyAddr(VOID* data) {
    return (UINT_PTR) data + NicPktPoolPhyAddrOffset;
}

INLINE NTSTATUS NicPktPoolInit(UINT count) {
    NicPktPoolBase = (BYTE*) NicAllocSharedMem(count * DMAPKT_SIZE);
    if (!NicPktPoolBase) return NETERR_MEMORY;
    NicPktPoolPhyAddrOffset = MmGetPhysicalAddress(NicPktPoolBase) - (UINT_PTR) NicPktPoolBase;
    return NETERR_OK;
}

INLINE VOID NicPktPoolCleanup() {
    if (NicPktPoolBase) {
        NicFreeSharedMem(NicPktPoolBase);
        NicPktPoolBase = NULL;
        NicPktPoolPhyAddrOffset = 0;
    }
}

#endif // !_NICP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\sources.inc ===
!include ..\..\sources.inc

TARGETNAME=enet
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\;$(INCLUDES)

PRECOMPILED_INCLUDE=..\precomp.h

SOURCES=\
    ..\arp.c \
    ..\enet.c \
    ..\i82558.c \
    ..\xnic.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\precomp.h ===
#include "xnetp.h"
#include "ethernet.h"
#include "phy.h"

#ifdef SILVER
#include "i82558.h"
#else
#include "xnic.h"
#endif

#include "nicp.h"
#include "ifenet.h"
#include "dbgmon.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\xnic.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nic.h

Abstract:

    XBox Ethernet controller related declarations
    Refer to Medium Access Controller hardware spec for more info.

Revision History:

    07/24/2000 davidx
        Created it.

--*/

#ifndef _XNIC_H
#define _XNIC_H

//
// Nvidia PCI vendor and device ID
//
#define NIC_VENDORID 0x10DE
#define NIC_DEVICEID 0x01C3

//
// Receive and transmit descriptor
//
typedef struct _NicBufDesc {
    DWORD phyaddr;
        // physical address of the rx or tx buffer

    DWORD flags_count;
        // bit 31-16: control and status bits (see below)
        // bit 15-0: byte count (for tx, set to actual count - 1)
} NicBufDesc;

// Receive control and status bits
//  bit 31 (OWN):
//      0 - host owns the descriptor
//      1 - controller owns the descriptor
//  bit 30 (ERR): a receive error
//  bit 29 (FRAM): framing error
//  bit 28 (OFOL): overflow error
//  bit 27 (CRC): CRC error
//  bit 26 (LFER): length field error
//  bit 25 (MAX): received frame is larger than the max frame size
//  bit 24 (LCOL): late collision
//  bit 23 (RUNT): runt packet received
//  bit 22 (PAM): physical address match
//  bit 21 (MAM): multicast address match
//  bit 20 (BAM): broadcast address match
//  bit 19: reserved
//  bit 18 (EXTRA): received frame length has an extra byte
//  bit 17 (MISS): missed data reception
//  bit 16 (REND): end of receive frame

#define RXDESC_OWN      BIT(31)
#define RXDESC_ERR      BIT(30)
#define RXDESC_FRAM     BIT(29)
#define RXDESC_OFOL     BIT(28)
#define RXDESC_CRC      BIT(27)
#define RXDESC_LFER     BIT(26)
#define RXDESC_MAX      BIT(25)
#define RXDESC_LCOL     BIT(24)
#define RXDESC_RUNT     BIT(23)
#define RXDESC_PAM      BIT(22)
#define RXDESC_MAM      BIT(21)
#define RXDESC_BAM      BIT(20)
#define RXDESC_EXTRA    BIT(18)
#define RXDESC_MISS     BIT(17)
#define RXDESC_REND     BIT(16)

// Transmit control and status bits
//  bit 31 (OWN):
//      0 - host owns the descriptor
//      1 - controller owns the descriptor
//  bit 30 (ERR): transmit error
//  bit 29 (UFLO): underflow error
//  bit 28 (LCOL): late collision
//  bit 27 (LCAR): loss of carrier
//  bit 26 (DEF): deferred
//  bit 25 (EXDEF): excessive deferral
//  bit 24 (INTEN): interrupt override
//  bit 23-20 (TRC): transmit retry count
//  bit 19 (RTRY): retry error
//  bit 18-17: reserved
//  bit 16 (TEND): end of transmit frame

#define TXDESC_OWN      BIT(31)
#define TXDESC_ERR      BIT(30)
#define TXDESC_UFLO     BIT(29)
#define TXDESC_LCOL     BIT(28)
#define TXDESC_LCAR     BIT(27)
#define TXDESC_DEF      BIT(26)
#define TXDESC_EXDEF    BIT(25)
#define TXDESC_INTEN    BIT(24)
#define TXDESC_RTRY     BIT(19)
#define TXDESC_TEND     BIT(16)

//
// NIC registers
//
typedef struct _NIC_CSR {                   // base address fef00000
    DWORD intr;                             // 000
        // Interrupt register
        //  bit 7: reserved
        //  bit 6 (MINT): MII interrupt
        //  bit 5 (STINT): software timer interrupt
        //  bit 4 (TCINT): transmit complete w/o error interrupt
        //  bit 3 (TEINT): transmit complete with error interrupt
        //  bit 2 (MISS): missed a frame
        //  bit 1 (RCINT): receive complete w/o error interrupt
        //  bit 0 (REINT): receive complete with error interrupt

    #define INTR_MINT   BIT(6)
    #define INTR_STINT  BIT(5)
    #define INTR_TCINT  BIT(4)
    #define INTR_TEINT  BIT(3)
    #define INTR_MISS   BIT(2)
    #define INTR_RCINT  BIT(1)
    #define INTR_REINT  BIT(0)

    #define INTR_ALL    (INTR_MINT | \
                         INTR_TCINT | \
                         INTR_TEINT | \
                         INTR_MISS | \
                         INTR_RCINT | \
                         INTR_REINT)
    
    DWORD intr_mk;                          // 004
        // Master interrupt mask
        //  bit 7: reserved
        //  bit 6: MINT mask - 1 = enable and 0 = disable
        //  bit 5: STINT mask
        //  bit 4: TCINT mask
        //  bit 3: TEINT mask
        //  bit 2: MISS mask
        //  bit 1: RCINT mask
        //  bit 0: REINT mask

    DWORD swtr_cntl;                        // 008
        // Software timer control register
        //  bit 1 (STEN): software timer enable
        //  bit 0 (STREN): software timer reload enable

    DWORD swtr_itc;                         // 00c
        // Software timer register
        //  bit 31-16: current software timer count
        //  bit 15-0: software timer interval

    BYTE gap1[0x80 - 0x10];

    DWORD tx_cntl;                          // 080
        // Transmit control register
        //  bit 31-22: reserved
        //  bit 21 (UFLOM): underflow error mask
        //  bit 20 (TCOLM): transmit late collision mask
        //  bit 19 (LCARM): loss of carrier mask
        //  bit 18 (DEFM): deferred mask
        //  bit 17 (EXDEFM): excessive deferral mask
        //  bit 16 (RTRYM): retry error mask
        //  bit 15-12: reserved
        //  bit 11-8: maximum number of retries on collisions
        //  bit 7-6: MAC-PHY interface
        //  bit 5 (TDEFEN): two-part deferral enable
        //  bit 4 (FCSEN): FCS append enable
        //  bit 3 (PADEN): pad enable
        //  bit 2 (RTRYEN): retry enable
        //  bit 1 (HDEN): half-duplex enable
        //  bit 0: reserved
    
    #define TXCNTL_UFLOM    BIT(21)
    #define TXCNTL_TCOLM    BIT(20)
    #define TXCNTL_LCARM    BIT(19)
    #define TXCNTL_DEFM     BIT(18)
    #define TXCNTL_EXDEFM   BIT(17)
    #define TXCNTL_RTRYM    BIT(16)
    #define TXCNTL_RCSHIFT  8
    #define TXCNTL_PHYSHIFT 6
    #define TXCNTL_TDEFEN   BIT(5)
    #define TXCNTL_FCSEN    BIT(4)
    #define TXCNTL_PADEN    BIT(3)
    #define TXCNTL_RTRYEN   BIT(2)
    #define TXCNTL_HDEN     BIT(1)

    #define PHY_TYPE_MII    0
    #define TXCNTL_DEFAULT  (TXCNTL_UFLOM | \
                             TXCNTL_TCOLM | \
                             TXCNTL_LCARM | \
                             TXCNTL_EXDEFM | \
                             TXCNTL_RTRYM | \
                             TXCNTL_TDEFEN | \
                             TXCNTL_FCSEN | \
                             TXCNTL_PADEN | \
                             TXCNTL_RTRYEN | \
                             TXCNTL_HDEN | \
                             (PHY_TYPE_MII << TXCNTL_PHYSHIFT) | \
                             (15 << TXCNTL_RCSHIFT))

    DWORD tx_en;                            // 084
        // Transmit enable register
        //  bit 1: transmit enable

    #define TXEN_ENABLE     BIT(0)

    DWORD tx_sta;                           // 088
        // Transmit status register
        //  bit 31-22: reserved
        //  bit 21 (UFLO): underflow error
        //  bit 20 (TCOL): transmit late collision
        //  bit 19 (LCAR): loss of carrier
        //  bit 18 (DEF): deferred
        //  bit 17 (EXDEF): excessive deferral
        //  bit 16 (RTRY): retry error
        //  bit 15-1: reserved
        //  bit 0: transmit channel idle status
    
    #define TXSTA_UFLO      BIT(21)
    #define TXSTA_TCOL      BIT(20)
    #define TXSTA_LCAR      BIT(19)
    #define TXSTA_DEF       BIT(18)
    #define TXSTA_EXDEF     BIT(17)
    #define TXSTA_RTRY      BIT(16)
    #define TXSTA_BUSY      BIT(0)

    DWORD rx_cntl_0;                        // 08c
        // Receive control
        //  bit 31-23: reserved
        //  bit 22 (FRAMM): frame alignment error mask
        //  bit 21 (OFOLM): overflow error mask
        //  bit 20 (CRCM): FCS error mask
        //  bit 19 (LFERM): length error mask
        //  bit 18 (MAXM): maximum length error mask
        //  bit 17 (RLCOLM): receive late collision mask
        //  bit 16 (RUNTM): runt receive mask
        //  bit 15-9: reserved
        //  bit 8 (RDEFEN): receive deferral enable
        //  bit 7 (BRDIS): broadcast receive disable
        //  bit 6 (RUNTEN): runt packet receive enable
        //  bit 5 (AFEN): address filtering enable
        //  bit 4 (LBEN): loopback enable
        //  bit 3 (PAEN): pause enable
        //  bit 2 (FCSREN): FCS relay enable
        //  bit 1 (PADSEN): pad strip enable
        //  bit 0: reserved

    #define RXCNTL_FRAMM    BIT(22)
    #define RXCNTL_OFLOM    BIT(21)
    #define RXCNTL_CRCM     BIT(20)
    #define RXCNTL_LFERM    BIT(19)
    #define RXCNTL_MAXM     BIT(18)
    #define RXCNTL_RLCOLM   BIT(17)
    #define RXCNTL_RUNTM    BIT(16)
    #define RXCNTL_RDEFEN   BIT(8)
    #define RXCNTL_BRDIS    BIT(7)
    #define RXCNTL_RUNTEN   BIT(6)
    #define RXCNTL_AFEN     BIT(5)
    #define RXCNTL_LBEN     BIT(4)
    #define RXCNTL_PAEN     BIT(3)
    #define RXCNTL_FCSREN   BIT(2)
    #define RXCNTL_PADSEN   BIT(1)

    #define RXCNTL_DEFAULT  (RXCNTL_FRAMM | \
                             RXCNTL_OFLOM | \
                             RXCNTL_CRCM | \
                             RXCNTL_LFERM | \
                             RXCNTL_MAXM | \
                             RXCNTL_RLCOLM | \
                             RXCNTL_RUNTM | \
                             RXCNTL_AFEN)

    DWORD rx_cntl_1;                        // 090
        // Maximum receive frame size register

    DWORD rx_en;                            // 094
        // Receive enable register
        //  bit 1: receive enable

    #define RXEN_ENABLE     BIT(0)

    DWORD rx_sta;                           // 098
        // Receive status register
        //  bit 31-23: reserved
        //  bit 22 (FRAM): frame alignment error
        //  bit 21 (OFOL): overflow error
        //  bit 20 (CRC): FCS error
        //  bit 19 (LFER): length error
        //  bit 18 (MAX): maximum length error
        //  bit 17 (RLCOL): receive late collision
        //  bit 16 (RUNT): runt receive
        //  bit 15-1: reserved
        //  bit 0: receive channel idle status
    
    #define RXSTA_FRAM      BIT(22)
    #define RXSTA_OFLO      BIT(21)
    #define RXSTA_CRC       BIT(20)
    #define RXSTA_LFER      BIT(19)
    #define RXSTA_MAX       BIT(18)
    #define RXSTA_RLCOL     BIT(17)
    #define RXSTA_RUNT      BIT(16)
    #define RXSTA_BUSY      BIT(0)

    DWORD bkoff_cntl;                       // 09c
        // Backoff control register (for HomePNA)
        //  bit 31-16: reserved
        //  bit 15-8: slot time, 127 for IEEE 802.3
        //  bit 7-0: random seed

    #define BKOFFCNTL_RSSHIFT   0
    #define BKOFFCNTL_STSHIFT   8

    #define BKOFFCNTL_DEFAULT   ((8 << BKOFFCNTL_RSSHIFT) | \
                                 (127 << BKOFFCNTL_STSHIFT))

    DWORD tx_def;                           // 0a0
        // Transmit deferral timing register
        //  bit 31-24: reserved
        //  bit 23-16 (TIFG): number of clocks for inter-frame gap
        //      when two-part deferral is disabled
        //  bit 15-8 (TIFG2): number of clocks for the second part
        //      inter-frame gap for two-part deferral
        //  bit 7-0 (TIFG1): number of clocks for the first part
        //      inter-frame gap for two-part deferral

    #define TXDEF_GSHIFT    16
    #define TXDEF_G2SHIFT   8
    #define TXDEF_G1SHIFT   0

    // Default values for IEEE 802.3
    #define TXDEF_DEFAULT   ((15 << TXDEF_G1SHIFT) | \
                             (7 << TXDEF_G2SHIFT) | \
                             (22 << TXDEF_GSHIFT))

    DWORD rx_def;                           // 0a4
        // Receive deferral register
        //  bit 7-0 (RIFG): number of clocks for inter-frame gap
        //      when receive deferral is enabled

    #define RXDEF_DEFAULT   0x16

    DWORD uni0;                             // 0a8
        // Lower 32-bits of the unicast address

    DWORD uni1;                             // 0ac
        // Higher 16-bits of the unicast address

    DWORD mult0;                            // 0b0
        // Lower 32-bits of the multicast address

    DWORD mult1;                            // 0b4
        // Higher 16-bits of the multicast address

    DWORD mult_mk0;                         // 0b8
        // Lower 32-bits of the multicast address mask

    DWORD mult_mk1;                         // 0bc
        // Higher 16-bits of the multicast address mask

    BYTE gap2[0x100 - 0xc0];

    DWORD tx_dadr;                          // 100
        // Transmit descriptor ring physical address

    DWORD rx_dadr;                          // 104
        // Receive descriptor ring physical address

    DWORD dlen;                             // 108
        // Descriptor ring length register
        //  bit 31-26: reserved
        //  bit 25-16 (RDLEN): receive descriptor block length (-1)
        //  bit 15-10: reserved
        //  bit 9-0 (TDLEN): transmit descriptor block length (-1)

    DWORD tx_poll;                          // 10c
        // Transmit descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (TPEN): transmit poll enable
        //  bit 15-0: transmit poll interval

    DWORD rx_poll;                          // 110
        // Receive descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (RPEN): receive poll enable
        //  bit 15-0: receive poll interval
        //      this is measured in 66MHz / 15ns clock cycles

    #define RXPOLL_EN           BIT(16)
    #define RXPOLL_FREQ_100MPS  100
    #define RXPOLL_FREQ_10MPS   1000

    DWORD tx_pcnt;                          // 114
        // Current transmit poll count

    DWORD rx_pcnt;                          // 118
        // Current receive poll count

    DWORD tx_cur_dadr;                      // 11c
        // Current transmit descriptor physical address

    DWORD rx_cur_dadr;                      // 120
        // Current receive descriptor physical address

    DWORD tx_cur_prd0;                      // 124
        // Current transmit physical address

    DWORD tx_cur_prd1;                      // 128
        // bit 31-16: current status of actively transmited frame
        // bit 15-0: current number of bytes remaining

    DWORD rx_cur_prd0;                      // 12c
        // Current receive physical address

    DWORD rx_cur_prd1;                      // 130
        // bit 31-16: current status of actively received frame
        // bit 15-0: current number of bytes remaining

    DWORD tx_nxt_dadr;                      // 134
        // Next transmit descriptor physical address

    DWORD rx_nxt_dadr;                      // 138
        // Next receive descriptor physical address

    DWORD tx_fifo_wm;                       // 13c
        // Transmit FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define TXFIFOWM_HWSHIFT    16
    #define TXFIFOWM_LWSHIFT    0

    #define TXFIFOWM_DEFAULT    ((0x10 << TXFIFOWM_LWSHIFT) | \
                                 (0x30 << TXFIFOWM_HWSHIFT))

    DWORD rx_fifo_wm;                       // 140
        // Receive FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define RXFIFOWM_HWSHIFT    16
    #define RXFIFOWM_LWSHIFT    0

    #define RXFIFOWM_DEFAULT    ((0x10 << RXFIFOWM_LWSHIFT) | \
                                 (0x30 << RXFIFOWM_HWSHIFT))
    DWORD mode;                             // 144
        // Mode register
        //  bit 4: buffer management reset
        //      need to be set for >= 3.2us before it's cleared
        //  bit 3: there is no active DMA transfer in progress
        //  bit 2: disable DMA transfer
        //  bit 1 (RXDM): receive demand
        //  bit 0 (TXDM): transmit demand

    #define MODE_RESET_BUFFERS  BIT(4)
    #define MODE_DMA_IDLE       BIT(3)
    #define MODE_DISABLE_DMA    BIT(2)
    #define MODE_RXDM           BIT(1)
    #define MODE_TXDM           BIT(0)

    BYTE gap3[0x180 - 0x148];

    DWORD mintr;                            // 180
        // MII interrupt register
        //  bit 7-5: reserved
        //  bit 4 (MPDI): MII PHY detect interrupt
        //  bit 3 (MAPI): MII auto-polling interrupt
        //  bit 2 (MCCI): MII command complete interrupt
        //  bit 1 (MCCII): MII command complete internal interrupt
        //  bit 0 (MREI): MII read error interrupt
    
    #define MINTR_MPDI  BIT(4)
    #define MINTR_MAPI  BIT(3)
    #define MINTR_MCCI  BIT(2)
    #define MINTR_MCCII BIT(1)
    #define MINTR_MREI  BIT(0)

    DWORD mintr_mk;                         // 184
        // MII interrupt mask register
        //  bit 7-5: reserved
        //  bit 4: MPDI mask - 1 to enable and 0 to disable
        //  bit 3: MAPI mask
        //  bit 2: MCCI mask
        //  bit 1: MCCII mask
        //  bit 0: MREI mask

    DWORD mii_cs;                           // 188
        // MII control and status register
        //  bit 31-29: reserved
        //  bit 28-24: PHY address
        //  bit 23-21: reserved
        //  bit 20 (APEN): auto-polling enable
        //  bit 19-16 (APTI): auto-polling time interval
        //  bit 15 (T4): 100BASE-T4
        //  bit 14 (XFD): 100BASE-X full duplex
        //  bit 13 (XHD): 100BASE-X half duplex
        //  bit 12 (10FD): 10Mb/s full-duplex
        //  bit 11 (10HD): 10Mb/s half-duplex
        //  bit 10 (ET2FD): 100BASE-T2 full-duplex
        //  bit 9 (T2HD): 100BASE-T2 half-duplex
        //  bit 8 (EXST): extended status
        //  bit 7: reserved
        //  bit 6 (MFPS): MF preamble suppression
        //  bit 5 (ANC): auto negotiation complete
        //  bit 4 (RF): remote fault
        //  bit 3 (ANA): auto-negotiation ability
        //  bit 2 (LS): link status
        //  bit 1 (JD): Jabber detect
        //  bit 0 (EC): extended capability
    
    #define MIICS_PADRSHIFT 24
    #define MIICS_APEN      BIT(20)
    #define MIICS_APSHIFT   16
    #define MIICS_T4        BIT(15)
    #define MIICS_XFD       BIT(14)
    #define MIICS_XHD       BIT(13)
    #define MIICS_10FD      BIT(12)
    #define MIICS_10HD      BIT(11)
    #define MIICS_ET2FD     BIT(10)
    #define MIICS_T2HD      BIT(9)
    #define MIICS_EXST      BIT(8)
    #define MIICS_MFPS      BIT(6)
    #define MIICS_ANC       BIT(5)
    #define MIICS_RF        BIT(4)
    #define MIICS_ANA       BIT(3)
    #define MIICS_LS        BIT(2)
    #define MIICS_JD        BIT(1)
    #define MIICS_EC        BIT(0)

    #define PHY_ADDR        1
    #define MIICS_DEFAULT   ((PHY_ADDR << MIICS_PADRSHIFT) | \
                             (4 << MIICS_APSHIFT) | \
                             MIICS_APEN)

    DWORD mii_tm;                           // 18c
        // MII clock timer register
        //  bit 15: MII timer status
        //  bit 14-9: reserved
        //  bit 8: MII timer enable
        //  bit 7-0: MII timer interval

    #define MIITM_BUSY      BIT(15)
    #define MIITM_EN        BIT(8)
    #define MIITM_TISHIFT   0

    #define MIITM_INTERVAL  5
    #define MIITM_DEFAULT   ((MIITM_INTERVAL << MIITM_TISHIFT) | MIITM_EN)
    #define PHYRW_TIMEOUT   ((64*2*2*400*MIITM_INTERVAL/1000)*4)

    DWORD mdio_adr;                         // 190
        // MDIO address register
        //  bit 15 (MDLK): MDIO lock
        //  bit 14-11: reserved
        //  bit 10 (MDRW): MDIO read/write
        //  bit 9-5 (PHYADR): physical address of the PHY to be accessed
        //  bit 4-0 (PHYREG): register address of the PHY to be accessed

    #define MDIOADR_LOCK        BIT(15)
    #define MDIOADR_WRITE       BIT(10)
    #define MDIOADR_PHYSHIFT    5
    #define MDIOADR_REGSHIFT    0

    DWORD mdio_data;                        // 194
        // MDIO data register
        //  bit 15-0 (PHYD): data for the last PHY read/write access

    BYTE gap4[0x200 - 0x198];

    DWORD pm_cntl;                          // 200
        // Power management control register

    struct {
        DWORD crc;
        DWORD mask0;
        DWORD mask1;
        DWORD mask2;
        DWORD mask3;
    } pmc_crc[5];
        // Pattern match CRC registers

    DWORD pmc_alias;
        // PCI power management register 0 alias

    DWORD pmcsr_alias;
        // PCI power management register 1 alias
} volatile *PNIC_CSR;

#define NicCsr ((PNIC_CSR) XPCICFG_NIC_MEMORY_REGISTER_BASE_0)
        

//
// NIC transmit and receive buffer descriptors
//
typedef struct _NicCmdBuffer {
    UINT_PTR phyaddrOffset;
    NicBufDesc* txstart;
    NicBufDesc* txend;
    NicBufDesc* txhead;
    NicBufDesc* txtail;
    NicBufDesc* rxstart;
    NicBufDesc* rxend;
    NicBufDesc* rxptr;
} NicCmdBuffer;

#define NicBufPhyAddr(nic, p) \
        ((UINT_PTR) (p) + (nic)->cmdbuf.phyaddrOffset)

//
// Extra overhead required by the NIC in the DMA receive buffer
// NOTE: We don't actually need any overhead for nVidia NIC.
// But we'll reserve 8 bytes of space after the Packet header (24 bytes)
// so that the received frame data starts on a 32-byte aligned address.
//
#define RECVPKT_OVERHEAD 8

//
// Allocate shared memory buffers for the NIC
//  BUGBUG!!! We have to used uncached memory for shared DMA buffers
//  because of a hardware snooping bug in nv2a.
//
#define NicFreeSharedMem(p) MmFreeContiguousMemory(p)
#ifndef DVTSNOOPBUG
#define NicAllocSharedMem(size) MmAllocateContiguousMemory(size)
#else // DVTSNOOPBUG
INLINE VOID* NicAllocSharedMem(UINT size) {
    VOID* p = MmAllocateContiguousMemoryEx(size, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);
    __asm wbinvd
}
#endif // DVTSNOOPBUG

//
// Disable and enable NIC interrupts
//
INLINE VOID NicDisableInterrupt() {
    NicCsr->intr_mk = 0;
}

INLINE VOID NicEnableInterrupt() {
    NicCsr->intr_mk = INTR_ALL;
}

#endif // !_XNIC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\dbgmon\dbgmon.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgmon.c

Abstract:

    Functions that are specific to the debug monitor stack

Revision History:

    08/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Debug monitor related global variables
//
PRIVATE IPRECEIVEPROC IpReceivePacketProc;
PRIVATE FREEPKTPROC FreePacketProc;
PRIVATE IfEnet *IfpEnetShared;

VOID
DmExFreePool(
    IN PVOID P
    );

//
// Pass the received frame up to the IP layer
//
VOID IPRECEIVEPACKET(Packet* pkt) {
    // If two stacks are present, we need to figure out
    // who's supposed to get this packet.
    if (IpReceivePacketProc) {
        IpHeader* iphdr;
        TcpHeader* tcphdr;
        UdpHeader* udphdr;
        UINT iphdrlen;

        // We assume the packet data length >= IPHDRLEN
        iphdr = GETPKTDATA(pkt, IpHeader);
        iphdrlen = GETIPHDRLEN(iphdr);
        tcphdr = (TcpHeader*) ((BYTE*) iphdr + iphdrlen);
        udphdr = (UdpHeader*) ((BYTE*) iphdr + iphdrlen);

        if (iphdrlen && 
            (iphdr->protocol == IPPROTOCOL_TCP &&
            iphdrlen+TCPHDRLEN <= pkt->datalen &&
            tcphdr->dstport == HTONS(DEBUGGER_PORT)) ||
            (iphdr->protocol == IPPROTOCOL_UDP &&
            iphdrlen+UDPHDRLEN <= pkt->datalen &&
            udphdr->dstport == HTONS(DEBUGGER_PORT))) {
            IpReceivePacket(pkt);
        } else {
            IpReceivePacketProc(pkt);
        }
    } else {
        IpReceivePacket(pkt);
    }
}


//
// Dispose of a packet after transmission
//
VOID COMPLETEPACKET(Packet* pkt, NTSTATUS status) {
    if (pkt->pktflags & PKTFLAG_DBGMON) {
        XnetCompletePacket(pkt, status);
    } else {
        // This packet came from the regular net stack.
        // We must use the callback function to dispose of it.
        if (pkt->completionCallback) {
            pkt->completionCallback(pkt, status);
        #ifdef DVTSNOOPBUG
        } else if (pkt->pktflags & PKTFLAG_UNCACHED) {
            XnetUncachedFreeProc(pkt);
        #endif
        } else if (!(pkt->pktflags & PKTFLAG_NETPOOL)) {
            // The packet memory came from the system pool
            DmExFreePool(pkt);
        } else if (FreePacketProc) {
            // The packet memory came from the private pool
            FreePacketProc(pkt);
        }
    }
}


//
// Cancel any pending transmissions that
// originated from the regular stack.
//
VOID DmCancelPendingPackets(PacketQueue* pktq) {
    PacketQueue tmpq;
    Packet* pkt;
    INT dropped = 0;
    
    PktQInit(&tmpq);
    while (!PktQIsEmpty(pktq)) {
        pkt = PktQRemoveHead(pktq);
        if (pkt->pktflags & PKTFLAG_DBGMON) {
            PktQInsertTail(&tmpq, pkt);
        } else {
            COMPLETEPACKET(pkt, NETERR_CANCELLED);
            dropped++;
        }
    }

    *pktq = tmpq;
    if (dropped) {
        WARNING_("Pending transmissions cancelled: %d", dropped);
    }
}


//
// Check to see if we should delete the enet interface
//
VOID IFENET_DELETE_CHECK(IfEnet* ifp) {
    ASSERT(ifp->refcount > 0);
    if (--ifp->refcount > 0) {
        //
        // Cancel any pending transmissions that
        // originated from the regular stack.
        //
        INT index;
        DmCancelPendingPackets(&ifp->sendq);
        NicWaitForXmitQEmpty(ifp);
        for (index=0; index < ARP_CACHE_SIZE; index++) {
            DmCancelPendingPackets(&ifp->arpCache[index].waitq);
        }

        IpReceivePacketProc = NULL;
        FreePacketProc = NULL;
    }
}


//
// Notify the debug monitor that regular netstack is starting up
//
PRIVATE IfEnet* EnetStartTitleStack(ENETINITPARAMS* initParams) {
    // NOTE: Wait until we acquired an address 
    // before starting the title stack.
    DhcpWaitForAddress((IfInfo*) IfpEnetShared);

    IpReceivePacketProc = initParams->IpReceiveProc;
    FreePacketProc = initParams->FreePktProc;
    initParams->UncachedAllocProc = XnetUncachedAllocProc;
    initParams->UncachedFreeProc = XnetUncachedFreeProc;
    IfpEnetShared->refcount++;
    return IfpEnetShared;
}



//
// Set the enet interface information in the process control block
//
VOID SET_DBGMON_ENETINFO(IfEnet* ifp) {
    IfpEnetShared = ifp;
    ASSERT(KeGetCurrentPrcb()->DmEnetFunc == 0);

    #pragma warning(disable:4054)
    KeGetCurrentPrcb()->DmEnetFunc = (VOID*) EnetStartTitleStack;
}


//
// Return the IP address of the Ethernet interface to the debugger
//
DWORD DmGetIpAddress(void) {
    return IfpEnetShared ? HTONL(IfpEnetShared->ipaddr) : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\enet\xnic.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nic.c

Abstract:

    XBox network controller "driver" code

Revision History:

    07/25/2000 davidx
        Created it.

--*/

#include "precomp.h"

#ifndef SILVER
#include <xboxp.h>

//
// NIC driver global variables
//
UINT NicXmitDescCount;
BYTE* NicPktPoolBase;
UINT_PTR NicPktPoolPhyAddrOffset;
KINTERRUPT NicIntrObject;
BOOL NicDontCopyReceivedPacket;

PRIVATE VOID NicInterruptDpc(PKDPC, PVOID, PVOID, PVOID);

// BUGBUG: temporary workaround for nv2a snooping bug
#ifdef DVTSNOOPBUG
BYTE NicTempRecvBuffer[DMAPKT_SIZE];
PRIVATE VOID NicTempRecvBufferPktCompletion(Packet* pkt, NTSTATUS status) {}
#endif

//
// NIC statistics
//
typedef struct _XNICSTATS {
    ULONG isrCount;
    ULONG dpcCount;
    ULONG txGoodFrames;
    ULONG rxGoodFrames;
    ULONG txStuckXmits;
    ULONG txUnderflowErrors;
    ULONG txLateCollisions;
    ULONG txLostCarriers;
    ULONG txDefers;
    ULONG txExcessiveDefers;
    ULONG txRetryErrors;
    ULONG rxFramingErrors;
    ULONG rxOverFlowErrors;
    ULONG rxCrcErrors;
    ULONG rxLengthErrors;
    ULONG rxMaxFrameErrors;
    ULONG rxLateCollisions;
    ULONG rxRunts;
    ULONG rxExtraByteErrors;
    ULONG rxMissedFrames;
    ULONG rxEndOfFrameErrors;
} XNICSTATS;
XNICSTATS NicStats;

//
// Lock and unlock the physical pages containing packet data
//
INLINE VOID NicLockPacketPages(Packet* pkt) {
    MmLockUnlockBufferPages(pkt->data, pkt->datalen, FALSE);
}

INLINE VOID NicUnlockPacketPages(Packet* pkt) {
    MmLockUnlockBufferPages(pkt->data, pkt->datalen, TRUE);
}

//
// Where the received Ethernet frame data starts
//
#define GetPktFrameData(pkt) (&(pkt)->buf[RECVPKT_OVERHEAD])

//
// Receive packet completion routine
//
PRIVATE VOID NicRecvBufferPktCompletion(Packet* pkt, NTSTATUS status) {
    pkt->nextpkt = NULL;
    pkt->data = GetPktFrameData(pkt);
    pkt->pktflags = PKTFLAG_DMA;
}


PRIVATE VOID
NicStopXmitRecv(
    IfEnet* nic,
    INT handleIntr
    )

/*++

Routine Description:

    Stop the controller from receiving and transmitting

Arguments:

    nic - Points to the NIC data structure
    handleIntr - Whether to handle the pending interrupts
        > 0 : disable and then handle interrupts
        = 0 : disable interrupts
        < 0 : leave interrupts alone

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    INT timeout;

    // Turn off the transmitter and receiver
    csr->rx_poll = 0;
    csr->rx_en = 0;
    csr->tx_en = 0;

    // Wait for a max of 5msec until both 
    // the transmitter and receiver are idle
    for (timeout=500; timeout--; ) {
        if (!(csr->rx_sta & RXSTA_BUSY) &&
            !(csr->tx_sta & TXSTA_BUSY))
            break;
        KeStallExecutionProcessor(10);
    }

    // Ensure there is no active DMA transfer in progress
    csr->mode = MODE_DISABLE_DMA;
    for (timeout=500; timeout--; ) {
        if (csr->mode & MODE_DMA_IDLE) break;
        KeStallExecutionProcessor(10);
    }
    csr->mode = 0;

    if (handleIntr >= 0) {
        // Disable interrupts and
        // handle any pending interrupts if requested
        NicDisableInterrupt();

        if (handleIntr > 0) {
            NicInterruptDpc(&nic->dpc, nic, nic, NULL);
        }
    }
}


//
// Start the transmitter and receiver
//
INLINE VOID NicStartXmitRecv(PNIC_CSR csr, DWORD rxpoll_freq) {
    csr->rx_poll = RXPOLL_EN | rxpoll_freq;
    csr->tx_en = TXEN_ENABLE;
    csr->rx_en = RXEN_ENABLE;
    csr->mode = MODE_TXDM;
}

PRIVATE VOID
NicProcessRecvInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process receive interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    NicBufDesc* bufdesc = nic->cmdbuf.rxptr;
    Packet* pkt;
    DWORD flags_count;

    // Looping until we ran into a receive descriptor
    // that's still owned by the controller
    while (!((flags_count = bufdesc->flags_count) & RXDESC_OWN)) {
        pkt = PktQRemoveHead(&nic->recvq);
        if (flags_count & RXDESC_REND) {
            //
            // NOTE: Workaround for hardware bu